CE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);

        }

        // can't handle any other kinds of different fourcc or RGB overlays
        NvReleaseSemaphore(pDriverData);
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 90");
        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    if (caps & DDSCAPS_MODEX) {

        NvReleaseSemaphore(pDriverData);
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Mode X requested" );
        lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDMODE;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    // Don't allow 3D devices in 8bpp (except for primary surface access, fixes Jedi Knight)
    if ((caps & DDSCAPS_3DDEVICE) && (!(caps & DDSCAPS_PRIMARYSURFACE))) {

        if (dwModeBPP == 1) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 100");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

    }

    // Although the DD API passes DWORD height and width, the internal structures
    // of DDRAW only hold 16 bits.  So we refuse all surfaces that exceed that limit.
    if ((lpDDSurface->dwFlags & DDSD_HEIGHT) && (lpDDSurface->dwHeight > 0xFFFF))
    {
        NvReleaseSemaphore(pDriverData);
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - height too big 105");
        lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    if ((lpDDSurface->dwFlags & DDSD_WIDTH) && (lpDDSurface->dwWidth > 0xFFFF))
    {
        NvReleaseSemaphore(pDriverData);
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - width too big 105");
        lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    if (caps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Frontbuffer requested" );

        if (caps & DDSCAPS_OVERLAY) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 110");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        if (caps & DDSCAPS_FLIP) {
            if (lpDDSurface->dwHeight > (unsigned long)dwModeHeight) {
                if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - height too big 10");
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                else {
                    lpDDSurface->dwHeight = (unsigned long)dwModeHeight;
                }

            }
            if (lpDDSurface->dwWidth > (unsigned long)dwModeWidth) {
                if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - width too big 10");
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                else {
                    lpDDSurface->dwWidth = (unsigned long)dwModeWidth;
                }
            }
        }
        NvReleaseSemaphore(pDriverData);
        lpCanCreateSurface->ddRVal = DD_OK;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    else if (caps & DDSCAPS_BACKBUFFER) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Backbuffer requested" );
        if (caps & DDSCAPS_OVERLAY) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 120");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        if (caps & DDSCAPS_FLIP) {
            if (lpDDSurface->dwHeight > (unsigned long)dwModeHeight) {
                if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - height too big 20");
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                else {
                    lpDDSurface->dwHeight = (unsigned long)dwModeHeight;
                }

            }
            if (lpDDSurface->dwWidth > (unsigned long)dwModeWidth) {
                if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - width too big 20");
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                else {
                    lpDDSurface->dwWidth = (unsigned long)dwModeWidth;
                }
            }
        }
        NvReleaseSemaphore(pDriverData);
        lpCanCreateSurface->ddRVal = DD_OK;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    else if (caps & DDSCAPS_OFFSCREENPLAIN) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Can create offscreen requested" );

        if (caps & DDSCAPS_VIDEOMEMORY) {
            if (caps & DDSCAPS_OVERLAY) {
                NvReleaseSemaphore(pDriverData);
                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 140");
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                DDENDTICK(SURF4_CANCREATESURFACE);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }

            if (caps & DDSCAPS_FLIP) {
                if (lpDDSurface->dwHeight > (unsigned long)dwModeHeight) {
                    if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                        NvReleaseSemaphore(pDriverData);
                        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - height too big 30");
                        lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    else {
                        lpDDSurface->dwHeight = (unsigned long)dwModeHeight;
                    }
                }
                if (lpDDSurface->dwWidth > (unsigned long)dwModeWidth) {
                    if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                        NvReleaseSemaphore(pDriverData);
                        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - width too big 30");
                        lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    else {
                        lpDDSurface->dwWidth = (unsigned long)dwModeWidth;
                    }

                }
            }
        }
        NvReleaseSemaphore(pDriverData);
        lpCanCreateSurface->ddRVal = DD_OK;
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Can create offscreen granted" );
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    else if (caps & (DDSCAPS_FLIP | DDSCAPS_VIDEOMEMORY | DDSCAPS_ZBUFFER)) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Can create flipping surface requested" );

        if (caps & DDSCAPS_OVERLAY) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 150");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
        if (caps & DDSCAPS_ZBUFFER) {
            if ((dwModeBPP != 2) && (dwModeBPP != 4)) {
                NvReleaseSemaphore(pDriverData);
                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 160");
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                DDENDTICK(SURF4_CANCREATESURFACE);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }
        NvReleaseSemaphore(pDriverData);
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Can create flipping surface available" );
        lpCanCreateSurface->ddRVal = DD_OK;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    else if (caps & DDSCAPS_SYSTEMMEMORY) {

        NvReleaseSemaphore(pDriverData);
        lpCanCreateSurface->ddRVal = DD_OK;
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Can create system memory requested" );
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    NvReleaseSemaphore(pDriverData);
    DDENDTICK(SURF4_CANCREATESURFACE);
    dbgTracePop();
    return (DDHAL_DRIVER_NOTHANDLED);

} // CanCreateSurface32

//---------------------------------------------------------------------------

// DestroySurface32

DWORD __stdcall DestroySurface32 (LPDDHAL_DESTROYSURFACEDATA lpDestroySurface)
{
    dbgTracePush ("DestroySurface32");

    if (lpDestroySurface->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        //silly hack for screwed up kernel calls
        DWORD dwRetVal;
        dwRetVal = D3DDestroyExecuteBuffer32(lpDestroySurface);
        dbgTracePop();
        return dwRetVal;
    }

    DDSTARTTICK(SURF4_DESTROYSURFACE);
    nvSetDriverDataPtrFromDDGbl (lpDestroySurface->lpDD);

    LPDDRAWI_DIRECTDRAW_GBL   pDDGbl  = lpDestroySurface->lpDD;
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl = lpDestroySurface->lpDDSurface;
    LPDDRAWI_DDRAWSURFACE_GBL pDDSGbl = pDDSLcl->lpGbl;

    DWORD dwIndex;


#ifdef  NEW_FRONT_RENDER
    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_BACKBUFFER)
    {
        pDDSLcl->lpGbl->fpVidMem = BackVidMem;
        SET_PNVOBJ(pDDSLcl, pBackNvObj);
    }
#endif  //NEW_FRONT_RENDER
    if (global.dwDXRuntimeVersion < 0x700) {
        DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "DestroySurface: pDDGbl = %08x, pDDSLcl = %08x", pDDGbl, pDDSLcl);
    } else {
        DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "DestroySurface: pDDGbl = %08x, pDDSLcl = %08x, handle = %02x",
            pDDGbl, pDDSLcl, pDDSLcl->lpSurfMore->dwSurfaceHandle);
    }

    // textures do not want to wait for idle. check for them here
    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {
        // Call the D3D driver to destroy the texture surface.
        nvTextureDestroySurface (lpDestroySurface, pDDSLcl);
        NvReleaseSemaphore(pDriverData);
        DDENDTICK(SURF4_DESTROYSURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }


    if(!pDriverData->vpp.dwOverlaySurfaces &&
        (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) &&
        (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE)) {
        //clear FSDOSSSTATUS_RECOVERYNEEDED_DDRAW flag if not overlay surface exists
        pDriverData->dwFullScreenDOSStatus &=  ~FSDOSSTATUS_RECOVERYNEEDED_DDRAW;

    }


    if ((pDriverData->lpProcessInfoHead) && (getDC()->nvPusher.isValid())) {
        WaitForIdle(TRUE, TRUE);
    }

    // clear ring0 flipping flag to make sure new surfaces aren't tagged for ring0 flipping
    if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC))
    {

        if((pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) &&
           (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE)) {
            //clear FSDOSSSTATUS_RECOVERYNEEDED_D3D flag
            nvD3DRecover();
        }
        // Should check if YUV surface is an active VPE surface and make sure
        // to stop VPE hardware before destroying VPE surface somewhere in YUV
        // surface code in this function.

        if (VppIsOverlayActive(&pDriverData->vpp))
        {
            NvNotification *pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;
            LPPROCESSINFO lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());

            if (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
                // make sure we sync with other channels before writing put
                getDC()->nvPusher.setSyncChannelFlag();

                pDriverData->dwRingZeroMutex = TRUE;

                if (getDC()->nvPusher.isValid()) {
                    Sleep(VPP_TIMEOUT_TIME * 3);
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                    nvPushData(1, NV_VPP_OVERLAY_IID);
                    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_STOP_OVERLAY(0) | 0x80000);
                    nvPushData(3, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[0]
                    nvPushData(4, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[1]
                    nvPusherAdjust(5);
                    nvPusherStart(TRUE);
                }
            }

            pDriverData->dwRingZeroMutex = FALSE;
            pDriverData->dDrawSpareSubchannelObject = 0;

            // Only do recover if a DOS full screen switch has completed.
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
                if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
                nvDDrawRecover();
                }
            }
        }

#ifdef NVPE
        NVPCleanUp(pDriverData, pDDGbl);
#else
        pDriverData->bRing0FlippingFlag = FALSE;
#endif // NVPE

        pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL = NULL;

        if (pDriverData->vpp.dwOverlayFSNumSurfaces){
            VppDestroyFSMirror(&(pDriverData->vpp));
#ifdef VPEFSMIRROR
            if (pDriverData->nvpeState.bFsMirrorEnabled) {
                NVPFsMirrorDisable(pDriverData);
            }
#endif
        }

        //destroy overlay only when it is active and for the last overly
        //surface.
        if (VppIsOverlayActive(&pDriverData->vpp)
            && (pDriverData->vpp.dwOverlaySurfaces <= 1)){
            VppDestroyOverlay(&(pDriverData->vpp));
        }
    }

    // if there's an NvObject associated with this DDSLcl, remove its entry from
    // our list of handles. (this is because assinine apps will later reference
    // handles to surfaces they've previously destroyed)
    CNvObject *pObj = GET_PNVOBJ (pDDSLcl);

    if ((((DWORD)pObj) & MASK_FLOATING_CONTEXT_DMA_ID) == FLOATING_CONTEXT_DMA_ID) {
        // DX7 doesn't always call CreateSurfaceEx, in these cases we may be storing
        // a floating system memory DMA context at this location
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, ((DWORD)pObj));
        SET_PNVOBJ(pDDSLcl, NULL);
        pObj = NULL;
    }

    // Don't exit early for Primary surfaces on surfaces that aren't really Primary.
    // In Win2K fpVidMem and GET_PRIMARY_ADDR() may both be zero if an Overlay
    // or other FourCC surface create fails.
    if (!((pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
        (pDDSGbl->ddpfSurface.dwFlags & DDPF_FOURCC))) {

        if (pDDSGbl->fpVidMem == GET_PRIMARY_ADDR()) {
#ifdef WINNT
            ppdev->bD3DappIsRunning = FALSE;
#endif
            lpDestroySurface->ddRVal = DD_OK;
           // Need to tell NT displaydriver that we destroyed a PRIMARY surface
            NV_OGLDDRAWSURFACEDESTROYED(ppdev);
            goto Handled_Exit;
        }
    }

    // Mode switches might occur without warning
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
    {
        if (!nvEnable32 (lpDestroySurface->lpDD)) {
            lpDestroySurface->ddRVal = DDERR_OUTOFMEMORY;
            goto Handled_Exit;
        }
    }

    if ((pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
        (pDDSGbl->ddpfSurface.dwFlags & DDPF_FOURCC)) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "  FOURCC surface" );

        // destroy shared system workspace
        if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC) &&
            (pDriverData->vpp.dwOverlaySurfaces <= 1))
        {
            // tells the ring0 code to not run any more!
            pDriverData->vpp.regRing0ColourCtlInterlockFlags = pDriverData->vpp.regRing0ColourCtlInterlockFlags & 0xFFFFFFFE;
            {
                DWORD aCount = 16;
                while((pDriverData->vpp.regRing0ColourCtlInterlockFlags & 0x02) && aCount-- ) {
                    Sleep(1);  // waits 1 millisecond
                }
            }
            if (pDriverData->vpp.fpOverlayShadow)
            {
                NvRmFree(pDriverData->dwRootHandle, pDriverData->vpp.hChannel,
                         NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW);
                FreeIPM((void*)pDriverData->vpp.fpOverlayShadow);
                pDriverData->vpp.fpOverlayShadow = 0;
            }

            pDriverData->dDrawSpareSubchannelObject = 0;
        }

        switch ( pDDSLcl->lpGbl->ddpfSurface.dwFourCC ) {
            case FOURCC_RGB0:
            case FOURCC_RAW8:
                if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                    if (pDDSGbl->fpVidMem > 0) {
                        NVHEAP_FREE (pDDSGbl->fpVidMem);
                        pDDSGbl->fpVidMem = 0;
                        if (pDriverData->DDrawVideoSurfaceCount > 0)
                            pDriverData->DDrawVideoSurfaceCount--;
                    }
                }
                else {
                    HGLOBAL hMem = (HGLOBAL)pDDSGbl->dwReserved1;
                    GlobalFree(hMem);
                    pDDSGbl->dwReserved1 = 0;
                }
                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;

            case FOURCC_NVMC: // Our Win9x motion comp control surface, only on NV10 or greater
                if (pDDSGbl->fpVidMem > 0) {
                    NVHEAP_FREE (pDDSGbl->fpVidMem);
                    pDDSGbl->fpVidMem = 0;
                    if (pDriverData->DDrawVideoSurfaceCount > 0)
                        pDriverData->DDrawVideoSurfaceCount--;
                }

                pDDSGbl->dwReserved1 = 0;

                pDriverData->dwMCNVMCSurface = 0;

                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;

            case FOURCC_NVDS: // Our Win9x Direct Show dummy motion comp surface, only on NV10 or greater
                if ((pDriverData->dwMCNVDSSurfaceBase != 0) && (pDDSGbl->fpVidMem > 0)) {
                    pDriverData->dwMCNVDSSurfaceBase = 0;
                    NVHEAP_FREE (pDDSGbl->fpVidMem);
                }

                pDDSGbl->fpVidMem = 0;

                if (pDriverData->DDrawVideoSurfaceCount > 0)
                    pDriverData->DDrawVideoSurfaceCount--;

                pDDSGbl->dwReserved1 = 0;

                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;

            case FOURCC_NVSP: // a subpicture surface (overlay)
                if (pDDSGbl->fpVidMem > 0) {
                    NVHEAP_FREE (pDDSGbl->fpVidMem);
                    pDDSGbl->fpVidMem = 0;
                    if (pDriverData->DDrawVideoSurfaceCount > 0)
                        pDriverData->DDrawVideoSurfaceCount--;
                }

                pDDSGbl->dwReserved1 = 0;

                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;

            case FOURCC_NVID: // These surfaces can exist only on NV10 or greater
                // Send a sync to make sure we are done with it

                if (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
                    // Let D3D code know that we have touched NV
                    pDriverData->TwoDRenderingOccurred = 1;

                    getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

                    // Make sure celsius class isn't currently referencing an IDCT context Dma
                    if (getDC()->nvPusher.isValid()) {
                        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                          NV097_SET_CONTEXT_DMA_B | 0x40000);
                            nvPushData(1, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // Reset to what D3D expects to see
                            nvPusherAdjust(2);
                            nvPusherStart(TRUE);
                        } else {
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                          NV056_SET_CONTEXT_DMA_B | 0x40000);
                            nvPushData(1, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // Reset to what D3D expects to see
                            nvPusherAdjust(2);
                            nvPusherStart(TRUE);
                        }
                        pDriverData->dwMostRecentHWUser = MODULE_ID_DDRAW;
                    }
                    // wait for HW to catch up
                    getDC()->pRefCount->wait (CReferenceCount::WAIT_PREEMPTIVE);
                }

                // Clear current IDCT context Dma
                pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;

                for (dwIndex=0; dwIndex<4; dwIndex++) {
                    if (pDDSGbl->fpVidMem == pDriverData->dwMCIDCTAGPSurfaceBase[dwIndex]) {
                        pDriverData->dwMCIDCTAGPSurfaceBase[dwIndex] = 0;
                        if (pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] != 0) {
                            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                                     NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex);
                            pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] = 0;
                            pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;
                        }
                    }
                }

                // First check if surface is in video memory
                if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM) {
                    if (pDDSGbl->fpVidMem > 0) {
                        // free memory using initial unadjusted pointer
                        NVHEAP_FREE (pDDSGbl->dwReserved1);
                        pDDSGbl->fpVidMem = 0;
                        if (pDriverData->DDrawVideoSurfaceCount > 0)
                            pDriverData->DDrawVideoSurfaceCount--;
                    }
                } else {
                    // this should never happen
                    nvAssert(0);
                }

                pDDSGbl->dwReserved1 = 0;

                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;

            case FOURCC_IF09:
            case FOURCC_YVU9:
            case FOURCC_IV32:
            case FOURCC_IV31:
            case FOURCC_YUY2:
            case FOURCC_YUNV:
            case FOURCC_UYVY:
            case FOURCC_UYNV:
            case FOURCC_NV12:
            case FOURCC_YV12:
                if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                    DWORD dwIndex = 0;
                    if (pDriverData->vpp.dwOverlaySurfaces > 0)
                        pDriverData->vpp.dwOverlaySurfaces--;
                    if (pDriverData->vpp.dwOverlaySurfaces == 0) {
                        pDriverData->vpp.dwOverlayOwner = 0;
                        for (DWORD i = 0; i < NV_VPP_MAX_EXTRA_SURFACES; i++) {
                            pDriverData->vpp.extraOverlayOffset[i] = 0;
                        }
                        pDriverData->vpp.extraNumSurfaces = 0;
                        pDriverData->bMCOverlaySrcIsSingleField1080i = FALSE;
                        pDriverData->bMCHorizontallyDownscale1080i = FALSE;
                    }
                    while (dwIndex < NV_VPP_MAX_OVERLAY_SURFACES) {
                        if ((DWORD)pDDSLcl == pDriverData->vpp.dwOverlaySurfaceLCL[dwIndex]) {
                            pDriverData->vpp.dwOverlaySurfaceLCL[dwIndex] = 0;
                        }
                        dwIndex++;
                    }
                }

                if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) == 0)) {
                    if (pDDSGbl->fpVidMem > 0) {
                        if (pDDSGbl->fpVidMem + pDDSGbl->dwReserved1 - pDriverData->BaseAddress ==
                            pDriverData->vpp.extraOverlayOffset[0]) {
                            for (DWORD i = 0; i < NV_VPP_MAX_EXTRA_SURFACES; i++) {
                                pDriverData->vpp.extraOverlayOffset[i] = 0;
                            }
                            pDriverData->vpp.extraNumSurfaces = 0;
                        }
                        NVHEAP_FREE (pDDSGbl->fpVidMem);
                        pDDSGbl->fpVidMem = 0;
                        if (pDriverData->DDrawVideoSurfaceCount > 0)
                            pDriverData->DDrawVideoSurfaceCount--;
                    }
                }
                else {
                    HGLOBAL hMem = (HGLOBAL)pDDSGbl->dwReserved1;
                    GlobalFree(hMem);
                }
                pDDSGbl->dwReserved1 = 0;
                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;
            case FOURCC_420i:
                if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                    DWORD dwIndex = 0;
                    while (dwIndex < NV_VPP_MAX_OVERLAY_SURFACES) {
                        if ((DWORD)pDDSLcl == pDriverData->vpp.dwOverlaySurfaceLCL[dwIndex]) {
                            pDriverData->vpp.dwOverlaySurfaceLCL[dwIndex] = 0;
                            if (pDriverData->vpp.dwOverlaySurfaces > 0)
                                pDriverData->vpp.dwOverlaySurfaces--;
                            if (pDriverData->vpp.dwOverlaySurfaces == 0) {
                                pDriverData->vpp.dwOverlayOwner = 0;
                            }
                        }
                        dwIndex++;
                    }
                }

                if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                    (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
#ifdef OLD_BLIT_CODE
                    if (pDDSGbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]) {

                        if (pDriverData->NvYUY2Surface0Mem > 0) {
                            NVHEAP_FREE (pDriverData->NvYUY2Surface0Mem);
                            pDriverData->NvYUY2Surface0Mem = 0;
                            if (pDriverData->DDrawVideoSurfaceCount > 0)
                                pDriverData->DDrawVideoSurfaceCount--;
                        }

                        if (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) &&
                            (getDV()->nvPusher.isValid())) {
                            // make sure we sync with other channels before writing put
                            getDC()->nvPusher.setSyncChannelFlag();
                        }

                        if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {  // Mode switches might occur without warning
                            NvReleaseSemaphore(pDriverData);
                            lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                            DDENDTICK(SURF4_DESTROYSURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }

                        // If AGP memory then send a sync rectangle to make sure we are done with it
                        if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) &&
                           !(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {

                            NvNotification *pDmaSyncNotifier = (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

                            // Let D3D code know that we have touched NV
                            pDriverData->TwoDRenderingOccurred = 1;

                            // MUST wait for any pending notification to prevent possible loss of notification serialization
                            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;
#ifdef CAPTURE
                            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                                CAPTURE_SYNC3 sync;
                                sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                                sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                                sync.dwExtensionID        = CAPTURE_XID_SYNC3;
                                sync.dwType               = CAPTURE_SYNC_TYPE_NOTIFIER;
                                sync.dwCtxDMAHandle       = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
                                sync.dwOffset             = 0;
                                sync.dwValue              = 0;
                                captureLog (&sync,sizeof(sync));
                            }
#endif // CAPTURE
                            pDmaSyncNotifier->status = NV_IN_PROGRESS;

                            nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
                            nvPushData (1,0);
                            nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
                            nvPushData (3,0);
                            nvPusherAdjust (4);
                            nvPusherStart  (TRUE);

                            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification
#ifdef CAPTURE
                            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                                CAPTURE_SYNC3 sync;
                                sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                                sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                                sync.dwExtensionID        = CAPTURE_XID_SYNC3;
                                sync.dwType               = CAPTURE_SYNC_TYPE_NOTIFIER;
                                sync.dwCtxDMAHandle       = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
                                sync.dwOffset             = 0;
                                sync.dwValue              = 0;
                                captureLog (&sync,sizeof(sync));
                            }
#endif // CAPTURE
                        }

#ifdef OLD_BLIT_CODE
                        if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                             pDriverData->BaseAddress) || // If system memory
                            (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                             (unsigned long)pDriverData->VideoHeapEnd)) {
                            NvNotification *pDmaSyncNotifier =
                            (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

                            if (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
                                // Let D3D code know that we have touched NV
                                pDriverData->TwoDRenderingOccurred = 1;

                                // MUST wait for any pending notification to prevent possible loss of notification serialization
                                while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                                pDriverData->dDrawSpareSubchannelObject = 0;

                                pDmaSyncNotifier->status = NV_IN_PROGRESS;

                                // Trash spare subchannel
                                nvPushData (0,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                                nvPushData (1,NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
                                nvPushData (2,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                         MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000);
                                nvPushData (3,NV1_NULL_OBJECT);
                                nvPushData (4,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                         MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000);
                                nvPushData (5,NV1_NULL_OBJECT);
                                nvPushData (6,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                                nvPushData (7,NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
                                nvPushData (8,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                         MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000);
                                nvPushData (9,NV1_NULL_OBJECT);
                                nvPushData (10,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                          MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000);
                                nvPushData (11,NV1_NULL_OBJECT);
                                nvPushData (12,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                                nvPushData (13,NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
                                nvPushData (14,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                          MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000);
                                nvPushData (15,NV1_NULL_OBJECT);
                                nvPushData (16,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                          MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000);
                                nvPushData (17,NV1_NULL_OBJECT);
                                nvPushData (18,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                                nvPushData (19,NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
                                nvPushData (20,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                          MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000);
                                nvPushData (21,NV1_NULL_OBJECT);
                                nvPushData (22,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                          MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000);
                                nvPushData (23,NV1_NULL_OBJECT);
                                nvPushData (24,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                                          RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
                                nvPushData (25,0);
                                nvPushData (26,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                                          RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
                                nvPushData (27,0);

                                nvPusherAdjust (28);
                                nvPusherStart  (TRUE);

                                while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification
                            }

                            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                                     NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
                        }
#endif  // OLD_BLIT_CODE

                        // If in AGP memory then deallocate it from there
                        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
                            // this should never happen
                            nvAssert(0);
                        }
                        else {
#ifdef OLD_BLIT_CODE
                            if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                                 pDriverData->BaseAddress) || // If system memory
                                (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                                 (unsigned long)pDriverData->VideoHeapEnd)) {
                                GlobalFree((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                            }
                            else {
#endif
                                NVHEAP_FREE (pDDSGbl->fpVidMem);
                                if (pDriverData->DDrawVideoSurfaceCount > 0)
                                    pDriverData->DDrawVideoSurfaceCount--;
#ifdef OLD_BLIT_CODE
                            }
#endif
                        }

#ifdef OLD_BLIT_CODE
                        pDriverData->NvFloatingMem2MemFormatMemoryHandle = 0;

                        pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
                        pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                        pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                        pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] = 0;
#endif  // OLD_BLIT_CODE
                    }
                    else {
#ifdef OLD_BLIT_CODE
                        if (pDDSGbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1]) {
                            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                            if (pDriverData->NvYUY2Surface1Mem > 0) {
                                NVHEAP_FREE (pDriverData->NvYUY2Surface1Mem);
                                pDriverData->NvYUY2Surface1Mem = 0;
                                if (pDriverData->DDrawVideoSurfaceCount > 0)
                                    pDriverData->DDrawVideoSurfaceCount--;
                            }
                        }
                        else if (pDDSGbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2]) {
                            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                            if (pDriverData->NvYUY2Surface2Mem > 0) {
                                NVHEAP_FREE (pDriverData->NvYUY2Surface2Mem);
                                pDriverData->NvYUY2Surface2Mem = 0;
                                if (pDriverData->DDrawVideoSurfaceCount > 0)
                                    pDriverData->DDrawVideoSurfaceCount--;
                            }
                        }
                        else {
                            if (pDriverData->NvYUY2Surface3Mem > 0) {
                                NVHEAP_FREE (pDriverData->NvYUY2Surface3Mem);
                                pDriverData->NvYUY2Surface3Mem = 0;
                                if (pDriverData->DDrawVideoSurfaceCount > 0)
                                    pDriverData->DDrawVideoSurfaceCount--;
                            }
                        }
#endif  // OLD_BLIT_CODE
                    }
#endif  // OLD_BLIT_CODE
                    pDDSGbl->fpVidMem = 0;
                }
                else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                    if (pDDSGbl->fpVidMem > 0) {
                        NVHEAP_FREE (pDDSGbl->fpVidMem);
                        pDDSGbl->fpVidMem = 0;
                        if (pDriverData->DDrawVideoSurfaceCount > 0)
                            pDriverData->DDrawVideoSurfaceCount--;
                    }
                }
                else {
                    HGLOBAL hMem = (HGLOBAL)pDDSGbl->dwReserved1;
                    GlobalFree(hMem);
                }
                NvReleaseSemaphore(pDriverData);
                pDDSGbl->dwReserved1 = 0;
                lpDestroySurface->ddRVal = DD_OK;
                DDENDTICK(SURF4_DESTROYSURFACE);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
                break;
        }
    }

    else if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
        // surfaces in this branch must have an NVObject
        if (global.dwDXRuntimeVersion < 0x0700) {
            // make sure that DX6 render targets still point at the right memory
            CSimpleSurface* pSurf = pObj ? pObj->getSimpleSurface() : NULL;
            if (pSurf) {
                // undo damage caused by nvRefreshSurfaceInfo
                pSurf->setAddress(pDDSGbl->fpVidMem);
            }
        }

        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER){
            //walk the pcontext lists to remove any dangling references to this zbuffer
            //our nvCelsiusAACreate will touch this pointer later and cause problems.
            //ideally zbuffer/destroys are not frequent so this should be low impact.
            PNVD3DCONTEXT pContext;
            pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
            while(pContext){
                if(pObj && pContext->pZetaBuffer == pObj->getSimpleSurface()) pContext->pZetaBuffer = NULL;
                // update cached pointer
                pContext->kelvinAA.UpdateZBuffer();
                pContext = pContext->pContextNext;
            }
        }

        // the surface, surface object and NVObject will all be deallocated when the NVObject is released below
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Offscreen deallocated" );
        pDDSGbl->fpVidMem = 0;
        pDDSGbl->dwReserved1 = 0;
        lpDestroySurface->ddRVal = DD_OK;
        goto Handled_Exit;
    }

    else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    System memory deallocated" );
        HGLOBAL hMem = (HGLOBAL)pDDSGbl->dwReserved1;
        GlobalFree(hMem);
        pDDSGbl->dwReserved1 = 0;
        lpDestroySurface->ddRVal = DD_OK;
        goto Handled_Exit;
    }

    NvReleaseSemaphore(pDriverData);
    DDENDTICK(SURF4_DESTROYSURFACE);
    dbgTracePop();
    return (DDHAL_DRIVER_NOTHANDLED);

Handled_Exit:
    if (pObj) {
        nvClearObjectListEntry (pObj, &global.pNvSurfaceLists);
#ifndef WINNT
        if (pObj == (CNvObject*)pDXShare->pNvPrimarySurf)
        {
            DPF("DestroySurface32 called for primary surface, freeing back buffers instead");
            // normally we don't get calls to free the primary surface on Win9X, but sometimes the runtime
            // gets mixed up and sends us a destroy call for the primary surface but not for the back buffer.
            // in this case we should release the backbuffer to prevent a memory leak
            pObj = pObj->getAttachedA();
            if (pObj) {
                pObj->release();
            }
        } else {
            pObj->release();
        }
#else
        pObj->release();
#endif
        // clear the dwReseved field (pointer to the NvObject). on NT we must check for this when
        // traversing the surface chain in CreateSurfaceEx and ignore surfaces with deleted NvObjects
        // this corresponds with the explicit attachment concept under win9x
        SET_PNVOBJ(pDDSLcl, NULL);
    }

    NvReleaseSemaphore(pDriverData);
    DDENDTICK(SURF4_DESTROYSURFACE);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
} // DestroySurface32

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\ddVideo.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1997, 1999, 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       ddVideo.cpp
 *  Content:    NVidia Direct Video/Active Movie Direct Draw support
 *              32 bit DirectDraw part.
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#if 0
DWORD __stdcall HandleVideoPortOverlayUpdate(LPDDHAL_UPDATEOVERLAYDATA lpUOData);
#endif

extern BOOL ResetTwinViewState(GLOBALDATA *pDriverData);


// --------------------------------------------------------------------------------------
// TimerProc
//      Timer callback
void CALLBACK TimerProc(HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl = (LPDDRAWI_DDRAWSURFACE_LCL) pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL;
    LPDDRAWI_DDRAWSURFACE_GBL lpSurfGbl;

    if (lpSurfLcl == NULL) {
        return;
    }

    if ((pDriverData->dwTVTunerFlipCount > 15) ||
        (pDriverData->regTVTunerHack == NV4_REG_VBMM_SINGLEOVL) ||
        (pDriverData->regTVTunerHack == NV4_REG_VBMM_FORCE)) {
        DWORD dwVPPFlags;

        lpSurfGbl = lpSurfLcl->lpGbl;
        if (lpSurfGbl == NULL) {
            return;
        }

        dwVPPFlags = VPP_ALL | VPP_WAIT;

        if (lpSurfLcl->lpSurfMore) {
            if (lpSurfLcl->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED) {
                dwVPPFlags |= VPP_INTERLEAVED | VPP_ODD;
            }
            if (lpSurfLcl->lpSurfMore->dwOverlayFlags & DDOVER_BOB) {
                dwVPPFlags |= VPP_BOB | VPP_ODD;
            }
        }
        if (lpSurfLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {
            dwVPPFlags |= VPP_VIDEOPORT;
        }

        VppDoFlip(&(pDriverData->vpp),
                      lpSurfGbl->fpVidMem - pDriverData->BaseAddress,
                      lpSurfGbl->lPitch,
                      lpSurfGbl->wWidth,
                      lpSurfGbl->wHeight,
                      lpSurfGbl->ddpfSurface.dwFourCC,
                      dwVPPFlags);

        pDriverData->dwTVTunerFlipCount = 16;
    } else {
        pDriverData->dwTVTunerFlipCount++;
    }
}

// --------------------------------------------------------------------------------------
// TVTunerTimerHack
//      Hack used for bus mastering TV tuners which never call flip.  When detected,
//      install a timer to autoflip
#define TV_TUNER_HACK_FRAME_PERIOD 33

BOOL __stdcall TVTunerTimerHack()
{
#ifdef WINNT
    return FALSE;
#else   // Win9x
    if ((pDriverData->dwTVTunerTimer != NULL) ||
        (pDriverData->regTVTunerHack == NV4_REG_VBMM_NOHACK) ||
        (pDriverData->regTVTunerHack == NV4_REG_VBMM_DETECT && pDriverData->vpp.dwOverlaySurfaces != 1) ||
        (pDriverData->regTVTunerHack == NV4_REG_VBMM_SINGLEOVL && pDriverData->vpp.dwOverlaySurfaces != 1)){
        return FALSE;
    }

    pDriverData->dwTVTunerFlipCount = 0;
    pDriverData->dwTVTunerTimer = SetTimer(NULL, NULL, TV_TUNER_HACK_FRAME_PERIOD, TimerProc);
    return TRUE;
#endif  // WINNT
}


/*
 * UpdateOverlay32
 *
 *
 * NOTES:
 *
 * This callback is invoked to update an overlay surface.
 * This is where the src/destination is specified, any effects, and
 * it is shown or hidden
 *
 * For overlay surfaces NOT associated with a video port the surface will
 * be shown (DDOVER_SHOW) according to the following criteria.
 *
 *     DDOVER_INTERLEAVED   DDOVER_BOB      DISPLAYED
 *
 *             1                1           Even field
 *             1                0           Full surface (no special processing)
 *             0                X           Full surface (no special processing)
 *
 */

DWORD __stdcall
UpdateOverlay32( LPDDHAL_UPDATEOVERLAYDATA lpUOData )
{
    NvNotification              *pPioFlipOverlayNotifier;
    DWORD                       index = 0;
    DWORD                       match = 0;
#ifndef WINNT
    DWORD                       dwSavedNBData = 0;
#endif
    long                        srcDeltaX;
    long                        srcDeltaY;
    long                        dwSrcWidth;
    long                        dwSrcHeight;
    long                        dwDstWidth;
    long                        dwDstHeight;
    U032                        bMediaPortControl = FALSE;
    DWORD                       dwOverlayFormat = 0;
    DWORD                       dwVPPFlags;

    LPDDRAWI_DDRAWSURFACE_LCL   srcx = lpUOData->lpDDSrcSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   src = srcx->lpGbl;
    LPDDRAWI_DDRAWSURFACE_LCL   pLastVisibleSurfLcl;

    dbgTracePush ("UpdateOverlay32");

    nvSetDriverDataPtrFromDDGbl (lpUOData->lpDD);

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = GET_HALINFO();

    pLastVisibleSurfLcl = (LPDDRAWI_DDRAWSURFACE_LCL) pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL;

    pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;

    // subrectangle size may change, reset temporal filter.
    pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_NOTFIRST;

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvDDrawRecover();
        } else {
            lpUOData->ddRVal = DDERR_SURFACEBUSY;
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_TWINVIEW_STATE_CHANGE) {
        VppDestroyFSMirror(&pDriverData->vpp);
        VppDestroyOverlay(&pDriverData->vpp);
        ResetTwinViewState(pDriverData);
        VppCreateOverlay(&pDriverData->vpp);
        VppCreateFSMirror(&pDriverData->vpp, pDriverData->vpp.dwOverlayFSSrcWidth, pDriverData->vpp.dwOverlayFSSrcHeight);
    }

#if 0
        // This code will eventually be used to specially opt out of overlay stuff when video port is in use
    if( srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  {

        lpUOData->ddRVal = HandleVideoPortOverlayUpdate( lpUOData);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;

    }
#endif //

#ifdef NVPE
    // VPE takes care of overlay !
    if ((srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) || (pDriverData->bRing0FlippingFlag))
    {
        bMediaPortControl = TRUE;
    }

    else
        bMediaPortControl = FALSE;

    // Workaround for 640x480 Panel overlay flip notifier problem.
    // If mode is 480 lines and overlay ends at line 480, reduce it to line 479.
    if ((GET_MODE_HEIGHT() == 480)      &&
        (lpUOData->rDest.bottom == 480) &&
        (lpUOData->rDest.top < 477)     &&
        (pDriverData->vpp.dwNVOverlayFlags & OVERLAY_FLAG_ON_PANEL)) {

        lpUOData->rDest.bottom = 479;
    }

#endif // NVPE

    if ((src->ddpfSurface.dwFourCC != FOURCC_UYVY) &&
        (src->ddpfSurface.dwFourCC != FOURCC_UYNV) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YUY2) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YUNV) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YV12) &&
        (src->ddpfSurface.dwFourCC != FOURCC_NV12) &&
        (src->ddpfSurface.dwFourCC != FOURCC_NVMC) &&
        (src->ddpfSurface.dwFourCC != FOURCC_NVDS) &&
        (src->ddpfSurface.dwFourCC != FOURCC_420i) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IF09) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YVU9) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV32) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV31)) {
            NvReleaseSemaphore(pDriverData);
            lpUOData->ddRVal = DDERR_INVALIDSURFACETYPE;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
    }

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY)) {
            NvReleaseSemaphore(pDriverData);
            lpUOData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
    }

    while ((index < NV_VPP_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == pDriverData->vpp.dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match) {
        // Do some DirectShow compatibility stuff
        if ((src->ddpfSurface.dwFourCC == FOURCC_NVMC) || (src->ddpfSurface.dwFourCC == FOURCC_NVDS)) {
#if (NVARCH >= 0x10)
            BYTE dstSurfaceIndex;
            LPNVMCFRAMEDATA lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(src->fpVidMem);
            dstSurfaceIndex = lpNvMCFrameData->bMCDestinationSurfaceIndex & 0x0F;
            if (pDriverData->dwMCNVMCSurface != 0) {
                if (dstSurfaceIndex >= 8)
                    dstSurfaceIndex = 0;
                srcx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[dstSurfaceIndex];
                if (srcx != NULL)
                    src = srcx->lpGbl;
            } else
                pLastVisibleSurfLcl = NULL;
#endif  // NVARCH >= 0x10
        } else {
            dbgError("VPP: Could not locate overlay in private list of surfaces");
            NvReleaseSemaphore(pDriverData);
            lpUOData->ddRVal = DDERR_OUTOFCAPS;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    getDC()->nvPusher.waitForOtherChannels();

    if ((getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) ||   // Mode switches might occur without warning
        (pDriverData->vpp.dwOverlayFSOvlHead == 0xFFFFFFFF) ||                    // overlay surface has been destroyed
        (pDriverData->vpp.dwOverlayFSOvlLost)) {                                  // not overlay capable any more

        nvDDrawRecover();
        lpUOData->ddRVal = DDERR_SURFACELOST;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    pDriverData->dwRingZeroMutex = TRUE;

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // turn off write posting
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, 0
                in  al, dx
                mov dwSavedNBData, eax
                and eax, 0FFFFFF7Fh
                out dx, al
        }
    }
#endif

//#ifndef WINNT
#if (!defined(WINNT) && !defined(NVPE))
    // check and possibly allocate overlay events for Ring0 functioning
    // note these will only be actually CALLED if write_then_awaken is used
    // so we're safe since ONLY ring0 should be calling that... hopefully heh heh...
    if(!pDriverData->vpp.dwOverlayEventsAllocated ){
      if(( ((vpSurfaces*)(pDriverData->dwMySurfacesPtr))->pNotifyOverlay0NotifyProc != 0 ) &&
           (((vpSurfaces*)(pDriverData->dwMySurfacesPtr))->pNotifyOverlay1NotifyProc != 0 )  ){
        U032 status = 0;
        status = NvRmAllocEvent (   pDriverData->dwRootHandle,
                              NV_VIDEO_OVERLAY,
                              MY_OVERLAY0_BUFFER_EVENT,
                              NV01_EVENT_KERNEL_CALLBACK,
                              NV07A_NOTIFIERS_SET_OVERLAY(0),
                              (void*)(((vpSurfaces*)(pDriverData->dwMySurfacesPtr))->pNotifyOverlay0NotifyProc));
        if( status !=  0x0 /* meaning sucess */ ) {
          DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
        }
        status = NvRmAllocEvent (   pDriverData->dwRootHandle,
                              NV_VIDEO_OVERLAY,
                              MY_OVERLAY1_BUFFER_EVENT,
                              NV01_EVENT_KERNEL_CALLBACK,
                              NV07A_NOTIFIERS_SET_OVERLAY(1),
                              (void*)(((vpSurfaces*)(pDriverData->dwMySurfacesPtr))->pNotifyOverlay1NotifyProc));
        if( status !=  0x0 /* meaning sucess */ ) {
          DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
        }
        pDriverData->vpp.dwOverlayEventsAllocated = TRUE;
      }
    }
#endif  // (!defined(WINNT) && !defined(NVPE))

    index = pDriverData->vpp.overlayBufferIndex;

    dwSrcWidth  = lpUOData->rSrc.right - lpUOData->rSrc.left;
    dwSrcHeight = lpUOData->rSrc.bottom - lpUOData->rSrc.top;
    dwDstWidth  = lpUOData->rDest.right - lpUOData->rDest.left;
    dwDstHeight = lpUOData->rDest.bottom - lpUOData->rDest.top;

    // if hide/show state, field state, size, and colour key state are the same, then we can do a
    // SetOverlayPosition instead
    if (pDriverData->vpp.dwOverlayFlipCount > 2 &&
        pLastVisibleSurfLcl != NULL &&
        pLastVisibleSurfLcl->lpGbl != NULL &&
        src->fpVidMem == pDriverData->vpp.dwOverlayLastVisibleFpVidMem &&
        (DWORD) src->lPitch == pDriverData->vpp.dwOverlayLastVisiblePitch &&
        src->ddpfSurface.dwFourCC == pDriverData->vpp.dwOverlayLastVisiblePixelFormat &&
        lpUOData->dwFlags == pDriverData->vpp.dwOverlayCachedFlags &&
        lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue == pDriverData->vpp.dwOverlayColorKey &&
        (DWORD)dwSrcWidth == pDriverData->vpp.dwOverlaySrcWidth &&
        (DWORD)dwSrcHeight == pDriverData->vpp.dwOverlaySrcHeight &&
        (DWORD)dwDstWidth == pDriverData->vpp.dwOverlayDstWidth &&

        (DWORD)dwDstHeight == pDriverData->vpp.dwOverlayDstHeight &&
#ifndef NVPE
        !(srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)) {
#else
        !(bMediaPortControl)) {
#endif // !NVPE
        pDriverData->dwRingZeroMutex = TRUE;
        pDriverData->vpp.dwOverlayDstX = (short)lpUOData->rDest.left;
        pDriverData->vpp.dwOverlayDstY = (short)lpUOData->rDest.top;

        // Direct Access to a VPP object - should not! -@mjl@
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_VPP_OVERLAY_IID);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_SET_OVERLAY_POINT_OUT_A | 0x40000);
        nvPushData(3, asmMergeCoords(lpUOData->rDest.left, lpUOData->rDest.top));  // SetOverlayPointOutA
        nvPusherAdjust(4);
        nvPusherStart(TRUE);

        pDriverData->dwRingZeroMutex = FALSE;
        pDriverData->dDrawSpareSubchannelObject = 0;
#ifndef WINNT
        // check for VIA 82C598 north bridge
        if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
            // restore write posting value
            _asm {
                    mov edx, 0cf8h
                    mov eax, 80000840h
                    out dx, eax
                    mov edx, 0cfch
                    mov eax, dwSavedNBData
                    out dx, al
            }
        }
#endif

        NvReleaseSemaphore(pDriverData);
        lpUOData->ddRVal = DD_OK;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    } else {
        // reset the overlay flip count
        // both overlay buffers must be set with correct paramters before using the setoverlyposition optimization
        pDriverData->vpp.dwOverlayFlipCount = 0;
    }

    pDriverData->vpp.dwOverlayCachedFlags = lpUOData->dwFlags;

    if ((lpUOData->dwFlags & DDOVER_HIDE ) || dwDstWidth <= 1 || dwDstHeight <= 1) {
        LPPROCESSINFO lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());

        DPF("UPDATE OVERLAY - DDOVER_HIDE");

#ifdef WINNT
        // WIN2K HACK: DX7 under win2k presents incorrect flags, so manually fix them
        if (pLastVisibleSurfLcl) {
            pLastVisibleSurfLcl->ddsCaps.dwCaps &= ~(DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER);
            pLastVisibleSurfLcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
        }
#endif  // WINNT
        pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL = 0;

        pDriverData->vpp.dwOverlaySrcWidth = 0;
        pDriverData->vpp.dwOverlayDstWidth = 0;
        pDriverData->vpp.dwOverlaySrcHeight = 0;
        pDriverData->vpp.dwOverlayDstHeight = 0;

#ifdef NVPE

        // H.AZAR: (10/20/99) tell VPE kernel to stop autoflip !
        if (bMediaPortControl)
            NVPUpdateOverlay(pDriverData, lpUOData->lpDD);
        else
        {
            Sleep(VPP_TIMEOUT_TIME * 3);

            // Direct Access to VPP object! -@mjl@
            nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData(1, NV_VPP_OVERLAY_IID);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_STOP_OVERLAY(0) | 0x80000);
            nvPushData(3, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[0]
            nvPushData(4, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[1]
            nvPusherAdjust(5);
            nvPusherStart(TRUE);

            pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
            pPioFlipOverlayNotifier[2].status = 0;
        }
#else
        Sleep(VPP_TIMEOUT_TIME * 3);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_DD_DMA_OVERLAY);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_STOP_OVERLAY(0) | 0x80000);
        nvPushData(3, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[0]
        nvPushData(4, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[1]
        nvPusherAdjust(5);
        nvPusherStart(TRUE);

        pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
        pPioFlipOverlayNotifier[2].status = 0;

#endif  // #ifdef NVPE

          //pDriverData->dwRingZeroMutex = FALSE;

        pDriverData->dDrawSpareSubchannelObject = 0;
        pDriverData->vpp.dwOverlayFormat = 0;     // This should hide things, since we'll stop flipping

        /* Let DDraw know how many visible overlays are active */
        pHalInfo->ddCaps.dwCurrVisibleOverlays = 0;

    } else {

        DPF("UPDATE OVERLAY - DDOVER_SHOW OR MOVE/RESIZE ");
        DPF( "Source Rect = (%d,%d), (%d,%d)",
             lpUOData->rSrc.left, lpUOData->rSrc.top,
             lpUOData->rSrc.right, lpUOData->rSrc.bottom );

        DPF( "Dest Rect = (%d,%d), (%d,%d)",
             lpUOData->rDest.left, lpUOData->rDest.top,
             lpUOData->rDest.right, lpUOData->rDest.bottom );

#ifdef WINNT
        // WIN2K HACK: DX7 under win2k presents incorrect flags, so manually fix them
        if (pLastVisibleSurfLcl) {
            pLastVisibleSurfLcl->ddsCaps.dwCaps &= ~(DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER);
            pLastVisibleSurfLcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
        }
        srcx->ddsCaps.dwCaps |= DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER;
        srcx->ddsCaps.dwCaps &= ~DDSCAPS_BACKBUFFER;
#endif  // WINNT
        pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL = (DWORD) srcx;
        pDriverData->vpp.dwOverlayLastVisibleFpVidMem = src->fpVidMem;
        pDriverData->vpp.dwOverlayLastVisiblePitch = src->lPitch;
        pDriverData->vpp.dwOverlayLastVisiblePixelFormat = src->ddpfSurface.dwFourCC;

        if ((lpUOData->rDest.left < 0) || (lpUOData->rDest.top < 0)) {
            pDriverData->dwRingZeroMutex = FALSE;

#ifndef WINNT
            // check for VIA 82C598 north bridge
            if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
                // restore write posting value
                _asm {
                        mov edx, 0cf8h
                        mov eax, 80000840h
                        out dx, eax
                        mov edx, 0cfch
                        mov eax, dwSavedNBData
                        out dx, al
                }
            }
#endif
            NvReleaseSemaphore(pDriverData);
            lpUOData->ddRVal = DDERR_INVALIDPOSITION;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }

        // For bus mastering TV tuners that never flip
        TVTunerTimerHack();

        /* Remember sizes so Flip32 knows what to do */
        pDriverData->vpp.dwOverlaySrcWidth = dwSrcWidth;
        pDriverData->vpp.dwOverlayDstWidth = dwDstWidth;
        pDriverData->vpp.dwOverlaySrcHeight = dwSrcHeight;
        pDriverData->vpp.dwOverlayDstHeight = dwDstHeight;


#ifndef NVPE
        // cheehoi. Need driver to flip (bMediaPortControl=TRUE) for nv4/5 when
        // media port is used. Only applies to nv4/5????
        if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10){
            if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {
                //if (lpUOData->dwFlags & DDOVER_AUTOFLIP  ||
                //  pDriverData->vpp.dwOverlaySurfaces==1){ //autoflip or 1 ovl.surf.
                    bMediaPortControl = TRUE;
                //}
            }
        }else{
            //nv10. This was leftover from Chris. May not be needed.
            if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {
                if (lpUOData->dwFlags & DDOVER_AUTOFLIP){
                    bMediaPortControl = TRUE;
                }
            }
        }

        if(pDriverData != 0) {
          if (pDriverData->bRing0FlippingFlag  )  {
            bMediaPortControl = TRUE;
          }
        }

#endif // !NVPE

        if (dwDstWidth <= 1) {
            srcDeltaX = 0x100000;
        } else {
            srcDeltaX = ((dwSrcWidth - 1) << 20) / (dwDstWidth - 1);
        }

        // Align to 2 pixel boundary + 1 for video scaler
//        dwDstWidth = (dwDstWidth + 2) & ~1L;
//        dwDstHeight = (dwDstHeight + 1) & ~1L;

        if (dwDstHeight <= 1) {
            srcDeltaY = 0x100000;
        } else {
            srcDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
        }

        // Let the world know what the overlay src info is
        pDriverData->vpp.dwOverlaySrcX = (short)(lpUOData->rSrc.left & ~1);
        pDriverData->vpp.dwOverlaySrcY = (short)lpUOData->rSrc.top;

        // Do 1080i single field fixups if necessary
        if ((pDriverData->bMCOverlaySrcIsSingleField1080i) && (src->ddpfSurface.dwFourCC == FOURCC_NV12)) {
            if (pDriverData->bMCHorizontallyDownscale1080i) {
                dwSrcWidth = (dwSrcWidth * 10) / 18;
                srcDeltaX = ((dwSrcWidth - 1) << 20) / (dwDstWidth - 1);
                pDriverData->vpp.dwOverlaySrcX = (pDriverData->vpp.dwOverlaySrcX * 10) / 18;
            }
            dwSrcHeight >>= 1;
            srcDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
            pDriverData->vpp.dwOverlaySrcHeight = dwSrcHeight;
        }

        pDriverData->vpp.dwOverlaySrcSize = asmMergeCoords(dwSrcWidth, dwSrcHeight);

        // Get the video mirror source dimensions
        if (pDriverData->vpp.dwOverlayFSSrcWidth < (DWORD) dwSrcWidth) {
            pDriverData->vpp.dwOverlayFSSrcWidth = dwSrcWidth;
        }
        if (pDriverData->vpp.dwOverlayFSSrcHeight < (DWORD) dwSrcHeight) {
            pDriverData->vpp.dwOverlayFSSrcHeight = dwSrcHeight;
        }
        if (pDriverData->vpp.dwOverlayFSSrcMinX > (DWORD) pDriverData->vpp.dwOverlaySrcX) {
            pDriverData->vpp.dwOverlayFSSrcMinX = pDriverData->vpp.dwOverlaySrcX;
        }
        if (pDriverData->vpp.dwOverlayFSSrcMinY > (DWORD) pDriverData->vpp.dwOverlaySrcY) {
            pDriverData->vpp.dwOverlayFSSrcMinY = pDriverData->vpp.dwOverlaySrcY;
        }

        /* Let the world know what the current overlay destination offset is */
        pDriverData->vpp.dwOverlayDstX = (short)lpUOData->rDest.left;
        pDriverData->vpp.dwOverlayDstY = (short)lpUOData->rDest.top;

        if (pDriverData->vpp.extraNumSurfaces == 0) {
            // VPP pipe is disable, only overlay scaling will be used
            if (dwSrcWidth > (dwDstWidth * (long)pDriverData->vpp.dwOverlayMaxDownScale)) {
                srcDeltaX = 0x100000 * pDriverData->vpp.dwOverlayMaxDownScale;
            }

            if (dwSrcHeight > (dwDstHeight * (long)pDriverData->vpp.dwOverlayMaxDownScale)) {
                srcDeltaY = 0x100000 * pDriverData->vpp.dwOverlayMaxDownScale;
            }
        } else {
            if (!bMediaPortControl)
            {
                if (pDriverData->vpp.dwOverlayMaxDownScaleX <= 1) {
                    // prescaler will be doing all the downscaling
                    if (dwSrcWidth > dwDstWidth) {
                        srcDeltaX = 0x100000;
                    }
                } else {
                    // predict what the cascading downscaler will produce for the overlay scale factor
                    long dwNewSrcWidth = dwSrcWidth;
                    while (dwNewSrcWidth > (dwDstWidth * (long)pDriverData->vpp.dwOverlayMaxDownScaleX)) {
                        dwNewSrcWidth /= 2;
                        srcDeltaX = ((dwNewSrcWidth - 1) << 20) / dwDstWidth;
                    }
                }
                if (pDriverData->vpp.dwOverlayMaxDownScaleY <= 1) {
                    // prescaler will be doing all the downscaling
                    if (dwSrcHeight > dwDstHeight) {
                        srcDeltaY = 0x100000;
                    }
                } else {
                    // predict what the cascading downscaler will produce for the overlay scale factor
                    long dwNewSrcHeight = dwSrcHeight;
                    while (dwNewSrcHeight > (dwDstHeight * (long)pDriverData->vpp.dwOverlayMaxDownScaleY)) {
                        dwNewSrcHeight /= 2;
                        srcDeltaY = ((dwNewSrcHeight - 1) << 20) / dwDstHeight;
                    }
                }
            }
            else
            {
                if (dwSrcWidth > (dwDstWidth * (long)pDriverData->vpp.dwOverlayMaxDownScale))
                {
                    srcDeltaX = 0x100000;
                }

                if (dwSrcHeight > (dwDstHeight * (long)pDriverData->vpp.dwOverlayMaxDownScale))
                {
                    srcDeltaY = 0x100000;
                }
            }

            if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
                // if HQVUp is enabled, the prescaler will do vertical upscale too
                if ((pDriverData->vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) ||
                    (lpUOData->dwFlags & (DDOVER_INTERLEAVED | DDOVER_BOB))) {
                    srcDeltaY = 0x100000;
                }
            }
        }



#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0 (0x04000000)
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 (0x02000000)
#define NV_VFM_FORMAT_BOBFROMINTERLEAVE           (0x08000000)

        // color key?
        if (lpUOData->dwFlags & DDOVER_KEYDESTOVERRIDE) {
            DPF( "Dest ColorKey = %08x,%08x",
                lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue,
                lpUOData->overlayFX.dckDestColorkey.dwColorSpaceHighValue );

            // Save this for later reference
            pDriverData->vpp.dwOverlayColorKey =
                lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue;

            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_IMAGE << 20);

        } else if (lpUOData->dwFlags & DDOVER_KEYDEST) {
            DPF( "Dest ColorKey = %08x,%08x",
                lpUOData->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue,
                lpUOData->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceHighValue );

            // Save this for later reference
            pDriverData->vpp.dwOverlayColorKey =
                lpUOData->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;

            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_IMAGE << 20);

        } else {    // disable color key
            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_OVERLAY << 20);
        }

/*
        if(!bMediaPortControl) {
          nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
          nvPushData(1, NV_DD_DMA_OVERLAY);
          nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_SET_OVERLAY_COLORKEY(index) | 0x40000);
          nvPushData(3, pDriverData->vpp.dwOverlayColorKey);                                // SetOverlayColorKey
          nvPushData(4, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_SET_OVERLAY_DU_DX(index) | 0x100000);
          nvPushData(5, srcDeltaX);                                                   // SetOverlayDuDx
          nvPushData(6, srcDeltaY);                                                   // SetOverlayDvDy
          nvPushData(7, asmMergeCoords(lpUOData->rDest.left, lpUOData->rDest.top));   // SetOverlayPointOut
          nvPushData(8, asmMergeCoords((dwDstWidth & ~1), dwDstHeight));              // SetOverlaySizeOut
          nvPusherAdjust(9);
          nvPusherStart(TRUE);
        }
*/
        if (lpUOData->dwFlags & DDOVER_AUTOFLIP)
            index = 0; // overide index for mediaport/overlay autoflip

        if ((src->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
            (src->ddpfSurface.dwFourCC == FOURCC_UYNV)) {

            // we need to know if we're bobbing
          if((srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)
              && (lpUOData->dwFlags & DDOVER_BOB)
              && (lpUOData->dwFlags & DDOVER_INTERLEAVED) ){
              pDriverData->vpp.dwOverlayMode =  NV_VFM_FORMAT_BOBFROMINTERLEAVE | NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1;
              DPF( "Video Port Overlay control - Interleaved - BOB");
          } else if((srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)
              && (lpUOData->dwFlags & DDOVER_BOB)
              ){
              pDriverData->vpp.dwOverlayMode =  NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1;
              DPF( "Video Port Overlay control - Separate - BOB");
          } else if((srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)
              ){
              pDriverData->vpp.dwOverlayMode =  NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1;
              DPF( "Video Port Overlay control - weave or odd or even");
          } else {
              pDriverData->vpp.dwOverlayMode = 0;

          }

          dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8 << 16);

        } else {
            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16);
        }

        dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT601 << 24);
        // don't know the source pitch yet, let vppFlip update it
//        dwOverlayFormat |= dwSrcPitch;
        dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_NOTIFY_WRITE_ONLY << 31);

        // Let the world know what the overlay format info is
        pDriverData->vpp.dwOverlayFormat = dwOverlayFormat;

        pDriverData->vpp.dwOverlayDeltaX = (DWORD)srcDeltaX;
        pDriverData->vpp.dwOverlayDeltaY = (DWORD)srcDeltaY;

        // all the overlay source information is set in vppFlip
        // no way to convey odd or even field, assume odd if bobbed
        dwVPPFlags = VPP_STATIC | VPP_WAIT;
        if (lpUOData->dwFlags & DDOVER_BOB) {
            dwVPPFlags |= VPP_BOB | VPP_ODD;
        }
        if (lpUOData->dwFlags & DDOVER_INTERLEAVED) {
            dwVPPFlags |= VPP_INTERLEAVED | VPP_ODD;
        }
        if (bMediaPortControl) {
            dwVPPFlags |= VPP_VIDEOPORT;
            pDriverData->vpp.dwOverlaySrcPitch = src->lPitch;

        }  else {
#if (NVARCH >= 0x10)
            if (src->ddpfSurface.dwFourCC == FOURCC_NV12) {
                LPNVMCSURFACEFLAGS lpSurfaceFlags =
                    (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

                while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                       (lpSurfaceFlags->dwMCSurfaceBase != src->fpVidMem))
                        lpSurfaceFlags++;

                // Make sure the surface has been format converted
                if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
                    (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
                    nvMoCompConvertSurfaceFormat(src->fpVidMem, TRUE, 15);
                else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) &&
                    ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3))
                    nvMoCompConvertSurfaceFormat(src->fpVidMem, TRUE, 3);
                else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
                    (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 12))
                    nvMoCompConvertSurfaceFormat(src->fpVidMem, TRUE, 12);

                if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                    (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                    (pDriverData->bMCTemporalFilterDisabled == FALSE) &&
                    IS_FIELD(dwVPPFlags))
                    nvMoCompTemporalFilter(src->fpVidMem, pDriverData->bMCPercentCurrentField);

                // Check if filtering is disabled on this surface for this display call only
                if (lpSurfaceFlags->bMCFrameType & TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE) {
                    lpSurfaceFlags->bMCFrameIsFiltered = FALSE;
                    lpSurfaceFlags->bMCFrameType &= ~TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE;
                }

                // Always display non-filtered portion of non-interleaved frames
                if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME)
                    lpSurfaceFlags->bMCFrameIsFiltered = FALSE;

            }
#endif  // (NVARCH >= 0x10)

#ifdef  DEBUG
#if (NVARCH >= 0x010)
            if ((moCompDebugLevel > 0) && (src->ddpfSurface.dwFourCC == FOURCC_NV12)) {
                if (overlaySurfaceBase == 0)
                    overlaySurfaceBase = src->fpVidMem;

                dwVPPFlags &= ~VPP_BOB;
                dwVPPFlags &= ~VPP_ODD;

                VppDoFlip(
                    &(pDriverData->vpp),
                    overlaySurfaceBase - pDriverData->BaseAddress,
                    src->lPitch,
                    src->wWidth,
                    src->wHeight,
                    src->ddpfSurface.dwFourCC,
                    dwVPPFlags);
            }
            else
#endif  // NVARCH >= 0x010
#endif  // DEBUG
            {
                VppDoFlip(&(pDriverData->vpp),
                              src->fpVidMem - pDriverData->BaseAddress,
                              src->lPitch,
                              src->wWidth,
                              src->wHeight,
                              src->ddpfSurface.dwFourCC,
                              dwVPPFlags);
            }
        }

        /* Let DDraw know how many visible overlays are active */
        if (pHalInfo->ddCaps.dwCurrVisibleOverlays == 0) {
            pHalInfo->ddCaps.dwCurrVisibleOverlays = 1;
        }
    }

    pDriverData->dwRingZeroMutex = FALSE;

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // restore write posting value
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, dwSavedNBData
                out dx, al
        }
    }
#endif

#ifdef NVPE

    ///// H.AZAR: (10/20/1999): notify VPE kernel of overlay changes !
    if (bMediaPortControl)
        NVPUpdateOverlay(pDriverData, lpUOData->lpDD);
#endif  // #ifdef NVPE

    // We make this call here simply to ensure that the color control
    // values are reset to the values we're holding in pDriverData.
    //
    // There is an outstanding issue which causes zeros to be written
    // sometimes on a modeswitch.  By forcing this here, we update the
    // value very near the 'end' of the overlay rebuild process (just before
    // show) so we're likely to overwrite the zeros.
    //
    // The proper fix of course is to determine what part of the system is
    // writing the zeros.  Refer to BUG #20000807-184148
    //
    if (!bMediaPortControl) {
    VppSetOverlayColourControl(&(pDriverData->vpp));
    }

    NvReleaseSemaphore(pDriverData);
    lpUOData->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;

} /* UpdateOverlay32 */


/*
 * SetOverlayPosition32
 */
DWORD __stdcall
SetOverlayPosition32( LPDDHAL_SETOVERLAYPOSITIONDATA lpSOPData )
{
    NvNotification              *pPioFlipOverlayNotifier;
    DWORD                       index = 0;
    DWORD                       match = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   srcx = lpSOPData->lpDDSrcSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   src = srcx->lpGbl;
    BOOL                        bMediaPortControl = FALSE;

    dbgTracePush ("SetOverlayPosition32");

    nvSetDriverDataPtrFromDDGbl (lpSOPData->lpDD);

    pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_TWINVIEW_STATE_CHANGE) {
        VppDestroyFSMirror(&pDriverData->vpp);
        VppDestroyOverlay(&pDriverData->vpp);
        ResetTwinViewState(pDriverData);
        VppCreateOverlay(&pDriverData->vpp);
        VppCreateFSMirror(&pDriverData->vpp, pDriverData->vpp.dwOverlayFSSrcWidth, pDriverData->vpp.dwOverlayFSSrcHeight);
    }

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY)) {
            NvReleaseSemaphore(pDriverData);
            lpSOPData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
    }

    if ((lpSOPData->lXPos < 0) || (lpSOPData->lYPos < 0)) {
            NvReleaseSemaphore(pDriverData);
            lpSOPData->ddRVal = DDERR_INVALIDPOSITION;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
    }

    while ((index < NV_VPP_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == pDriverData->vpp.dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match) {
        // Do some DirectShow compatibility stuff
        if ((src->ddpfSurface.dwFourCC == FOURCC_NVMC) || (src->ddpfSurface.dwFourCC == FOURCC_NVDS)) {
#if (NVARCH >= 0x10)
            LPNVMCFRAMEDATA lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(src->fpVidMem);
            DWORD dwIndex = lpNvMCFrameData->bMCDestinationSurfaceIndex;
            nvAssert (dwIndex < 8);
            srcx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[dwIndex];
            nvAssert (srcx);
            src = srcx->lpGbl;
#endif  // NVARCH >= 0x10
        } else {
            NvReleaseSemaphore(pDriverData);
            lpSOPData->ddRVal = DDERR_OUTOFCAPS;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

#if 0
    // This code will eventually be used to specially opt out of overlay stuff when video port is in use
    if( srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  {

        lpUOData->ddRVal = HandleVideoPortOverlayPosition( lpSOPData);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;

    }
#endif //

    if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  {
        bMediaPortControl = TRUE;
    }

    if (pDriverData != 0) {
        if (pDriverData->bRing0FlippingFlag)  {
            bMediaPortControl = TRUE;
        }
    }

    getDC()->nvPusher.waitForOtherChannels();

    if ((getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) ||     /* Mode switches might occur without warning */
        pDriverData->vpp.dwOverlayFSOvlLost) {

        NvReleaseSemaphore(pDriverData);
        lpSOPData->ddRVal = DDERR_SURFACELOST;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * NOTES:
     * This callback is invoked to set an overlay position
     */
    DPF( "SET OVERLAY POSITION" );
    DPF( "Overlay surface = %08x", lpSOPData->lpDDSrcSurface );
    DPF( "(%d,%d)", lpSOPData->lXPos, lpSOPData->lYPos );

    pDriverData->dwRingZeroMutex = TRUE;

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvDDrawRecover();
        } else {
            lpSOPData->ddRVal = DDERR_SURFACEBUSY;
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /* Let the world know what the current overlay destination offset is */
    pDriverData->vpp.dwOverlayDstX = (short)lpSOPData->lXPos;
    pDriverData->vpp.dwOverlayDstY = (short)lpSOPData->lYPos;

    // Direct Access to VPP object! -@mjl@
    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData(1, NV_VPP_OVERLAY_IID);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_SET_OVERLAY_POINT_OUT_A | 0x40000);
    nvPushData(3, asmMergeCoords(lpSOPData->lXPos, lpSOPData->lYPos));  // SetOverlayPointOutA
    nvPusherAdjust(4);
    nvPusherStart(TRUE);

    pDriverData->dwRingZeroMutex = FALSE;

    pDriverData->dDrawSpareSubchannelObject = 0;

    NvReleaseSemaphore(pDriverData);
    lpSOPData->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;

} /* SetOverlayPosition32 */


//---------------------------------------------------------------------------
#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\ddnvstat.cpp ===
//======================================================================
// Module:		ddnvstat.cpp
// Description:	NVidia statistics driver routines, for NV3/NV4
// 
//  Copyright (C) 1999 NVidia Corporation.  All Rights Reserved.
//======================================================================
// NB: This file is 'opted out' of using pre-compiled headers
#include <windows.h>
#include <tchar.h>

#define STAT_INSTANIATE_TABLE
#include "statdef.h"			// has to be included before nvprecomp.

#include "nvprecomp.h"


#ifndef WINNT

#undef NVSTATNT_IOCTL
#define NVSTATNT_IOCTL(x) x

#endif

NVSTATLOCKINDEX nvStatLockIndex = NVSTAT_LOCK_UNKNOWN;
STATINDEX *gNVStatIndex;

HANDLE OpenDriver (TCHAR *pDeviceName);
BOOL CloseDriver(HANDLE hDriver);
DWORD GetDriverVersion(HANDLE hDriver);

HANDLE gDriverHandle = INVALID_HANDLE_VALUE;
NVSTATCNF statCfg;
NVDXTICK *DXStatTickPtr = NULL;

//======================================================================
// Function:	nvStatLookupIndex
// Description	Lookup and Index and fill in StatIndex structure
//				log/capture timings for d3d/ddraw functions.
// Parameters:	.
// Returns:		.
//======================================================================
void __cdecl nvStatLookupIndex(char *fmt, ...)
{
	DWORD nParms;
	DWORD sLen;
	DWORD ID;

	if (gNVStatIndex)
	{
		if (gNVStatIndex->index != INVALID_INDEX)
		{
			// log parameters 
			if (DXStatTickPtr && (DXStatTickPtr->logFormat & LOG_MEDIUM_BIT))
			{
				nParms = gNVStatIndex->nParms;
				if (nParms > 0)
				{
					ID = gNVStatIndex->index | D3D_LOG_PARAMETERS;
					nvStatWriteLogOpCode(nParms+1, ID);
					nvStatWriteLogData(nParms, (DWORD *)(&fmt+1));
				}
			}
			return;
		}

		__asm {
			push eax
			push ebx
			push ecx
			push edx
			push esi
			push edi

			mov	esi, fmt
			sub	esi, 1
			mov	ecx, STAT_HASH_TABLE_SIZE+1
			xor	eax,eax
			xor edx,edx
			mov bl, '%'
	loopSize:
			add	esi, 1
			dec	ecx
			je	done
			cmp	byte ptr [esi],al
			je	done
			cmp	[esi], bl
			jne	loopSize
			inc	edx
			jmp	loopSize
	done:
			neg	ecx
			add	ecx, STAT_HASH_TABLE_SIZE
			mov	sLen, ecx
			mov nParms, edx

			mov	ebx,ecx
			shl	ebx,3			// multiply by size of LENHASH structure
			add	ebx, OFFSET statDefHash
			mov	eax, dword ptr ([ebx]statDefHash.numEntries)
			mov	edx,[ebx]statDefHash.offset
			add	edx, OFFSET statDefList
	strLoop:
			mov	esi, edx
			mov edi, fmt
			mov	ecx, sLen
			add	edx, ecx
			repe	cmpsb
			je	foundName
			add	edx, 1			// + \0
			add	eax, (1 SHL 16)	// update ID in high word of eax
			dec	ax
			jne	strLoop
			mov	eax,-1
	foundName:
			shr		eax, 16
			cwde
			mov	ID, eax

			pop	edi
			pop	esi
			pop	edx
			pop	ecx
			pop	ebx
			pop	eax
		};

		gNVStatIndex->index = ID;
		gNVStatIndex->nParms = nParms;

		if (DXStatTickPtr)
		{
			if (ID != INVALID_INDEX)
			{
				nvStatWriteLogOpCode(1, ID);
				if (DXStatTickPtr->logFormat & LOG_MEDIUM_BIT)
				{
					NVStatLogMedium(0, ID);
				}
				else if (DXStatTickPtr->logFormat & LOG_MAXIMUM_BIT)
				{
					NVStatLogMaximum(0, ID);
				}
			}
		}
	}
}

//======================================================================
// Function:	AttachNVStat
// Description	Attaches to statistics Driver, so we can
//				log/capture timings for d3d/ddraw functions.
// Parameters:	.
// Returns:		.
//======================================================================
void __stdcall AttachNVStat()
{
	DWORD bytesReturned;

	gDriverHandle = OpenDriver(_T("nvstat"));

	if (gDriverHandle != INVALID_HANDLE_VALUE)
	{
		if (NvDeviceIoControl(gDriverHandle, NVSTATNT_IOCTL(GETCONFIGURATION), NULL, 0, &statCfg, sizeof(NVSTATCNF), 
			&bytesReturned, NULL) != 0)
		{
			// make sure configuration size is matches..
			if (bytesReturned == sizeof(NVSTATCNF))
			{
				// make sure at least the structure sizes match.
				if (statCfg.captureSize == sizeof(NVDXTICK))
					DXStatTickPtr = (NVDXTICK *)statCfg.captureMem;
			}
		}
	}
}

//======================================================================
// Function:	DetachNVStat
// Description	Detach statistics Driver (nvstat.Driver), freeing up resources
// Parameters:	.
// Returns:		.
//======================================================================
void __stdcall DetachNVStat()
{
	DXStatTickPtr = NULL;

	CloseDriver(gDriverHandle);	

	gDriverHandle = INVALID_HANDLE_VALUE;

}


//======================================================================
// Function:	OpenDriver
// Description:	opens the Driver for communication between ring 3 and 
//				ring 0
// Parameters:	pDeviceName = name of Driver
// returns:		HANDLE = opened file handle
//======================================================================
HANDLE OpenDriver (TCHAR *pDeviceName)
{

    HANDLE hDriver = 0;
    TCHAR device[64];

#ifdef WINNT
    nvSprintf( device, _T("%s"), pDeviceName);
#else
    PCHAR pExt = _tcsrchr( pDeviceName, '.');
    if (pExt && _tcsicmp( pExt, _T(".vxd")) == 0)
       *pExt = 0;

    nvSprintf( device, _T("\\\\.\\%s"), pDeviceName);
#endif

    hDriver = NvCreateFile( device, GENERIC_EXECUTE | GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
    if (hDriver == INVALID_HANDLE_VALUE)
    {
#ifdef WINNT
        nvStrCat( device, _T(".sys"));
#else
        nvStrCat( device, _T(".vxd"));
#endif

	    hDriver = CreateFile( device, GENERIC_EXECUTE | GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

    }
    return hDriver;
}


//======================================================================
// Function:	CloseDriver
// Description:	closes the Driver for freeing up resources
// Parameters:	HANDLE = opened file handle
// Returns:		!0 = success
//======================================================================
BOOL CloseDriver(HANDLE hDriver)
{
   BOOL retval;

   if (hDriver == INVALID_HANDLE_VALUE)
      return 0;

#ifdef WINNT
   retval = NvCloseHandle(hDriver);
#else
   retval = CLOSE_HANDLE( hDriver);
#endif

   return retval;
}

//======================================================================
// Function:	GetDriverVersion
// Description:	Retreives the Driver Version through an IOCTL
// Parameters:	HANDLE = opened file handle
// Returns:		packed version information
//======================================================================
DWORD GetDriverVersion(HANDLE hDriver)
{
    DWORD  cbBytesReturned;
    struct { BYTE minor; BYTE major; WORD product; } verinfo = {0,0,0};

    if (hDriver == INVALID_HANDLE_VALUE)
       return 0;

    if (!NvDeviceIoControl( hDriver,NVSTATNT_IOCTL(GETVERSION),0,0,&verinfo,sizeof(verinfo),&cbBytesReturned,NULL))
       return 0;

    return ( (verinfo.major << 8) | verinfo.minor);
}

//=====================================================================
// Function:	nvStatCheckLogSpace
// Description:	check for space in log file memory area
// Parameters:	nDWords = number of DWORDS we are going to write
// Returns:		TRUE if space in log memory area
//=====================================================================
BOOL nvStatCheckLogSpace(DWORD nDWords)
{
	DWORD freeSize;
	DWORD kLogSize;

	if (DXStatTickPtr->logFull)
		return TRUE;

	kLogSize = (DXStatTickPtr->logSize << 10);
	if (DXStatTickPtr->logHead > DXStatTickPtr->logTail)
	{
		// this really shouldn't happen, as the log file
		// stops when logTail reaches the end of the buffer, this is no longer
		// a circular buffer...But just in case figure something out.
		DPF("For some reason logging head pointer passed logging tail pointer????");
		freeSize = (DXStatTickPtr->logHead - DXStatTickPtr->logTail);
	}
	else
	{
		freeSize = kLogSize - (DXStatTickPtr->logTail - DXStatTickPtr->logHead);
	}

	if (freeSize >= (nDWords << 2))
		return TRUE;

	return FALSE;

}

//=====================================================================
// Function:	nvStatWriteLogOpCode
// Description:	write an opcode for upcoming log entries
// Parameters:	nDWords = number of DWORDS we are going to write
//							including opCode itself
//				opCode = the opcode to write to log memory
// Returns:		.
//=====================================================================
void nvStatWriteLogOpCode(DWORD nDWords, DWORD opCode)
{
	DWORD *tPtr;
	DWORD logSize;

	if (DXStatTickPtr == NULL)
		return;

	if (DXStatTickPtr->captureOn == 0)
		return;

	if (!(DXStatTickPtr->logFormat & (LOG_MINIMUM_BIT | LOG_MEDIUM_BIT | LOG_MAXIMUM_BIT)))
		return;

	if (DXStatTickPtr->logFull)
		return;

	if (nvStatCheckLogSpace(nDWords))
	{
		tPtr = (DWORD *)((BYTE *)DXStatTickPtr->logMem + DXStatTickPtr->logTail);
		*tPtr = (opCode << 16) | (nDWords & 0xffff);

		logSize = DXStatTickPtr->logSize << 10;

		// we only wrote out one of the words 
		DXStatTickPtr->logTail = DXStatTickPtr->logTail + (1 << 2);

		if (DXStatTickPtr->logTail >= logSize)
		{
			// stop logging when buffer is full
			DXStatTickPtr->logFull = TRUE;
		}
	}
	else
	{
		// stop logging when buffer is full
		DXStatTickPtr->logFull = TRUE;
		DXStatTickPtr->logMissed += 1;
	}


}

//=====================================================================
// Function:	nvStatWriteLogOpData
// Description:	write data for log entries
// Parameters:	nDWords = number of DWORDS we are going to write
//							including opCode itself
//				theData = pointer to dword data
// Returns:		.
//=====================================================================
void nvStatWriteLogData(DWORD nDWords, DWORD *theData)
{
	DWORD *tPtr;
	DWORD kLogSize;
	DWORD dwCount;

	if (DXStatTickPtr == NULL)
		return;

	if (DXStatTickPtr->captureOn == 0)
		return;

	if (DXStatTickPtr->logFull)
		return;

	if (!(DXStatTickPtr->logFormat & (LOG_MINIMUM_BIT | LOG_MEDIUM_BIT | LOG_MAXIMUM_BIT)))
		return;

	if (nvStatCheckLogSpace(nDWords))
	{
		tPtr = (DWORD *)((BYTE *)DXStatTickPtr->logMem + DXStatTickPtr->logTail);
		dwCount = nDWords;
		while (dwCount)
		{
			*tPtr++ = *theData++;
			dwCount--;
		}

		kLogSize = DXStatTickPtr->logSize << 10;

		DXStatTickPtr->logTail = DXStatTickPtr->logTail + (nDWords << 2);

		if (DXStatTickPtr->logTail == DXStatTickPtr->logHead)
		{
			// stop logging when buffer is full
			DXStatTickPtr->logFull = TRUE;
		}
	}
	else
	{
		// stop logging when buffer is full
		DXStatTickPtr->logFull = TRUE;
		DXStatTickPtr->logMissed += nDWords;
	}
}

//======================================================================
// Function:	nvStatLogError
// Description:	Log an error to the log file
// Parameters:	.
// Returns:		.
//======================================================================
void __cdecl nvStatLogError(DWORD dwLevel, LPSTR szFormat, ...)
{
	TCHAR tBuff[256];
	DWORD sLen;

	if (DXStatTickPtr == NULL)
		return;

	if (!(DXStatTickPtr->logFormat & (LOG_MINIMUM_BIT | LOG_MEDIUM_BIT | LOG_MAXIMUM_BIT)))
		return;

	if (!(dwLevel & (NVDBG_LEVEL_ERROR | NVDBG_LEVEL_PERFORMANCE)))
		return;

	nvSprintf(tBuff, szFormat, (va_list)(&szFormat+1));

	// include ending 0
	sLen = nvStrLen(tBuff)+1;

	// turn into # of double words
	sLen = (sLen + 3) >> 2;

	if (dwLevel & NVDBG_LEVEL_ERROR)
	{
		nvStatWriteLogOpCode(sLen+1, D3D_LOG_ERROR);
		nvStatWriteLogData(sLen, (LPDWORD)tBuff);
	}
	else if (DXStatTickPtr->logFormat & LOG_PERFORMANCE_BIT)
	{
		nvStatWriteLogOpCode(sLen+1, D3D_LOG_PERFORMANCE);
		nvStatWriteLogData(sLen, (LPDWORD)tBuff);
	}


}

//======================================================================
// Function:	nvStatLogState
// Description:	Log state change to log file
// Parameters:	state = which state has changed
//				context = which context changed the state
// Returns:		.
//======================================================================
void nvStatLogState(DWORD state, PNVD3DCONTEXT context)
{
}

//======================================================================
// Function:	nvStatLogPrimitives
// Description:	Log primitve information to log file
// Parameters:	command = primitive command to log
//				commandCount = # commands of this type
// Returns:		.
//======================================================================
void nvStatLogPrimitives(BYTE command,WORD commandCount)
{

}

//======================================================================
// Function:	nvStatLogLight
// Description:	log light parameters which come from DX7
// Parameters:	pLight7 pointer ot light structure
// Returns:		.
//======================================================================
void nvStatLogLight(LPD3DLIGHT7 pLight7)
{
}


//======================================================================
// Function:	nvStatLogDwordData
// Description:	log some dword data to the log file
// Parameters:	parmEnum = enumeration for parameter type
//				count = number of dwords to write
//				... = dword parameters
// Returns:		.
//======================================================================
void nvStatLogDwordData(DWORD parmEnum, int count, ...)
{
	va_list marker;
	DWORD curDW;

	if (DXStatTickPtr == NULL)
		return;

	if (!(DXStatTickPtr->logFormat & (LOG_MEDIUM_BIT | LOG_MAXIMUM_BIT)))
		return;

	if (DXStatTickPtr->logFull)
		return;


	nvStatWriteLogOpCode(count+1, parmEnum);

	va_start(marker, count);

	while (count)
	{
		curDW = va_arg(marker, DWORD);
		nvStatWriteLogData(1, &curDW);
		count--;
	}

	va_end(marker);

}

void __stdcall nvCelsiusDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress)
{
#if 0
	DWORD *pdwData;
	DWORD flags;
	DWORD nUserUVS;
	DWORD nDWORDS;

	if (DXStatTickPtr == NULL)
		return;

	if (!(DXStatTickPtr->logFormat & LOG_MAXIMUM_BIT))
		return;

	pdwData = ((DWORD*)dwPutAddress) + 1;

	nDWORDS = 0;
	flags = 0;
	nUserUVS = 0;

	if (fvfData.dwBMask)
	{
		flags |= VERTSBMASK;
		nDWORDS++;
	}

	if (fvfData.dwNormalMask)
	{
		flags |= VERTSNORMALMASK;
		nDWORDS += 3;
	}

	if (pContext->celsiusState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
	{
		DWORD dwD3DStage = pContext->celsiusState.dwTexUnitToTexStageMapping[1];
        DWORD dwTCIndex  = (pContext->celsiusState.dwTexCoordIndices >> 16) & 0xffff;
        DWORD dwCount    = (pContext->celsiusState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) ?
                           4 : fvfData.dwUVCount[dwTCIndex];
		flags |= VERTSUSERUV1;
		nDWORDS += dwCount;
		nUserUVS = dwCount << 16;
	}

	if (pContext->celsiusState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
	{
		DWORD dwD3DStage = pContext->celsiusState.dwTexUnitToTexStageMapping[0];
        DWORD dwTCIndex  = (pContext->celsiusState.dwTexCoordIndices >>  0) & 0xffff;
        DWORD dwCount    = (pContext->celsiusState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(0))) ?
                           4 : fvfData.dwUVCount[dwTCIndex];
		flags |= VERTSUSERUV0;
		nDWORDS += dwCount;
		nUserUVS |= dwCount;
	}

	if (fvfData.dwSpecularMask)
	{
		flags |= VERTSSPECULAR;
		nDWORDS++;

	}

	if (fvfData.dwDiffuseMask)
	{
		flags |= VERTSDIFFUSE;
		nDWORDS++;
	}

	if (fvfData.dwXYZMask)
	{
		flags |= VERTSXYZ;
		nDWORDS += 3;
	}

	if (fvfData.dwRHWMask)
	{
		if (pdwData[nDWORDS] == 0.0f)
		{
			nvStatLogError(NVDBG_LEVEL_ERROR, "RHW = 0.0f, it should equal 1.0f");
		}
		flags |= VERTSRHW;
		nDWORDS++;
	}

	nvStatWriteLogOpCode(nDWORDS+3, D3D_LOG_DX7_PRIMITIVES);
	nvStatWriteLogData(1, &flags);
	nvStatWriteLogData(1, &nUserUVS);
	nvStatWriteLogData(nDWORDS, pdwData);
#endif
}

void __stdcall nvKelvinDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress)
{
#if 0
    static DWORD  dwVertexCount = 0;
           DWORD *pdwData       = ((DWORD*)dwPutAddress) + 1;

	if (DXStatTickPtr == NULL)
		return;

	if (!(DXStatTickPtr->logFormat & (LOG_MEDIUM_BIT | LOG_MAXIMUM_BIT)))
		return;

    if (DXStatTickPtr->logFormat & LOG_MEDIUM_BIT)
    {
        dwVertexCount ++;

        DPF ("Vertex %d",dwVertexCount);

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT])) {
            DPF ("         B = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL])) {
            DPF ("    Normal = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
            DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
            pdwData += 3;
        }

        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(1)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 8) & 0xff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV1[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(0)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV0[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])){
            DPF ("  Specular = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
            DPF ("   Diffuse = %08x",pdwData[0]);
            pdwData += 1;
        }

        nvAssert (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]));
        DPF ("       XYZ = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
        DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
        pdwData += 3;

        if (pContext->hwState.pVertexShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD)) {
            DPF ("       RHW = %f [%08x]", FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
            pdwData += 1;
        }
        DPF ("");
    }
#endif
}

//======================================================================
// Function:	nvStatLogVertexData
// Description:	Log an error to the log file
// Parameters:	dx6 = flag indicating dx6 or not
//				pVertex = pointer to vertex data to dump to log file
// Returns:		.
//======================================================================
void nvStatLogVertexData(BOOL dx6, DWORD *pVertex)
{
	if (DXStatTickPtr == NULL)
		return;

	if (!(DXStatTickPtr->logFormat & LOG_MAXIMUM_BIT))
		return;

	if (DXStatTickPtr->logFull)
		return;

	if (dx6)
	{
		nvStatWriteLogOpCode(11, D3D_LOG_DX6_PRIMITIVES);
		nvStatWriteLogData(10, pVertex);
	}
	else
	{
		nvStatWriteLogOpCode(9, D3D_LOG_DX5_PRIMITIVES);
		nvStatWriteLogData(8, pVertex);
	}
}

//======================================================================
// Function:	NVStatLogMedium
// Description:	Log medium amount of data depending on log opcode
// Parameters:	pContext = pointer to context for this DX module
//				DXFunction = enumeration number of function
// Returns:		.
//======================================================================
void NVStatLogMedium(DWORD DXFunction, DWORD value)
{
	DWORD opCode;


	if ((DXFunction >= START_RENDER_STATE) && (DXFunction <= END_RENDER_STATE))
	{
		opCode = DXFunction|D3D_LOG_PARAMETERS;
		nvStatWriteLogOpCode(2, opCode);
		nvStatWriteLogData(1, &value);
	}

	if (nvStatLockIndex != NVSTAT_LOCK_UNKNOWN)
	{
		opCode = D3D_LOG_LOCK_INDEX|D3D_LOG_PARAMETERS;
		nvStatWriteLogOpCode (2, opCode);
		nvStatWriteLogData(1, (DWORD *)&nvStatLockIndex);
		nvStatLockIndex = NVSTAT_LOCK_UNKNOWN;
	}
}

//======================================================================
// Function:	NVStatLogMaximum
// Description:	Log maximum amount of data depending on log opcode
// Parameters:	pContext = pointer to context for this DX module
//				DXFunction = enumeration number of function
// Returns:		.
//======================================================================
void NVStatLogMaximum(DWORD DXFunction, DWORD value)
{
	NVStatLogMedium(DXFunction, value);

	// add more dumping here...???
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\ddFlip.cpp ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
* Module: ddFlip.cpp                                                        *
*                                                                           *
*****************************************************************************
*  Content:    DirectDraw HAL surface flipping support
*                                                                           *
* History:                                                                  *
*       schaefer           7/6/99                                           *
*                                                                           *
\***************************************************************************/

#include "nvprecomp.h"
#include "wincommon.h"

extern DWORD __stdcall ConvertOverlay32 ( LPDDRAWI_DDRAWSURFACE_LCL, BOOL waitForCompletion, LPDWORD lpDstYOffset);

extern BOOL pmAddProcess(GLOBALDATA *pDriverData, DWORD processID);
extern BOOL pmDeleteProcess(DWORD processID);

extern BOOL ResetTwinViewState(GLOBALDATA *pDriverData);

//---------------------------------------------------------------------------

inline DWORD getFlipCountNotifier()
{
    // since the notifier buffers are used for alternate flips,
    // each notifier buffer will increment in steps of two.
    // we must check both and return the larger of the two

    // in the multihead case, there are also two dac objects.
    // in clone mode we must wait for both dacs to finish,
    // so we use the smaller of the two dac object notifiers

    if ((pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) ||
        (pDriverData->dwDesktopState == NVTWINVIEW_STATE_SPAN))
    {
        NvNotification *pNotifierFlat1 = &pDriverData->pDmaFlipPrimaryNotifierFlat[0 * 16]; // head 0
        NvNotification *pNotifierFlat2 = &pDriverData->pDmaFlipPrimaryNotifierFlat[1 * 16]; // head 1
        DWORD dwCount1 = max(pNotifierFlat1[1].info32, pNotifierFlat1[2].info32);
        DWORD dwCount2 = max(pNotifierFlat2[1].info32, pNotifierFlat2[2].info32);

        return min(dwCount1, dwCount2);
    }
    else
    {
        DWORD dwHead = GET_CURRENT_HEAD();
        NvNotification *pNotifierFlat = &pDriverData->pDmaFlipPrimaryNotifierFlat[dwHead * 16];

        return max(pNotifierFlat[1].info32, pNotifierFlat[2].info32);
    }
}

//---------------------------------------------------------------------------

/*
 * getFlipStatusPrimary
 *
 * Checks if the most recent flip on the given primary surface has completed.
 * If the given primary is 0, checks for pending flips on any surface
 */

HRESULT __stdcall getFlipStatusPrimary (FLATPTR fpVidMem)
{

#if (NVARCH >= 0x010) && defined(HWFLIP)

    DWORD dwCurrentIndex, dwIndex;

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_FAMILY_KELVIN))
#else
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS))
#endif
    {
        DWORD dwQueuedFlips, dwFlipCountNotifier;

        dwFlipCountNotifier = getFlipCountNotifier();
        if (CURRENT_FLIP >= dwFlipCountNotifier) {
            dwQueuedFlips = CURRENT_FLIP - dwFlipCountNotifier;
        }
        else { // handle the wrap around case
            dwQueuedFlips = dwFlipCountNotifier - CURRENT_FLIP;
        }

        if (dwQueuedFlips && (fpVidMem == FLIP_ANYSURFACE))
            return DDERR_WASSTILLDRAWING;

        dwCurrentIndex = getDC()->flipHistory.dwIndex;
        for (DWORD i = 0; i < dwQueuedFlips; i++) {
            dwIndex = (dwCurrentIndex - i) & FLIP_HISTORY_MASK;
#ifdef CHECK_FLIP_TO
            if ((getDC()->flipHistory.surfacesFrom[dwIndex] == fpVidMem) ||
                (getDC()->flipHistory.surfacesTo[dwIndex]   == fpVidMem)) {
        return (DDERR_WASSTILLDRAWING);
            }
#else
            if (getDC()->flipHistory.surfacesFrom[dwIndex] == fpVidMem) {
                return (DDERR_WASSTILLDRAWING);
            }
#endif
        }

        return (DD_OK);
    }

#endif  // HWFLIP

    /*
     * see if a flip has happened recently
     */
    if (getDC()->flipPrimaryRecord.bFlipFlag &&
        ((fpVidMem == FLIP_ANYSURFACE) || (fpVidMem == getDC()->flipPrimaryRecord.fpFlipFrom)) ) {

        NvNotification *pDmaFlipPrimaryNotifier = pDriverData->pDmaFlipPrimaryNotifierFlat;

        // D3D: if VSYNC is forced off, we always advertise that flips have completed
        //      this can break ddraw apps and maybe even fail WHQL - therefore
        //      we do not recommend VSYNC ever be disabled by default
        if (getDC()->nvD3DRegistryData.regVSyncMode == D3D_REG_VSYNCMODE_FORCEOFF) {
            return DD_OK;
        }

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_5) {
            if (((volatile)pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                ((volatile)pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS))
                return (DDERR_WASSTILLDRAWING);
            else {
                pDriverData->CurrentVisibleSurfaceAddress = getDC()->flipPrimaryRecord.fpFlipTo;
                getDC()->flipPrimaryRecord.bFlipFlag = FALSE;
                return (DD_OK);
            }
        }
        else {
            NvNotification *pDmaSyncNotifier = pDriverData->pDmaSyncNotifierFlat;
            /* pDmaSyncNotifier is used for NOVSYNC flips for devices < NV5 */
            if (((volatile)pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                ((volatile)pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS) ||
                ((pDriverData->fIsBltStyleFlip) &&
                 (pDmaSyncNotifier->status == NV_IN_PROGRESS)))
                return (DDERR_WASSTILLDRAWING);
            else {
                pDriverData->CurrentVisibleSurfaceAddress = getDC()->flipPrimaryRecord.fpFlipTo;
                getDC()->flipPrimaryRecord.bFlipFlag = FALSE;
                return (DD_OK);
            }
        }
    }

    return (DD_OK);

} // getFlipStatusPrimary

//---------------------------------------------------------------------------

/*
 * getFrameStatusOverlay
 *
 * Checks if the most recent flip on the given overlay surface has occurred
 */

HRESULT __stdcall getFlipStatusOverlay (FLATPTR fpVidMem)
{
    int iIndex;

    if (getDC()->flipOverlayRecord.bFlipFlag &&
        ((fpVidMem == FLIP_ANYSURFACE) ||
         (fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) ||
         (fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom)) ) {

        NvNotification *pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;

        if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
            if (fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom) {
                // only need for one to flush out
                iIndex = pDriverData->vpp.overlayBufferIndex + 1;
                if (pPioFlipOverlayNotifier[iIndex].status == NV_IN_PROGRESS)
                    return (DDERR_WASSTILLDRAWING);
            } else {
                // need to wait for both flips to flush out
                if (((volatile)pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) ||
                    ((volatile)pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                    return (DDERR_WASSTILLDRAWING);
                } else {
                    getDC()->flipOverlayRecord.bFlipFlag = FALSE;
                }
            }
        } else {
            if (fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom) {
/* The WHQL flip status test doesn't like this conservatism.  Comment out for now.
                LONGLONG timeNow;
                // only need for one to flush out, no way to really determine this on NV10,
                // but if we wait at least one CRTC refresh since it was issued, we can
                // guarantee it has been flushed through
                if ((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                    (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                    QueryPerformanceCounter((LARGE_INTEGER *) &timeNow);
                    if ((timeNow - getDC()->flipOverlayRecord.llFlipTime) < (getDC()->flipPrimaryRecord.dwFlipDuration * 2)) {
                        return (DDERR_WASSTILLDRAWING);
                    }
                }
*/
            } else {
                if (fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) {
                    LONGLONG timeNow = 0x7FFFFFFFFFFFFFFF;
                    DWORD    dwTimeoutCount;

                    // We use different timeout values for 640x480 and higher res modes.
                    if (GET_MODE_HEIGHT() <= 480)
                        dwTimeoutCount = 4;
                    else
                        dwTimeoutCount = 16;

                    // need to wait for both flips to flush out
                    if (((volatile)pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                        ((volatile)pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                        LONGLONG timeNow = 0x7FFFFFFFFFFFFFFF;

                        // If notifiers don't get set for two CRTC refresh times, time out and return success.
                        QueryPerformanceCounter((LARGE_INTEGER *) &timeNow);
                        if ((timeNow - getDC()->flipOverlayRecord.llFlipTime) < (getDC()->flipPrimaryRecord.dwFlipDuration * dwTimeoutCount)) {
                            return (DDERR_WASSTILLDRAWING);
                        }
                        else {
                            getDC()->flipOverlayRecord.bFlipFlag = FALSE;

                            // Reset notifiers that may be stuck.
                            pPioFlipOverlayNotifier[1].status = 0;
                            pPioFlipOverlayNotifier[2].status = 0;
                        }
                    } else {
                        getDC()->flipOverlayRecord.bFlipFlag = FALSE;
                    }
                }
            }
        }
        return (DD_OK);
    }

    return (DD_OK);

} // getFrameStatusOverlay

//---------------------------------------------------------------------------

// update frame status on surface of indeterminate type

HRESULT __stdcall getFlipStatus (FLATPTR fpVidMem, DWORD dwType)
{
    if (dwType & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT)) {
        return getFlipStatusOverlay (fpVidMem);
    }
    else {
        return getFlipStatusPrimary (fpVidMem);
    }
}

//---------------------------------------------------------------------------

// GetFlipStatus32

DWORD __stdcall GetFlipStatus32 (LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    nvSetDriverDataPtrFromDDGbl (lpGetFlipStatus->lpDD);

    // validate device
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        NvReleaseSemaphore(pDriverData);
        lpGetFlipStatus->ddRVal = DDERR_SURFACELOST;
        return (DDHAL_DRIVER_HANDLED);
    }

    // validate flags
    DWORD dwFlagsAll = (DDGFS_CANFLIP | DDGFS_ISFLIPDONE);
    DWORD dwFlagsSet = lpGetFlipStatus->dwFlags & dwFlagsAll;
    if ((dwFlagsSet == 0) || (dwFlagsSet == dwFlagsAll)) {
        DPF ("invalid params in GetBlitStatus32");
        NvReleaseSemaphore(pDriverData);
        lpGetFlipStatus->ddRVal = DDERR_INVALIDPARAMS;
        return (DDHAL_DRIVER_HANDLED);
    }

    if (dwFlagsSet & DDGFS_CANFLIP) {

        if (lpGetFlipStatus->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT)) {

            // handle overlays and videoports
            LPPROCESSINFO lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());
            if ((IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hOvlFlipEvenEvent3, 0))) &&
                (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hOvlFlipOddEvent3, 0)))) {
                lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
            }
            /*
            NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;
            iIndex = pDriverData->OverlayBufferIndex + 1;
            if (pPioFlipOverlayNotifier[iIndex].status == NV_IN_PROGRESS)
                lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;  */

        }

        else {

            // get flip status for the primary
#if (NVARCH >= 0x010) && defined(HWFLIP)
#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_FAMILY_KELVIN))
#else
            if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS))
#endif
            {
                // with nv15 (etc), we can always flip
                lpGetFlipStatus->ddRVal = DD_OK;
            }
            else
#endif  // HWFLIP
            {
                // make sure we sync with other channels before writing put
                getDC()->nvPusher.setSyncChannelFlag();
                if (getDC()->nvPusher.isIdle(TRUE)) {
                    lpGetFlipStatus->ddRVal = DD_OK;
                }
                else {
                    nvPusherStart (TRUE);
                    lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
                }
            }
        }
    }

    else {  // DDGFS_ISFLIPDONE

        // simply get flip status
        lpGetFlipStatus->ddRVal = getFlipStatus (lpGetFlipStatus->lpDDSurface->lpGbl->fpVidMem,
                                                 lpGetFlipStatus->lpDDSurface->ddsCaps.dwCaps);

        // OLD CODE FOR OVERLAYS ONLY:
        // (current thinking is that getFrameStatus always works)
        /*
                NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;
                if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
                {
                    if (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                        (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) &&
                        ((fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom) ||
                         (fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) ||
                         (fpVidMem == getDC()->flipOverlayRecord.fpFlipTo) ||
                         (fpVidMem == NULL)))
                        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
                }
                else
                {
                    if (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) ||
                         (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) &&
                        ((fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom) ||
                         (fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) ||
                         (fpVidMem == getDC()->flipOverlayRecord.fpFlipTo) ||
                         (fpVidMem == NULL)))
                        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
                }
    */

    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} // GetFlipStatus32

//---------------------------------------------------------------------------

// Check how many frames we are ahead
// we want to limit this since we have serious lag effect on fast CPUs.
// if we're too many frames ahead, we wait.
// free count for d3d stuff must be accurate

void nvCheckQueuedFlips (void)
{
    // max queued frames is regPreRenderLimit (defaults to 3 - PC99 spec)
    DWORD dwMaxQueuedFrames = getDC()->nvD3DRegistryData.regPreRenderLimit;

    // get HW frame #
    COMPLETED_FLIP = getFlipCountNotifier();

    // have we progressed too far?
    while (int(CURRENT_FLIP - COMPLETED_FLIP) > int(dwMaxQueuedFrames))
    {
        // kick off buffer
        nvPusherStart (TRUE);
        // wait for HW to catch up
        nvDelay();
        COMPLETED_FLIP = getFlipCountNotifier();
    }
}

//---------------------------------------------------------------------------

void nvUpdateFlipTracker (DWORD dwSurfaceFrom, DWORD dwSurfaceTo)
{
    // make a note of the fact that we've queued a flip or blit involving these surfaces
    getDC()->flipHistory.dwIndex ++;
    getDC()->flipHistory.dwIndex &= FLIP_HISTORY_MASK;
    getDC()->flipHistory.surfacesFrom[getDC()->flipHistory.dwIndex] = dwSurfaceFrom;
#ifdef CHECK_FLIP_TO
    getDC()->flipHistory.surfacesTo[getDC()->flipHistory.dwIndex]   = dwSurfaceTo;
#endif
    // update frame counters
    CURRENT_FLIP ++;
}

//---------------------------------------------------------------------------

// do a blit instead of a flip

void nvFlipBlit (LPDDHAL_FLIPDATA pfd)
{
    NvNotification *pDmaSyncNotifier = pDriverData->pDmaSyncNotifierFlat;

    DWORD dwSrcOffset = (DWORD)pfd->lpSurfTarg->lpGbl->fpVidMem - (DWORD)pDriverData->BaseAddress;
    DWORD dwDstOffset = (DWORD)pfd->lpSurfCurr->lpGbl->fpVidMem - (DWORD)pDriverData->BaseAddress;
    DWORD dwPitch     = (pfd->lpSurfTarg->lpGbl->lPitch  << 16) | pfd->lpSurfCurr->lpGbl->lPitch;
    DWORD dwDims      = (pfd->lpSurfCurr->lpGbl->wHeight << 16) | pfd->lpSurfCurr->lpGbl->wWidth;

    if (dwDstOffset == dwSrcOffset) dwDstOffset = 0;

    if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

        nvPushData (0,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        nvPushData (1,NV_DD_IMAGE_BLACK_RECTANGLE);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_SURFACES) + IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000);
        nvPushData (3,0);
        nvPushData (4,asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP));
        nvPushData (5,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        nvPushData (6,NV_DD_SURFACES_2D);

        nvPusherAdjust (7);
        nvPusherStart  (TRUE);

        pDriverData->dwSharedClipChangeCount++;

        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
    }

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) + SET_ROP_OFFSET | 0x40000);
    nvPushData (1,SRCCOPYINDEX);
    pDriverData->bltData.dwLastRop = SRCCOPYINDEX;

    nvPushData (2,dDrawSubchannelOffset(NV_DD_SURFACES) + SURFACES_2D_PITCH_OFFSET | 0xC0000);
    nvPushData (3,dwPitch);
    nvPushData (4,dwSrcOffset);
    nvPushData (5,dwDstOffset);
    pDriverData->bltData.dwLastCombinedPitch = dwPitch;
    pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
    pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    nvPushData (6,dDrawSubchannelOffset(NV_DD_BLIT) + BLIT_POINT_IN_OFFSET | 0xC0000);
    nvPushData (7,0);
    nvPushData (8,0);
    nvPushData (9,dwDims);

    nvPusherAdjust (10);

    if (pfd->dwFlags & DDFLIP_NOVSYNC) {

        getDC()->flipPrimaryRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        getDC()->flipPrimaryRecord.fpFlipTo = pfd->lpSurfTarg->lpGbl->fpVidMem;
        getDC()->flipPrimaryRecord.bFlipFlag = TRUE;
        pDriverData->fIsBltStyleFlip = TRUE;

        pDmaSyncNotifier->status = NV_IN_PROGRESS;

        nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
        nvPushData (1,0);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
        nvPushData (3,0);

        nvPusherAdjust (4);
    }

    nvUpdateFlipTracker (pfd->lpSurfCurr->lpGbl->fpVidMem, pfd->lpSurfTarg->lpGbl->fpVidMem);

    nvPusherStart (TRUE);

    // flip the vidmem pointers (so ddraw can flip them back)
    pfd->lpSurfCurr->lpGbl->fpVidMem = dwSrcOffset + (DWORD)pDriverData->BaseAddress;
    pfd->lpSurfTarg->lpGbl->fpVidMem = dwDstOffset + (DWORD)pDriverData->BaseAddress;

}

//---------------------------------------------------------------------------

void nvFlipPrimary (LPDDHAL_FLIPDATA pfd, BOOL bNoVSync)
{
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfTarg_gbl;

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        pfd->ddRVal = DDERR_SURFACELOST;
        return;
    }

    pSurfTarg_gbl = pfd->lpSurfTarg->lpGbl;

    // assume OK unless we find otherwise
    pfd->ddRVal = DD_OK;

#if (NVARCH >= 0x010) && defined(HWFLIP)

#if (NVARCH >= 0x020)

#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        getDC()->nvFlipper.flip (&(getDC()->nvPusher), &(getDC()->nvPusherDAC),
                                 pfd->lpSurfCurr, pfd->lpSurfTarg, bNoVSync);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS)) {
#else // !KELVIN_SEMAPHORES
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
#endif // !KELVIN_SEMAPHORES

#else // !(NVARCH >= 0x020)

    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS)) {

#endif // !(NVARCH >= 0x020)

        // tell the HW we want to start writing to the next buffer
        nvglSetNv15CelsiusSyncIncWrite (NV_DD_CELSIUS);

        // a bug in the HW requires a no-op here. otherwise the stall may
        // get processed before the write actually gets done.
        nvglSetNv10CelsiusNoOp (NV_DD_CELSIUS);

        PRIMARY_BUFFER_INDEX ^= 0x1;

        BOOL  bCloneMode = (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE);
        BOOL  bSpanMode  = (pDriverData->dwDesktopState == NVTWINVIEW_STATE_SPAN);
        DWORD dwNumHeads = (bCloneMode || bSpanMode) ? pDriverData->dwHeads : 1;
        DWORD dwFormat   = (NV07C_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31) |
                           (NV07C_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP << 25) |
                           pSurfTarg_gbl->lPitch;
        dwFormat |= bNoVSync   ? (NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY << 20) :
                                 (NV07C_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER << 20);
        dwFormat |= (bCloneMode || bSpanMode) ? (NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_ENABLED << 24) :
                                                (NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_DISABLED << 24);

        for (DWORD dwLogicalHead = 0; dwLogicalHead < dwNumHeads; dwLogicalHead++) {
            // calculate offset, the RM will add the pan & scan adjustment from the display driver if needed
            DWORD dwOffset = pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress;
#ifdef WINNT
            DWORD dwDAC          = NV_DD_VIDEO_LUT_CURSOR_DAC;
            DWORD dwPhysicalHead = ppdev->ulDeviceDisplay[dwLogicalHead];
#else // !WINNT
            DWORD dwDAC          = NV_DD_VIDEO_LUT_CURSOR_DAC + (bCloneMode ? 0 : GET_CURRENT_HEAD());
            DWORD dwPhysicalHead = dwLogicalHead;
#endif // !WINNT

            if (bSpanMode) {
                // add the span mode offset
                dwOffset += GET_SPAN_OFFSET(dwPhysicalHead);
            }

            // program the flip
            nvglSetObject (NV_DD_SURFACES, dwDAC + dwPhysicalHead); // load the DAC object
            nvglSetNv15VideoLUTCursorDACImageData (NV_DD_SURFACES, PRIMARY_BUFFER_INDEX, dwOffset , dwFormat);
        }

        // stall the graphics pipe until we've flipped away from the buffer we want to write to
        nvglSetNv15CelsiusSyncStall (NV_DD_CELSIUS);

        // put back the NV_DD_SURFACES_2D object
        nvglSetObject (NV_DD_SURFACES, NV_DD_SURFACES_2D);
    }

    else
#endif  // HWFLIP
    {
        NvNotification *pDmaSyncNotifier        = pDriverData->pDmaSyncNotifierFlat;
        NvNotification *pDmaFlipPrimaryNotifier = pDriverData->pDmaFlipPrimaryNotifierFlat;

        // find out if any previous flips are still pending
        HRESULT ddrval = getFlipStatusPrimary (FLIP_ANYSURFACE);

        if (ddrval != DD_OK) {
            // flush the push buffer if we haven't yet done so for this particular flip
            if (!(pDriverData->fDmaPushBufferHasBeenFlushed)) {

                // make sure we sync with other channels before writing put
                getDC()->nvPusher.setSyncChannelFlag();

                // Let D3D code know that we have touched NV
                pDriverData->TwoDRenderingOccurred = 1;

                pDmaSyncNotifier->status = NV_IN_PROGRESS;
                nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
                nvPushData (1,0);
                nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
                nvPushData (3,0);

                nvPusherAdjust (4);
                nvPusherStart  (TRUE);

                pDriverData->fDmaPushBufferHasBeenFlushed = TRUE;
            }

            // if we've been instructed to wait, wait until we can do the flip and proceed
            // otherwise, just return the failure (the app will try again)
            if (pfd->dwFlags & DDFLIP_WAIT) {
                while (ddrval != DD_OK) {
                    NV_SLEEPFLIP;
                    ddrval = getFlipStatusPrimary(FLIP_ANYSURFACE);
                }
            }
            else {
                pfd->ddRVal = ddrval;
                return;
            }

        }

        // make sure we sync with other channels before writing put
        getDC()->nvPusher.setSyncChannelFlag();

        // we do not want this flip to wait for itself
        getDC()->nvPusher.clearSyncFlipFlag();

        PRIMARY_BUFFER_INDEX ^= 0x1;

        if (!bNoVSync) {
            pDmaFlipPrimaryNotifier[PRIMARY_BUFFER_INDEX + 1].status = NV_IN_PROGRESS;
        }

        // Temporarily load VIDEO_LUT_CURSOR_DAC object
        nvPushData (0,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        nvPushData (1,NV_DD_VIDEO_LUT_CURSOR_DAC);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_SURFACES) + NV067_SET_IMAGE_OFFSET(PRIMARY_BUFFER_INDEX) | 0x80000);
        nvPushData (3,pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress);
        if (bNoVSync) {
            nvPushData (4,(NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31) |
                          (NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY << 20)  |
                          pSurfTarg_gbl->lPitch);
        }
        else {
            nvPushData (4,(NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31)      |
                          (NV067_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER << 20) |
                          pSurfTarg_gbl->lPitch);
        }
        // put back the NV_DD_SURFACES2D object
        nvPushData (5,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        nvPushData (6,NV_DD_SURFACES_2D);

        nvPusherAdjust (7);

        getDC()->flipPrimaryRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        getDC()->flipPrimaryRecord.fpFlipTo   = pSurfTarg_gbl->fpVidMem;
        getDC()->flipPrimaryRecord.bFlipFlag  = TRUE;

        pDriverData->fDmaPushBufferHasBeenFlushed = FALSE;
    }

    // make a note of the fact that we've advanced a frame
    nvUpdateFlipTracker (pfd->lpSurfCurr->lpGbl->fpVidMem, pfd->lpSurfTarg->lpGbl->fpVidMem);

    // get things started
    nvPusherStart (TRUE);
#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
#ifdef NV_PROFILE_PUSHER
        nvpSetLogPusher(false);
#endif
        getDC()->nvPusherDAC.start (TRUE);
#ifdef NV_PROFILE_PUSHER
        nvpSetLogPusher(true);
#endif
    }
#endif
#endif

    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "nvFlipPrimary: RGB Flip request completed successfully");
}

//---------------------------------------------------------------------------

/* NOTES:
 *
 * When flipping overlay surfaces NOT associated with a video port
 * the surface will be flipped according to the following criteria.
 * DDOVER_INTERLEAVED and DDOVER_BOB values used are those set on most
 * recent UpdateOverlay32 call referencing this overlay surface.
 *
 *  DDOVER_INTERLEAVED  DDOVER_BOB  DDFLIP_EVEN DDFLIP_ODD  DISPLAYED
 *
 *          1               1            1          0       Even field
 *          1               1            X          1       Odd field with BOB
 *          1               1            0          0       Full interleaved surface
 *          1               0            1          0       Even field
 *          1               0            X          1       Odd field
 *          1               0            0          0       Full interleaved surface
 *          0               1            X          X       Full non-interleaved surface
 *          0               0            X          X       Full non-interleaved surface
 */

void nvFlipOverlay (LPDDHAL_FLIPDATA pfd)
{
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfTarg;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfTarg_gbl;

    DWORD   dwVPPFlags;
#ifndef WINNT
    DWORD   dwSavedNBData;
#endif
    HRESULT ddrval;

    dbgTracePush ("nvFlipOverlay");

    lpSurfTarg    = pfd->lpSurfTarg;
    pSurfTarg_gbl = lpSurfTarg->lpGbl;

    // presume OK unless we find otherwise
    pfd->ddRVal = DD_OK;

#ifdef WINNT
    // WIN2K HACK: DX7 under win2k presents incorrect flags, so manually fix them
    if (pfd->lpSurfCurr) {
        pfd->lpSurfCurr->ddsCaps.dwCaps &= ~(DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER);
        pfd->lpSurfCurr->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
    }
    lpSurfTarg->ddsCaps.dwCaps |= DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER;
    lpSurfTarg->ddsCaps.dwCaps &= ~DDSCAPS_BACKBUFFER;

    // WIN2K HACK: More flags that aren't set properly by Win2K DX7:
    // dwOverlayFlags may have Bob and Interleaved flags set for some overlay buffers in
    // the flip chain but not others.  We need to fix them for Bob mode to work later on.
    if ((lpSurfTarg->lpGbl->ddpfSurface.dwFourCC == FOURCC_NV12) && (lpSurfTarg->lpSurfMore)) {
        if (pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
            pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags |= DDOVER_INTERLEAVED;
            pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags |= DDOVER_BOB;
        }
        else {
            pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags &= ~DDOVER_INTERLEAVED;
            pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags &= ~DDOVER_BOB;
        }
    }

#endif WINNT

    pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL = (DWORD) lpSurfTarg;
    pDriverData->vpp.dwOverlayLastVisibleFpVidMem = pSurfTarg_gbl->fpVidMem;
    pDriverData->vpp.dwOverlayLastVisiblePitch = pSurfTarg_gbl->lPitch;
    pDriverData->vpp.dwOverlayLastVisiblePixelFormat = pSurfTarg_gbl->ddpfSurface.dwFourCC;

    if (pDriverData->vpp.dwOverlayFSHead == 0xFFFFFFFE &&
        pDriverData->vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pHWCrtcCX == 0) {
        // TwinView state has changed while video mirror enabled, make the app reinstantiate the overlay
        pfd->ddRVal = DDERR_SURFACELOST;
    }

    // Do some DirectShow compatibility stuff
    if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NVMC) {
#if (NVARCH >= 0x10)
        dbgTracePop();
        return;
#endif  // NVARCH >= 0x10
    }

    else if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NV12) || (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NVDS)) {

        LPNVMCSURFACEFLAGS lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

#if (NVARCH >= 0x10)

        if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NVDS) {
            LPNVMCFRAMEDATA lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(pSurfTarg_gbl->fpVidMem);
            DWORD dwIndex = lpNvMCFrameData->bMCDestinationSurfaceIndex;
            if (dwIndex >= 8) {
                dbgTracePop();
                return;
            }
            lpSurfTarg = (LPDDRAWI_DDRAWSURFACE_LCL)(pDriverData->dwMCNV12Surface[dwIndex]);
            pSurfTarg_gbl = lpSurfTarg->lpGbl;

            // Check for mode switches and full screen DOS interruptions
            if (pDriverData->dwMCDestinationSurface == 0) {
                pfd->ddRVal = DDERR_SURFACELOST;
                dbgTracePop();
                return;
            }
        }

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != pSurfTarg_gbl->fpVidMem)) {
            lpSurfaceFlags++;
        }

        // If this is an NV12 surface and DXVA Back End alpha blending is enabled,
        // perform an alpha blend operation on this frame.
        if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NV12) &&
            (pDriverData->dwDXVAFlags & DXVA_BACK_END_ALPHA_ENABLED) &&
            pDriverData->dwMCNVMCSurface) {

            // Make sure you only blend each frame once -- in Bob mode we get two Flips per frame.
            if (lpSurfaceFlags->bMCFrameIsComposited == FALSE) {
                nvDXVABackEndAlphaBlend(lpSurfTarg->lpGbl->fpVidMem);
                lpSurfaceFlags->bMCFrameIsComposited = TRUE;
            }
        }

        // Make sure the surface has been format converted
        if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
            (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
            nvMoCompConvertSurfaceFormat(pSurfTarg_gbl->fpVidMem, TRUE, 15);
        else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) &&
            ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3))
            nvMoCompConvertSurfaceFormat(pSurfTarg_gbl->fpVidMem, TRUE, 3);
        else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
            (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 12))
            nvMoCompConvertSurfaceFormat(pSurfTarg_gbl->fpVidMem, TRUE, 12);

        if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
            (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
            (lpSurfaceFlags->bMCFrameIsComposited == FALSE) &&
            (pDriverData->bMCTemporalFilterDisabled == FALSE) &&
            ((pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN)) != 0))
            nvMoCompTemporalFilter(pSurfTarg_gbl->fpVidMem, pDriverData->bMCPercentCurrentField);

#endif  // NVARCH >= 0x10

        if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
            pfd->ddRVal = DDERR_SURFACELOST;
            dbgTracePop();
            return;
        }

        // Wait for the surface to finish format conversion.
        getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                       lpSurfaceFlags->dwMCFormatCnvReferenceCount);

        // If this is a composited surface, wait for it to finish compositing.
        if (lpSurfaceFlags->bMCFrameIsComposited) {
            getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                      lpSurfaceFlags->dwMCCompositeReferenceCount);
        }

        // If this is a filtered surface, wait for it to finish filtering.
        if (lpSurfaceFlags->bMCFrameIsFiltered) {
            getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                           lpSurfaceFlags->dwMCTemporalFilterReferenceCount);
        }

        // Check if filtering is disabled on this surface for this display call only
        if (lpSurfaceFlags->bMCFrameType & TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE) {
            lpSurfaceFlags->bMCFrameIsFiltered = FALSE;
            lpSurfaceFlags->bMCFrameType &= ~TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE;
        }

        // Always display non-filtered portion of non-interleaved frames
        if ((pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN)) == 0) {
            if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME)
                lpSurfaceFlags->bMCFrameIsFiltered = FALSE;
        }
    }

    if ((getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) ||
        pDriverData->vpp.dwOverlayFSOvlLost) {
        pfd->ddRVal = DDERR_SURFACELOST;
        dbgTracePop();
        return;
    }

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvDDrawRecover();
        }
        else {
            pfd->ddRVal = DDERR_SURFACEBUSY;
            dbgTracePop();
            return;
        }
    }

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // turn off write posting
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, 0
                in  al, dx
                mov dwSavedNBData, eax
                and eax, 0FFFFFF7Fh
                out dx, al
        }
    }
#endif

    /* Limit flips to 1 at a time to work around NV4 RM limitation */
    ddrval = getFlipStatusOverlay (pSurfTarg_gbl->fpVidMem);

    /* Only reject flip requests when flipping frames (but allow fields to proceed) */
    if ((pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN)) == 0) {
        if (ddrval != DD_OK) {
            if (pfd->dwFlags & DDFLIP_WAIT) {
                while (ddrval != DD_OK) {
                    LPPROCESSINFO lpProcInfo = pmGetProcess (pDriverData, GetCurrentProcessId());
                    if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hOvlFlipEvenEvent3, VPP_TIMEOUT_TIME))) {
                        EVENT_ERROR;
                    }
                    if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hOvlFlipOddEvent3, VPP_TIMEOUT_TIME))) {
                        EVENT_ERROR;
                    }
                    ddrval = getFlipStatusOverlay (pSurfTarg_gbl->fpVidMem);
                }
            }

            else {
                pfd->ddRVal = ddrval;
#ifndef WINNT
                // check for VIA 82C598 north bridge
                if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
                    // restore write posting value
                    _asm {
                            mov edx, 0cf8h
                            mov eax, 80000840h
                            out dx, eax
                            mov edx, 0cfch
                            mov eax, dwSavedNBData
                            out dx, al
                    }
                }
#endif
                dbgTracePop();
                return;
            }
        }

    } else if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NV12) {
        if (ddrval != DD_OK) {
            NV_SLEEPFLIP;
            pfd->ddRVal = ddrval;
            dbgTracePop();
            return;
        }
    }

    /*
     * make sure we sync with other channels before writing put
     */
    getDC()->nvPusher.setSyncChannelFlag();

    dwVPPFlags = VPP_ALL;
    if ((pfd->lpSurfTarg->lpGbl->ddpfSurface.dwFourCC == FOURCC_NVDS) && (pfd->lpSurfTarg->lpSurfMore)) {
        if (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED) {
            dwVPPFlags |= VPP_INTERLEAVED;
        }
        if (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB) {
            dwVPPFlags |= VPP_BOB;
        }
    } else if (lpSurfTarg->lpSurfMore) {
        if (lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED) {
            dwVPPFlags |= VPP_INTERLEAVED;
        }
        if (lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB) {
            dwVPPFlags |= VPP_BOB;
        }
    }
    if (pfd->dwFlags & DDFLIP_ODD) {
        dwVPPFlags |= VPP_ODD;
    } else if (pfd->dwFlags & DDFLIP_EVEN) {
        dwVPPFlags |= VPP_EVEN;
    }
    if (lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {
        dwVPPFlags |= VPP_VIDEOPORT;
    }
    if (pfd->dwFlags & DDFLIP_WAIT) {
        dwVPPFlags |= VPP_WAIT;
    }

    // don't call VPP stuff if the Ring0 KMVT stuff is active
    if (pDriverData->bRing0FlippingFlag == FALSE) {
#ifdef DEBUG
#if (NVARCH >= 0x010)
        if ((moCompDebugLevel > 0) && (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NV12)) {
            if (overlaySurfaceBase == 0)
                overlaySurfaceBase = pSurfTarg_gbl->fpVidMem;

            dwVPPFlags &= ~VPP_BOB;
            dwVPPFlags &= ~VPP_EVEN;
            dwVPPFlags &= ~VPP_ODD;

            if (!VppDoFlip(&(pDriverData->vpp),
                                overlaySurfaceBase - pDriverData->BaseAddress,
                               pSurfTarg_gbl->lPitch,
                               pSurfTarg_gbl->wWidth,
                               pSurfTarg_gbl->wHeight,
                               pSurfTarg_gbl->ddpfSurface.dwFourCC,
                               dwVPPFlags)) {
#ifndef WINNT
                // check for VIA 82C598 north bridge
                if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
                    // restore write posting value
                    _asm {
                            mov edx, 0cf8h
                            mov eax, 80000840h
                            out dx, eax
                            mov edx, 0cfch
                            mov eax, dwSavedNBData
                            out dx, al
                    }

                }
#endif
                pfd->ddRVal = DDERR_WASSTILLDRAWING;
                dbgTracePop();
                return;
            }
        }
        else
#endif  // NVARCH >= 0x010
#endif  // DEBUG
        {
            if (!VppDoFlip(&(pDriverData->vpp),
                               pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress,
                               pSurfTarg_gbl->lPitch,
                               pSurfTarg_gbl->wWidth,
                               pSurfTarg_gbl->wHeight,
                               pSurfTarg_gbl->ddpfSurface.dwFourCC,
                               dwVPPFlags)) {
#ifndef WINNT
                // check for VIA 82C598 north bridge
                if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
                    // restore write posting value
                    _asm {
                            mov edx, 0cf8h
                            mov eax, 80000840h
                            out dx, eax
                            mov edx, 0cfch
                            mov eax, dwSavedNBData
                            out dx, al
                    }

                }
#endif
                pfd->ddRVal = DDERR_WASSTILLDRAWING;
                dbgTracePop();
                return;
            }
        }
    }

    getDC()->flipOverlayRecord.llPreviousFlipTime = getDC()->flipOverlayRecord.llFlipTime;
    QueryPerformanceCounter((LARGE_INTEGER *) &getDC()->flipOverlayRecord.llFlipTime);
    getDC()->flipOverlayRecord.fpPreviousFlipFrom = getDC()->flipOverlayRecord.fpFlipFrom;
    getDC()->flipOverlayRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
    getDC()->flipOverlayRecord.fpFlipTo = pSurfTarg_gbl->fpVidMem;

    getDC()->flipOverlayRecord.bFlipFlag = TRUE;

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // restore write posting value
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, dwSavedNBData
                out dx, al
        }
    }
#endif

    dbgTracePop();
}

//---------------------------------------------------------------------------

// Flip32
// Flip RGB or overlay surfaces.

#ifdef NV_PROFILE_DP2OPS
DWORD flags = 0;
#endif

DWORD __stdcall Flip32 (LPDDHAL_FLIPDATA pfd)
{
    dbgTracePush ("Flip32");

    DDSTARTTICK(SURF4_FLIP);
    DDFLIPTICKS(FEFLIP);
#ifdef CNT_TEX
    g_dwFrames++;
#endif
    nvSetDriverDataPtrFromDDGbl (pfd->lpDD);

#ifdef  STEREO_SUPPORT
    StereoFlipNotify(pfd);
#endif  //STEREO_SUPPORT

#ifdef NV_PROFILE_DP2OPS
    if (pDriverData->pBenchmark == NULL) {
        pDriverData->pBenchmark = new CBenchmark;
        pDriverData->pBenchmark->resetData();
    }
    else
        pDriverData->pBenchmark->outputData(flags);
#endif

    /*
     * NOTES:
     *
     * This callback is invoked whenever we are about to flip from
     * one surface to another.   pfd->lpSurfCurr is the surface we were at,
     * pfd->lpSurfTarg is the one we are flipping to.
     *
     * You should point the hardware registers at the new surface, and
     * also keep track of the surface that was flipped away from, so
     * that if the user tries to lock it, you can be sure that it is done
     * being displayed
     */


    DPF_LEVEL(NVDBG_LEVEL_FLIP,"Flip32: curr=%08x, targ=%08x", pfd->lpSurfCurr, pfd->lpSurfTarg );
    DPF_LEVEL(NVDBG_LEVEL_FLIP,"        vidmem ptrs change: %08x->%08x",
              pfd->lpSurfCurr->lpGbl->fpVidMem,
              pfd->lpSurfTarg->lpGbl->fpVidMem );

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_TWINVIEW_STATE_CHANGE) {
        if (pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
            VppDestroyFSMirror(&pDriverData->vpp);
            VppDestroyOverlay(&pDriverData->vpp);
            ResetTwinViewState(pDriverData);
            VppCreateOverlay(&pDriverData->vpp);
            VppCreateFSMirror(&pDriverData->vpp, pDriverData->vpp.dwOverlayFSSrcWidth, pDriverData->vpp.dwOverlayFSSrcHeight);
        } else {
            ResetTwinViewState(pDriverData);
        }
    }

    // front buffer rendering will fake flip
    if (dbgFrontRender)
    {
        DWORD dwTemp = pfd->lpSurfCurr->lpGbl->fpVidMem;
        NvReleaseSemaphore(pDriverData);
        pfd->lpSurfCurr->lpGbl->fpVidMem = pfd->lpSurfTarg->lpGbl->fpVidMem;
        pfd->lpSurfTarg->lpGbl->fpVidMem = dwTemp;
        pfd->ddRVal = DD_OK;
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // figure out whether we should vsync
    BOOL bNoVSyncCapable, bNoVSync;
    bNoVSyncCapable = (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0049_DAC |
                                                                 NVCLASS_0067_DAC |
                                                                 NVCLASS_007C_DAC));
    if (bNoVSyncCapable) {
        switch (getDC()->nvD3DRegistryData.regVSyncMode) {
            case D3D_REG_VSYNCMODE_PASSIVE:
                bNoVSync = (pfd->dwFlags & DDFLIP_NOVSYNC) ? TRUE : FALSE;
                break;
            case D3D_REG_VSYNCMODE_FORCEOFF:
                bNoVSync = TRUE;
                break;
            case D3D_REG_VSYNCMODE_FORCEON:
                bNoVSync = FALSE;
                break;
            default:
                DPF ("unknown VSYNC mode in Flip32");
                dbgD3DError();
                break;
        } // switch
    }
    else {
        bNoVSync = FALSE;
    }

    if (!(pfd->lpSurfTarg->ddsCaps.dwCaps & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT))) {
#if (NVARCH >= 0x010) && defined(HWFLIP)
        if ((bNoVSync)
            ||
            (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS))
#if (NVARCH >= 0x020)
            ||
            (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
#endif  // NVARCH >= 0x020
            )
        {
            nvCheckQueuedFlips ();
        }
#else  // !HWFLIP
        if (bNoVSync)
        {
            nvCheckQueuedFlips ();
        }
#endif  // !HWFLIP
    }

#if (NVARCH >= 0x010)
    // Handle AA: make sure that the regular buffer has updated before flipping
    if (getDC()->dwAAContextCount >= 1)
    {
        CNvObject *pObj = GET_PNVOBJ(pfd->lpSurfTarg);
        if (pObj) {
            PNVD3DCONTEXT pContext;
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                pContext = CKelvinAAState::GetContext(pObj->getSimpleSurface());
            } else {
                pContext = nvCelsiusAAFindContext(pObj->getSimpleSurface());
            }

            if (pContext) {
                pContext->aa.Flip(pContext);
                pContext->kelvinAA.Flip();
            }
        }
    }
#endif  // NVARCH >= 0x010

#ifdef  STEREO_SUPPORT
    StereoBackend(pfd);
#endif  //STEREO_SUPPORT

    // perform flip by either flipping at horz retrace or blt if that is not supported
    if ((bNoVSync) &&
        (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_5))
    {
        // do the blit
        nvFlipBlit (pfd);
        // done
        pfd->ddRVal = DD_OK;
        DDENDTICK(SURF4_FLIP);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // everything is OK, do the flip here
    pDriverData->fIsBltStyleFlip = FALSE;

    if (!(pfd->lpSurfTarg->ddsCaps.dwCaps & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT))) {
        nvFlipPrimary (pfd, bNoVSync);
    }

    else if (pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
        nvFlipOverlay (pfd);
    }

    else {  // Video port flips handled by FlipVideoPort32
        pfd->ddRVal = DDERR_INVALIDSURFACETYPE;
    }

/* DO NOT REMOVE - force flip to be slower than a given speed
    if (getDC()->dwD3DContextCount > 0)
    {
               double maxRefresh = 85.0; // set max refresh rate here
               double microWait  = (1e6/maxRefresh);
               double tick2micro = (1e6/500e6);
        static double last       = 0.0;

        if (last)
        {
            double now;

            do
            {
                __int64 i64;
                __asm
                {
                    _emit 0x0f
                    _emit 0x31
                    mov dword ptr [i64],eax
                    mov dword ptr [i64 + 4],edx
                }
                now = ((double)i64) * tick2micro;
            }
            while ((now - last) < microWait);
            last = now;
        }
        else
        {
            __int64 i64;
            __asm
            {
                _emit 0x0f
                _emit 0x31
                mov dword ptr [i64],eax
                mov dword ptr [i64 + 4],edx
            }
            last = ((double)i64) * tick2micro;
        }
    }
//*/
    dbgFlushType (NVDBG_FLUSH_2D);
    DDENDTICK(SURF4_FLIP);

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} // Flip32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\Global.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: Global.cpp                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History: ?                                                                *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "x86.h"
void ILCCompile_move (DWORD,DWORD,DWORD);

//#pragma data_seg("GLOBAL")
#pragma pack(push,1) // we control alignment

global_struc global={{0}};
DWORD dwDXRuntimeVersion; // version of DirectX runtime installed (inferred from GUIDs)

#pragma pack(pop)

void __stdcall init_globals (void) {

    memset (&g_adapterData, 0, sizeof(g_adapterData));
    memset (&global,        0, sizeof(global));

    // init aligned KNI state
    global.pKNI             = (KATMAI_STATE*)((((DWORD)&global.kni) + 15) & ~15);
    global.pKNI->fFogC1[0]  = global.pKNI->fFogC1[1]
                            = global.pKNI->fFogC1[2]
                            = global.pKNI->fFogC1[3]
                            = 2.0f;
    global.pKNI->fFogC2[0]  = global.pKNI->fFogC2[1]
                            = global.pKNI->fFogC2[2]
                            = global.pKNI->fFogC2[3]
                            = -1.44269504f * (float)0x800000;
    global.pKNI->fZero[0]   = global.pKNI->fZero[1]
                            = global.pKNI->fZero[2]
                            = global.pKNI->fZero[3]
                            = 0.0f;
    global.pKNI->fOne[0]    = global.pKNI->fOne[1]
                            = global.pKNI->fOne[2]
                            = global.pKNI->fOne[3]
                            = 1.0f;
    global.pKNI->f255[0]    = global.pKNI->f255[1]
                            = global.pKNI->f255[2]
                            = global.pKNI->f255[3]
                            = 255.0f;
    global.pKNI->fRHW[3]    = 1.0f;

    global.fCTC1      = 0.5f;

    global.dwILCData  = NULL;
    global.dwILCCount = 0;
    global.dwILCMax   = 0;

#if (NVARCH >= 0x010)
    global.celsius.qwBegin3 = ((unsigned __int64)NV056_SET_BEGIN_END3_OP_TRIANGLES << 32)
                            | (((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END3);
    global.celsius.qwEnd3   = ((unsigned __int64)NV056_SET_BEGIN_END3_OP_END << 32)
                            | (((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END3);
#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
    global.kelvin.qwBegin = ((unsigned __int64)NV097_SET_BEGIN_END_OP_TRIANGLES << 32)
                            | (((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    global.kelvin.qwEnd   = ((unsigned __int64)NV097_SET_BEGIN_END_OP_END << 32)
                            | (((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
#endif  // NVARCH >= 0x010

    global.pKNI->dwTriDispatch[0] = ((((3) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT32(0))));

#if (NVARCH >= 0x020)
    global.pKNI->dwKelvinTriDispatch[0] = ((((3) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT32)));
#endif
    // init delay loop until we get calibrate it properlty
    global.dwDelayCount = 400;

    global.b16BitCode = FALSE;

#ifndef WINNT
    // get and cache pointer to the device enumeration function
    // we used to do this on demand, but calls to LoadLibrary were sporadically hanging. lovely.
    HMODULE hModule = LoadLibrary("user32");
#ifdef UNICODE
    global.pfEnumDisplayDevices = (BOOL (WINAPI*)(LPCSTR, DWORD, PDISPLAY_DEVICE, DWORD)) GetProcAddress(hModule, "EnumDisplayDevicesW");
#else
    global.pfEnumDisplayDevices = (BOOL (WINAPI*)(LPCSTR, DWORD, PDISPLAY_DEVICE, DWORD)) GetProcAddress(hModule, "EnumDisplayDevicesA");
#endif // !UNICODE

    hModule = LoadLibrary("kernel32.dll");
    global.pfOpenVxDHandle = (HANDLE (WINAPI *)(HANDLE))GetProcAddress(hModule, "OpenVxDHandle");
#endif // !WINNT

#ifdef WINNT
    // force runtime version to be at least 7.00 for Win2K
    //check for existence of DX8:
    {
        HANDLE temp;
        CHAR name[9] = "D3D8.DLL";
        WCHAR uniname[9];
        ULONG outStrLen;

        //grr.... convert to Unicode.
        EngMultiByteToUnicodeN((LPWSTR)uniname, 9*sizeof(WCHAR), &outStrLen,
                       (char *)name, (9)*sizeof(CHAR));


        temp = EngLoadModule( uniname );
        if (temp)
        {
            EngFreeModule(temp);
            global.dwDXRuntimeVersion = 0x0800;
        }
        else
        {
            global.dwDXRuntimeVersion = 0x0700;
        }
    }
#else // WINNT
    // force runtime version to be at least 3.00 for Win9x
    global.dwDXRuntimeVersion = 0x0300;
#endif // !WINNT
}

//////////////////////////////////////////////////////////////////////////////
// registry (encrypted as a post-build step)
// keep this in sync with the defintion of reg_struc in global.h!

reg_struc reg =
{
    // signature
    {
        0x0badbeef,0x0badcafe,0xdeadbeef,0x420352ec,
        0x420352ec,0xdeadbeef,0x0badcafe,0x0badbeef,
    },
    // size
    sizeof(reg_struc) - 4 * (8 + 1),
    // to be encrypted registry key strings.
    // booleans
    D3D_REG_ANTIALIASENABLE_STRING,
    D3D_REG_ANTIALIASFORCEENABLE_STRING,
    D3D_REG_ANTIALIASDYNAMICENABLE_STRING,
    D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_STRING,
    D3D_REG_CKCOMPATABILITYENABLE_STRING,
    D3D_REG_DIRECTMAPENABLE_STRING,
    D3D_REG_ENFORCESTRICTTRILINEAR_STRING,
    D3D_REG_FLUSHAFTERBLITENABLE_STRING,
    D3D_REG_FOGTABLEENABLE_STRING,
    D3D_REG_FORCEBLITWAITFLAGENABLE_STRING,
    D3D_REG_LIMITQUEUEDFBBLITSENABLE_STRING,
    D3D_REG_LOGOENABLE_STRING,
#ifndef TEXFORMAT_CRD
    D3D_REG_PALETTEENABLE_STRING,
#endif  // !TEXFORMAT_CRD
    D3D_REG_SQUASHW_STRING,
    D3D_REG_SSYNCENABLE_STRING,
#ifndef TEXFORMAT_CRD
    D3D_REG_TEXTURECOMPRESSIONENABLE_STRING,
#endif  // !TEXFORMAT_CRD
    D3D_REG_TEXTUREMANAGEMENTENABLE_STRING,
    D3D_REG_TILINGENABLE_STRING,
    D3D_REG_ZCULLENABLE_STRING,
    D3D_REG_USERMIPMAPENABLE_STRING,
    D3D_REG_VIDEOTEXTUREENABLE_STRING,
    D3D_REG_VS_HOS_EMULATION_STRING,
    D3D_REG_WBUFFERENABLE_STRING,
    D3D_REG_Z24ENABLE_STRING,
    D3D_REG_ZCOMPRESSENABLE_STRING,
    0xdeadbeef,
    // non-boolean enumerated types
    D3D_REG_ANTIALIASQUALITY_STRING,
    D3D_REG_ANTIALIASDYNAMICFPS_STRING,
    D3D_REG_CAPTURECONFIG_STRING,
    D3D_REG_CAPTUREENABLE_STRING,
    D3D_REG_CKREF_STRING,
    D3D_REG_ANISOTROPICLEVEL_STRING,
    D3D_REG_MIPMAPDITHERMODE_STRING,
#ifdef TEXFORMAT_CRD
    D3D_REG_SURFACEFORMATSDX7_STRING,
    D3D_REG_SURFACEFORMATSDX8_STRING,
#endif  // TEXFORMAT_CRD
    D3D_REG_TEXELALIGNMENT_STRING,
    D3D_REG_TEXTUREMANAGESTRATEGY_STRING,
    D3D_REG_VALIDATEZMETHOD_STRING,
    D3D_REG_VSYNCMODE_STRING,
    D3D_REG_WFORMAT16_STRING,
    D3D_REG_WFORMAT32_STRING,
    0xdeadbeef,
    // non-boolean non-enumerated types
    D3D_REG_AACOMPATIBILITYBITS_STRING,
    D3D_REG_AAREADCOMPATIBILITYFILE_STRING,
    D3D_REG_AGPTEXCUTOFF_STRING,
    D3D_REG_CAPTUREPLAYFILENUM_STRING,
    D3D_REG_CAPTURERECORDFILENUM_STRING,
    D3D_REG_D3DCONTEXTMAX_STRING,
    D3D_REG_D3DTEXTUREMAX_STRING,
    D3D_REG_DEBUGLEVEL_STRING,
    D3D_REG_LODBIAS_STRING,
    D3D_REG_MINVIDTEXSIZE_STRING,
    D3D_REG_PCITEXHEAPSIZE_STRING,
    D3D_REG_PERFSTRATEGYOR_STRING,
    D3D_REG_PERFSTRATEGYAND_STRING,
    D3D_REG_PRERENDERLIMIT_STRING,
    D3D_REG_PUSHBUFFERSIZEMAX_STRING,
    D3D_REG_WSCALE16_STRING,
    D3D_REG_WSCALE24_STRING,
    D3D_REG_ZBIAS_STRING,
    0xdeadbeef,
    // strings
    D3D_REG_CAPTUREPLAYFILENAME_STRING,
    D3D_REG_CAPTUREPLAYPATH_STRING,
    D3D_REG_CAPTURERECORDFILENAME_STRING,
    D3D_REG_CAPTURERECORDPATH_STRING,
    0xdeadbeef
};

void decryptRegistryKeys
(
    void
)
{
    if (reg.dwSize == ~0) // encrypted?
    {
        DWORD i;
        BYTE  *p = ((BYTE*)&reg.dwSize) + 4; // 1st entry
        for (i = 0; i < sizeof(reg_struc) - 4 * (8 + 1); i++,p++)
        {
            *p ^= 0x42 ^ (BYTE)i;
        }

        reg.dwSize = 0; // tag as decrypted
    }
#ifdef DEBUG
//    else
//    {
//        if (reg.dwSize)
//        {
            /*
             * not encrypted - warn
             */
//            DPF ("Registry not encrypted!!!!!");
///        }
//    }
#endif
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\MoComp.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoComp.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "dxshare.h"

// For DirectX VA definitions.
// Note: Initguid.h causes Guids defined in Dxvadefs.h to be created as global data.
#include "initguid.h"
#include "dxvadefs.h"


extern NVMOCOMPPARAMS           nvMoCompParams;

#ifndef WINNT
    extern DISPDRVDIRECTXCOMMON    *pDXShare;
#endif // WINNT

extern DWORD __stdcall nvInitCelsiusForMoComp(void);
extern DWORD __stdcall nvInitCelsiusForMoCompPrediction(void);
extern DWORD __stdcall nvInitCelsiusForMoCompCorrection();
extern DWORD __stdcall nvInitCelsiusForMoCompConversion(void);
extern DWORD __stdcall nvInitCelsiusForMoCompTemporalFilter(void);
extern DWORD __stdcall nvMoCompProcessCelsiusFrameMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                              DWORD numMacroblocks, BYTE formatConversionStatus);
extern DWORD __stdcall nvMoCompProcessCelsiusFieldMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                              DWORD numMacroblocks, BYTE formatConversionStatus);
extern DWORD __stdcall nvInitKelvinForMoComp(void);
extern DWORD __stdcall nvInitKelvinForMoCompPrediction(void);
extern DWORD __stdcall nvInitKelvinForMoCompCorrection();
extern DWORD __stdcall nvInitKelvinForMoCompConversion(void);
extern DWORD __stdcall nvInitKelvinForMoCompTemporalFilter(void);
extern DWORD __stdcall nvMoCompProcessKelvinFrameMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                              DWORD numMacroblocks, BYTE formatConversionStatus);
extern DWORD __stdcall nvMoCompProcessKelvinFieldMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                              DWORD numMacroblocks, BYTE formatConversionStatus);

PNVMCPREDFUNC nvDoBidirectionalFieldPrediction;
PNVMCPREDFUNC nvDoTwoBidirectionalFieldPredictions;
PNVMCPREDFUNC nvDoForwardFieldPrediction;
PNVMCPREDFUNC nvDoTwoForwardFieldPredictions;
PNVMCPREDFUNC nvDoBackwardFieldPrediction;
PNVMCPREDFUNC nvDoTwoBackwardFieldPredictions;

PNVMCPREDFUNC2 nvPredictFrameLumaMacroblock;
PNVMCPREDFUNC2 nvPredictFieldLumaMacroblock;
PNVMCPREDFUNC2 nvPredictFrameChromaMacroblock;
PNVMCPREDFUNC2 nvPredictFieldChromaMacroblock;

PNVMCCORRFUNC2 nvDoAllIntraFieldCorrections;
PNVMCCORRFUNC2 nvDoAllFieldCorrections;
PNVMCCORRFUNC nvDoAllIntraFrameCorrections;
PNVMCCORRFUNC nvDoAllFrameCorrections;
PNVMCCORRFUNC nvDoIntraFieldCorrection;
PNVMCCORRFUNC nvDoOptimizedIntraFieldCorrection;
PNVMCCORRFUNC nvDoFieldCorrection;
PNVMCCORRFUNC nvDoIntraFrameCorrection;
PNVMCCORRFUNC nvDoFrameCorrection;

#ifdef  DEBUG
unsigned long overlaySurfaceBase = 0;
unsigned long moCompDebugLevel = 0;
#endif  // DEBUG

/*
 * nvMoCompCelsiusConvertSurfaceFormat
 *
 * Performs format conversion from our motion comp surface format to an overlay
 * compatible surface format.
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in pel units.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompCelsiusConvertSurfaceFormat(DWORD fpVidMem, BOOL filterChroma, DWORD dwHowMuchToConvert)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    unsigned long               surfaceWidth = dst->wWidth;
    unsigned long               surfaceHeight = dst->wHeight;
    unsigned long               surfacePitch = dst->lPitch;
    unsigned long               dwDstSurfaceOffset;
    unsigned long               tmpVal;
    unsigned long               Y0 = 0;
    unsigned long               Y1 = surfaceHeight;
    long                        dstX0;
    long                        dstX1;
    BYTE                        updateReferenceCount = FALSE;
    BYTE                        frameType;

    if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
        if (!(nvInitCelsiusForMoComp()))
            return FALSE;
    }

    // Let the display code know how to display this surface
    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != fpVidMem))
        lpDstSurfaceFlags++;

    if (!(nvInitCelsiusForMoCompConversion()))
        return FALSE;

    frameType = lpDstSurfaceFlags->bMCPictureStructure;

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

    if (pDriverData->bMCOverlaySrcIsSingleField1080i) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_FILTER(0) | 0x40000);
        nvPushData(1, tmpVal);

        nvPusherAdjust(2);
    }

    if (filterChroma) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_FILTER(1) | 0x40000);
        nvPushData(1, tmpVal);

        nvPusherAdjust(2);
    }

    // 420 LUMA portion of this surface starts at fpVidMem
    dwDstSurfaceOffset = VIDMEM_OFFSET(fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
    if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
        nvPushData(1, (dwDstSurfaceOffset + surfacePitch));
    else
        nvPushData(1, dwDstSurfaceOffset);

    // 420 CHROMA portion of this surface starts here
    dwDstSurfaceOffset += (surfacePitch * dst->wHeight);

    if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
        nvPushData(2, (dwDstSurfaceOffset + surfacePitch));
    else
        nvPushData(2, dwDstSurfaceOffset);

    nvPusherAdjust(3);

    // 422 portion of this surface starts here
    dwDstSurfaceOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

    if (frameType == PICTURE_STRUCTURE_FRAME) {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwDstSurfaceOffset);

        nvPusherAdjust(4);

        if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 7)
            Y0 = (surfaceHeight >> 1) + (surfaceHeight >> 2);
        else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 3)
            Y0 = (surfaceHeight >> 1);
        else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 1)
            Y0 = (surfaceHeight >> 2);

        if (dwHowMuchToConvert == 7)
            Y1 = (surfaceHeight >> 1) + (surfaceHeight >> 2);
        else if (dwHowMuchToConvert == 3)
            Y1 = (surfaceHeight >> 1);
        else if (dwHowMuchToConvert == 1)
            Y1 = (surfaceHeight >> 2);

        if (dwHowMuchToConvert == 15)
            updateReferenceCount = TRUE;

    } else {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, surfacePitch << 17);
        nvPushData(2, surfacePitch << 17);

        surfacePitch = ((surfaceWidth + 3) & ~3);

        // Determine pitch of 422 pixel block
        surfacePitch = ((surfacePitch << 1) + 127) & ~127; // YUY2 destination is twice the surface width

        nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(4, 0);

        nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);

        if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
            nvPushData(6, (dwDstSurfaceOffset + surfacePitch));
        else
            nvPushData(6, dwDstSurfaceOffset);

        surfacePitch |= (surfacePitch << 16);
        surfacePitch <<= 1;

        nvPushData(7, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(8, surfacePitch);

        nvPusherAdjust(9);

        if (frameType == PICTURE_STRUCTURE_TOP_FIELD) {
            if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 1)
                Y0 = (surfaceHeight >> 1);

            if ((dwHowMuchToConvert & 3) != 3)
                Y1 = (surfaceHeight >> 1);
        } else {
            if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 4)
                Y0 = (surfaceHeight >> 1);

            if ((dwHowMuchToConvert & 12) != 12)
                Y1 = (surfaceHeight >> 1);
        }

        if ((frameType == PICTURE_STRUCTURE_TOP_FIELD) &&
            (dwHowMuchToConvert == 3))
            updateReferenceCount = TRUE;
        else if ((frameType == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
            (dwHowMuchToConvert == 12))
            updateReferenceCount = TRUE;
    }

    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    if (pDriverData->bMCHorizontallyDownscale1080i) {
        dstX0 = (0 - SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
        dstX1 = ((surfaceWidth << 1) - SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
    } else {
        dstX0 = (0 - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
        dstX1 = ((surfaceWidth << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) | NV056_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    nvPushData(1, ((surfacePitch << 17) | 0));
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) | NV056_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    nvPushData(3, ((surfaceHeight << 17) | 0));
    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    if (frameType == PICTURE_STRUCTURE_FRAME) {
        DWORD dstYScale = 18;
        
        if (pDriverData->bMCOverlaySrcIsSingleField1080i)
            dstYScale = 17;

        nvPushData(3, ((Y0 >> 1) << 16) | 0);
        nvPushData(4, (Y0 << 16) | 0);
        nvPushData(5, (Y0 << dstYScale) | dstX0);

        nvPushData(6, ((Y1 >> 1) << 16) | 0); // CHROMA texture is in pel units and is only half the surface height
        nvPushData(7, (Y1 << 16) | 0); // LUMA texture is in pel units
        nvPushData(8, (Y1 << dstYScale) | dstX0); // destination is in quarter pel units

        nvPushData(9, ((Y1 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(10, (Y1 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(11, (Y1 << dstYScale) | dstX1); // each 32 bit write contains data for 2 422 pixels

        nvPushData(12, ((Y0 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(13, (Y0 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(14, (Y0 << dstYScale) | dstX1);
    } else {
        nvPushData(3, ((Y0 >> 2) << 16) | 0);
        nvPushData(4, ((Y0 >> 1) << 16) | 0);
        nvPushData(5, (Y0 << 17) | dstX0);

        nvPushData(6, ((Y1 >> 2) << 16) | 0); // CHROMA texture is in pel units and is only half the surface height
        nvPushData(7, ((Y1 >> 1) << 16) | 0); // LUMA texture is in pel units
        nvPushData(8, (Y1 << 17) | dstX0); // destination is in quarter pel units

        nvPushData(9, ((Y1 >> 2) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(10, ((Y1 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(11, (Y1 << 17) | dstX1); // each 32 bit write contains data for 2 422 pixels

        nvPushData(12, ((Y0 >> 2) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(13, ((Y0 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(14, (Y0 << 17) | dstX1);
    }

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    if (updateReferenceCount) {
        // Update reference count so we know when we can display this surface
        lpDstSurfaceFlags->dwMCFormatCnvReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
    }

    nvPusherStart(TRUE);

    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted |= dwHowMuchToConvert;

    return TRUE;

} /* nvMoCompCelsiusConvertSurfaceFormat */


/*
 * nvMoCompCelsiusTemporalFilter
 *
 * Performs intra frame temporal filtering between the fields of a post format converted overlay surface
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in quarter pel units.
 *       The combination factor should be in the range of 0 (0%) - 100 (100%)
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompCelsiusTemporalFilter(DWORD fpVidMem, BYTE combinationFactor)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    unsigned long               surfaceWidth = dst->wWidth;
    unsigned long               surfaceHeight = dst->wHeight;
    unsigned long               surfacePitch = dst->lPitch;
    unsigned long               dwSrcOffset;
    unsigned long               dwDstOffset;
    unsigned long               pitch422;
    unsigned long               topFieldCombinationFactor;
    unsigned long               bottomFieldCombinationFactor;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    long                        dstX0;
    long                        dstX1;

    // We currently don't allocate filtering memory for large surfaces so we don't allow filtering on them
    if (dst->wWidth > 1024)
        return DDERR_GENERIC;

    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != fpVidMem))
        lpDstSurfaceFlags++;

    // 422 portion of this surface starts here
    dwSrcOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

    // 422 filtering portion of this surface starts here
    pitch422 = (dst->wWidth + 3) & ~3;
    pitch422 = ((pitch422 << 1) + 127) & ~127;
    dwDstOffset = dwSrcOffset + (pitch422 * (DWORD)dst->wHeight);   // 422 filtering portion

    // Make sure surface has been format converted
    if ((lpDstSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
        nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 15);
    else {
        if ((lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3)
            nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 3);
        if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 12)
            nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 12);
    }

    // If this surface has already been filtered then just return
    if (lpDstSurfaceFlags->bMCFrameIsFiltered == TRUE)
        return DD_OK;

    if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
        if (!(nvInitCelsiusForMoComp()))
            return DDERR_GENERIC;
    }

    if (!(nvInitCelsiusForMoCompTemporalFilter()))
        return DDERR_GENERIC;

    if (combinationFactor > 100)
        return DDERR_INVALIDPARAMS;

    topFieldCombinationFactor = (combinationFactor * 256) / 100;
    if (topFieldCombinationFactor > 255)
        topFieldCombinationFactor = 255;
    topFieldCombinationFactor |= topFieldCombinationFactor << 8;
    topFieldCombinationFactor |= topFieldCombinationFactor << 16;

    bottomFieldCombinationFactor = 255 - topFieldCombinationFactor;
    bottomFieldCombinationFactor |= bottomFieldCombinationFactor << 8;
    bottomFieldCombinationFactor |= bottomFieldCombinationFactor << 16;

    // Load combination factors
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(1, topFieldCombinationFactor); // % of top field
    nvPushData(2, bottomFieldCombinationFactor); // % of bottom field

    nvPusherAdjust(3);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(0) | 0x80000);

    nvPushData(1, dwSrcOffset);
    nvPushData(2, (dwSrcOffset + pitch422));

    lpDstSurfaceFlags->bMCFrameIsFiltered = TRUE;

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(4, 0);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);

    nvPushData(6, dwDstOffset);

    nvPusherAdjust(7);

    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    // Filter Top Field

    if (pDriverData->bMCHorizontallyDownscale1080i) {
        dstX0 = (0 - SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
        dstX1 = ((surfaceWidth << 1) - SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
    } else {
        dstX0 = (0 - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
        dstX1 = ((surfaceWidth << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushData(3, (0 << 16) | 0); // Odd field
    nvPushData(4, (0 << 16) | 0);
    nvPushData(5, (0 << 16) | dstX0);

    nvPushData(6, (surfaceHeight << 17) | 0);
    nvPushData(7, (surfaceHeight << 17) | 0);
    nvPushData(8, (surfaceHeight << 17) | dstX0);

    nvPushData(9, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(10, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(11, (surfaceHeight << 17) | dstX1); // each 32 bit write contains data 2 422 pixels

    nvPushData(12, (0 << 16) | (surfaceWidth << 1));
    nvPushData(13, (0 << 16) | (surfaceWidth << 1));
    nvPushData(14, (0 << 16) | dstX1);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    // Now reverse combination factors
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(1, bottomFieldCombinationFactor); // % of top field
    nvPushData(2, topFieldCombinationFactor); // % of bottom field

    // Filter Bottom Field

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(4, 0);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);

    nvPushData(6, dwDstOffset + pitch422);

    nvPusherAdjust(7);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushData(3, (0 << 16) | 0); // Odd field
    nvPushData(4, (0 << 16) | 0);
    nvPushData(5, (0 << 16) | dstX0);

    nvPushData(6, (surfaceHeight << 17) | 0);
    nvPushData(7, (surfaceHeight << 17) | 0);
    nvPushData(8, (surfaceHeight << 17) | dstX0);

    nvPushData(9, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(10, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(11, (surfaceHeight << 17) | dstX1); // each 32 bit write contains data 2 422 pixels

    nvPushData(12, (0 << 16) | (surfaceWidth << 1));
    nvPushData(13, (0 << 16) | (surfaceWidth << 1));
    nvPushData(14, (0 << 16) | dstX1);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    // Update reference count so we know when we can display this surface
    lpDstSurfaceFlags->dwMCTemporalFilterReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

    nvPusherStart(TRUE);

    return DD_OK;

} /* nvMoCompCelsiusTemporalFilter */


/*
 * nvMoCompKelvinConvertSurfaceFormat
 *
 * Performs format conversion from our motion comp surface format to an overlay
 * compatible surface format.
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in pel units.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompKelvinConvertSurfaceFormat(DWORD fpVidMem, BOOL filterChroma, DWORD dwHowMuchToConvert)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    unsigned long               surfaceWidth = dst->wWidth;
    unsigned long               surfaceHeight = dst->wHeight;
    unsigned long               surfacePitch = dst->lPitch;
    unsigned long               dwDstSurfaceOffset;
    unsigned long               tmpVal;
    unsigned long               Y0 = 0;
    unsigned long               Y1 = surfaceHeight;
    BYTE                        updateReferenceCount = FALSE;
    BYTE                        frameType;

    if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
        if (!(nvInitKelvinForMoComp()))
            return FALSE;
    }

    // Let the display code know how to display this surface
    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != fpVidMem))
        lpDstSurfaceFlags++;

    if (!(nvInitKelvinForMoCompConversion()))
        return FALSE;

    frameType = lpDstSurfaceFlags->bMCPictureStructure;

    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    if (pDriverData->bMCOverlaySrcIsSingleField1080i) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_FILTER(0) | 0x40000);
        nvPushData(1, tmpVal);

        nvPusherAdjust(2);
    }

    if (filterChroma) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_FILTER(1) | 0x40000);
        nvPushData(1, tmpVal);

        nvPusherAdjust(2);
    }

    // 420 LUMA portion of this surface starts at fpVidMem
    dwDstSurfaceOffset = VIDMEM_OFFSET(fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
        nvPushData(1, (dwDstSurfaceOffset + surfacePitch));
    else
        nvPushData(1, dwDstSurfaceOffset);

    // 420 CHROMA portion of this surface starts here
    dwDstSurfaceOffset += (surfacePitch * dst->wHeight);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
        nvPushData(3, (dwDstSurfaceOffset + surfacePitch));
    else
        nvPushData(3, dwDstSurfaceOffset);

    nvPusherAdjust(4);

#ifdef  DEBUG
    if ((moCompDebugLevel > 0) && (overlaySurfaceBase != 0)) {
        dwDstSurfaceOffset = VIDMEM_OFFSET(overlaySurfaceBase);
        dwDstSurfaceOffset += (surfacePitch * dst->wHeight);
        lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted = 0;
    }
#endif  // DEBUG

    // 422 portion of this surface starts here
    dwDstSurfaceOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

    if (frameType == PICTURE_STRUCTURE_FRAME) {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwDstSurfaceOffset);

        nvPusherAdjust(4);

        if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 7)
            Y0 = (surfaceHeight >> 1) + (surfaceHeight >> 2);
        else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 3)
            Y0 = (surfaceHeight >> 1);
        else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 1)
            Y0 = (surfaceHeight >> 2);

        if (dwHowMuchToConvert == 7)
            Y1 = (surfaceHeight >> 1) + (surfaceHeight >> 2);
        else if (dwHowMuchToConvert == 3)
            Y1 = (surfaceHeight >> 1);
        else if (dwHowMuchToConvert == 1)
            Y1 = (surfaceHeight >> 2);

        if (dwHowMuchToConvert == 15)
            updateReferenceCount = TRUE;

    } else {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
        nvPushData(1, surfacePitch << 17);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(3, surfacePitch << 17);

        surfacePitch = ((surfaceWidth + 3) & ~3);

        // Determine pitch of 422 pixel block
        surfacePitch = ((surfacePitch << 1) + 127) & ~127; // YUY2 destination is twice the surface width

        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(5, 0);

        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);

        if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
            nvPushData(7, (dwDstSurfaceOffset + surfacePitch));
        else
            nvPushData(7, dwDstSurfaceOffset);

        surfacePitch |= (surfacePitch << 16);
        surfacePitch <<= 1;

        nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_PITCH | 0x40000);
        nvPushData(9, surfacePitch);

        nvPusherAdjust(10);

        if (frameType == PICTURE_STRUCTURE_TOP_FIELD) {
            if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 1)
                Y0 = (surfaceHeight >> 1);

            if ((dwHowMuchToConvert & 3) != 3)
                Y1 = (surfaceHeight >> 1);
        } else {
            if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 4)
                Y0 = (surfaceHeight >> 1);

            if ((dwHowMuchToConvert & 12) != 12)
                Y1 = (surfaceHeight >> 1);
        }

        if ((frameType == PICTURE_STRUCTURE_TOP_FIELD) &&
            (dwHowMuchToConvert == 3))
            updateReferenceCount = TRUE;
        else if ((frameType == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
            (dwHowMuchToConvert == 12))
            updateReferenceCount = TRUE;
    }

    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    if (frameType == PICTURE_STRUCTURE_FRAME) {
        DWORD dstYScale = 18;

        if (pDriverData->bMCOverlaySrcIsSingleField1080i)
            dstYScale = 17;

        nvPushData(3, (Y0 << dstYScale) | 0);
        nvPushData(4, (Y0 << 16) | 0);
        nvPushData(5, ((Y0 >> 1) << 16) | 0);

        nvPushData(6, (Y1 << dstYScale) | 0); // destination is in quarter pel units
        nvPushData(7, (Y1 << 16) | 0); // LUMA texture is in pel units
        nvPushData(8, ((Y1 >> 1) << 16) | 0); // CHROMA texture is in pel units and is only half the surface height

        nvPushData(9, (Y1 << dstYScale) | (surfaceWidth << 1)); // each 32 bit write contains data for 2 422 pixels
        nvPushData(10, (Y1 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(11, ((Y1 >> 1) << 16) | ((surfaceWidth + 1) >> 1));

        nvPushData(12, (Y0 << dstYScale) | (surfaceWidth << 1));
        nvPushData(13, (Y0 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(14, ((Y0 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
    } else {
        nvPushData(3, (Y0 << 17) | 0);
        nvPushData(4, ((Y0 >> 1) << 16) | 0);
        nvPushData(5, ((Y0 >> 2) << 16) | 0);

        nvPushData(6, (Y1 << 17) | 0); // destination is in quarter pel units
        nvPushData(7, ((Y1 >> 1) << 16) | 0); // LUMA texture is in pel units
        nvPushData(8, ((Y1 >> 2) << 16) | 0); // CHROMA texture is in pel units and is only half the surface height

        nvPushData(9, (Y1 << 17) | (surfaceWidth << 1)); // each 32 bit write contains data for 2 422 pixels
        nvPushData(10, ((Y1 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(11, ((Y1 >> 2) << 16) | ((surfaceWidth + 1) >> 1));

        nvPushData(12, (Y0 << 17) | (surfaceWidth << 1));
        nvPushData(13, ((Y0 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(14, ((Y0 >> 2) << 16) | ((surfaceWidth + 1) >> 1));
    }

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    if (updateReferenceCount) {
        // Update reference count so we know when we can display this surface
#ifdef  DEBUG
        if (moCompDebugLevel > 0) {
            lpDstSurfaceFlags->dwMCFormatCnvReferenceCount = getDC()->pRefCount->readShadow();
            getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
        } else {
            lpDstSurfaceFlags->dwMCFormatCnvReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
        }
#else   // DEBUG
        lpDstSurfaceFlags->dwMCFormatCnvReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
#endif  // DEBUG
    }

    nvPusherStart(TRUE);

    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted |= dwHowMuchToConvert;

    return TRUE;

} /* nvMoCompKelvinConvertSurfaceFormat */


/*
 * nvMoCompKelvinTemporalFilter
 *
 * Performs intra frame temporal filtering between the fields of a post format converted overlay surface
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in quarter pel units.
 *       The combination factor should be in the range of 0 (0%) - 100 (100%)
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompKelvinTemporalFilter(DWORD fpVidMem, BYTE combinationFactor)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    unsigned long               surfaceWidth = dst->wWidth;
    unsigned long               surfaceHeight = dst->wHeight;
    unsigned long               surfacePitch = dst->lPitch;
    unsigned long               dwSrcOffset;
    unsigned long               dwDstOffset;
    unsigned long               pitch422;
    unsigned long               topFieldCombinationFactor;
    unsigned long               bottomFieldCombinationFactor;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;

    // We currently don't allocate filtering memory for large surfaces so we don't allow filtering on them
    if (dst->wWidth > 1024)
        return DDERR_GENERIC;

#ifdef  DEBUG
    return DD_OK;
#endif  // DEBUG

    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != fpVidMem))
        lpDstSurfaceFlags++;

    // 422 portion of this surface starts here
    dwSrcOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

    // 422 filtering portion of this surface starts here
    pitch422 = (dst->wWidth + 3) & ~3;
    pitch422 = ((pitch422 << 1) + 127) & ~127;
    dwDstOffset = dwSrcOffset + (pitch422 * (DWORD)dst->wHeight);   // 422 filtering portion

    // Make sure surface has been format converted
    if ((lpDstSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
        nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 15);
    else {
        if ((lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3)
            nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 3);
        if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 12)
            nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 12);
    }

    // If this surface has already been filtered then just return
    if (lpDstSurfaceFlags->bMCFrameIsFiltered == TRUE)
        return DD_OK;

    if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
        if (!(nvInitKelvinForMoComp()))
            return DDERR_GENERIC;
    }

    if (!(nvInitKelvinForMoCompTemporalFilter()))
        return DDERR_GENERIC;

    if (combinationFactor > 100)
        return DDERR_INVALIDPARAMS;

    topFieldCombinationFactor = (combinationFactor * 256) / 100;
    if (topFieldCombinationFactor > 255)
        topFieldCombinationFactor = 255;
    topFieldCombinationFactor |= topFieldCombinationFactor << 8;
    topFieldCombinationFactor |= topFieldCombinationFactor << 16;

    bottomFieldCombinationFactor = 255 - topFieldCombinationFactor;
    bottomFieldCombinationFactor |= bottomFieldCombinationFactor << 8;
    bottomFieldCombinationFactor |= bottomFieldCombinationFactor << 16;

    // Load combination factors
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(1, topFieldCombinationFactor); // % of top field
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(3, bottomFieldCombinationFactor); // % of bottom field

    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    nvPushData(1, dwSrcOffset);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(3, (dwSrcOffset + pitch422));

    lpDstSurfaceFlags->bMCFrameIsFiltered = TRUE;

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(5, 0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
    nvPushData(7, dwDstOffset);

    nvPusherAdjust(8);

    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    // Filter Top Field

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushData(3, (0 << 16) | 0); // Odd field
    nvPushData(4, (0 << 16) | 0);
    nvPushData(5, (0 << 16) | 0);

    nvPushData(6, (surfaceHeight << 17) | 0);
    nvPushData(7, (surfaceHeight << 17) | 0);
    nvPushData(8, (surfaceHeight << 17) | 0);

    nvPushData(9, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(10, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(11, (surfaceHeight << 17) | (surfaceWidth << 1)); // each 32 bit write contains data 2 422 pixels

    nvPushData(12, (0 << 16) | (surfaceWidth << 1));
    nvPushData(13, (0 << 16) | (surfaceWidth << 1));
    nvPushData(14, (0 << 16) | (surfaceWidth << 1));

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    // Now reverse combination factors
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(1, bottomFieldCombinationFactor); // % of top field
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(3, topFieldCombinationFactor); // % of bottom field

    // Filter Bottom Field

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(5, 0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);

    nvPushData(7, dwDstOffset + pitch422);

    nvPusherAdjust(8);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushData(3, (0 << 16) | 0); // Odd field
    nvPushData(4, (0 << 16) | 0);
    nvPushData(5, (0 << 16) | 0);

    nvPushData(6, (surfaceHeight << 17) | 0);
    nvPushData(7, (surfaceHeight << 17) | 0);
    nvPushData(8, (surfaceHeight << 17) | 0);

    nvPushData(9, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(10, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(11, (surfaceHeight << 17) | (surfaceWidth << 1)); // each 32 bit write contains data 2 422 pixels

    nvPushData(12, (0 << 16) | (surfaceWidth << 1));
    nvPushData(13, (0 << 16) | (surfaceWidth << 1));
    nvPushData(14, (0 << 16) | (surfaceWidth << 1));

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    // Update reference count so we know when we can display this surface
    lpDstSurfaceFlags->dwMCTemporalFilterReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

    nvPusherStart(TRUE);

    return DD_OK;

} /* nvMoCompKelvinTemporalFilter */


/*
 * nvMoCompConvertSurfaceFormat
 *
 * Performs format conversion from our motion comp surface format to an overlay
 * compatible surface format.
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in pel units.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompConvertSurfaceFormat(DWORD fpVidMem, BOOL filterChroma, DWORD dwHowMuchToConvert)
{
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(NULL)) {
            return FALSE;
        }
    }

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        return nvMoCompKelvinConvertSurfaceFormat(fpVidMem, filterChroma, dwHowMuchToConvert);
    } else {
        return nvMoCompCelsiusConvertSurfaceFormat(fpVidMem, filterChroma, dwHowMuchToConvert);
    }
} /* nvMoCompConvertSurfaceFormat */


/*
 * nvMoCompTemporalFilter
 *
 * Performs intra frame temporal filtering between the fields of a post format converted overlay surface
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in quarter pel units.
 *       The combination factor should be in the range of 0 (0%) - 100 (100%)
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompTemporalFilter(DWORD fpVidMem, BYTE combinationFactor)
{
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(NULL)) {
            return DDERR_SURFACELOST;
        }
    }

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        return nvMoCompKelvinTemporalFilter(fpVidMem, combinationFactor);
    } else {
        return nvMoCompCelsiusTemporalFilter(fpVidMem, combinationFactor);
    }

} /* nvMoCompTemporalFilter */


/*
 * nvMoCompDecompressSubpicture
 *
 * Performs full or partial decompression of a subpicture surface to a DVD_SUBPICTURE compatible format.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompDecompressSubpicture(LPVOID lpInputData, DWORD dwSurfaceIndex)
{
    LPNVSPDECOMPRESSDATA lpNvSPDecompressData = (LPNVSPDECOMPRESSDATA)lpInputData;
    LPDDRAWI_DDRAWSURFACE_LCL pSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL pSurf_gbl;
    DWORD dwBlockSize;
    unsigned long dwLUTOffset;
    unsigned long dwDstOffset;
    unsigned long ulColor;
    float fRed;
    float fGreen;
    float fBlue;
    float fY;
    float fCb;
    float fCr;
    unsigned long dwCrCbY;
    unsigned char *LUTable;
    long n;
    unsigned long temp;
    long srcScanLength;
    long nxtSrcScan;
    FAST short pxlCount;
    unsigned long dwSrcOffset;
    unsigned char *pSrcInitBits;

    DWORD dwModeBPP = GET_MODE_BPP();
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    if (pSurf_gbl->ddpfSurface.dwFourCC != FOURCC_NVSP)
        return (DDERR_INVALIDPARAMS);

    if ((lpNvSPDecompressData->wSPHOffset < 0) ||
        (lpNvSPDecompressData->wSPVOffset < 0) ||
        (lpNvSPDecompressData->wSPWidth <= 0) ||
        (lpNvSPDecompressData->wSPHeight <= 0))
        return (DDERR_INVALIDPARAMS);


    dwBlockSize = pSurf_gbl->lPitch * pSurf_gbl->wHeight; // calculate size of 8 bit index per pixel plane
    dwBlockSize <<= 1;  // double size to skip over 8 bit alpha per pixel plane
    dwBlockSize += (dwBlockSize << 1); // increase to skip over fully decompressed 32 bit per pixel plane

    dwLUTOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    // offset to base of look up table in video memory
    dwLUTOffset += dwBlockSize;

    // Update color conversion table if necessary
    if (lpNvSPDecompressData->bSPUpdateLookUpTable) {

        nvPushData (0, dDrawSubchannelOffset(NV_DD_SURFACES) +
            NV042_SET_COLOR_FORMAT | 0x40000);
        nvPushData (1, NV042_SET_COLOR_FORMAT_LE_R5G6B5);
        nvPushData (2, dDrawSubchannelOffset(NV_DD_SURFACES) +
            NV042_SET_PITCH | 0xC0000);
        nvPushData (3, (1024 << 16) | 1024);
        nvPushData (4, 0);
        nvPushData (5, dwLUTOffset);
        nvPusherAdjust (6);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
        pDriverData->bltData.dwLastCombinedPitch = (1024 << 16) | 1024;
        pDriverData->bltData.dwLastSrcOffset = 0;
        pDriverData->bltData.dwLastDstOffset = dwLUTOffset;

        nvPushData (0, dDrawSubchannelOffset(NV_DD_ROP) +
            SET_ROP_OFFSET | 0x40000);
        nvPushData (1, SRCCOPYINDEX);
        pDriverData->bltData.dwLastRop = SRCCOPYINDEX;

        nvPushData (2, dDrawSubchannelOffset(NV_DD_IMAGE) +
            NV061_SET_COLOR_FORMAT | 0x40000);
        nvPushData (3, NV061_SET_COLOR_FORMAT_LE_R5G6B5);

        nvPushData (4, dDrawSubchannelOffset(NV_DD_IMAGE) +
            IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000);
        nvPushData (5, 0);

        if (lpNvSPDecompressData->bSPNumberOfActiveTableEntries == 0) {
            n = 256;
            nvPushData (6, asmMergeCoords(512, 1));
            nvPushData (7, asmMergeCoords(512, 1));
        } else {
            n = lpNvSPDecompressData->bSPNumberOfActiveTableEntries;
            nvPushData (6, asmMergeCoords((lpNvSPDecompressData->bSPNumberOfActiveTableEntries << 1), 1));
            nvPushData (7, asmMergeCoords((lpNvSPDecompressData->bSPNumberOfActiveTableEntries << 1), 1));
        }

        nvPusherAdjust (8);

        getDC()->nvPusher.makeSpace (1 + n); // > 128 word xfer
        nvPushData (0, dDrawSubchannelOffset(NV_DD_IMAGE) +
                       IMAGE_FROM_CPU_COLOR_OFFSET | (n << 18));
        getDC()->nvPusher.inc (1);

        LUTable = (unsigned char *)&lpNvSPDecompressData->dwSPLookUpTable[0];

        while (--n >= 0) {

            if (lpNvSPDecompressData->bSPFormat == 1) { // RGB look up table values
                ulColor = LUTable[0];
                fBlue = (float)ulColor;
                ulColor = LUTable[1];
                fGreen = (float)ulColor;
                ulColor = LUTable[2];
                fRed = (float)ulColor;

                // ITU-R BT.601 RGB conversion to YCbCr assuming gamma corrected RGB values ranging from 0 - 255
                //
                // Cr = 0.439R - 0.368G - 0.071B + 128
                // Cb = -0.148R - 0.291G + 0.439B + 128
                // Y = 0.257R + 0.504G + 0.98B + 16

                fCr = (float)((0.439 * fRed) - (0.368 * fGreen) - (0.071 * fBlue) + 128.0);
                if (fCr < 0.0)
                    fCr = 0.0;
                else if (fCr > 255.0)
                    fCr = 255.0;
                dwCrCbY = (unsigned long)fCr;
                dwCrCbY <<= 8;
                fCb = (float)((-0.148 * fRed) - (0.291 * fGreen) + (0.439 * fBlue) + 128.0);
                if (fCb < 0.0)
                    fCb = 0.0;
                else if (fCb > 255.0)
                    fCb = 255.0;
                dwCrCbY |= (unsigned long)fCb;
                dwCrCbY <<= 8;
                fY = (float)((0.257 * fRed) + (0.504 * fGreen) + (0.98 * fBlue) + 16.0);
                if (fY > 255.0)
                    dwCrCbY |= 255;
                else dwCrCbY |= (unsigned long)fY;
            } else { // YUV look up table values
                dwCrCbY = LUTable[0];
                dwCrCbY = (dwCrCbY << 8) | LUTable[1];
                dwCrCbY = (dwCrCbY << 8) | LUTable[2];
            }

            LUTable += 4;

            nvPushData (0, dwCrCbY);

            getDC()->nvPusher.inc (1);
        }

        // Restore IMAGE_FROM_CPU color format
        nvPushData (0, dDrawSubchannelOffset(NV_DD_IMAGE) +
            NV061_SET_OPERATION | 0x40000);
        nvPushData (1, NV061_SET_COLOR_FORMAT);

        if (dwModeBPP == 8)
            nvPushData (2, NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
        else if (dwModeBPP == 16)
            nvPushData (2, NV061_SET_COLOR_FORMAT_LE_R5G6B5);
        else
            nvPushData (2, NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);

        nvPusherAdjust (3);

        nvPusherStart (TRUE);
    }

    // Now decompress index plane to X8Y8U8V8
    dwBlockSize = pSurf_gbl->lPitch * pSurf_gbl->wHeight; // calculate size of 8 bit index per pixel plane
    dwBlockSize <<= 1;  // double size to skip over 8 bit alpha per pixel plane

    dwDstOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    // offset to base of fully decompressed pixel plane in video memory
    dwDstOffset += dwBlockSize;

    nvPushData (0, dDrawSubchannelOffset(NV_DD_SURFACES) +
        NV042_SET_COLOR_FORMAT | 0x40000);
    nvPushData (1, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
    nvPushData (2, dDrawSubchannelOffset(NV_DD_SURFACES) +
        NV042_SET_PITCH | 0xC0000);
    nvPushData (3, (pSurf_gbl->lPitch << 18) | (pSurf_gbl->lPitch << 2)); // output is 32 bpp
    nvPushData (4, 0);
    nvPushData (5, dwDstOffset);
    nvPusherAdjust (6);
    pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
    pDriverData->bltData.dwLastCombinedPitch = (pSurf_gbl->lPitch << 18) | (pSurf_gbl->lPitch << 2);
    pDriverData->bltData.dwLastSrcOffset = 0;
    pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    srcScanLength = pSurf_gbl->lPitch;

    pSrcInitBits = (unsigned char *) VIDMEM_ADDR(pSurf_gbl->fpVidMem);

    pSrcInitBits += (lpNvSPDecompressData->wSPVOffset * srcScanLength);

    pSrcInitBits += (lpNvSPDecompressData->wSPHOffset & 0xFFFC);

    dwSrcOffset = lpNvSPDecompressData->wSPHOffset & 3;

    temp = ((lpNvSPDecompressData->wSPWidth + dwSrcOffset + 3) & 0xFFFC);

    nxtSrcScan = srcScanLength - temp;

    n = lpNvSPDecompressData->wSPHeight;

    nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (1, NV_DD_IMAGE_BLACK_RECTANGLE);

    // Let others know that we changed the clip
    pDriverData->dwSharedClipChangeCount++;

    pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;

    // changing canvas clip avoids manually aligning 8-bit source
    nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
        IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000);
    nvPushData (3, 0);
    nvPushData (4, asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP));

    nvPushData (5, dDrawSubchannelOffset(NV_DD_ROP) +
        SET_ROP_OFFSET | 0x40000);
    nvPushData (6, SRCCOPYINDEX);
    pDriverData->bltData.dwLastRop = SRCCOPYINDEX;

    nvPusherAdjust (7);

    nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (1, NV_DD_INDEXED_IMAGE_FROM_CPU);

    nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
        NV064_INDEX_FORMAT | 0x40000);
    nvPushData (3, NV064_INDEX_FORMAT_LE_I8);

    nvPushData (4, dDrawSubchannelOffset(NV_DD_SPARE) +
        NV064_LUT_OFFSET | 0x40000);
    nvPushData (5, dwLUTOffset);

    /* compiler screws up this expression when it goes negative in following macro */
    temp = lpNvSPDecompressData->wSPHOffset - dwSrcOffset;

    nvPushData (6, dDrawSubchannelOffset(NV_DD_SPARE) +
        NV064_POINT | 0xC0000);
    nvPushData (7, asmMergeCoords(temp, lpNvSPDecompressData->wSPVOffset));
    nvPushData (8,
        asmMergeCoords(lpNvSPDecompressData->wSPWidth + dwSrcOffset, lpNvSPDecompressData->wSPHeight));

    temp = ((lpNvSPDecompressData->wSPWidth + dwSrcOffset + 3) & 0xFFFC);

    nvPushData (9, asmMergeCoords(temp, lpNvSPDecompressData->wSPHeight));

    nvPusherAdjust (10);

    {
       FAST unsigned char *pSrcBits = pSrcInitBits;
       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

       while (--n >= 0) {

           pxlCount = (short)temp;

           getDC()->nvPusher.makeSpace (1 + temp / 2); // > 128 word xfer
           nvPushData (0,dDrawSubchannelOffset(NV_DD_SPARE) +
               NV064_INDICES(0) | (temp << 16));
           getDC()->nvPusher.inc (1);

           while (pxlCount >= 32) {
               pxlCount -= 32;

               tmpPxls0 = *(unsigned long *)&pSrcBits[0];
               tmpPxls1 = *(unsigned long *)&pSrcBits[4];
               nvPushData (0,tmpPxls0);
               tmpPxls2 = *(unsigned long *)&pSrcBits[8];
               nvPushData (1,tmpPxls1);
               tmpPxls0 = *(unsigned long *)&pSrcBits[12];
               tmpPxls1 = *(unsigned long *)&pSrcBits[16];
               nvPushData (2,tmpPxls2);
               nvPushData (3,tmpPxls0);
               tmpPxls2 = *(unsigned long *)&pSrcBits[20];
               tmpPxls0 = *(unsigned long *)&pSrcBits[24];
               nvPushData (4,tmpPxls1);
               nvPushData (5,tmpPxls2);
               tmpPxls1 = *(unsigned long *)&pSrcBits[28];
               nvPushData (6,tmpPxls0);
               pSrcBits += 32;
               nvPushData (7,tmpPxls1);

               getDC()->nvPusher.inc (8);
           }

           if (pxlCount > 0) {

               while (pxlCount >= 8) {
                   pxlCount -= 8;
                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                   tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                   pSrcBits += 8;
                   nvPushData (0,tmpPxls0);
                   nvPushData (1,tmpPxls1);
                   getDC()->nvPusher.inc (2);
               }

               if (pxlCount > 0) {
                   pxlCount -= 4;
                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                   pSrcBits += 4;
                   nvPushData (0,tmpPxls0);

                   getDC()->nvPusher.inc (1);

                   if (pxlCount > 0) {
                       tmpPxls1 = *(unsigned long *)&pSrcBits[0];
                       pSrcBits += 4;
                       nvPushData (0,tmpPxls1);
                       getDC()->nvPusher.inc (1);
                   }
               }
           }
           pSrcBits += nxtSrcScan;

           nvPusherStart (TRUE);
        }
    }

    // Restore surface color format
    nvPushData (0, dDrawSubchannelOffset(NV_DD_SURFACES) +
        NV042_SET_COLOR_FORMAT | 0x40000);

    if (dwModeBPP == 8) {
        nvPushData (1, NV042_SET_COLOR_FORMAT_LE_Y8);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_Y8;
    } else if (dwModeBPP == 16) {
        nvPushData (1, NV042_SET_COLOR_FORMAT_LE_R5G6B5);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
    } else {
        nvPushData (1, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
    }

    nvPusherAdjust (2);

    // Now copy the corresponding alpha values into the freshly decompressed X8Y8U8V8 pixels
    dwSrcOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    dwSrcOffset += pSurf_gbl->lPitch * pSurf_gbl->wHeight; // offset over the 8 bit index per pixel plane

    dwSrcOffset += (lpNvSPDecompressData->wSPVOffset * srcScanLength);

    dwSrcOffset += lpNvSPDecompressData->wSPHOffset;

    // Destination is 32 bits per pixel
    dwDstOffset += (lpNvSPDecompressData->wSPVOffset * (srcScanLength << 2));

    dwDstOffset += (lpNvSPDecompressData->wSPHOffset << 2);

    dwDstOffset += 3; // first alpha value is 4 byte of first X8Y8U8V8 dword

    n = lpNvSPDecompressData->wSPHeight;

    nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (1, NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
            MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
    nvPushData (3, dwSrcOffset);
    nvPushData (4, dwDstOffset);
    nvPushData (5, srcScanLength);
    nvPushData (6, (srcScanLength << 2));
    nvPushData (7, (DWORD)lpNvSPDecompressData->wSPWidth);
    nvPushData (8, (DWORD)lpNvSPDecompressData->wSPHeight);
    nvPushData (9, (4 << 8) | 1);
    nvPushData (10, 0);

    nvPusherAdjust (11);

    nvPusherStart (TRUE);

    pDriverData->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

    return DD_OK;

} /* nvMoCompDecompressSubpicture */



/*
 * nvMoCompCompositeSubpicture
 *
 * Performs full or partial compositing of a decompressed subpicture surface to the destination overlay
 * surface with scaling.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompCompositeSubpicture(LPVOID lpInputData, DWORD dwSurfaceIndex)
{
    LPNVSPCOMPOSITEDATA lpNvSPCompositeData = (LPNVSPCOMPOSITEDATA)lpInputData;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    LPDDRAWI_DDRAWSURFACE_LCL   pSPSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSPSurf_gbl;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    DWORD                       dwBlockSize;
    unsigned long               dwSrcOffset;
    unsigned long               dw422Offset;
    unsigned long               dwDstOffset;
    unsigned long               pitch422;
    unsigned long               dwSubPictureSurfaceWidth;
    unsigned long               dwSubPictureSurfaceHeight;
    unsigned long               dwCompositeSurfaceWidth;
    unsigned long               dwCompositeSurfaceHeight;
    BYTE                        revertRegion = FALSE;


    if ((lpNvSPCompositeData->wSPHOffset < 0) ||
        (lpNvSPCompositeData->wSPVOffset < 0) ||
        (lpNvSPCompositeData->wSPWidth < 0) ||
        (lpNvSPCompositeData->wSPHeight < 0))
        return (DDERR_INVALIDPARAMS);

    if ((lpNvSPCompositeData->wMCHOffset < 0) ||
        (lpNvSPCompositeData->wMCVOffset < 0) ||
        (lpNvSPCompositeData->wMCWidth < 0) ||
        (lpNvSPCompositeData->wMCHeight < 0))
        return (DDERR_INVALIDPARAMS);

    // Is this a request to revert to an uncomposited destination ?
    if ((lpNvSPCompositeData->wSPHOffset == 0) &&
        (lpNvSPCompositeData->wSPVOffset == 0) &&
        (lpNvSPCompositeData->wSPWidth == 0) &&
        (lpNvSPCompositeData->wSPHeight == 0))
        revertRegion = TRUE;

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    pitch422 = (pSurf_gbl->wWidth + 3) & ~3;
    pitch422 = ((pitch422 << 1) + 127) & ~127;

    dwCompositeSurfaceWidth = pSurf_gbl->wWidth;
    dwCompositeSurfaceHeight = pSurf_gbl->wHeight;

    pSPSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    pSPSurf_gbl = pSPSurf_lcl->lpGbl;
    
    if(!pSPSurf_gbl->fpVidMem)
        return (DDERR_SURFACELOST);

    dwSubPictureSurfaceWidth = pSurf_gbl->wWidth;
    dwSubPictureSurfaceHeight = pSurf_gbl->wHeight;

    if (pSPSurf_gbl->ddpfSurface.dwFourCC != FOURCC_NVSP) {
        return (DDERR_INVALIDPARAMS);
    }

    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
        lpDstSurfaceFlags++;

    // First make sure destination surface has been format converted
    if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 15);
    else if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_TOP_FIELD) &&
        ((lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 3);
    else if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 12))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 12);

    if ((revertRegion) || (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing)) {
        unsigned long X0, Y0, X1, Y1;
        unsigned long tmpVal;

        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

            if (!(nvInitKelvinForMoCompConversion()))
                return DDERR_GENERIC;

            tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
                     (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
                     (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
                     (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
                     (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
                     (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
                     (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_FILTER(1) | 0x40000);
            nvPushData(1, tmpVal);

            nvPusherAdjust(2);

            // 420 LUMA portion of this surface starts at fpVidMem
            dwDstOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(1, dwDstOffset);

            // 420 CHROMA portion of this surface starts here
            dwDstOffset += (pSurf_gbl->lPitch * pSurf_gbl->wHeight);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(3, dwDstOffset);
            nvPusherAdjust(4);
        } else {

            if (!(nvInitCelsiusForMoCompConversion()))
                return DDERR_GENERIC;

            tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
                     (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_FILTER(1) | 0x40000);
            nvPushData(1, tmpVal);

            nvPusherAdjust(2);

            // 420 LUMA portion of this surface starts at fpVidMem
            dwDstOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
            nvPushData(1, dwDstOffset);

            // 420 CHROMA portion of this surface starts here
            dwDstOffset += (pSurf_gbl->lPitch * pSurf_gbl->wHeight);
            nvPushData(2, dwDstOffset);
            nvPusherAdjust(3);
        }

        if (revertRegion) {
            dw422Offset = lpDstSurfaceFlags->dwMCSurface422Offset;

            // Offset to NV12 surface filtered pixel area if necessary
            if (lpDstSurfaceFlags->bMCFrameIsFiltered) {
                if ((lpDstSurfaceFlags->bMCPictureStructure != PICTURE_STRUCTURE_FRAME) ||
                    (lpNvSPCompositeData->bSPCompositeWith != PICTURE_STRUCTURE_FRAME)) {
                    dw422Offset += (pitch422 * (DWORD)pSurf_gbl->wHeight);  // 422 portion
                }
            }
        } else {
            dw422Offset = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);
            dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight; // calculate size of subpicture 8 bit index per pixel plane
            dwBlockSize <<= 1;                  // double size to skip over 8 bit alpha per pixel plane
            dw422Offset += dwBlockSize;         // offset to base of fully decompressed pixel plane in video memory
            dw422Offset += (dwBlockSize << 1);  // increase to skip fully decompressed 32 bit per pixel plane
            dw422Offset += 1024;                // also skip indexed image look up table
        }

        X0 = lpNvSPCompositeData->wMCHOffset;
        X1 = X0 + lpNvSPCompositeData->wMCWidth;
        Y0 = lpNvSPCompositeData->wMCVOffset;
        Y1 = Y0 + lpNvSPCompositeData->wMCHeight;

        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, dw422Offset);

            nvPusherAdjust(4);

            SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_BEGIN_END | 0x40000);
            nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_INLINE_ARRAY | 0x40300000);

            nvPushData(3, (Y0 << 18) | (X0 << 1));
            nvPushData(4, (Y0 << 16) | (X0 >> 1));
            nvPushData(5, (Y0 << 15) | (X0 >> 1));

            nvPushData(6, ((Y1 << 2) << 16) | (X0 << 1)); // destination is in quarter pel units
            nvPushData(7, (Y1 << 16) | (X0 >> 1)); // LUMA texture is in pel units
            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(8, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            else
                nvPushData(8, ((Y1 >> 2) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height

            nvPushData(9, ((Y1 << 2) << 16) | (X1 << 1)); // each 32 bit write contains data for 2 422 pixels
            nvPushData(10, (Y1 << 16) | (X1 >> 1));
            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(11, ((Y1 >> 1) << 16) | (X1 >> 1));
            else
                nvPushData(11, ((Y1 >> 2) << 16) | (X1 >> 1));

            nvPushData(12, (Y0 << 18) | (X1 << 1));
            nvPushData(13, (Y0 << 16) | (X1 >> 1));
            nvPushData(14, (Y0 << 15) | (X1 >> 1));

            nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_BEGIN_END | 0x40000);
            nvPushData(16, NV097_SET_BEGIN_END_OP_END);
            nvPusherAdjust(17);
        } else {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, dw422Offset);

            nvPusherAdjust(4);

            SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_BEGIN_END | 0x40000);
            nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_INLINE_ARRAY(0) | 0x300000);

            // No HD scaled version because subpicture compositing is not used for HD 
            nvPushData(3, (Y0 << 15) | (X0 >> 1));
            nvPushData(4, (Y0 << 16) | (X0 >> 1));
            nvPushData(5, (Y0 << 18) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(6, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            else
                nvPushData(6, ((Y1 >> 2) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            nvPushData(7, (Y1 << 16) | (X0 >> 1)); // LUMA texture is in pel units
            nvPushData(8, ((Y1 << 2) << 16) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination is in quarter pel units

            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(9, ((Y1 >> 1) << 16) | (X1 >> 1));
            else
                nvPushData(9, ((Y1 >> 2) << 16) | (X1 >> 1));
            nvPushData(10, (Y1 << 16) | (X1 >> 1));
            nvPushData(11, ((Y1 << 2) << 16) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // each 32 bit write contains data for 2 422 pixels

            nvPushData(12, (Y0 << 15) | (X1 >> 1));
            nvPushData(13, (Y0 << 16) | (X1 >> 1));
            nvPushData(14, (Y0 << 18) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

            nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_BEGIN_END | 0x40000);
            nvPushData(16, NV056_SET_BEGIN_END_OP_END);
            nvPusherAdjust(17);
        }

        nvPusherStart(TRUE);
    }

    if (!revertRegion) {
        long subPictureScaleDeltaX;
        long subPictureScaleDeltaY;

        dwDstOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

        if (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing == 0)
            dw422Offset = dwDstOffset;

        if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
            lpDstSurfaceFlags->bMCFrameIsComposited = PICTURE_STRUCTURE_FRAME;
        else if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_TOP_FIELD)
            lpDstSurfaceFlags->bMCFrameIsComposited |= PICTURE_STRUCTURE_TOP_FIELD;
        else
            lpDstSurfaceFlags->bMCFrameIsComposited |= PICTURE_STRUCTURE_BOTTOM_FIELD;

        dwSrcOffset = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);

        dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight;   // calculate size of subpicture 8 bit index per pixel plane
        dwBlockSize <<= 1;                                          // double size to skip over 8 bit alpha per pixel plane

        dwSrcOffset += dwBlockSize;                                 // offset to base of fully decompressed pixel plane in video memory

        subPictureScaleDeltaX = lpNvSPCompositeData->wSPWidth;
        subPictureScaleDeltaX = (subPictureScaleDeltaX << 20) / lpNvSPCompositeData->wMCWidth;
        if ((subPictureScaleDeltaX < 0x10000) || (subPictureScaleDeltaX > 0x1000000))
            subPictureScaleDeltaX = 0x100000;

        subPictureScaleDeltaY = lpNvSPCompositeData->wSPHeight;
        subPictureScaleDeltaY = (subPictureScaleDeltaY << 20) / lpNvSPCompositeData->wMCHeight;
        if ((subPictureScaleDeltaY < 0x10000) || (subPictureScaleDeltaY > 0x1000000))
            subPictureScaleDeltaY = 0x100000;

        if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME) {

            nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
            nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                    NV088_IMAGE_OUT_POINT | 0x400000);
            nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
            nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
            nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | pitch422);
            nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
            nvPushData (7, 0x100000);
            nvPushData (8, 0x100000);
            nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
            nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | pitch422);

            nvPushData (11, dw422Offset);                                           // 422 source pixel area
            nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
            nvPushData (13, subPictureScaleDeltaX);
            nvPushData (14, subPictureScaleDeltaY);
            nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
            nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 2));
            nvPushData (17, dwSrcOffset);
            nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

            nvPusherAdjust (19);

            if (lpDstSurfaceFlags->bMCFrameIsFiltered) {
                dwDstOffset += (pitch422 * (DWORD)pSurf_gbl->wHeight);  // 422 filtered portion

                if (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing == 0)
                dw422Offset = dwDstOffset;

                nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
                nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                        NV088_IMAGE_OUT_POINT | 0x400000);
                nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
                nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
                nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | pitch422);
                nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
                nvPushData (7, 0x100000);
                nvPushData (8, 0x100000);
                nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
                nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | pitch422);

                nvPushData (11, dw422Offset);                                           // 422 source pixel area
                nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
                nvPushData (13, subPictureScaleDeltaX);
                nvPushData (14, subPictureScaleDeltaY);
                nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
                nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 2));
                nvPushData (17, dwSrcOffset);
                nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

                nvPusherAdjust (19);
            }
        } else if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_TOP_FIELD) {

            nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
            nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                    NV088_IMAGE_OUT_POINT | 0x400000);
            nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
            nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
            nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));
            nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
            nvPushData (7, 0x100000);
            nvPushData (8, 0x100000);
            nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
            nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));

            nvPushData (11, dw422Offset);                                           // 422 source pixel area
            nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
            nvPushData (13, subPictureScaleDeltaX);
            nvPushData (14, subPictureScaleDeltaY);
            nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
            nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 3));
            nvPushData (17, dwSrcOffset);
            nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

            nvPusherAdjust (19);

            if (lpDstSurfaceFlags->bMCFrameIsFiltered) {
                dwDstOffset += (pitch422 * (DWORD)pSurf_gbl->wHeight);  // 422 filtered portion

                if (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing == 0)
                dw422Offset = dwDstOffset;

                nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
                nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                        NV088_IMAGE_OUT_POINT | 0x400000);
                nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
                nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
                nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));
                nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
                nvPushData (7, 0x100000);
                nvPushData (8, 0x100000);
                nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
                nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));

                nvPushData (11, dw422Offset);                                           // 422 source pixel area
                nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
                nvPushData (13, subPictureScaleDeltaX);
                nvPushData (14, subPictureScaleDeltaY);
                nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
                nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 3));
                nvPushData (17, dwSrcOffset);
                nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

                nvPusherAdjust (19);
            }
        } else {

            nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
            nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                    NV088_IMAGE_OUT_POINT | 0x400000);
            nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
            nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
            nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));
            nvPushData (6, (dwDstOffset + pitch422));                               // 422 destination pixel area
            nvPushData (7, 0x100000);
            nvPushData (8, 0x100000);
            nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
            nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));

            nvPushData (11, (dw422Offset + pitch422));                              // 422 source pixel area
            nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
            nvPushData (13, subPictureScaleDeltaX);
            nvPushData (14, subPictureScaleDeltaY);
            nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
            nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 3));
            nvPushData (17, (dwSrcOffset + (pSurf_gbl->lPitch << 2)));
            nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

            nvPusherAdjust (19);

            if (lpDstSurfaceFlags->bMCFrameIsFiltered) {
                dwDstOffset += (pitch422 * (DWORD)pSurf_gbl->wHeight);  // 422 filtered portion

                if (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing == 0)
                dw422Offset = dwDstOffset;

                nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
                nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                        NV088_IMAGE_OUT_POINT | 0x400000);
                nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
                nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
                nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));
                nvPushData (6, (dwDstOffset + pitch422));                               // 422 destination pixel area
                nvPushData (7, 0x100000);
                nvPushData (8, 0x100000);
                nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
                nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));

                nvPushData (11, (dw422Offset + pitch422));                              // 422 source pixel area
                nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
                nvPushData (13, subPictureScaleDeltaX);
                nvPushData (14, subPictureScaleDeltaY);
                nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
                nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 3));
                nvPushData (17, (dwSrcOffset + (pSurf_gbl->lPitch << 2)));
                nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

                nvPusherAdjust (19);
            }
        }
    }

    // Update reference count in case we get a status query
    lpDstSurfaceFlags->dwMCCompositeReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

    nvPusherStart(TRUE);

    pDriverData->dDrawSpareSubchannelObject = NV_VPP_DVD_SUBPICTURE_IID;

    return DD_OK;

} /* nvMoCompCompositeSubpicture */


#if 0

// This is a test function to demonstrate NV12 subpicture compositing using Celsius in NV17.
// It would need some modification to actually be used in the driver.

extern DWORD __stdcall nvInitCelsiusForMoCompNV12LumaSubpictureCompositing(void);
extern DWORD __stdcall nvInitCelsiusForMoCompNV12ChromaSubpictureCompositing(void);

/*
 * nvMoCompCompositeNV12Subpicture
 *
 * Performs full or partial compositing of a decompressed subpicture surface to the destination NV12
 * surface with scaling.  Currently works in frame mode only.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompCompositeNV12Subpicture(LPVOID lpInputData, DWORD dwSurfaceIndex)
{
    LPNVSPCOMPOSITEDATA lpNvSPCompositeData = (LPNVSPCOMPOSITEDATA)lpInputData;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    LPDDRAWI_DDRAWSURFACE_LCL   pSPSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSPSurf_gbl;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    DWORD                       dwBlockSize;
    unsigned long               dwSrcOffset;
    unsigned long               dw422Offset;
    unsigned long               dwDstOffset;
    unsigned long               pitch422;
    unsigned long               dwSubPictureSurfaceWidth;
    unsigned long               dwSubPictureSurfaceHeight;
    unsigned long               dwCompositeSurfaceWidth;
    unsigned long               dwCompositeSurfaceHeight;
    unsigned long               X0, Y0, X1, Y1;
    unsigned long               SPX0, SPY0, SPX1, SPY1;
    BYTE                        revertRegion = FALSE;

    if ((lpNvSPCompositeData->wSPHOffset < 0) ||
        (lpNvSPCompositeData->wSPVOffset < 0) ||
        (lpNvSPCompositeData->wSPWidth < 0) ||
        (lpNvSPCompositeData->wSPHeight < 0))
        return (DDERR_INVALIDPARAMS);

    if ((lpNvSPCompositeData->wMCHOffset < 0) ||
        (lpNvSPCompositeData->wMCVOffset < 0) ||
        (lpNvSPCompositeData->wMCWidth < 0) ||
        (lpNvSPCompositeData->wMCHeight < 0))
        return (DDERR_INVALIDPARAMS);

    // Is this a request to revert to an uncomposited destination ?
    if ((lpNvSPCompositeData->wSPHOffset == 0) &&
        (lpNvSPCompositeData->wSPVOffset == 0) &&
        (lpNvSPCompositeData->wSPWidth == 0) &&
        (lpNvSPCompositeData->wSPHeight == 0))
        revertRegion = TRUE;

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    pitch422 = (pSurf_gbl->wWidth + 3) & ~3;
    pitch422 = ((pitch422 << 1) + 127) & ~127;

    dwCompositeSurfaceWidth = pSurf_gbl->wWidth;
    dwCompositeSurfaceHeight = pSurf_gbl->wHeight;

    pSPSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    pSPSurf_gbl = pSPSurf_lcl->lpGbl;

    dwSubPictureSurfaceWidth = pSurf_gbl->wWidth;
    dwSubPictureSurfaceHeight = pSurf_gbl->wHeight;

    if (pSPSurf_gbl->ddpfSurface.dwFourCC != FOURCC_NVSP) {
        return (DDERR_INVALIDPARAMS);
    }

    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
        lpDstSurfaceFlags++;

    // First make sure destination surface has been format converted
    if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 15);
    else if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_TOP_FIELD) &&
        ((lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 3);
    else if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 12))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 12);

    X0 = lpNvSPCompositeData->wMCHOffset;
    X1 = X0 + lpNvSPCompositeData->wMCWidth;
    Y0 = lpNvSPCompositeData->wMCVOffset;
    Y1 = Y0 + lpNvSPCompositeData->wMCHeight;

    SPX0 = lpNvSPCompositeData->wSPHOffset;
    SPX1 = SPX0 + lpNvSPCompositeData->wSPWidth;
    SPY0 = lpNvSPCompositeData->wSPVOffset;
    SPY1 = SPY0 + lpNvSPCompositeData->wSPHeight;

    if ((revertRegion) || (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing)) {
        unsigned long tmpVal;

        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

            if (!(nvInitKelvinForMoCompConversion()))
                return DDERR_GENERIC;

            tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
                     (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
                     (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
                     (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
                     (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
                     (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
                     (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_FILTER(1) | 0x40000);
            nvPushData(1, tmpVal);

            nvPusherAdjust(2);

            // 420 LUMA portion of this surface starts at fpVidMem
            dwDstOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(1, dwDstOffset);

            // 420 CHROMA portion of this surface starts here
            dwDstOffset += (pSurf_gbl->lPitch * pSurf_gbl->wHeight);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(3, dwDstOffset);
            nvPusherAdjust(4);
        } else {

            if (!(nvInitCelsiusForMoCompConversion()))
                return DDERR_GENERIC;

            tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
                     (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_FILTER(1) | 0x40000);
            nvPushData(1, tmpVal);

            nvPusherAdjust(2);

            // 420 LUMA portion of this surface starts at fpVidMem
            dwDstOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
            nvPushData(1, dwDstOffset);

            // 420 CHROMA portion of this surface starts here
            dwDstOffset += (pSurf_gbl->lPitch * pSurf_gbl->wHeight);
            nvPushData(2, dwDstOffset);
            nvPusherAdjust(3);
        }

        if (revertRegion) {
            dw422Offset = lpDstSurfaceFlags->dwMCSurface422Offset;

            // Offset to NV12 surface filtered pixel area if necessary
            if (lpDstSurfaceFlags->bMCFrameIsFiltered) {
                if ((lpDstSurfaceFlags->bMCPictureStructure != PICTURE_STRUCTURE_FRAME) ||
                    (lpNvSPCompositeData->bSPCompositeWith != PICTURE_STRUCTURE_FRAME)) {
                    dw422Offset += (pitch422 * (DWORD)pSurf_gbl->wHeight);  // 422 portion
                }
            }
        } else {
            dw422Offset = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);
            dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight; // calculate size of subpicture 8 bit index per pixel plane
            dwBlockSize <<= 1;                  // double size to skip over 8 bit alpha per pixel plane
            dw422Offset += dwBlockSize;         // offset to base of fully decompressed pixel plane in video memory
            dw422Offset += (dwBlockSize << 1);  // increase to skip fully decompressed 32 bit per pixel plane
            dw422Offset += 1024;                // also skip indexed image look up table
        }


        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, dw422Offset);

            nvPusherAdjust(4);

            SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_BEGIN_END | 0x40000);
            nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_INLINE_ARRAY | 0x40300000);

            nvPushData(3, (Y0 << 18) | (X0 << 1));
            nvPushData(4, (Y0 << 16) | (X0 >> 1));
            nvPushData(5, (Y0 << 15) | (X0 >> 1));

            nvPushData(6, ((Y1 << 2) << 16) | (X0 << 1)); // destination is in quarter pel units
            nvPushData(7, (Y1 << 16) | (X0 >> 1)); // LUMA texture is in pel units
            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(8, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            else
                nvPushData(8, ((Y1 >> 2) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height

            nvPushData(9, ((Y1 << 2) << 16) | (X1 << 1)); // each 32 bit write contains data for 2 422 pixels
            nvPushData(10, (Y1 << 16) | (X1 >> 1));
            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(11, ((Y1 >> 1) << 16) | (X1 >> 1));
            else
                nvPushData(11, ((Y1 >> 2) << 16) | (X1 >> 1));

            nvPushData(12, (Y0 << 18) | (X1 << 1));
            nvPushData(13, (Y0 << 16) | (X1 >> 1));
            nvPushData(14, (Y0 << 15) | (X1 >> 1));

            nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_BEGIN_END | 0x40000);
            nvPushData(16, NV097_SET_BEGIN_END_OP_END);
            nvPusherAdjust(17);
        } else {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, dw422Offset);

            nvPusherAdjust(4);

            SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_BEGIN_END | 0x40000);
            nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_INLINE_ARRAY(0) | 0x300000);

            // No HD scaled version because subpicture compositing is not used for HD 
            nvPushData(3, (Y0 << 15) | (X0 >> 1));
            nvPushData(4, (Y0 << 16) | (X0 >> 1));
            nvPushData(5, (Y0 << 18) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(6, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            else
                nvPushData(6, ((Y1 >> 2) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            nvPushData(7, (Y1 << 16) | (X0 >> 1)); // LUMA texture is in pel units
            nvPushData(8, ((Y1 << 2) << 16) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination is in quarter pel units

            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(9, ((Y1 >> 1) << 16) | (X1 >> 1));
            else
                nvPushData(9, ((Y1 >> 2) << 16) | (X1 >> 1));
            nvPushData(10, (Y1 << 16) | (X1 >> 1));
            nvPushData(11, ((Y1 << 2) << 16) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // each 32 bit write contains data for 2 422 pixels

            nvPushData(12, (Y0 << 15) | (X1 >> 1));
            nvPushData(13, (Y0 << 16) | (X1 >> 1));
            nvPushData(14, (Y0 << 18) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

            nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_BEGIN_END | 0x40000);
            nvPushData(16, NV056_SET_BEGIN_END_OP_END);
            nvPusherAdjust(17);
        }

        nvPusherStart(TRUE);
    }

    if (!revertRegion) {
        unsigned long dwSPSrcOffset;
        unsigned long dwSurfacePitch;
        unsigned long surfaceWidth;
        unsigned long tmpVal;
        
        dwSrcOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

        // compositing portion of this surface starts here (overwrites filtered portion)
        dwDstOffset = lpDstSurfaceFlags->dwMCSurface422Offset + (pitch422 * (DWORD)pSurf_gbl->wHeight);   // 420 compositing and 422 filtering portion

        if (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing == 0)
            dw422Offset = dwDstOffset;

        if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
            lpDstSurfaceFlags->bMCFrameIsComposited = PICTURE_STRUCTURE_FRAME;
        else if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_TOP_FIELD)
            lpDstSurfaceFlags->bMCFrameIsComposited |= PICTURE_STRUCTURE_TOP_FIELD;
        else
            lpDstSurfaceFlags->bMCFrameIsComposited |= PICTURE_STRUCTURE_BOTTOM_FIELD;

        dwSPSrcOffset = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);

        dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight;   // calculate size of subpicture 8 bit index per pixel plane
        dwBlockSize <<= 1;                                          // double size to skip over 8 bit alpha per pixel plane

        dwSPSrcOffset += dwBlockSize;                               // offset to base of fully decompressed pixel plane in video memory

        if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
            if (!(nvInitCelsiusForMoComp()))
                return DDERR_GENERIC;
        }

        // Now blend subpicture rectangle with NV12 luma plane

        if (!(nvInitCelsiusForMoCompNV12LumaSubpictureCompositing()))
            return DDERR_GENERIC;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwDstOffset);

        nvPusherAdjust(4);

        dwSurfacePitch = pSurf_gbl->lPitch;
        dwSurfacePitch |= (dwSurfacePitch << 16);
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, dwSurfacePitch);

        nvPusherAdjust(2);
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(1, dwSPSrcOffset);
        nvPushData(2, dwSrcOffset);

        nvPusherAdjust(3);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, pSPSurf_gbl->lPitch << 18); // pitch << 2
        nvPushData(2, dwSurfacePitch << 16);

        nvPusherAdjust(3);

        SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x300000);

        // No HD scaled version because subpicture compositing is not used for HD 
        nvPushData(3, (Y0 << 16) | (X0)); // source NV12 luma in pel units
        nvPushData(4, (SPY0 << 16) | (SPX0)); // AVUY subpicture in pel units
        nvPushData(5, (Y0 << 18) | (((X0 << 2) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination NV12 luma in quarter pel units

        nvPushData(6, (Y1 << 16) | (X0));
        nvPushData(7, (SPY1 << 16) | (SPX0));
        nvPushData(8, (Y1 << 18) | (((X0 << 2) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(9, (Y1 << 16) | (X1));
        nvPushData(10, (SPY1 << 16) | (SPX1));
        nvPushData(11, (Y1 << 18) | (((X1 << 2) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(12, (Y0 << 16) | (X1));
        nvPushData(13, (SPY0 << 16) | (SPX1));
        nvPushData(14, (Y0 << 18) | (((X1 << 2) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

        // Now blend subpicture rectangle with NV12 chroma plane
        
        if (!(nvInitCelsiusForMoCompNV12ChromaSubpictureCompositing()))
            return DDERR_GENERIC;

        dwDstOffset += pSurf_gbl->lPitch * (DWORD)pSurf_gbl->wHeight; // Change offset to destination chroma plane

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwDstOffset);

        nvPusherAdjust(4);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, dwSurfacePitch);

        nvPusherAdjust(2);
        
        dwSrcOffset += pSurf_gbl->lPitch * (DWORD)pSurf_gbl->wHeight; // Change offset to source chroma plane

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(1, dwSPSrcOffset);
        nvPushData(2, dwSrcOffset);

        nvPusherAdjust(3);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, pSPSurf_gbl->lPitch << 18); // pitch << 2
        nvPushData(2, dwSurfacePitch << 16);

        nvPusherAdjust(3);

        SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x300000);

        // No HD scaled version because subpicture compositing is not used for HD 
        nvPushData(3, ((Y0 >> 1) << 16) | (X0 >> 1)); // source NV12 chroma in pel units
        nvPushData(4, (SPY0 << 16) | (SPX0)); // AVUY subpicture in pel units
        nvPushData(5, (Y0 << 17) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination NV12 chroma in quarter pel units

        nvPushData(6, ((Y1 >> 1) << 16) | (X0 >> 1));
        nvPushData(7, (SPY1 << 16) | (SPX0));
        nvPushData(8, (Y1 << 17) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(9, ((Y1 >> 1) << 16) | (X1 >> 1));
        nvPushData(10, (SPY1 << 16) | (SPX1));
        nvPushData(11, (Y1 << 17) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(12, ((Y0 >> 1) << 16) | (X1 >> 1));
        nvPushData(13, (SPY0 << 16) | (SPX1));
        nvPushData(14, (Y0 << 17) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

        // Update reference count in case we get a status query
        lpDstSurfaceFlags->dwMCCompositeReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

        nvPusherStart(TRUE);

        // Now format convert final NV12 blended rectangle to 422 overwriting current 422 pixels

        if (!(nvInitCelsiusForMoCompConversion()))
            return FALSE;

        tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
                 (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_FILTER(1) | 0x40000);
        nvPushData(1, tmpVal);

        nvPusherAdjust(2);

        // 420 LUMA portion of this surface starts at fpVidMem
        dwDstOffset -= pSurf_gbl->lPitch * (DWORD)pSurf_gbl->wHeight; // Change offset back to destination luma plane
        
        dwSurfacePitch = pSurf_gbl->lPitch;
        
        surfaceWidth = pSurf_gbl->wWidth;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(1, dwDstOffset);

        // 420 CHROMA portion of this surface starts here
        dwDstOffset += (dwSurfacePitch * pSurf_gbl->wHeight);

        nvPushData(2, dwDstOffset);

        nvPusherAdjust(3);

        // 422 portion of this surface starts here
        dwDstOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwDstOffset);

        nvPusherAdjust(4);

        // Align surface pitch and set surface format and pitch
        dwSurfacePitch = ((surfaceWidth << 1) + 127) & ~127; // YUY2 destination is twice the surface width
        dwSurfacePitch |= (dwSurfacePitch << 16);
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, dwSurfacePitch);

        nvPusherAdjust(2);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, pSurf_gbl->lPitch << 16);
        nvPushData(2, pSurf_gbl->lPitch << 16);

        nvPusherAdjust(3);

        SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x300000);

        // No HD scaled version because subpicture compositing is not used for HD 
        nvPushData(3, ((Y0 >> 1) << 16) | 0);
        nvPushData(4, (Y0 << 16) | 0);
        nvPushData(5, (Y0 << 18) | ((0 - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(6, ((Y1 >> 1) << 16) | 0); // CHROMA texture is in pel units and is only half the surface height
        nvPushData(7, (Y1 << 16) | 0); // LUMA texture is in pel units
        nvPushData(8, (Y1 << 18) | ((0 - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination is in quarter pel units

        nvPushData(9, ((Y1 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(10, (Y1 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(11, (Y1 << 18) | (((surfaceWidth << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // each 32 bit write contains data for 2 422 pixels

        nvPushData(12, ((Y0 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(13, (Y0 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(14, (Y0 << 18) | (((surfaceWidth << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

        // Update reference count so we know when we can display this surface
        lpDstSurfaceFlags->dwMCFormatCnvReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

        nvPusherStart(TRUE);

        lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted |= 15;
    }

    nvPusherStart(TRUE);

    return DD_OK;

} /* nvMoCompCompositeNV12Subpicture */

#endif


/*
 * nvMoCompDisplaySurface
 *
 * Displays the current destination FOURCC_NV12 overlay surface
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompDisplaySurface(LPVOID lpInputData, DWORD dwSurfaceIndex)
{
    LPNVMCDISPLAYOVERLAYDATA    lpNvMCDisplayOverlayData = (LPNVMCDISPLAYOVERLAYDATA)lpInputData;
    NvNotification              *pPioFlipOverlayNotifier;
    HRESULT                     ddrval;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
#ifndef WINNT
    DWORD                       dwSavedNBData;
#endif
    DWORD                       dwVPPFlags;
    LPNVMCSURFACEFLAGS          lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
    unsigned long               returnVal;

    dbgTracePush ("nvMoCompDisplaySurface");

    DDSTARTTICK(SURF4_FLIP);
    DDFLIPTICKS(FEFLIP);

    pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;

    if (dwSurfaceIndex >= 8) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }

    pSurf = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[dwSurfaceIndex];

    if (pSurf == 0) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDERR_NOTFOUND);
    }

    pDriverData->dwMCDestinationSurface = (DWORD)pSurf;
    pSurf_gbl = pSurf->lpGbl;

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDERR_SURFACELOST);
    }

    // If UpdateOverlay hasn't been called yet then just return success
    if (GET_HALINFO()->ddCaps.dwCurrVisibleOverlays == 0) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return DD_OK;
    }

    if ((pDriverData->bMCOverlaySrcIsSingleField1080i) &&
        (lpNvMCDisplayOverlayData->dwMCFlipFlags & DDFLIP_ODD)) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return DD_OK;
    }

    while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
        lpSurfaceFlags++;

    // Make sure the surface has been format converted
    if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
        (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 15);
    else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) &&
        ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 3);
    else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
        (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 12))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 12);

    // Has this surface finished format conversion yet ?
    if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                   lpSurfaceFlags->dwMCFormatCnvReferenceCount,
                                   1)) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDERR_WASSTILLDRAWING);
    }

    // If this is a composited surface, is it done compositing yet ?
    if (lpSurfaceFlags->bMCFrameIsComposited) {
        if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                       lpSurfaceFlags->dwMCCompositeReferenceCount,
                                       1)) {
            DDENDTICK(SURF4_FLIP);
            dbgTracePop();
            return (DDERR_WASSTILLDRAWING);
        }
    }

    // If this is a filtered surface, is it done filtering yet ?
    if (lpSurfaceFlags->bMCFrameIsFiltered) {
        if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                       lpSurfaceFlags->dwMCTemporalFilterReferenceCount,
                                       1)) {
            DDENDTICK(SURF4_FLIP);
            dbgTracePop();
            return (DDERR_WASSTILLDRAWING);
        }
    }

    // Check if filtering is disabled on this surface for this display call only
    if (lpSurfaceFlags->bMCFrameType & TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE) {
        lpSurfaceFlags->bMCFrameIsFiltered = FALSE;
        lpSurfaceFlags->bMCFrameType &= ~TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE;
    }

    // Always display non-filtered portion of non-interleaved frames
    if ((lpNvMCDisplayOverlayData->dwMCFlipFlags & (DDFLIP_ODD | DDFLIP_EVEN)) == 0) {
        if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME)
            lpSurfaceFlags->bMCFrameIsFiltered = FALSE;
    }

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDERR_SURFACELOST);
    }

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvDDrawRecover();
        }
        else {
            DDENDTICK(SURF4_FLIP);
            dbgTracePop();
            return (DDERR_SURFACELOST);
        }
    }

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // turn off write posting
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, 0
                in  al, dx
                mov dwSavedNBData, eax
                and eax, 0FFFFFF7Fh
                out dx, al
        }
    }
#endif

    /* Limit flips to 1 at a time to work around NV4 RM limitation */
    ddrval = nvMoCompFrameStatus (pSurf_gbl->fpVidMem);

    /* Only reject flip requests when flipping frames (but allow fields to proceed) */
    if ((lpNvMCDisplayOverlayData->dwMCFlipFlags & (DDFLIP_ODD | DDFLIP_EVEN)) == 0) {
        if (ddrval != DD_OK) {
            if (lpNvMCDisplayOverlayData->dwMCFlipFlags & DDFLIP_WAIT) {
                while (ddrval != DD_OK) {
                    ddrval = nvMoCompFrameStatus (pSurf_gbl->fpVidMem);
                    if (ddrval != DD_OK) {
                        NV_SLEEPFLIP;
                    }
                }
            }
            else {
#ifndef WINNT
                // check for VIA 82C598 north bridge
                if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
                    // restore write posting value
                    _asm {
                            mov edx, 0cf8h
                            mov eax, 80000840h
                            out dx, eax
                            mov edx, 0cfch
                            mov eax, dwSavedNBData
                            out dx, al
                    }
                }
#endif
                DDENDTICK(SURF4_FLIP);
                dbgTracePop();
                return (DDERR_WASSTILLDRAWING);
            }
        }
    } else {
        if (ddrval != DD_OK) {
            NV_SLEEPFLIP;
            DDENDTICK(SURF4_FLIP);
            dbgTracePop();
            return (DDERR_WASSTILLDRAWING);
        }
    }

    /*
     * make sure we sync with other channels before writing put
     */
    getDC()->nvPusher.setSyncChannelFlag();

    getDC()->flipOverlayRecord.llPreviousFlipTime = getDC()->flipOverlayRecord.llFlipTime;
    QueryPerformanceCounter((LARGE_INTEGER *) &getDC()->flipOverlayRecord.llFlipTime);
    getDC()->flipOverlayRecord.fpPreviousFlipFrom = getDC()->flipOverlayRecord.fpFlipFrom;
    getDC()->flipOverlayRecord.fpFlipFrom = getDC()->flipOverlayRecord.fpFlipTo;
    getDC()->flipOverlayRecord.fpFlipTo = pSurf_gbl->fpVidMem;

    getDC()->flipOverlayRecord.bFlipFlag = TRUE;

//    dwVPPFlags = VPP_OPTIMIZE | VPP_PRESCALE; // only when rescaling already visible surface
    dwVPPFlags = VPP_MOCOMP;
    if (lpNvMCDisplayOverlayData->dwMCOverlayFlags & DDOVER_INTERLEAVED) {
        dwVPPFlags |= VPP_INTERLEAVED;
    }
    if (lpNvMCDisplayOverlayData->dwMCOverlayFlags & DDOVER_BOB) {
        dwVPPFlags |= VPP_BOB;
    }
    if (lpNvMCDisplayOverlayData->dwMCFlipFlags & DDFLIP_ODD) {
        dwVPPFlags |= VPP_ODD;
    } else if (lpNvMCDisplayOverlayData->dwMCFlipFlags & DDFLIP_EVEN) {
        dwVPPFlags |= VPP_EVEN;
    }

    returnVal = VppDoFlip(&(pDriverData->vpp),
                          VIDMEM_OFFSET(pSurf_gbl->fpVidMem),
                          pSurf_gbl->lPitch,
                          pSurf_gbl->wWidth,
                          pSurf_gbl->wHeight,
                          pSurf_gbl->ddpfSurface.dwFourCC,
                          dwVPPFlags);

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // restore write posting value
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, dwSavedNBData
                out dx, al
        }
    }
#endif

    DDENDTICK(SURF4_FLIP);
    dbgTracePop();
    return (returnVal ? DD_OK : DDERR_WASSTILLDRAWING);

} /* nvMoCompDisplaySurface */


/*
 * nvGetMoCompGuids
 *
 * Returns our motion comp GUID
 *
 */
DWORD __stdcall nvGetMoCompGuids( LPDDHAL_GETMOCOMPGUIDSDATA lpGMCGData)
{
    nvSetDriverDataPtrFromDDGbl(lpGMCGData->lpDD->lpGbl);

    if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
        lpGMCGData->ddRVal = DDERR_UNSUPPORTED;
        NvReleaseSemaphore(pDriverData);
        return (DDHAL_DRIVER_HANDLED);
    }

    lpGMCGData->dwNumGuids = 4;

    // Return DX VA Guids for MPEG2 Type A and B restricted profiles.
    if (lpGMCGData->lpGuids != NULL) {
        memcpy(lpGMCGData->lpGuids,     (GUID *)&DXVA_ModeMPEG2_A, sizeof(GUID));
        memcpy(lpGMCGData->lpGuids + 1, (GUID *)&DXVA_ModeMPEG2_B, sizeof(GUID));
        memcpy(lpGMCGData->lpGuids + 2, (GUID *)&DXVA_ModeMPEG2_C, sizeof(GUID));
        memcpy(lpGMCGData->lpGuids + 3, (GUID *)&DXVA_ModeMPEG2_D, sizeof(GUID));
    }

    NvReleaseSemaphore(pDriverData);
    lpGMCGData->ddRVal = DD_OK;

    return (DDHAL_DRIVER_HANDLED);

} /* nvGetMoCompGuids */



/*
 * nvGetMoCompFormats
 *
 * Returns our motion comp uncompressed surface format
 *
 */
DWORD __stdcall nvGetMoCompFormats( LPDDHAL_GETMOCOMPFORMATSDATA lpGMCFData)
{
    nvSetDriverDataPtrFromDDGbl(lpGMCFData->lpDD->lpGbl);

    // Assume we will succeed
    lpGMCFData->ddRVal = DD_OK;

    // If either MPEG2 A, B, C, or D guid is provided, return the
    // uncompressed overlay format we support.
    if (IsEqualIID_C(*(lpGMCFData->lpGuid), DXVA_ModeMPEG2_A) ||
        IsEqualIID_C(*(lpGMCFData->lpGuid), DXVA_ModeMPEG2_B) ||
        IsEqualIID_C(*(lpGMCFData->lpGuid), DXVA_ModeMPEG2_C) ||
        IsEqualIID_C(*(lpGMCFData->lpGuid), DXVA_ModeMPEG2_D)) {
        lpGMCFData->dwNumFormats = 1;

        if (lpGMCFData->lpFormats != NULL) {
            lpGMCFData->lpFormats[0].dwFlags = DDPF_FOURCC;
            lpGMCFData->lpFormats[0].dwFourCC = FOURCC_NV12;
            lpGMCFData->lpFormats[0].dwYUVBitCount = 12;
            lpGMCFData->lpFormats[0].dwYBitMask = 0;
            lpGMCFData->lpFormats[0].dwUBitMask = 0;
            lpGMCFData->lpFormats[0].dwVBitMask = 0;
            lpGMCFData->lpFormats[0].dwYUVAlphaBitMask = 0;
        }

    } else {
        lpGMCFData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvGetMoCompFormats */


/*
 * nvCreateMoComp
 *
 * Returns whether we can support a motion comp uncompressed surface of
 * the requested format and size
 *
 */
DWORD __stdcall nvCreateMoComp( LPDDHAL_CREATEMOCOMPDATA lpCMCData)
{
    BYTE                        bIndex;
    LPDXVA_ConnectMode          lpConnectMode;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;

    nvSetDriverDataPtrFromDDGbl(lpCMCData->lpDD->lpGbl);

    // Assume we will succeed
    lpCMCData->ddRVal = DD_OK;

    if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
        lpCMCData->ddRVal = DDERR_UNSUPPORTED;
    } else {
        if (IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_A) ||
            IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_B) ||
            IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_C) ||
            IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_D)) {

            if (lpCMCData->ddUncompPixelFormat.dwFourCC == FOURCC_NV12) {
                // Maximum NV10 motion comp texture width/height is 2046
                if (lpCMCData->dwUncompWidth > 2046)
                    lpCMCData->ddRVal = DDERR_TOOBIGWIDTH;

                if (lpCMCData->dwUncompHeight > 2046)
                    lpCMCData->ddRVal = DDERR_TOOBIGHEIGHT;
            } else {
                lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
            }
        } else {
            lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
        }
    }

    // Check connect mode data and make sure it matches what we want.
    lpConnectMode = (LPDXVA_ConnectMode)lpCMCData->lpData;

    if (IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_A)) {
        if ((lpConnectMode->guidMode        != DXVA_ModeMPEG2_A) ||
            (lpConnectMode->wRestrictedMode != DXVA_RESTRICTED_MODE_MPEG2_A))
            lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }
    else if (IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_B)) {
        if ((lpConnectMode->guidMode        != DXVA_ModeMPEG2_B) ||
            (lpConnectMode->wRestrictedMode != DXVA_RESTRICTED_MODE_MPEG2_B))
            lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }
    else if (IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_C)) {
        if ((lpConnectMode->guidMode        != DXVA_ModeMPEG2_C) ||
            (lpConnectMode->wRestrictedMode != DXVA_RESTRICTED_MODE_MPEG2_C))
            lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }
    else if (IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_D)) {
        if ((lpConnectMode->guidMode        != DXVA_ModeMPEG2_D) ||
            (lpConnectMode->wRestrictedMode != DXVA_RESTRICTED_MODE_MPEG2_D))
            lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }

    // If everything's okay, allocate a system memory buffer for
    // processing Macroblock control headers in Render.
    if (lpCMCData->ddRVal == DD_OK)
        pDriverData->dwDXVAConvertBuffer = (DWORD)GlobalAlloc(GMEM_FIXED, CONVERT_BUFFER_SIZE);

    // Initialize some things in pDriverData.
    pDriverData->dwDXVAFlags |= DXVA_MO_COMP_IN_PROGRESS;

    if (pDriverData->vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_DXVA_BACK_END_ALPHA_PREFERRED) {
        pDriverData->dwDXVAFlags |= DXVA_BACK_END_ALPHA_SELECTED;
    } else {
        pDriverData->dwDXVAFlags &= ~DXVA_BACK_END_ALPHA_SELECTED;
    }

    // Initialize some things in our NVMC surface.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);
    lpNvMCFrameData->dwDXVASubpicBuffer = 0;
    lpNvMCFrameData->dwDXVASubpicStride = 0;

    // In case the decoder doesn't call BeginFrame for a surface before using the
    // surface, we try to initialize our surface index arrays to reasonable values.
    // These should be overrwritten by BeginFrame later.
    for (bIndex = 0; bIndex < 8; bIndex++) {
        if (pDriverData->dwMCNV12Surface[bIndex]) {
            pDriverData->bDXVAIndexToNVIndex[bIndex] = bIndex;
            pDriverData->dwDXVAIndexToVidMem[bIndex] =
                ((LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[bIndex])->lpGbl->fpVidMem;
        }
        else {
            pDriverData->bDXVAIndexToNVIndex[bIndex] = 0;
            pDriverData->dwDXVAIndexToVidMem[bIndex] = 0;
        }
    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvCreateMoComp */


/*
 * nvGetMoCompBuffInfo
 *
 * Returns our required motion comp buffer info
 *
 */
DWORD __stdcall nvGetMoCompBuffInfo( LPDDHAL_GETMOCOMPCOMPBUFFDATA lpGMCBData)
{
    nvSetDriverDataPtrFromDDGbl(lpGMCBData->lpDD->lpGbl);

    // Assume we will succeed
    lpGMCBData->ddRVal = DD_OK;

    if (IsEqualIID_C(*(lpGMCBData->lpGuid), DXVA_ModeMPEG2_A) ||
        IsEqualIID_C(*(lpGMCBData->lpGuid), DXVA_ModeMPEG2_B) ||
        IsEqualIID_C(*(lpGMCBData->lpGuid), DXVA_ModeMPEG2_C) ||
        IsEqualIID_C(*(lpGMCBData->lpGuid), DXVA_ModeMPEG2_D)) {
        if (lpGMCBData->ddPixelFormat.dwFourCC == FOURCC_NV12) {
            if (lpGMCBData->lpCompBuffInfo == NULL) {
                lpGMCBData->dwNumTypesCompBuffs = 16;
            }
            else if (lpGMCBData->dwNumTypesCompBuffs < 16) {
                lpGMCBData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
            }
            else {

                DWORD   dwPadWidth, dwPadHeight;
                DWORD   dwFlags, dwRGBBitCount, dwBytesPerPixel;
                DWORD   dwRBitMask, dwGBitMask, dwBBitMask;
                DWORD   dwScreenWidth;

                // We always fill in exactly 16 buffers structures for DXVA.
                lpGMCBData->dwNumTypesCompBuffs = 16;

                // Calculate RGB parameters for the first two types of surfaces.
                dwScreenWidth = GET_MODE_WIDTH();
                dwRGBBitCount = GET_MODE_BPP();
                dwBytesPerPixel = dwRGBBitCount / 8;
                switch (dwRGBBitCount)
                {
                case 8:
                    dwFlags = DDPF_RGB | DDPF_PALETTEINDEXED8;
                    dwRBitMask = dwGBitMask = dwBBitMask = 0;
                    break;

                case 16:
                    dwFlags = DDPF_RGB;
                    dwRBitMask = 0xf800;
                    dwGBitMask = 0x07e0;
                    dwBBitMask = 0x001f;
                    break;

                case 32:
                    dwFlags = DDPF_RGB;
                    dwRBitMask = 0x00ff0000;
                    dwGBitMask = 0x0000ff00;
                    dwBBitMask = 0x000000ff;
                    break;
                }

                // Initialize unused CompBuffInfo structure members to zero.
                memset(lpGMCBData->lpCompBuffInfo, 0, 16 * sizeof(DDMCBUFFERINFO));

                // The #0 CompBuffInfo structure isn't used by DXVA.
                // We'll use it to create an NVMC surface to assist our motion comp decoding.
                // The width and height are ignored by our driver.  Creating this surface
                // causes our CreateSurface32 function to initialize certain index arrays
                // related to the NV12 and NVID surfaces.
                lpGMCBData->lpCompBuffInfo[0].dwNumCompBuffers = 1;
                lpGMCBData->lpCompBuffInfo[0].dwWidthToCreate = 16;
                lpGMCBData->lpCompBuffInfo[0].dwHeightToCreate = 16;
                lpGMCBData->lpCompBuffInfo[0].dwBytesToAllocate = 256;
                lpGMCBData->lpCompBuffInfo[0].ddCompCaps.dwCaps = DDSCAPS_VIDEOMEMORY |
                                                                   DDSCAPS_LOCALVIDMEM |
                                                                   DDSCAPS_OVERLAY;
                lpGMCBData->lpCompBuffInfo[0].ddPixelFormat.dwFlags = DDPF_FOURCC;
                lpGMCBData->lpCompBuffInfo[0].ddPixelFormat.dwFourCC = FOURCC_NVMC;
                lpGMCBData->lpCompBuffInfo[0].ddPixelFormat.dwYUVBitCount = 16;

                // The #1 CompBuffInfo structure must be for a picture parameter buffer,
                // large enough to hold a DXVA_PictureParameters structure.  Here we create
                // it as an RGB surface, but the exact format doesn't matter.  We put it in
                // local video memory so Lock32 will wait until all previous decoding is done.
                dwPadWidth = (sizeof(DXVA_PictureParameters) + 7) & 0xFFFFFFF8L;
                dwPadHeight = 1;
                lpGMCBData->lpCompBuffInfo[1].dwNumCompBuffers = 1;
                lpGMCBData->lpCompBuffInfo[1].dwWidthToCreate = dwPadWidth / dwBytesPerPixel;
                lpGMCBData->lpCompBuffInfo[1].dwHeightToCreate = dwPadHeight;
                lpGMCBData->lpCompBuffInfo[1].dwBytesToAllocate = dwPadWidth * dwPadHeight;
                lpGMCBData->lpCompBuffInfo[1].ddCompCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                                  DDSCAPS_SYSTEMMEMORY;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwFlags = dwFlags;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwFourCC = 0;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwRGBBitCount = dwRGBBitCount;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwRBitMask = dwRBitMask;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwGBitMask = dwGBitMask;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwBBitMask = dwBBitMask;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #2 CompBuffInfo structure must be for a macroblock control command buffer.
                // We want three of these, to match the three NVID buffers requested below.
                // Again we create them as RGB buffers but they're just a plain memory buffers.
                dwPadWidth = 1800;                                      // Enough for PAL DVD frame, plus padding.
                dwPadHeight = sizeof(DXVA_MBctrl_P_HostResidDiff_1);    // Max size of each macroblock structure.
                lpGMCBData->lpCompBuffInfo[2].dwNumCompBuffers = 3;
                lpGMCBData->lpCompBuffInfo[2].dwWidthToCreate = dwPadWidth / dwBytesPerPixel;
                lpGMCBData->lpCompBuffInfo[2].dwHeightToCreate = dwPadHeight;
                lpGMCBData->lpCompBuffInfo[2].dwBytesToAllocate = dwPadWidth * dwPadHeight;
                lpGMCBData->lpCompBuffInfo[2].ddCompCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                                  DDSCAPS_SYSTEMMEMORY;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwFlags = dwFlags;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwFourCC = 0;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwRGBBitCount = dwRGBBitCount;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwRBitMask = dwRBitMask;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwGBitMask = dwGBitMask;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwBBitMask = dwBBitMask;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #3 CompBuffInfo structure must be for a residual difference buffer,
                // to hold host-based IDCT data.  They're allocated in local video memory.
                // If frame buffer is 32MB or greater, we want 3 buffers 1MB each, unless
                // TwinView is enabled, then only use 2 to leave room for Video Mirror.
                if (pDriverData->TotalVRAM >= 0x2000000) {

                    if ((pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW) ||
                        (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE)) {

                        lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers = 2;
                        lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = 1024L * 1024L;
                    }
                    else {
                        lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers = 3;
                        lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = 1024L * 1024L;
                    }
                }

                // Else for 16MB NTSC-size DVD playback...
                else if (lpGMCBData->dwHeight <= 480) {

                    // For the special case of TwinView 1024x768x32, we allocate
                    // the minimum amount to allow Video Mirror to work OK.
                    if (((pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW) ||
                        (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE)) &&
                        (dwScreenWidth == 1024) && (dwRGBBitCount == 32)) {

                        lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers = 1;
                        lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate = 600;
                        lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = 1024L * 600L;
                    }
                    else  if (dwScreenWidth == 800){
                        //DCT test mode.  DCT requires at least 6 NV12 surfaces
                        // allocate less memory for NVID surfaces.
                        lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers = 3;
                        lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate = 600;
                        lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = 3L*1024L * 600L;

                    }
                    else {
                        DWORD dwTotalMem, dwFreeMem, dwNumBuffer, dwBufferHeight,dwBufferWidth;
                        //FOURCC_NVSP surface 
                        dwTotalMem =(768 * 576 * 2) + (768 * 576 * 4) + 1024 +(768 * 576 * 2);
                        //add  4 NV12 and one extra (size based on Steven's DXVA Memory Layout SpreadSheets)
                        dwTotalMem += 1296640 * 5;
                        //buffer width
                        dwBufferWidth = 512;
                        if(pDriverData->VideoHeapFree >(int)dwTotalMem)
                        {
                            // Find out total free memory
                            dwFreeMem = pDriverData->VideoHeapFree - dwTotalMem;
                            //choose 512X2048 first
                            dwBufferHeight = 2048;
                            dwNumBuffer = dwFreeMem / (dwBufferWidth * dwBufferHeight);
                            if( dwNumBuffer < 2)
                            {
                                 dwNumBuffer = 2;                        //may be no memory to support DXVA
                                 dwBufferHeight = 1200;
                            }
                            else if(dwNumBuffer > 3)
                            {
                                //increas buffer size
                                dwNumBuffer = 3;
                                dwBufferHeight = dwFreeMem / ( dwBufferWidth * 3);
                                if(dwBufferHeight > 6144 )
                                    dwBufferHeight = 6144;
                                else
                                    dwBufferHeight &= ~511;

                            }

                        }
                        else
                        {
                            dwNumBuffer = 2;                        //no memory to support DXVA
                            dwBufferHeight = 1200;
                        }

                        lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers  = dwNumBuffer;
                        lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate	= dwBufferWidth;
                        lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate	= dwBufferHeight;
                        lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = dwBufferWidth * dwBufferHeight * dwNumBuffer;
                    }		
                }
                // Else for 16MB PAL-size DVD playback, do the same thing but with
                // PAL-size buffers.
                else {
                    lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers = 2;
                    lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate = 1024;
                    lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate = 700;
                    lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = 1024L * 700L;
                }

                lpGMCBData->lpCompBuffInfo[3].ddCompCaps.dwCaps = DDSCAPS_VIDEOMEMORY;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwFlags = DDPF_FOURCC;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwFourCC = FOURCC_NVID;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwYUVBitCount = 8;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwYBitMask = 0;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwUBitMask = 0;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwVBitMask = 0;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwYUVAlphaBitMask = 0;

                // The #4 CompBuffInfo structure must be for a Deblocking Filter Control buffer.
                // We don't use this one.

                // The #5 CompBuffInfo structure must be for a Inverse Quantization Matrix buffer.
                // We don't use this one.

                // The #6 CompBuffInfo structure must be for a Slice Control buffer.
                // We don't use this one.

                // The #7 CompBuffInfo structure must be for a Bitstream Data buffer.
                // We don't use this one.

                // The #8 CompBuffInfo structure must be for a YUV Palette buffer.
                // We can put this one in system memory.
                dwPadWidth = 64;
                lpGMCBData->lpCompBuffInfo[8].dwNumCompBuffers = 2;
                lpGMCBData->lpCompBuffInfo[8].dwWidthToCreate = dwPadWidth / dwBytesPerPixel;
                lpGMCBData->lpCompBuffInfo[8].dwHeightToCreate = 1;
                lpGMCBData->lpCompBuffInfo[8].dwBytesToAllocate = dwPadWidth;
                lpGMCBData->lpCompBuffInfo[8].ddCompCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                                  DDSCAPS_SYSTEMMEMORY;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwFlags = dwFlags;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwFourCC = 0;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwRGBBitCount = dwRGBBitCount;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwRBitMask = dwRBitMask;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwGBitMask = dwGBitMask;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwBBitMask = dwBBitMask;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #9 CompBuffInfo structure must be for an IA44 Alpha Blending buffer.
                // We can put this one in system memory.  Always make it 720x576, since
                // subpicture size may be independent of DVD video size.
                dwPadWidth  = 720;
                dwPadHeight = 576;
                lpGMCBData->lpCompBuffInfo[9].dwNumCompBuffers = 2;
                lpGMCBData->lpCompBuffInfo[9].dwWidthToCreate = dwPadWidth / dwBytesPerPixel;
                lpGMCBData->lpCompBuffInfo[9].dwHeightToCreate = dwPadHeight;
                lpGMCBData->lpCompBuffInfo[9].dwBytesToAllocate = dwPadWidth * dwPadHeight;
                lpGMCBData->lpCompBuffInfo[9].ddCompCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                                  DDSCAPS_SYSTEMMEMORY;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwFlags = dwFlags;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwFourCC = 0;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwRGBBitCount = dwRGBBitCount;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwRBitMask = dwRBitMask;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwGBitMask = dwGBitMask;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwBBitMask = dwBBitMask;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #10 CompBuffInfo structure is for a DPXD Alpha Blending buffer.
                // We don't support DPXD, but we'll use this structure to create a
                // private NVSP surface that we need for subpicture blending.
                // The NVSP surface contains the following buffers:
                //   720x576x2  Compressed subpicture (currently not used for DXVA)
                //   720x576x4  Uncompressed subpicture in YUV32 format
                //   256x4      Lookup table buffer (currently no used for DXVA)
                //   720x576x2  Mixer buffer for subpicture blending
                // Note that the 720 width is padded to a 768 stride for dwBytesToAllocate.
                lpGMCBData->lpCompBuffInfo[10].dwNumCompBuffers = 1;
                lpGMCBData->lpCompBuffInfo[10].dwWidthToCreate = 720;
                lpGMCBData->lpCompBuffInfo[10].dwHeightToCreate = 576;
                lpGMCBData->lpCompBuffInfo[10].dwBytesToAllocate = (768L * 576 * 2) +
                                                                   (768L * 576 * 4) +
                                                                   1024L +
                                                                   (768L * 576 * 2);
                lpGMCBData->lpCompBuffInfo[10].ddCompCaps.dwCaps = DDSCAPS_VIDEOMEMORY |
                                                                   DDSCAPS_LOCALVIDMEM;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwFlags = DDPF_FOURCC;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwFourCC = FOURCC_NVSP;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwRGBBitCount = 8;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwRBitMask = 0;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwGBitMask = 0;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwBBitMask = 0;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #11 CompBuffInfo structure must be for a Highlight Data buffer.
                // We don't use this one.

                // The #12 CompBuffInfo structure must be for a DCCMD Data buffer.
                // We don't use this one.

                // The #13 CompBuffInfo structure must be for an Alpha Blending Combination buffer.
                // We can put this one in system memory.
                dwPadWidth = (sizeof(DXVA_BlendCombination) + 7) & 0xFFFFFFF8L;
                lpGMCBData->lpCompBuffInfo[13].dwNumCompBuffers = 2;
                lpGMCBData->lpCompBuffInfo[13].dwWidthToCreate = dwPadWidth / dwBytesPerPixel;
                lpGMCBData->lpCompBuffInfo[13].dwHeightToCreate = 1;
                lpGMCBData->lpCompBuffInfo[13].dwBytesToAllocate = dwPadWidth;
                lpGMCBData->lpCompBuffInfo[13].ddCompCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                                  DDSCAPS_SYSTEMMEMORY;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwFlags = dwFlags;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwFourCC = 0;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwRGBBitCount = dwRGBBitCount;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwRBitMask = dwRBitMask;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwGBitMask = dwGBitMask;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwBBitMask = dwBBitMask;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #14 CompBuffInfo structure must be for a Picture Resampling Control buffer.
                // We don't use this one.

                // The #15 CompBuffInfo structure must be for a Read-Back buffer.
                // We don't use this one.
            }
        } else {
            lpGMCBData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
        }
    } else {
        lpGMCBData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvGetMoCompBuffInfo */


/*
 * nvGetInternalMoCompInfo
 *
 * Returns our internal motion comp video memory requirements
 *
 */
DWORD __stdcall nvGetInternalMoCompInfo( LPDDHAL_GETINTERNALMOCOMPDATA lpGIMCData)
{
    nvSetDriverDataPtrFromDDGbl(lpGIMCData->lpDD->lpGbl);

    // Assume we will succeed
    lpGIMCData->ddRVal = DD_OK;

    if (IsEqualIID_C(*(lpGIMCData->lpGuid), DXVA_ModeMPEG2_A) ||
        IsEqualIID_C(*(lpGIMCData->lpGuid), DXVA_ModeMPEG2_B) ||
        IsEqualIID_C(*(lpGIMCData->lpGuid), DXVA_ModeMPEG2_C) ||
        IsEqualIID_C(*(lpGIMCData->lpGuid), DXVA_ModeMPEG2_D)) {
        if (lpGIMCData->ddPixelFormat.dwFourCC == FOURCC_NV12) {
            lpGIMCData->dwScratchMemAlloc = 0;
        } else {
            lpGIMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
        }
    } else {
        lpGIMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvGetInternalMoCompInfo */



/*
 * nvBeginMoCompFrame
 *
 * Prepares to perform motion compensation on a new frame
 *
 */
DWORD __stdcall nvBeginMoCompFrame( LPDDHAL_BEGINMOCOMPFRAMEDATA lpBMCFData)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpBMCFData->lpDD->lpGbl);

    // If the NVMC or NV12 surface has been destroyed, return Surface Lost error.
    if (!pDriverData->dwMCNVMCSurface    ||
        !pDriverData->dwMCNV12Surface[0] ||
        !lpBMCFData->lpDestSurface)
    {
        NvReleaseSemaphore(pDriverData);
        lpBMCFData->ddRVal = DDERR_SURFACELOST;
        return (DDHAL_DRIVER_HANDLED);
    }

    // Check to see if the destination surface is still being displayed by the overlay.
    // If so, return an error code to force the decoder to try again later.
    lpBMCFData->ddRVal = DD_OK;
    if ( getFlipStatusOverlay(lpBMCFData->lpDestSurface->lpGbl->fpVidMem) != DD_OK) {

        NvReleaseSemaphore(pDriverData);
        lpBMCFData->ddRVal = DDERR_WASSTILLDRAWING;
        return (DDHAL_DRIVER_HANDLED);
    }

    // In the DX-VA spec, decoders need to call BeginFrame at least
    // once for each uncompressed buffer they plan to use, to associate
    // a buffer index with the uncompressed buffer DDraw surface handle.
    // We need to record these assocations to use later in Render.
    if (lpBMCFData->dwInputDataSize >= 2) {
        WORD    wDXVAIndex;

        // Extract index from lpInputData.
        wDXVAIndex = *((LPWORD)(lpBMCFData->lpInputData));

        // Save corresponding fpVidMem in our array.
        pDriverData->dwDXVAIndexToVidMem[wDXVAIndex]
            = (DWORD)lpBMCFData->lpDestSurface->lpGbl->fpVidMem;
    }

    // Calculate a linear pointer to the NVMC surface created by DShow.
    // We use this surface to store the NVMCFRAMEDATA structure.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Initialize some things for the new frame.
    lpNvMCFrameData->bMCEndOfPicture = FALSE;
    pDriverData->bMCNewFrame         = TRUE;

    NvReleaseSemaphore(pDriverData);
    lpBMCFData->ddRVal = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
} /* nvBeginMoCompFrame */


/*
 * nvEndMoCompFrame
 *
 * Finishes motion compensation on current frame.
 *
 */
DWORD __stdcall nvEndMoCompFrame( LPDDHAL_ENDMOCOMPFRAMEDATA lpEMCFData)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;
    LPNVMCSURFACEFLAGS          lpSurfaceFlags;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpEMCFData->lpDD->lpGbl);

    // If the NVMC or NV12 surface has been destroyed, return Surface Lost error.
    if (!pDriverData->dwMCNVMCSurface ||
        !pDriverData->dwMCNV12Surface[0])
    {
        NvReleaseSemaphore(pDriverData);
        lpEMCFData->ddRVal = DDERR_SURFACELOST;
        return (DDHAL_DRIVER_HANDLED);
    }

    // If EndFrame is beging called after some macroblocks have been
    // decoded, we need to finish up a few things.  (This might be skipped
    // if BeginFrame/EndFrame have been called around an Alpha Blend
    // operation.)
    if (pDriverData->dwDXVAFlags & DXVA_PICTURE_IN_PROGRESS) {
        // Calculate a linear pointer to the NVMC surface created by DShow.
        // We use this surface to store the NVMCFRAMEDATA structure.
        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
        lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

        // If End of Picture flag wasn't already set by someone...
        // set End of Picture flag and make a call to Execute with no macroblocks
        // to finish up this frame.
        if (!lpNvMCFrameData->bMCEndOfPicture) {
            lpNvMCFrameData->bMCEndOfPicture = 1;
            nvMoCompExecute(lpNvMCFrameData->dwMCMultiMonID,
                            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION,
                            (LPVOID)(pDriverData->dwDXVAConvertBuffer + MACROBLOCKS_OFFSET),
                            0,
                            0);
        }

        // Clean up.  Make sure surface has been format converted
        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != pDriverData->dwMCMostRecentlyDecodedSurfaceBase)) {
            lpSurfaceFlags++;
        }
        if (lpSurfaceFlags->dwMCSurfaceBase != 0) {
            if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
                (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
                nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 15);
            else if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) {
                if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3)
                    nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 3);
            } else if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {
                if (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 12)
                    nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 12);
            }
            if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                (pDriverData->bMCTemporalFilterDisabled == FALSE))
                nvMoCompTemporalFilter(lpSurfaceFlags->dwMCSurfaceBase, pDriverData->bMCPercentCurrentField);
        }
    }

    // Reset flag to say this picture is done.
    pDriverData->dwDXVAFlags &= ~DXVA_PICTURE_IN_PROGRESS;

    lpEMCFData->ddRVal = DD_OK;
    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);
} /* nvEndMoCompFrame */


/*
 * nvRenderMoComp
 *
 * Performs motion compensation on a portion of a new frame.
 * Several buffers may be passed to this function at one time,
 * of the following types:
 *
 * 1 - Picture Parameter Buffer
 * 2 - Macroblock Control Command Buffer
 * 3 - Residual Difference Block Data Buffer (contains post-IDCT data)
 * 7 - DVD Subpicture Control Buffer
 *
 */
DWORD __stdcall nvRenderMoComp(LPDDHAL_RENDERMOCOMPDATA lpRMCData)
{
    DWORD                       dwRenderIndex;
    DWORD                       dwRetValue;
    LPDDMCBUFFERINFO            lpBufferInfo;
    LPBYTE                      lpBufferLinear;
    LPDXVA_BufferDescription    lpBufferHeader;
    DWORD                       dwMacroblockIndex = 255;
    DWORD                       dwDifferenceIndex = 255;
    DWORD                       dwFunction;
    DWORD                       dwDXVA_Func;
    DWORD                       dwQueryOrReplyFlag;
    DWORD                       dwReturn;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // If the NVMC, NV12 or NVID surface has been destroyed, return Surface Lost error.
    if (!pDriverData->dwMCNVMCSurface    ||
        !pDriverData->dwMCNV12Surface[0] ||
        !pDriverData->dwMCNVIDSurface[0])
    {
        NvReleaseSemaphore(pDriverData);
        lpRMCData->ddRVal = DDERR_SURFACELOST;
        return (DDHAL_DRIVER_HANDLED);
    }

    // Use the dwFunction value to decide what to do with the buffers
    // passed to us.
    dwFunction = lpRMCData->dwFunction;

    // First check to see if dwFunction contains a QueryOrReply function.
    dwDXVA_Func = readDXVA_QueryOrReplyFuncFunc(&dwFunction);
    dwQueryOrReplyFlag = readDXVA_QueryOrReplyFuncFlag(&dwFunction);
    if ((dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY) ||
        (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY)) {
        switch (dwDXVA_Func) {
        case DXVA_PICTURE_DECODING_FUNCTION:
            dwReturn = nvRenderCheckDecodeConfig(lpRMCData);
            break;

        case DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION:
            dwReturn = nvRenderCheckAlphaLoadConfig(lpRMCData);
            break;

        case DXVA_ALPHA_BLEND_COMBINATION_FUNCTION:
            dwReturn = nvRenderCheckAlphaCombineConfig(lpRMCData);
            break;
        }

        // Return QueryOrReply response.
        NvReleaseSemaphore(pDriverData);
        return (DDHAL_DRIVER_HANDLED);
    }

    // For other functions, we may need to use our DXVA-To-NV index
    // translation tables.  Make sure they're up to date, since a
    // DDFlip call may swap info between the surface structures.
    nvUpdateDXVAIndexTable(pDriverData);

    // If dwFunction doesn't contain a QueryOrReply function, check it for
    // other functions.  Note that dwFunction can contain up to four 1-byte
    // commands, so they have to be checked one by one, starting with the
    // most significant byte.  (If dwFunction only has one function byte
    // in it, shift it into the top byte so we don't waste too much time.)
    if (dwFunction < 256)
        dwFunction <<= 24;
    while (dwFunction) {
        // Note: if dwFunction starts with FF, we'll fall through to the default
        // case, and it will be treated as a multi-byte command.
        dwDXVA_Func = (dwFunction >> 24);
        dwFunction <<= 8;

        switch (dwDXVA_Func) {

        case 0:     // Unused
            break;

        case DXVA_PICTURE_DECODING_FUNCTION:

            // We need to go through each of the buffers we've been passed and
            // process it according to the buffer type.  For Macroblock and
            // Residual buffers, record their buffer index at this point until
            // we have a match set - we need both to do the motion comp operation.
            lpBufferHeader   = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
            lpBufferInfo = (LPDDMCBUFFERINFO)(lpRMCData->lpBufferInfo);
            for (dwRenderIndex = 0; dwRenderIndex < lpRMCData->dwNumBuffers; dwRenderIndex++) {
                lpBufferLinear   = nvGetLinearAddress(lpBufferInfo->lpCompSurface)
                                   + lpBufferInfo->dwDataOffset;

                switch (lpBufferHeader->dwTypeIndex) {

                case DXVA_PICTURE_DECODE_BUFFER:
                    // Extract the picture parameters for the next frame from
                    // the buffer we were sent.
                    dwRetValue = nvRenderGetPictureParams(lpRMCData, lpBufferInfo);
                    if (dwRetValue != DD_OK) {
                        lpRMCData->ddRVal = dwRetValue;
                        NvReleaseSemaphore(pDriverData);
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    break;

                case DXVA_MACROBLOCK_CONTROL_BUFFER:
                    // Just record the pointer to the Macroblock buffer info for later.
                    dwMacroblockIndex = dwRenderIndex;
                    break;

                case DXVA_RESIDUAL_DIFFERENCE_BUFFER:
                    // Just record the pointer to the Difference buffer info for later.
                    dwDifferenceIndex = dwRenderIndex;
                    break;
                }

                // If we got both a Macroblock and a Difference buffer, we can perform the
                // motion compensation operation for this Render call.
                if ((dwMacroblockIndex != 255) && (dwDifferenceIndex != 255)) {
                    dwRetValue = nvRenderDoMotionComp(lpRMCData,
                                                      dwMacroblockIndex,
                                                      dwDifferenceIndex);
                    dwMacroblockIndex = 255;
                    dwDifferenceIndex = 255;
                }

                lpBufferInfo++;
                lpBufferHeader++;
            }
            break;


        case DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION:

            // We only check for YUV Palette and IA44 Surface buffers here.
            lpBufferHeader   = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
            lpBufferInfo = (LPDDMCBUFFERINFO)(lpRMCData->lpBufferInfo);
            for (dwRenderIndex = 0; dwRenderIndex < lpRMCData->dwNumBuffers; dwRenderIndex++) {
                lpBufferLinear   = nvGetLinearAddress(lpBufferInfo->lpCompSurface)
                                   + lpBufferInfo->dwDataOffset;

                switch (lpBufferHeader->dwTypeIndex) {

                case DXVA_AYUV_BUFFER:
                    // Process the new YUV palette.
                    nvRenderGetYUVPalette(lpRMCData, dwRenderIndex);
                    break;

                case DXVA_IA44_SURFACE_BUFFER:
                    // Process the new subpicture bitmap.
                    nvRenderGetIA44Surface(lpRMCData, dwRenderIndex);
                    break;
                }

                lpBufferInfo++;
                lpBufferHeader++;
            }
            break;


        case DXVA_ALPHA_BLEND_COMBINATION_FUNCTION:

            // We only check for Alpha Blend Combination buffers here.
            // The Alpha Blend data should have been provided in earlier Render calls.
            lpBufferHeader   = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
            lpBufferInfo = (LPDDMCBUFFERINFO)(lpRMCData->lpBufferInfo);
            for (dwRenderIndex = 0; dwRenderIndex < lpRMCData->dwNumBuffers; dwRenderIndex++) {
                lpBufferLinear   = nvGetLinearAddress(lpBufferInfo->lpCompSurface)
                                   + lpBufferInfo->dwDataOffset;

                switch (lpBufferHeader->dwTypeIndex) {

                case DXVA_ALPHA_BLEND_COMBINATION_BUFFER:
                    // Blend the subpicture bitmap into a video frame.
                    nvRenderAlphaBlendCombination(lpRMCData, dwRenderIndex);
                    break;
                }

                lpBufferInfo++;
                lpBufferHeader++;
            }
            break;
        }
    }

    // For non-Query functions, we are normally supposed to return a status
    // code in the lpPrivateOutputData area as a DWord.  Default to OK.
    if (lpRMCData->lpOutputData && (lpRMCData->dwOutputDataSize >= 4)) {
        *((LPDWORD)lpRMCData->lpOutputData) = 0;
    }

    // Return success code.
    lpRMCData->ddRVal = DD_OK;
    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);
} /* nvRenderMoComp */


/*
 * nvRenderCheckDecodeConfig
 *
 * Private function called by nvRenderMoComp.
 * Checks picture decoding configuration given by the decoder
 * to see if it's a configuration we support.
 *
 */
DWORD __stdcall nvRenderCheckDecodeConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData)
{
    LPDXVA_ConfigPictureDecode  lpConnectConfigInput;
    LPDXVA_ConfigPictureDecode  lpConnectConfigOutput;
    DXVA_ConfigPictureDecode    NVConnectConfig = {0};
    DWORD                   dwReturn;
    DWORD                   dwFunction;
    DWORD                   dwDXVA_Func;
    DWORD                   dwQueryOrReplyFlag;

    // Get QueryOrReply details.
    dwFunction = lpRMCData->dwFunction;
    dwDXVA_Func = readDXVA_QueryOrReplyFuncFunc(&dwFunction);
    dwQueryOrReplyFlag = readDXVA_QueryOrReplyFuncFlag(&dwFunction);

    // Set up pointers to input and output structures.
    lpConnectConfigInput  = (LPDXVA_ConfigPictureDecode)lpRMCData->lpInputData;
    lpConnectConfigOutput = (LPDXVA_ConfigPictureDecode)lpRMCData->lpOutputData;

    // Check input structure against our preferred structure.
    // Note that we don't care about bConfigMBcontrolRasterOrder
    // and bConfigIntraResidUnsigned, we'll accept either value.
    if ((lpConnectConfigInput->dwFunction                     != dwFunction)     ||
        (lpConnectConfigInput->guidConfigBitstreamEncryption  != DXVA_NoEncrypt) ||
        (lpConnectConfigInput->guidConfigMBcontrolEncryption  != DXVA_NoEncrypt) ||
        (lpConnectConfigInput->guidConfigResidDiffEncryption  != DXVA_NoEncrypt) ||
        (lpConnectConfigInput->bConfigBitstreamRaw            != 0)              ||
        (lpConnectConfigInput->bConfigResidDiffHost           != 1)              ||
        (lpConnectConfigInput->bConfigSpatialResid8           != 1)              ||
        (lpConnectConfigInput->bConfigResid8Subtraction       != 0)              ||
        (lpConnectConfigInput->bConfigSpatialHost8or9Clipping != 0)              ||
        (lpConnectConfigInput->bConfigSpatialResidInterleaved != 1)              ||
        (lpConnectConfigInput->bConfigResidDiffAccelerator    != 0)              ||
        (lpConnectConfigInput->bConfigHostInverseScan         != 0)              ||
        (lpConnectConfigInput->bConfigSpecificIDCT            != 0)              ||
        (lpConnectConfigInput->bConfig4GroupedCoefs           != 0)) {

        // Make the output a duplicate of our preferred structure.
        NVConnectConfig.dwFunction = dwFunction;
        memcpy((GUID *)&NVConnectConfig.guidConfigBitstreamEncryption,
               (GUID *)&DXVA_NoEncrypt,
               sizeof(GUID));
        memcpy((GUID *)&NVConnectConfig.guidConfigMBcontrolEncryption,
               (GUID *)&DXVA_NoEncrypt,
               sizeof(GUID));
        memcpy((GUID *)&NVConnectConfig.guidConfigResidDiffEncryption,
               (GUID *)&DXVA_NoEncrypt,
               sizeof(GUID));
        NVConnectConfig.bConfigResidDiffHost = 1;
        NVConnectConfig.bConfigSpatialResid8 = 1;
        NVConnectConfig.bConfigSpatialResidInterleaved = 1;
        NVConnectConfig.bConfigIntraResidUnsigned = 0;

        memcpy(lpRMCData->lpOutputData,
               (LPVOID)&NVConnectConfig,
               sizeof(DXVA_ConfigPictureDecode));

        lpRMCData->ddRVal = S_FALSE;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS;
    }
    else {
        // Make the output a duplicate of the input structure.
        memcpy(lpRMCData->lpOutputData,
               lpRMCData->lpInputData,
               sizeof(DXVA_ConfigPictureDecode));

        // Record the setting of the Intra IDCT Unsigned flag.
        if (lpConnectConfigInput->bConfigIntraResidUnsigned)
            pDriverData->dwDXVAFlags |= DXVA_INTRA_IDCT_UNSIGNED;
        else
            pDriverData->dwDXVAFlags &= ~DXVA_INTRA_IDCT_UNSIGNED;

        lpRMCData->ddRVal = S_OK;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY;
    }

    writeDXVA_QueryOrReplyFunc(&lpConnectConfigOutput->dwFunction, dwReturn, dwDXVA_Func);
    return dwReturn;
}  // nvRenderCheckDecodeConfig


/*
 * nvRenderCheckAlphaLoadConfig
 *
 * Private function called by nvRenderMoComp.
 * Checks alpha blend load configuration given by the decoder
 * to see if it's a configuration we support.
 *
 */
DWORD __stdcall nvRenderCheckAlphaLoadConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData)
{
    LPDXVA_ConfigAlphaLoad  lpConfigAlphaLoadInput;
    LPDXVA_ConfigAlphaLoad  lpConfigAlphaLoadOutput;
    DXVA_ConfigAlphaLoad    NVConfigAlphaLoad = {0};
    DWORD                   dwFunction;
    DWORD                   dwReturn;
    DWORD                   dwDXVA_Func;
    DWORD                   dwQueryOrReplyFlag;

    // Get QueryOrReply details.
    dwFunction = lpRMCData->dwFunction;
    dwDXVA_Func = readDXVA_QueryOrReplyFuncFunc(&dwFunction);
    dwQueryOrReplyFlag = readDXVA_QueryOrReplyFuncFlag(&dwFunction);

    // Set up pointers to input and output structures.
    lpConfigAlphaLoadInput  = (LPDXVA_ConfigAlphaLoad)lpRMCData->lpInputData;
    lpConfigAlphaLoadOutput = (LPDXVA_ConfigAlphaLoad)lpRMCData->lpOutputData;

    // Check input structure against our preferred structure.
    if ((lpConfigAlphaLoadInput->dwFunction      != dwFunction) ||
        (lpConfigAlphaLoadInput->bConfigDataType != DXVA_CONFIG_DATA_TYPE_IA44)) {

        // Make the output a duplicate of our preferred structure.
        NVConfigAlphaLoad.dwFunction = dwFunction;
        NVConfigAlphaLoad.bConfigDataType = DXVA_CONFIG_DATA_TYPE_IA44;     // AYUV Palette & IA44 Surface.
        memcpy(lpRMCData->lpOutputData,
               (LPVOID)&NVConfigAlphaLoad,
               sizeof(DXVA_ConfigAlphaLoad));

        lpRMCData->ddRVal = S_FALSE;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS;
    }
    else {
        // Make the output a duplicate the input structure.
        memcpy(lpRMCData->lpOutputData,
               lpRMCData->lpInputData,
               sizeof(DXVA_ConfigAlphaLoad));

        lpRMCData->ddRVal = S_OK;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY;
    }

    writeDXVA_QueryOrReplyFunc(&lpConfigAlphaLoadOutput->dwFunction, dwReturn, dwDXVA_Func);
    return dwReturn;
}  // nvRenderCheckAlphaLoadConfig


/*
 * nvRenderCheckAlphaCombineConfig
 *
 * Private function called by nvRenderMoComp.
 * Checks alpha blend combination configuration given by the decoder
 * to see if it's a configuration we support.
 *
 */
DWORD __stdcall nvRenderCheckAlphaCombineConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData)
{
    LPDXVA_ConfigAlphaCombine   lpConfigAlphaCombineInput;
    LPDXVA_ConfigAlphaCombine   lpConfigAlphaCombineOutput;
    DXVA_ConfigAlphaCombine     NVConfigAlphaCombine = {0};
    DWORD                       dwFunction;
    DWORD                       dwReturn;
    DWORD                       dwDXVA_Func;
    DWORD                       dwQueryOrReplyFlag;

    // Get QueryOrReply details.
    dwFunction = lpRMCData->dwFunction;
    dwDXVA_Func = readDXVA_QueryOrReplyFuncFunc(&dwFunction);
    dwQueryOrReplyFlag = readDXVA_QueryOrReplyFuncFlag(&dwFunction);

    // Set up pointers to input and output structures.
    lpConfigAlphaCombineInput  = (LPDXVA_ConfigAlphaCombine)lpRMCData->lpInputData;
    lpConfigAlphaCombineOutput = (LPDXVA_ConfigAlphaCombine)lpRMCData->lpOutputData;

    // Check to see if this is a valid Front End Alpha Blend configuration.
    // We only allow this configuration if video memory size is 32K or above,
    // because front end blending requires extra NV12 surfaces.
    if ((pDriverData->TotalVRAM >= 0x2000000) &&
        (lpConfigAlphaCombineInput->bConfigBlendType == DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER) &&
        (lpConfigAlphaCombineInput->bConfigOnlyUsePicDestRectArea == 1) &&
        (lpConfigAlphaCombineInput->bConfigWholePlaneAlpha == 0)) {

        // Make the output a duplicate of the input structure.
        memcpy(lpRMCData->lpOutputData,
               lpRMCData->lpInputData,
               sizeof(DXVA_ConfigAlphaCombine));

        // Reset flag to say we're going to use Front End blending.
        pDriverData->dwDXVAFlags &= ~DXVA_BACK_END_ALPHA_SELECTED;
        pDriverData->dwDXVAFlags &= ~DXVA_BACK_END_ALPHA_ENABLED;
        pDriverData->vpp.regOverlayMode3 &= ~NV4_REG_OVL_MODE3_DXVA_BACK_END_ALPHA_PREFERRED;

        lpRMCData->ddRVal = S_OK;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY;
    }

    // Else check to see if this is a valid Back End Alpha Blend configuration.
    // We allow this configuration for all memory sizes.
    // Check input structure against our preferred structure
    // (we can accept either value of GraphicResizing.)
    else if ((lpConfigAlphaCombineInput->bConfigBlendType == DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE) &&
        (lpConfigAlphaCombineInput->bConfigPictureResizing        == 0) &&
        (lpConfigAlphaCombineInput->bConfigOnlyUsePicDestRectArea == 1) &&
        (lpConfigAlphaCombineInput->bConfigWholePlaneAlpha        == 0)) {

        // Make the output a duplicate of the input structure.
        memcpy(lpRMCData->lpOutputData,
               lpRMCData->lpInputData,
               sizeof(DXVA_ConfigAlphaCombine));

        // Set flag to say we're going to use Back End blending, initially disabled.
        pDriverData->dwDXVAFlags |= DXVA_BACK_END_ALPHA_SELECTED;
        pDriverData->dwDXVAFlags &= ~DXVA_BACK_END_ALPHA_ENABLED;
        pDriverData->vpp.regOverlayMode3 |= NV4_REG_OVL_MODE3_DXVA_BACK_END_ALPHA_PREFERRED;

        lpRMCData->ddRVal = S_OK;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY;
    }

    // Otherwise return an error code and preferred configuration based on video
    // memory size.
    else if (pDriverData->TotalVRAM >= 0x2000000) {

        // Make the output a duplicate of our preferred structure for Front End blending.
        NVConfigAlphaCombine.dwFunction = dwFunction;
        NVConfigAlphaCombine.bConfigBlendType = DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER;
        NVConfigAlphaCombine.bConfigPictureResizing        = 1; // Support picture resize.
        NVConfigAlphaCombine.bConfigOnlyUsePicDestRectArea = 1; // Restrict destination rectangle.
        NVConfigAlphaCombine.bConfigGraphicResizing        = 1; // Support subpicture resizing.
        NVConfigAlphaCombine.bConfigWholePlaneAlpha        = 0; // No alpha override.
        NVConfigAlphaCombine.dwFunction = dwFunction;
        memcpy(lpRMCData->lpOutputData,
               (LPVOID)&NVConfigAlphaCombine,
               sizeof(DXVA_ConfigAlphaCombine));

        lpRMCData->ddRVal = S_FALSE;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS;
    }

    else {

        // Make the output a duplicate of our preferred structure for Back End blending.
        NVConfigAlphaCombine.dwFunction = dwFunction;
        NVConfigAlphaCombine.bConfigBlendType = DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE;
        NVConfigAlphaCombine.bConfigPictureResizing        = 0; // Don't support picture resize.
        NVConfigAlphaCombine.bConfigOnlyUsePicDestRectArea = 1; // Restrict destination rectangle.
        NVConfigAlphaCombine.bConfigGraphicResizing        = 1; // Support subpicture resizing.
        NVConfigAlphaCombine.bConfigWholePlaneAlpha        = 0; // No alpha override.
        NVConfigAlphaCombine.dwFunction = dwFunction;
        memcpy(lpRMCData->lpOutputData,
               (LPVOID)&NVConfigAlphaCombine,
               sizeof(DXVA_ConfigAlphaCombine));

        lpRMCData->ddRVal = S_FALSE;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS;
    }

    writeDXVA_QueryOrReplyFunc(&lpConfigAlphaCombineOutput->dwFunction, dwReturn, dwDXVA_Func);
    return dwReturn;
}  // nvRenderCheckAlphaLoadConfig


/*
 * nvRenderGetPictureParams
 *
 * Private function called by nvRenderMoComp.
 * Extracts information for decoding a new frame from a
 * Picture Parameter structure passed to RenderMoComp.
 *
 */
DWORD __stdcall nvRenderGetPictureParams(LPDDHAL_RENDERMOCOMPDATA lpRMCData,
                                         LPDDMCBUFFERINFO lpPictureBuffer)
{
    LPBYTE                      lpBufferLinear;
    LPDXVA_PictureParameters    lpPictureParams;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // Because our Picture Parameter buffer is in System memory,
    // decoder doesn't call our Lock32 before using it.  The
    // following may be required for some DVD decoders.
    getDC()->nvPusher.flush(TRUE, CPushBuffer::FLUSH_WITH_DELAY);

    // Calculate a pointer to the Picture Parameters structure in the buffer.
    lpBufferLinear   = nvGetLinearAddress(lpPictureBuffer->lpCompSurface)
                       + lpPictureBuffer->dwDataOffset;
    lpPictureParams  = (LPDXVA_PictureParameters)lpBufferLinear;

    // Calculate a linear pointer to the NVMC surface created by DShow.
    // We use this surface to store the NVMCFRAMEDATA structure.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Make a copy of some Picture Parameters we need later.
    lpNvMCFrameData->wDXVAPicWidthInMB  = lpPictureParams->wPicWidthInMBminus1 + 1;
    lpNvMCFrameData->wDXVAPicHeightInMB = lpPictureParams->wPicHeightInMBminus1 + 1;

    // Extract the Picture Parameter values and use them to fill in our
    // NVMCFRAMEDATA structure, which is used by MoCompExecute.
    lpNvMCFrameData->dwMCNvExecute = 0;

#ifdef WINNT
    // For Win2K, return lpDD as the MultiMon parameter, since pDXShare is NULL.
    lpNvMCFrameData->dwMCMultiMonID = (DWORD)lpRMCData->lpDD;
#else
    // For Win98, return pDXShare as the MultiMon parameter for compatibility
    // with the nVidia proprietary motion comp interface.
    lpNvMCFrameData->dwMCMultiMonID = (DWORD)pDXShare;
#endif

    // Store the "raw" DXVA buffer indexes in the NVMC surface for now.
    // We'll convert them later to NV buffer indexes in RenderDoMotionComp.
    // Note: unused indexes may be set to 0xFFFF according to the DXVA spec.
    lpNvMCFrameData->wDXVADecodedPictureIndex     = min(lpPictureParams->wDecodedPictureIndex, 7);
    lpNvMCFrameData->wDXVAForwardRefPictureIndex  = min(lpPictureParams->wForwardRefPictureIndex, 7);
    lpNvMCFrameData->wDXVABackwardRefPictureIndex = min(lpPictureParams->wBackwardRefPictureIndex, 7);

    lpNvMCFrameData->bMCPictureStructure
        = lpPictureParams->bPicStructure;

    if (lpPictureParams->bPicIntra)
        lpNvMCFrameData->bMCPictureCodingType = PICTURE_TYPE_I;
    else if (lpPictureParams->bPicBackwardPrediction)
        lpNvMCFrameData->bMCPictureCodingType = PICTURE_TYPE_B;
    else
        lpNvMCFrameData->bMCPictureCodingType = PICTURE_TYPE_P;

    lpNvMCFrameData->bMCTopFieldFirst = 1;
    lpNvMCFrameData->bMCSecondField   = lpPictureParams->bSecondField;

    if (lpPictureParams->bPicStructure == PICTURE_STRUCTURE_FRAME)
        lpNvMCFrameData->bMCFrameType = 0;
    else
        lpNvMCFrameData->bMCFrameType = 1;

    lpNvMCFrameData->bMCEndOfPicture  = 0;

    NvReleaseSemaphore(pDriverData);
    return DD_OK;
}  // nvRenderGetPictureParams


/*
 * nvRenderDoMotionComp
 *
 * Private function called by nvRenderMoComp.
 * Does motion comp operation with data passed to Render.
 *
 */

DWORD __stdcall nvRenderDoMotionComp(LPDDHAL_RENDERMOCOMPDATA lpRMCData,
                                     DWORD dwMacroblockIndex,
                                     DWORD dwDifferenceIndex)
{
    LPBYTE                          lpDXVAMacroblockLinear;
    LPBYTE                          lpDXVAMacroblockPtr;
    LPDXVA_MBctrl_P_HostResidDiff_1 lpDXVAType;
    LPNVDECODEMACROBLOCK            lpNVMacroblockPtr;
    DWORD                           dwNumSrcMacroblocks, dwNumDstMacroblocks;
    DWORD                           dwIndex;
    LPDDRAWI_DDRAWSURFACE_LCL       pSurf_lcl;
    LPNVMCFRAMEDATA                 lpNvMCFrameData;
    LPBYTE                          lpIDCTLinear;
    WORD                            wNVIndex;
    DWORD                           dwIDCTOffset;
    DWORD                           dwIDCTIndex;
    WORD                            wDXVAPicWidthInMB;
    WORD                            wDXVAPicHeightInMB;
    BYTE                            bEndOfPicture = 0;
    LPDXVA_BufferDescription        lpDXVAMacroblockHeader;
    LPDXVA_BufferDescription        lpDXVADifferenceHeader;
    LPDXVA_BufferDescription        lpDataHeaders;
    LPDDMCBUFFERINFO                lpMacroblockBuffer;
    LPDDMCBUFFERINFO                lpDifferenceBuffer;
    DWORD                           dwCommand;
    DWORD                           dwStructureSize;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // Set flag to say we're doing a picture decode.
    pDriverData->dwDXVAFlags |= DXVA_PICTURE_IN_PROGRESS;

    // Get pointers to the Macroblock and Difference buffer headers from lpInputData.
    lpDataHeaders = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
    lpDXVAMacroblockHeader = lpDataHeaders + dwMacroblockIndex;
    lpDXVADifferenceHeader = lpDataHeaders + dwDifferenceIndex;

    // Calculate a pointer to the Macroblock data buffers.
    lpMacroblockBuffer = lpRMCData->lpBufferInfo + dwMacroblockIndex;
    lpDXVAMacroblockLinear = nvGetLinearAddress(lpMacroblockBuffer->lpCompSurface)
                             + lpMacroblockBuffer->dwDataOffset;
    lpDXVAMacroblockPtr    = lpDXVAMacroblockLinear;

    // Calculate the index of the Difference buffer.  This is normally used when we call
    // nvMoCompExecute.
    lpDifferenceBuffer = lpRMCData->lpBufferInfo + dwDifferenceIndex;
    for (wNVIndex = 0; wNVIndex < 4; wNVIndex++) {
        if ((DWORD)lpDifferenceBuffer->lpCompSurface == pDriverData->dwMCNVIDSurface[wNVIndex])
            break;
    }
    if (wNVIndex > 3)
        wNVIndex = 0;


    // Set up a pointer to the IDCT buffer we're going to use.
    lpDifferenceBuffer = lpRMCData->lpBufferInfo + dwDifferenceIndex;
    lpIDCTLinear = (LPBYTE)VIDMEM_ADDR(lpDifferenceBuffer->lpCompSurface->lpGbl->fpVidMem);

    // Calculate an offset to the beginning of the IDCT data in the surface.
    // This is needed for the 0.9.2 version of DXVA, not for 0.9.3.
    dwIDCTOffset = lpDifferenceBuffer->dwDataOffset;

    // Calculate a linear pointer to the NVMC surface created by DShow.
    // We use this surface to store the NVMCFRAMEDATA structure.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Convert DXVA indexes we were given earlier into NV surface indexes
    // using our translation table.
    lpNvMCFrameData->bMCDestinationSurfaceIndex
        = pDriverData->bDXVAIndexToNVIndex[lpNvMCFrameData->wDXVADecodedPictureIndex];
    lpNvMCFrameData->bMCForwardSurfaceIndex
        = pDriverData->bDXVAIndexToNVIndex[lpNvMCFrameData->wDXVAForwardRefPictureIndex];
    lpNvMCFrameData->bMCBackwardSurfaceIndex
        = pDriverData->bDXVAIndexToNVIndex[lpNvMCFrameData->wDXVABackwardRefPictureIndex];

    // Set up a pointer to the beginning our Conversion buffer, where we'll
    // create NV-style macroblock headers from the DXVA-style headers we've
    // been given.
    lpNVMacroblockPtr = (LPNVDECODEMACROBLOCK)(pDriverData->dwDXVAConvertBuffer
                                               + MACROBLOCKS_OFFSET);

    // Convert Macroblock Buffer into the nVidia Macroblock format,
    // so we can pass it and the IDCT data surface to nvMoCompExecute.
    wDXVAPicWidthInMB  = lpNvMCFrameData->wDXVAPicWidthInMB;
    wDXVAPicHeightInMB = lpNvMCFrameData->wDXVAPicHeightInMB;

    // Calculate number of input macroblocks based on the data buffer size,
    // since skipped macroblocks may make dwNumMBsInBuffer unreliable.
    if (lpNvMCFrameData->bMCPictureCodingType == PICTURE_TYPE_I)
        dwStructureSize = sizeof(DXVA_MBctrl_I_HostResidDiff_1);
    else
        dwStructureSize = sizeof(DXVA_MBctrl_P_HostResidDiff_1);
    dwNumSrcMacroblocks = lpDXVAMacroblockHeader->dwDataSize / dwStructureSize;
    dwNumDstMacroblocks = 0;

    for (dwIndex = 0; dwIndex < dwNumSrcMacroblocks; dwIndex++) {

        // First take care of fields that are common for Intra and non-Intra
        // macroblocks.
        lpDXVAType = (LPDXVA_MBctrl_P_HostResidDiff_1)lpDXVAMacroblockPtr;

        lpNVMacroblockPtr->hOffset
            = (lpDXVAType->wMBaddress % wDXVAPicWidthInMB) * 16;
        lpNVMacroblockPtr->vOffset
            = (lpDXVAType->wMBaddress / wDXVAPicWidthInMB) * 16;

        // If this is the last macroblock in the frame, set a flag so we
        // know we should set the NV End of Picture byte.
        if (lpDXVAType->wMBaddress == wDXVAPicWidthInMB * wDXVAPicHeightInMB - 1)
            bEndOfPicture = 1;

        dwIDCTIndex = readDXVA_MBdataLocation(lpDXVAType);
        dwIDCTIndex >>= 4;
        lpNVMacroblockPtr->firstIDCTIndex = (WORD)dwIDCTIndex;

        if (readDXVA_FieldResidual(lpDXVAType))
            lpNVMacroblockPtr->DCTType = DCT_FIELD;
        else
            lpNVMacroblockPtr->DCTType = DCT_FRAME;

        lpNVMacroblockPtr->codedBlockPattern
            = lpDXVAType->wPatternCode >> 6;

        lpNVMacroblockPtr->overflowCodedBlockPattern
            = lpDXVAType->wPC_Overflow >> 6;

        // For Intra macroblocks, set motion entries to zero.
        if (readDXVA_IntraMacroblock(lpDXVAType)) {
            // No motion.
            lpNVMacroblockPtr->motionType = 0;

            lpNVMacroblockPtr->macroblockType = MB_INTRA;
        }

        // For Non-Intra macroblocks, set up the motion fields.
        else {

            // Get field selects.
            lpNVMacroblockPtr->fieldSelect[0][0] = readDXVA_MvertFieldSel_0(lpDXVAType);
            lpNVMacroblockPtr->fieldSelect[0][1] = readDXVA_MvertFieldSel_1(lpDXVAType);
            lpNVMacroblockPtr->fieldSelect[1][0] = readDXVA_MvertFieldSel_2(lpDXVAType);
            lpNVMacroblockPtr->fieldSelect[1][1] = readDXVA_MvertFieldSel_3(lpDXVAType);

            // Set up macroblock type.
            lpNVMacroblockPtr->macroblockType = 0;
            if (readDXVA_MotionForward(lpDXVAType))
                lpNVMacroblockPtr->macroblockType |= MB_MOTION_FORWARD;
            if (readDXVA_MotionBackward(lpDXVAType))
                lpNVMacroblockPtr->macroblockType |= MB_MOTION_BACKWARD;

            // Progressive frame cases.
            if (lpNvMCFrameData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
                switch(readDXVA_MotionType(lpDXVAType)) {
                case 0:
                case 1:
                    lpNVMacroblockPtr->motionType = FRAME_STRUCTURE_MOTION_FIELD;
                    if(lpNVMacroblockPtr->macroblockType == MB_MOTION_FORWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 4);
                        memcpy(lpNVMacroblockPtr->PMV[1][0], &lpDXVAType->MVector[2], 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType == MB_MOTION_BACKWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV[0][1], &lpDXVAType->MVector[1], 4);
                        memcpy(lpNVMacroblockPtr->PMV[1][1], &lpDXVAType->MVector[3], 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 16);
                    }
                    break;
                case 2:
                    lpNVMacroblockPtr->motionType = FRAME_STRUCTURE_MOTION_FRAME;

                    if(lpNVMacroblockPtr->macroblockType == MB_MOTION_FORWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType == MB_MOTION_BACKWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV[0][1], &lpDXVAType->MVector[1], 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 8);
                    }

                    break;
                case 3:
                    lpNVMacroblockPtr->motionType = FRAME_STRUCTURE_MOTION_DP;
                    memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 16);

                    // Copy derived motion vectors for dual-prime.
                    lpNVMacroblockPtr->PMV[1][0][0] = lpNVMacroblockPtr->PMV[0][1][0];
                    lpNVMacroblockPtr->PMV[1][0][1] = lpNVMacroblockPtr->PMV[0][1][1];

                    // Zero out unused motion vectors and field selects.
                    lpNVMacroblockPtr->PMV[0][1][0] = 0;
                    lpNVMacroblockPtr->PMV[0][1][1] = 0;
                    memset(lpNVMacroblockPtr->fieldSelect, 0, 4);
                    break;
                }

           }

            // Interlaced frame cases.
            else {
                switch(readDXVA_MotionType(lpDXVAType)) {
                case 0:
                case 1:
                    lpNVMacroblockPtr->motionType = FIELD_STRUCTURE_MOTION_FIELD;
                    if(lpNVMacroblockPtr->macroblockType == MB_MOTION_FORWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType == MB_MOTION_BACKWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV[0][1], &lpDXVAType->MVector[1], 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 8);
                    }
                    break;
                case 2:
                    lpNVMacroblockPtr->motionType = FIELD_STRUCTURE_MOTION_16X8;
                    if(lpNVMacroblockPtr->macroblockType == MB_MOTION_FORWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 4);
                        memcpy(lpNVMacroblockPtr->PMV[1][0], &lpDXVAType->MVector[2], 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType == MB_MOTION_BACKWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV[0][1], &lpDXVAType->MVector[1], 4);
                        memcpy(lpNVMacroblockPtr->PMV[1][1], &lpDXVAType->MVector[3], 4);

                    }
                    else if(lpNVMacroblockPtr->macroblockType)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 16);
                    }
                    break;
                case 3:
                    lpNVMacroblockPtr->motionType = FIELD_STRUCTURE_MOTION_DP;

                    memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 8);

                    // Copy derived motion vectors for dual-prime.
                    lpNVMacroblockPtr->PMV[1][0][0] = lpNVMacroblockPtr->PMV[0][1][0];
                    lpNVMacroblockPtr->PMV[1][0][1] = lpNVMacroblockPtr->PMV[0][1][1];

                    // Zero out unused motion vectors and field selects.
                    lpNVMacroblockPtr->PMV[0][1][0] = 0;
                    lpNVMacroblockPtr->PMV[0][1][1] = 0;
                    memset(lpNVMacroblockPtr->fieldSelect, 0, 4);
                    break;
                }

            }

            // If this is a No Motion case, convert it into a forward prediction
            // with null motion vectors.
            if (!lpNVMacroblockPtr->macroblockType) {
                lpNVMacroblockPtr->macroblockType = MB_MOTION_FORWARD;
                memset(lpNVMacroblockPtr->PMV, 0, 12);
            }
        }

        // Move to next NV macroblock header position in the Conversion buffer.
        lpNVMacroblockPtr++;
        dwNumDstMacroblocks++;

        // If there were any skipped macroblocks following this block, we
        // need to generate new macroblocks headers for them.  Each of
        // these new headers should have the same type as the real header
        // we were given, but with zero motion vectors and IDCT data.
        // Note: I frames should never have skipped macroblocks.
        if (readDXVA_MBskipsFollowing(lpDXVAType))
        {
            WORD    wSkipIndex;

            for (wSkipIndex = 0; wSkipIndex < readDXVA_MBskipsFollowing(lpDXVAType); wSkipIndex++)
            {
                // Generate each new header from the previous header.
                *lpNVMacroblockPtr = *(lpNVMacroblockPtr - 1);
                lpNVMacroblockPtr->hOffset += 0x10;
                lpNVMacroblockPtr->codedBlockPattern = 0;
                lpNVMacroblockPtr->overflowCodedBlockPattern = 0;
                lpNVMacroblockPtr++;
                dwNumDstMacroblocks++;
            }
        }

        // Move to next DXVA macroblock header.
        lpDXVAMacroblockPtr += dwStructureSize;
    }

    // If this frame contained the last macroblock of the picture, set the
    // End of Picture flag.
    lpNvMCFrameData->bMCEndOfPicture = bEndOfPicture;

    // Send the Conversion buffer to nvMoCompExecute, along with the NVID
    // surface containing the IDCT data.
    if (pDriverData->dwDXVAFlags & DXVA_INTRA_IDCT_UNSIGNED)
        dwCommand = EXECUTE_NON_PREBIASED_MOTION_COMPENSATION;
    else
        dwCommand = EXECUTE_MOTION_COMPENSATION;
    nvMoCompExecute(lpNvMCFrameData->dwMCMultiMonID,
                    dwCommand,
                    (LPVOID)(pDriverData->dwDXVAConvertBuffer + MACROBLOCKS_OFFSET),
                    dwNumDstMacroblocks * sizeof(NVDECODEMACROBLOCK),
                    wNVIndex);

    NvReleaseSemaphore(pDriverData);
    return DD_OK;
}  // nvRenderDoMotionComp


/*
 * nvRenderGetYUVPalette
 *
 * Private function called by nvRenderMoComp.
 * Takes the YUV subpicture palette provided by the decoder and uses it to generate
 * a new subpicture pixel lookup table, then use the lookup table to update the
 * current subpicture bitmap.
 *
 */
DWORD __stdcall nvRenderGetYUVPalette(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex)
{
    LPDDMCBUFFERINFO            lpPaletteBuffer;
    LPDXVA_BufferDescription    lpPaletteHeader;
    LPBYTE                      lpPaletteLinear;
    DWORD                       dwIndex, dwPaletteIndex;
    DWORD                       dwX, dwY;
    LPDDRAWI_DDRAWSURFACE_LCL   lpDstSurface;
    LPDWORD                     lpDst;
    DWORD                       dwDstStride;
    DWORD                       dwDstWidth, dwDstHeight;
    DWORD                       dwSrcOffset, dwDstOffset;
    DWORD                       dwAlpha;
    DWORD                       dwYUVArray[16];
    LPBYTE                      lpTemp;
    LPBYTE                      lpSrc;
    LPDWORD                     lpIA44toAYUVLookup;
    LPDXVA_AYUVsample           lpPaletteAYUV;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;
    DWORD                       dwSubpicBuffer, dwSubpicStride;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // Calculate pointer to decompressed section of our NVSP surface.
    lpDstSurface = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    dwDstWidth   = (DWORD)lpDstSurface->lpGbl->wWidth;
    dwDstHeight  = (DWORD)lpDstSurface->lpGbl->wHeight;
    dwDstStride  = (DWORD)lpDstSurface->lpGbl->lPitch;
    lpDst        = (LPDWORD)(nvGetLinearAddress(lpDstSurface)
                             + 2 * dwDstStride * dwDstHeight);

    // Get pointer to the YUV Palette buffer header from lpInputData.
    lpPaletteHeader = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
    lpPaletteHeader += dwRenderIndex;

    // Get pointer to the YUV Palette surface data.
    lpPaletteBuffer = lpRMCData->lpBufferInfo + dwRenderIndex;
    lpPaletteLinear = nvGetLinearAddress(lpPaletteBuffer->lpCompSurface)
                      + lpPaletteBuffer->dwDataOffset;
    lpPaletteAYUV   = (LPDXVA_AYUVsample)lpPaletteLinear;

    // Get pointer to our IA44 to AYUV lookup table.
    lpIA44toAYUVLookup = (LPDWORD)(pDriverData->dwDXVAConvertBuffer + LOOKUP_TABLE_OFFSET);

    // First convert the YUV palette into a YUV array in the correct order for us.
    lpTemp = (LPBYTE)dwYUVArray;
    for (dwIndex = 0; dwIndex < 16; dwIndex++) {
        *lpTemp++ = lpPaletteAYUV->bY_Value;
        *lpTemp++ = lpPaletteAYUV->bCbValue;
        *lpTemp++ = lpPaletteAYUV->bCrValue;
        *lpTemp++ = 0;
        lpPaletteAYUV++;
    }

    // Now use the YUV palette values to fill up the IA44 to AYUV lookup table.
    for (dwIndex = 0; dwIndex < 256; dwIndex++) {
        dwPaletteIndex = readDXVA_IA44index(&dwIndex);
        dwAlpha        = readDXVA_IA44alpha(&dwIndex);

        // Rescale dwAlpha from 0-15 to 0-255 range and shift into right position.
        dwAlpha        = ((dwAlpha * 255) / 15) << 24;
        *(lpIA44toAYUVLookup + dwIndex) = dwYUVArray[dwPaletteIndex] + dwAlpha;
    }

    // Calculate a linear pointer to the NVMC surface created by DShow.
    // We use this surface to store the NVMCFRAMEDATA structure.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);
    dwSubpicBuffer = lpNvMCFrameData->dwDXVASubpicBuffer;
    dwSubpicStride = lpNvMCFrameData->dwDXVASubpicStride;

    // Finally, use this new lookup table to re-convert the last IA44 bitmap
    // to AYUV format and copy it into the decompressed section of our NVSP
    // surface.  (Note that dwDstStride is in DWord units, not Byte units.)
    if (dwSubpicBuffer) {
        lpSrc = (LPBYTE)dwSubpicBuffer;
        for (dwY = 0; dwY < dwDstHeight; dwY++) {
            dwSrcOffset = dwY * dwSubpicStride;
            dwDstOffset = dwY * dwDstStride;
            for (dwX = 0; dwX < dwDstWidth; dwX++) {
                *(lpDst + dwDstOffset)
                    = *(lpIA44toAYUVLookup + *(lpSrc + dwSrcOffset));
                dwSrcOffset++;
                dwDstOffset++;
            }
        }
    }

    NvReleaseSemaphore(pDriverData);
    return DD_OK;
}  // nvRenderGetYUVPalette


/*
 * nvRenderGetIA44Surface
 *
 * Private function called by nvRenderMoComp.
 * Takes the IA44 subpicture bitmap provided by the decoder and uses it to generate
 * a new subpicture bitmap in NV AYUV format.
 *
 */
DWORD __stdcall nvRenderGetIA44Surface(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex)
{
    LPDXVA_BufferDescription    lpIA44Header;
    LPDDMCBUFFERINFO            lpIA44Buffer;
    LPBYTE                      lpIA44Linear;
    DWORD   dwX, dwY;
    LPDDRAWI_DDRAWSURFACE_LCL   lpDstSurface;
    LPDWORD                     lpDst;
    DWORD                       dwDstStride;
    DWORD                       dwDstWidth, dwDstHeight;
    DWORD                       dwSrcOffset, dwDstOffset;
    LPBYTE                      lpSrc;
    LPDWORD                     lpIA44toAYUVLookup;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;
    DWORD                       dwSubpicBuffer, dwSubpicStride;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // Calculate pointer to decompressed section of our NVSP surface.
    lpDstSurface = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    dwDstWidth   = (DWORD)lpDstSurface->lpGbl->wWidth;
    dwDstHeight  = (DWORD)lpDstSurface->lpGbl->wHeight;
    dwDstStride  = (DWORD)lpDstSurface->lpGbl->lPitch;
    lpDst        = (LPDWORD)(nvGetLinearAddress(lpDstSurface)
                             + 2 * dwDstStride * dwDstHeight);
    memset(lpDst, 0, dwDstHeight * dwDstStride * 4);

    // Get pointer to the IA44 buffer header from lpInputData.
    lpIA44Header = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
    lpIA44Header += dwRenderIndex;

    // Get pointer to the IA44 surface data.
    lpIA44Buffer = lpRMCData->lpBufferInfo + dwRenderIndex;
    lpIA44Linear = (LPBYTE)nvGetLinearAddress(lpIA44Buffer->lpCompSurface)
                       + lpIA44Buffer->dwDataOffset;

    // Get pointer to our IA44 to AYUV lookup table.
    lpIA44toAYUVLookup = (LPDWORD)(pDriverData->dwDXVAConvertBuffer + LOOKUP_TABLE_OFFSET);

    // Calculate a linear pointer to the NVMC surface created by DShow.
    // We use this surface to store the NVMCFRAMEDATA structure.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Record subpicture linear address and stride for other functions.
    lpNvMCFrameData->dwDXVASubpicBuffer = (DWORD)lpIA44Linear;
    lpNvMCFrameData->dwDXVASubpicStride = lpIA44Header->dwStride;
    dwSubpicBuffer = lpNvMCFrameData->dwDXVASubpicBuffer;
    dwSubpicStride = lpNvMCFrameData->dwDXVASubpicStride;

    // Finally, use our lookup table to convert this IA44 bitmap to AYUV format
    // and copy it into the decompressed section of our NVSP surface.  (Note
    // that dwDstStride is in DWord units, not Byte units.)
    lpSrc = (LPBYTE)dwSubpicBuffer;
    for (dwY = 0; dwY < dwDstHeight; dwY++) {
        dwSrcOffset = dwY * dwSubpicStride;
        dwDstOffset = dwY * dwDstStride;
        for (dwX = 0; dwX < dwDstWidth; dwX++) {
            *(lpDst + dwDstOffset)
                = *(lpIA44toAYUVLookup + *(lpSrc + dwSrcOffset));
            dwSrcOffset++;
            dwDstOffset++;
        }
    }

    // If back-end alpha blending  enabled, merge this graphic with the frame
    // currently being displayed.
    if (pDriverData->dwDXVAFlags & DXVA_BACK_END_ALPHA_ENABLED)
        nvDXVABackEndAlphaBlend(getDC()->flipOverlayRecord.fpFlipTo);

    NvReleaseSemaphore(pDriverData);
    return DD_OK;
}  // nvRenderGetIA44Surface


/*
 * nvRenderAlphaBlendCombination
 *
 * Private function called by nvRenderMoComp.
 * Alpha blends subpicture bitmap into a decoded video frame.
 *
 */
DWORD __stdcall nvRenderAlphaBlendCombination(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex)
{
    LPDXVA_BufferDescription    lpAlphaHeader;
    LPDDMCBUFFERINFO            lpAlphaBuffer;
    LPBYTE                      lpAlphaLinear;
    LPDXVA_BlendCombination     lpDXVABlend;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // Get pointer to NVMC surface with FrameData info.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Get pointer to the Alpha Blend Combination buffer header from lpInputData.
    lpAlphaHeader = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
    lpAlphaHeader += dwRenderIndex;

    // Get pointer to the Alpha Blend Combination surface data.
    lpAlphaBuffer = lpRMCData->lpBufferInfo + dwRenderIndex;
    lpAlphaLinear = nvGetLinearAddress(lpAlphaBuffer->lpCompSurface)
                       + lpAlphaBuffer->dwDataOffset;
    lpDXVABlend = (LPDXVA_BlendCombination)lpAlphaLinear;

    // If Back End alpha blending is selected, we just store the information
    // from the DXVABlendCombination structure for later when we decode or Flip.
    if (pDriverData->dwDXVAFlags & DXVA_BACK_END_ALPHA_SELECTED) {

        // Store new back-end blend parameters in our NVMC structure.
        lpNvMCFrameData->rcGraphicSourceRect      = lpDXVABlend->GraphicSourceRect;
        lpNvMCFrameData->rcGraphicDestinationRect = lpDXVABlend->GraphicDestinationRect;
        lpNvMCFrameData->bBlendOn                 = lpDXVABlend->bBlendOn;

        // If bBlendOn, set blend enabled flag and blend graphic into the current frame.
        if (lpDXVABlend->bBlendOn) {
            nvDXVABackEndAlphaBlend(getDC()->flipOverlayRecord.fpFlipTo);
            pDriverData->dwDXVAFlags |= DXVA_BACK_END_ALPHA_ENABLED;
        }
        else {
            pDriverData->dwDXVAFlags &= ~DXVA_BACK_END_ALPHA_ENABLED;
        }
    }

    // Else Front End alpha blending is selected, and we use the Execute
    // function to perform it on the selected frame.
    else {
        // We use the newer EXECUTE_DXVA_ALPHA_BLENDING function to do the
        // blending from the source buffer to the destination.
        nvMoCompExecute(lpNvMCFrameData->dwMCMultiMonID,
                        EXECUTE_DXVA_ALPHA_BLENDING,
                        (LPVOID)lpDXVABlend,
                        sizeof(DDHAL_RENDERMOCOMPDATA),
                        dwRenderIndex);
    }

    NvReleaseSemaphore(pDriverData);
    return DD_OK;
}  // nvRenderAlphaBlendCombination


/*
 * nvMoCompExecute
 *
 * Performs motion compensation on a portion of a new frame
 * (same functionality as nvRenderMoComp() but called directly by decoder as an
 *  interim Win9x interface solution until the HVA interface becomes available on Win9x)
 *
 * Functions supported: 0 = perform motion compensation operation
 *                      1 = temporally filter fields in destination frame
 *                      2 = decompress subpicture surface
 *                      3 = composite decompressed subpicture surface with destination surface
 *                      4 = display overlay surface
 *                      5 = format convert overlay surface
 *                      6 = perform non-prebiased motion compensation operation
 *
 */
DWORD __stdcall nvMoCompExecute(DWORD dwMCMultiMonID, DWORD dwFunction, LPVOID lpInputData, DWORD dwInputDataSize, DWORD dwSurfaceIndex)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    DWORD                       status, dwIndex;
    DWORD                       dwBlockSize;
    LPNVMCFRAMEDATA             lpNvMCFrameData;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    LPNVMCSURFACEFLAGS          lpSurfaceFlags;

    // Set up our multimon environment
#ifdef WINNT
    // For Win2K, get pDriverData from lpDD passed as the MultiMon parameter.
    nvSetDriverDataPtrFromDDGbl(((LPDDRAWI_DIRECTDRAW_LCL)dwMCMultiMonID)->lpGbl);
#else
    pDXShare = (DISPDRVDIRECTXCOMMON *)(dwMCMultiMonID);
    NvAcquireSemaphore((GLOBALDATA *) (pDXShare->pDirectXData));
    pDriverData = (CDriverContext *) (pDXShare->pDirectXData);
#endif

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(NULL)) {
            NvReleaseSemaphore(pDriverData);
            return (DDERR_SURFACELOST);
        }
        pDriverData->dwMostRecentHWUser = MODULE_ID_NONE;
    }

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            if (!(nvInitKelvinForMoComp())) {
                NvReleaseSemaphore(pDriverData);
                return (DDERR_GENERIC);
            }
        }
        else {
            if (!(nvInitCelsiusForMoComp())) {
                NvReleaseSemaphore(pDriverData);
                return (DDERR_GENERIC);
            }
        }
    }

    // Check if this is the first call on a new frame/field
    if (pDriverData->bMCNewFrame) {

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
        lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

        // Check if decoder updated it's data in the surface
        if (lpNvMCFrameData->bMCDestinationSurfaceIndex == 255) {
            NvReleaseSemaphore(pDriverData);
            return(DDERR_INVALIDPARAMS);
        }

        pDriverData->bMCNewFrame = FALSE;

        pDriverData->bMCPictureStructure = lpNvMCFrameData->bMCPictureStructure;
        pDriverData->bMCPictureCodingType = lpNvMCFrameData->bMCPictureCodingType;
        pDriverData->bMCTopFieldFirst = lpNvMCFrameData->bMCTopFieldFirst;
        pDriverData->bMCSecondField = lpNvMCFrameData->bMCSecondField;

        if (lpNvMCFrameData->bMCDestinationSurfaceIndex < 8)
            pDriverData->dwMCDestinationSurface = pDriverData->dwMCNV12Surface[lpNvMCFrameData->bMCDestinationSurfaceIndex];
        else
            pDriverData->dwMCDestinationSurface = pDriverData->dwMCNV12Surface[0];

        // Check for mode switches and full screen DOS interruptions
        if (pDriverData->dwMCDestinationSurface == 0) {
            NvReleaseSemaphore(pDriverData);
            return (DDERR_SURFACELOST);
        }

        if (lpNvMCFrameData->bMCForwardSurfaceIndex < 8)
            pDriverData->dwMCForwardSurface = pDriverData->dwMCNV12Surface[lpNvMCFrameData->bMCForwardSurfaceIndex];
        else
            pDriverData->dwMCForwardSurface = pDriverData->dwMCNV12Surface[0];

        if (pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) {
            if (lpNvMCFrameData->bMCBackwardSurfaceIndex < 8)
                pDriverData->dwMCBackwardSurface = pDriverData->dwMCNV12Surface[lpNvMCFrameData->bMCBackwardSurfaceIndex];
            else
                pDriverData->dwMCBackwardSurface = pDriverData->dwMCNV12Surface[0];
            pDriverData->dwMCDualPrimeSurface = pDriverData->dwMCForwardSurface; // necessary for broken HDTV tuner
        } else {
            // For self referencing field structured P fields
            pDriverData->dwMCBackwardSurface = pDriverData->dwMCDestinationSurface;
            pDriverData->dwMCDualPrimeSurface = pDriverData->dwMCForwardSurface;
        }

        // Make sure none of the surface indexes were for surfaces that were never created.
        if (!pDriverData->dwMCDestinationSurface)
            pDriverData->dwMCDestinationSurface  = pDriverData->dwMCNV12Surface[0];
        if (!pDriverData->dwMCForwardSurface)
            pDriverData->dwMCForwardSurface      = pDriverData->dwMCNV12Surface[0];
        if (!pDriverData->dwMCBackwardSurface)
                pDriverData->dwMCBackwardSurface = pDriverData->dwMCNV12Surface[0];
        if (!pDriverData->dwMCDualPrimeSurface)
            pDriverData->dwMCDualPrimeSurface    = pDriverData->dwMCNV12Surface[0];

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
        pSurf_gbl = pSurf_lcl->lpGbl;

        pDriverData->dwMCDestinationSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, pDriverData->dwMCDestinationSurfaceOffset);
            nvPusherAdjust(4);

            nvPusherStart(TRUE);
        } else {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, pDriverData->dwMCDestinationSurfaceOffset);
            nvPusherAdjust(4);

            nvPusherStart(TRUE);
        }

        // Initialize frame specific data if this is indeed a new frame
        if ((dwFunction == EXECUTE_MOTION_COMPENSATION) ||
            (dwFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION)) {

            lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

            while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
                   (lpDstSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
                lpDstSurfaceFlags++;

            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
                if (pDriverData->dwMCMostRecentlyDecodedSurfaceBase != pSurf_gbl->fpVidMem)
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted = 0;
                else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 15)
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted = 0;
            } else if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) {
                if ((pDriverData->dwMCMostRecentlyDecodedSurfaceBase != pSurf_gbl->fpVidMem) ||
                    (lpDstSurfaceFlags->bMCPictureStructure != pDriverData->bMCPictureStructure))
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted &= ~3;
                else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 3)
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted &= ~3;
            } else {
                if ((pDriverData->dwMCMostRecentlyDecodedSurfaceBase != pSurf_gbl->fpVidMem) ||
                    (lpDstSurfaceFlags->bMCPictureStructure != pDriverData->bMCPictureStructure))
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted &= ~12;
                else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 12)
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted &= ~12;
            }

            // Initialize surface flags in video memory
            lpDstSurfaceFlags->bMCPictureStructure = pDriverData->bMCPictureStructure;
            lpDstSurfaceFlags->bMCPictureCodingType = pDriverData->bMCPictureCodingType;
            lpDstSurfaceFlags->bMCTopFieldFirst = pDriverData->bMCTopFieldFirst;
            lpDstSurfaceFlags->bMCSecondField = pDriverData->bMCSecondField;
            lpDstSurfaceFlags->bMCFrameType = 0;
            lpDstSurfaceFlags->bMCFrameIsFiltered = FALSE;
            lpDstSurfaceFlags->bMCFrameIsComposited = FALSE;

            pDriverData->dwMCMostRecentlyDecodedSurfaceBase = pSurf_gbl->fpVidMem;
            pDriverData->bMCMostRecentlyDecodedPictureStructure = pDriverData->bMCPictureStructure;

            // Make sure this surface is not currently visible
            if (pSurf_lcl->lpGbl->wWidth < 1024) { // If DVD
                while (nvMoCompFrameStatus (pSurf_lcl->lpGbl->fpVidMem) != DD_OK)
                    NV_SLEEP1; // Don't change (bmac)
            } // else { // If HDTV (don't even check, especially on NV11)
//                while (nvMoCompFlipStatus(pSurf_lcl->lpGbl->fpVidMem) != DD_OK)
//                    NV_SLEEP; // Don't change (bmac)
//            }
            
            if (pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) {
                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface;

                lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

                while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                       (lpSurfaceFlags->dwMCSurfaceBase != pSurf_lcl->lpGbl->fpVidMem))
                    lpSurfaceFlags++;

                pDriverData->bMCForwardPictureStructure = lpSurfaceFlags->bMCPictureStructure;

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

                while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                       (lpSurfaceFlags->dwMCSurfaceBase != pSurf_lcl->lpGbl->fpVidMem))
                    lpSurfaceFlags++;

                pDriverData->bMCBackwardPictureStructure = lpSurfaceFlags->bMCPictureStructure;
            }
        }

    } else {

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
        lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

        // Check if decoder updated it's data in the surface
        if (lpNvMCFrameData->bMCDestinationSurfaceIndex == 255) {
            NvReleaseSemaphore(pDriverData);
            return(DDERR_INVALIDPARAMS);
            }

        pDriverData->bMCPictureStructure = lpNvMCFrameData->bMCPictureStructure;
        pDriverData->bMCPictureCodingType = lpNvMCFrameData->bMCPictureCodingType;
        pDriverData->bMCTopFieldFirst = lpNvMCFrameData->bMCTopFieldFirst;
        pDriverData->bMCSecondField = lpNvMCFrameData->bMCSecondField;

        if (lpNvMCFrameData->bMCDestinationSurfaceIndex < 8)
            pDriverData->dwMCDestinationSurface = pDriverData->dwMCNV12Surface[lpNvMCFrameData->bMCDestinationSurfaceIndex];
        else
            pDriverData->dwMCDestinationSurface = pDriverData->dwMCNV12Surface[0];

        // Check for mode switches and full screen DOS interruptions
        if (pDriverData->dwMCDestinationSurface == 0) {
            NvReleaseSemaphore(pDriverData);
            return (DDERR_SURFACELOST);
        }
    }

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    pDriverData->dwMCDestinationSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
        lpDstSurfaceFlags++;

    pDriverData->bMCCurrentExecuteFunction = (BYTE)dwFunction;

    if ((dwFunction == EXECUTE_MOTION_COMPENSATION) ||
        (dwFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION)) {
        LPNVDECODEMACROBLOCK pMacroblocks = (LPNVDECODEMACROBLOCK)lpInputData;
        long dwNumMacroblocks;
        long macroblockIncr = 256;

        // Update reference count on previous IDCT surface to indicate we have switched away from it
        if (pDriverData->dwMCIDCTSurface != 0) {
            for (dwIndex=0; dwIndex<4; dwIndex++) {
                if (pDriverData->dwMCIDCTSurface == pDriverData->dwMCNVIDSurface[dwIndex]) {
                    break;
                }
            }

            if (dwIndex >= 4)
                dwIndex = 0;

            if ((dwIndex < 4) && (dwSurfaceIndex != dwIndex)) {
                pDriverData->dwMCNVIDSurfaceReferenceCount[dwIndex] = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
                nvPusherStart(TRUE);
            }
        }

        if (dwSurfaceIndex < 4)
            pDriverData->dwMCIDCTSurface = pDriverData->dwMCNVIDSurface[dwSurfaceIndex];
        else
            pDriverData->dwMCIDCTSurface = pDriverData->dwMCNVIDSurface[0];

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface;
        pSurf_gbl = pSurf_lcl->lpGbl;

        pDriverData->dwMCForwardSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;
        pSurf_gbl = pSurf_lcl->lpGbl;

        pDriverData->dwMCBackwardSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCIDCTSurface;
        pSurf_gbl = pSurf_lcl->lpGbl;

        if (pSurf_gbl->ddpfSurface.dwFourCC != FOURCC_NVID) {
            NvReleaseSemaphore(pDriverData);
            return (DDERR_INVALIDPARAMS);
        }

        dwBlockSize = pSurf_gbl->lPitch * pSurf_gbl->wHeight;
        dwBlockSize |= 0xFF; // Context DMA must end on 256 byte boundary (enough extra memory was allocated for this correction)


        for (dwIndex=0; dwIndex<4; dwIndex++) {
            if (pSurf_gbl->fpVidMem == pDriverData->dwMCIDCTAGPSurfaceBase[dwIndex]) {
                break;
            }
        }

        if (dwIndex >= 4)
            dwIndex = 0;

        if (pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] == 0) {
            pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;
            status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                                         NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex,
                                         NV01_CONTEXT_DMA,
                                         DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                                         DRF_DEF(OS03, _FLAGS, _LOCKED, _ALWAYS) |
                                         DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                                         (PVOID) VIDMEM_ADDR(pSurf_gbl->fpVidMem),
                                         dwBlockSize);
            if (status != NVOS03_STATUS_SUCCESS) {
                NvReleaseSemaphore(pDriverData);
                return (DDERR_SURFACELOST);
            }

            pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] = dwBlockSize;
        }
        // Update IDCT context Dma
        if (pDriverData->dwMCCurrentCelsiusIDCTCtxDma != (NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex)) {
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_CONTEXT_DMA_B | 0x40000);
                nvPushData(1, NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex);
                nvPusherAdjust(2);
                nvPusherStart(TRUE);
            } else {
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_CONTEXT_DMA_B | 0x40000);
                nvPushData(1, NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex);
                nvPusherAdjust(2);
                nvPusherStart(TRUE);
            }
            pDriverData->dwMCCurrentCelsiusIDCTCtxDma = NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex;
        }

        dwNumMacroblocks = dwInputDataSize / sizeof(NVDECODEMACROBLOCK);

        if ((dwNumMacroblocks * sizeof(NVDECODEMACROBLOCK)) != dwInputDataSize) {
            NvReleaseSemaphore(pDriverData);
            return (DDERR_INVALIDPARAMS);
        }

        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
                while (dwNumMacroblocks > 0) {
                    if (dwNumMacroblocks > macroblockIncr) {
                        if (!(nvMoCompProcessKelvinFrameMacroblocks(pMacroblocks,
                                                                    macroblockIncr,
                                                                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    } else {
                        if (!(nvMoCompProcessKelvinFrameMacroblocks(pMacroblocks,
                                                                    dwNumMacroblocks,
                                                                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    }
                    pMacroblocks += macroblockIncr;
                    dwNumMacroblocks -= macroblockIncr;
                }
            } else {
                while (dwNumMacroblocks > 0) {
                    if (dwNumMacroblocks > macroblockIncr) {
                        if (!(nvMoCompProcessKelvinFieldMacroblocks(pMacroblocks,
                                                                    macroblockIncr,
                                                                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    } else {
                        if (!(nvMoCompProcessKelvinFieldMacroblocks(pMacroblocks,
                                                                    dwNumMacroblocks,
                                                                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    }
                    pMacroblocks += macroblockIncr;
                    dwNumMacroblocks -= macroblockIncr;
                }
            }
        } else {
            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
                while (dwNumMacroblocks > 0) {
                    if (dwNumMacroblocks > macroblockIncr) {
                        if (!(nvMoCompProcessCelsiusFrameMacroblocks(pMacroblocks,
                                                                     macroblockIncr,
                                                                     lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    } else {
                        if (!(nvMoCompProcessCelsiusFrameMacroblocks(pMacroblocks,
                                                                     dwNumMacroblocks,
                                                                     lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    }
                    pMacroblocks += macroblockIncr;
                    dwNumMacroblocks -= macroblockIncr;
                }
            } else {
                while (dwNumMacroblocks > 0) {
                    if (dwNumMacroblocks > macroblockIncr) {
                        if (!(nvMoCompProcessCelsiusFieldMacroblocks(pMacroblocks,
                                                                     macroblockIncr,
                                                                     lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    } else {
                        if (!(nvMoCompProcessCelsiusFieldMacroblocks(pMacroblocks,
                                                                     dwNumMacroblocks,
                                                                     lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    }
                    pMacroblocks += macroblockIncr;
                    dwNumMacroblocks -= macroblockIncr;
                }
            }
        }

        // Update reference count in case we get a status query
        lpDstSurfaceFlags->dwMCMotionCompReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
        nvPusherStart(TRUE);

    } else if (dwFunction == EXECUTE_TEMPORAL_FILTER) { // function 1 = temporally filter destination surface
        LPNVMCFILTERDATA lpNvMCFilterData = (LPNVMCFILTERDATA)lpInputData;

        // Only allow temporal filter changes if temporal filtering is allowed.
        // Not allowed if bMCTemporalFilterDisabled == 2 (no temporal filter area in NV12 buffers.)
        if (pDriverData->bMCTemporalFilterDisabled < 2) {
            if (lpNvMCFilterData->bMCFilterOptions & TEMPORAL_FILTER_DISABLE_ON_ALL_SURFACES)
                pDriverData->bMCTemporalFilterDisabled = TRUE;
            else
                pDriverData->bMCTemporalFilterDisabled = FALSE;

            if (lpNvMCFilterData->bMCFilterOptions & TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE)
                pDriverData->nvMCSurfaceFlags[dwSurfaceIndex].bMCFrameType |= TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE;

            pDriverData->bMCPercentCurrentField = lpNvMCFilterData->bMCCurrentFieldCombinationFactor;
        }

        NvReleaseSemaphore(pDriverData);
        return (DD_OK);

    } else if (dwFunction == EXECUTE_SUBPICTURE_DECOMPRESSION) { // function 2 = decompress subpicture surface
        DWORD status = nvMoCompDecompressSubpicture(lpInputData, dwSurfaceIndex);
        NvReleaseSemaphore(pDriverData);
        return (status);

    } else if (dwFunction == EXECUTE_SUBPICTURE_COMPOSITING) { // function 3 = composite subpicture

        DWORD status = nvMoCompCompositeSubpicture(lpInputData, dwSurfaceIndex);
        NvReleaseSemaphore(pDriverData);
        return (status);

    } else if (dwFunction == EXECUTE_DISPLAY_OVERLAY_SURFACE) { // function 4 = display overlay surface

        DWORD status = nvMoCompDisplaySurface(lpInputData, dwSurfaceIndex);
        NvReleaseSemaphore(pDriverData);
        return (status);

    } else if (dwFunction == EXECUTE_FORMAT_CONVERT_OVERLAY_SURFACE) {  // function 5 = format convert overlay surface

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
        pSurf_gbl = pSurf_lcl->lpGbl;

        lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

        while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpDstSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
            lpDstSurfaceFlags++;

        lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted = 0;
        lpDstSurfaceFlags->bMCPictureStructure = pDriverData->bMCPictureStructure;
        pDriverData->dwMCMostRecentlyDecodedSurfaceBase = pSurf_gbl->fpVidMem;
        pDriverData->bMCMostRecentlyDecodedPictureStructure = pDriverData->bMCPictureStructure;

        nvMoCompConvertSurfaceFormat(pDriverData->dwMCMostRecentlyDecodedSurfaceBase, TRUE, 15);
    }

    else if (dwFunction == EXECUTE_DXVA_ALPHA_BLENDING) {
        DWORD status = nvDXVACompositeSubpicture(lpInputData, dwSurfaceIndex);
        NvReleaseSemaphore(pDriverData);
        return (status);
    }



    NvReleaseSemaphore(pDriverData);
    return (DD_OK);

} /* nvMoCompExecute */


/*
 * nvQueryMoCompStatus
 *
 * Returns current motion comp status.  Does not currently associate status with
 * a particular surface.
 *
 */
DWORD __stdcall nvQueryMoCompStatus( LPDDHAL_QUERYMOCOMPSTATUSDATA lpQMCSData)
{
    LPNVMCSURFACEFLAGS          lpSurfaceFlags;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;

    nvSetDriverDataPtrFromDDGbl (lpQMCSData->lpDD->lpGbl);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(lpQMCSData->lpDD->lpGbl)) {
            NvReleaseSemaphore(pDriverData);
            lpQMCSData->ddRVal = DDERR_SURFACELOST;
            return (DDHAL_DRIVER_HANDLED);
        }
        if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                if (!(nvInitKelvinForMoComp())) {
                    NvReleaseSemaphore(pDriverData);
                    lpQMCSData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
                    return(DDHAL_DRIVER_HANDLED);
                }
            }
            else {
                if (!(nvInitCelsiusForMoComp())) {
                    NvReleaseSemaphore(pDriverData);
                    lpQMCSData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
                    return(DDHAL_DRIVER_HANDLED);
                }
            }
        }
    }

    // Assume return state is OK unless we find out otherwise
    lpQMCSData->ddRVal = DD_OK;

    // Do different status checks depending on surface FourCC type.
    switch (lpQMCSData->lpSurface->lpGbl->ddpfSurface.dwFourCC) {

    case FOURCC_NV12:

        // Get flags for this NV12 surface.
        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != lpQMCSData->lpSurface->lpGbl->fpVidMem)) {
            lpSurfaceFlags++;
        }

        // If this NV12 surface is the last surface decoded into, check to see if the motion comp
        // operation is done before you allow it to be written or read.
        if (lpQMCSData->lpSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface) {
            if (lpQMCSData->dwFlags & DDMCQUERY_READ) {
                if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                               lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                               0)) {
                    lpQMCSData->ddRVal = DDERR_WASSTILLDRAWING;
                }
            }
            else {
                if ((!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                                0))
                    ||
                    (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                lpSurfaceFlags->dwMCFormatCnvReferenceCount,
                                                0))) {
                    lpQMCSData->ddRVal = DDERR_WASSTILLDRAWING;
                }
            }
        }

        // Else if this NV12 surface is being used as a reference frame, check to see if the motion comp
        // operation is done before you allow it to be written to.
        else if ((lpQMCSData->lpSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface) ||
                 (lpQMCSData->lpSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface)) {
            if (!(lpQMCSData->dwFlags & DDMCQUERY_READ)) {
                if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                               lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                               0)) {
                    lpQMCSData->ddRVal = DDERR_WASSTILLDRAWING;
                }
            }
        }
        // Else  check the surface is in the middle of compositing sub-picture
        else  if (lpSurfaceFlags->bMCFrameIsComposited) {
            if(!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                lpSurfaceFlags->dwMCCompositeReferenceCount, 0))
            {
           
               lpQMCSData->ddRVal = DDERR_WASSTILLDRAWING;
 

            }

        }
 
        break;

    case FOURCC_NVID:

        // If this NVID surface is the one last used for a motion comp operation, check to see
        // if the motion comp operation is done before you allow it to be reused.
        if ((DWORD)lpQMCSData->lpSurface == pDriverData->dwMCIDCTSurface) {

            // Get flags for the corresponding NV12 surface.
            pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
            lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
            while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                   (lpSurfaceFlags->dwMCSurfaceBase != pSurf_lcl->lpGbl->fpVidMem)) {
                lpSurfaceFlags++;
            }

            if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                           lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                           0)) {
                lpQMCSData->ddRVal = DDERR_WASSTILLDRAWING;
            }
        }
        break;
    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvQueryMoCompStatus */


/*
 * nvDestroyMoComp
 *
 * Destroys anything temporarily created for motion comp operations.
 *
 */
DWORD __stdcall nvDestroyMoComp( LPDDHAL_DESTROYMOCOMPDATA lpDMCData)
{
    nvSetDriverDataPtrFromDDGbl(lpDMCData->lpDD->lpGbl);

    // If a conversion buffer was created by nvCreateMoComp, free it now.
    if (pDriverData->dwDXVAConvertBuffer) {
        GlobalFree((HGLOBAL)pDriverData->dwDXVAConvertBuffer);
        pDriverData->dwDXVAConvertBuffer = 0;
    }

    // Reset some variables.
    pDriverData->dwDXVAFlags &= DXVA_BACK_END_ALPHA_ENABLED;    // don't reset this flag, we may be going through a mode switch

    lpDMCData->ddRVal = DD_OK;
    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvDestroyMoComp */


/*
 * nvGetMoCompDriverInfo
 *
 * Initialize Motion Comp Functionality HAL Callbacks
 *
 */
void __stdcall nvGetMoCompDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
{
    DDHAL_DDMOTIONCOMPCALLBACKS moCompCB;
    DWORD dwSize = lpData->dwExpectedSize;

    // Check to see whether DXVAEnable was set in the registry.
    // If not, return an error and don't fill in the function table.
    // Note: dwDXVAFlags is set by D3DReadRegistry.
    if (!(pDriverData->dwDXVAFlags & DXVA_ENABLED_IN_REGISTRY)) {
        lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return;
    }

    global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0600);

    if ( sizeof(moCompCB) < dwSize )
        dwSize = sizeof(moCompCB);

    lpData->dwActualSize = sizeof(moCompCB);
    memset(&moCompCB, 0, dwSize);

    moCompCB.dwSize = dwSize;

    moCompCB.dwFlags = DDHAL_MOCOMP32_GETGUIDS |
                       DDHAL_MOCOMP32_GETFORMATS |
                       DDHAL_MOCOMP32_CREATE |
                       DDHAL_MOCOMP32_GETCOMPBUFFINFO |
                       DDHAL_MOCOMP32_GETINTERNALINFO |
                       DDHAL_MOCOMP32_BEGINFRAME |
                       DDHAL_MOCOMP32_ENDFRAME |
                       DDHAL_MOCOMP32_RENDER |
                       DDHAL_MOCOMP32_QUERYSTATUS |
                       DDHAL_MOCOMP32_DESTROY;

    moCompCB.GetMoCompGuids = nvGetMoCompGuids;
    moCompCB.GetMoCompFormats = nvGetMoCompFormats;
    moCompCB.CreateMoComp = nvCreateMoComp;
    moCompCB.GetMoCompBuffInfo = nvGetMoCompBuffInfo;
    moCompCB.GetInternalMoCompInfo = nvGetInternalMoCompInfo;
    moCompCB.BeginMoCompFrame = nvBeginMoCompFrame;
    moCompCB.EndMoCompFrame = nvEndMoCompFrame;
    moCompCB.RenderMoComp = nvRenderMoComp;
    moCompCB.QueryMoCompStatus = nvQueryMoCompStatus;
    moCompCB.DestroyMoComp = nvDestroyMoComp;

    memcpy(lpData->lpvData, &moCompCB, dwSize );

    lpData->ddRVal = DD_OK;

} /* nvGetMoCompDriverInfo */


/*
 * nvGetLinearAddress
 *
 * Return the linear address of a DDraw surface, depending on whether
 * it's in Local, NonLocal, or System memory.
 *
 */
LPBYTE __stdcall nvGetLinearAddress(LPDDRAWI_DDRAWSURFACE_LCL lpSurf)
{
    if (lpSurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
        if (lpSurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            return (LPBYTE)AGPMEM_ADDR(lpSurf->lpGbl->fpVidMem);
        else
            return (LPBYTE)VIDMEM_ADDR(lpSurf->lpGbl->fpVidMem);
    }
    else
        return (LPBYTE)lpSurf->lpGbl->fpVidMem;
}  // nvGetLinearAddress


/*
 * nvDXVACompositeSubpicture
 *
 * Performs full or partial compositing of a decompressed subpicture surface to the destination overlay
 * surface with scaling.  This function does subpicture blending DXVA-style, blending from one NV12
 * surface to another, and allowing for scaling of the video image before the subpicture is blended in.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvDXVACompositeSubpicture(LPVOID lpInputData, DWORD dwIndex)
{
    LPDXVA_BlendCombination     lpDXVABlend;
    LPDDRAWI_DDRAWSURFACE_LCL   pSrcSurf_lcl, pDstSurf_lcl, pSPSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSrcSurf_gbl, pDstSurf_gbl, pSPSurf_gbl;
    LPNVMCSURFACEFLAGS          lpSrcSurfaceFlags, lpDstSurfaceFlags;
    DWORD                       dwBlockSize;
    DWORD                       dwSrcOffset, dwDstOffset, dwSPOffset;
    DWORD                       dwMixOffset;
    DWORD                       dwPitch422;
    DWORD                       dwSPSurfaceWidth, dwSPSurfaceHeight;
    DWORD                       dwDstSurfaceWidth, dwDstSurfaceHeight;
    int                         nPicSrcX, nPicSrcY, nPicSrcW, nPicSrcH;
    int                         nPicDstX, nPicDstY, nPicDstW, nPicDstH;
    int                         nSubSrcX, nSubSrcY, nSubSrcW, nSubSrcH;
    int                         nSubDstX, nSubDstY, nSubDstW, nSubDstH;
    WORD                        wDXVASrcIndex, wDXVADstIndex;
    BYTE                        bNVSrcIndex, bNVDstIndex;
    DDHAL_BLTDATA               BltData;
    RECTL                       SrcRect, DstRect;
    DWORD                       X0, Y0, X1, Y1;
    DWORD                       tmpVal;
    DWORD                       dwLumaOffset, dwChromaOffset;
    DWORD                       dwScaleX, dwScaleY;
    RECT                        rcPictureSourceRect;
    BYTE                        bScaled;

    // Get pointer to DXVA BlendCombination structure from lpInputData.
    lpDXVABlend = (LPDXVA_BlendCombination)lpInputData;

    // Pick up parameters from DXVA Blend structure.
    wDXVASrcIndex = lpDXVABlend->wPictureSourceIndex;
    wDXVADstIndex = lpDXVABlend->wBlendedDestinationIndex;

    rcPictureSourceRect.left   = lpDXVABlend->PictureSourceRect16thPel.left   >> 4;
    rcPictureSourceRect.top    = lpDXVABlend->PictureSourceRect16thPel.top    >> 4;
    rcPictureSourceRect.right  = lpDXVABlend->PictureSourceRect16thPel.right  >> 4;
    rcPictureSourceRect.bottom = lpDXVABlend->PictureSourceRect16thPel.bottom >> 4;

    nPicSrcX = rcPictureSourceRect.left;
    nPicSrcY = rcPictureSourceRect.top;
    nPicSrcW = rcPictureSourceRect.right  - rcPictureSourceRect.left;
    nPicSrcH = rcPictureSourceRect.bottom - rcPictureSourceRect.top;

    nPicDstX = lpDXVABlend->PictureDestinationRect.left;
    nPicDstY = lpDXVABlend->PictureDestinationRect.top;
    nPicDstW = lpDXVABlend->PictureDestinationRect.right
             - lpDXVABlend->PictureDestinationRect.left;
    nPicDstH = lpDXVABlend->PictureDestinationRect.bottom
             - lpDXVABlend->PictureDestinationRect.top;

    nSubSrcX = lpDXVABlend->GraphicSourceRect.left;
    nSubSrcY = lpDXVABlend->GraphicSourceRect.top;
    nSubSrcW = lpDXVABlend->GraphicSourceRect.right
             - lpDXVABlend->GraphicSourceRect.left;
    nSubSrcH = lpDXVABlend->GraphicSourceRect.bottom
             - lpDXVABlend->GraphicSourceRect.top;

    nSubDstX = lpDXVABlend->GraphicDestinationRect.left;
    nSubDstY = lpDXVABlend->GraphicDestinationRect.top;
    nSubDstW = lpDXVABlend->GraphicDestinationRect.right
             - lpDXVABlend->GraphicDestinationRect.left;
    nSubDstH = lpDXVABlend->GraphicDestinationRect.bottom
             - lpDXVABlend->GraphicDestinationRect.top;

    // Check parameters.
    if ((nSubSrcX <  0) ||
        (nSubSrcY <  0) ||
        (nSubSrcW <  0) ||
        (nSubSrcH <  0))
        return (DDERR_INVALIDPARAMS);

    if ((nPicDstX <  0) ||
        (nPicDstY <  0) ||
        (nPicDstW <= 0) ||
        (nPicDstH <= 0))
        return (DDERR_INVALIDPARAMS);

    // Convert DXVA buffer indexes into NV indexes.
    bNVSrcIndex = pDriverData->bDXVAIndexToNVIndex[wDXVASrcIndex];
    bNVDstIndex = pDriverData->bDXVAIndexToNVIndex[wDXVADstIndex];

    // Get pointers to source and dest NV12 surfaces and the subpicture NVSP surface.
    pSrcSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[bNVSrcIndex];
    pSrcSurf_gbl = pSrcSurf_lcl->lpGbl;
    pDstSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[bNVDstIndex];
    pDstSurf_gbl = pDstSurf_lcl->lpGbl;
    pSPSurf_lcl  = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    pSPSurf_gbl  = pSPSurf_lcl->lpGbl;

    // Get surface flags for source and dest.
    lpSrcSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
    while ((lpSrcSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpSrcSurfaceFlags->dwMCSurfaceBase != pSrcSurf_gbl->fpVidMem))
        lpSrcSurfaceFlags++;
    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != pDstSurf_gbl->fpVidMem))
        lpDstSurfaceFlags++;

    // Calculate some things for the surfaces.
    dwPitch422 = (pDstSurf_gbl->wWidth + 3) & ~3;
    dwPitch422 = ((dwPitch422 << 1) + 127) & ~127;

    dwDstSurfaceWidth  = pDstSurf_gbl->wWidth;
    dwDstSurfaceHeight = pDstSurf_gbl->wHeight;

    dwSPSurfaceWidth  = pSPSurf_gbl->wWidth;
    dwSPSurfaceHeight = pSPSurf_gbl->wHeight;

    dwSrcOffset = lpSrcSurfaceFlags->dwMCSurface422Offset;
    dwDstOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

    // Check for rectangles too large for their respective surface.
    if (((DWORD)(nPicSrcX + nPicSrcW) > dwDstSurfaceWidth) ||
        ((DWORD)(nPicSrcY + nPicSrcH) > dwDstSurfaceHeight))
        return (DDERR_INVALIDPARAMS);
    
    if (((DWORD)(nPicDstX + nPicDstW) > dwDstSurfaceWidth) ||
        ((DWORD)(nPicDstY + nPicDstH) > dwDstSurfaceHeight))
        return (DDERR_INVALIDPARAMS);
    
    if (((DWORD)(nSubSrcX + nSubSrcW) > dwSPSurfaceWidth) ||
        ((DWORD)(nSubSrcY + nSubSrcH) > dwSPSurfaceHeight))
        return (DDERR_INVALIDPARAMS);
    
    if (((DWORD)(nSubDstX + nSubDstW) > dwDstSurfaceWidth) ||
        ((DWORD)(nSubDstY + nSubDstH) > dwDstSurfaceHeight))
        return (DDERR_INVALIDPARAMS);
    
    // Calculate offsets in the NVSP subpicture surface.
    // dwSPOffset points to the YUV32 subpicture bitmap.
    dwSPOffset  = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);
    dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight;
    dwBlockSize <<= 1;
    dwSPOffset += dwBlockSize;

    // dwMixOffset points to the Mixer buffer used temporarily for alpha blending.
    dwMixOffset = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);
    dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight;
    dwBlockSize <<= 1;
    dwMixOffset += dwBlockSize;
    dwMixOffset += (dwBlockSize << 1);
    dwMixOffset += 1024;

    // If the picture source and dest buffers are the same (usually only when
    // back-end alpha blending is enabled) we use the Mix buffer for blending.
    // Else if the picture source and dest rects are the same, we don't need to scale
    // or crop, and we can do our subpicture blending in the destination buffer.
    // But if the rectangles don't match, we need to use the Mix buffer to hold
    // the YUY2 image temporarily until we can scale it into the Dst buffer, and
    // then blend the subpicture into the Dst buffer.
    if (bNVSrcIndex == bNVDstIndex) {
        bScaled = 0;
    }
    else if (memcmp(&(rcPictureSourceRect), &(lpDXVABlend->PictureDestinationRect), sizeof(RECT))) {
        bScaled = 1;
    }
    else {
        bScaled = 0;
        dwMixOffset = dwDstOffset;
    }


    // If the DXVA source and destination indexes are different, use DDBlt
    // to copy the image from the NV12 source to the NV12 destination before
    // we blend.  Note that this only copies the NV12-format portion of the
    // surface, not the YUY2 converted portion.
    if (bNVSrcIndex != bNVDstIndex) {
        memset(&BltData, 0, sizeof(BltData));
        BltData.lpDD            = (LPDDRAWI_DIRECTDRAW_GBL)pDriverData->dwDDGlobal;
        BltData.dwFlags         = DDBLT_ROP;
        BltData.lpDDSrcSurface  = pSrcSurf_lcl;
        BltData.lpDDDestSurface = pDstSurf_lcl;
        SrcRect.top             = 0;
        SrcRect.left            = 0;
        SrcRect.bottom          = (LONG)dwDstSurfaceWidth;
        SrcRect.right           = (LONG)dwDstSurfaceHeight;
        BltData.rSrc            = SrcRect;
        DstRect.top             = 0;
        DstRect.left            = 0;
        DstRect.bottom          = (LONG)dwDstSurfaceWidth;
        DstRect.right           = (LONG)dwDstSurfaceHeight;
        BltData.rDest           = DstRect;
        BltData.bltFX.dwSize    = sizeof(DDBLTFX);
        BltData.bltFX.dwROP     = SRCCOPY;
        Blit32(&BltData);
    }

    // We need to generate a fresh YUY2 copy from the NV12 source in case
    // a subpicture was blended in already.  We do this into the Mix buffer
    // hidden in the NVSP surface.
    dwLumaOffset = VIDMEM_OFFSET(pSrcSurf_gbl->fpVidMem);
    dwChromaOffset = dwLumaOffset + (pSrcSurf_gbl->lPitch * pSrcSurf_gbl->wHeight);

    X0 = 0;
    X1 = dwDstSurfaceWidth;
    Y0 = 0;
    Y1 = dwDstSurfaceHeight;

    // If Kelvin class...
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

        if (!(nvInitKelvinForMoCompConversion()))
            return DDERR_GENERIC;

        tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
                 (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
                 (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
                 (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
                 (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
                 (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
                 (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_TEXTURE_FILTER(1) | 0x40000);
        nvPushData(1, tmpVal);
        nvPusherAdjust(2);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(1, dwLumaOffset);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(3, dwChromaOffset);
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_NO_OPERATION | 0x40000);
        nvPushData(5, 0);
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(7, dwMixOffset);
        nvPusherAdjust(8);

        SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_INLINE_ARRAY | 0x40300000);
        nvPushData(3, (Y0 << 18) | (X0 << 1));
        nvPushData(4, (Y0 << 16) | (X0 >> 1));
        nvPushData(5, (Y0 << 15) | (X0 >> 1));
        nvPushData(6, ((Y1 << 2) << 16) | (X0 << 1)); // destination is in quarter pel units
        nvPushData(7, (Y1 << 16) | (X0 >> 1));        // LUMA texture is in pel units
        nvPushData(8, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
        nvPushData(9, ((Y1 << 2) << 16) | (X1 << 1)); // each 32 bit write contains data for 2 422 pixels
        nvPushData(10, (Y1 << 16) | (X1 >> 1));
        nvPushData(11, ((Y1 >> 1) << 16) | (X1 >> 1));
        nvPushData(12, (Y0 << 18) | (X1 << 1));
        nvPushData(13, (Y0 << 16) | (X1 >> 1));
        nvPushData(14, (Y0 << 15) | (X1 >> 1));
        nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV097_SET_BEGIN_END_OP_END);
        nvPusherAdjust(17);
        nvPusherStart(TRUE);
    }

    // Else if Celsius class...
    else {

        if (!(nvInitCelsiusForMoCompConversion()))
            return DDERR_GENERIC;

        tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
                 (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_TEXTURE_FILTER(1) | 0x40000);
        nvPushData(1, tmpVal);
        nvPusherAdjust(2);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(1, dwLumaOffset);
        nvPushData(2, dwChromaOffset);
        nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_NO_OPERATION | 0x40000);
        nvPushData(4, 0);
        nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(6, dwMixOffset);
        nvPusherAdjust(7);

        SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

        // No HD scaled version because subpicture compositing is not used for HD 
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_INLINE_ARRAY(0) | 0x300000);
        nvPushData(3, (Y0 << 15) | (X0 >> 1));
        nvPushData(4, (Y0 << 16) | (X0 >> 1));
        nvPushData(5, (Y0 << 18) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));
        nvPushData(6, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
        nvPushData(7, (Y1 << 16) | (X0 >> 1));        // LUMA texture is in pel units
        nvPushData(8, ((Y1 << 2) << 16) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination is in quarter pel units
        nvPushData(9, ((Y1 >> 1) << 16) | (X1 >> 1));
        nvPushData(10, (Y1 << 16) | (X1 >> 1));
        nvPushData(11, ((Y1 << 2) << 16) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // each 32 bit write contains data for 2 422 pixels
        nvPushData(12, (Y0 << 15) | (X1 >> 1));
        nvPushData(13, (Y0 << 16) | (X1 >> 1));
        nvPushData(14, (Y0 << 18) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));
        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);
        nvPusherAdjust(17);
        nvPusherStart(TRUE);
    }

    // If picture scaling is required, we scale the image from the Mix buffer to
    // the Dst buffer.  No subpicture blending is done at this stage.
    if (bScaled) {
        dwScaleX = (nPicSrcW << 20) / nPicDstW;
        if ((dwScaleX < 0x10000) || (dwScaleX > 0x1000000))
            dwScaleX = 0x100000;
        dwScaleY = (nPicSrcH << 20) / nPicDstH;
        if ((dwScaleY < 0x10000) || (dwScaleY > 0x1000000))
            dwScaleY = 0x100000;

        nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
        nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) + NV088_IMAGE_OUT_POINT | 0x400000);
        nvPushData (3, asmMergeCoords(nPicDstX, nPicDstY));
        nvPushData (4, asmMergeCoords(nPicDstW, nPicDstH));
        nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
        nvPushData (7, dwScaleX);
        nvPushData (8, dwScaleY);
        nvPushData (9, asmMergeCoords(dwDstSurfaceWidth, dwDstSurfaceHeight));
        nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (11, dwMixOffset);                                           // 422 source pixel area
        nvPushData (12, ((asmMergeCoords(nPicSrcX, nPicSrcY)) << 4));
        nvPushData (13, 0x100000);
        nvPushData (14, 0x100000);
        nvPushData (15, asmMergeCoords(dwSPSurfaceWidth, dwSPSurfaceHeight));
        nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | (pSPSurf_gbl->lPitch << 2));
        nvPushData (17, dwSPOffset);                                            // AYUV source pixel area
        nvPushData (18, ((asmMergeCoords(nSubSrcX, nSubSrcY)) << 4));
        nvPusherAdjust (19);
        nvPusherStart(TRUE);

        // Further operations should be done in the Dst buffer.
        dwMixOffset = dwDstOffset;
    }

    // Next we use the DVD Subpicture class to blend the subpicture into the Dst buffer.
    if ((nSubSrcW > 0) && (nSubSrcH > 0)) {
        dwScaleX = (nSubSrcW << 20) / nSubDstW;
        if ((dwScaleX < 0x10000) || (dwScaleX > 0x1000000))
            dwScaleX = 0x100000;
        dwScaleY = (nSubSrcH << 20) / nSubDstH;
        if ((dwScaleY < 0x10000) || (dwScaleY > 0x1000000))
            dwScaleY = 0x100000;
        nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
        nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) + NV088_IMAGE_OUT_POINT | 0x400000);
        nvPushData (3, asmMergeCoords(nSubDstX, nSubDstY));
        nvPushData (4, asmMergeCoords(nSubDstW, nSubDstH));
        nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (6, dwMixOffset);                                            // 422 destination pixel area
        nvPushData (7, 0x100000);
        nvPushData (8, 0x100000);
        nvPushData (9, asmMergeCoords(dwDstSurfaceWidth, dwDstSurfaceHeight));
        nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (11, dwMixOffset);                                          // 422 source pixel area
        nvPushData (12, ((asmMergeCoords(nSubDstX, nSubDstY)) << 4));
        nvPushData (13, dwScaleX);
        nvPushData (14, dwScaleY);
        nvPushData (15, asmMergeCoords(dwSPSurfaceWidth, dwSPSurfaceHeight));
        nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSPSurf_gbl->lPitch << 2));
        nvPushData (17, dwSPOffset);                                            // AYUV source pixel area
        nvPushData (18, ((asmMergeCoords(nSubSrcX, nSubSrcY)) << 4));
        nvPusherAdjust (19);
        nvPusherStart(TRUE);
    }

    // If the source buffer and destination buffer are the same (usually only
    // when back-end alpha blending is enabled) we need to copy the blended image
    // to the destination buffer.
    if (bNVSrcIndex == bNVDstIndex) {
        nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
        nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) + NV088_IMAGE_OUT_POINT | 0x400000);
        nvPushData (3, asmMergeCoords(0, 0));
        nvPushData (4, asmMergeCoords(dwDstSurfaceWidth, dwDstSurfaceHeight));
        nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
        nvPushData (7, 0x100000);
        nvPushData (8, 0x100000);
        nvPushData (9, asmMergeCoords(dwDstSurfaceWidth, dwDstSurfaceHeight));
        nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (11, dwMixOffset);                                           // 422 source pixel area
        nvPushData (12, ((asmMergeCoords(0, 0)) << 4));
        nvPushData (13, 0x100000);
        nvPushData (14, 0x100000);
        nvPushData (15, asmMergeCoords(dwSPSurfaceWidth, dwSPSurfaceHeight));
        nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | (pSPSurf_gbl->lPitch << 2));
        nvPushData (17, dwSPOffset);                                            // AYUV source pixel area
        nvPushData (18, ((asmMergeCoords(0, 0)) << 4));
        nvPusherAdjust (19);
    }

    // See if we need to do temporal filtering on the alpha blended image.
    lpDstSurfaceFlags->bMCFrameIsFiltered = FALSE;
    if (pDriverData->bMCTemporalFilterDisabled == FALSE) {
        nvPusherStart(TRUE);
        nvMoCompTemporalFilter(lpDstSurfaceFlags->dwMCSurfaceBase, pDriverData->bMCPercentCurrentField);
    }

    // Update reference count in case we get a status query
    lpDstSurfaceFlags->dwMCCompositeReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

    nvPusherStart(TRUE);
    pDriverData->dDrawSpareSubchannelObject = NV_VPP_DVD_SUBPICTURE_IID;

    // Set some surface flags for the destination surface.
    lpDstSurfaceFlags->bMCFrameIsComposited = PICTURE_STRUCTURE_FRAME;
    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted = 15;
    lpDstSurfaceFlags->bMCPictureStructure  = lpSrcSurfaceFlags->bMCPictureStructure;
    lpDstSurfaceFlags->bMCPictureCodingType = lpSrcSurfaceFlags->bMCPictureCodingType;
    lpDstSurfaceFlags->bMCTopFieldFirst     = lpSrcSurfaceFlags->bMCTopFieldFirst;
    lpDstSurfaceFlags->bMCSecondField       = lpSrcSurfaceFlags->bMCSecondField;
    lpDstSurfaceFlags->bMCFrameType         = lpSrcSurfaceFlags->bMCFrameType;

    return DD_OK;

} /* nvDXVACompositeSubpicture */


/*
 * nvUpdateDXVAIndexTables
 *
 * Recalculates the table pDriverData->bDXVAIndexToNVIndex[8] which is used to convert surface indexes
 * sent by DXVA into our internal NV indexes.  Because the Win/ME DDFlip operation swaps surface
 * pointers, this table may need to be updated if a Flip command came since the last time it was
 * calculated.
 *
 */
 void __stdcall nvUpdateDXVAIndexTable(GLOBALDATA *pDriverData)
 {
    WORD    wDXVAIndex;
    BYTE    bNVIndex;
    DWORD   dwTableVidMem, dwSurfVidMem;

    // Compare the values in the bDXVAIndexToNVIndex and bDXVAIndexToVidMem tables.
    // If they don't match, search through the IndexToVidMem table to see if you can find a match.
    for (wDXVAIndex = 0; wDXVAIndex < 8; wDXVAIndex++) {
        dwTableVidMem = pDriverData->dwDXVAIndexToVidMem[wDXVAIndex];
        if (dwTableVidMem) {
            bNVIndex = pDriverData->bDXVAIndexToNVIndex[wDXVAIndex];
            if (pDriverData->dwMCNV12Surface[bNVIndex]) {
                dwSurfVidMem = ((LPDDRAWI_DDRAWSURFACE_LCL)(pDriverData->dwMCNV12Surface[bNVIndex]))->lpGbl->fpVidMem;
                if (dwTableVidMem != dwSurfVidMem) {
                    for (bNVIndex = 0; bNVIndex < 8; bNVIndex++) {
                        if (pDriverData->dwMCNV12Surface[bNVIndex]) {
                            dwSurfVidMem = ((LPDDRAWI_DDRAWSURFACE_LCL)(pDriverData->dwMCNV12Surface[bNVIndex]))->lpGbl->fpVidMem;
                            if (dwTableVidMem == dwSurfVidMem) {
                                pDriverData->bDXVAIndexToNVIndex[wDXVAIndex] = bNVIndex;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
 }  // nvUpdateDXVAIndexTables


/*
 * nvMoCompFrameStatus
 *
 * This is a variation of getFrameStatusOverlay for motion comp overlay surfaces only.
 * It does additional checking for "previous flip from" surfaces which the other function
 * skips because of WHQL test requirements.
 *
 */
DWORD __stdcall nvMoCompFrameStatus(FLATPTR fpVidMem)
{
    if (getDC()->flipOverlayRecord.bFlipFlag &&
        ((fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) ||
         (fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom))) {

        NvNotification *pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;

        if (fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom) {
            LONGLONG timeNow = 0;
            // only need for one to flush out, no way to really determine this on NV10,
            // but if we wait at least one CRTC refresh since it was issued, we can
            // guarantee it has been flushed through
            if ((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                QueryPerformanceCounter((LARGE_INTEGER *) &timeNow);
                if ((timeNow - getDC()->flipOverlayRecord.llFlipTime) < (getDC()->flipPrimaryRecord.dwFlipDuration * 2)) {
                    return (DDERR_WASSTILLDRAWING);
                }
            }
        } else {
            if (fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) {
                // need to wait for both flips to flush out
                if (((volatile)pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                    ((volatile)pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                    return (DDERR_WASSTILLDRAWING);
                } else {
                    getDC()->flipOverlayRecord.bFlipFlag = FALSE;
                }
            }
        }
        return (DD_OK);
    }
    return (DD_OK);
}  // nvMoCompFrameStatus


/*
 * nvDXVABackEndAlphaBlend
 *
 * This function blends the current subpicture graphic into the selected frame.
 * It can be called from MoComp or Flip functions.
 * Note: pDriverData should be set before this function is called.
 *
 */
DWORD __stdcall nvDXVABackEndAlphaBlend(FLATPTR fpVidMem)
{
    WORD                        wDXVAIndex;
    DXVA_BlendCombination       DXVABlendCombination = {0};
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;

    // Look up index of target surface to blend into.
    for (wDXVAIndex = 0; wDXVAIndex < 8; wDXVAIndex++) {
        if (pDriverData->dwDXVAIndexToVidMem[wDXVAIndex] == (DWORD)fpVidMem)
            break;
    }
    if (wDXVAIndex > 7)
        wDXVAIndex = 0;

    // Get pointer to NVMC surface used to store parameters.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Set up DXVA_BlendCombination structure with subpicture parameters.
    DXVABlendCombination.wPictureSourceIndex = wDXVAIndex;
    DXVABlendCombination.wBlendedDestinationIndex = wDXVAIndex;
    DXVABlendCombination.PictureSourceRect16thPel.left   = 0;
    DXVABlendCombination.PictureSourceRect16thPel.top    = 0;
    DXVABlendCombination.PictureSourceRect16thPel.right  = lpNvMCFrameData->wDXVAPicWidthInMB * 16 * 16;
    DXVABlendCombination.PictureSourceRect16thPel.bottom = lpNvMCFrameData->wDXVAPicHeightInMB * 16 * 16;
    DXVABlendCombination.PictureDestinationRect.left   = 0;
    DXVABlendCombination.PictureDestinationRect.top    = 0;
    DXVABlendCombination.PictureDestinationRect.right  = lpNvMCFrameData->wDXVAPicWidthInMB * 16;
    DXVABlendCombination.PictureDestinationRect.bottom = lpNvMCFrameData->wDXVAPicHeightInMB * 16;
    DXVABlendCombination.GraphicSourceRect      = lpNvMCFrameData->rcGraphicSourceRect;
    DXVABlendCombination.GraphicDestinationRect = lpNvMCFrameData->rcGraphicDestinationRect;

    nvMoCompExecute(lpNvMCFrameData->dwMCMultiMonID,
                    EXECUTE_DXVA_ALPHA_BLENDING,
                    (LPVOID)&DXVABlendCombination,
                    sizeof(DXVA_BlendCombination),
                    0);

    return DD_OK;
}


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\MoCompExKelvin.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoCompExKelvin.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "dxshare.h"

extern NVMOCOMPPARAMS           nvMoCompParams;

#ifndef WINNT
    extern DISPDRVDIRECTXCOMMON    *pDXShare;
#endif // WINNT

extern BOOL __fastcall nvMoCompCheckFieldPredictionEqual(LPNVDECODEMACROBLOCK pMacroblock0,
                                                         LPNVDECODEMACROBLOCK pMacroblock1, BYTE macroblockType);

extern DWORD __stdcall nvInitKelvinForMoComp(void);
extern DWORD __stdcall nvInitKelvinForMoCompPrediction(void);
extern DWORD __stdcall nvInitKelvinForMoCompCorrection();
extern void __stdcall nvDoKelvinBidirectionalDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoKelvinBidirectionalDVDFieldPredictions(BOOL);
extern void __stdcall nvDoKelvinForwardDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoKelvinForwardDVDFieldPredictions(BOOL);
extern void __stdcall nvDoKelvinBackwardDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoKelvinBackwardDVDFieldPredictions(BOOL);
extern void __stdcall nvDoAllKelvinIntraDVDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoAllKelvinDVDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoKelvinIntraDVDFieldCorrection(void);
extern void __stdcall nvDoOptimizedKelvinIntraDVDFieldCorrection(void);
extern void __stdcall nvDoKelvinDVDFieldCorrection(void);
extern void __stdcall nvDoAllKelvinIntraFrameCorrections(void);
extern void __stdcall nvDoAllKelvinFrameCorrections(void);
extern void __stdcall nvDoKelvinIntraFrameCorrection(void);
extern void __stdcall nvDoKelvinFrameCorrection(void);
extern DWORD __stdcall nvPredictKelvinFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictKelvinFieldLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictKelvinFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictKelvinFieldChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern void __stdcall nvCorrectKelvinIntraFrame(LPNVDECODEMACROBLOCK pMacroblock, long macroblockCount);
extern void __stdcall nvCorrectKelvinFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectKelvinFullFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectKelvinFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectKelvinFullFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectKelvinIntraField(LPNVDECODEMACROBLOCK pMacroblock, long macroblockCount);
extern void __stdcall nvCorrectKelvinFieldMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);

extern PNVMCPREDFUNC nvDoBidirectionalFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBidirectionalFieldPredictions;
extern PNVMCPREDFUNC nvDoForwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoForwardFieldPredictions;
extern PNVMCPREDFUNC nvDoBackwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBackwardFieldPredictions;

extern PNVMCPREDFUNC2 nvPredictFrameLumaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFieldLumaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFrameChromaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFieldChromaMacroblock;

extern PNVMCCORRFUNC2 nvDoAllIntraFieldCorrections;
extern PNVMCCORRFUNC2 nvDoAllFieldCorrections;
extern PNVMCCORRFUNC nvDoAllIntraFrameCorrections;
extern PNVMCCORRFUNC nvDoAllFrameCorrections;
extern PNVMCCORRFUNC nvDoIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoOptimizedIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoFieldCorrection;
extern PNVMCCORRFUNC nvDoIntraFrameCorrection;
extern PNVMCCORRFUNC nvDoFrameCorrection;


/*
 * nvMoCompProcessKelvinFrameMacroblocks
 *
 * Parses the current macroblock command stream and performs the necessary operations on
 * each macroblock.
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvMoCompProcessKelvinFrameMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                      DWORD numMacroblocks, BYTE formatConversionStatus)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVDECODEMACROBLOCK        pMacroblock;
    LPNVDECODEMACROBLOCK        pLastMacroblock;
    LPNVDECODEMACROBLOCK        pMacroblock1;
    unsigned long               dwFirstAlignedIDCTOffset;
    unsigned long               dwSurfaceOffset;
    unsigned long               surfacePitch;
    unsigned long               moCompCorrectionICW;
    unsigned long               moCompNonPrebiasedCorrectionICW;
    long                        macroblockLimit;
    long                        n;
    long                        macroblockIndex;
    BYTE                        surfaceDecodeStatus = 0;
    BYTE                        numCombinedMacroblocks[256];
    short                       maxHeight = (short)dst->wHeight - 16;
    short                       maxWidth = (short)dst->wWidth - 16;
    BOOL                        hasFieldPredictions = FALSE;
    int                         index, i;
    int                         firstAlignedIDCTIndex;

    nvMoCompParams.vertexMode = 0; // Initialize vertexMode to an invalid value
    nvMoCompParams.surfaceLumaPitch = dst->lPitch;
    nvMoCompParams.surfaceLumaHeight = (dst->wHeight + 1) & ~1;
    nvMoCompParams.surfaceOffset = VIDMEM_OFFSET(dst->fpVidMem);
    nvMoCompParams.surfaceChromaOffset = nvMoCompParams.surfaceLumaPitch * nvMoCompParams.surfaceLumaHeight;
    nvMoCompParams.surfaceBiasedIntraBlockOffset =
        (dst->lPitch * dst->wHeight) + (dst->lPitch * (dst->wHeight >> 1) + (8 * dst->lPitch));

    if (pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) {

        if (!(nvInitKelvinForMoCompPrediction()))
            return FALSE;

        nvDoBidirectionalFieldPrediction = nvDoKelvinBidirectionalDVDFieldPrediction;
        nvDoTwoBidirectionalFieldPredictions = nvDoTwoKelvinBidirectionalDVDFieldPredictions;
        nvDoForwardFieldPrediction = nvDoKelvinForwardDVDFieldPrediction;
        nvDoTwoForwardFieldPredictions = nvDoTwoKelvinForwardDVDFieldPredictions;
        nvDoBackwardFieldPrediction = nvDoKelvinBackwardDVDFieldPrediction;
        nvDoTwoBackwardFieldPredictions = nvDoTwoKelvinBackwardDVDFieldPredictions;

        nvPredictFrameLumaMacroblock = nvPredictKelvinFrameLumaMacroblock;
        nvPredictFrameChromaMacroblock = nvPredictKelvinFrameChromaMacroblock;
        nvPredictFieldLumaMacroblock = nvPredictKelvinFieldLumaMacroblock;
        nvPredictFieldChromaMacroblock = nvPredictKelvinFieldChromaMacroblock;

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        surfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        // Must temporarily set destination surface pitch back to it's normal frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_PITCH | 0x40000);
        nvPushData(3, surfacePitch);

        // Must also change texture pitches back to normal frame pitch so that quarter pel addressing works correctly
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
        nvPushData(5, surfacePitch << 16);
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(7, surfacePitch << 16);

        nvPusherAdjust(8);

        // Perform luma prediction pass
        while (n > 0) {
            numCombinedMacroblocks[macroblockIndex] = 1;
            if (pMacroblock->macroblockType == MB_MOTION_FORWARD) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;	//no more macroblock left
							pMacroblock1++;	

						}
					} else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;							
						}
                    }
                }

                if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                    nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                else
                    hasFieldPredictions = TRUE;

                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == MB_MOTION_BACKWARD) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) {
                    	//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
                    } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) {
  						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}
                    }
                }

                if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                    nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                else
                    hasFieldPredictions = TRUE;

                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0]) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}                        
                    } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) {
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}
                    }
                }

                if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                    nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                else
                    hasFieldPredictions = TRUE;

                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else {
                if (pMacroblock->macroblockType != MB_INTRA) {

                    if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                        nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                    else
                        hasFieldPredictions = TRUE;

                }
                pMacroblock++;
                n--;
            }
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

#ifdef  DEBUG
        if (moCompDebugLevel < 3) {
#endif  // DEBUG

        // Change surface offsets to chroma portion of surface
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPusherAdjust(8);

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        // Perform chroma prediction pass
        while (n > 0) {
            if (pMacroblock->macroblockType != MB_INTRA) {

                if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                    nvPredictFrameChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

            }
            pMacroblock += numCombinedMacroblocks[macroblockIndex];
            n -= numCombinedMacroblocks[macroblockIndex];
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

#ifdef  DEBUG
        }
#endif  // DEBUG

        // Now do non-frame structured predictions if any are necessary
        if (hasFieldPredictions) {

            // Restore offsets and pitches to field based pitches
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset);

            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(5, pDriverData->dwMCForwardSurfaceOffset);

            nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset);

            nvPusherAdjust(8);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_PITCH | 0x40000);
            nvPushData(1, (surfacePitch << 1));

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
            nvPushData(3, surfacePitch << 17);
            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(5, surfacePitch << 17);

            nvPusherAdjust(6);

            pMacroblock = pMacroblocks;
            n = numMacroblocks;
            macroblockIndex = 0;

            nvMoCompParams.currentForwardField = 0;
            nvMoCompParams.currentBackwardField = 0;
            nvMoCompParams.currentDestinationField = 0;
            nvMoCompParams.destinationFieldIs0 = TRUE; // First process all destination field 0 updates

            // Perform luma prediction pass
            while (n > 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {

                    if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                        nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                }
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
                macroblockIndex++;
            }

            nvPusherStart(TRUE);

            // Change surface offsets to chroma portion of surface
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPusherAdjust(8);

            pMacroblock = pMacroblocks;
            n = numMacroblocks;
            macroblockIndex = 0;

            nvMoCompParams.currentForwardField = 0;
            nvMoCompParams.currentBackwardField = 0;
            nvMoCompParams.currentDestinationField = 0;
            nvMoCompParams.destinationFieldIs0 = TRUE; // First process all destination field 0 updates

            // Perform chroma prediction pass
            while (n > 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {

                    if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                        nvPredictFrameChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                }
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
                macroblockIndex++;
            }

            nvPusherStart(TRUE);
        }
    }

    if (!(nvInitKelvinForMoCompCorrection()))
        return FALSE;

    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    nvDoAllIntraFieldCorrections = nvDoAllKelvinIntraDVDFieldCorrections;
    nvDoAllFieldCorrections = nvDoAllKelvinDVDFieldCorrections;
    nvDoIntraFieldCorrection = nvDoKelvinIntraDVDFieldCorrection;
    nvDoOptimizedIntraFieldCorrection = nvDoOptimizedKelvinIntraDVDFieldCorrection;
    nvDoFieldCorrection = nvDoKelvinDVDFieldCorrection;

    nvDoAllIntraFrameCorrections = nvDoAllKelvinIntraFrameCorrections;
    nvDoAllFrameCorrections = nvDoAllKelvinFrameCorrections;
    nvDoIntraFrameCorrection = nvDoKelvinIntraFrameCorrection;
    nvDoFrameCorrection = nvDoKelvinFrameCorrection;

    // Default motion comp correction ICW
    moCompCorrectionICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                          (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                          (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                          (NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                          (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                          (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                          (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                          (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                          (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                          (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                          (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                           NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Non-prebiased motion comp correction ICW
    moCompNonPrebiasedCorrectionICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                                      (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                                      (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                                      (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                                      (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                                      (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                                      (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                                      (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                                      (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                                      (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                                      (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                                       NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;

    nvMoCompParams.currentDestinationField = 0;
    nvMoCompParams.destinationField = 0;

    pMacroblock = pMacroblocks;
    n = numMacroblocks;

    // This assumes that the first IDCT index of the first macroblock in the command stream is the
    // lowest index in the entire command stream for this call.

    dwSurfaceOffset = pDriverData->dwMCDestinationSurfaceOffset;

    macroblockIndex = 0;
    index = 0;

    while (n > 0) {

        macroblockLimit = n;

        if (macroblockLimit > 32)
            macroblockLimit = 32;

        pDriverData->dwMCFirstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

        // Attempt to sanity check index
        if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
            pDriverData->dwMCFirstAlignedIDCTIndex = 0;

        dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

        // Force both texture caches to flush
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(5, dwFirstAlignedIDCTOffset);
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(7, dwSurfaceOffset);

        nvPusherAdjust(8);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform non-prebiased intrablock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompNonPrebiasedCorrectionICW);

            nvPusherAdjust(2);

            SET_KELVIN_UNBIASED_CORRECTION_DATA_FORMAT();
        } else {
            SET_KELVIN_CORRECTION_DATA_FORMAT();
        }   

        if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_I) &&
            (pMacroblock->codedBlockPattern == 0xFF)) {
            nvCorrectKelvinIntraFrame(pMacroblock, macroblockLimit);
            pMacroblock += macroblockLimit;
            n -= macroblockLimit;
        } else {
            long saveMacroblockLimit = macroblockLimit;
            long fieldTypeCount = 0;
            BOOL hasPartialCorrections = FALSE;

            pMacroblock1 = pMacroblock;

            nvMoCompParams.destinationFieldIs0 = TRUE;

            // Change texture1 surface offset to point to block of half bias values (0x80)
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

            // Change texture0 pitch to 16 bytes
            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
            nvPushData(3, 16 << 16);
            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(5, 16 << 16); // half bias Intra block pitch

            nvPusherAdjust(6);

            // Perform first correction pass
            while (--macroblockLimit >= 0) {
                if ((pMacroblock->overflowCodedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                    numCombinedMacroblocks[macroblockIndex++] = (BYTE) index;
                index++;
                if ((pMacroblock->DCTType != DCT_FIELD) && (pMacroblock->macroblockType == MB_INTRA)) {
                    if (pMacroblock->codedBlockPattern >= 0xFC) {
                        nvCorrectKelvinFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        // Change texture0 pitch to it's default value of 8 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 8 << 16);

                        nvPusherAdjust(2);

                        nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                        // Change texture0 pitch to 16 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 16 << 16);

                        nvPusherAdjust(2);

                    }
                } else
                    fieldTypeCount++;

                pMacroblock++;
                --n;
            }

            nvPusherStart(TRUE);

            if (pDriverData->bMCCurrentExecuteFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                SET_KELVIN_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT();
            } else {
                SET_KELVIN_CHROMA_CORRECTION_DATA_FORMAT();
            }   

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if (pMacroblock->macroblockType == MB_INTRA) {
                    if (pMacroblock->codedBlockPattern == 0xFF) {
                        nvCorrectKelvinFullFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        nvCorrectKelvinFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    }
                }
                pMacroblock++;
            }

            nvPusherStart(TRUE);

            // Force both texture caches to flush
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(3, dwSurfaceOffset);

            nvPusherAdjust(4);

            // Change texture0 pitch to 16 bytes
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
            nvPushData(1, 16 << 16);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceLumaPitch << 16);

            nvPusherAdjust(4);

            nvMoCompParams.destinationFieldIs0 = TRUE;

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            if (pDriverData->bMCCurrentExecuteFunction ==
                EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                // Modify combiners to perform interblock correction
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                nvPushData(1, moCompCorrectionICW);

                nvPusherAdjust(2);

            }    

            SET_KELVIN_CORRECTION_DATA_FORMAT();

            // Perform first correction pass
            while (--macroblockLimit >= 0) {
                if ((pMacroblock->DCTType != DCT_FIELD) && (pMacroblock->macroblockType != MB_INTRA)) {
                    if (pMacroblock->codedBlockPattern >= 0xFC) {
                        nvCorrectKelvinFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        // Change texture0 pitch to it's default value of 8 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 8 << 16);

                        nvPusherAdjust(2);

                        nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                        // Change texture0 pitch to 16 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 16 << 16);

                        nvPusherAdjust(2);

                    }
                }
                pMacroblock++;
            }

            nvPusherStart(TRUE);

            SET_KELVIN_CHROMA_CORRECTION_DATA_FORMAT();

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {
                    if (pMacroblock->codedBlockPattern == 0xFF) {
                        nvCorrectKelvinFullFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        nvCorrectKelvinFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    }
                }
                pMacroblock++;
            }

            if (fieldTypeCount > 0) {

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                // Change destination pitch to field pitch
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 17) | (nvMoCompParams.surfaceLumaPitch << 1)));

                // Change texture1 surface offset to point to block of half bias values (0x80)
                nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(5, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

                // Change texture0 pitch to 16 bytes
                nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(7, 16 << 16);
                nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(9, 16 << 16); // half bias Intra block pitch

                nvPusherAdjust(10);

                if (pDriverData->bMCCurrentExecuteFunction ==
                    EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                    // Modify combiners to perform non-prebiased intrablock correction
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                    nvPushData(1, moCompNonPrebiasedCorrectionICW);

                    nvPusherAdjust(2);

                    SET_KELVIN_UNBIASED_CORRECTION_DATA_FORMAT();
                } else {
                    SET_KELVIN_CORRECTION_DATA_FORMAT();
                }    

                pMacroblock = pMacroblock1;
                macroblockLimit = saveMacroblockLimit;

                while (--macroblockLimit >= 0) {
                    if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType == MB_INTRA)) {
                        if (pMacroblock->codedBlockPattern >= 0xFC) {
                            nvCorrectKelvinFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                        } else if (pMacroblock->codedBlockPattern != 0) {
                            // Change texture0 pitch to it's default value of 8 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 8 << 16);

                            nvPusherAdjust(2);

                            hasPartialCorrections = TRUE;

                            nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                            // Change texture0 pitch to 16 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 16 << 16);

                            nvPusherAdjust(2);
                        }
                    }
                    pMacroblock++;
                }

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(3, dwFirstAlignedIDCTOffset);
                nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(5, dwSurfaceOffset);

                nvPusherAdjust(6);

                // Change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(3, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(4);

                if (pDriverData->bMCCurrentExecuteFunction ==
                    EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                    // Modify combiners to perform interblock correction
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                    nvPushData(1, moCompCorrectionICW);

                    nvPusherAdjust(2);
                }    

                SET_KELVIN_CORRECTION_DATA_FORMAT();

                nvMoCompParams.destinationFieldIs0 = TRUE;

                pMacroblock = pMacroblock1;
                macroblockLimit = saveMacroblockLimit;

                while (--macroblockLimit >= 0) {
                    if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType != MB_INTRA)) {
                        if (pMacroblock->codedBlockPattern >= 0xFC) {
                            nvCorrectKelvinFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                        } else if (pMacroblock->codedBlockPattern != 0) {
                            // Change texture0 pitch to it's default value of 8 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 8 << 16);

                            nvPusherAdjust(2);

                            hasPartialCorrections = TRUE;

                            nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                            // Change texture0 pitch to 16 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 16 << 16);

                            nvPusherAdjust(2);
                        }
                    }
                    pMacroblock++;
                }

                // Restore surface pitch
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_SURFACE_PITCH | 0x40000);
                nvPushData(1, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

                nvPusherAdjust(2);
            }
        }
        nvPusherStart(TRUE);
    }

    pLastMacroblock = pMacroblock - 1;

    if ((pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) && (macroblockIndex > 0)) {
        long saveN = macroblockIndex;

        n = macroblockIndex;
        macroblockIndex = 0;
        pMacroblock1 = pMacroblocks;
        index = -32;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        // DO NOT REMOVE: This is necessary to work around an NV10 texture cache bug
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPusherAdjust(4);

        nvMoCompParams.currentDestinationField = 0;
        nvMoCompParams.destinationField = 0;

        // Change destination pitch back to frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(3, nvMoCompParams.surfaceOffset);

        // Change texture0 pitch to 16 bytes
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
        nvPushData(5, 16 << 16);
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(7, nvMoCompParams.surfaceLumaPitch << 16);

        nvPusherAdjust(8);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform interblock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompCorrectionICW);

            nvPusherAdjust(2);
        }    

        SET_KELVIN_CHROMA_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            pMacroblock = &pMacroblock1[numCombinedMacroblocks[macroblockIndex]];

            firstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 32) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(3, dwSurfaceOffset);

                nvPusherAdjust(4);

                nvMoCompParams.currentDestinationField = 0;
                nvMoCompParams.destinationField = 0;
            }

            // Perform chroma overflow correction pass
            nvCorrectKelvinFrameChromaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        n = saveN;
        macroblockIndex = 0;
        index = -32;

        // Change texture0 pitch to it's default value of 8 bytes
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
        nvPushData(1, 8 << 16);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(3, nvMoCompParams.surfaceLumaPitch << 16);

        nvPusherAdjust(4);

        SET_KELVIN_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            pMacroblock = &pMacroblock1[numCombinedMacroblocks[macroblockIndex]];

            firstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 32) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(3, dwSurfaceOffset);

                nvPusherAdjust(4);

                nvMoCompParams.currentDestinationField = 0;
                nvMoCompParams.destinationField = 0;
            }


            // Perform luma overflow correction pass
            if (pMacroblock->DCTType == DCT_FIELD) {

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 17) | (nvMoCompParams.surfaceLumaPitch << 1)));

                // Change texture0 pitch to default value of 8 bytes
                nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(5, 8 << 16);
                nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(7, nvMoCompParams.surfaceLumaPitch << 17);

                nvPusherAdjust(8);

                nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                // Restore surface pitch
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

                // Change texture0 pitch to default value of 8 bytes
                nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(5, 8 << 16);
                nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(7, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(8);

            } else
                nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);
    }

    if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
        surfaceDecodeStatus = 15;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight - (nvMoCompParams.surfaceLumaHeight >> 2)))
        surfaceDecodeStatus = 7;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 1))
        surfaceDecodeStatus = 3;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
        surfaceDecodeStatus = 1;

    if (surfaceDecodeStatus > formatConversionStatus) {
        LPNVMCSURFACEFLAGS lpSurfaceFlags;

        nvMoCompConvertSurfaceFormat(dst->fpVidMem, TRUE, (DWORD)surfaceDecodeStatus);

        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != dst->fpVidMem))
            lpSurfaceFlags++;

            if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                (pDriverData->bMCTemporalFilterDisabled == FALSE))
                nvMoCompTemporalFilter(dst->fpVidMem, pDriverData->bMCPercentCurrentField);
    }

    return TRUE;

} /* nvMoCompProcessKelvinFrameMacroblocks */


/*
 * nvMoCompProcessKelvinFieldMacroblocks
 *
 * Parses the current macroblock command stream and performs the necessary operations on
 * each macroblock.
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvMoCompProcessKelvinFieldMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                      DWORD numMacroblocks, BYTE formatConversionStatus)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVDECODEMACROBLOCK        pMacroblock;
    LPNVDECODEMACROBLOCK        pLastMacroblock;
    LPNVDECODEMACROBLOCK        pMacroblock1;
    unsigned long               dwFirstAlignedIDCTOffset;
    unsigned long               dwSurfaceOffset;
    unsigned long               moCompCorrectionICW;
    unsigned long               moCompNonPrebiasedCorrectionICW;
    long                        macroblockLimit;
    long                        n;
    long                        macroblockIndex;
    BYTE                        surfaceDecodeStatus = 0;
    BYTE                        numCombinedMacroblocks[256];
    short                       maxHeight = (short)(dst->wHeight >> 1) - 16;
    short                       maxWidth = (short)dst->wWidth - 16;
    int                         index,i;
    int                         firstAlignedIDCTIndex;

    nvMoCompParams.vertexMode = 0; // Initialize vertexMode to an invalid value
    nvMoCompParams.surfaceLumaPitch = dst->lPitch;
    nvMoCompParams.surfaceLumaHeight = (dst->wHeight + 1) & ~1;
    nvMoCompParams.surfaceOffset = VIDMEM_OFFSET(dst->fpVidMem);
    nvMoCompParams.surfaceChromaOffset = nvMoCompParams.surfaceLumaPitch * nvMoCompParams.surfaceLumaHeight;
    nvMoCompParams.surfaceBiasedIntraBlockOffset =
        (dst->lPitch * dst->wHeight) + (dst->lPitch * (dst->wHeight >> 1) + (8 * dst->lPitch));

    if (pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) {

        if (!(nvInitKelvinForMoCompPrediction()))
            return FALSE;

        nvDoBidirectionalFieldPrediction = nvDoKelvinBidirectionalDVDFieldPrediction;
        nvDoTwoBidirectionalFieldPredictions = nvDoTwoKelvinBidirectionalDVDFieldPredictions;
        nvDoForwardFieldPrediction = nvDoKelvinForwardDVDFieldPrediction;
        nvDoTwoForwardFieldPredictions = nvDoTwoKelvinForwardDVDFieldPredictions;
        nvDoBackwardFieldPrediction = nvDoKelvinBackwardDVDFieldPrediction;
        nvDoTwoBackwardFieldPredictions = nvDoTwoKelvinBackwardDVDFieldPredictions;

        nvPredictFrameLumaMacroblock = nvPredictKelvinFrameLumaMacroblock;
        nvPredictFrameChromaMacroblock = nvPredictKelvinFrameChromaMacroblock;
        nvPredictFieldLumaMacroblock = nvPredictKelvinFieldLumaMacroblock;
        nvPredictFieldChromaMacroblock = nvPredictKelvinFieldChromaMacroblock;

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceLumaPitch);

            nvPusherAdjust(4);

            nvMoCompParams.currentDestinationField = 1;
        }

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        // Perform luma prediction pass
        while (n > 0) {
            numCombinedMacroblocks[macroblockIndex] = 1;
            if (pMacroblock->macroblockType == MB_MOTION_FORWARD) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
                                ((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
                                (pMacroblock->fieldSelect[0][0] == pMacroblock1->fieldSelect[0][0]) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;		//no more macroblock left
							pMacroblock1++;
                        }
					}else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
                }
                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == MB_MOTION_BACKWARD) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(pMacroblock->fieldSelect[0][1] == pMacroblock1->fieldSelect[0][1]) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
                            
					} else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
                    }
                }
                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
                            
                    } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
                    }
                }
                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else {
                if (pMacroblock->macroblockType != MB_INTRA)
                    nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock++;
                n--;
            }
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

#ifdef  DEBUG
        if (moCompDebugLevel < 3) {
#endif  // DEBUG

        // Change surface offsets to chroma portion of surface
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);

        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {
            nvMoCompParams.currentDestinationField = 1;
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset + nvMoCompParams.surfaceLumaPitch);
        } else {
            nvMoCompParams.currentDestinationField = 0;
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);
        }

        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPusherAdjust(8);

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;

        // Perform chroma prediction pass
        while (n > 0) {
            if (pMacroblock->macroblockType != MB_INTRA)
                nvPredictFieldChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
            pMacroblock += numCombinedMacroblocks[macroblockIndex];
            n -= numCombinedMacroblocks[macroblockIndex];
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

#ifdef  DEBUG
        }
#endif  // DEBUG
    }

    if (!(nvInitKelvinForMoCompCorrection()))
        return FALSE;

    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    nvDoAllIntraFieldCorrections = nvDoAllKelvinIntraDVDFieldCorrections;
    nvDoAllFieldCorrections = nvDoAllKelvinDVDFieldCorrections;
    nvDoIntraFieldCorrection = nvDoKelvinIntraDVDFieldCorrection;
    nvDoOptimizedIntraFieldCorrection = nvDoOptimizedKelvinIntraDVDFieldCorrection;
    nvDoFieldCorrection = nvDoKelvinDVDFieldCorrection;

    nvDoAllIntraFrameCorrections = nvDoAllKelvinIntraFrameCorrections;
    nvDoAllFrameCorrections = nvDoAllKelvinFrameCorrections;
    nvDoIntraFrameCorrection = nvDoKelvinIntraFrameCorrection;
    nvDoFrameCorrection = nvDoKelvinFrameCorrection;

    // Default motion comp correction ICW
    moCompCorrectionICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                          (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                          (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                          (NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                          (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                          (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                          (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                          (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                          (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                          (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                          (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                           NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Non-prebiased motion comp correction ICW
    moCompNonPrebiasedCorrectionICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                                      (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                                      (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                                      (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                                      (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                                      (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                                      (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                                      (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                                      (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                                      (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                                      (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                                       NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;

    nvMoCompParams.currentDestinationField = 0;

    pMacroblock = pMacroblocks;
    n = numMacroblocks;

    // This assumes that the first IDCT index of the first macroblock in the command stream is the
    // lowest index in the entire command stream for this call.

    dwSurfaceOffset = pDriverData->dwMCDestinationSurfaceOffset;

    macroblockIndex = 0;

    index = 0;

    while (n > 0) {

        macroblockLimit = n;

        if (macroblockLimit > 32)
            macroblockLimit = 32;

        pDriverData->dwMCFirstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

        dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

        // Force both texture caches to flush
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(1, dwFirstAlignedIDCTOffset);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPusherAdjust(4);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform non-prebiased intrablock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompNonPrebiasedCorrectionICW);

            nvPusherAdjust(2);

            SET_KELVIN_UNBIASED_CORRECTION_DATA_FORMAT();
        } else {
            SET_KELVIN_CORRECTION_DATA_FORMAT();
        }    

        // Perform first correction pass
        if (pDriverData->bMCPictureCodingType == PICTURE_TYPE_I) {
            nvCorrectKelvinIntraField(pMacroblock, macroblockLimit);
            pMacroblock += macroblockLimit;
            n -= macroblockLimit;
        } else {
            long saveMacroblockLimit = macroblockLimit;

            pMacroblock1 = pMacroblock;

            // Change texture1 surface offset to point to block of half bias values (0x80)
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

            // Change texture0 pitch to 16 bytes
            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
            nvPushData(3, 16 << 16);
            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(5, 16 << 16); // half bias Intra block pitch

            nvPusherAdjust(6);

            while (--macroblockLimit >= 0) {
                if ((pMacroblock->overflowCodedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                    numCombinedMacroblocks[macroblockIndex++] = (BYTE) index;
                index++;
                if ((pMacroblock->codedBlockPattern != 0) && (pMacroblock->macroblockType == MB_INTRA))
                     nvCorrectKelvinFieldMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                pMacroblock++;
                --n;
            }

            nvPusherStart(TRUE);

            // Force both texture caches to flush
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(3, dwFirstAlignedIDCTOffset);
            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(5, dwSurfaceOffset);

            nvPusherAdjust(6);

            // Change texture0 pitch to 16 bytes
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
            nvPushData(1, 16 << 16);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceLumaPitch << 17);

            nvPusherAdjust(4);

            if (pDriverData->bMCCurrentExecuteFunction ==
                EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                // Modify combiners to perform interblock correction
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                nvPushData(1, moCompCorrectionICW);

                nvPusherAdjust(2);
            }    

            SET_KELVIN_CORRECTION_DATA_FORMAT();

            nvMoCompParams.currentDestinationField = 0;

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if ((pMacroblock->codedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                     nvCorrectKelvinFieldMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                pMacroblock++;
            }
        }

        nvPusherStart(TRUE);
    }

    pLastMacroblock = pMacroblock - 1;

    if ((pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) && (macroblockIndex > 0)) {

        pMacroblock = pMacroblocks;
        n = macroblockIndex;
        macroblockIndex = 0;
        index = -32;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        // DO NOT REMOVE: This is necessary to work around an NV10 texture cache bug
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPusherAdjust(4);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform interblock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompCorrectionICW);

            nvPusherAdjust(2);
        }    

        SET_KELVIN_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            firstAlignedIDCTIndex = (&pMacroblock[numCombinedMacroblocks[macroblockIndex]])->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 32) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(3, dwSurfaceOffset);

                nvPusherAdjust(4);

                nvMoCompParams.currentDestinationField = 0;
            }

            // Perform overflow correction pass
            nvCorrectKelvinFieldMacroblock((&pMacroblock[numCombinedMacroblocks[macroblockIndex]]), CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);
    }

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) {
        if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
            surfaceDecodeStatus = 3;
        else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
            surfaceDecodeStatus = 1;
    } else {
        if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
            surfaceDecodeStatus = 12;
        else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
            surfaceDecodeStatus = 4;
    }

    if (surfaceDecodeStatus > formatConversionStatus) {
        LPNVMCSURFACEFLAGS lpSurfaceFlags;

        nvMoCompConvertSurfaceFormat(dst->fpVidMem, TRUE, (DWORD)surfaceDecodeStatus);

        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != dst->fpVidMem))
            lpSurfaceFlags++;

            if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                (pDriverData->bMCTemporalFilterDisabled == FALSE))
                nvMoCompTemporalFilter(dst->fpVidMem, pDriverData->bMCPercentCurrentField);
    }

    return TRUE;

} /* nvMoCompProcessKelvinFieldMacroblocks */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\MoInit.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 1999 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoInit.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

NVMOCOMPPARAMS nvMoCompParams;

/*
 * nvInitCelsiusForMoComp
 *
 * Performs basic motion comp initialization of the celcius class object
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoComp(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst;
    unsigned long               surfaceWidth;
    unsigned long               surfaceHeight;
    unsigned long               surfacePitch;
    unsigned long               tmpVal;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    float                       xTrans, yTrans, zTrans;

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(NULL)) {
            return FALSE;
        }
    }

	if(dstx == NULL)		//It happnes for WinDVD
		return FALSE;

    dst = dstx->lpGbl;
    surfaceWidth = dst->wWidth;
    surfaceHeight = dst->wHeight;
    surfacePitch = dst->lPitch;

    pDriverData->dwMostRecentHWUser = MODULE_ID_DDRAW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Clear current IDCT context Dma
    pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;

    // Reset current vertex mode
    nvMoCompParams.vertexMode = 0;

    // Reset current data format
    nvMoCompParams.dataFormat = 0;

    // Reset the celsius context Dmas to use the default video context Dma
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTEXT_DMA_A | 0x40000);
    nvPushData(1, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTEXT_DMA_B | 0x40000);
    nvPushData(3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTEXT_DMA_VERTEX | 0x40000);
    nvPushData(5, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTEXT_DMA_STATE | 0x40000);
    nvPushData(7, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTEXT_DMA_COLOR | 0x40000);
    nvPushData(9, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_CONTEXT_DMA_ZETA | 0x40000);
    nvPushData(11, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPusherAdjust(12);

    // Set up one window clip rectangle to be the rendered area
    // All the other rectangles are deactivated
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_WINDOW_CLIP_HORIZONTAL(0) | 0x200000);
    nvPushData(1, ((2047 << 16) | (-2048 & 0xfff)));
    nvPushData(2, 0);
    nvPushData(3, 0);
    nvPushData(4, 0);
    nvPushData(5, 0);
    nvPushData(6, 0);
    nvPushData(7, 0);
    nvPushData(8, 0);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_WINDOW_CLIP_VERTICAL(0) | 0x200000);
    nvPushData(10, ((2047 << 16) | (-2048 & 0xfff)));
    nvPushData(11, 0);
    nvPushData(12, 0);
    nvPushData(13, 0);
    nvPushData(14, 0);
    nvPushData(15, 0);
    nvPushData(16, 0);
    nvPushData(17, 0);

    nvPushData(18, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_WINDOW_CLIP_TYPE | 0x40000);
    nvPushData(19, NV056_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);

    nvPushData(20, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    // pitch << 1
    nvPushData(21, ((surfacePitch << 17) | 0));

    nvPushData(22, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    // height << 1 which is at least enough for luma height + chroma height
    nvPushData(23, ((surfaceHeight << 17) | 0));

    nvPusherAdjust(24);

    // Enable transforms
    tmpVal = (NV056_SET_TLMODE_W_DIVIDE_1_ENABLE << 2) |
             (NV056_SET_TLMODE_W_DIVIDE_0_ENABLE << 1) |
              NV056_SET_TLMODE_PASSTHROUGH_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TLMODE | 0x40000);
    nvPushData(1, tmpVal);

    nvPusherAdjust(2);

    // Set Control0 defaults
    tmpVal = (NV056_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE << 24) |
             (NV056_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE << 20) |
             (NV056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE << 16) |
             (NV056_SET_CONTROL0_Z_FORMAT_FIXED << 12) |
             (NV056_SET_CONTROL0_WBUFFER_SELECT_0 << 8) |
             (NV056_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTROL0 | 0x40000);
    nvPushData(1, tmpVal);

    nvPusherAdjust(2);

    // Load ModelView matrix and inverse ModelView matrix with identity
    fBuffer[0]  = 1.0; fBuffer[1]  = 0.0; fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0; fBuffer[5]  = 1.0; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0; fBuffer[9]  = 0.0; fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0; fBuffer[13] = 0.0; fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_MODEL_VIEW_MATRIX0(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_INVERSE_MODEL_VIEW_MATRIX0(0) | 0x400000);
    nvPushData(18, ftol[0]);
    nvPushData(19, ftol[4]);
    nvPushData(20, ftol[8]);
    nvPushData(21, ftol[12]);
    nvPushData(22, ftol[1]);
    nvPushData(23, ftol[5]);
    nvPushData(24, ftol[9]);
    nvPushData(25, ftol[13]);
    nvPushData(26, ftol[2]);
    nvPushData(27, ftol[6]);
    nvPushData(28, ftol[10]);
    nvPushData(29, ftol[14]);
    nvPushData(30, ftol[3]);
    nvPushData(31, ftol[7]);
    nvPushData(32, ftol[11]);
    nvPushData(33, ftol[15]);

    nvPusherAdjust(34);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1; // Surface is always referenced by hardware in field mode

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    // Set up viewport
//    xTrans = (float)(-2048 - (1.0 / 32.0)); // hardware epsilon
    // Changed to allow destination X coordinate range of -2046 - 2046 for optimal 1080i performance
    xTrans = (float)(-2 - (1.0 / 32.0)); // hardware epsilon
    yTrans = (float)(-2048 - (1.0 / 32.0));
    zTrans = 0.0;

    // Load composite matrix assuming quarter pel scaling of surface coordinates
    if (pDriverData->bMCHorizontallyDownscale1080i)
        fBuffer[0]  = 0.1875; // quarter pel xScale
    else
        fBuffer[0]  = 0.25; // quarter pel xScale
    fBuffer[1]  = 0.0;
    fBuffer[2]  = 0.0;
    fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;
    fBuffer[5]  = 0.25; // quarter pel yScale
    fBuffer[6]  = 0.0;
    fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;
    fBuffer[9]  = 0.0;
    fBuffer[10] = 1.0;
    fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;
    fBuffer[13] = 0.0;
    fBuffer[14] = 0.0;
    fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMPOSITE_MATRIX(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPusherAdjust(17);

    // Set viewport offset separately
    fBuffer[0] = xTrans;
    fBuffer[1] = yTrans;
    fBuffer[2] = zTrans;
    fBuffer[3] = 0.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_VIEWPORT_OFFSET(0) | 0x100000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[1]);
    nvPushData(3, ftol[2]);
    nvPushData(4, ftol[3]);

    nvPusherAdjust(5);

    // Set front and back clipping
    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CLIP_MIN | 0x80000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[1]);

    nvPusherAdjust(3);

    // Disable almost everything

    // Disable alpha test
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_ALPHA_TEST_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_ALPHA_TEST_ENABLE_V_FALSE);

    // Disable blending
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BLEND_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_BLEND_ENABLE_V_FALSE);

    // Disable culling
    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CULL_FACE_ENABLE | 0x40000);
    nvPushData(5, NV056_SET_CULL_FACE_ENABLE_V_FALSE);

    // Disable depth test
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_DEPTH_TEST_ENABLE | 0x40000);
    nvPushData(7, NV056_SET_DEPTH_TEST_ENABLE_V_FALSE);

    // Disable dither
    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_DITHER_ENABLE | 0x40000);
    nvPushData(9, NV056_SET_DITHER_ENABLE_V_FALSE);

    // Disable lighting
    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_LIGHTING_ENABLE | 0x40000);
    nvPushData(11, NV056_SET_LIGHTING_ENABLE_V_FALSE);

    // Disable point parameters computation
    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POINT_PARAMS_ENABLE | 0x40000);
    nvPushData(13, NV056_SET_POINT_PARAMS_ENABLE_V_FALSE);

    // Disable point smoothing
    nvPushData(14, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POINT_SMOOTH_ENABLE | 0x40000);
    nvPushData(15, NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable line smoothing
    nvPushData(16, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_LINE_SMOOTH_ENABLE | 0x40000);
    nvPushData(17, NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable polygon smoothing
    nvPushData(18, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLY_SMOOTH_ENABLE | 0x40000);
    nvPushData(19, NV056_SET_POLY_SMOOTH_ENABLE_V_FALSE);

    // Disable skinning
    nvPushData(20, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_SKIN_ENABLE | 0x40000);
    nvPushData(21, NV056_SET_SKIN_ENABLE_V_FALSE);

    // Disable stencil test
    nvPushData(22, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_STENCIL_TEST_ENABLE | 0x40000);
    nvPushData(23, NV056_SET_STENCIL_TEST_ENABLE_V_FALSE);

    // Disable polygon offset point
    nvPushData(24, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLY_OFFSET_POINT_ENABLE | 0x40000);
    nvPushData(25, NV056_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE);

    // Disable polygon offset line
    nvPushData(26, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLY_OFFSET_LINE_ENABLE | 0x40000);
    nvPushData(27, NV056_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE);

    // Disable polygon offset fill
    nvPushData(28, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLY_OFFSET_FILL_ENABLE | 0x40000);
    nvPushData(29, NV056_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);

    nvPusherAdjust(30);

    // Set light control
    tmpVal = (NV056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE << 1) |
              NV056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_LIGHT_CONTROL | 0x40000);
    nvPushData(1, tmpVal);

    // Disable color material
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COLOR_MATERIAL | 0x40000);
    nvPushData(3, NV056_SET_COLOR_MATERIAL_V_DISABLED);

    // Set material emission
    fBuffer[0] = 0.0;

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_MATERIAL_EMISSION(0) | 0xC0000);
    nvPushData(5, ftol[0]);
    nvPushData(6, ftol[0]);
    nvPushData(7, ftol[0]);

    // Disable specular
    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SPECULAR_ENABLE | 0x40000);
    nvPushData(9, NV056_SET_SPECULAR_ENABLE_V_FALSE);

    // Disable all lights
    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_LIGHT_ENABLE_MASK | 0x40000);
    nvPushData(11, 0);

    nvPusherAdjust(12);

    // Disable texgen modes for now (OpenGL default is EYE_LINEAR)

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_S(0) | 0x40000);
    nvPushData(1, NV056_SET_TEXGEN_S_V_DISABLE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_T(0) | 0x40000);
    nvPushData(3, NV056_SET_TEXGEN_T_V_DISABLE);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_R(0) | 0x40000);
    nvPushData(5, NV056_SET_TEXGEN_R_V_DISABLE);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_Q(0) | 0x40000);
    nvPushData(7, NV056_SET_TEXGEN_Q_V_DISABLE);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_S(1) | 0x40000);
    nvPushData(9, NV056_SET_TEXGEN_S_V_DISABLE);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_T(1) | 0x40000);
    nvPushData(11, NV056_SET_TEXGEN_T_V_DISABLE);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_R(1) | 0x40000);
    nvPushData(13, NV056_SET_TEXGEN_R_V_DISABLE);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_Q(1) | 0x40000);
    nvPushData(15, NV056_SET_TEXGEN_Q_V_DISABLE);

    nvPusherAdjust(16);

    // Set default texgen planes
    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_SPLANE0(0) | 0x100000);
    nvPushData(1, ftol[1]);
    nvPushData(2, ftol[0]);
    nvPushData(3, ftol[0]);
    nvPushData(4, ftol[0]);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_TPLANE0(0) | 0x100000);
    nvPushData(6, ftol[0]);
    nvPushData(7, ftol[1]);
    nvPushData(8, ftol[0]);
    nvPushData(9, ftol[0]);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_RPLANE0(0) | 0x100000);
    nvPushData(11, ftol[0]);
    nvPushData(12, ftol[0]);
    nvPushData(13, ftol[0]);
    nvPushData(14, ftol[0]);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_QPLANE0(0) | 0x100000);
    nvPushData(16, ftol[0]);
    nvPushData(17, ftol[0]);
    nvPushData(18, ftol[0]);
    nvPushData(19, ftol[0]);

    nvPushData(20, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_SPLANE1(0) | 0x100000);
    nvPushData(21, ftol[1]);
    nvPushData(22, ftol[0]);
    nvPushData(23, ftol[0]);
    nvPushData(24, ftol[0]);

    nvPushData(25, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_TPLANE1(0) | 0x100000);
    nvPushData(26, ftol[0]);
    nvPushData(27, ftol[1]);
    nvPushData(28, ftol[0]);
    nvPushData(29, ftol[0]);

    nvPushData(30, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_RPLANE1(0) | 0x100000);
    nvPushData(31, ftol[0]);
    nvPushData(32, ftol[0]);
    nvPushData(33, ftol[0]);
    nvPushData(34, ftol[0]);

    nvPushData(35, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_QPLANE1(0) | 0x100000);
    nvPushData(36, ftol[0]);
    nvPushData(37, ftol[0]);
    nvPushData(38, ftol[0]);
    nvPushData(39, ftol[0]);

    nvPusherAdjust(40);

    // Set default fog mode
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_MODE | 0x40000);
    nvPushData(1, NV056_SET_FOG_MODE_FOG_MODE_LINEAR);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_GEN_MODE | 0x40000);
    nvPushData(3, NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT);

    // Disable fog
    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(5, NV056_SET_FOG_ENABLE_V_FALSE);

    // Set default fog parameters
    fBuffer[0] = 1.0;                           // K0
    fBuffer[1] = 1.0;                           // K1
    fBuffer[2] = 0.0;                           // K2

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_PARAMS(0) | 0xC0000);
    nvPushData(7, ftol[0]);
    nvPushData(8, ftol[1]);
    nvPushData(9, ftol[2]);

    // Set default fog color
    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_FOG_COLOR | 0x40000);
    nvPushData(11, 0xFFFFFFFF);

    nvPusherAdjust(12);

    // Set default alpha function
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_ALPHA_FUNC | 0x40000);
    nvPushData(1, NV056_SET_ALPHA_FUNC_V_ALWAYS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_ALPHA_REF | 0x40000);
    nvPushData(3, 0);

    // Set default blend equation
    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BLEND_EQUATION | 0x40000);
    nvPushData(5, NV056_SET_BLEND_EQUATION_V_FUNC_ADD);

    // Set default blend color
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BLEND_COLOR | 0x40000);
    nvPushData(7, 0);

    // Set default blend func source factor
    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BLEND_FUNC_SFACTOR | 0x40000);
    nvPushData(9, NV056_SET_BLEND_FUNC_SFACTOR_V_ONE);

    // Set default blend func destination factor
    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BLEND_FUNC_DFACTOR | 0x40000);
    nvPushData(11, NV056_SET_BLEND_FUNC_DFACTOR_V_ZERO);

    nvPusherAdjust(12);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FRONT_FACE | 0x40000);
    nvPushData(1, NV056_SET_FRONT_FACE_V_CCW);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CULL_FACE | 0x40000);
    nvPushData(3, NV056_SET_CULL_FACE_V_BACK);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SHADE_MODE | 0x40000);
    nvPushData(5, NV056_SET_SHADE_MODE_V_SMOOTH);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FRONT_POLYGON_MODE | 0x40000);
    nvPushData(7, NV056_SET_FRONT_POLYGON_MODE_V_FILL);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BACK_POLYGON_MODE | 0x40000);
    nvPushData(9, NV056_SET_BACK_POLYGON_MODE_V_FILL);

    fBuffer[0] = 0.0;

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLYGON_OFFSET_SCALE_FACTOR | 0x40000);
    nvPushData(11, ftol[0]);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLYGON_OFFSET_BIAS | 0x40000);
    nvPushData(13, ftol[0]);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_EDGE_FLAG | 0x40000);
    nvPushData(15, 1);

    nvPusherAdjust(16);

    // Initialize some vertex attributes
    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    // Set color for MODULATE blend mode
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_DIFFUSE_COLOR4F(0) | 0x100000);
    nvPushData(1, ftol[1]);
    nvPushData(2, ftol[1]);
    nvPushData(3, ftol[1]);
    nvPushData(4, ftol[1]);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SPECULAR_COLOR3F(0) | 0xC0000);
    nvPushData(6, ftol[0]);
    nvPushData(7, ftol[0]);
    nvPushData(8, ftol[0]);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXCOORD0_4F(0) | 0x100000);
    nvPushData(10, ftol[0]);
    nvPushData(11, ftol[0]);
    nvPushData(12, ftol[0]);
    nvPushData(13, ftol[1]);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXCOORD1_4F(0) | 0x100000);
    nvPushData(15, ftol[0]);
    nvPushData(16, ftol[0]);
    nvPushData(17, ftol[0]);
    nvPushData(18, ftol[1]);

    nvPushData(19, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_NORMAL3F(0) | 0xC0000);
    nvPushData(20, ftol[0]);
    nvPushData(21, ftol[0]);
    nvPushData(22, ftol[1]);

    nvPushData(23, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_FOG1F | 0x40000);
    nvPushData(24, ftol[0]);

    nvPushData(25, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_WEIGHT1F | 0x40000);
    nvPushData(26, ftol[1]);

    nvPusherAdjust(27);

    // Set depth function
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_DEPTH_FUNC | 0x40000);
    nvPushData(1, NV056_SET_DEPTH_FUNC_V_ALWAYS);

    // Set color mask
    tmpVal = (NV056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE << 24) |
             (NV056_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE << 16) |
             (NV056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE << 8) |
              NV056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COLOR_MASK | 0x40000);
    nvPushData(3, tmpVal);

    // Set depth mask
    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_DEPTH_MASK | 0x40000);
    nvPushData(5, NV056_SET_DEPTH_MASK_V_FALSE);

    nvPusherAdjust(6);

    // Initialize stencil state (test already disabled above)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_STENCIL_FUNC | 0x40000);
    nvPushData(1, NV056_SET_STENCIL_FUNC_V_ALWAYS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_STENCIL_FUNC_REF | 0x40000);
    nvPushData(3, 0);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_STENCIL_FUNC_MASK | 0x40000);
    nvPushData(5, 0x000000FF);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_STENCIL_OP_FAIL | 0x40000);
    nvPushData(7, NV056_SET_STENCIL_OP_FAIL_V_KEEP);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_STENCIL_OP_ZFAIL | 0x40000);
    nvPushData(9, NV056_SET_STENCIL_OP_ZFAIL_V_KEEP);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_STENCIL_OP_ZPASS | 0x40000);
    nvPushData(11, NV056_SET_STENCIL_OP_ZPASS_V_KEEP);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_STENCIL_MASK | 0x40000);
    nvPushData(13, 0x000000FF);

    nvPusherAdjust(14);

    // This is set once and forgotten. It puts the class in OGL flat shade mode.
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FLAT_SHADE_OP | 0x40000);
    nvPushData(1, NV056_SET_FLAT_SHADE_OP_V_LAST_VTX);

    nvPusherAdjust(2);

    // Load texture matrices assuming quarter pel scaling of texture coordinates
    if (pDriverData->bMCHorizontallyDownscale1080i)
        fBuffer[0]  = 0.1875;
    else
        fBuffer[0]  = 0.25;

                        fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_MATRIX1(0) | 0x400000);
    nvPushData(18, ftol[0]);
    nvPushData(19, ftol[4]);
    nvPushData(20, ftol[8]);
    nvPushData(21, ftol[12]);
    nvPushData(22, ftol[1]);
    nvPushData(23, ftol[5]);
    nvPushData(24, ftol[9]);
    nvPushData(25, ftol[13]);
    nvPushData(26, ftol[2]);
    nvPushData(27, ftol[6]);
    nvPushData(28, ftol[10]);
    nvPushData(29, ftol[14]);
    nvPushData(30, ftol[3]);
    nvPushData(31, ftol[7]);
    nvPushData(32, ftol[11]);
    nvPushData(33, ftol[15]);

    nvPusherAdjust(34);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoComp */



/*
 * nvInitCelsiusForMoCompPrediction
 *
 * Performs final celsius object motion comp initialization for
 * the prediction portion of the algorithm.
 *
 * For prediction, texture 0 is used for forward prediction, texture 1
 * is used for backward prediction.  These textures are just passed through
 * the register combiners to the final combiner.  The final combiner is
 * configured so that the fog coordinate is used to control the contribution
 * of each texture in the final output.  A fog value of 0.0 selects forward
 * prediction, 0.5 selects bidirectional prediction, and 1.0 selects backward
 * prediction.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = (1.0)constantColor0, B = texture0, C = (1.0)constantColor0, D = texture1
 *      OUTPUT: spare0 = A * B, spare1 = C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: A.rgb = Fog.a, B = spare1, C = spare0, D = 0
 *      OUTPUT: B * A + C * (1.0 - A)
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompPrediction(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               dwSurfaceOffset;
    unsigned long               tmpVal;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    unsigned long               moCompICW;
    unsigned long               moCompOCW;
    unsigned long               moCompFinalCW0;
    unsigned long               moCompFinalCW1;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Initialize surface offsets
    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
    nvPushData(3, dwSurfaceOffset);

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
    nvPushData(5, dwSurfaceOffset);

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(7, dwSurfaceOffset);

    nvPusherAdjust(8);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1; // Surface is always referenced by hardware in field mode

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE);

    nvMoCompParams.dataFormat = DATA_FORMAT_LUMA;

    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(5, tmpVal);
    nvPushData(6, tmpVal);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(7, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(8, pDriverData->dwMCTex0Control0);
    nvPushData(9, pDriverData->dwMCTex1Control0);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(11, surfacePitch << 16);
    nvPushData(12, surfacePitch << 16);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(14, 0);
    nvPushData(15, 0);

//    tmpVal = (2044 << 16) | (surfaceHeight << 1); // Must be even and <= 2046
    tmpVal = (2044 << 16) | 2046; // Must be even and <= 2046

    nvPushData(16, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(17, tmpVal);
    nvPushData(18, tmpVal);

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

    nvPushData(19, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(20, tmpVal);
    nvPushData(21, tmpVal);

    nvPusherAdjust(22);

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {

        // Load composite and texture matrices assuming quarter pel horizontal scaling and eigth pel vertical
        // scaling of texture coordinates
        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;
        else
            fBuffer[0]  = 0.25;

                            fBuffer[1]  = 0.0;   fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;  fBuffer[5]  = 0.125; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;   fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;  fBuffer[13] = 0.0;   fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_MATRIX0(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
            NV056_SET_TEXTURE_MATRIX1(0) | 0x400000);
        nvPushData(18, ftol[0]);
        nvPushData(19, ftol[4]);
        nvPushData(20, ftol[8]);
        nvPushData(21, ftol[12]);
        nvPushData(22, ftol[1]);
        nvPushData(23, ftol[5]);
        nvPushData(24, ftol[9]);
        nvPushData(25, ftol[13]);
        nvPushData(26, ftol[2]);
        nvPushData(27, ftol[6]);
        nvPushData(28, ftol[10]);
        nvPushData(29, ftol[14]);
        nvPushData(30, ftol[3]);
        nvPushData(31, ftol[7]);
        nvPushData(32, ftol[11]);
        nvPushData(33, ftol[15]);

        nvPusherAdjust(34);
    }

    // Enable fog (mocomp fog modes set during default mocomp initialization)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_TRUE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our prediction moComp values
    // combiner0, RGB portion:   A = 1
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = 1
    // combiner0, RGB portion:   D = texture1

    moCompICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT << 29) |
                (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0 << 24) |

                (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                 NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_ICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompICW);
    nvPushData(5, DEFAULT_COLOR_ICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0xFFFFFFFF); // 100%
    nvPushData(8, 0xFFFFFFFF); // 100%

    nvPusherAdjust(9);

    // combiner0, RGB portion:   spare0 = texture0, spare1 = texture1
    moCompOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0 << 8) |
                (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C << 4) |
                 NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_OCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompOCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, DEFAULT_C1_COLOR_OCW);

    nvPusherAdjust(7);

    // Reconfigure fog unit to interpolate
    // fog factor in alpha
    // fog = 0.0: all texture0
    // fog = 0.5: equal parts of texture0 and texture1
    // fog = 1.0: all texture1

    moCompFinalCW0 = (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE << 28) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3 << 24) |   // fog

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D << 16) |   // spare1

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C << 8) |    // spare0

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0;           // 0

    moCompFinalCW1 = (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |   // 0

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |   // 0

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE << 13) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0 << 8) |    // 0xFF

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) |
                      NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE;

    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, moCompFinalCW0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, moCompFinalCW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompPrediction */


/*
 * nvInitCelsiusForMoCompCorrection
 *
 * Performs final celcius object motion comp initialization for
 * the correction portion of the algorithm.
 *
 * For correction, texture 0 is used for the error terms, texture 1
 * is mapped over the source/destination.  The error terms are signed
 * and the textures are unsigned so the register combiners need to be
 * setup appropriately.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = (1.0)constantColor0, B = (signed)texture0, C = (1.0)constantColor0, D = (unsigned)texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompCorrection(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               dwSurfaceOffset;
    unsigned long               texturePitch0;
    unsigned long               texturePitch1 = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               textureFormat0;
    unsigned long               textureFormat1;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    unsigned long               moCompICW;
    unsigned long               moCompOCW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Initialize surface offsets
    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
    nvPushData(3, dwSurfaceOffset);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
    nvPushData(5, 0);
    nvPushData(6, dwSurfaceOffset);

    nvPusherAdjust(7);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);

    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        surfacePitch <<= 1; // Field surface is always referenced by hardware using double pitch

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE);

    nvMoCompParams.dataFormat = DATA_FORMAT_CORRECTION;

    // Signed Y8
    textureFormat0 = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
                     (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
                     (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
                     (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
                     (1 << 12) | // 1 MIPMAP level
                     (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8 << 7) |
                     (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
                     (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
                     (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
                      NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B;
    // Unsigned Y8
    textureFormat1 = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
                     (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
                     (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
                     (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
                     (1 << 12) | // 1 MIPMAP level
                     (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) |
                     (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
                     (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
                     (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
                      NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(5, textureFormat0);
    nvPushData(6, textureFormat1);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(7, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(8, pDriverData->dwMCTex0Control0);
    nvPushData(9, pDriverData->dwMCTex1Control0);

    nvPusherAdjust(10);

    // Correction textures ALWAYS have 8 byte frame pitches or 16 byte field pitches
    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        texturePitch0 = 16;
    else {
        texturePitch0 = 8;

        // Load composite and texture matrices assuming quarter pel scaling of texture coordinates
        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;
        else
            fBuffer[0]  = 0.25;

                            fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);

        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.25;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_MATRIX0(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;

        nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
            NV056_SET_TEXTURE_MATRIX1(0) | 0x400000);
        nvPushData(18, ftol[0]);
        nvPushData(19, ftol[4]);
        nvPushData(20, ftol[8]);
        nvPushData(21, ftol[12]);
        nvPushData(22, ftol[1]);
        nvPushData(23, ftol[5]);
        nvPushData(24, ftol[9]);
        nvPushData(25, ftol[13]);
        nvPushData(26, ftol[2]);
        nvPushData(27, ftol[6]);
        nvPushData(28, ftol[10]);
        nvPushData(29, ftol[14]);
        nvPushData(30, ftol[3]);
        nvPushData(31, ftol[7]);
        nvPushData(32, ftol[11]);
        nvPushData(33, ftol[15]);

        nvPusherAdjust(34);
    }

    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        texturePitch1 <<= 1; // Field textures are always referenced by hardware using double pitch

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(1, texturePitch0 << 16);
    nvPushData(2, texturePitch1 << 16);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(4, 0);
    nvPushData(5, 0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(7, (16 << 16) | 2044); // Must be even and <= 2046
//    nvPushData(8, ((2044 << 16) | (surfaceHeight << 1))); // Must be even and <= 2046
    nvPushData(8, ((2044 << 16) | 2046)); // Must be even and <= 2046

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST << 24);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(10, tmpVal);
    nvPushData(11, tmpVal);

    nvPusherAdjust(12);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our correction moComp values
    // combiner0, RGB portion:   A = 1
    // combiner0, RGB portion:   B = (signed)texture0
    // combiner0, RGB portion:   C = 1
    // combiner0, RGB portion:   D = (unsigned)texture1

    moCompICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                (NV056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                 NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_ICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompICW);
    nvPushData(5, DEFAULT_COLOR_ICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0xFFFFFFFF); // 100%
    nvPushData(8, 0); // 0%

    nvPusherAdjust(9);

    // combiner0, RGB portion:   texture0 + texture1
    // spare0 = A * B + C * D
    moCompOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                 NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_OCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompOCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, DEFAULT_C1_COLOR_OCW);

    nvPusherAdjust(7);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_FINAL_CW0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_FINAL_CW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompCorrection */

#if 0 // Until NV17

/*
 * nvInitCelsiusForMoCompNV12LumaSubpictureCompositing
 *
 * Performs final celsius object motion comp initialization for
 * A8V8U8Y8 subpicture compositing with an NV12 surface luma portion resulting in an
 * output surface also in NV12 format.
 *
 * For luma subpicture compositing, texture0 is the subpicture in A8V8U8Y8 format from
 * which we extract the A8 and Y8 components and alpha blend with the Y8 components of
 * the NV12 source surface in texture1 to produce alpha blended Y8 components in NV12
 * format in the destination surface.
 * The output texture is just passed through the register combiners to the final combiner.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = texture0 alpha, B = texture0 color B(Y), C = !texture0 alpha, D = texture1 color B(Y)
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompNV12LumaSubpictureCompositing(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               texturePitch = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               moCompColorICW;
    unsigned long               moCompAlphaOCW;
    unsigned long               moCompColorOCW;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Surface offsets are initialized in the subpicture compositing function

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Just disable both texture matrices since these texture coordinates are unscaled

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE);

    nvPusherAdjust(4);

    nvMoCompParams.dataFormat = DATA_FORMAT_SUBPICTURE_LUMA_BLEND;

    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(1, tmpVal);
    
    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(2, tmpVal);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(4, pDriverData->dwMCTex0Control0);
    nvPushData(5, pDriverData->dwMCTex1Control0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(7, texturePitch << 16);
    nvPushData(8, texturePitch << 16);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(10, 0);
    nvPushData(11, 0);

//    tmpVal = (2044 << 16) | (surfaceHeight << 1); // Must be even and <= 2046
    tmpVal = (2044 << 16) | 2046; // Must be even and <= 2046

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(13, tmpVal);
    nvPushData(14, tmpVal);

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST << 24);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(16, tmpVal);
    nvPushData(17, tmpVal);

    nvPusherAdjust(18);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our subpictue luma alpha blending moComp values
    // combiner0, RGB portion:   A = texture0(Alpha)
    // combiner0, RGB portion:   B = texture0(RGB(VUY))
    // combiner0, RGB portion:   C = texture0(!Alpha)
    // combiner0, RGB portion:   D = texture1(BBB(YYY))

    moCompColorICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_ICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompColorICW);
    nvPushData(5, DEFAULT_COLOR_ICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0xFF0000FF); // 100%
    nvPushData(8, 0xFF0000FF); // 100%

    nvPusherAdjust(9);

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 alpha * texture0 B(Y) + !texture0 alpha * texture1 B(Y)
    moCompColorOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_OCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompColorOCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, DEFAULT_C1_COLOR_OCW);

    nvPusherAdjust(7);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_FINAL_CW0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_FINAL_CW1);

    nvPusherAdjust(4);


    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompNV12LumaSubpictureCompositing */


/*
 * nvInitCelsiusForMoCompNV12ChromaSubpictureCompositing
 *
 * Performs final celsius object motion comp initialization for
 * A8V8U8Y8 subpicture compositing with an NV12 surface chroma portion resulting in an
 * output surface also in NV12 format.
 *
 * For chroma subpicture compositing, texture0 is the subpicture in A8V8U8Y8 format from
 * which we extract the A8 and V8U8 components and alpha blend with the V8U8 components of
 * the NV12 source surface in texture1 to produce alpha blended V8U8 components in NV12
 * format in the destination surface.
 *
 * In this mode the register combiners are set to:
 *
 * COMBINER0:
 *      INPUT: A = texture0 alpha, B = texture0 color RGB(VUY), C = !texture0 alpha, D = texture1 color RBB(VUU)
 *      OUTPUT: spare0 = A * B + C * D
 * COMBINER1:
 *      INPUT: A = constant0 (0,1,0)(U), B = spare0 color (VUU), C = constant1(1,0,0)(V), D = spare0 color (VUU)
 *      OUTPUT: OCW C = A . B = UUU, OCW D = C . D = VVV
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = UUU, D = VVV
 *      OUTPUT: C = VU
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompNV12ChromaSubpictureCompositing(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               texturePitch = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               moCompColorICW;
    unsigned long               moCompColorOCW;
    unsigned long               moCompFinalCW;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Surface offsets are initialized in the subpicture compositing function

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_G8B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Just disable both texture matrices since these texture coordinates are unscaled

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE);

    nvPusherAdjust(4);

    nvMoCompParams.dataFormat = DATA_FORMAT_SUBPICTURE_CHROMA_BLEND;

    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(1, tmpVal);
    
    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(2, tmpVal);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(4, pDriverData->dwMCTex0Control0);
    nvPushData(5, pDriverData->dwMCTex1Control0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(7, texturePitch << 16);
    nvPushData(8, texturePitch << 16);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(10, 0);
    nvPushData(11, 0);

//    tmpVal = (2044 << 16) | (surfaceHeight << 1); // Must be even and <= 2046
    tmpVal = (2044 << 16) | 2046; // Must be even and <= 2046

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(13, tmpVal);
    nvPushData(14, tmpVal);

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST << 24);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(16, tmpVal);
    nvPushData(17, tmpVal);

    nvPusherAdjust(18);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our subpicture chroma alpha blending moComp values for combiner0
    // combiner0, RGB portion:   A = texture0(Alpha)
    // combiner0, RGB portion:   B = texture0(RGB(VUY))
    // combiner0, RGB portion:   C = texture0(!Alpha)
    // combiner0, RGB portion:   D = texture1(RBB(VUU))

    moCompColorICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_ICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompColorICW);

    // Our subpicture chroma alpha blending moComp values for combiner1
    // combiner1, RGB portion:   A = constant0(0,1,0)(U)
    // combiner1, RGB portion:   B = combiner0 color (final VUU)
    // combiner1, RGB portion:   C = constant1(1,0,0)(V)
    // combiner1, RGB portion:   D = combiner0 color (final VUU)

    moCompColorICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C;

    nvPushData(5, moCompColorICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0x0000FF00); // 100%
    nvPushData(8, 0x00FF0000); // 100%

    nvPusherAdjust(9);

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 alpha * texture0 RGB(VUY) + !texture0 alpha * texture1 RBB(VUU)
    moCompColorOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_OCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompColorOCW);

    // combiner1, RGB portion:      OCW C = A . B = constant0 (0,1,0) * final U, OCW D = C . D = constant1(1,0,0) * final V
    moCompColorOCW = (NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO << 28) |
                     (NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB << 27) |
                     (NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE << 13) |
                     (NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE << 12) |
                     (NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0 << 8) |
                     (NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C << 4) |
                      NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D;

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, moCompColorOCW);

    nvPusherAdjust(7);

    // Load final stages: final output (VU) = constant0(0,1,0) * OCW D (VVV) + (1 - constant0)(1,0,1) * OCW C (UUU) + 0
    // Initialize combiner final CW methods

    moCompFinalCW = (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE << 28) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1 << 24) |
                                                                                          
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D << 16) |
                                                                                           
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C << 8) |
                                                                                         
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |
                     NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, moCompFinalCW);
    
    moCompFinalCW = (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |
                                                                                          
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |
                                                                                      
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE << 13) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE << 12) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0 << 8) |
                                                                                          
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) |
                     NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE;
    
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, moCompFinalCW);

    nvPusherAdjust(4);


    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompNV12ChromaSubpictureCompositing */

#endif // Until NV17

/*
 * nvInitCelsiusForMoCompConversion
 *
 * Performs final celsius object motion comp initialization for
 * the format conversion portion of the algorithm.
 *
 * For conversion, texture0 is used to convert the luma values to 0x00Y100Y0 and
 * texture1 is used to convert the chroma values to 0xV000U000 which are then added together
 * thus allowing the conversion to take place in one pass.  The textures are modulated
 * with constant colors to select which component comes from which texture.
 * The output texture is just passed through the register combiners to the final combiner.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = constantColor0, B = texture0, C = constantColor1, D = texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompConversion(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               texturePitch = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               moCompAlphaICW;
    unsigned long               moCompColorICW;
    unsigned long               moCompAlphaOCW;
    unsigned long               moCompColorOCW;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    if (pDriverData->bMCHorizontallyDownscale1080i) {
        // Restore default composite and texture matrices assuming quarter pel scaling of texture coordinates
        fBuffer[0]  = 0.1875; fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;    fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;    fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;    fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);
    }

    // Surface offsets are initialized in the format conversion function

    // Align surface pitch and set surface format and pitch
    surfacePitch = ((surfaceWidth << 1) + 127) & ~127; // YUY2 destination is twice the surface width
    surfacePitch |= (surfacePitch << 16);

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Just disable both texture matrices since these texture coordinates are unscaled

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE);

    nvPusherAdjust(4);

    nvMoCompParams.dataFormat = DATA_FORMAT_FOURCC_CONVERSION;

    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(1, tmpVal);
    nvPushData(2, tmpVal);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(4, pDriverData->dwMCTex0Control0);
    nvPushData(5, pDriverData->dwMCTex1Control0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(7, texturePitch << 16);
    nvPushData(8, texturePitch << 16);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(10, 0);
    nvPushData(11, 0);

//    tmpVal = (2044 << 16) | (surfaceHeight << 1); // Must be even and <= 2046
    tmpVal = (2044 << 16) | 2046; // Must be even and <= 2046

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(13, tmpVal);
    nvPushData(14, tmpVal);

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST << 24);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(16, tmpVal);
    nvPushData(17, tmpVal);

    nvPusherAdjust(18);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our format conversion moComp values
    // combiner0, Alpha portion:   A = 0
    // combiner0, Alpha portion:   B = 0
    // combiner0, Alpha portion:   C = constantColor1 (0xFF00FF00)
    // combiner0, Alpha portion:   D = texture1
    // combiner0, RGB portion:   A = constantColor0 (0x00FF00FF)
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = constantColor1 (0xFF00FF00)
    // combiner0, RGB portion:   D = texture1

    moCompAlphaICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0 << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    moCompColorICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, moCompAlphaICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompColorICW);
    nvPushData(5, DEFAULT_COLOR_ICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0x00FF00FF); // luma
    nvPushData(8, 0xFF00FF00); // chroma

    nvPusherAdjust(9);

    // combiner0, Alpha portion:    spare0 = A * B + C * D = texture1
    moCompAlphaOCW = (NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0;

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1
    moCompColorOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, moCompAlphaOCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompColorOCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, DEFAULT_C1_COLOR_OCW);

    nvPusherAdjust(7);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_FINAL_CW0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_FINAL_CW1);

    nvPusherAdjust(4);


    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompConversion */


/*
 * nvInitCelsiusForMoCompTemporalFilter
 *
 * Performs final celsius object motion comp initialization for
 * the intra frame field temporal filtering portion of the algorithm.
 *
 * For temporal filtering, texture0 is used to reference the top field and
 * texture1 is used to reference the bottom field which are then added together
 * thus allowing the filter to complete in one pass.  The textures are modulated
 * with constant colors to select the fraction of coverage which comes from which texture.
 * The output texture is just passed through the register combiners to the final combiner.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = constantColor0, B = texture0, C = constantColor1, D = texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompTemporalFilter(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch;
    unsigned long               tmpVal;
    unsigned long               moCompAlphaICW;
    unsigned long               moCompColorICW;
    unsigned long               moCompAlphaOCW;
    unsigned long               moCompColorOCW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Surface offsets are initialized in the temporal filter function

    // Align surface pitch and set surface format and pitch
    surfacePitch = (pSurf_gbl->wWidth + 3) & ~3;
    surfacePitch = ((surfacePitch << 1) + 127) & ~127; // YUY2 destination is twice the surface width
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1;

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Enable both texture matrices since these texture coordinates are in quarter pel
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE);

    nvPusherAdjust(4);

    nvMoCompParams.dataFormat = DATA_FORMAT_TEMPORAL_FILTER;

    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(1, tmpVal);
    nvPushData(2, tmpVal);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(4, pDriverData->dwMCTex0Control0);
    nvPushData(5, pDriverData->dwMCTex1Control0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(7, (surfacePitch << 16));
    nvPushData(8, (surfacePitch << 16));

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(10, 0);
    nvPushData(11, 0);

//    tmpVal = (2044 << 16) | (surfaceHeight << 1); // Must be even and <= 2046
    tmpVal = (2044 << 16) | 2046; // Must be even and <= 2046

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(13, tmpVal);
    nvPushData(14, tmpVal);

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(16, tmpVal);
    nvPushData(17, tmpVal);

    nvPusherAdjust(18);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our temporal filter moComp values
    // combiner0, RGB portion:   A = constantColor0
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = constantColor1
    // combiner0, RGB portion:   D = texture1

    moCompAlphaICW = (NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |
                     (NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1 << 24) |

                     (NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |
                     (NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8 << 16) |

                     (NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |
                     (NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2 << 8) |

                     (NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |
                      NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9;

    moCompColorICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, moCompAlphaICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompColorICW);
    nvPushData(5, DEFAULT_COLOR_ICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0x80808080); // % of top field
    nvPushData(8, 0x80808080); // % of bottom field

    nvPusherAdjust(9);

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1
    moCompAlphaOCW = (NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0;

    moCompColorOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, moCompAlphaOCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompColorOCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, DEFAULT_C1_COLOR_OCW);

    nvPusherAdjust(7);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_FINAL_CW0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_FINAL_CW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompTemporalFilter */



#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\MoCorr.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoCorr.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)


extern NVMOCOMPPARAMS nvMoCompParams;

extern PNVMCCORRFUNC2 nvDoAllIntraFieldCorrections;
extern PNVMCCORRFUNC2 nvDoAllFieldCorrections;
extern PNVMCCORRFUNC nvDoIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoOptimizedIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoFieldCorrection;

extern PNVMCCORRFUNC nvDoAllIntraFrameCorrections;
extern PNVMCCORRFUNC nvDoAllFrameCorrections;
extern PNVMCCORRFUNC nvDoIntraFrameCorrection;
extern PNVMCCORRFUNC nvDoFrameCorrection;

#ifdef  DEBUG
extern unsigned long moCompDebugLevel;
#endif  // DEBUG

/*
 * nvDoCelsiusIntraFrameCorrection
 *
 * Performs frame correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusIntraFrameCorrection(void)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    
    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(7);

    nvPushData(19, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(20, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(21);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusIntraFrameCorrection */


/*
 * nvDoAllCelsiusIntraFrameCorrections
 *
 * Performs frame correction on all blocks in a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusIntraFrameCorrections(void)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    long                        nextBlockYOffset = 32 << 16;
    
    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0xC00000);

    nvPushMoCompQuadData(7);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(19);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 -= 32;
    blockX1 -= 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY0 += nextBlockYOffset;
    blockY1 += nextBlockYOffset;

    nvPushMoCompQuadData(31);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;

    nvPushMoCompQuadData(43);

    nvPushData(55, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(56, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(57);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusIntraFrameCorrections */



/*
 * nvDoCelsiusFrameCorrection
 *
 * Performs frame correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusFrameCorrection(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    
    texture1BlockX0 = nvMoCompParams.blockX;
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusFrameCorrection */


/*
 * nvDoAllCelsiusFrameCorrections
 *
 * Performs frame correction on all blocks in a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusFrameCorrections(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    long nextBlockYOffset = 32 << 16;
    
    texture1BlockX0 = nvMoCompParams.blockX;
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;
    
    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0xC00000);

    nvPushMoCompQuadData(3);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(15);

    texture1BlockX0 -= 32;
    texture1BlockX1 -= 32;
    texture1BlockY0 += nextBlockYOffset;
    texture1BlockY1 += nextBlockYOffset;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 -= 32;
    blockX1 -= 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY0 += nextBlockYOffset;
    blockY1 += nextBlockYOffset;

    nvPushMoCompQuadData(27);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;

    nvPushMoCompQuadData(39);

    nvPushData(51, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(52, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(53);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusFrameCorrections */


/*
 * nvCorrectCelsiusIntraFrame                                             
 *
 * Processes LUMA blocks in an IntraFrame then makes a 2nd pass and processes chroma blocks
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusIntraFrame(LPNVDECODEMACROBLOCK pFirstMacroblock, long macroblockCount)
{
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    LPNVDECODEMACROBLOCK        pMacroblock;
    unsigned long               IDCTIndex;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    unsigned long               dstSurfacePitch;
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1 = 64;
    long                        texture1BlockY1 = 32 << 16;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0;
    long                        texture0BlockX1 = 64;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    int                         n;
    int                         i;
    
    dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;
            
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    if (pMacroblock->codedBlockPattern == 0xFF) {
        // Change texture0 pitch to 16 bytes
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, 16 << 16);
        nvPushData(2, 16 << 16); // half bias Intra block pitch

        nvPusherAdjust(3);
    }   
    
    i = 0;
    
    nvMoCompParams.destinationField = 0;

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex;
        blockPattern = pMacroblock->codedBlockPattern;

        if (pMacroblock->DCTType != DCT_FIELD) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                nvDoIntraFrameCorrection();
            } else {
                // Change texture0 pitch to 8 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(1, 8 << 16);
                nvPushData(2, 8 << 16); // half bias Intra block pitch

                nvPusherAdjust(3);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                nvDoAllIntraFrameCorrections();

                // Change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(1, 16 << 16);
                nvPushData(2, 16 << 16); // half bias Intra block pitch

                nvPusherAdjust(3);
            }

        } else
            i++;

        pMacroblock++;
    }
    
    nvPusherStart(TRUE);

    if (i > 0) { // if there were any DCT_FIELD macroblocks

        pMacroblock = pFirstMacroblock;
        n = macroblockCount;

        // Must temporarily set destination surface pitch back to double it's normal frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, dstSurfacePitch << 1);

        nvPusherAdjust(2);
                
        while (--n >= 0) {
        
            IDCTIndex = pMacroblock->firstIDCTIndex;
            blockPattern = pMacroblock->codedBlockPattern;

            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.destinationField = 0;
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                } else {    
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                }
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (blockPattern >= 0xFC) {
                    nvDoIntraFieldCorrection();
                } else {
                    // Change texture0 pitch to 8 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                    nvPushData(1, 8 << 16);
                    nvPushData(2, 8 << 16); // half bias Intra block pitch

                    nvPusherAdjust(3);

                    nvDoAllIntraFieldCorrections(8, 2);

                    // Change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                    nvPushData(1, 16 << 16);
                    nvPushData(2, 16 << 16); // half bias Intra block pitch

                    nvPusherAdjust(3);
                }
            }

            pMacroblock++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pFirstMacroblock;
        n = macroblockCount;

        while (--n >= 0) {
        
            IDCTIndex = pMacroblock->firstIDCTIndex;
            blockPattern = pMacroblock->codedBlockPattern;

            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoIntraFieldCorrection();
                } else {
                    // Change texture0 pitch to 8 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                    nvPushData(1, 8 << 16);
                    nvPushData(2, 8 << 16); // half bias Intra block pitch

                    nvPusherAdjust(3);

                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllIntraFieldCorrections(8, 2);

                    // Change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                    nvPushData(1, 16 << 16);
                    nvPushData(2, 16 << 16); // half bias Intra block pitch

                    nvPusherAdjust(3);
                }
            }

            pMacroblock++;
        }

        nvPusherStart(TRUE);

    }
    

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    if (pDriverData->bMCCurrentExecuteFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
        SET_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT();
    } else {
        SET_CHROMA_CORRECTION_DATA_FORMAT();
    }    
  
    // Chroma IDCTs are always frame based
    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    nvMoCompParams.destinationField = 0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(1, dstSurfacePitch);

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Temporarily change texture0 pitch to 16 bytes
    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(5, 16 << 16);
    nvPushData(6, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(7);

    texture0BlockX1 = 32;
    texture1BlockX1 = 32;
 
    while (n >= 8) {

        n -= 8;
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x1800000);

        i = 3;
        
        while (i < 99) {        
            IDCTIndex = pMacroblock->firstIDCTIndex + 4;

            texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
            texture0BlockY1 = texture0BlockY0 + 32;
            texture0BlockY1 <<= 16;
            texture0BlockY0 <<= 16;

            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

            blockX0 = (pMacroblock->hOffset << 1) - nvMoCompParams.celsiusDestinationViewportXOffset;
            blockY0 = nvMoCompParams.blockY;
            blockY0 <<= 16;
            blockX1 = blockX0 + 32;
            blockX1 &= 0x0000FFFF;
            blockX0 &= 0x0000FFFF;
            blockY1 = nvMoCompParams.blockY + 32;
            blockY1 <<= 16;

            nvPushMoCompQuadData(i);
            
            i += 12;

            pMacroblock++;
        }
        
        nvPushData(i, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        i++;
                       
        nvPushData(i, NV056_SET_BEGIN_END_OP_END);
        
        i++;

        nvPusherAdjust(i);

#ifdef  DEBUG
        if (moCompDebugLevel > 1)
            nvPusherStart(TRUE);
#endif  // DEBUG
    }

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex + 4;

        texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
        texture0BlockY1 = texture0BlockY0 + 32;
        texture0BlockY1 <<= 16;
        texture0BlockY0 <<= 16;

        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

        blockX0 = (pMacroblock->hOffset << 1) - nvMoCompParams.celsiusDestinationViewportXOffset;
        blockY0 = nvMoCompParams.blockY;
        blockY0 <<= 16;
        blockX1 = blockX0 + 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY1 = nvMoCompParams.blockY + 32;
        blockY1 <<= 16;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x300000);

        nvPushMoCompQuadData(3);

        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

#ifdef  DEBUG
        if (moCompDebugLevel > 1)
            nvPusherStart(TRUE);
#endif  // DEBUG

        pMacroblock++;
    }

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectCelsiusIntraFrame */


/*
 * nvCorrectCelsiusFullFrameLumaMacroblock
 *
 * Performs correction on all blocks in macroblock assuming Y0/Y1/Y2/Y3 are in NV optimized format
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusFullFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    unsigned long dstSurfacePitch;
    
    if (pMacroblock->DCTType == DCT_FIELD) {

        dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockWidth = 64;
        nvMoCompParams.blockHeight = 32;
        nvMoCompParams.blockX = pMacroblock->hOffset << 2;
        nvMoCompParams.blockY = pMacroblock->vOffset << 1;

        if (pMacroblock->macroblockType != MB_INTRA) {           

            // Temporarily change texture1 pitch to match destination surface pitch
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, dstSurfacePitch << 17);

            nvPusherAdjust(2);

            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoFieldCorrection();
            nvMoCompParams.destinationField = 1;
            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoFieldCorrection();
            
            // Restore texture1 pitch to it's default value
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

            nvPusherAdjust(2);

        } else {
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoIntraFieldCorrection();
            nvMoCompParams.destinationField = 1;
            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoIntraFieldCorrection();
        }

    } else {
        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockX = pMacroblock->hOffset << 2;
        nvMoCompParams.blockY = pMacroblock->vOffset << 2;

        nvMoCompParams.blockWidth = 64;
        nvMoCompParams.blockHeight = 64;
        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(1, nvMoCompParams.surfaceOffset);

        nvPusherAdjust(2);

        if (pMacroblock->macroblockType != MB_INTRA) {
            nvDoFrameCorrection();
        } else
            nvDoIntraFrameCorrection();

    }

} /* nvCorrectCelsiusFullFrameLumaMacroblock */


/*
 * nvCorrectCelsiusFullFrameChromaMacroblock
 *
 * Performs correction on all blocks in macroblock assuming Y0/Y1/Y2/Y3 are in NV optimized format
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusFullFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long chromaVOffset;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    IDCTIndex += 4;

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    // Chroma IDCTs are always frame based
    nvMoCompParams.correctionField = 0;
    nvMoCompParams.destinationField = 0;
    nvMoCompParams.blockWidth = 32;
    nvMoCompParams.blockHeight = 32;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;
    nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

    if (pMacroblock->macroblockType != MB_INTRA)           
        nvDoFrameCorrection();
    else
        nvDoIntraFrameCorrection();

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectCelsiusFullFrameChromaMacroblock */


/*
 * nvCorrectCelsiusFrameLumaMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    BYTE blockPattern;
    unsigned long dstSurfacePitch;
    
    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if (pMacroblock->DCTType == DCT_FIELD) {
        // Must temporarily set destination surface pitch back to double it's normal frame pitch
        dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        if (pMacroblock->macroblockType != MB_INTRA) {           
            // Temporarily change texture1 pitch to match destination surface pitch
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, dstSurfacePitch << 17);

            nvPusherAdjust(2);
        }
    }

    if ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) {

        if (pMacroblock->DCTType == DCT_FIELD) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 1;

            if (pMacroblock->macroblockType != MB_INTRA) {           

                if (blockPattern >= 0xFC) {

                    // Temporarily change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);

                    nvPusherAdjust(2);

                    nvMoCompParams.blockWidth = 64;

                    if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (correctionType == CORRECTION_FIRST_PASS)) {
                        if (nvMoCompParams.destinationFieldIs0) {
                            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                            nvDoFieldCorrection();
                        } else {
                            nvMoCompParams.destinationField = 1;
                            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                            nvDoFieldCorrection();
                        }
                    } else {
                        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                        nvDoFieldCorrection();
                        nvMoCompParams.destinationField = 1;
                        nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                        nvDoFieldCorrection();
                    }

                    // Restore texture0 pitch to default value
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);

                    nvPusherAdjust(2);

                } else {

                    nvMoCompParams.blockWidth = 32;

                    if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (correctionType == CORRECTION_FIRST_PASS)) {
                        if (nvMoCompParams.destinationFieldIs0) {
                            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                            nvDoAllFieldCorrections(8, 2);
                        } else {
                            nvMoCompParams.destinationField = 1;
                            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                            nvDoAllFieldCorrections(8, 2);
                        }    
                    } else {
                        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                        nvDoAllFieldCorrections(8, 2);
                        nvMoCompParams.destinationField = 1;
                        nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                        nvDoAllFieldCorrections(8, 2);
                    }
                }
                
            } else {
                if (blockPattern >= 0xFC) {
                    // Temporarily change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);

                    nvPusherAdjust(2);

                    nvMoCompParams.blockWidth = 64;

                    if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (correctionType == CORRECTION_FIRST_PASS)) {
                        if (nvMoCompParams.destinationFieldIs0) {
                            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                            nvDoIntraFieldCorrection();
                        } else {    
                            nvMoCompParams.destinationField = 1;
                            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                            nvDoIntraFieldCorrection();
                        }    
                    } else {
                        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                        nvDoIntraFieldCorrection();
                        nvMoCompParams.destinationField = 1;
                        nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                        nvDoIntraFieldCorrection();
                    }

                    // Restore texture0 pitch to default value
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);

                    nvPusherAdjust(2);
                } else {
                    nvMoCompParams.blockWidth = 32;

                    if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (correctionType == CORRECTION_FIRST_PASS)) {
                        if (nvMoCompParams.destinationFieldIs0) {
                            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                            nvDoAllIntraFieldCorrections(8, 2);
                        } else {
                            nvMoCompParams.destinationField = 1;
                            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                            nvDoAllIntraFieldCorrections(8, 2);
                        }
                    } else {
                        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                        nvDoAllIntraFieldCorrections(8, 2);
                        nvMoCompParams.destinationField = 1;
                        nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                        nvDoAllIntraFieldCorrections(8, 2);
                    }    
                }
            }
            
            if (pMacroblock->macroblockType != MB_INTRA) {           
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(2);
            }
        } else {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset);

            nvPusherAdjust(2);

            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

                // Temporarily change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);

                if (pMacroblock->macroblockType != MB_INTRA) {          
                    nvDoFrameCorrection();
                } else
                    nvDoIntraFrameCorrection();

                // Restore texture0 pitch to default value
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                if (pMacroblock->macroblockType != MB_INTRA) {          
                    nvDoAllFrameCorrections();
                } else
                    nvDoAllIntraFrameCorrections();
            }
        }

        IDCTIndex += 4;

    } else {

        nvMoCompParams.blockWidth = 32;
        nvMoCompParams.blockHeight = 32;

        if ((pMacroblock->DCTType == DCT_FIELD) && (nvMoCompParams.surfaceLumaPitch >= 1024) && (correctionType == CORRECTION_FIRST_PASS)) {

            if (blockPattern & CBP_Y0) {

                if (nvMoCompParams.destinationFieldIs0) {
                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.destinationField = 0; // Component Y0 is in destination field 0
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                    if (pMacroblock->macroblockType != MB_INTRA)           
                        nvDoFieldCorrection();
                    else
                        nvDoIntraFieldCorrection();
                }
                
                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {

                if (nvMoCompParams.destinationFieldIs0) {
                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.destinationField = 0; // Component Y1 is in destination field 0
                    nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    
                    if (pMacroblock->macroblockType != MB_INTRA)           
                        nvDoFieldCorrection();
                    else
                        nvDoIntraFieldCorrection();
                }
                
                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {

                if (!nvMoCompParams.destinationFieldIs0) {
                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.destinationField = 1; // Component Y2 is in destination field 1
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                    if (pMacroblock->macroblockType != MB_INTRA)           
                        nvDoFieldCorrection();
                    else
                        nvDoIntraFieldCorrection();
                }
                
                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {

                if (!nvMoCompParams.destinationFieldIs0) {
                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.destinationField = 1; // Component Y3 is in destination field 1
                    nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                    if (pMacroblock->macroblockType != MB_INTRA)           
                        nvDoFieldCorrection();
                    else
                        nvDoIntraFieldCorrection();
                }
                
                IDCTIndex++;
            }

        } else {

            if (blockPattern & CBP_Y0) {

                nvMoCompParams.correctionField = 0;
                nvMoCompParams.destinationField = 0; // Component Y0 is in destination field 0
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                if (pMacroblock->DCTType == DCT_FIELD)
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                else
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                if (pMacroblock->macroblockType != MB_INTRA)           
                    nvDoFieldCorrection();
                else
                    nvDoIntraFieldCorrection();

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.destinationField = 0; // Component Y1 is in destination field 0
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                if (pMacroblock->DCTType == DCT_FIELD)
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                else
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                
                if (pMacroblock->macroblockType != MB_INTRA)           
                    nvDoFieldCorrection();
                else
                    nvDoIntraFieldCorrection();

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                if (pMacroblock->DCTType == DCT_FIELD) {
                    nvMoCompParams.destinationField = 1; // Component Y2 is in destination field 1
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                } else {
                    nvMoCompParams.destinationField = 0;
                    nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;
                }
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                if (pMacroblock->macroblockType != MB_INTRA)           
                    nvDoFieldCorrection();
                else
                    nvDoIntraFieldCorrection();

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                if (pMacroblock->DCTType == DCT_FIELD) {
                    nvMoCompParams.destinationField = 1; // Component Y3 is in destination field 1
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                } else {
                    nvMoCompParams.destinationField = 0;
                    nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;
                }
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                if (pMacroblock->macroblockType != MB_INTRA)           
                    nvDoFieldCorrection();
                else
                    nvDoIntraFieldCorrection();

                IDCTIndex++;
            }
        }

        if (pMacroblock->DCTType == DCT_FIELD) {
            // Must temporarily set destination surface pitch back to double it's normal frame pitch
            dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

            if (pMacroblock->macroblockType != MB_INTRA) {           
                // Temporarily change texture1 pitch to match destination surface pitch
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(2);
            }
        }
    }

} /* nvCorrectCelsiusFrameLumaMacroblock */


/*
 * nvCorrectCelsiusFrameChromaMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long chromaVOffset;
    BYTE blockPattern;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) {

        IDCTIndex += 4;

    } else {

        if (blockPattern & CBP_Y0)
            IDCTIndex++;

        if (blockPattern & CBP_Y1)
            IDCTIndex++;

        if (blockPattern & CBP_Y2)
            IDCTIndex++;

        if (blockPattern & CBP_Y3)
            IDCTIndex++;
    }

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    // Chroma IDCTs are always frame based

    if (blockPattern & (CBP_CB | CBP_CR)) {

        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockWidth = 32;
        nvMoCompParams.blockHeight = 32;
        nvMoCompParams.blockX = pMacroblock->hOffset << 1;
        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

        if (pMacroblock->macroblockType != MB_INTRA)           
            nvDoFrameCorrection();
        else
            nvDoIntraFrameCorrection();
    }

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectCelsiusFrameChromaMacroblock */


/*
 * nvDoAllCelsiusIntraDVDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusIntraDVDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    long                        yIncr = correctionYIncr << 18;
    long                        nextBlockYOffset = 32 << 16;
    
    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0) 
        blockX0 += nvMoCompParams.celsiusFieldXOffset;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV056_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x600000);
    else
        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0xC00000);
    
    nvPushMoCompQuadData(7);

    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(19);

    nvPusherAdjust(31);

    if (numBlocks == 4) {

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushMoCompQuadData(0);

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;

        nvPushMoCompQuadData(12);

        nvPusherAdjust(24);
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusIntraDVDFieldCorrections */



/*
 * nvDoAllCelsiusDVDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusDVDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    long yIncr = correctionYIncr << 18;
    long nextBlockYOffset = 32 << 16;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0) {
        texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset;
        blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x600000);
    else
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0xC00000);

    nvPushMoCompQuadData(3);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(15);

    nvPusherAdjust(27);

    if (numBlocks == 4) {

        texture1BlockX0 -= 32;
        texture1BlockX1 -= 32;
        texture1BlockY0 += nextBlockYOffset;
        texture1BlockY1 += nextBlockYOffset;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushMoCompQuadData(0);

        texture1BlockX0 += 32;
        texture1BlockX1 += 32;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;

        nvPushMoCompQuadData(12);

        nvPusherAdjust(24);
    }
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusDVDFieldCorrections */


/*
 * nvDoCelsiusIntraDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusIntraDVDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(4);
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusIntraDVDFieldCorrection */


/*
 * nvDoOptimizedCelsiusIntraDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoOptimizedCelsiusIntraDVDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoOptimizedCelsiusIntraDVDFieldCorrection */


/*
 * nvDoCelsiusDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusDVDFieldCorrection(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0) {
        texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset;
        blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusDVDFieldCorrection */



/*
 * nvDoAllCelsiusIntraHDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusIntraHDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    long                        yIncr = correctionYIncr << 18;
    long                        nextBlockYOffset = 32 << 16;
    
    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV056_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x600000);
    else
        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0xC00000);
    
    nvPushMoCompQuadData(7);

    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(19);

    nvPusherAdjust(31);

    if (numBlocks == 4) {

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushMoCompQuadData(0);

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;

        nvPushMoCompQuadData(12);

        nvPusherAdjust(24);
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusIntraHDFieldCorrections */



/*
 * nvDoAllCelsiusHDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusHDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    long yIncr = correctionYIncr << 18;
    long nextBlockYOffset = 32 << 16;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;

    if (nvMoCompParams.destinationField != nvMoCompParams.currentDestinationField) {

        if (nvMoCompParams.destinationField != 0) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceLumaPitch);
        } else {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset);
        }
        nvPusherAdjust(2);

        nvMoCompParams.currentDestinationField = nvMoCompParams.destinationField;
    }

    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x600000);
    else
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0xC00000);

    nvPushMoCompQuadData(3);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(15);

    nvPusherAdjust(27);

    if (numBlocks == 4) {

        texture1BlockX0 -= 32;
        texture1BlockX1 -= 32;
        texture1BlockY0 += nextBlockYOffset;
        texture1BlockY1 += nextBlockYOffset;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushMoCompQuadData(0);

        texture1BlockX0 += 32;
        texture1BlockX1 += 32;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;

        nvPushMoCompQuadData(12);

        nvPusherAdjust(24);
    }
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusHDFieldCorrections */


/*
 * nvDoCelsiusIntraHDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusIntraHDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(4);
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusIntraHDFieldCorrection */


/*
 * nvDoOptimizedCelsiusIntraHDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoOptimizedCelsiusIntraHDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoOptimizedCelsiusIntraHDFieldCorrection */


/*
 * nvDoCelsiusHDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusHDFieldCorrection(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;

    if (nvMoCompParams.destinationField != nvMoCompParams.currentDestinationField) {

        if (nvMoCompParams.destinationField != 0) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceLumaPitch);
        } else {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset);
        }
        nvPusherAdjust(2);

        nvMoCompParams.currentDestinationField = nvMoCompParams.destinationField;
    }
    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusHDFieldCorrection */



/*
 * nvCorrectCelsiusIntraField
 *
 * Processes LUMA blocks in an IntraField then makes a 2nd pass and processes chroma blocks
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusIntraField(LPNVDECODEMACROBLOCK pFirstMacroblock, long macroblockCount)
{
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    LPNVDECODEMACROBLOCK        pMacroblock;
    unsigned long               IDCTIndex;
    unsigned long               dwSurfaceOffset;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1 = 64;
    long                        texture1BlockY1 = 32 << 16;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0;
    long                        texture0BlockX1 = 64;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    int                         n;
    int                         i;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 1;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(4);
    
    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
        nvMoCompParams.destinationField = 0;
    else    
        nvMoCompParams.destinationField = 1;

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex;
        blockPattern = pMacroblock->codedBlockPattern;

        if (pMacroblock->DCTType == DCT_FIELD) {
            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 16;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;

                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvDoOptimizedIntraFieldCorrection();
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoOptimizedIntraFieldCorrection();

                // IDCTIndex += 2;
                
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY += 16;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvDoOptimizedIntraFieldCorrection();
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoOptimizedIntraFieldCorrection();
                
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                nvDoAllIntraFieldCorrections(8, 4);
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoAllIntraFieldCorrections(8, 4);
            }
        } else {
            if (blockPattern >= 0xFC) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoOptimizedIntraFieldCorrection();
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;

                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);
                
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                nvDoOptimizedIntraFieldCorrection();

                // IDCTIndex++;

                nvMoCompParams.blockX += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                nvDoOptimizedIntraFieldCorrection();

                IDCTIndex++;

                nvMoCompParams.blockX -= 32;
                nvMoCompParams.blockY += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                nvDoOptimizedIntraFieldCorrection();

                IDCTIndex++;

                nvMoCompParams.blockX += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                nvDoOptimizedIntraFieldCorrection();

                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }    
        }
        
        pMacroblock++;
    }
    
    nvPusherStart(TRUE);

    // Chroma IDCTs are always frame based

    dwSurfaceOffset = 0; // Assume destination field 0
    
    if (nvMoCompParams.destinationField != 0)
        dwSurfaceOffset += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    while (n >= 8) {

        n -= 8;
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x1800000);
        
        i = 3;
        
        while (i < 99) {        
            IDCTIndex = pMacroblock->firstIDCTIndex + 4;

            texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
            texture0BlockY1 = texture0BlockY0 + 32;
            texture0BlockY1 <<= 16;
            texture0BlockY0 <<= 16;

            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

            blockX0 = dwSurfaceOffset + (pMacroblock->hOffset << 2) - nvMoCompParams.celsiusDestinationViewportXOffset;
            blockY0 = nvMoCompParams.blockY;
            blockY0 <<= 16;
            blockX1 = blockX0 + 64;
            blockX1 &= 0x0000FFFF;
            blockX0 &= 0x0000FFFF;
            blockY1 = nvMoCompParams.blockY + 32;
            blockY1 <<= 16;

            nvPushMoCompQuadData(i);
            
            i += 12;

            pMacroblock++;
        }
        
        nvPushData(i, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        i++;

        nvPushData(i, NV056_SET_BEGIN_END_OP_END);

        i++;
    
        nvPusherAdjust(i);
    }

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex + 4;

        texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
        texture0BlockY1 = texture0BlockY0 + 32;
        texture0BlockY1 <<= 16;
        texture0BlockY0 <<= 16;

        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

        blockX0 = dwSurfaceOffset + (pMacroblock->hOffset << 2) - nvMoCompParams.celsiusDestinationViewportXOffset;
        blockY0 = nvMoCompParams.blockY;
        blockY0 <<= 16;
        blockX1 = blockX0 + 64;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY1 = nvMoCompParams.blockY + 32;
        blockY1 <<= 16;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x300000);

        nvPushMoCompQuadData(3);

        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

        pMacroblock++;
    }

} /* nvCorrectCelsiusIntraField */


/*
 * nvCorrectCelsiusFieldMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 511 assuming all blocks are 4 texels high (by 16 texels wide with 8 texels per field).
 *
 */
void __stdcall nvCorrectCelsiusFieldMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long               IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 1;

    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
        nvMoCompParams.destinationField = 0;
    else    
        nvMoCompParams.destinationField = 1;

    if (pMacroblock->macroblockType != MB_INTRA) {          
        if  ((blockPattern >= 0xFC) || 
            ((pMacroblock->DCTType == DCT_FIELD) &&
            ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)))) {

            if (pMacroblock->DCTType == DCT_FIELD) {
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();

                    // IDCTIndex += 2;
                    
                    nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();

                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();
                    
                } else {
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoAllFieldCorrections(8, 4);
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoAllFieldCorrections(8, 4);
                }
            } else {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoFieldCorrection();
            }
            
            IDCTIndex += 4;

        } else {

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
            }

            if (blockPattern & CBP_Y0) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY = 16;
                    nvDoFieldCorrection();
                }            

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }
        }
        
#ifdef  DEBUG
        if (moCompDebugLevel < 3) {
#endif  // DEBUG

        // Chroma IDCTs are always frame based

        if (blockPattern & (CBP_CB | CBP_CR)) {

            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockWidth = 64;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

            nvDoFieldCorrection();
        }

#ifdef  DEBUG
        }
#endif  // DEBUG

    } else { // MB_INTRA

        // Change texture1 surface offset to point to block of half bias values (0x80)
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

        // Change texture1 pitch to 16 bytes
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(3, 16 << 16); // half bias Intra block pitch

        nvPusherAdjust(4);
        
        if  ((blockPattern >= 0xFC) || 
            ((pMacroblock->DCTType == DCT_FIELD) &&
            ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)))) {

            if (pMacroblock->DCTType == DCT_FIELD) {
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoOptimizedIntraFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();

                    // IDCTIndex += 2;
                    
                    nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();
                    
                } else {
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoAllIntraFieldCorrections(8, 4);
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoAllIntraFieldCorrections(8, 4);
                }
            } else {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoOptimizedIntraFieldCorrection();
            }
            
            IDCTIndex += 4;

        } else {

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
            }
    
            if (blockPattern & CBP_Y0) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY = 16;
                    nvDoOptimizedIntraFieldCorrection();
                }            

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }
        
        }
        
    #ifdef  DEBUG
        if (moCompDebugLevel < 3) {
    #endif  // DEBUG

        // Chroma IDCTs are always frame based

        if (blockPattern & (CBP_CB | CBP_CR)) {

            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockWidth = 64;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

            nvDoOptimizedIntraFieldCorrection();
        }

#ifdef  DEBUG
        }
#endif  // DEBUG
    }
} /* nvCorrectCelsiusFieldMacroblock */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\MoInitKelvin.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoInitKelvin.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

extern NVMOCOMPPARAMS nvMoCompParams;

/*
 * nvInitKelvinForMoComp
 *
 * Performs basic motion comp initialization of the kelvin class object
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitKelvinForMoComp(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst;
    unsigned long               surfaceWidth;
    unsigned long               surfaceHeight;
    unsigned long               surfacePitch;
    unsigned long               tmpVal;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    float                       xTrans, yTrans, zTrans;

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(NULL)) {
            return FALSE;
        }
    }

	if(dstx == NULL)	//it happens with WinDVD
		return FALSE;

    dst = dstx->lpGbl;
    surfaceWidth = dst->wWidth;
    surfaceHeight = dst->wHeight;
    surfacePitch = dst->lPitch;

    pDriverData->dwMostRecentHWUser = MODULE_ID_DDRAW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Clear current IDCT context Dma
    pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;

    // Reset current vertex mode
    nvMoCompParams.vertexMode = 0;

    // Reset current data format
    nvMoCompParams.dataFormat = 0;

    // Reset the kelvin context Dmas to use the default video context Dma
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData(1, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_A | 0x40000);
    nvPushData(3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_B | 0x40000);
    nvPushData(5, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_STATE | 0x40000);
    nvPushData(7, NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_COLOR | 0x40000);
    nvPushData(9, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_ZETA | 0x40000);
    nvPushData(11, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_CONTEXT_DMA_VERTEX_A | 0x40000);
    nvPushData(13, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_CONTEXT_DMA_VERTEX_B | 0x40000);
    nvPushData(15, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_CONTEXT_DMA_SEMAPHORE | 0x40000);
    nvPushData(17, NV01_NULL_OBJECT);

    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_CONTEXT_DMA_REPORT | 0x40000);
    nvPushData(19, NV01_NULL_OBJECT);

    nvPusherAdjust(20);

    // Set surface clip rectangle
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    // pitch << 1
    nvPushData(1, ((surfacePitch << 17) | 0));

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    // height << 1 which is at least enough for luma height + chroma height
    nvPushData(3, ((surfaceHeight << 17) | 0));

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_WINDOW_CLIP_TYPE | 0x40000);
    nvPushData(5, NV097_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);

    // Set up one window clip rectangle to be the rendered area
    // All the other rectangles are deactivated
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_WINDOW_CLIP_HORIZONTAL(0) | 0x200000);
    nvPushData(7, ((4095 << 16) | 0));
    nvPushData(8, 0);
    nvPushData(9, 0);
    nvPushData(10, 0);
    nvPushData(11, 0);
    nvPushData(12, 0);
    nvPushData(13, 0);
    nvPushData(14, 0);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_WINDOW_CLIP_VERTICAL(0) | 0x200000);
    nvPushData(16, ((4095 << 16) | 0));
    nvPushData(17, 0);
    nvPushData(18, 0);
    nvPushData(19, 0);
    nvPushData(20, 0);
    nvPushData(21, 0);
    nvPushData(22, 0);
    nvPushData(23, 0);

    nvPusherAdjust(24);

    // Set Control0 defaults
    tmpVal = (NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_PASS << 28) |
             (NV097_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE << 24) |
             (NV097_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE << 20) |
             (NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE << 16) |
             (NV097_SET_CONTROL0_Z_FORMAT_FIXED << 12) |
             (NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTROL0 | 0x40000);
    nvPushData(1, tmpVal);

    nvPusherAdjust(2);

    // Make sure to disable any transform program which may be running in D3D
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TRANSFORM_EXECUTION_MODE | 0x40000);
    nvPushData(1, ((NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV << 2) |
                    NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED));

    nvPusherAdjust(2);

    // Load Projection, ModelView, and inverse ModelView matrix with identity
    fBuffer[0]  = 1.0; fBuffer[1]  = 0.0; fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0; fBuffer[5]  = 1.0; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0; fBuffer[9]  = 0.0; fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0; fBuffer[13] = 0.0; fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_PROJECTION_MATRIX(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPusherAdjust(17);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_MODEL_VIEW_MATRIX0(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPusherAdjust(17);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPusherAdjust(17);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1; // Surface is always referenced by hardware in field mode

    tmpVal = (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
             (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
             (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
              NV097_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    // Set up viewport
    xTrans = (float)(1.0 / 32.0); // hardware epsilon
    yTrans = (float)(1.0 / 32.0);
    zTrans = 0.0;

    // Load composite matrix assuming quarter pel scaling of surface coordinates
    if (pDriverData->bMCHorizontallyDownscale1080i)
        fBuffer[0]  = 0.1875; // quarter pel xScale
    else
        fBuffer[0]  = 0.25; // quarter pel xScale
    fBuffer[1]  = 0.0;
    fBuffer[2]  = 0.0;
    fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;
    fBuffer[5]  = 0.25; // quarter pel yScale
    fBuffer[6]  = 0.0;
    fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;
    fBuffer[9]  = 0.0;
    fBuffer[10] = 1.0;
    fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;
    fBuffer[13] = 0.0;
    fBuffer[14] = 0.0;
    fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMPOSITE_MATRIX(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPusherAdjust(17);

    // Set viewport offset separately
    fBuffer[0] = xTrans;
    fBuffer[1] = yTrans;
    fBuffer[2] = zTrans;
    fBuffer[3] = 0.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_VIEWPORT_OFFSET(0) | 0x100000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[1]);
    nvPushData(3, ftol[2]);
    nvPushData(4, ftol[3]);

    nvPusherAdjust(5);

#if (NVARCH >= 0x20)
    // Set front and back clipping
    fBuffer[0] = 0.0;
    fBuffer[1] = KELVIN_Z_SCALE24;
#endif

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CLIP_MIN | 0x80000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[1]);

    nvPusherAdjust(3);

    // Set light control
    tmpVal = (NV097_SET_LIGHT_CONTROL_SOUT_ZERO_OUT << 17) |
             (NV097_SET_LIGHT_CONTROL_LOCALEYE_FALSE << 16) |
              NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_LIGHT_CONTROL | 0x40000);
    nvPushData(1, tmpVal);

    // Disable color material
    tmpVal = (NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_DISABLE << 14) |
             (NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_DISABLE << 12) |
             (NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_DISABLE << 10) |
             (NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_DISABLE << 8) |
             (NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DISABLE << 6) |
             (NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DISABLE << 4) |
             (NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DISABLE << 2) |
              NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_DISABLE;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COLOR_MATERIAL | 0x40000);
    nvPushData(3, tmpVal);

    nvPusherAdjust(4);

    // Set default fog mode
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_MODE | 0x40000);
    nvPushData(1, NV097_SET_FOG_MODE_V_LINEAR);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_GEN_MODE | 0x40000);
//    nvPushData(3, NV097_SET_FOG_GEN_MODE_V_SPEC_ALPHA);
    nvPushData(3, NV097_SET_FOG_GEN_MODE_V_FOG_X);

    // Disable fog
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_ENABLE | 0x40000);
    nvPushData(5, NV097_SET_FOG_ENABLE_V_FALSE);

    // Set default fog color
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_COLOR | 0x40000);
    nvPushData(7, 0xFFFFFFFF);

    nvPusherAdjust(8);

    // Disable almost everything

    // Disable alpha test
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_ALPHA_TEST_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_ALPHA_TEST_ENABLE_V_FALSE);

    // Disable blending
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BLEND_ENABLE | 0x40000);
    nvPushData(3, NV097_SET_BLEND_ENABLE_V_FALSE);

    // Disable culling
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CULL_FACE_ENABLE | 0x40000);
    nvPushData(5, NV097_SET_CULL_FACE_ENABLE_V_FALSE);

    // Disable depth test
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_DEPTH_TEST_ENABLE | 0x40000);
    nvPushData(7, NV097_SET_DEPTH_TEST_ENABLE_V_FALSE);

    // Disable dither
    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_DITHER_ENABLE | 0x40000);
    nvPushData(9, NV097_SET_DITHER_ENABLE_V_FALSE);

    // Disable lighting
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_LIGHTING_ENABLE | 0x40000);
    nvPushData(11, NV097_SET_LIGHTING_ENABLE_V_FALSE);

    // Disable point parameters computation
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POINT_PARAMS_ENABLE | 0x40000);
    nvPushData(13, NV097_SET_POINT_PARAMS_ENABLE_V_FALSE);

    // Disable point smoothing
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POINT_SMOOTH_ENABLE | 0x40000);
    nvPushData(15, NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable line smoothing
    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_LINE_SMOOTH_ENABLE | 0x40000);
    nvPushData(17, NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable polygon smoothing
    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLY_SMOOTH_ENABLE | 0x40000);
    nvPushData(19, NV097_SET_POLY_SMOOTH_ENABLE_V_FALSE);

    // Disable stippling
    nvPushData(20, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_STIPPLE_CONTROL | 0x40000);
    nvPushData(21, NV097_SET_STIPPLE_CONTROL_V_OFF);

    // Disable skinning
    nvPushData(22, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_SKIN_MODE | 0x40000);
    nvPushData(23, NV097_SET_SKIN_MODE_V_OFF);

    // Disable stencil test
    nvPushData(24, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_STENCIL_TEST_ENABLE | 0x40000);
    nvPushData(25, NV097_SET_STENCIL_TEST_ENABLE_V_FALSE);

    // Disable polygon offset point
    nvPushData(26, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLY_OFFSET_POINT_ENABLE | 0x40000);
    nvPushData(27, NV097_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE);

    // Disable polygon offset line
    nvPushData(28, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLY_OFFSET_LINE_ENABLE | 0x40000);
    nvPushData(29, NV097_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE);

    // Disable polygon offset fill
    nvPushData(30, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLY_OFFSET_FILL_ENABLE | 0x40000);
    nvPushData(31, NV097_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);

    nvPusherAdjust(32);

    // Set default alpha function
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_ALPHA_FUNC | 0x40000);
    nvPushData(1, NV097_SET_ALPHA_FUNC_V_ALWAYS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_ALPHA_REF | 0x40000);
    nvPushData(3, 0);

    // Initialize blend factors for later use
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BLEND_FUNC_SFACTOR | 0x40000);
    nvPushData(5, NV097_SET_BLEND_FUNC_SFACTOR_V_ONE);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BLEND_FUNC_DFACTOR | 0x40000);
    nvPushData(7, NV097_SET_BLEND_FUNC_DFACTOR_V_ONE);

    // Set default blend color
    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BLEND_COLOR | 0x40000);
    nvPushData(9, 0);

    // Set default blend equation
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BLEND_EQUATION | 0x40000);
    nvPushData(11, NV097_SET_BLEND_EQUATION_V_FUNC_ADD_SIGNED);

    nvPusherAdjust(12);

    // Set depth function
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_DEPTH_FUNC | 0x40000);
    nvPushData(1, NV097_SET_DEPTH_FUNC_V_ALWAYS);

    // Set color mask
    tmpVal = (NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE << 24) |
             (NV097_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE << 16) |
             (NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE << 8) |
              NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COLOR_MASK | 0x40000);
    nvPushData(3, tmpVal);

    // Set depth mask
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_DEPTH_MASK | 0x40000);
    nvPushData(5, NV097_SET_DEPTH_MASK_V_FALSE);

    nvPusherAdjust(6);

    // Initialize stencil state (test already disabled above)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_STENCIL_MASK | 0x40000);
    nvPushData(1, 0x000000FF);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_STENCIL_FUNC | 0x40000);
    nvPushData(3, NV097_SET_STENCIL_FUNC_V_ALWAYS);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_STENCIL_FUNC_REF | 0x40000);
    nvPushData(5, 0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_STENCIL_FUNC_MASK | 0x40000);
    nvPushData(7, 0x000000FF);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_STENCIL_OP_FAIL | 0x40000);
    nvPushData(9, NV097_SET_STENCIL_OP_FAIL_V_KEEP);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_STENCIL_OP_ZFAIL | 0x40000);
    nvPushData(11, NV097_SET_STENCIL_OP_ZFAIL_V_KEEP);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_STENCIL_OP_ZPASS | 0x40000);
    nvPushData(13, NV097_SET_STENCIL_OP_ZPASS_V_KEEP);

    nvPusherAdjust(14);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SHADE_MODE | 0x40000);
    nvPushData(1, NV097_SET_SHADE_MODE_V_FLAT);

    fBuffer[0] = 0.0;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLYGON_OFFSET_SCALE_FACTOR | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLYGON_OFFSET_BIAS | 0x40000);
    nvPushData(5, ftol[0]);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FRONT_POLYGON_MODE | 0x40000);
    nvPushData(7, NV097_SET_FRONT_POLYGON_MODE_V_FILL);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BACK_POLYGON_MODE | 0x40000);
    nvPushData(9, NV097_SET_BACK_POLYGON_MODE_V_FILL);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_CULL_FACE | 0x40000);
    nvPushData(11, NV097_SET_CULL_FACE_V_BACK);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_FRONT_FACE | 0x40000);
    nvPushData(13, NV097_SET_FRONT_FACE_V_CCW);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_NORMALIZATION_ENABLE | 0x40000);
    nvPushData(15, NV097_SET_NORMALIZATION_ENABLE_V_FALSE);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_EDGE_FLAG | 0x40000);
    nvPushData(17, NV097_SET_EDGE_FLAG_V_TRUE);

    nvPusherAdjust(18);

    // Set material emission
    fBuffer[0] = 0.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_MATERIAL_EMISSION(0) | 0xC0000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[0]);
    nvPushData(3, ftol[0]);

    // Disable specular
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SPECULAR_ENABLE | 0x40000);
    nvPushData(5, NV097_SET_SPECULAR_ENABLE_V_FALSE);

    // Disable all lights
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_LIGHT_ENABLE_MASK | 0x40000);
    nvPushData(7, 0);

    nvPusherAdjust(8);

    // Disable texgen modes for now (OpenGL default is EYE_LINEAR)

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXGEN_S(0) | 0x40000);
    nvPushData(1, NV097_SET_TEXGEN_S_V_DISABLE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXGEN_T(0) | 0x40000);
    nvPushData(3, NV097_SET_TEXGEN_T_V_DISABLE);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXGEN_R(0) | 0x40000);
    nvPushData(5, NV097_SET_TEXGEN_R_V_DISABLE);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXGEN_Q(0) | 0x40000);
    nvPushData(7, NV097_SET_TEXGEN_Q_V_DISABLE);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXGEN_S(1) | 0x40000);
    nvPushData(9, NV097_SET_TEXGEN_S_V_DISABLE);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXGEN_T(1) | 0x40000);
    nvPushData(11, NV097_SET_TEXGEN_T_V_DISABLE);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXGEN_R(1) | 0x40000);
    nvPushData(13, NV097_SET_TEXGEN_R_V_DISABLE);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXGEN_Q(1) | 0x40000);
    nvPushData(15, NV097_SET_TEXGEN_Q_V_DISABLE);

    nvPusherAdjust(16);

    // We don't use texgen so we skip setting texgen planes

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SWATH_WIDTH | 0x40000);
    nvPushData(1, NV097_SET_SWATH_WIDTH_V_OFF);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SHADER_STAGE_PROGRAM | 0x40000);
    nvPushData(3, ((NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE << 15) |
                   (NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE << 10) |
                   (NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_2D_PROJECTIVE << 5) |
                    NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE));

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SHADER_CLIP_PLANE_MODE | 0x40000);
    nvPushData(5, 0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SHADER_OTHER_STAGE_INPUT | 0x40000);
    nvPushData(7, 0);

    // This is set once and forgotten. It puts the class in OGL flat shade mode.
    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FLAT_SHADE_OP | 0x40000);
    nvPushData(9, NV097_SET_FLAT_SHADE_OP_V_LAST_VTX);

    nvPusherAdjust(10);

    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    // Set default fog parameters
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_PARAMS(0) | 0xC0000);
    nvPushData(1, ftol[1]);                     // K0
    nvPushData(2, ftol[1]);                     // K1
    nvPushData(3, ftol[0]);                     // K2

    // Set fog plane
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_PLANE(0) | 0x100000);
    nvPushData(5, ftol[0]);
    nvPushData(6, ftol[0]);
    nvPushData(7, ftol[1]);
    nvPushData(8, ftol[0]);

    nvPusherAdjust(9);

    // Initialize some vertex attributes
    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    // Set color for MODULATE blend mode
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_DIFFUSE_COLOR4F(0) | 0x100000);
    nvPushData(1, ftol[1]);
    nvPushData(2, ftol[1]);
    nvPushData(3, ftol[1]);
    nvPushData(4, ftol[1]);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SPECULAR_COLOR3F(0) | 0xC0000);
    nvPushData(6, ftol[0]);
    nvPushData(7, ftol[0]);
    nvPushData(8, ftol[0]);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXCOORD0_4F(0) | 0x100000);
    nvPushData(10, ftol[0]);
    nvPushData(11, ftol[0]);
    nvPushData(12, ftol[0]);
    nvPushData(13, ftol[1]);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXCOORD1_4F(0) | 0x100000);
    nvPushData(15, ftol[0]);
    nvPushData(16, ftol[0]);
    nvPushData(17, ftol[0]);
    nvPushData(18, ftol[1]);

    nvPushData(19, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_NORMAL3F(0) | 0xC0000);
    nvPushData(20, ftol[0]);
    nvPushData(21, ftol[0]);
    nvPushData(22, ftol[1]);

    nvPushData(23, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_FOG1F | 0x40000);
    nvPushData(24, ftol[0]);

    nvPushData(25, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_WEIGHT1F | 0x40000);
    nvPushData(26, ftol[1]);

    nvPusherAdjust(27);

    // Load texture matrices assuming quarter pel scaling of texture coordinates
    if (pDriverData->bMCHorizontallyDownscale1080i)
        fBuffer[0]  = 0.1875;
    else
        fBuffer[0]  = 0.25;

                        fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_MATRIX0(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_KELVIN) +
        NV097_SET_TEXTURE_MATRIX1(0) | 0x400000);
    nvPushData(18, ftol[0]);
    nvPushData(19, ftol[4]);
    nvPushData(20, ftol[8]);
    nvPushData(21, ftol[12]);
    nvPushData(22, ftol[1]);
    nvPushData(23, ftol[5]);
    nvPushData(24, ftol[9]);
    nvPushData(25, ftol[13]);
    nvPushData(26, ftol[2]);
    nvPushData(27, ftol[6]);
    nvPushData(28, ftol[10]);
    nvPushData(29, ftol[14]);
    nvPushData(30, ftol[3]);
    nvPushData(31, ftol[7]);
    nvPushData(32, ftol[11]);
    nvPushData(33, ftol[15]);

    nvPusherAdjust(34);

    // Disable logic ops
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_LOGIC_OP_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_LOGIC_OP_ENABLE_V_FALSE);

    // Disable Z min/max culling
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_ZMIN_MAX_CONTROL | 0x40000);
    nvPushData(3, ((NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_TRUE << 8) |
                   (NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CLAMP << 4) |
                    NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_FALSE));

    // MUST set antialiasing control sample mask even though antialiasing is disabled
    // Disable antialiasing
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_ANTI_ALIASING_CONTROL | 0x40000);
    nvPushData(5, ((0xFFFF0000) |
                    NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_FALSE));

    // Disable z buffer compression
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMPRESS_ZBUFFER_EN | 0x40000);
    nvPushData(7, NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE);

    // Disable z stencil occlusion
    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_OCCLUDE_ZSTENCIL_EN | 0x40000);
    nvPushData(9, NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_DISABLE);

    // Disable two sided lighting
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TWO_SIDE_LIGHT_EN | 0x40000);
    nvPushData(11, NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE);

    // Disable z pass pixel counting
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_ZPASS_PIXEL_COUNT_ENABLE | 0x40000);
    nvPushData(13, NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_FALSE);

    nvPusherAdjust(14);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitKelvinForMoComp */



/*
 * nvInitKelvinForMoCompPrediction
 *
 * Performs final kelvin object motion comp initialization for
 * the prediction portion of the algorithm.
 *
 * For prediction, texture 0 is used for forward prediction, texture 1
 * is used for backward prediction.  These textures are just passed through
 * the register combiners to the final combiner.  The final combiner is
 * configured so that the fog coordinate is used to control the contribution
 * of each texture in the final output.  A fog value of 0.0 selects forward
 * prediction, 0.5 selects bidirectional prediction, and 1.0 selects backward
 * prediction.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = (1.0)constantColor0, B = texture0, C = (1.0)constantColor0, D = texture1
 *      OUTPUT: spare0 = A * B, spare1 = C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: A.rgb = Fog.a, B = spare1, C = spare0, D = 0
 *      OUTPUT: B * A + C * (1.0 - A)
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitKelvinForMoCompPrediction(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               dwSurfaceOffset;
    unsigned long               tmpVal;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    unsigned long               moCompICW;
    unsigned long               moCompOCW;
    unsigned long               moCompFinalCW0;
    unsigned long               moCompFinalCW1;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Initialize surface offsets
    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
    nvPushData(3, dwSurfaceOffset);

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    nvPushData(5, dwSurfaceOffset);

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(7, dwSurfaceOffset);

    nvPusherAdjust(8);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1; // Surface is always referenced by hardware in field mode

    tmpVal = (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
             (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
             (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
              NV097_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_MATRIX_ENABLE(0) | 0x100000);
    nvPushData(1, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(2, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(3, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(4, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);

    nvPusherAdjust(5);

    nvMoCompParams.dataFormat = DATA_FORMAT_LUMA;

    tmpVal = (1 << 16) | // 1 MIPMAP level
             (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) |
             (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
             (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
             (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(0) | 0x40000);
    nvPushData(1, tmpVal);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(1) | 0x40000);
    nvPushData(3, tmpVal);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(3) | 0x40000);
    nvPushData(7, tmpVal);

    tmpVal = (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE << 24) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE << 20) |
             (NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE << 16) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE << 12) |
             (NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE << 8) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE << 4) |
              NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE;

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_ADDRESS(0) | 0x40000);
    nvPushData(9, tmpVal);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(1) | 0x40000);
    nvPushData(11, tmpVal);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(2) | 0x40000);
    nvPushData(13, tmpVal);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(3) | 0x40000);
    nvPushData(15, tmpVal);

    nvPusherAdjust(16);

    pDriverData->dwMCTex0Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(0) | 0x40000);
    nvPushData(1, pDriverData->dwMCTex0Control0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(1) | 0x40000);
    nvPushData(3, pDriverData->dwMCTex1Control0);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(3) | 0x40000);
    nvPushData(7, tmpVal);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    nvPushData(9, surfacePitch << 16);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(11, surfacePitch << 16);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    nvPushData(13, surfacePitch << 16);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    nvPushData(15, surfacePitch << 16);

    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(0) | 0x40000);
    nvPushData(17, tmpVal);
    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(1) | 0x40000);
    nvPushData(19, tmpVal);
    nvPushData(20, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(2) | 0x40000);
    nvPushData(21, tmpVal);
    nvPushData(22, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(3) | 0x40000);
    nvPushData(23, tmpVal);

    tmpVal = (4094 << 16) | 2046; // Must be even and <= 4094

    nvPushData(24, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    nvPushData(25, tmpVal);
    nvPushData(26, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    nvPushData(27, tmpVal);
    nvPushData(28, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    nvPushData(29, tmpVal);
    nvPushData(30, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    nvPushData(31, tmpVal);

    nvPusherAdjust(32);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TRANSFORM_EXECUTION_MODE | 0x40000);
    nvPushData(1, ((NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV << 2) |
                    NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED));

    nvPusherAdjust(2);


    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {

        // Load composite and texture matrices assuming quarter pel horizontal scaling and eigth pel vertical
        // scaling of texture coordinates
        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;
        else
            fBuffer[0]  = 0.25;

                            fBuffer[1]  = 0.0;   fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;  fBuffer[5]  = 0.125; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;   fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;  fBuffer[13] = 0.0;   fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_MATRIX0(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPushData(17, dDrawSubchannelOffset(NV_DD_KELVIN) +
            NV097_SET_TEXTURE_MATRIX1(0) | 0x400000);
        nvPushData(18, ftol[0]);
        nvPushData(19, ftol[4]);
        nvPushData(20, ftol[8]);
        nvPushData(21, ftol[12]);
        nvPushData(22, ftol[1]);
        nvPushData(23, ftol[5]);
        nvPushData(24, ftol[9]);
        nvPushData(25, ftol[13]);
        nvPushData(26, ftol[2]);
        nvPushData(27, ftol[6]);
        nvPushData(28, ftol[10]);
        nvPushData(29, ftol[14]);
        nvPushData(30, ftol[3]);
        nvPushData(31, ftol[7]);
        nvPushData(32, ftol[11]);
        nvPushData(33, ftol[15]);

        nvPusherAdjust(34);
    }

    // Enable fog (mocomp fog modes set during default mocomp initialization)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_FOG_ENABLE_V_TRUE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our prediction moComp values
    // combiner0, RGB portion:   A = 1
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = 1
    // combiner0, RGB portion:   D = texture1

    moCompICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT << 29) |
                (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0 << 24) |

                (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                 NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_ICW(0) | 0x100000);
    nvPushData(1, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_ICW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x100000);
    nvPushData(6, moCompICW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_ICW);

    // Load combination factors
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(11, 0xFFFFFFFF); // 100%

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(13, 0xFFFFFFFF); // 100%

    nvPusherAdjust(14);

    // combiner0, RGB portion:   spare0 = texture0, spare1 = texture1
    moCompOCW = (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE << 19) |
                (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE << 18) |
                (NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT << 15) |
                (NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                (NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                (NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                (NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_0 << 8) |
                (NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_C << 4) |
                 NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_D;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_OCW(0) | 0x100000);
    nvPushData(1, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_OCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_OCW(0) | 0x100000);
    nvPushData(6, moCompOCW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_OCW);

    tmpVal = (NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL << 16) |
             (NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL << 12) |
             (NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB << 8) |
              NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE;

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_CONTROL | 0x40000);
    nvPushData(11, tmpVal);

    nvPusherAdjust(12);

    // Reconfigure fog unit to interpolate
    // fog factor in alpha
    // fog = 0.0: all texture0
    // fog = 0.5: equal parts of texture0 and texture1
    // fog = 1.0: all texture1

    moCompFinalCW0 = (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE << 28) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3 << 24) |   // fog

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D << 16) |   // spare1

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C << 8) |    // spare0

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |
                      NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0;           // 0

    moCompFinalCW1 = (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |   // 0

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |   // 0

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE << 13) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0 << 8) |    // 0xFF

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) |
                      NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE;

    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, moCompFinalCW0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, moCompFinalCW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitKelvinForMoCompPrediction */


/*
 * nvInitKelvinForMoCompCorrection
 *
 * Performs final kelvin object motion comp initialization for
 * the correction portion of the algorithm.
 *
 * For correction, texture 0 is used for the error terms, texture 1
 * is mapped over the source/destination.  The error terms are signed
 * and the textures are unsigned so the register combiners need to be
 * setup appropriately.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = (1.0)constantColor0, B = (signed)texture0, C = (1.0)constantColor0, D = (unsigned)texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitKelvinForMoCompCorrection(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               dwSurfaceOffset;
    unsigned long               texturePitch0;
    unsigned long               texturePitch1 = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               textureFormat0;
    unsigned long               textureFormat1;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    unsigned long               moCompICW;
    unsigned long               moCompOCW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Initialize surface offsets
    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
    nvPushData(3, dwSurfaceOffset);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    nvPushData(5, 0);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(7, dwSurfaceOffset);

    nvPusherAdjust(8);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);

    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        surfacePitch <<= 1; // Field surface is always referenced by hardware using double pitch

    tmpVal = (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
             (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
             (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
              NV097_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_MATRIX_ENABLE(0) | 0x100000);
    nvPushData(1, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(2, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(3, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(4, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);

    nvPusherAdjust(5);

    nvMoCompParams.dataFormat = DATA_FORMAT_CORRECTION;

    // Signed Y8
    textureFormat0 = (1 << 16) | // 1 MIPMAP level
                     (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8 << 8) |
                     (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
                     (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
                     (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
                      NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B;

    // Unsigned Y8
    textureFormat1 = (1 << 16) | // 1 MIPMAP level
                     (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) |
                     (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
                     (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
                     (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
                      NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(0) | 0x40000);
    nvPushData(1, textureFormat0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(1) | 0x40000);
    nvPushData(3, textureFormat1);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(2) | 0x40000);
    nvPushData(5, textureFormat1);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(3) | 0x40000);
    nvPushData(7, textureFormat1);

    tmpVal = (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE << 24) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE << 20) |
             (NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE << 16) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE << 12) |
             (NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE << 8) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE << 4) |
              NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE;

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_ADDRESS(0) | 0x40000);
    nvPushData(9, tmpVal);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(1) | 0x40000);
    nvPushData(11, tmpVal);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(2) | 0x40000);
    nvPushData(13, tmpVal);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(3) | 0x40000);
    nvPushData(15, tmpVal);

    nvPusherAdjust(16);

    // Correction textures ALWAYS have 8 byte frame pitches or 16 byte field pitches
    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        texturePitch0 = 16;
    else {
        texturePitch0 = 8;

        // Load composite and texture matrices assuming quarter pel scaling of texture coordinates
        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;
        else
            fBuffer[0]  = 0.25;

                            fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);

        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.25;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_MATRIX0(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;

        nvPushData(17, dDrawSubchannelOffset(NV_DD_KELVIN) +
            NV097_SET_TEXTURE_MATRIX1(0) | 0x400000);
        nvPushData(18, ftol[0]);
        nvPushData(19, ftol[4]);
        nvPushData(20, ftol[8]);
        nvPushData(21, ftol[12]);
        nvPushData(22, ftol[1]);
        nvPushData(23, ftol[5]);
        nvPushData(24, ftol[9]);
        nvPushData(25, ftol[13]);
        nvPushData(26, ftol[2]);
        nvPushData(27, ftol[6]);
        nvPushData(28, ftol[10]);
        nvPushData(29, ftol[14]);
        nvPushData(30, ftol[3]);
        nvPushData(31, ftol[7]);
        nvPushData(32, ftol[11]);
        nvPushData(33, ftol[15]);

        nvPusherAdjust(34);
    }

    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        texturePitch1 <<= 1; // Field textures are always referenced by hardware using double pitch

    pDriverData->dwMCTex0Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(0) | 0x40000);
    nvPushData(1, pDriverData->dwMCTex0Control0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(1) | 0x40000);
    nvPushData(3, pDriverData->dwMCTex1Control0);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(3) | 0x40000);
    nvPushData(7, tmpVal);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    nvPushData(9, texturePitch0 << 16);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(11, texturePitch1 << 16);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    nvPushData(13, texturePitch1 << 16);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    nvPushData(15, texturePitch1 << 16);

    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_BOX_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(0) | 0x40000);
    nvPushData(17, tmpVal);
    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(1) | 0x40000);
    nvPushData(19, tmpVal);
    nvPushData(20, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(2) | 0x40000);
    nvPushData(21, tmpVal);
    nvPushData(22, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(3) | 0x40000);
    nvPushData(23, tmpVal);

    tmpVal = (4094 << 16) | 2046; // Must be even and <= 4094

    nvPushData(24, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    nvPushData(25, (16 << 16) | 2044); // Must be even and <= 2046
    nvPushData(26, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    nvPushData(27, tmpVal);
    nvPushData(28, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    nvPushData(29, tmpVal);
    nvPushData(30, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    nvPushData(31, tmpVal);

    nvPusherAdjust(32);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our correction moComp values
    // combiner0, RGB portion:   A = 1
    // combiner0, RGB portion:   B = (signed)texture0
    // combiner0, RGB portion:   C = 1
    // combiner0, RGB portion:   D = (unsigned)texture1

    moCompICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                (NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                 NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_ICW(0) | 0x100000);
    nvPushData(1, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_ICW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x100000);
    nvPushData(6, moCompICW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_ICW);

    // Load combination factors
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(11, 0xFFFFFFFF); // 100%

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(13, 0x0); // 0%

    nvPusherAdjust(14);

    // combiner0, RGB portion:   texture0 + texture1
    // spare0 = A * B + C * D
    moCompOCW = (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE << 19) |
                (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE << 18) |
                (NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT << 15) |
                (NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                (NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                (NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                (NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C << 8) |
                (NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0 << 4) |
                 NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_OCW(0) | 0x100000);
    nvPushData(1, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_OCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_OCW(0) | 0x100000);
    nvPushData(6, moCompOCW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_OCW);

    tmpVal = (NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL << 16) |
             (NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL << 12) |
             (NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB << 8) |
              NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE;

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_CONTROL | 0x40000);
    nvPushData(11, tmpVal);

    nvPusherAdjust(12);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_KELVIN_FINAL_CW0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_KELVIN_FINAL_CW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitKelvinForMoCompCorrection */



/*
 * nvInitKelvinForMoCompConversion
 *
 * Performs final kelvin object motion comp initialization for
 * the format conversion portion of the algorithm.
 *
 * For conversion, texture0 is used to convert the luma values to 0x00Y100Y0 and
 * texture1 is used to convert the chroma values to 0xV000U000 which are then added together
 * thus allowing the conversion to take place in one pass.  The textures are modulated
 * with constant colors to select which component comes from which texture.
 * The output texture is just passed through the register combiners to the final combiner.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = constantColor0, B = texture0, C = constantColor1, D = texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitKelvinForMoCompConversion(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               texturePitch = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               moCompAlphaICW;
    unsigned long               moCompColorICW;
    unsigned long               moCompAlphaOCW;
    unsigned long               moCompColorOCW;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    if (pDriverData->bMCHorizontallyDownscale1080i) {
        // Restore default composite and texture matrices assuming quarter pel scaling of texture coordinates
        fBuffer[0]  = (float)0.1875; fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;           fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;           fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;           fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);
    }

    // Surface offsets are initialized in the format conversion function

    // Align surface pitch and set surface format and pitch
    surfacePitch = ((surfaceWidth << 1) + 127) & ~127; // YUY2 destination is twice the surface width
    surfacePitch |= (surfacePitch << 16);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    tmpVal = (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
             (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
             (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
              NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Just disable both texture matrices since these texture coordinates are unscaled
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_MATRIX_ENABLE(0) | 0x100000);
    nvPushData(1, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(2, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(3, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(4, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);

    nvPusherAdjust(5);

    nvMoCompParams.dataFormat = DATA_FORMAT_FOURCC_CONVERSION;

    tmpVal = (1 << 16) | // 1 MIPMAP level
             (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8 << 8) |
             (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
             (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
             (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(0) | 0x40000);
    nvPushData(1, tmpVal);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(1) | 0x40000);
    nvPushData(3, tmpVal);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(3) | 0x40000);
    nvPushData(7, tmpVal);

    tmpVal = (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE << 24) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE << 20) |
             (NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE << 16) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE << 12) |
             (NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE << 8) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE << 4) |
              NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE;

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_ADDRESS(0) | 0x40000);
    nvPushData(9, tmpVal);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(1) | 0x40000);
    nvPushData(11, tmpVal);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(2) | 0x40000);
    nvPushData(13, tmpVal);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(3) | 0x40000);
    nvPushData(15, tmpVal);

    nvPusherAdjust(16);

    pDriverData->dwMCTex0Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(0) | 0x40000);
    nvPushData(1, pDriverData->dwMCTex0Control0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(1) | 0x40000);
    nvPushData(3, pDriverData->dwMCTex1Control0);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(3) | 0x40000);
    nvPushData(7, tmpVal);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    nvPushData(9, texturePitch << 16);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(11, texturePitch << 16);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    nvPushData(13, texturePitch << 16);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    nvPushData(15, texturePitch << 16);

    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_BOX_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(0) | 0x40000);
    nvPushData(17, tmpVal);
    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(1) | 0x40000);
    nvPushData(19, tmpVal);
    nvPushData(20, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(2) | 0x40000);
    nvPushData(21, tmpVal);
    nvPushData(22, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(3) | 0x40000);
    nvPushData(23, tmpVal);

    tmpVal = (4094 << 16) | 2046; // Must be even and <= 4094

    nvPushData(24, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    nvPushData(25, tmpVal);
    nvPushData(26, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    nvPushData(27, tmpVal);
    nvPushData(28, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    nvPushData(29, tmpVal);
    nvPushData(30, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    nvPushData(31, tmpVal);

    nvPusherAdjust(32);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our format conversion moComp values
    // combiner0, Alpha portion:   A = 0
    // combiner0, Alpha portion:   B = 0
    // combiner0, Alpha portion:   C = constantColor1 (0xFF00FF00)
    // combiner0, Alpha portion:   D = texture1
    // combiner0, RGB portion:   A = constantColor0 (0x00FF00FF)
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = constantColor1 (0xFF00FF00)
    // combiner0, RGB portion:   D = texture1

    moCompAlphaICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE << 28) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0 << 24) |

                     (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE << 20) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0 << 16) |

                     (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE << 12) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE << 4) |
                      NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    moCompColorICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                     (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_ICW(0) | 0x100000);
    nvPushData(1, moCompAlphaICW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_ICW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x100000);
    nvPushData(6, moCompColorICW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_ICW);

    // Load combination factors
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(11, 0x00FF00FF); // luma

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(13, 0xFF00FF00); // chroma

    nvPusherAdjust(14);

    // combiner0, Alpha portion:    spare0 = A * B + C * D = texture1
    moCompAlphaOCW = (NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                     (NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                     (NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                      NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0;

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1
    moCompColorOCW = (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE << 19) |
                     (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE << 18) |
                     (NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT << 15) |
                     (NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_OCW(0) | 0x100000);
    nvPushData(1, moCompAlphaOCW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_OCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_OCW(0) | 0x100000);
    nvPushData(6, moCompColorOCW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_OCW);

    tmpVal = (NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL << 16) |
             (NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL << 12) |
             (NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB << 8) |
              NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE;

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_CONTROL | 0x40000);
    nvPushData(11, tmpVal);

    nvPusherAdjust(12);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_KELVIN_FINAL_CW0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_KELVIN_FINAL_CW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitKelvinForMoCompConversion */


/*
 * nvInitKelvinForMoCompTemporalFilter
 *
 * Performs final kelvin object motion comp initialization for
 * the intra frame field temporal filtering portion of the algorithm.
 *
 * For temporal filtering, texture0 is used to reference the top field and
 * texture1 is used to reference the bottom field which are then added together
 * thus allowing the filter to complete in one pass.  The textures are modulated
 * with constant colors to select the fraction of coverage which comes from which texture.
 * The output texture is just passed through the register combiners to the final combiner.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = constantColor0, B = texture0, C = constantColor1, D = texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitKelvinForMoCompTemporalFilter(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch;
    unsigned long               tmpVal;
    unsigned long               moCompAlphaICW;
    unsigned long               moCompColorICW;
    unsigned long               moCompAlphaOCW;
    unsigned long               moCompColorOCW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Surface offsets are initialized in the temporal filter function

    // Align surface pitch and set surface format and pitch
    surfacePitch = (pSurf_gbl->wWidth + 3) & ~3;
    surfacePitch = ((surfacePitch << 1) + 127) & ~127; // YUY2 destination is twice the surface width
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    tmpVal = (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
             (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
             (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
              NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Enable both texture matrices since these texture coordinates are in quarter pel
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_MATRIX_ENABLE(0) | 0x100000);
    nvPushData(1, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(2, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(3, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(4, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);

    nvPusherAdjust(5);

    nvMoCompParams.dataFormat = DATA_FORMAT_TEMPORAL_FILTER;

    tmpVal = (1 << 16) | // 1 MIPMAP level
             (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8 << 8) |
             (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
             (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
             (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(0) | 0x40000);
    nvPushData(1, tmpVal);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(1) | 0x40000);
    nvPushData(3, tmpVal);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(3) | 0x40000);
    nvPushData(7, tmpVal);

    tmpVal = (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE << 24) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE << 20) |
             (NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE << 16) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE << 12) |
             (NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE << 8) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE << 4) |
              NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE;

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_ADDRESS(0) | 0x40000);
    nvPushData(9, tmpVal);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(1) | 0x40000);
    nvPushData(11, tmpVal);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(2) | 0x40000);
    nvPushData(13, tmpVal);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(3) | 0x40000);
    nvPushData(15, tmpVal);

    nvPusherAdjust(16);

    pDriverData->dwMCTex0Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(0) | 0x40000);
    nvPushData(1, pDriverData->dwMCTex0Control0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(1) | 0x40000);
    nvPushData(3, pDriverData->dwMCTex1Control0);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(3) | 0x40000);
    nvPushData(7, tmpVal);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    nvPushData(9, surfacePitch << 16);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(11, surfacePitch << 16);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    nvPushData(13, surfacePitch << 16);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    nvPushData(15, surfacePitch << 16);

    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(0) | 0x40000);
    nvPushData(17, tmpVal);
    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(1) | 0x40000);
    nvPushData(19, tmpVal);
    nvPushData(20, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(2) | 0x40000);
    nvPushData(21, tmpVal);
    nvPushData(22, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(3) | 0x40000);
    nvPushData(23, tmpVal);

    tmpVal = (4094 << 16) | 2046; // Must be even and <= 4094

    nvPushData(24, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    nvPushData(25, tmpVal);
    nvPushData(26, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    nvPushData(27, tmpVal);
    nvPushData(28, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    nvPushData(29, tmpVal);
    nvPushData(30, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    nvPushData(31, tmpVal);

    nvPusherAdjust(32);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our temporal filter moComp values
    // combiner0, RGB portion:   A = constantColor0
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = constantColor1
    // combiner0, RGB portion:   D = texture1

    moCompAlphaICW = (NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |
                     (NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1 << 24) |

                     (NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |
                     (NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8 << 16) |

                     (NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |
                     (NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2 << 8) |

                     (NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |
                      NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9;

    moCompColorICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                     (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_ICW(0) | 0x100000);
    nvPushData(1, moCompAlphaICW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_ICW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x100000);
    nvPushData(6, moCompColorICW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_ICW);

    // Load combination factors
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(11, 0x80808080); // % of top field

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(13, 0x80808080); // % of bottom field

    nvPusherAdjust(14);

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1
    moCompAlphaOCW = (NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                     (NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                     (NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                      NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0;

    moCompColorOCW = (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE << 19) |
                     (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE << 18) |
                     (NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT << 15) |
                     (NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_OCW(0) | 0x100000);
    nvPushData(1, moCompAlphaOCW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_OCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_OCW(0) | 0x100000);
    nvPushData(6, moCompColorOCW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_OCW);

    tmpVal = (NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL << 16) |
             (NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL << 12) |
             (NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB << 8) |
              NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE;

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_CONTROL | 0x40000);
    nvPushData(11, tmpVal);

    nvPusherAdjust(12);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_KELVIN_FINAL_CW0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_KELVIN_FINAL_CW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitKelvinForMoCompTemporalFilter */



#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\MoPred.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvprecomp.h"

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoPred.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/

#if (NVARCH >= 0x10)

extern NVMOCOMPPARAMS nvMoCompParams;

extern PNVMCPREDFUNC nvDoBidirectionalFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBidirectionalFieldPredictions;
extern PNVMCPREDFUNC nvDoForwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoForwardFieldPredictions;
extern PNVMCPREDFUNC nvDoBackwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBackwardFieldPredictions;

#ifdef  DEBUG
extern unsigned long moCompDebugLevel;
#endif  // DEBUG


/*
 * nvDoCelsiusBidirectionalDVDFieldPrediction
 *
 * Performs bidirectional field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusBidirectionalDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.5;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture1BlockX0;
    long            texture1BlockY0;
    long            texture1BlockX1;
    long            texture1BlockY1;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture1BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.backwardField != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.backwardField != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(5);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(18, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(19);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusBidirectionalDVDFieldPrediction */


/*
 * nvDoTwoCelsiusBidirectionalDVDFieldPredictions
 *
 * Performs two bidirectional field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoCelsiusBidirectionalDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 0.5;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    long            texture1BlockX0;
    long            texture1BlockY0;
    long            texture1BlockX1;
    long            texture1BlockY1;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture1BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.backwardField != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.backwardField != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x600000);

    nvPushMoCompQuadData(5);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.forwardVerticalVector2;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector2;

    texture1BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.backwardVerticalVector2;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.backwardField2 != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.backwardField2 != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }

    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushMoCompQuadData(17);

    nvPushData(29, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(30, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(31);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoCelsiusBidirectionalDVDFieldPredictions */


/*
 * nvDoCelsiusForwardDVDFieldPrediction
 *
 * Performs forward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusForwardDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_FORWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x200000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusForwardDVDFieldPrediction */


/*
 * nvDoTwoCelsiusForwardDVDFieldPredictions
 *
 * Performs two forward field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoCelsiusForwardDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 0.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_FORWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x400000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.forwardVerticalVector2;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(13, texture0BlockY0 | texture0BlockX0);
    nvPushData(14, blockY0 | blockX0);
    nvPushData(15, texture0BlockY1 | texture0BlockX0);
    nvPushData(16, blockY1 | blockX0);
    nvPushData(17, texture0BlockY1 | texture0BlockX1);
    nvPushData(18, blockY1 | blockX1);
    nvPushData(19, texture0BlockY0 | texture0BlockX1);
    nvPushData(20, blockY0 | blockX1);

    nvPushData(21, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(22, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(23);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoCelsiusForwardDVDFieldPredictions */



/*
 * nvDoCelsiusBackwardDVDFieldPrediction
 *
 * Performs backward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusBackwardDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 1.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BACKWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.backwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.backwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x200000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusBackwardDVDFieldPrediction */


/*
 * nvDoTwoCelsiusBackwardDVDFieldPredictions
 *
 * Performs two backward field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoCelsiusBackwardDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 1.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BACKWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.backwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.backwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x400000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.backwardVerticalVector2;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.backwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.backwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(13, texture0BlockY0 | texture0BlockX0);
    nvPushData(14, blockY0 | blockX0);
    nvPushData(15, texture0BlockY1 | texture0BlockX0);
    nvPushData(16, blockY1 | blockX0);
    nvPushData(17, texture0BlockY1 | texture0BlockX1);
    nvPushData(18, blockY1 | blockX1);
    nvPushData(19, texture0BlockY0 | texture0BlockX1);
    nvPushData(20, blockY0 | blockX1);

    nvPushData(21, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(22, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(23);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoCelsiusBackwardFieldPredictions */


/*
 * nvDoCelsiusBidirectionalHDFieldPrediction
 *
 * Performs bidirectional field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusBidirectionalHDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.5;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture1BlockX0;
    long            texture1BlockY0;
    long            texture1BlockX1;
    long            texture1BlockY1;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture1BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        dwSurfaceOffset = nvMoCompParams.surfaceChromaOffset;
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }

    if (nvMoCompParams.forwardField != nvMoCompParams.currentForwardField) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
        if (nvMoCompParams.forwardField != 0) {
            nvPushData(1, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceLumaPitch + dwSurfaceOffset);
        } else {
            nvPushData(1, pDriverData->dwMCForwardSurfaceOffset + dwSurfaceOffset);
        }
        nvPusherAdjust(2);
        nvMoCompParams.currentForwardField = nvMoCompParams.forwardField;
    }

    if (nvMoCompParams.backwardField != nvMoCompParams.currentBackwardField) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        if (nvMoCompParams.backwardField != 0) {
            nvPushData(1, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceLumaPitch + dwSurfaceOffset);
        } else {
            nvPushData(1, pDriverData->dwMCBackwardSurfaceOffset + dwSurfaceOffset);
        }
        nvPusherAdjust(2);
        nvMoCompParams.currentBackwardField = nvMoCompParams.backwardField;
    }
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(5);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(18, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(19);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusBidirectionalHDFieldPrediction */


/*
 * nvDoCelsiusForwardHDFieldPrediction
 *
 * Performs forward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusForwardHDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_FORWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        dwSurfaceOffset = nvMoCompParams.surfaceChromaOffset;
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    if (nvMoCompParams.forwardField != nvMoCompParams.currentForwardField) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
        if (nvMoCompParams.forwardField != 0) {
            nvPushData(1, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceLumaPitch + dwSurfaceOffset);
        } else {
            nvPushData(1, pDriverData->dwMCForwardSurfaceOffset + dwSurfaceOffset);
        }
        nvPusherAdjust(2);
        nvMoCompParams.currentForwardField = nvMoCompParams.forwardField;
    }

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x200000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusForwardHDFieldPrediction */



/*
 * nvDoCelsiusBackwardHDFieldPrediction
 *
 * Performs backward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusBackwardHDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 1.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BACKWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        dwSurfaceOffset = nvMoCompParams.surfaceChromaOffset;
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    if (nvMoCompParams.backwardField != nvMoCompParams.currentBackwardField) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        if (nvMoCompParams.backwardField != 0) {
            nvPushData(1, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceLumaPitch + dwSurfaceOffset);
        } else {
            nvPushData(1, pDriverData->dwMCBackwardSurfaceOffset + dwSurfaceOffset);
        }
        nvPusherAdjust(2);
        nvMoCompParams.currentBackwardField = nvMoCompParams.backwardField;
    }
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x200000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusBackwardHDFieldPrediction */



#if 0
/*
 * nvDualPrimeArithmetic
 *
 * Performs new prediction motion vectors from original and differential vectors
 *
 */
void __stdcall nvDualPrimeArithmetic(short DMV[][2],
                                     short *differentialMotionVector,
                                     short horizontalMotionVector,
                                     short verticalMotionVector)
{

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
        if (pDriverData->bMCTopFieldFirst) {
            // Vector for prediction of top field from bottom field
            DMV[0][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[0][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] - 1;

            // Vector for prediction of bottom field from top field
            DMV[1][0] = ((3*horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[1][1] = ((3*verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] + 1;
        } else {
            // Vector for prediction of top field from bottom field
            DMV[0][0] = ((3*horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[0][1] = ((3*verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] - 1;

            // Vector for prediction of bottom field from top field
            DMV[1][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[1][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] + 1;
        }
    } else { // Vector for prediction for field of opposite 'parity'
        DMV[0][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                      differentialMotionVector[0];
        DMV[0][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                      differentialMotionVector[1];

        // Correct for vertical field shift
        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
            DMV[0][1]--;
        else
            DMV[0][1]++;
    }

} /* nvDualPrimeArithmetic */

#endif

/*
 * nvPredictCelsiusFrameLumaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units
 *
 */
DWORD __stdcall nvPredictCelsiusFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
//    short dmvector[2];
//    short DMV[2][2];

    SET_LUMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    nvMoCompParams.blockWidth = 64 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 2;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

            nvMoCompParams.forwardField = 0;
            nvMoCompParams.backwardField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockHeight = 128;
            nvMoCompParams.blockY = pMacroblock->vOffset << 3;
            nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] << 1;
            nvMoCompParams.forwardVerticalVector = pMacroblock->PMV[0][0][1] << 2;
            nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] << 1;
            nvMoCompParams.backwardVerticalVector = pMacroblock->PMV[0][1][1] << 2;

            nvDoBidirectionalFieldPrediction(FALSE);

        } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

            nvMoCompParams.blockHeight = 64;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            if (nvMoCompParams.surfaceLumaPitch >= 1024) {
            
                if (nvMoCompParams.destinationFieldIs0) {
                    // Top field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                    nvDoBidirectionalFieldPrediction(FALSE);
                } else {
                    // Bottom field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.destinationField = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                    nvDoBidirectionalFieldPrediction(FALSE);
                }
            } else {
            
                // Top field prediction
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoTwoBidirectionalFieldPredictions(FALSE);
            }
            
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if ((pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {
                
                nvMoCompParams.forwardField = 0;
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockHeight = 128;
                nvMoCompParams.blockY = pMacroblock->vOffset << 3;
                nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] << 1;
                nvMoCompParams.forwardVerticalVector = pMacroblock->PMV[0][0][1] << 2;

                nvDoForwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {
                        // Top field prediction
                        nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                        nvDoForwardFieldPrediction(FALSE);
                    } else {
                        // Bottom field prediction
                        nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                        nvDoForwardFieldPrediction(FALSE);
                    }
                } else {
                                                                        
                    // Top field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                    // Bottom field prediction
                    nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                    nvMoCompParams.destinationField2 = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoTwoForwardFieldPredictions(FALSE);
                }
                
            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_DP) { // Dual prime prediction

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      (short)(pMacroblock->PMV[0][0][1] >> 1));

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                        nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceLumaPitch));

                        nvPusherAdjust(2);
                        
                        nvMoCompParams.currentBackwardField = 1;

                        // Predict top field from top field
                        // and add to top field from bottom field
                        nvMoCompParams.forwardField = 0;
                        nvMoCompParams.backwardField = 1;
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                        nvDoBidirectionalFieldPrediction(FALSE);

                    } else {
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                        nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                        nvPusherAdjust(2);

                        nvMoCompParams.currentBackwardField = 0;

                        // Predict bottom field from bottom field
                        // and add to bottom field from top field
                        nvMoCompParams.forwardField = 1;
                        nvMoCompParams.backwardField = 0;
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                        nvDoBidirectionalFieldPrediction(FALSE);
                    }

                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                    nvPusherAdjust(2);

                    nvMoCompParams.currentBackwardField = 0;
                    nvMoCompParams.backwardField = 0;
                    
                } else {
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                    nvPusherAdjust(2);

                    // Predict top field from top field
                    // and add to top field from bottom field
                    nvMoCompParams.forwardField = 0;
                    nvMoCompParams.backwardField = 1;
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBidirectionalFieldPrediction(FALSE);

                    // Predict bottom field from bottom field
                    // and add to bottom field from top field
                    nvMoCompParams.forwardField = 1;
                    nvMoCompParams.backwardField = 0;
                    nvMoCompParams.destinationField = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                    nvDoBidirectionalFieldPrediction(FALSE);

                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                    nvPusherAdjust(2);

                }
                
            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

                nvMoCompParams.backwardField = 0;
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockHeight = 128;
                nvMoCompParams.blockY = pMacroblock->vOffset << 3;
                nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] << 1;
                nvMoCompParams.backwardVerticalVector = pMacroblock->PMV[0][1][1] << 2;

                nvDoBackwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {
                        // Top field prediction
                        nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                        nvDoBackwardFieldPrediction(FALSE);
                    } else {
                        // Bottom field prediction
                        nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                        nvDoBackwardFieldPrediction(FALSE);
                    }
                } else {

                    // Top field prediction
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                    nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                    // Bottom field prediction
                    nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.destinationField2 = 1;
                    *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                    nvDoTwoBackwardFieldPredictions(FALSE);

                }
            }
        }
    }

    return TRUE;

} /* nvPredictCelsiusFrameLumaMacroblock */


/*
 * nvPredictCelsiusFrameChromaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units.
 *       This function assumes chroma format is interleaved CrCb so predictions are
 *       performed at twice the horizontal offset and width so that only 1 pass is required.
 *       This 16 bit pixel format also requires that the prediction functions be notified
 *       that they must use a pitch of half the default size when attempting to access field 1.
 *
 */
DWORD __stdcall nvPredictCelsiusFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
//    short dmvector[2];
//    short DMV[2][2];

    SET_CHROMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    nvMoCompParams.destinationField = 0;
    nvMoCompParams.forwardField = 0;
    nvMoCompParams.backwardField = 0;
    nvMoCompParams.blockWidth = 32 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

            if (pMacroblock->PMV[0][0][0] < 0) 
                pMacroblock->PMV[0][0][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][0][1] < 0) 
                pMacroblock->PMV[0][0][1] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][0] < 0) 
                pMacroblock->PMV[0][1][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][1] < 0) 
                pMacroblock->PMV[0][1][1] += 1; // round toward 0

            nvMoCompParams.blockHeight = 64;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;
            nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] & 0xFFFE;
            nvMoCompParams.forwardVerticalVector = (pMacroblock->PMV[0][0][1] & 0xFFFE) << 1;
            nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] & 0xFFFE;
            nvMoCompParams.backwardVerticalVector = (pMacroblock->PMV[0][1][1] & 0xFFFE) << 1;

            nvDoBidirectionalFieldPrediction(TRUE);

        } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockY = pMacroblock->vOffset << 1;

            if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                if (nvMoCompParams.destinationFieldIs0) {
                
                    if (pMacroblock->PMV[0][0][0] < 0) 
                        pMacroblock->PMV[0][0][0] += 1; // round toward 0

                    if (pMacroblock->PMV[0][0][1] < 0) 
                        pMacroblock->PMV[0][0][1] += 1; // round toward 0

                    if (pMacroblock->PMV[0][1][0] < 0) 
                        pMacroblock->PMV[0][1][0] += 1; // round toward 0

                    if (pMacroblock->PMV[0][1][1] < 0) 
                        pMacroblock->PMV[0][1][1] += 1; // round toward 0

                    // Top field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

                    nvDoBidirectionalFieldPrediction(TRUE);

                } else {
                
                    if (pMacroblock->PMV[1][0][0] < 0) 
                        pMacroblock->PMV[1][0][0] += 1; // round toward 0

                    if (pMacroblock->PMV[1][0][1] < 0) 
                        pMacroblock->PMV[1][0][1] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][0] < 0) 
                        pMacroblock->PMV[1][1][0] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][1] < 0) 
                        pMacroblock->PMV[1][1][1] += 1; // round toward 0

                    // Bottom field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.destinationField = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                    nvDoBidirectionalFieldPrediction(TRUE);
                }
            } else {

                if (pMacroblock->PMV[0][0][0] < 0) 
                    pMacroblock->PMV[0][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][0][1] < 0) 
                    pMacroblock->PMV[0][0][1] += 1; // round toward 0

                if (pMacroblock->PMV[0][1][0] < 0) 
                    pMacroblock->PMV[0][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][1][1] < 0) 
                    pMacroblock->PMV[0][1][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][0][0] < 0) 
                    pMacroblock->PMV[1][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[1][0][1] < 0) 
                    pMacroblock->PMV[1][0][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][0] < 0) 
                    pMacroblock->PMV[1][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][1] < 0) 
                    pMacroblock->PMV[1][1][1] += 1; // round toward 0

                // Top field prediction
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                nvDoTwoBidirectionalFieldPredictions(TRUE);
            }
            
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if ((pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {
            
                if (pMacroblock->PMV[0][0][0] < 0) 
                    pMacroblock->PMV[0][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][0][1] < 0) 
                    pMacroblock->PMV[0][0][1] += 1; // round toward 0

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] & 0xFFFE;
                nvMoCompParams.forwardVerticalVector = (pMacroblock->PMV[0][0][1] & 0xFFFE) << 1;

                nvDoForwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {

                        if (pMacroblock->PMV[0][0][0] < 0) 
                            pMacroblock->PMV[0][0][0] += 1; // round toward 0

                        if (pMacroblock->PMV[0][0][1] < 0) 
                            pMacroblock->PMV[0][0][1] += 1; // round toward 0

                        // Top field prediction
                        nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;

                        nvDoForwardFieldPrediction(TRUE);

                    } else {

                        if (pMacroblock->PMV[1][0][0] < 0) 
                            pMacroblock->PMV[1][0][0] += 1; // round toward 0
                            
                        if (pMacroblock->PMV[1][0][1] < 0) 
                            pMacroblock->PMV[1][0][1] += 1; // round toward 0
                        
                        // Bottom field prediction
                        nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                        nvDoForwardFieldPrediction(TRUE);
                    }
                } else {

                    if (pMacroblock->PMV[0][0][0] < 0) 
                        pMacroblock->PMV[0][0][0] += 1; // round toward 0

                    if (pMacroblock->PMV[0][0][1] < 0) 
                        pMacroblock->PMV[0][0][1] += 1; // round toward 0

                    if (pMacroblock->PMV[1][0][0] < 0) 
                        pMacroblock->PMV[1][0][0] += 1; // round toward 0
                        
                    if (pMacroblock->PMV[1][0][1] < 0) 
                        pMacroblock->PMV[1][0][1] += 1; // round toward 0
                    
                    // Top field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;

                    nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                    // Bottom field prediction
                    nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                    nvMoCompParams.destinationField2 = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                    nvDoTwoForwardFieldPredictions(TRUE);
                }

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_DP) { // Dual prime prediction

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      (short)(pMacroblock->PMV[0][0][1] >> 1));

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                        nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceLumaPitch + nvMoCompParams.surfaceChromaOffset));

                        nvPusherAdjust(2);

                        if (pMacroblock->PMV[0][0][0] < 0) 
                            pMacroblock->PMV[0][0][0] += 1; // round toward 0

                        if (pMacroblock->PMV[0][0][1] < 0) 
                            pMacroblock->PMV[0][0][1] += 1; // round toward 0

                        if (pMacroblock->PMV[1][0][0] < 0) 
                            pMacroblock->PMV[1][0][0] += 1; // round toward 0

                        if (pMacroblock->PMV[1][0][1] < 0) 
                            pMacroblock->PMV[1][0][1] += 1; // round toward 0

                        nvMoCompParams.currentBackwardField = 1;

                        // Predict top field from top field
                        // and add to top field from bottom field
                        nvMoCompParams.forwardField = 0;
                        nvMoCompParams.backwardField = 1;
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                        nvDoBidirectionalFieldPrediction(TRUE);

                    } else {
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                        nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                        nvPusherAdjust(2);

                        if (pMacroblock->PMV[1][1][0] < 0) 
                            pMacroblock->PMV[1][1][0] += 1; // round toward 0

                        if (pMacroblock->PMV[1][1][1] < 0) 
                            pMacroblock->PMV[1][1][1] += 1; // round toward 0

                        nvMoCompParams.currentBackwardField = 0;

                        // Predict bottom field from bottom field
                        // and add to bottom field from top field
                        nvMoCompParams.forwardField = 1;
                        nvMoCompParams.backwardField = 0;
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                        nvDoBidirectionalFieldPrediction(TRUE);
                    }

                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset));

                    nvPusherAdjust(2);

                    nvMoCompParams.currentBackwardField = 0;
                    nvMoCompParams.backwardField = 0;
                    
                } else {
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                    nvPusherAdjust(2);

                    if (pMacroblock->PMV[0][0][0] < 0) 
                        pMacroblock->PMV[0][0][0] += 1; // round toward 0

                    if (pMacroblock->PMV[0][0][1] < 0) 
                        pMacroblock->PMV[0][0][1] += 1; // round toward 0

                    if (pMacroblock->PMV[1][0][0] < 0) 
                        pMacroblock->PMV[1][0][0] += 1; // round toward 0

                    if (pMacroblock->PMV[1][0][1] < 0) 
                        pMacroblock->PMV[1][0][1] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][0] < 0) 
                        pMacroblock->PMV[1][1][0] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][1] < 0) 
                        pMacroblock->PMV[1][1][1] += 1; // round toward 0

                    // Predict top field from top field
                    // and add to top field from bottom field
                    nvMoCompParams.forwardField = 0;
                    nvMoCompParams.backwardField = 1;
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                    nvDoBidirectionalFieldPrediction(TRUE);

                    // Predict bottom field from bottom field
                    // and add to bottom field from top field
                    nvMoCompParams.forwardField = 1;
                    nvMoCompParams.backwardField = 0;
                    nvMoCompParams.destinationField = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                    nvDoBidirectionalFieldPrediction(TRUE);

                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                    nvPusherAdjust(2);
                }
                
            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

                if (pMacroblock->PMV[0][1][0] < 0) 
                    pMacroblock->PMV[0][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][1][1] < 0) 
                    pMacroblock->PMV[0][1][1] += 1; // round toward 0

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] & 0xFFFE;
                nvMoCompParams.backwardVerticalVector = (pMacroblock->PMV[0][1][1] & 0xFFFE) << 1;

                nvDoBackwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {

                        if (pMacroblock->PMV[0][1][0] < 0) 
                            pMacroblock->PMV[0][1][0] += 1; // round toward 0

                        if (pMacroblock->PMV[0][1][1] < 0) 
                            pMacroblock->PMV[0][1][1] += 1; // round toward 0

                        // Top field prediction
                        nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

                        nvDoBackwardFieldPrediction(TRUE);

                    } else {

                        if (pMacroblock->PMV[1][1][0] < 0) 
                            pMacroblock->PMV[1][1][0] += 1; // round toward 0

                        if (pMacroblock->PMV[1][1][1] < 0) 
                            pMacroblock->PMV[1][1][1] += 1; // round toward 0

                        // Bottom field prediction
                        nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                        nvDoBackwardFieldPrediction(TRUE);
                    }
                } else {

                    if (pMacroblock->PMV[0][1][0] < 0) 
                        pMacroblock->PMV[0][1][0] += 1; // round toward 0

                    if (pMacroblock->PMV[0][1][1] < 0) 
                        pMacroblock->PMV[0][1][1] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][0] < 0) 
                        pMacroblock->PMV[1][1][0] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][1] < 0) 
                        pMacroblock->PMV[1][1][1] += 1; // round toward 0

                    // Top field prediction
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

                    nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                    // Bottom field prediction
                    nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.destinationField2 = 1;
                    *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                    nvDoTwoBackwardFieldPredictions(TRUE);
                }    
            }
        }
    }

    return TRUE;

} /* nvPredictCelsiusFrameChromaMacroblock */


/*
 * nvPredictCelsiusFieldLumaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units
 *
 */
DWORD __stdcall nvPredictCelsiusFieldLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    unsigned long currentField;
    unsigned long doBackwardPrediction;
//    short dmvector[2];
//    short DMV[2][2];

    SET_LUMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    // Destination field offset already set at init time
    nvMoCompParams.destinationField = 0;

    nvMoCompParams.blockWidth = 64 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        // Field based prediction
        if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.blockHeight = 64;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

            nvDoBidirectionalFieldPrediction(FALSE);

        } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

            nvMoCompParams.blockHeight = 32;

            // Top half
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

            if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                nvDoBidirectionalFieldPrediction(FALSE);

                // Bottom half
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY += 32;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoBidirectionalFieldPrediction(FALSE);

            } else {

                // Bottom half
                nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY2 = nvMoCompParams.blockY + 32;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoTwoBidirectionalFieldPredictions(FALSE);
            }
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
                currentField = 0;
            else
                currentField = 1;

            doBackwardPrediction = 0; // previous frame

            // Determine which frame to use for prediction
            if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                 pDriverData->bMCSecondField &&
                (currentField != pMacroblock->fieldSelect[0][0]))
                doBackwardPrediction = 1; // same frame

            // Field based prediction
            if ((pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {

                nvMoCompParams.blockHeight = 64;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 32;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }

                doBackwardPrediction = 0; // previous frame

                // Determine which frame to use for lower prediction
                if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                     pDriverData->bMCSecondField &&
                    (currentField != pMacroblock->fieldSelect[1][0]))
                    doBackwardPrediction = 1; // same frame

                nvMoCompParams.blockY += 32;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_DP) { // Dual prime prediction

                if (pDriverData->bMCSecondField)
                    doBackwardPrediction = 1; // same frame
                else
                    doBackwardPrediction = 0; // previous frame

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      pMacroblock->PMV[0][0][1]);


                if (doBackwardPrediction)
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
                else
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);
                
                // Predict from field of same parity
                // added to field of opposite parity
                nvMoCompParams.forwardField = (BYTE)currentField;
                nvMoCompParams.backwardField = (BYTE)currentField ^ 1;
                nvMoCompParams.blockHeight = 64;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                // nvMoCompParams.backwardHorizontalVector = DMV[0][0];
                // nvMoCompParams.backwardVerticalVector = DMV[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                nvDoBidirectionalFieldPrediction(FALSE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);

            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            // Field based prediction
            if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.blockHeight = 64;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                nvDoBackwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 32;

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    nvDoBackwardFieldPrediction(FALSE);

                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.blockY += 32;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);

                } else {

                    nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                    nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.blockY2 = nvMoCompParams.blockY + 32;
                    *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                    nvDoTwoBackwardFieldPredictions(FALSE);
                }
            } else {
                // Error
                return FALSE;
            }
        }
    }

    return TRUE;

} /* nvPredictCelsiusFieldLumaMacroblock */


/*
 * nvPredictCelsiusFieldChromaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units.
 *       This function assumes chroma format is interleaved CrCb so predictions are
 *       performed at twice the horizontal offset and width so that only 1 pass is required.
 *       This 16 bit pixel format also requires that the prediction functions be notified
 *       that they must use a pitch of half the default size when attempting to access field 1.
 *
 */
DWORD __stdcall nvPredictCelsiusFieldChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    unsigned long currentField;
    unsigned long doBackwardPrediction;
//    short dmvector[2];
//    short DMV[2][2];

    SET_CHROMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    // Destination field offset already set at init time
    nvMoCompParams.destinationField = 0;

    nvMoCompParams.blockWidth = 32 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;
    nvMoCompParams.blockY = pMacroblock->vOffset << 1;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        // Field based prediction
        if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.blockHeight = 32;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

            nvDoBidirectionalFieldPrediction(TRUE);

        } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

            nvMoCompParams.blockHeight = 16;

            // Top half
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

            if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                nvDoBidirectionalFieldPrediction(TRUE);

                // Bottom half
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY += 16;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]);

                nvDoBidirectionalFieldPrediction(TRUE);

            } else {

                // Bottom half
                nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY2 = nvMoCompParams.blockY + 16;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]);
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]);

                nvDoTwoBidirectionalFieldPredictions(TRUE);
            }
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
                currentField = 0;
            else
                currentField = 1;

            doBackwardPrediction = 0; // previous frame

            // Determine which frame to use for prediction
            if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                 pDriverData->bMCSecondField &&
                (currentField != pMacroblock->fieldSelect[0][0]))
                doBackwardPrediction = 1; // same frame

            // Field based prediction
            if ((pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {

                nvMoCompParams.blockHeight = 32;

                if (doBackwardPrediction) {

                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 16;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }

                doBackwardPrediction = 0; // previous frame

                // Determine which frame to use for lower prediction
                if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                     pDriverData->bMCSecondField &&
                    (currentField != pMacroblock->fieldSelect[1][0]))
                    doBackwardPrediction = 1; // same frame

                nvMoCompParams.blockY += 16;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_DP) { // Dual prime prediction

                if (pDriverData->bMCSecondField)
                    doBackwardPrediction = 1; // same frame
                else
                    doBackwardPrediction = 0; // previous frame

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      pMacroblock->PMV[0][0][1]);

                if (doBackwardPrediction)
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
                else
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);

                // Predict from field of same parity
                // added to field of opposite parity
                nvMoCompParams.forwardField = (BYTE)currentField;
                nvMoCompParams.backwardField = (BYTE)currentField ^ 1;
                nvMoCompParams.blockHeight = 32;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
                // nvMoCompParams.backwardHorizontalVector = DMV[0][0] >> 1;
                // nvMoCompParams.backwardVerticalVector = DMV[0][1] >> 1;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                nvDoBidirectionalFieldPrediction(TRUE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);

            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            // Field based prediction
            if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.blockHeight = 32;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

                nvDoBackwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 16;

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    nvDoBackwardFieldPrediction(TRUE);

                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.blockY += 16;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]);

                    nvDoBackwardFieldPrediction(TRUE);

                } else {

                    nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                    nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.blockY2 = nvMoCompParams.blockY + 16;
                    *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]);

                    nvDoTwoBackwardFieldPredictions(TRUE);
                }
            } else {
                // Error
                return FALSE;
            }
        }
    }

    return TRUE;

} /* nvPredictCelsiusFieldChromaMacroblock */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\MoCompEx.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoCompEx.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "dxshare.h"

extern NVMOCOMPPARAMS           nvMoCompParams;

#ifndef WINNT
    extern DISPDRVDIRECTXCOMMON    *pDXShare;
#endif // WINNT

extern DWORD __stdcall nvInitCelsiusForMoComp(void);
extern DWORD __stdcall nvInitCelsiusForMoCompPrediction(void);
extern DWORD __stdcall nvInitCelsiusForMoCompCorrection();
extern void __stdcall nvDoCelsiusBidirectionalDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoCelsiusBidirectionalDVDFieldPredictions(BOOL);
extern void __stdcall nvDoCelsiusForwardDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoCelsiusForwardDVDFieldPredictions(BOOL);
extern void __stdcall nvDoCelsiusBackwardDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoCelsiusBackwardDVDFieldPredictions(BOOL);
extern void __stdcall nvDoCelsiusBidirectionalHDFieldPrediction(BOOL);
extern void __stdcall nvDoCelsiusForwardHDFieldPrediction(BOOL);
extern void __stdcall nvDoCelsiusBackwardHDFieldPrediction(BOOL);
extern void __stdcall nvDoAllCelsiusIntraDVDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoAllCelsiusDVDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoCelsiusIntraDVDFieldCorrection(void);
extern void __stdcall nvDoOptimizedCelsiusIntraDVDFieldCorrection(void);
extern void __stdcall nvDoCelsiusDVDFieldCorrection(void);
extern void __stdcall nvDoAllCelsiusIntraHDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoAllCelsiusHDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoCelsiusIntraHDFieldCorrection(void);
extern void __stdcall nvDoOptimizedCelsiusIntraHDFieldCorrection(void);
extern void __stdcall nvDoCelsiusHDFieldCorrection(void);
extern void __stdcall nvDoAllCelsiusIntraFrameCorrections(void);
extern void __stdcall nvDoAllCelsiusFrameCorrections(void);
extern void __stdcall nvDoCelsiusIntraFrameCorrection(void);
extern void __stdcall nvDoCelsiusFrameCorrection(void);
extern DWORD __stdcall nvPredictCelsiusFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictCelsiusFieldLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictCelsiusFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictCelsiusFieldChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern void __stdcall nvCorrectCelsiusIntraFrame(LPNVDECODEMACROBLOCK pMacroblock, long macroblockCount);
extern void __stdcall nvCorrectCelsiusFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectCelsiusFullFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectCelsiusFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectCelsiusFullFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectCelsiusIntraField(LPNVDECODEMACROBLOCK pMacroblock, long macroblockCount);
extern void __stdcall nvCorrectCelsiusFieldMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);

extern PNVMCPREDFUNC nvDoBidirectionalFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBidirectionalFieldPredictions;
extern PNVMCPREDFUNC nvDoForwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoForwardFieldPredictions;
extern PNVMCPREDFUNC nvDoBackwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBackwardFieldPredictions;

extern PNVMCPREDFUNC2 nvPredictFrameLumaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFieldLumaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFrameChromaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFieldChromaMacroblock;

extern PNVMCCORRFUNC2 nvDoAllIntraFieldCorrections;
extern PNVMCCORRFUNC2 nvDoAllFieldCorrections;
extern PNVMCCORRFUNC nvDoAllIntraFrameCorrections;
extern PNVMCCORRFUNC nvDoAllFrameCorrections;
extern PNVMCCORRFUNC nvDoIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoOptimizedIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoFieldCorrection;
extern PNVMCCORRFUNC nvDoIntraFrameCorrection;
extern PNVMCCORRFUNC nvDoFrameCorrection;



/*
 * nvMoCompCheckFieldPredictionEqual
 *
 * Tests whether the field predictions are equal on 2 macroblocks.
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
BOOL __fastcall nvMoCompCheckFieldPredictionEqual(LPNVDECODEMACROBLOCK pMacroblock0,
                                                  LPNVDECODEMACROBLOCK pMacroblock1, BYTE macroblockType)
{
    if (macroblockType & MB_MOTION_FORWARD) {
        if ((pMacroblock0->fieldSelect[0][0] != pMacroblock1->fieldSelect[0][0]) ||
            (pMacroblock0->fieldSelect[1][0] != pMacroblock1->fieldSelect[1][0]) ||
            (*(long *)&pMacroblock0->PMV[0][0][0] != *(long *)&pMacroblock1->PMV[0][0][0]) ||
            (*(long *)&pMacroblock0->PMV[1][0][0] != *(long *)&pMacroblock1->PMV[1][0][0]))
            return FALSE;
    }
    if (macroblockType & MB_MOTION_BACKWARD) {
        if ((pMacroblock0->fieldSelect[0][1] != pMacroblock1->fieldSelect[0][1]) ||
            (pMacroblock0->fieldSelect[1][1] != pMacroblock1->fieldSelect[1][1]) ||
            (*(long *)&pMacroblock0->PMV[0][1][0] != *(long *)&pMacroblock1->PMV[0][1][0]) ||
            (*(long *)&pMacroblock0->PMV[1][1][0] != *(long *)&pMacroblock1->PMV[1][1][0]))
            return FALSE;
    }
    return TRUE;

} /* nvMoCompCheckFieldPredictionEqual */


/*
 * nvMoCompProcessCelsiusFrameMacroblocks
 *
 * Parses the current macroblock command stream and performs the necessary operations on
 * each macroblock.
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvMoCompProcessCelsiusFrameMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                       DWORD numMacroblocks, BYTE formatConversionStatus)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVDECODEMACROBLOCK        pMacroblock;
    LPNVDECODEMACROBLOCK        pLastMacroblock;
    LPNVDECODEMACROBLOCK        pMacroblock1;
    unsigned long               dwFirstAlignedIDCTOffset;
    unsigned long               dwSurfaceOffset;
    unsigned long               surfacePitch;
    unsigned long               moCompCorrectionICW;
    unsigned long               moCompNonPrebiasedCorrectionICW;
    long                        macroblockLimit;
    long                        n,i;
    long                        macroblockIndex;
    BYTE                        surfaceDecodeStatus = 0;
    BYTE                        numCombinedMacroblocks[256];
    short                       maxHeight = (short)dst->wHeight - 16;
    short                       maxWidth = (short)dst->wWidth - 16;
    BOOL                        hasFieldPredictions = FALSE;
    int                         index;
    int                         firstAlignedIDCTIndex;

    nvMoCompParams.vertexMode = 0; // Initialize vertexMode to an invalid value
    nvMoCompParams.surfaceLumaPitch = dst->lPitch;
    nvMoCompParams.surfaceLumaHeight = (dst->wHeight + 1) & ~1;
    nvMoCompParams.surfaceOffset = VIDMEM_OFFSET(dst->fpVidMem);
    nvMoCompParams.surfaceChromaOffset = nvMoCompParams.surfaceLumaPitch * nvMoCompParams.surfaceLumaHeight;
    nvMoCompParams.surfaceBiasedIntraBlockOffset =
        (dst->lPitch * dst->wHeight) + (dst->lPitch * (dst->wHeight >> 1) + (8 * dst->lPitch));
    if (pDriverData->bMCHorizontallyDownscale1080i) {
        nvMoCompParams.celsiusDestinationViewportXOffset = SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET;
        if (nvMoCompParams.surfaceLumaPitch > 1280)
            nvMoCompParams.celsiusFieldXOffset = 10240; // (1920 / 0.75) << 2, MUST CHANGE IF IN TILED MEMORY
        else
            nvMoCompParams.celsiusFieldXOffset = 6827; // (1280 / 0.75) << 2; MUST CHANGE IF IN TILED MEMORY
    } else {
        nvMoCompParams.celsiusDestinationViewportXOffset = CELSIUS_DESTINATION_VIEWPORT_XOFFSET;
        nvMoCompParams.celsiusFieldXOffset = (short)nvMoCompParams.surfaceLumaPitch << 2;
    }
    
    if (pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) {

        if (!(nvInitCelsiusForMoCompPrediction()))
            return FALSE;

        if (nvMoCompParams.surfaceLumaPitch >= 1024) {
            nvDoBidirectionalFieldPrediction = nvDoCelsiusBidirectionalHDFieldPrediction;
            nvDoForwardFieldPrediction = nvDoCelsiusForwardHDFieldPrediction;
            nvDoBackwardFieldPrediction = nvDoCelsiusBackwardHDFieldPrediction;
        } else {
            nvDoBidirectionalFieldPrediction = nvDoCelsiusBidirectionalDVDFieldPrediction;
            nvDoTwoBidirectionalFieldPredictions = nvDoTwoCelsiusBidirectionalDVDFieldPredictions;
            nvDoForwardFieldPrediction = nvDoCelsiusForwardDVDFieldPrediction;
            nvDoTwoForwardFieldPredictions = nvDoTwoCelsiusForwardDVDFieldPredictions;
            nvDoBackwardFieldPrediction = nvDoCelsiusBackwardDVDFieldPrediction;
            nvDoTwoBackwardFieldPredictions = nvDoTwoCelsiusBackwardDVDFieldPredictions;
        }

        nvPredictFrameLumaMacroblock = nvPredictCelsiusFrameLumaMacroblock;
        nvPredictFrameChromaMacroblock = nvPredictCelsiusFrameChromaMacroblock;
        nvPredictFieldLumaMacroblock = nvPredictCelsiusFieldLumaMacroblock;
        nvPredictFieldChromaMacroblock = nvPredictCelsiusFieldChromaMacroblock;

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        surfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        // Must temporarily set destination surface pitch back to it's normal frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(3, surfacePitch);

        // Must also change texture pitches back to normal frame pitch so that quarter pel addressing works correctly
        nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(5, surfacePitch << 16);
        nvPushData(6, surfacePitch << 16);

        nvPusherAdjust(7);

        // Perform luma prediction pass
        while (n > 0) {
            numCombinedMacroblocks[macroblockIndex] = 1;
			if (pMacroblock->macroblockType == MB_MOTION_FORWARD) {
				if(n > 1){
					pMacroblock1 = pMacroblock + 1;
					if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;	//no more macroblck left
							pMacroblock1++;	

						}
					}
					else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;							
						}
					}
				}
				if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
					 nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
				 else
					 hasFieldPredictions = TRUE;

				pMacroblock += numCombinedMacroblocks[macroblockIndex];
				n -= numCombinedMacroblocks[macroblockIndex];
			 } else if (pMacroblock->macroblockType == MB_MOTION_BACKWARD) {
				if(n > 1){
					pMacroblock1 = pMacroblock + 1;
					if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
					else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD){
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}
					}
				}
				if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
					nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
				else
					hasFieldPredictions = TRUE;
	
				pMacroblock += numCombinedMacroblocks[macroblockIndex];
				n -= numCombinedMacroblocks[macroblockIndex];

			 } else if (pMacroblock->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) {
				 if(n > 1){
					 pMacroblock1 = pMacroblock + 1;
					 if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0]) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}
					}
					else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD){
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}
					}
				}
			  
				if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
					nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
				else
					hasFieldPredictions = TRUE;
	
				pMacroblock += numCombinedMacroblocks[macroblockIndex];
				n -= numCombinedMacroblocks[macroblockIndex];
			} else {
				if (pMacroblock->macroblockType != MB_INTRA) {

					if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
						nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
					else
						hasFieldPredictions = TRUE;

				}
				pMacroblock++;
				n--;
			}
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        // Change surface offsets to chroma portion of surface
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPusherAdjust(8);

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        // Perform chroma prediction pass
        while (n > 0) {
            if (pMacroblock->macroblockType != MB_INTRA) {

                if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                    nvPredictFrameChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

            }
            pMacroblock += numCombinedMacroblocks[macroblockIndex];
            n -= numCombinedMacroblocks[macroblockIndex];
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        // Now do non-frame structured predictions if any are necessary
        if (hasFieldPredictions) {

            // Restore offsets and pitches to field based pitches
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset);

            nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(5, pDriverData->dwMCForwardSurfaceOffset);

            nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset);

            nvPusherAdjust(8);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_PITCH | 0x40000);
            nvPushData(1, (surfacePitch << 1));

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
            nvPushData(3, surfacePitch << 17);
            nvPushData(4, surfacePitch << 17);

            nvPusherAdjust(5);

            pMacroblock = pMacroblocks;
            n = numMacroblocks;
            macroblockIndex = 0;

            nvMoCompParams.currentForwardField = 0;
            nvMoCompParams.currentBackwardField = 0;
            nvMoCompParams.currentDestinationField = 0;
            nvMoCompParams.destinationFieldIs0 = TRUE; // First process all destination field 0 updates

            // Perform luma prediction pass
            while (n > 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {

                    if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                        nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                }
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
                macroblockIndex++;
            }

            nvPusherStart(TRUE);

            // Change surface offsets to chroma portion of surface
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPusherAdjust(8);

            pMacroblock = pMacroblocks;
            n = numMacroblocks;
            macroblockIndex = 0;

            nvMoCompParams.currentForwardField = 0;
            nvMoCompParams.currentBackwardField = 0;
            nvMoCompParams.currentDestinationField = 0;
            nvMoCompParams.destinationFieldIs0 = TRUE; // First process all destination field 0 updates

            // Perform chroma prediction pass
            while (n > 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {

                    if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                        nvPredictFrameChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                }
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
                macroblockIndex++;
            }

            nvPusherStart(TRUE);

            if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
                nvPushData(3, nvMoCompParams.surfaceOffset);

                nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(5, pDriverData->dwMCForwardSurfaceOffset);

                nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset);

                nvPusherAdjust(8);

                pMacroblock = pMacroblocks;
                n = numMacroblocks;
                macroblockIndex = 0;

                nvMoCompParams.currentForwardField = 0;
                nvMoCompParams.currentBackwardField = 0;
                nvMoCompParams.currentDestinationField = 0;
                nvMoCompParams.destinationFieldIs0 = FALSE; // Then process all destination field 1 updates

                // Perform luma prediction pass
                while (n > 0) {
                    if (pMacroblock->macroblockType != MB_INTRA) {

                        if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                            nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                    }
                    pMacroblock += numCombinedMacroblocks[macroblockIndex];
                    n -= numCombinedMacroblocks[macroblockIndex];
                    macroblockIndex++;
                }

                nvPusherStart(TRUE);

                // Change surface offsets to chroma portion of surface
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
                nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);

                nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

                nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

                nvPusherAdjust(8);

                pMacroblock = pMacroblocks;
                n = numMacroblocks;
                macroblockIndex = 0;

                nvMoCompParams.currentForwardField = 0;
                nvMoCompParams.currentBackwardField = 0;
                nvMoCompParams.currentDestinationField = 0;

                // Perform chroma prediction pass
                while (n > 0) {
                    if (pMacroblock->macroblockType != MB_INTRA) {

                        if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                            nvPredictFrameChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                    }
                    pMacroblock += numCombinedMacroblocks[macroblockIndex];
                    n -= numCombinedMacroblocks[macroblockIndex];
                    macroblockIndex++;
                }

                nvPusherStart(TRUE);
            }
        }
    }

    if (!(nvInitCelsiusForMoCompCorrection()))
        return FALSE;

    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    if (nvMoCompParams.surfaceLumaPitch >= 1024) {
        nvDoAllIntraFieldCorrections = nvDoAllCelsiusIntraHDFieldCorrections;
        nvDoAllFieldCorrections = nvDoAllCelsiusHDFieldCorrections;
        nvDoIntraFieldCorrection = nvDoCelsiusIntraHDFieldCorrection;
        nvDoOptimizedIntraFieldCorrection = nvDoOptimizedCelsiusIntraHDFieldCorrection;
        nvDoFieldCorrection = nvDoCelsiusHDFieldCorrection;
    } else {
        nvDoAllIntraFieldCorrections = nvDoAllCelsiusIntraDVDFieldCorrections;
        nvDoAllFieldCorrections = nvDoAllCelsiusDVDFieldCorrections;
        nvDoIntraFieldCorrection = nvDoCelsiusIntraDVDFieldCorrection;
        nvDoOptimizedIntraFieldCorrection = nvDoOptimizedCelsiusIntraDVDFieldCorrection;
        nvDoFieldCorrection = nvDoCelsiusDVDFieldCorrection;
    }

    nvDoAllIntraFrameCorrections = nvDoAllCelsiusIntraFrameCorrections;
    nvDoAllFrameCorrections = nvDoAllCelsiusFrameCorrections;
    nvDoIntraFrameCorrection = nvDoCelsiusIntraFrameCorrection;
    nvDoFrameCorrection = nvDoCelsiusFrameCorrection;

    // Default motion comp correction ICW
    moCompCorrectionICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                          (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                          (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                          (NV056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                          (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                          (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                          (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                          (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                          (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                          (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                          (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                           NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Non-prebiased motion comp correction ICW
    moCompNonPrebiasedCorrectionICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                                      (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                                      (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                                      (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                                      (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                                      (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                                      (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                                      (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                                      (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                                      (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                                      (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                                       NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;
 
    nvMoCompParams.currentDestinationField = 0;
    nvMoCompParams.destinationField = 0;

    pMacroblock = pMacroblocks;
    n = numMacroblocks;

    // This assumes that the first IDCT index of the first macroblock in the command stream is the
    // lowest index in the entire command stream for this call.

    dwSurfaceOffset = pDriverData->dwMCDestinationSurfaceOffset;

    macroblockIndex = 0;
    index = 0;

    while (n > 0) {

        macroblockLimit = n;

        if (macroblockLimit > 24)
            macroblockLimit = 24;

        pDriverData->dwMCFirstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

        // Attempt to sanity check index
        if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
            pDriverData->dwMCFirstAlignedIDCTIndex = 0;

        dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

        // Force both texture caches to flush
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(5, dwFirstAlignedIDCTOffset);
        nvPushData(6, dwSurfaceOffset);

        nvPusherAdjust(7);

        nvMoCompParams.destinationField = 0;
        nvMoCompParams.currentDestinationField = nvMoCompParams.destinationField;
        nvMoCompParams.destinationFieldIs0 = TRUE;

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform non-prebiased intrablock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompNonPrebiasedCorrectionICW);

            nvPusherAdjust(2);

            SET_UNBIASED_CORRECTION_DATA_FORMAT();
        } else {
            SET_CORRECTION_DATA_FORMAT();
        }    

        if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_I) &&
            (pMacroblock->codedBlockPattern == 0xFF)) {
            nvCorrectCelsiusIntraFrame(pMacroblock, macroblockLimit);
            pMacroblock += macroblockLimit;
            n -= macroblockLimit;
        } else {
            long saveMacroblockLimit = macroblockLimit;
            long fieldTypeCount = 0;
            BOOL hasPartialCorrections = FALSE;

            pMacroblock1 = pMacroblock;

            nvMoCompParams.destinationFieldIs0 = TRUE;

             // Change texture1 surface offset to point to block of half bias values (0x80)
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

            // Change texture0 pitch to 16 bytes
            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
            nvPushData(3, 16 << 16);
            nvPushData(4, 16 << 16); // half bias Intra block pitch

            nvPusherAdjust(5);

            // Perform first correction pass
            while (--macroblockLimit >= 0) {
                if ((pMacroblock->overflowCodedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                    numCombinedMacroblocks[macroblockIndex++] = (BYTE) index;
                index++;
                if ((pMacroblock->DCTType != DCT_FIELD) && (pMacroblock->macroblockType == MB_INTRA)) {
                    if (pMacroblock->codedBlockPattern >= 0xFC) {
                        nvCorrectCelsiusFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        // Change texture0 pitch to it's default value of 8 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                       NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 8 << 16);

                        nvPusherAdjust(2);

                        nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                        // Change texture0 pitch to 16 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                       NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 16 << 16);

                        nvPusherAdjust(2);

                    }
               } else
                    fieldTypeCount++;

                pMacroblock++;
                --n;
            }

            nvPusherStart(TRUE);

            if (pDriverData->bMCCurrentExecuteFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                SET_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT();
            } else {
                SET_CHROMA_CORRECTION_DATA_FORMAT();
            }    

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if (pMacroblock->macroblockType == MB_INTRA) {
                    if (pMacroblock->codedBlockPattern == 0xFF) {
                        nvCorrectCelsiusFullFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        nvCorrectCelsiusFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    }
                }
                pMacroblock++;
            }

            nvPusherStart(TRUE);

            // Force both texture caches to flush
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(3, dwSurfaceOffset);

            nvPusherAdjust(4);

            // Change texture0 pitch to 16 bytes
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
            nvPushData(1, 16 << 16);
            nvPushData(2, nvMoCompParams.surfaceLumaPitch << 16);

            nvPusherAdjust(3);

            if (pDriverData->bMCCurrentExecuteFunction ==
                EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                // Modify combiners to perform interblock correction
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                nvPushData(1, moCompCorrectionICW);

                nvPusherAdjust(2);
            }    

            SET_CORRECTION_DATA_FORMAT();

            nvMoCompParams.destinationFieldIs0 = TRUE;

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            // Perform first correction pass
            while (--macroblockLimit >= 0) {
                if ((pMacroblock->DCTType != DCT_FIELD) && (pMacroblock->macroblockType != MB_INTRA)) {
                    if (pMacroblock->codedBlockPattern >= 0xFC) {
                        nvCorrectCelsiusFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        // Change texture0 pitch to it's default value of 8 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                       NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 8 << 16);

                        nvPusherAdjust(2);

                        nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                        // Change texture0 pitch to 16 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                       NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 16 << 16);

                        nvPusherAdjust(2);
                    }
                }
                pMacroblock++;
            }

            nvPusherStart(TRUE);

            SET_CHROMA_CORRECTION_DATA_FORMAT();

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {
                    if (pMacroblock->codedBlockPattern == 0xFF) {
                        nvCorrectCelsiusFullFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        nvCorrectCelsiusFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    }
                }
                pMacroblock++;
            }

            nvPusherStart(TRUE);

            if (fieldTypeCount > 0) {

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                // Change destination pitch to field pitch
                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 17) | (nvMoCompParams.surfaceLumaPitch << 1)));

                // Change texture1 surface offset to point to block of half bias values (0x80)
                nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(5, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

                // Change texture0 pitch to 16 bytes
                nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(7, 16 << 16);
                nvPushData(8, 16 << 16); // half bias Intra block pitch

                nvPusherAdjust(9);

                if (pDriverData->bMCCurrentExecuteFunction ==
                    EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                    // Modify combiners to perform non-prebiased intrablock correction
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                    nvPushData(1, moCompNonPrebiasedCorrectionICW);

                    nvPusherAdjust(2);

                    SET_UNBIASED_CORRECTION_DATA_FORMAT();
                } else {
                    SET_CORRECTION_DATA_FORMAT();
                }    

                pMacroblock = pMacroblock1;
                macroblockLimit = saveMacroblockLimit;

                while (--macroblockLimit >= 0) {
                    if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType == MB_INTRA)) {
                        if (pMacroblock->codedBlockPattern >= 0xFC) {
                            nvCorrectCelsiusFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                        } else if (pMacroblock->codedBlockPattern != 0) {
                            // Change texture0 pitch to it's default value of 8 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                           NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 8 << 16);

                            nvPusherAdjust(2);

                            hasPartialCorrections = TRUE;

                            nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                            // Change texture0 pitch to 16 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                           NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 16 << 16);

                            nvPusherAdjust(2);
                        }
                    }
                    pMacroblock++;
                }

                if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (hasPartialCorrections)) {

                    nvMoCompParams.destinationFieldIs0 = FALSE;

                    pMacroblock = pMacroblock1;
                    macroblockLimit = saveMacroblockLimit;

                    while (--macroblockLimit >= 0) {
                        if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType == MB_INTRA)) {
                             if ((pMacroblock->codedBlockPattern < 0xFC) &&
                                (pMacroblock->codedBlockPattern != 0)) {
                                // Change texture0 pitch to it's default value of 8 bytes
                                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                                nvPushData(1, 8 << 16);

                                nvPusherAdjust(2);

                                nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                                // Change texture0 pitch to 16 bytes
                                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                                nvPushData(1, 16 << 16);

                                nvPusherAdjust(2);
                            }
                        }
                        pMacroblock++;
                    }

                    // Restore frame offsets
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_NO_OPERATION | 0x40000);
                    nvPushData(1, 0);

                    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
                    nvPushData(3, nvMoCompParams.surfaceOffset);

                    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(5, nvMoCompParams.surfaceOffset);

                    nvPusherAdjust(6);

                    nvMoCompParams.destinationField = 0;
                    nvMoCompParams.currentDestinationField = nvMoCompParams.destinationField;
                }

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
                nvPushData(3, dwFirstAlignedIDCTOffset);
                nvPushData(4, dwSurfaceOffset);

                nvPusherAdjust(5);

                // Change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(1, 16 << 16);
                nvPushData(2, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(3);

                if (pDriverData->bMCCurrentExecuteFunction ==
                    EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                    // Modify combiners to perform interblock correction
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                    nvPushData(1, moCompCorrectionICW);

                    nvPusherAdjust(2);
                }    

                SET_CORRECTION_DATA_FORMAT();

                nvMoCompParams.destinationFieldIs0 = TRUE;

                pMacroblock = pMacroblock1;
                macroblockLimit = saveMacroblockLimit;

                while (--macroblockLimit >= 0) {
                    if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType != MB_INTRA)) {
                        if (pMacroblock->codedBlockPattern >= 0xFC) {
                            nvCorrectCelsiusFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                        } else if (pMacroblock->codedBlockPattern != 0) {
                            // Change texture0 pitch to it's default value of 8 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                           NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 8 << 16);

                            nvPusherAdjust(2);

                            hasPartialCorrections = TRUE;

                            nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                            // Change texture0 pitch to 16 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                           NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 16 << 16);

                            nvPusherAdjust(2);
                        }
                    }
                    pMacroblock++;
                }

                if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (hasPartialCorrections)) {

                    nvMoCompParams.destinationFieldIs0 = FALSE;

                    pMacroblock = pMacroblock1;
                    macroblockLimit = saveMacroblockLimit;

                    while (--macroblockLimit >= 0) {
                        if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType != MB_INTRA)) {
                            if ((pMacroblock->codedBlockPattern < 0xFC) &&
                                (pMacroblock->codedBlockPattern != 0)) {
                                // Change texture0 pitch to it's default value of 8 bytes
                                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                                nvPushData(1, 8 << 16);

                                nvPusherAdjust(2);

                                nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                                // Change texture0 pitch to 16 bytes
                                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                                nvPushData(1, 16 << 16);

                                nvPusherAdjust(2);
                            }
                        }
                        pMacroblock++;
                    }

                    // Restore frame offsets
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_NO_OPERATION | 0x40000);
                    nvPushData(1, 0);

                    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
                    nvPushData(3, nvMoCompParams.surfaceOffset);

                    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(5, nvMoCompParams.surfaceOffset);

                    nvPusherAdjust(6);

                    nvMoCompParams.destinationField = 0;
                    nvMoCompParams.currentDestinationField = nvMoCompParams.destinationField;
                }

                // Restore surface pitch
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_PITCH | 0x40000);
                nvPushData(1, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

                nvPusherAdjust(2);
            }
        }
        nvPusherStart(TRUE);
    }

    pLastMacroblock = pMacroblock - 1;

    if ((pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) && (macroblockIndex > 0)) {
        long saveN = macroblockIndex;

        n = macroblockIndex;
        macroblockIndex = 0;
        pMacroblock1 = pMacroblocks;
        index = -24;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        // DO NOT REMOVE: This is necessary to work around an NV10 texture cache bug
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPusherAdjust(4);

        nvMoCompParams.currentDestinationField = 0;
        nvMoCompParams.destinationField = 0;

        // Change destination pitch back to frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(3, nvMoCompParams.surfaceOffset);

        // Change texture0 pitch to 16 bytes
        nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(5, 16 << 16);
        nvPushData(6, nvMoCompParams.surfaceLumaPitch << 16);

        nvPusherAdjust(7);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform interblock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompCorrectionICW);

            nvPusherAdjust(2);
        }    

        SET_CHROMA_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            pMacroblock = &pMacroblock1[numCombinedMacroblocks[macroblockIndex]];

            firstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 24) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dwSurfaceOffset);

                nvPusherAdjust(3);

                nvMoCompParams.currentDestinationField = 0;
                nvMoCompParams.destinationField = 0;
            }

            // Perform chroma overflow correction pass
            nvCorrectCelsiusFrameChromaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        n = saveN;
        macroblockIndex = 0;
        index = -24;

        // Change texture0 pitch to it's default value of 8 bytes
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, 8 << 16);
        nvPushData(2, nvMoCompParams.surfaceLumaPitch << 16);

        nvPusherAdjust(3);

        SET_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            pMacroblock = &pMacroblock1[numCombinedMacroblocks[macroblockIndex]];

            firstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 24) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dwSurfaceOffset);

                nvPusherAdjust(3);

                nvMoCompParams.currentDestinationField = 0;
                nvMoCompParams.destinationField = 0;

                // For 1080I, reset offset.
                if (nvMoCompParams.surfaceLumaPitch >= 1024) {
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
                    nvPushData(1, nvMoCompParams.surfaceOffset);
                    nvPusherAdjust(2);
                }
            }


            // Perform luma overflow correction pass
            if (pMacroblock->DCTType == DCT_FIELD) {

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 17) | (nvMoCompParams.surfaceLumaPitch << 1)));

                // Change texture0 pitch to default value of 8 bytes
                nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(5, 8 << 16);
                nvPushData(6, nvMoCompParams.surfaceLumaPitch << 17);

                nvPusherAdjust(7);

                nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                // Restore surface pitch
                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

                // Change texture0 pitch to default value of 8 bytes
                nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(5, 8 << 16);
                nvPushData(6, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(7);

            } else
                nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);
    }

    if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
        surfaceDecodeStatus = 15;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight - (nvMoCompParams.surfaceLumaHeight >> 2)))
        surfaceDecodeStatus = 7;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 1))
        surfaceDecodeStatus = 3;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
        surfaceDecodeStatus = 1;

    if (surfaceDecodeStatus > formatConversionStatus) {
        LPNVMCSURFACEFLAGS lpSurfaceFlags;

        nvMoCompConvertSurfaceFormat(dst->fpVidMem, TRUE, (DWORD)surfaceDecodeStatus);

        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != dst->fpVidMem))
            lpSurfaceFlags++;

            if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                (pDriverData->bMCTemporalFilterDisabled == FALSE))
                nvMoCompTemporalFilter(dst->fpVidMem, pDriverData->bMCPercentCurrentField);
    }

    return TRUE;

} /* nvMoCompProcessCelsiusFrameMacroblocks */


/*
 * nvMoCompProcessCelsiusFieldMacroblocks
 *
 * Parses the current macroblock command stream and performs the necessary operations on
 * each macroblock.
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvMoCompProcessCelsiusFieldMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                       DWORD numMacroblocks, BYTE formatConversionStatus)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVDECODEMACROBLOCK        pMacroblock;
    LPNVDECODEMACROBLOCK        pLastMacroblock;
    LPNVDECODEMACROBLOCK        pMacroblock1;
    unsigned long               dwFirstAlignedIDCTOffset;
    unsigned long               dwSurfaceOffset;
    unsigned long               moCompCorrectionICW;
    unsigned long               moCompNonPrebiasedCorrectionICW;
    long                        macroblockLimit;
    long                        n,i;
    long                        macroblockIndex;
    BYTE                        surfaceDecodeStatus = 0;
    BYTE                        numCombinedMacroblocks[256];
    short                       maxHeight = (short)(dst->wHeight >> 1) - 16;
    short                       maxWidth = (short)dst->wWidth - 16;
    int                         index;
    int                         firstAlignedIDCTIndex;

    nvMoCompParams.vertexMode = 0; // Initialize vertexMode to an invalid value
    nvMoCompParams.surfaceLumaPitch = dst->lPitch;
    nvMoCompParams.surfaceLumaHeight = (dst->wHeight + 1) & ~1;
    nvMoCompParams.surfaceOffset = VIDMEM_OFFSET(dst->fpVidMem);
    nvMoCompParams.surfaceChromaOffset = nvMoCompParams.surfaceLumaPitch * nvMoCompParams.surfaceLumaHeight;
    nvMoCompParams.surfaceBiasedIntraBlockOffset =
        (dst->lPitch * dst->wHeight) + (dst->lPitch * (dst->wHeight >> 1) + (8 * dst->lPitch));
    nvMoCompParams.celsiusDestinationViewportXOffset = CELSIUS_DESTINATION_VIEWPORT_XOFFSET;
    nvMoCompParams.celsiusFieldXOffset = (short)nvMoCompParams.surfaceLumaPitch << 2;

    if (pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) {

        if (!(nvInitCelsiusForMoCompPrediction()))
            return FALSE;

        if (nvMoCompParams.surfaceLumaPitch >= 1024) {
            nvDoBidirectionalFieldPrediction = nvDoCelsiusBidirectionalHDFieldPrediction;
            nvDoForwardFieldPrediction = nvDoCelsiusForwardHDFieldPrediction;
            nvDoBackwardFieldPrediction = nvDoCelsiusBackwardHDFieldPrediction;
        } else {
            nvDoBidirectionalFieldPrediction = nvDoCelsiusBidirectionalDVDFieldPrediction;
            nvDoTwoBidirectionalFieldPredictions = nvDoTwoCelsiusBidirectionalDVDFieldPredictions;
            nvDoForwardFieldPrediction = nvDoCelsiusForwardDVDFieldPrediction;
            nvDoTwoForwardFieldPredictions = nvDoTwoCelsiusForwardDVDFieldPredictions;
            nvDoBackwardFieldPrediction = nvDoCelsiusBackwardDVDFieldPrediction;
            nvDoTwoBackwardFieldPredictions = nvDoTwoCelsiusBackwardDVDFieldPredictions;
        }

        nvPredictFrameLumaMacroblock = nvPredictCelsiusFrameLumaMacroblock;
        nvPredictFrameChromaMacroblock = nvPredictCelsiusFrameChromaMacroblock;
        nvPredictFieldLumaMacroblock = nvPredictCelsiusFieldLumaMacroblock;
        nvPredictFieldChromaMacroblock = nvPredictCelsiusFieldChromaMacroblock;

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceLumaPitch);

            nvPusherAdjust(4);

            nvMoCompParams.currentDestinationField = 1;
        }

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        // Perform luma prediction pass
        while (n > 0) {
            numCombinedMacroblocks[macroblockIndex] = 1;
            if (pMacroblock->macroblockType == MB_MOTION_FORWARD) {
                if (n > 1) {
					pMacroblock1 = pMacroblock + 1;
					if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
                                ((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
                                (pMacroblock->fieldSelect[0][0] == pMacroblock1->fieldSelect[0][0]) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;		//no more macroblock left
							pMacroblock1++;
						}
					}
					else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
				}
                    
                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == MB_MOTION_BACKWARD) {
                if (n > 1) {
					pMacroblock1 = pMacroblock + 1;
					if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(pMacroblock->fieldSelect[0][1] == pMacroblock1->fieldSelect[0][1]) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
					else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
				}
                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) {
                if (n > 1) {
					pMacroblock1 = pMacroblock + 1;
					if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
					else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
				}

                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else {
                if (pMacroblock->macroblockType != MB_INTRA)
                    nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock++;
                n--;
            }
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        // Change surface offsets to chroma portion of surface
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);

        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {
            nvMoCompParams.currentDestinationField = 1;
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset + nvMoCompParams.surfaceLumaPitch);
        } else {
            nvMoCompParams.currentDestinationField = 0;
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);
        }

        nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPusherAdjust(8);

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;

        // Perform chroma prediction pass
        while (n > 0) {
            if (pMacroblock->macroblockType != MB_INTRA)
                nvPredictFieldChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
            pMacroblock += numCombinedMacroblocks[macroblockIndex];
            n -= numCombinedMacroblocks[macroblockIndex];
            macroblockIndex++;
        }

        nvPusherStart(TRUE);
    }

    if (!(nvInitCelsiusForMoCompCorrection()))
        return FALSE;

    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    if (nvMoCompParams.surfaceLumaPitch >= 1024) {
        nvDoAllIntraFieldCorrections = nvDoAllCelsiusIntraHDFieldCorrections;
        nvDoAllFieldCorrections = nvDoAllCelsiusHDFieldCorrections;
        nvDoIntraFieldCorrection = nvDoCelsiusIntraHDFieldCorrection;
        nvDoOptimizedIntraFieldCorrection = nvDoOptimizedCelsiusIntraHDFieldCorrection;
        nvDoFieldCorrection = nvDoCelsiusHDFieldCorrection;
    } else {
        nvDoAllIntraFieldCorrections = nvDoAllCelsiusIntraDVDFieldCorrections;
        nvDoAllFieldCorrections = nvDoAllCelsiusDVDFieldCorrections;
        nvDoIntraFieldCorrection = nvDoCelsiusIntraDVDFieldCorrection;
        nvDoOptimizedIntraFieldCorrection = nvDoOptimizedCelsiusIntraDVDFieldCorrection;
        nvDoFieldCorrection = nvDoCelsiusDVDFieldCorrection;
    }

    nvDoAllIntraFrameCorrections = nvDoAllCelsiusIntraFrameCorrections;
    nvDoAllFrameCorrections = nvDoAllCelsiusFrameCorrections;
    nvDoIntraFrameCorrection = nvDoCelsiusIntraFrameCorrection;
    nvDoFrameCorrection = nvDoCelsiusFrameCorrection;

    // Default motion comp correction ICW
    moCompCorrectionICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                          (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                          (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                          (NV056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                          (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                          (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                          (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                          (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                          (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                          (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                          (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                           NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Non-prebiased motion comp correction ICW
    moCompNonPrebiasedCorrectionICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                                      (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                                      (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                                      (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                                      (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                                      (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                                      (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                                      (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                                      (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                                      (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                                      (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                                       NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;

    nvMoCompParams.currentDestinationField = 0;

    pMacroblock = pMacroblocks;
    n = numMacroblocks;

    // This assumes that the first IDCT index of the first macroblock in the command stream is the
    // lowest index in the entire command stream for this call.

    dwSurfaceOffset = pDriverData->dwMCDestinationSurfaceOffset;

    macroblockIndex = 0;

    index = 0;

    while (n > 0) {

        macroblockLimit = n;

        if (macroblockLimit > 24)
            macroblockLimit = 24;

        pDriverData->dwMCFirstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

        dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

        // Force both texture caches to flush
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(1, dwFirstAlignedIDCTOffset);
        nvPushData(2, dwSurfaceOffset);

        nvPusherAdjust(3);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform non-prebiased intrablock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompNonPrebiasedCorrectionICW);

            nvPusherAdjust(2);

            SET_UNBIASED_CORRECTION_DATA_FORMAT();
        } else {
            SET_CORRECTION_DATA_FORMAT();
        }    

        // Perform first correction pass
        if (pDriverData->bMCPictureCodingType == PICTURE_TYPE_I) {
            nvCorrectCelsiusIntraField(pMacroblock, macroblockLimit);
            pMacroblock += macroblockLimit;
            n -= macroblockLimit;
        } else {
            long saveMacroblockLimit = macroblockLimit;

            pMacroblock1 = pMacroblock;

            // Change texture1 surface offset to point to block of half bias values (0x80)
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

            // Change texture0 pitch to 16 bytes
            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
            nvPushData(3, 16 << 16);
            nvPushData(4, 16 << 16); // half bias Intra block pitch

            nvPusherAdjust(5);

            while (--macroblockLimit >= 0) {
                if ((pMacroblock->overflowCodedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                    numCombinedMacroblocks[macroblockIndex++] = (BYTE) index;
                index++;
                if ((pMacroblock->codedBlockPattern != 0) && (pMacroblock->macroblockType == MB_INTRA))
                     nvCorrectCelsiusFieldMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                pMacroblock++;
                --n;
            }

            nvPusherStart(TRUE);

            // Force both texture caches to flush
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
            nvPushData(3, dwFirstAlignedIDCTOffset);
            nvPushData(4, dwSurfaceOffset);

            nvPusherAdjust(5);

            // Change texture0 pitch to 16 bytes
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
            nvPushData(1, 16 << 16);
            nvPushData(2, nvMoCompParams.surfaceLumaPitch << 17);

            nvPusherAdjust(3);

            if (pDriverData->bMCCurrentExecuteFunction ==
                EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                // Modify combiners to perform interblock correction
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                nvPushData(1, moCompCorrectionICW);

                nvPusherAdjust(2);
            }    

            SET_CORRECTION_DATA_FORMAT();

            nvMoCompParams.currentDestinationField = 0;

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if ((pMacroblock->codedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                     nvCorrectCelsiusFieldMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                pMacroblock++;
            }
        }

        nvPusherStart(TRUE);
    }

    pLastMacroblock = pMacroblock - 1;

    if ((pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) && (macroblockIndex > 0)) {

        pMacroblock = pMacroblocks;
        n = macroblockIndex;
        macroblockIndex = 0;
        index = -24;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        // DO NOT REMOVE: This is necessary to work around an NV10 texture cache bug
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPusherAdjust(4);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform interblock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompCorrectionICW);

            nvPusherAdjust(2);
        }    

        SET_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            firstAlignedIDCTIndex = (&pMacroblock[numCombinedMacroblocks[macroblockIndex]])->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 24) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dwSurfaceOffset);

                nvPusherAdjust(3);

                nvMoCompParams.currentDestinationField = 0;
            }

            // Perform overflow correction pass
            nvCorrectCelsiusFieldMacroblock((&pMacroblock[numCombinedMacroblocks[macroblockIndex]]), CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);
    }

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) {
        if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
            surfaceDecodeStatus = 3;
        else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
            surfaceDecodeStatus = 1;
    } else {
        if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
            surfaceDecodeStatus = 12;
        else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
            surfaceDecodeStatus = 4;
    }

    if (surfaceDecodeStatus > formatConversionStatus) {
        LPNVMCSURFACEFLAGS lpSurfaceFlags;

        nvMoCompConvertSurfaceFormat(dst->fpVidMem, TRUE, (DWORD)surfaceDecodeStatus);

        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != dst->fpVidMem))
            lpSurfaceFlags++;

            if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                (pDriverData->bMCTemporalFilterDisabled == FALSE))
                nvMoCompTemporalFilter(dst->fpVidMem, pDriverData->bMCPercentCurrentField);
    }

    return TRUE;

} /* nvMoCompProcessCelsiusFieldMacroblocks */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\MoCorrKelvin.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoCorrKelvin.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)


extern NVMOCOMPPARAMS nvMoCompParams;

extern PNVMCCORRFUNC2 nvDoAllIntraFieldCorrections;
extern PNVMCCORRFUNC2 nvDoAllFieldCorrections;
extern PNVMCCORRFUNC nvDoIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoOptimizedIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoFieldCorrection;

extern PNVMCCORRFUNC nvDoAllIntraFrameCorrections;
extern PNVMCCORRFUNC nvDoAllFrameCorrections;
extern PNVMCCORRFUNC nvDoIntraFrameCorrection;
extern PNVMCCORRFUNC nvDoFrameCorrection;

#ifdef  DEBUG
extern unsigned long moCompDebugLevel;
#endif  // DEBUG




/*
 * nvDoKelvinIntraFrameCorrection
 *
 * Performs frame correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoKelvinIntraFrameCorrection(void)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    
    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(7);

    nvPushData(19, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(20, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(21);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinIntraFrameCorrection */


/*
 * nvDoAllKelvinIntraFrameCorrections
 *
 * Performs frame correction on all blocks in a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllKelvinIntraFrameCorrections(void)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    long                        nextBlockYOffset = 32 << 16;
    
    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40C00000);

    nvPushKelvinMoCompQuadData(7);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    
    nvPushKelvinMoCompQuadData(19);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 -= 32;
    blockX1 -= 32;
    blockY0 += nextBlockYOffset;
    blockY1 += nextBlockYOffset;

    nvPushKelvinMoCompQuadData(31);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;

    nvPushKelvinMoCompQuadData(43);

    nvPushData(55, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(56, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(57);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllKelvinIntraFrameCorrections */



/*
 * nvDoKelvinFrameCorrection
 *
 * Performs frame correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoKelvinFrameCorrection(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    
    texture1BlockX0 = nvMoCompParams.blockX;
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinFrameCorrection */


/*
 * nvDoAllKelvinFrameCorrections
 *
 * Performs frame correction on all blocks in a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllKelvinFrameCorrections(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    long nextBlockYOffset = 32 << 16;
    
    texture1BlockX0 = nvMoCompParams.blockX;
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;
    
    blockX0 = nvMoCompParams.blockX;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40C00000);

    nvPushKelvinMoCompQuadData(3);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    
    nvPushKelvinMoCompQuadData(15);

    texture1BlockX0 -= 32;
    texture1BlockX1 -= 32;
    texture1BlockY0 += nextBlockYOffset;
    texture1BlockY1 += nextBlockYOffset;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 -= 32;
    blockX1 -= 32;
    blockY0 += nextBlockYOffset;
    blockY1 += nextBlockYOffset;

    nvPushKelvinMoCompQuadData(27);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;

    nvPushKelvinMoCompQuadData(39);

    nvPushData(51, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(52, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(53);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllKelvinFrameCorrections */


/*
 * nvCorrectKelvinIntraFrame                                             
 *
 * Processes LUMA blocks in an IntraFrame then makes a 2nd pass and processes chroma blocks
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinIntraFrame(LPNVDECODEMACROBLOCK pFirstMacroblock, long macroblockCount)
{
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    LPNVDECODEMACROBLOCK        pMacroblock;
    unsigned long               IDCTIndex;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    unsigned long               dstSurfacePitch;
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1 = 64;
    long                        texture1BlockY1 = 32 << 16;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0;
    long                        texture0BlockX1 = 64;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    int                         n;
    int                         i;
    
    dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;
            
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    if (pMacroblock->codedBlockPattern == 0xFF) {
        // Change texture0 pitch to 16 bytes
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
        nvPushData(1, 16 << 16);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(3, 16 << 16); // half bias Intra block pitch

        nvPusherAdjust(4);
    }   
    
    i = 0;
    
    nvMoCompParams.destinationField = 0;

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex;
        blockPattern = pMacroblock->codedBlockPattern;

        if (pMacroblock->DCTType != DCT_FIELD) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                nvDoIntraFrameCorrection();
            } else {
                // Change texture0 pitch to 8 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(3, 8 << 16); // half bias Intra block pitch

                nvPusherAdjust(4);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                nvDoAllIntraFrameCorrections();

                // Change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(3, 16 << 16); // half bias Intra block pitch

                nvPusherAdjust(4);
            }

        } else
            i++;

        pMacroblock++;
    }
    
    nvPusherStart(TRUE);

    if (i > 0) { // if there were any DCT_FIELD macroblocks

        pMacroblock = pFirstMacroblock;
        n = macroblockCount;

        // Must temporarily set destination surface pitch back to double it's normal frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, dstSurfacePitch << 1);

        nvPusherAdjust(2);
                
        while (--n >= 0) {
        
            IDCTIndex = pMacroblock->firstIDCTIndex;
            blockPattern = pMacroblock->codedBlockPattern;

            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.destinationField = 0;
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                } else {    
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                }
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (blockPattern >= 0xFC) {
                    nvDoIntraFieldCorrection();
                } else {
                    // Change texture0 pitch to 8 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);
                    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                    nvPushData(3, 8 << 16); // half bias Intra block pitch

                    nvPusherAdjust(4);

                    nvDoAllIntraFieldCorrections(8, 2);

                    // Change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);
                    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                    nvPushData(3, 16 << 16); // half bias Intra block pitch

                    nvPusherAdjust(4);
                }
            }

            pMacroblock++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pFirstMacroblock;
        n = macroblockCount;

        while (--n >= 0) {
        
            IDCTIndex = pMacroblock->firstIDCTIndex;
            blockPattern = pMacroblock->codedBlockPattern;

            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoIntraFieldCorrection();
                } else {
                    // Change texture0 pitch to 8 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);
                    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                    nvPushData(3, 8 << 16); // half bias Intra block pitch

                    nvPusherAdjust(4);

                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllIntraFieldCorrections(8, 2);

                    // Change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);
                    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                    nvPushData(3, 16 << 16); // half bias Intra block pitch

                    nvPusherAdjust(4);
                }
            }

            pMacroblock++;
        }

        nvPusherStart(TRUE);

    }
    

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    if (pDriverData->bMCCurrentExecuteFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
        SET_KELVIN_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT();
    } else {
        SET_KELVIN_CHROMA_CORRECTION_DATA_FORMAT();
    }    

    // Chroma IDCTs are always frame based
    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    nvMoCompParams.destinationField = 0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(1, dstSurfacePitch);

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Temporarily change texture0 pitch to 16 bytes
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    nvPushData(5, 16 << 16);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(7, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(8);

    texture0BlockX1 = 32;
    texture1BlockX1 = 32;
 
    while (n >= 8) {

        n -= 8;
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x41800000);

        i = 3;
        
        while (i < 99) {        
            IDCTIndex = pMacroblock->firstIDCTIndex + 4;

            texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
            texture0BlockY1 = texture0BlockY0 + 32;
            texture0BlockY1 <<= 16;
            texture0BlockY0 <<= 16;

            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

            blockX0 = pMacroblock->hOffset << 1;
            blockY0 = nvMoCompParams.blockY;
            blockY0 <<= 16;
            blockX1 = blockX0 + 32;
            blockY1 = nvMoCompParams.blockY + 32;
            blockY1 <<= 16;

            nvPushKelvinMoCompQuadData(i);
            
            i += 12;

            pMacroblock++;
        }
        
        nvPushData(i, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_BEGIN_END | 0x40000);
        i++;
                       
        nvPushData(i, NV097_SET_BEGIN_END_OP_END);
        
        i++;

        nvPusherAdjust(i);

#ifdef  DEBUG
        if (moCompDebugLevel > 1)
            nvPusherStart(TRUE);
#endif  // DEBUG
    }

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex + 4;

        texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
        texture0BlockY1 = texture0BlockY0 + 32;
        texture0BlockY1 <<= 16;
        texture0BlockY0 <<= 16;

        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

        blockX0 = pMacroblock->hOffset << 1;
        blockY0 = nvMoCompParams.blockY;
        blockY0 <<= 16;
        blockX1 = blockX0 + 32;
        blockY1 = nvMoCompParams.blockY + 32;
        blockY1 <<= 16;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40300000);

        nvPushKelvinMoCompQuadData(3);

        nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV097_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

#ifdef  DEBUG
        if (moCompDebugLevel > 1)
            nvPusherStart(TRUE);
#endif  // DEBUG

        pMacroblock++;
    }

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectKelvinIntraFrame */



/*
 * nvCorrectKelvinFullFrameLumaMacroblock
 *
 * Performs correction on all blocks in macroblock assuming Y0/Y1/Y2/Y3 are in NV optimized format
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinFullFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    unsigned long dstSurfacePitch;
    
    if (pMacroblock->DCTType == DCT_FIELD) {

        dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockWidth = 64;
        nvMoCompParams.blockHeight = 32;
        nvMoCompParams.blockX = pMacroblock->hOffset << 2;
        nvMoCompParams.blockY = pMacroblock->vOffset << 1;

        if (pMacroblock->macroblockType != MB_INTRA) {           

            // Temporarily change texture1 pitch to match destination surface pitch
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, dstSurfacePitch << 17);

            nvPusherAdjust(2);

            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoFieldCorrection();
            nvMoCompParams.destinationField = 1;
            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoFieldCorrection();
            
            // Restore texture1 pitch to it's default value
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

            nvPusherAdjust(2);

        } else {
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoIntraFieldCorrection();
            nvMoCompParams.destinationField = 1;
            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoIntraFieldCorrection();
        }

    } else {
        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockX = pMacroblock->hOffset << 2;
        nvMoCompParams.blockY = pMacroblock->vOffset << 2;

        nvMoCompParams.blockWidth = 64;
        nvMoCompParams.blockHeight = 64;
        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

        if (pMacroblock->macroblockType != MB_INTRA) {
            nvDoFrameCorrection();
        } else
            nvDoIntraFrameCorrection();

    }

} /* nvCorrectKelvinFullFrameLumaMacroblock */


/*
 * nvCorrectKelvinFullFrameChromaMacroblock
 *
 * Performs correction on all blocks in macroblock assuming Y0/Y1/Y2/Y3 are in NV optimized format
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinFullFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long chromaVOffset;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    IDCTIndex += 4;

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    // Chroma IDCTs are always frame based
    nvMoCompParams.correctionField = 0;
    nvMoCompParams.destinationField = 0;
    nvMoCompParams.blockWidth = 32;
    nvMoCompParams.blockHeight = 32;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;
    nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

    if (pMacroblock->macroblockType != MB_INTRA)           
        nvDoFrameCorrection();
    else
        nvDoIntraFrameCorrection();

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectKelvinFullFrameChromaMacroblock */


/*
 * nvCorrectKelvinFrameLumaMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    BYTE blockPattern;
    unsigned long dstSurfacePitch;
    
    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if (pMacroblock->DCTType == DCT_FIELD) {
        // Must temporarily set destination surface pitch back to double it's normal frame pitch
        dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        if (pMacroblock->macroblockType != MB_INTRA) {           
            // Temporarily change texture1 pitch to match destination surface pitch
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, dstSurfacePitch << 17);

            nvPusherAdjust(2);
        }
    }

    if ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) {

        if (pMacroblock->DCTType == DCT_FIELD) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 1;

            if (pMacroblock->macroblockType != MB_INTRA) {           

                if (blockPattern >= 0xFC) {

                    // Temporarily change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);

                    nvPusherAdjust(2);

                    nvMoCompParams.blockWidth = 64;

                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();

                    // Restore texture0 pitch to default value
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);

                    nvPusherAdjust(2);

                } else {

                    nvMoCompParams.blockWidth = 32;

                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllFieldCorrections(8, 2);
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllFieldCorrections(8, 2);
                }
                
            } else {
                if (blockPattern >= 0xFC) {
                    // Temporarily change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);

                    nvPusherAdjust(2);

                    nvMoCompParams.blockWidth = 64;

                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoIntraFieldCorrection();
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoIntraFieldCorrection();

                    // Restore texture0 pitch to default value
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);

                    nvPusherAdjust(2);
                } else {
                    nvMoCompParams.blockWidth = 32;

                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllIntraFieldCorrections(8, 2);
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllIntraFieldCorrections(8, 2);
                }
            }
            
            if (pMacroblock->macroblockType != MB_INTRA) {           
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(2);
            }
        } else {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

                // Temporarily change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);

                if (pMacroblock->macroblockType != MB_INTRA) {          
                    nvDoFrameCorrection();
                } else
                    nvDoIntraFrameCorrection();

                // Restore texture0 pitch to default value
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                if (pMacroblock->macroblockType != MB_INTRA) {          
                    nvDoAllFrameCorrections();
                } else
                    nvDoAllIntraFrameCorrections();
            }
        }

        IDCTIndex += 4;

    } else {

        nvMoCompParams.blockWidth = 32;
        nvMoCompParams.blockHeight = 32;

        if (blockPattern & CBP_Y0) {

            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0; // Component Y0 is in destination field 0
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            if (pMacroblock->DCTType == DCT_FIELD)
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;
            else
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

            if (pMacroblock->macroblockType != MB_INTRA)           
                nvDoFieldCorrection();
            else
                nvDoIntraFieldCorrection();

            IDCTIndex++;
        }

        if (blockPattern & CBP_Y1) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0; // Component Y1 is in destination field 0
            nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
            if (pMacroblock->DCTType == DCT_FIELD)
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;
            else
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
            
            if (pMacroblock->macroblockType != MB_INTRA)           
                nvDoFieldCorrection();
            else
                nvDoIntraFieldCorrection();

            IDCTIndex++;
        }

        if (blockPattern & CBP_Y2) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.destinationField = 1; // Component Y2 is in destination field 1
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;
            } else {
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;
            }
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

            if (pMacroblock->macroblockType != MB_INTRA)           
                nvDoFieldCorrection();
            else
                nvDoIntraFieldCorrection();

            IDCTIndex++;
        }

        if (blockPattern & CBP_Y3) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.destinationField = 1; // Component Y3 is in destination field 1
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;
            } else {
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;
            }
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

            if (pMacroblock->macroblockType != MB_INTRA)           
                nvDoFieldCorrection();
            else
                nvDoIntraFieldCorrection();

            IDCTIndex++;
        }

        if (pMacroblock->DCTType == DCT_FIELD) {
            // Must temporarily set destination surface pitch back to double it's normal frame pitch
            dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

            if (pMacroblock->macroblockType != MB_INTRA) {           
                // Temporarily change texture1 pitch to match destination surface pitch
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(2);
            }
        }
    }

} /* nvCorrectKelvinFrameLumaMacroblock */


/*
 * nvCorrectKelvinFrameChromaMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long chromaVOffset;
    BYTE blockPattern;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) {

        IDCTIndex += 4;

    } else {

        if (blockPattern & CBP_Y0)
            IDCTIndex++;

        if (blockPattern & CBP_Y1)
            IDCTIndex++;

        if (blockPattern & CBP_Y2)
            IDCTIndex++;

        if (blockPattern & CBP_Y3)
            IDCTIndex++;
    }

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    // Chroma IDCTs are always frame based

    if (blockPattern & (CBP_CB | CBP_CR)) {

        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockWidth = 32;
        nvMoCompParams.blockHeight = 32;
        nvMoCompParams.blockX = pMacroblock->hOffset << 1;
        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

        if (pMacroblock->macroblockType != MB_INTRA)           
            nvDoFrameCorrection();
        else
            nvDoIntraFrameCorrection();
    }

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectKelvinFrameChromaMacroblock */




/*
 * nvDoAllKelvinIntraDVDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllKelvinIntraDVDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    long                        yIncr = correctionYIncr << 18;
    long                        nextBlockYOffset = 32 << 16;
    
    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV097_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40600000);
    else
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40C00000);
    
    nvPushKelvinMoCompQuadData(7);

    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    
    nvPushKelvinMoCompQuadData(19);

    nvPusherAdjust(31);

    if (numBlocks == 4) {

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushKelvinMoCompQuadData(0);

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;

        nvPushKelvinMoCompQuadData(12);

        nvPusherAdjust(24);
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllKelvinIntraDVDFieldCorrections */



/*
 * nvDoAllKelvinDVDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllKelvinDVDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    long yIncr = correctionYIncr << 18;
    long nextBlockYOffset = 32 << 16;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0) {
        texture1BlockX0 += nvMoCompParams.surfaceLumaPitch << 2;
        blockX0 += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    }
    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40600000);
    else
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40C00000);

    nvPushKelvinMoCompQuadData(3);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    
    nvPushKelvinMoCompQuadData(15);

    nvPusherAdjust(27);

    if (numBlocks == 4) {

        texture1BlockX0 -= 32;
        texture1BlockX1 -= 32;
        texture1BlockY0 += nextBlockYOffset;
        texture1BlockY1 += nextBlockYOffset;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushKelvinMoCompQuadData(0);

        texture1BlockX0 += 32;
        texture1BlockX1 += 32;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;

        nvPushKelvinMoCompQuadData(12);

        nvPusherAdjust(24);
    }
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllKelvinDVDFieldCorrections */


/*
 * nvDoKelvinIntraDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoKelvinIntraDVDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(4);
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinIntraDVDFieldCorrection */


/*
 * nvDoOptimizedKelvinIntraDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoOptimizedKelvinIntraDVDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoOptimizedKelvinIntraDVDFieldCorrection */


/*
 * nvDoKelvinDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoKelvinDVDFieldCorrection(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0) {
        texture1BlockX0 += nvMoCompParams.surfaceLumaPitch << 2;
        blockX0 += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    }
    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinDVDFieldCorrection */



/*
 * nvCorrectKelvinIntraField
 *
 * Processes LUMA blocks in an IntraField then makes a 2nd pass and processes chroma blocks
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinIntraField(LPNVDECODEMACROBLOCK pFirstMacroblock, long macroblockCount)
{
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    LPNVDECODEMACROBLOCK        pMacroblock;
    unsigned long               IDCTIndex;
    unsigned long               dwSurfaceOffset;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1 = 64;
    long                        texture1BlockY1 = 32 << 16;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0;
    long                        texture0BlockX1 = 64;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    int                         n;
    int                         i;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 1;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(4);
    
    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
        nvMoCompParams.destinationField = 0;
    else    
        nvMoCompParams.destinationField = 1;

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex;
        blockPattern = pMacroblock->codedBlockPattern;

        if (pMacroblock->DCTType == DCT_FIELD) {
            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 16;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;

                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvDoOptimizedIntraFieldCorrection();
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoOptimizedIntraFieldCorrection();

                // IDCTIndex += 2;
                
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY += 16;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvDoOptimizedIntraFieldCorrection();
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoOptimizedIntraFieldCorrection();
                
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                nvDoAllIntraFieldCorrections(8, 4);
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoAllIntraFieldCorrections(8, 4);
            }
        } else {
            if (blockPattern >= 0xFC) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoOptimizedIntraFieldCorrection();
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;

                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);
                
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                nvDoOptimizedIntraFieldCorrection();

                // IDCTIndex++;

                nvMoCompParams.blockX += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                nvDoOptimizedIntraFieldCorrection();

                IDCTIndex++;

                nvMoCompParams.blockX -= 32;
                nvMoCompParams.blockY += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                nvDoOptimizedIntraFieldCorrection();

                IDCTIndex++;

                nvMoCompParams.blockX += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                nvDoOptimizedIntraFieldCorrection();

                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }    
        }
        
        pMacroblock++;
    }
    
    nvPusherStart(TRUE);

    // Chroma IDCTs are always frame based

    dwSurfaceOffset = 0; // Assume destination field 0
    
    if (nvMoCompParams.destinationField != 0) {
        dwSurfaceOffset += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    }

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    while (n >= 8) {

        n -= 8;
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x41800000);
        
        i = 3;
        
        while (i < 99) {        
            IDCTIndex = pMacroblock->firstIDCTIndex + 4;

            texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
            texture0BlockY1 = texture0BlockY0 + 32;
            texture0BlockY1 <<= 16;
            texture0BlockY0 <<= 16;

            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

            blockX0 = dwSurfaceOffset + (pMacroblock->hOffset << 2);
            blockY0 = nvMoCompParams.blockY;
            blockY0 <<= 16;
            blockX1 = blockX0 + 64;
            blockY1 = nvMoCompParams.blockY + 32;
            blockY1 <<= 16;

            nvPushKelvinMoCompQuadData(i);
            
            i += 12;

            pMacroblock++;
        }
        
        nvPushData(i, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_BEGIN_END | 0x40000);
        i++;

        nvPushData(i, NV097_SET_BEGIN_END_OP_END);

        i++;
        
        nvPusherAdjust(i);
    }

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex + 4;

        texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
        texture0BlockY1 = texture0BlockY0 + 32;
        texture0BlockY1 <<= 16;
        texture0BlockY0 <<= 16;

        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

        blockX0 = dwSurfaceOffset + (pMacroblock->hOffset << 2);
        blockY0 = nvMoCompParams.blockY;
        blockY0 <<= 16;
        blockX1 = blockX0 + 64;
        blockY1 = nvMoCompParams.blockY + 32;
        blockY1 <<= 16;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40300000);

        nvPushKelvinMoCompQuadData(3);

        nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV097_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

        pMacroblock++;
    }
} /* nvCorrectKelvinIntraField */


/*
 * nvCorrectKelvinFieldMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 511 assuming all blocks are 4 texels high (by 16 texels wide with 8 texels per field).
 *
 */
void __stdcall nvCorrectKelvinFieldMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long               IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 1;

    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
        nvMoCompParams.destinationField = 0;
    else    
        nvMoCompParams.destinationField = 1;

    if (pMacroblock->macroblockType != MB_INTRA) {          
        if  ((blockPattern >= 0xFC) || 
            ((pMacroblock->DCTType == DCT_FIELD) &&
            ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)))) {

            if (pMacroblock->DCTType == DCT_FIELD) {
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();

                    // IDCTIndex += 2;
                    
                    nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();

                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();
                    
                } else {
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoAllFieldCorrections(8, 4);
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoAllFieldCorrections(8, 4);
                }
            } else {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoFieldCorrection();
            }
            
            IDCTIndex += 4;

        } else {

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
            }

            if (blockPattern & CBP_Y0) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY = 16;
                    nvDoFieldCorrection();
                }            

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }
        }
        
#ifdef  DEBUG
        if (moCompDebugLevel < 3) {
#endif  // DEBUG

        // Chroma IDCTs are always frame based

        if (blockPattern & (CBP_CB | CBP_CR)) {

            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockWidth = 64;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

            nvDoFieldCorrection();
        }

#ifdef  DEBUG
        }
#endif  // DEBUG

    } else { // MB_INTRA

        // Change texture1 surface offset to point to block of half bias values (0x80)
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

        // Change texture1 pitch to 16 bytes
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(3, 16 << 16); // half bias Intra block pitch

        nvPusherAdjust(4);

        if  ((blockPattern >= 0xFC) || 
            ((pMacroblock->DCTType == DCT_FIELD) &&
            ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)))) {

            if (pMacroblock->DCTType == DCT_FIELD) {
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoOptimizedIntraFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();

                    // IDCTIndex += 2;
                    
                    nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();
                    
                } else {
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoAllIntraFieldCorrections(8, 4);
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoAllIntraFieldCorrections(8, 4);
                }
            } else {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoOptimizedIntraFieldCorrection();
            }
            
            IDCTIndex += 4;

        } else {

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
            }
    
            if (blockPattern & CBP_Y0) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY = 16;
                    nvDoOptimizedIntraFieldCorrection();
                }            

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }
        
        }
        
    #ifdef  DEBUG
        if (moCompDebugLevel < 3) {
    #endif  // DEBUG

        // Chroma IDCTs are always frame based

        if (blockPattern & (CBP_CB | CBP_CR)) {

            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockWidth = 64;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

            nvDoOptimizedIntraFieldCorrection();
        }

#ifdef  DEBUG
        }
#endif  // DEBUG
    }
} /* nvCorrectFieldMacroblock */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\MoPredKelvin.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoPredKelvin.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

extern NVMOCOMPPARAMS nvMoCompParams;

extern PNVMCPREDFUNC nvDoBidirectionalFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBidirectionalFieldPredictions;
extern PNVMCPREDFUNC nvDoForwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoForwardFieldPredictions;
extern PNVMCPREDFUNC nvDoBackwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBackwardFieldPredictions;

#ifdef  DEBUG
extern unsigned long moCompDebugLevel;
#endif  // DEBUG


/*
 * nvDoKelvinBidirectionalDVDFieldPrediction
 *
 * Performs bidirectional field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoKelvinBidirectionalDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.5;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    unsigned long   dwSurfaceOffset = 0;
    long            texture1BlockX0;
    long            texture1BlockY0;
    long            texture1BlockX1;
    long            texture1BlockY1;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture1BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX;

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    if (nvMoCompParams.forwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    if (nvMoCompParams.backwardField != 0)
        texture1BlockX0 += dwSurfacePitch;
    
    if (nvMoCompParams.destinationField != 0) 
        blockX0 += dwSurfacePitch;
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(5);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(18, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(19);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinBidirectionalDVDFieldPrediction */


/*
 * nvDoTwoKelvinBidirectionalDVDFieldPredictions
 *
 * Performs two bidirectional field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoKelvinBidirectionalDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 0.5;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    long            texture1BlockX0;
    long            texture1BlockY0;
    long            texture1BlockX1;
    long            texture1BlockY1;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture1BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    if (nvMoCompParams.forwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    if (nvMoCompParams.backwardField != 0)
        texture1BlockX0 += dwSurfacePitch;
    
    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0) 
        blockX0 += dwSurfacePitch;
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40600000);

    nvPushKelvinMoCompQuadData(5);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.forwardVerticalVector2;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector2;

    texture1BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.backwardVerticalVector2;

    if (nvMoCompParams.forwardField2 != 0)
        texture0BlockX0 += dwSurfacePitch;

    if (nvMoCompParams.backwardField2 != 0)
        texture1BlockX0 += dwSurfacePitch;
    
    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField2 != 0) 
        blockX0 += dwSurfacePitch;
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushKelvinMoCompQuadData(17);

    nvPushData(29, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(30, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(31);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoKelvinBidirectionalDVDFieldPredictions */


/*
 * nvDoKelvinForwardDVDFieldPrediction
 *
 * Performs forward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoKelvinForwardDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_FORWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    blockX0 = nvMoCompParams.blockX;

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    if (nvMoCompParams.forwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += dwSurfacePitch;
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40200000);

    nvPushData(5, blockY0 | blockX0);
    nvPushData(6, texture0BlockY0 | texture0BlockX0);
    nvPushData(7, blockY1 | blockX0);
    nvPushData(8, texture0BlockY1 | texture0BlockX0);
    nvPushData(9, blockY1 | blockX1);
    nvPushData(10, texture0BlockY1 | texture0BlockX1);
    nvPushData(11, blockY0 | blockX1);
    nvPushData(12, texture0BlockY0 | texture0BlockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinForwardDVDFieldPrediction */


/*
 * nvDoTwoKelvinForwardDVDFieldPredictions
 *
 * Performs two forward field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoKelvinForwardDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 0.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_FORWARD_VERTEX_ARRAY_MODE();

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    if (nvMoCompParams.forwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += dwSurfacePitch;
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40400000);

    nvPushData(5, blockY0 | blockX0);
    nvPushData(6, texture0BlockY0 | texture0BlockX0);
    nvPushData(7, blockY1 | blockX0);
    nvPushData(8, texture0BlockY1 | texture0BlockX0);
    nvPushData(9, blockY1 | blockX1);
    nvPushData(10, texture0BlockY1 | texture0BlockX1);
    nvPushData(11, blockY0 | blockX1);
    nvPushData(12, texture0BlockY0 | texture0BlockX1);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.forwardVerticalVector2;

    if (nvMoCompParams.forwardField2 != 0)
        texture0BlockX0 += dwSurfacePitch;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField2 != 0)
        blockX0 += dwSurfacePitch;
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(13, blockY0 | blockX0);
    nvPushData(14, texture0BlockY0 | texture0BlockX0);
    nvPushData(15, blockY1 | blockX0);
    nvPushData(16, texture0BlockY1 | texture0BlockX0);
    nvPushData(17, blockY1 | blockX1);
    nvPushData(18, texture0BlockY1 | texture0BlockX1);
    nvPushData(19, blockY0 | blockX1);
    nvPushData(20, texture0BlockY0 | texture0BlockX1);

    nvPushData(21, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(22, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(23);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoKelvinForwardDVDFieldPredictions */



/*
 * nvDoKelvinBackwardDVDFieldPrediction
 *
 * Performs backward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoKelvinBackwardDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 1.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_BACKWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX;

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    if (nvMoCompParams.backwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += dwSurfacePitch;
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40200000);

    nvPushData(5, blockY0 | blockX0);
    nvPushData(6, texture0BlockY0 | texture0BlockX0);
    nvPushData(7, blockY1 | blockX0);
    nvPushData(8, texture0BlockY1 | texture0BlockX0);
    nvPushData(9, blockY1 | blockX1);
    nvPushData(10, texture0BlockY1 | texture0BlockX1);
    nvPushData(11, blockY0 | blockX1);
    nvPushData(12, texture0BlockY0 | texture0BlockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinBackwardDVDFieldPrediction */


/*
 * nvDoTwoKelvinBackwardDVDFieldPredictions
 *
 * Performs two backward field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoKelvinBackwardDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 1.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_BACKWARD_VERTEX_ARRAY_MODE();

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    if (nvMoCompParams.backwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += dwSurfacePitch;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40400000);

    nvPushData(5, blockY0 | blockX0);
    nvPushData(6, texture0BlockY0 | texture0BlockX0);
    nvPushData(7, blockY1 | blockX0);
    nvPushData(8, texture0BlockY1 | texture0BlockX0);
    nvPushData(9, blockY1 | blockX1);
    nvPushData(10, texture0BlockY1 | texture0BlockX1);
    nvPushData(11, blockY0 | blockX1);
    nvPushData(12, texture0BlockY0 | texture0BlockX1);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.backwardVerticalVector2;

    if (nvMoCompParams.backwardField2 != 0)
        texture0BlockX0 += dwSurfacePitch;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField2 != 0)
        blockX0 += dwSurfacePitch;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(13, blockY0 | blockX0);
    nvPushData(14, texture0BlockY0 | texture0BlockX0);
    nvPushData(15, blockY1 | blockX0);
    nvPushData(16, texture0BlockY1 | texture0BlockX0);
    nvPushData(17, blockY1 | blockX1);
    nvPushData(18, texture0BlockY1 | texture0BlockX1);
    nvPushData(19, blockY0 | blockX1);
    nvPushData(20, texture0BlockY0 | texture0BlockX1);

    nvPushData(21, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(22, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(23);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoKelvinBackwardFieldPredictions */


#if 0
/*
 * nvDualPrimeArithmetic
 *
 * Performs new prediction motion vectors from original and differential vectors
 *
 */
void __stdcall nvDualPrimeArithmetic(short DMV[][2],
                                     short *differentialMotionVector,
                                     short horizontalMotionVector,
                                     short verticalMotionVector)
{

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
        if (pDriverData->bMCTopFieldFirst) {
            // Vector for prediction of top field from bottom field
            DMV[0][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[0][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] - 1;

            // Vector for prediction of bottom field from top field
            DMV[1][0] = ((3*horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[1][1] = ((3*verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] + 1;
        } else {
            // Vector for prediction of top field from bottom field
            DMV[0][0] = ((3*horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[0][1] = ((3*verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] - 1;

            // Vector for prediction of bottom field from top field
            DMV[1][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[1][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] + 1;
        }
    } else { // Vector for prediction for field of opposite 'parity'
        DMV[0][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                      differentialMotionVector[0];
        DMV[0][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                      differentialMotionVector[1];

        // Correct for vertical field shift
        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
            DMV[0][1]--;
        else
            DMV[0][1]++;
    }

} /* nvDualPrimeArithmetic */

#endif

/*
 * nvPredictKelvinFrameLumaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units
 *
 */
DWORD __stdcall nvPredictKelvinFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
//    short dmvector[2];
//    short DMV[2][2];

    SET_KELVIN_LUMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    nvMoCompParams.blockWidth = 64 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 2;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

            nvMoCompParams.forwardField = 0;
            nvMoCompParams.backwardField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockHeight = 128;
            nvMoCompParams.blockY = pMacroblock->vOffset << 3;
            nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] << 1;
            nvMoCompParams.forwardVerticalVector = pMacroblock->PMV[0][0][1] << 2;
            nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] << 1;
            nvMoCompParams.backwardVerticalVector = pMacroblock->PMV[0][1][1] << 2;

            nvDoBidirectionalFieldPrediction(FALSE);

        } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

            nvMoCompParams.blockHeight = 64;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            // Top field prediction
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.destinationField = 0;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

            nvMoCompParams.blockY2 = nvMoCompParams.blockY;

            // Bottom field prediction
            nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
            nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
            nvMoCompParams.destinationField2 = 1;
            *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

            nvDoTwoBidirectionalFieldPredictions(FALSE);
            
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if ((pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {
                
                nvMoCompParams.forwardField = 0;
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockHeight = 128;
                nvMoCompParams.blockY = pMacroblock->vOffset << 3;
                nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] << 1;
                nvMoCompParams.forwardVerticalVector = pMacroblock->PMV[0][0][1] << 2;

                nvDoForwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                // Top field prediction
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                nvDoTwoForwardFieldPredictions(FALSE);
                
            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_DP) { // Dual prime prediction

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      (short)(pMacroblock->PMV[0][0][1] >> 1));

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);

                // Predict top field from top field
                // and add to top field from bottom field
                nvMoCompParams.forwardField = 0;
                nvMoCompParams.backwardField = 1;
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                nvDoBidirectionalFieldPrediction(FALSE);

                // Predict bottom field from bottom field
                // and add to bottom field from top field
                nvMoCompParams.forwardField = 1;
                nvMoCompParams.backwardField = 0;
                nvMoCompParams.destinationField = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoBidirectionalFieldPrediction(FALSE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);
                
            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

                nvMoCompParams.backwardField = 0;
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockHeight = 128;
                nvMoCompParams.blockY = pMacroblock->vOffset << 3;
                nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] << 1;
                nvMoCompParams.backwardVerticalVector = pMacroblock->PMV[0][1][1] << 2;

                nvDoBackwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                // Top field prediction
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoTwoBackwardFieldPredictions(FALSE);
            }
        }
    }

    return TRUE;

} /* nvPredictKelvinFrameLumaMacroblock */


/*
 * nvPredictKelvinFrameChromaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units.
 *       This function assumes chroma format is interleaved CrCb so predictions are
 *       performed at twice the horizontal offset and width so that only 1 pass is required.
 *       This 16 bit pixel format also requires that the prediction functions be notified
 *       that they must use a pitch of half the default size when attempting to access field 1.
 *
 */
DWORD __stdcall nvPredictKelvinFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
//    short dmvector[2];
//    short DMV[2][2];

    SET_KELVIN_CHROMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    nvMoCompParams.destinationField = 0;
    nvMoCompParams.forwardField = 0;
    nvMoCompParams.backwardField = 0;
    nvMoCompParams.blockWidth = 32 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

            if (pMacroblock->PMV[0][0][0] < 0) 
                pMacroblock->PMV[0][0][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][0][1] < 0) 
                pMacroblock->PMV[0][0][1] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][0] < 0) 
                pMacroblock->PMV[0][1][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][1] < 0) 
                pMacroblock->PMV[0][1][1] += 1; // round toward 0

            nvMoCompParams.blockHeight = 64;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;
            nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] & 0xFFFE;
            nvMoCompParams.forwardVerticalVector = (pMacroblock->PMV[0][0][1] & 0xFFFE) << 1;
            nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] & 0xFFFE;
            nvMoCompParams.backwardVerticalVector = (pMacroblock->PMV[0][1][1] & 0xFFFE) << 1;

            nvDoBidirectionalFieldPrediction(TRUE);

        } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockY = pMacroblock->vOffset << 1;

            if (pMacroblock->PMV[0][0][0] < 0) 
                pMacroblock->PMV[0][0][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][0][1] < 0) 
                pMacroblock->PMV[0][0][1] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][0] < 0) 
                pMacroblock->PMV[0][1][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][1] < 0) 
                pMacroblock->PMV[0][1][1] += 1; // round toward 0

            if (pMacroblock->PMV[1][0][0] < 0) 
                pMacroblock->PMV[1][0][0] += 1; // round toward 0

            if (pMacroblock->PMV[1][0][1] < 0) 
                pMacroblock->PMV[1][0][1] += 1; // round toward 0

            if (pMacroblock->PMV[1][1][0] < 0) 
                pMacroblock->PMV[1][1][0] += 1; // round toward 0

            if (pMacroblock->PMV[1][1][1] < 0) 
                pMacroblock->PMV[1][1][1] += 1; // round toward 0

            // Top field prediction
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.destinationField = 0;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

            nvMoCompParams.blockY2 = nvMoCompParams.blockY;

            // Bottom field prediction
            nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
            nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
            nvMoCompParams.destinationField2 = 1;
            *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;
            *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

            nvDoTwoBidirectionalFieldPredictions(TRUE);
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if ((pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {
            
                if (pMacroblock->PMV[0][0][0] < 0) 
                    pMacroblock->PMV[0][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][0][1] < 0) 
                    pMacroblock->PMV[0][0][1] += 1; // round toward 0

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] & 0xFFFE;
                nvMoCompParams.forwardVerticalVector = (pMacroblock->PMV[0][0][1] & 0xFFFE) << 1;

                nvDoForwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (pMacroblock->PMV[0][0][0] < 0) 
                    pMacroblock->PMV[0][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][0][1] < 0) 
                    pMacroblock->PMV[0][0][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][0][0] < 0) 
                    pMacroblock->PMV[1][0][0] += 1; // round toward 0
                    
                if (pMacroblock->PMV[1][0][1] < 0) 
                    pMacroblock->PMV[1][0][1] += 1; // round toward 0
                
                // Top field prediction
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                nvDoTwoForwardFieldPredictions(TRUE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_DP) { // Dual prime prediction

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      (short)(pMacroblock->PMV[0][0][1] >> 1));

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);

                if (pMacroblock->PMV[0][0][0] < 0) 
                    pMacroblock->PMV[0][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][0][1] < 0) 
                    pMacroblock->PMV[0][0][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][0][0] < 0) 
                    pMacroblock->PMV[1][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[1][0][1] < 0) 
                    pMacroblock->PMV[1][0][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][0] < 0) 
                    pMacroblock->PMV[1][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][1] < 0) 
                    pMacroblock->PMV[1][1][1] += 1; // round toward 0

                // Predict top field from top field
                // and add to top field from bottom field
                nvMoCompParams.forwardField = 0;
                nvMoCompParams.backwardField = 1;
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                nvDoBidirectionalFieldPrediction(TRUE);

                // Predict bottom field from bottom field
                // and add to bottom field from top field
                nvMoCompParams.forwardField = 1;
                nvMoCompParams.backwardField = 0;
                nvMoCompParams.destinationField = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                nvDoBidirectionalFieldPrediction(TRUE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);
            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

                if (pMacroblock->PMV[0][1][0] < 0) 
                    pMacroblock->PMV[0][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][1][1] < 0) 
                    pMacroblock->PMV[0][1][1] += 1; // round toward 0

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] & 0xFFFE;
                nvMoCompParams.backwardVerticalVector = (pMacroblock->PMV[0][1][1] & 0xFFFE) << 1;

                nvDoBackwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (pMacroblock->PMV[0][1][0] < 0) 
                    pMacroblock->PMV[0][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][1][1] < 0) 
                    pMacroblock->PMV[0][1][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][0] < 0) 
                    pMacroblock->PMV[1][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][1] < 0) 
                    pMacroblock->PMV[1][1][1] += 1; // round toward 0

                // Top field prediction
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                nvDoTwoBackwardFieldPredictions(TRUE);
            }
        }
    }

    return TRUE;

} /* nvPredictKelvinFrameChromaMacroblock */


/*
 * nvPredictKelvinFieldLumaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units
 *
 */
DWORD __stdcall nvPredictKelvinFieldLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    unsigned long currentField;
    unsigned long doBackwardPrediction;
//    short dmvector[2];
//    short DMV[2][2];

    SET_KELVIN_LUMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    // Destination field offset already set at init time
    nvMoCompParams.destinationField = 0;

    nvMoCompParams.blockWidth = 64 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        // Field based prediction
        if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.blockHeight = 64;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

            nvDoBidirectionalFieldPrediction(FALSE);

        } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

            nvMoCompParams.blockHeight = 32;

            // Top half
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

            // Bottom half
            nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
            nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
            nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
            nvMoCompParams.blockY2 = nvMoCompParams.blockY + 32;
            *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

            nvDoTwoBidirectionalFieldPredictions(FALSE);
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
                currentField = 0;
            else
                currentField = 1;

            doBackwardPrediction = 0; // previous frame

            // Determine which frame to use for prediction
            if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                 pDriverData->bMCSecondField &&
                (currentField != pMacroblock->fieldSelect[0][0]))
                doBackwardPrediction = 1; // same frame

            // Field based prediction
            if ((pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {

                nvMoCompParams.blockHeight = 64;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 32;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }

                doBackwardPrediction = 0; // previous frame

                // Determine which frame to use for lower prediction
                if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                     pDriverData->bMCSecondField &&
                    (currentField != pMacroblock->fieldSelect[1][0]))
                    doBackwardPrediction = 1; // same frame

                nvMoCompParams.blockY += 32;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_DP) { // Dual prime prediction

                if (pDriverData->bMCSecondField)
                    doBackwardPrediction = 1; // same frame
                else
                    doBackwardPrediction = 0; // previous frame

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      pMacroblock->PMV[0][0][1]);


                if (doBackwardPrediction)
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
                else
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);
                
                // Predict from field of same parity
                // added to field of opposite parity
                nvMoCompParams.forwardField = (BYTE)currentField;
                nvMoCompParams.backwardField = (BYTE)currentField ^ 1;
                nvMoCompParams.blockHeight = 64;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                // nvMoCompParams.backwardHorizontalVector = DMV[0][0];
                // nvMoCompParams.backwardVerticalVector = DMV[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                nvDoBidirectionalFieldPrediction(FALSE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);

            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            // Field based prediction
            if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.blockHeight = 64;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                nvDoBackwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 32;

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY2 = nvMoCompParams.blockY + 32;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoTwoBackwardFieldPredictions(FALSE);

            } else {
                // Error
                return FALSE;
            }
        }
    }

    return TRUE;

} /* nvPredictKelvinFieldLumaMacroblock */


/*
 * nvPredictKelvinFieldChromaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units.
 *       This function assumes chroma format is interleaved CrCb so predictions are
 *       performed at twice the horizontal offset and width so that only 1 pass is required.
 *       This 16 bit pixel format also requires that the prediction functions be notified
 *       that they must use a pitch of half the default size when attempting to access field 1.
 *
 */
DWORD __stdcall nvPredictKelvinFieldChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    unsigned long currentField;
    unsigned long doBackwardPrediction;
//    short dmvector[2];
//    short DMV[2][2];

    SET_KELVIN_CHROMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    // Destination field offset already set at init time
    nvMoCompParams.destinationField = 0;

    nvMoCompParams.blockWidth = 32 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;
    nvMoCompParams.blockY = pMacroblock->vOffset << 1;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        // Field based prediction
        if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.blockHeight = 32;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

            nvDoBidirectionalFieldPrediction(TRUE);

        } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

            nvMoCompParams.blockHeight = 16;

            // Top half
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

            // Bottom half
            nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
            nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
            nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
            nvMoCompParams.blockY2 = nvMoCompParams.blockY + 16;
            *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]);
            *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]);

            nvDoTwoBidirectionalFieldPredictions(TRUE);

        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
                currentField = 0;
            else
                currentField = 1;

            doBackwardPrediction = 0; // previous frame

            // Determine which frame to use for prediction
            if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                 pDriverData->bMCSecondField &&
                (currentField != pMacroblock->fieldSelect[0][0]))
                doBackwardPrediction = 1; // same frame

            // Field based prediction
            if ((pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {

                nvMoCompParams.blockHeight = 32;

                if (doBackwardPrediction) {

                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 16;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }

                doBackwardPrediction = 0; // previous frame

                // Determine which frame to use for lower prediction
                if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                     pDriverData->bMCSecondField &&
                    (currentField != pMacroblock->fieldSelect[1][0]))
                    doBackwardPrediction = 1; // same frame

                nvMoCompParams.blockY += 16;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_DP) { // Dual prime prediction

                if (pDriverData->bMCSecondField)
                    doBackwardPrediction = 1; // same frame
                else
                    doBackwardPrediction = 0; // previous frame

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      pMacroblock->PMV[0][0][1]);

                if (doBackwardPrediction)
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
                else
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);

                // Predict from field of same parity
                // added to field of opposite parity
                nvMoCompParams.forwardField = (BYTE)currentField;
                nvMoCompParams.backwardField = (BYTE)currentField ^ 1;
                nvMoCompParams.blockHeight = 32;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
                // nvMoCompParams.backwardHorizontalVector = DMV[0][0] >> 1;
                // nvMoCompParams.backwardVerticalVector = DMV[0][1] >> 1;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                nvDoBidirectionalFieldPrediction(TRUE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);

            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            // Field based prediction
            if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.blockHeight = 32;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

                nvDoBackwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 16;

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

                nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY2 = nvMoCompParams.blockY + 16;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]);

                nvDoTwoBackwardFieldPredictions(TRUE);

            } else {
                // Error
                return FALSE;
            }
        }
    }

    return TRUE;

} /* nvPredictKelvinFieldChromaMacroblock */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nv4Tables.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nv4Tables.cpp                                                     *
*   NV4 Triangle Inner Loops. (Originally Machine Generated)                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal          05/23/98    NV4 development                    *
*       Craig Duttweiler     29Oct99     converted to general               *
*                                        repository of tables for nv4       *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

DWORD dwDrawPrimitiveTable[DRAW_PRIM_TABLE_ENTRIES+4] =
{
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x040*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x080*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x0c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x100*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x140*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x180*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x1c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x200*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x240*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x280*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x2c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x300*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x340*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x380*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x3c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x400*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x440*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x480*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x4c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x500*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x540*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x580*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x5c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x600*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x640*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x680*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x6c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x700*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x740*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x780*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x7c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x800*/
    (DWORD)NULL,
    (DWORD)nvDX5TriangleSetup,
    (DWORD)NULL,
    (DWORD)nvDX6TriangleSetup
};

DWORD nv4DP2OpToStride [D3D_DP2OP_MAX+1] =
{
    ~0,                             //   0  invalid
    ~0,                             //   1  D3DDP2OP_POINTS
    ~0,                             //   2  D3DDP2OP_INDEXEDLINELIST
    LEGACY_STRIDES,                 //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                             //   4  invalid
    ~0,                             //   5  invalid
    ~0,                             //   6  invalid
    ~0,                             //   7  invalid
    ~0,                             //   8  D3DDP2OP_RENDERSTATE
    ~0,                             //   9  invalid
    ~0,                             //  10  invalid
    ~0,                             //  11  invalid
    ~0,                             //  12  invalid
    ~0,                             //  13  invalid
    ~0,                             //  14  invalid
    ~0,                             //  15  D3DDP2OP_LINELIST
    ~0,                             //  16  D3DDP2OP_LINESTRIP
    ~0,                             //  17  D3DDP2OP_INDEXEDLINESTRIP
    LIST_STRIDES,                   //  18  D3DDP2OP_TRIANGLELIST
    STRIP_STRIDES,                  //  19  D3DDP2OP_TRIANGLESTRIP
    STRIP_STRIDES,                  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    FAN_STRIDES,                    //  21  D3DDP2OP_TRIANGLEFAN
    FAN_STRIDES,                    //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    FAN_STRIDES,                    //  23  D3DDP2OP_TRIANGLEFAN_IMM
    ~0,                             //  24  D3DDP2OP_LINELIST_IMM
    ~0,                             //  25  D3DDP2OP_TEXTURESTAGESTATE
    LIST_STRIDES,                   //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    ~0,                             //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                             //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                             //  29  D3DDP2OP_WINFO
    ~0,                             //  30  D3DDP2OP_SETPALETTE
    ~0,                             //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                             //  32  D3DDP2OP_ZRANGE
    ~0,                             //  33  D3DDP2OP_SETMATERIAL
    ~0,                             //  34  D3DDP2OP_SETLIGHT
    ~0,                             //  35  D3DDP2OP_CREATELIGHT
    ~0,                             //  36  D3DDP2OP_SETTRANSFORM
    ~0,                             //  37  D3DDP2OP_EXT
    ~0,                             //  38  D3DDP2OP_TEXBLT
    ~0,                             //  39  D3DDP2OP_STATESET
    ~0,                             //  40  D3DDP2OP_SETPRIORITY
    ~0,                             //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                             //  42  D3DDP2OP_CLEAR
    ~0,                             //  43  D3DDP2OP_SETTEXLOD
    ~0                              //  44  D3DDP2OP_SETCLIPPLANE
};

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvAGP.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvAGP.cpp                                                         *
*   AGP Allocation routines.                                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 01/12/99 - per context agp heap man.    *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)


//#define SANITY              // do sanity checks
//#define ANALSANITYCHECK     // do a real good job of sanity checking
//#define STATS               // print heap statistics
//#define TIME_ALLOC          // time AGPAlloc calls

#ifdef ANALSANITYCHECK
#define SANITY
#endif

//****************************************************************************
// constants
//****************************************************************************
#define REALSIZE(size)          (4 + ALIGN + GAPSIZE * 2 + (size))
#define MINCHUNKSIZE            (4 * REALSIZE(256 * 256 * 2))       // fit 4 256x256x16 textures
#define ALIGN                   (NV_TEXTURE_OFFSET_ALIGN + 1)
#define GROWSIZE                (128 * sizeof(AGPHEADER))
#define SLACK                   4

#ifdef DEBUG
#define GAPSIZE                 (ALIGN * 4) // must be aligned
#else
#define GAPSIZE                 0
#endif

//
// flags
//
#define AGPFLAG_ALLOCATED       0x00000001
#define AGPFLAG_DISCONTINUITY   0x00000002
#define AGPFLAG_UNUSED          0x00000004

//
// macros
//
#define ISALLOC(x)          ((x) & AGPFLAG_ALLOCATED)
#define ISFREE(x)           (!ISALLOC(x))
#define ISDISCONTINUOUS(x)  ((x) & AGPFLAG_DISCONTINUITY)
#define ISCONTINUOUS(x)     (!ISDISCONTINUOUS(x))
#define ISAVAILABLE(x)      ((x) & AGPFLAG_UNUSED)
#define ISUSED(x)           (!ISAVAILABLE(x))

#ifdef NV_AGP
#define LOWERGAPSTART(p)    (((p)->dwMemory - GAPSIZE))                    // lower no-mans-land
#define UPPERGAPSTART(p)    (((p)->dwMemory + (p)->dwSize))               // upper no-mans-land
#else
#define LOWERGAPSTART(p)    (AGPMEM_ADDR((p)->dwMemory - GAPSIZE))         // lower no-mans-land
#define UPPERGAPSTART(p)    (AGPMEM_ADDR((p)->dwMemory + (p)->dwSize))     // upper no-mans-land
#endif

#define HEADERPTR(dw)       (((dw) == ~0)  ? (AGPHEADER*)NULL : (AGPHEADER*)(getDC()->dwAGPHeapList + (dw)))
#define HEADERADDR(p)       (((p) == NULL) ? ~0 : ((DWORD)p - getDC()->dwAGPHeapList))

#define HASHPTR(dw)         (((dw) == ~0)  ? (AGPHASHENTRY*)NULL : (AGPHASHENTRY*)(getDC()->dwAGPHashTable + (dw)))
#define HASHADDR(p)         (((p) == NULL) ? ~0 : ((DWORD)p - getDC()->dwAGPHashTable))

#define AGPALLOCFLAG_USER   1 // return a user mode address for this allocation


//****************************************************************************
// structures
//****************************************************************************

#ifdef NV_AGP

typedef struct _AGPMAPPING
{
    NV_CFGEX_UNMAP_USER_SPACE_PARAMS addr;
    DWORD dwProcessId;
    _AGPMAPPING *pNext;
} AGPMAPPING, *PAGPMAPPING;

static DWORD      m_dwRMID;
static DWORD      m_dwRootHandle     = 0;
static DWORD      m_dwDeviceHandle   = AGP_DEVICE_HANDLE;
static AGPMAPPING m_pPendingMappings = { { 0, 0 }, 0, 0 };

#endif // NV_AGP

typedef struct
{
    DWORD  dwFlags;         // block status

    DWORD  dwRealMemory;    // actual memory block base
    DWORD  dwRealSize;      // actual memory block size (amount allocated)

    DWORD  dwMemory;        // address returned
    DWORD  dwSize;          // size requested by caller
#ifdef DEBUG
    DWORD  dwSerial;        // allocation serial number (DEBUG only)
#endif // DEBUG
#ifdef NV_AGP
    DWORD  dwRMID;          // block ID
    NV_CFGEX_UNMAP_USER_SPACE_PARAMS addr; // user mode address and memory descriptor list
    DWORD  dwProcessId;     // process ID of creator (when needed)
#else // !NV_AGP
    DWORD  _pad[2];
#endif // !NV_AGP

} AGPHEADER;

typedef struct
{
    DWORD dwAddress;        // actual user address (NULL implies a free entry)
    DWORD dwAGPListOffset;  // offset to surface descriptor (AGPHEADER)
    DWORD dwNext;           // offset to next hash table entry
    DWORD dwPrev;           // offset to prev hash table entry
} AGPHASHENTRY;

//****************************************************************************
// helpers
//****************************************************************************

#ifdef NV_AGP
inline DWORD nvMapUserSpace(AGPHEADER *pCurr)
{
    NV_CFGEX_MAP_USER_SPACE_PARAMS addr;

    addr.kAddr = (void *)pCurr->dwMemory;
    addr.mSize = pCurr->dwSize;
    addr.ppMDL = &pCurr->addr.pMDL;

    DWORD dwRes = NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_MAP_USER_SPACE, &addr, sizeof(addr));

    pCurr->addr.uAddr  = addr.uAddr;
    pCurr->dwProcessId = GetCurrentProcessId();
    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Mapped AGP address %08x, user space = %08x (pMDL = %08x, PID = %d)", pCurr->dwMemory, pCurr->addr.uAddr, pCurr->addr.pMDL, pCurr->dwProcessId);

    return dwRes;
}

//-------------------------------------------------------------------------

void nvPurgeAGPMappings(DWORD dwProcessId)
{
    AGPMAPPING *pPrev = &m_pPendingMappings;
    AGPMAPPING *pNext;
    DWORD dwFreed = 0, dwTotal = 0;

    for (AGPMAPPING *pMapping = m_pPendingMappings.pNext; pMapping; pMapping = pNext)
    {
        pNext = pMapping->pNext;
        if (pMapping->dwProcessId == dwProcessId) {
            NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_UNMAP_USER_SPACE, &pMapping->addr, sizeof(pMapping->addr));
            pPrev->pNext = pNext;
            dwFreed++;
            delete pMapping;
        }
        dwTotal++;
    }

    if (dwFreed) {
        DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Cleaned out %d pending mappings for process %d (%d mappings remaining)", dwFreed, dwProcessId, dwTotal - dwFreed);
    }
}

//-------------------------------------------------------------------------

inline void nvUnmapUserSpace(AGPHEADER *pCurr)
{

    DWORD dwProcessId = GetCurrentProcessId();

    // purge any pending mappings for this process
    if (m_pPendingMappings.pNext) {
        nvPurgeAGPMappings(dwProcessId);
    }

    if (pCurr->dwProcessId == dwProcessId) {
        // unmap
        DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "   Unmapping AGP address %08x, user space = %08x (pMDL = %08x)", pCurr->dwMemory, pCurr->addr.uAddr, pCurr->addr.pMDL);
        NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_UNMAP_USER_SPACE, &pCurr->addr, sizeof(pCurr->addr));
    } else {
        // wrong process ID, add this mapping to pending list
        DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "   Pending mapping added for process %d", pCurr->dwProcessId);
        AGPMAPPING *pNewMapping = new AGPMAPPING;
        if (pNewMapping) {
            pNewMapping->addr.uAddr  = pCurr->addr.uAddr;
            pNewMapping->addr.pMDL   = pCurr->addr.pMDL;
            pNewMapping->dwProcessId = pCurr->dwProcessId;
            pNewMapping->pNext       = m_pPendingMappings.pNext;
            m_pPendingMappings.pNext = pNewMapping;
        }
    }
}
#endif // NV_AGP

//-------------------------------------------------------------------------

#if 0
void dbgValidateAGPMemory(DWORD dwMem, DWORD dwSize)
{
    DWORD dwLimit = ((dwSize + 4095) & ~4095) - 1;

    NV_CFGEX_MEM_INFO_PARAMS info;
    DWORD dwRes = NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_MEM_INFO, &info, sizeof(info));
    DPF("PAT = %08x:%08x", info.uPATHigh, info.uPATLow);
    for(int i = 0; i < 8; i++)
    {
        if (info.uMTRRphysMaskLow[i] & 0x800)
        {
            DPF("MTRRphysBase%d = %08x:%08x, MTRRphysMask%d = %08x:%08x",
                i, info.uMTRRphysBaseHigh[i], info.uMTRRphysBaseLow[i],
                i, info.uMTRRphysMaskHigh[i], info.uMTRRphysMaskLow[i]);
        }
    }
    DWORD _CR3;
    _asm {
        mov eax, cr3;
        mov [_CR3], eax
    }

    for(DWORD dwOffset = 0; dwOffset < dwLimit; dwOffset += 4 * 1024)
    {
        DWORD dwAddress   = dwMem + dwOffset;
        DWORD dwDirectory = (dwAddress >> 22);
        DWORD dwTable     = (dwAddress >> 12) & 0x3FF;
        DWORD dwPTE       = 0x80000000 | _CR3 | (dwDirectory << 2);

        DWORD dwL1 = *(DWORD*)dwPTE;
        DWORD dwL2 = 0x80000000 + (dwL1 & 0xFFFFF000) + (dwTable << 2);
        DWORD dwL3 = *(DWORD*)dwL2;
        DWORD dwCache1 = ((dwL1 >> 3) & 0x03) | ((dwL1 >> 5) & 0x04);
        DWORD dwCache2 = ((dwL3 >> 3) & 0x03) | ((dwL3 >> 5) & 0x04);
        if ((dwCache1 != 0) || (dwCache2 != 1))
        {
            DPF("cache problem @ addr %08x (%08x) %03x %03x", dwAddress, dwL3 & 0xFFFFF000, dwCache1, dwCache2);
            _asm int 3;
        }
    }
}
#endif

//-------------------------------------------------------------------------

DWORD AllocAGPHeap
(
    DWORD dwSize
)
{
    dbgTracePush ("AllocAGPHeap");

    DWORD pAGPMem;

    dwSize += NV_TEXTURE_PAD;

    // get dd global
    LPDDRAWI_DIRECTDRAW_GBL pDrv = getDC()->getDDGlobal();

#ifdef NV_AGP
    DWORD dwLimit = ((dwSize + 4095) & ~4095) - 1;
    ULONG status = NvRmAllocMemory (m_dwRootHandle, 
                                    m_dwDeviceHandle,
                                    m_dwRMID,
                                    NV01_MEMORY_SYSTEM,
                                    (DRF_DEF(OS02, _FLAGS, _LOCATION, _AGP) |
                                    DRF_DEF(OS02, _FLAGS, _COHERENCY, _WRITE_COMBINE)),
                                    (PVOID *) &pAGPMem,
                                    (unsigned long *) &dwLimit);

    if (status) {
        DPF("AllocAGPHeap failed, out of memory");
        return ERR_DXALLOC_FAILED;
    }
    NV_CFGEX_GET_AGP_OFFSET_PARAMS addr;
    addr.linaddr = (void*)pAGPMem;
    NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_AGP_OFFSET, &addr, sizeof(addr));
    if (addr.offset + dwLimit > pDriverData->regMaxAGPLimit) {
        // memory was allocated, but lies outside the context dma range, free it and return an error
        NvRmFree (m_dwRootHandle, m_dwDeviceHandle, m_dwRMID);
        DPF("AllocAGPHeap failed, out of range");
        return ERR_DXALLOC_FAILED;
    }
#else
    pAGPMem = (DWORD)DDHAL32_VidMemAlloc(pDrv, AGP_HEAP, dwSize, 1);
#endif

    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Allocated AGP block at %08x (size = %08x)", pAGPMem, dwSize);

    dbgTracePop();
    return pAGPMem;
}

//-------------------------------------------------------------------------

BOOL FreeAGPHeap
(
    AGPHEADER *pCurr
)
{
    dbgTracePush("FreeAgpHeap");

    // get dd global
    LPDDRAWI_DIRECTDRAW_GBL pDrv = getDC()->getDDGlobal();

#ifdef NV_AGP
    // there should be no user mapping on a free block
    nvAssert(pCurr->addr.uAddr == 0);

    if (NvRmFree (m_dwRootHandle, m_dwDeviceHandle, pCurr->dwRMID)) {
        DPF("FreeAGPHeap failed");
        nvAssert (0);
        return FALSE;
    }
#else
    DDHAL32_VidMemFree(pDrv, AGP_HEAP, pCurr->dwRealMemory);
#endif

    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Freed AGP block at %08x (size = %08x)", pCurr->dwRealMemory, pCurr->dwRealSize);
    
    dbgTracePop();
    return TRUE;
}

//
// nvAGPAddBackPointer
//
// adds an address to the list of back pointers
//
BOOL nvAGPAddBackPointer
(
    DWORD      dwAddress,
    AGPHEADER *pHeader
)
{
    nvAssert(dwAddress);

    // get hash table index
    DWORD  dwIndex    = ((dwAddress >> 16) ^ (dwAddress >> 8)) & 255;
    DWORD *pHashTable = (DWORD*)getDC()->dwAGPHashTableHead;

    // if have no hash table list yet, get one
    if (!pHashTable)
    {
        getDC()->dwAGPHashTableHead = (DWORD)AllocIPM(4 * 256);
        pHashTable = (DWORD*)getDC()->dwAGPHashTableHead;
        assert (pHashTable);
        memset (pHashTable,~0,4 * 256);
    }

    for (AGPHASHENTRY *pEntry = HASHPTR(0);;)
    {
        // find a free hash table entry
        AGPHASHENTRY *pMax = (AGPHASHENTRY*)(getDC()->dwAGPHashTable + getDC()->dwAGPHashTableMax);
        for (; pEntry < pMax; pEntry++)
        {
            if (!pEntry->dwAddress)
            {
                // add to list (this becomes the new first entry)
                pEntry->dwAddress        = dwAddress;
                pEntry->dwAGPListOffset  = HEADERADDR(pHeader);
                pEntry->dwNext           = pHashTable[dwIndex];
                pEntry->dwPrev           = HASHADDR(NULL);
                AGPHASHENTRY *pEntryOld  = HASHPTR(pHashTable[dwIndex]);
                pHashTable[dwIndex]      = HASHADDR(pEntry);
                if (pEntryOld)
                {
                    pEntryOld->dwPrev    = pHashTable[dwIndex];
                }
                // done
                return TRUE;
            }
        }

        // out of space, make more space
        DWORD dwOldMax = getDC()->dwAGPHashTableMax;
        getDC()->dwAGPHashTableMax += sizeof(AGPHASHENTRY) * 256;
        void *pNewMem;
        if (!ReallocIPM((void*)getDC()->dwAGPHashTable, getDC()->dwAGPHashTableMax, &pNewMem))
        {
            DPF("nvAGPAddBackPointer: ReallocIPM failed");
            return FALSE;
        }
        getDC()->dwAGPHashTable = (DWORD)pNewMem;

        // clear out new part
        memset ((void*)(getDC()->dwAGPHashTable + dwOldMax),0,sizeof(AGPHASHENTRY) * 256);

        // loop back so we can find an entry. we know where one is, so we help a little
        pEntry = (AGPHASHENTRY*)(getDC()->dwAGPHashTable + dwOldMax);
    }

    dbgD3DError();
    return TRUE;
}

//
// nvAGPRemoveBackPointer
//
// removes a back pointer from the hash table
//
void nvAGPRemoveBackPointer
(
    AGPHASHENTRY *pEntry
)
{
    AGPHASHENTRY *pNext = HASHPTR(pEntry->dwNext);
    AGPHASHENTRY *pPrev = HASHPTR(pEntry->dwPrev);
    nvAssert(pEntry->dwAddress);
    if (pNext) pNext->dwPrev = pEntry->dwPrev;
    if (pPrev) pPrev->dwNext = pEntry->dwNext;
    else
    {
        DWORD  dwAddress    = pEntry->dwAddress;
        DWORD  dwIndex      = ((dwAddress >> 16) ^ (dwAddress >> 8)) & 255;
        DWORD *pHashTable   = (DWORD*)getDC()->dwAGPHashTableHead;
        pHashTable[dwIndex] = HASHADDR(pNext);
    }

#ifdef DEBUG
    memset (pEntry,0,sizeof(*pEntry));
#else
    pEntry->dwAddress = 0;
#endif
}

//
// nvAGPFindBackPointer
//
// finds the AGPHEADER that matches the given address
//
AGPHASHENTRY* nvAGPFindBackPointer
(
    DWORD dwAddress
)
{
    // valid hash table?
    if (!getDC()->dwAGPHashTable)
    {
        return NULL;
    }

    // get hash table index
    DWORD  dwIndex    = ((dwAddress >> 16) ^ (dwAddress >> 8)) & 255;
    DWORD *pHashTable = (DWORD*)getDC()->dwAGPHashTableHead;

    // find the address
    AGPHASHENTRY *pEntry = HASHPTR(pHashTable[dwIndex]);
    while (pEntry)
    {
#ifdef DEBUG
        if (!pEntry->dwAddress)
        {
            DPF("nvAGPFindBackPointer: AGP heap insane - empty table entry");
            __asm int 3;
            return NULL;
        }
#endif // DEBUG

        // test
        if (pEntry->dwAddress == dwAddress)
        {
            // got it
            return pEntry;
        }

        // next
        pEntry = HASHPTR(pEntry->dwNext);
    }

    // not found
    return NULL;
}


// debug stuff
#ifdef DEBUG

DWORD dwSerial      = 0;
DWORD dwSerialBreak = 0;

//
// nvAGPDebugTestSetup
//
// fills the no-mans-land around a surface with a known value so we can track
// cases where stuff overwrites the assigned boundaries or something else
// corrupts our memory
//
void nvAGPDebugTestSetup
(
    AGPHEADER *pHeader
)
{
    void *pLowerGapStart = (void*)LOWERGAPSTART(pHeader);
    void *pUpperGapStart = (void*)UPPERGAPSTART(pHeader);

    memset (pLowerGapStart, 0xe7, GAPSIZE);
    memset (pUpperGapStart, 0xe7, GAPSIZE);
}

//
// nvAGPDebugTest
//
// checks that the preset no-mans-land is intact. fail if not.
//
void nvAGPDebugTest
(
    AGPHEADER *pHeader
)
{
    DWORD dwLowerGapStart = LOWERGAPSTART(pHeader);
    DWORD dwUpperGapStart = UPPERGAPSTART(pHeader);
    DWORD dw,cnt;

    for (cnt = GAPSIZE,dw = dwLowerGapStart; cnt; dw++, cnt--)
    {
        if ((*(BYTE*)dw) != 0xe7)
        {
            DPF("AGPHeap underfill : Gap %08x : Fail %08x",dwLowerGapStart,dw);
            DPF("                    pHeader  = %08x",pHeader);
            DPF("                    S#       = %08x",pHeader->dwSerial);
            dbgD3DError();
        }
    }

    for (cnt = GAPSIZE,dw = dwUpperGapStart; cnt; dw++, cnt--)
    {
        if ((*(BYTE*)dw) != 0xe7)
        {
            DPF("AGPHeap overfill : Gap %08x : Fail %08x",dwUpperGapStart,dw);
            DPF("                   pHeader  = %08x",pHeader);
            DPF("                   S#       = %08x",pHeader->dwSerial);
            dbgD3DError();
        }
    }
}

//
// nvAGPHeapDump
//
// shows all memory block
//
void nvAGPHeapDump
(
    void
)
{
    DWORD i, j;

    for (i = getDC()->dwAGPHeapListMax, j = 0; i; j += sizeof(AGPHEADER), i -= sizeof(AGPHEADER))
    {
        char       s1[256];
        char       s2[256];
        AGPHEADER *pCurr = HEADERPTR(j);

        nvSprintf (s1,"%08x:",j);
        if (pCurr->dwFlags & AGPFLAG_DISCONTINUITY)
        {
            nvStrCat (s1," dis");
        }
        if (pCurr->dwFlags & AGPFLAG_UNUSED)
        {
            nvStrCat (s1," empty");
        }
        else
        {
            nvSprintf (s2," rm=0x%08x rs=%d", pCurr->dwRealMemory, pCurr->dwRealSize);
            nvStrCat (s1,s2);

            if (pCurr->dwFlags & AGPFLAG_ALLOCATED)
            {
                nvSprintf (s2," m=0x%08x s=%d #=0x%x", pCurr->dwMemory, pCurr->dwSize, pCurr->dwSerial);
                nvStrCat (s1,s2);
            }
            else
            {
                nvStrCat (s1," free");
            }
        }

        DPF("%s.",s1);
    }
}

//
// nvAGPHeapSanity
//
// checks that the agp heap is intact and setup properly
//
void nvAGPHeapSanity
(
    void
)
{
    DWORD i,j;

    for (i = getDC()->dwAGPHeapListMax, j = 0; i; j += sizeof(AGPHEADER),i -= sizeof(AGPHEADER))
    {
        AGPHEADER *pCurr = HEADERPTR(j);

        // find next
        DWORD      k      = i      - sizeof(AGPHEADER);
        AGPHEADER *pNext = pCurr + 1;
        while (k && ISAVAILABLE(pNext->dwFlags))
        {
            pNext ++;
            k      -= sizeof(AGPHEADER);
        }
        if (!k) pNext = NULL;

        // test back pointer
        if (ISALLOC(pCurr->dwFlags))
        {
            DWORD         dwMemory = pCurr->dwMemory;
            AGPHASHENTRY *pEntry  = nvAGPFindBackPointer(dwMemory);
            DWORD         dwTemp   = pEntry->dwAGPListOffset;

            if (dwTemp != j)
            {
                DPF("nvAGPHeapSanity: back pointer invalid");
                DPF("                 pCurr    = %08x",pCurr);
                DPF("                 dwMemory = %08x",dwMemory);
                DPF("                 dwTemp   = %08x",dwTemp);
                DPF("                 j        = %08x",j);
                DPF("                 S#       = %08x",pCurr->dwSerial);
                DPF("Hit F5 to dump heap blocks...");
                dbgD3DError();
                nvAGPHeapDump();
                __asm int 3;
            }
        }

        // test size
        if ((pNext)
         && ISUSED(pCurr->dwFlags)
         && ISUSED(pNext->dwFlags)
         && ISCONTINUOUS(pNext->dwFlags))
        {
            // real size & memory check out?
            if (pCurr->dwRealMemory + pCurr->dwRealSize != pNext->dwRealMemory)
            {
                DPF("nvAGPHeapSanity: real memory addr & size does not check out");
                DPF("                 pCurr    = %08x",pCurr);
                DPF("                 j        = %08x",j);
                DPF("                 S#       = %08x",pCurr->dwSerial);
                DPF("Hit F5 to dump heap blocks...");
                dbgD3DError();
                nvAGPHeapDump();
                __asm int 3;
            }
        }

        // is memory contained properly and aligned strict enough?
        if (ISALLOC(pCurr->dwFlags))
        {
            DWORD dwRealEnd = pCurr->dwRealMemory + pCurr->dwRealSize;
            DWORD dwEnd     = pCurr->dwMemory     + pCurr->dwSize;

            if ((pCurr->dwMemory < pCurr->dwRealMemory)
             || (dwEnd > dwRealEnd)
             || (pCurr->dwMemory & (ALIGN - 1)))
            {
                DPF("nvAGPHeapSanity: memory outsize of valid range Or not aligned");
                DPF("                 pCurr    = %08x",pCurr);
                DPF("                 dwMemory = %08x",pCurr->dwMemory);
                DPF("                 j        = %08x",j);
                DPF("                 S#       = %08x",pCurr->dwSerial);
                DPF("Hit F5 to dump heap blocks...");
                dbgD3DError();
                nvAGPHeapDump();
                __asm int 3;
            }

#ifdef ANALSANITYCHECK
            // test for over/underrun
            nvAGPDebugTest(pCurr);
#endif
        }
    }
}
#endif // DEBUG

#ifdef STATS
//
// nvAGPShowStats
//
// prints usage statistics
//
void nvAGPShowStats
(
    void
)
{
    DWORD dwTotalAlloc = 0;
    DWORD dwTotalUsed  = 0;
    DWORD i,j;

    for (i = getDC()->dwAGPHeapListMax, j = 0; i; j += sizeof(AGPHEADER),i -= sizeof(AGPHEADER))
    {
        AGPHEADER *pCurr = HEADERPTR(j);

        if (ISUSED(pCurr->dwFlags))
        {
            dwTotalAlloc += pCurr->dwRealSize;

            if (ISALLOC(pCurr->dwFlags))
            {
                dwTotalUsed += pCurr->dwRealSize;
            }
        }

    }

    DPF ("AGPHeap: %d/%d (%d%%) used", dwTotalUsed,dwTotalAlloc,(dwTotalUsed * 100) / dwTotalAlloc);
}
#endif //STATS

//
// nvAGPListInsertFree
//
// creates a free entry right after dwStart
//  returns TRUE on success
//
BOOL nvAGPListInsertFree
(
    DWORD dwStart,
    DWORD *pdwNew
)
{
    // do we want a specific entry or just one at the end of the list?
    // dwStart == ~0 to request eol
    //
    if (dwStart == ~0)
    {
        DWORD      dwMax;
        AGPHEADER *pCurr;

        // get a free header at end of list
        dwMax = getDC()->dwAGPHeapListMax;
        if (dwMax && (ISAVAILABLE((HEADERPTR(dwMax) - 1)->dwFlags))) // at least one available
        {
            // find first used block from the end of the list
            *pdwNew = dwMax;
            pCurr = HEADERPTR(*pdwNew);
            while (*pdwNew && ISAVAILABLE((pCurr - 1)->dwFlags))
            {
                pCurr --;
                *pdwNew -= sizeof(AGPHEADER);
            }

            // allow some slack space if we can - this introduce bubbles in the
            // list to make insertion faster
            if ((dwMax - *pdwNew) > SLACK * sizeof(AGPHEADER))
            {
                *pdwNew += SLACK * sizeof(AGPHEADER);
                pCurr += SLACK;
            }

            // return it
            return TRUE;
        }
        else
        {
            AGPHEADER *pHeader;
            *pdwNew = dwMax; // start of new block
            DWORD i;

            // alloc more space
            dwMax += GROWSIZE;
            void *pNewMem;
            if (!ReallocIPM((void*)getDC()->dwAGPHeapList, dwMax, &pNewMem))
            {
                DPF("nvAGPListInsertFree, ReallocIPM failed");
                return FALSE;
            }
            getDC()->dwAGPHeapList     = (DWORD)pNewMem;
            getDC()->dwAGPHeapListMax  = dwMax;

            // fill with empty headers
            for (pHeader = HEADERPTR(*pdwNew), i = *pdwNew; i < dwMax; pHeader++, i += sizeof(AGPHEADER))
            {
#ifdef DEBUG
                memset (pHeader,0x77,sizeof(*pHeader));
#endif
                pHeader->dwFlags = AGPFLAG_UNUSED;
            }

            // return appropriate entry (with some slack space)
            *pdwNew += SLACK * sizeof(AGPHEADER);
            return TRUE;
        }
    }
    else
    {
        DWORD      dwCount;
        DWORD      dwMax;
        AGPHEADER *pHeader;
        AGPHEADER *pFree;

        // find first free entry after start
        dwCount = 0;
        *pdwNew = dwStart;
        dwMax   = getDC()->dwAGPHeapListMax;
        pHeader   = HEADERPTR(dwStart);

        while ((*pdwNew < dwMax) && !ISAVAILABLE(pHeader->dwFlags))
        {
            dwCount ++;
            pHeader   ++;
            *pdwNew += sizeof(AGPHEADER);
        }

        // if we have not found one add it to the end
        if (*pdwNew >= dwMax)
        {
            // since we get here we know there are no free entries left
            // the following call will return (grow list) a free entry
            // that we just need to move into place
            //
            if (!nvAGPListInsertFree(~0, pdwNew))
            {
                DPF("nvAGPListInsertFree: nvAGPListInsertFree failed");
                return FALSE;
            }
            pHeader   = HEADERPTR(*pdwNew);
            dwCount = (*pdwNew - dwStart) / sizeof(AGPHEADER);
            dwMax   = getDC()->dwAGPHeapListMax;
        }

        // if the free pointer is not adjacent to start,
        // move the header list to make it so
        // also decrement dwCount so we know how many items to move
        if (--dwCount)
        {
            DWORD i;

            *pdwNew = dwStart + sizeof(AGPHEADER);
            pFree  = HEADERPTR(*pdwNew);
            memmove (pFree + 1,pFree,dwCount * sizeof(AGPHEADER));

            // update the back pointers
            pFree ++;
            for (i = dwCount; i; i--, pFree++)
            {
                if (ISALLOC(pFree->dwFlags)) // is in use
                {
                    AGPHASHENTRY *pEntry = nvAGPFindBackPointer(pFree->dwMemory);
                    if (pEntry)
                    {
                        pEntry->dwAGPListOffset += sizeof(AGPHEADER);
                    }
                }
            }
        }

        // done
        return TRUE;
    }
}

/*****************************************************************************
 * exports
 *****************************************************************************/

// CreateAGPHeap
// top-level routine for creation of the texture heap in AGP memory

BOOL nvAGPCreateHeap(void)
{
    dbgTracePush ("CreateAGPHeap");

    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "nvAGPCreateHeap");

    // shouldn't create the heap more than once
    nvAssert(!pDriverData->nvD3DTexHeapData.dwHandle);
    
    // should only do this if AGP is available
    nvAssert(pDriverData->GARTLinearBase);

    // create context DMA
    if (D3DCreateTextureContexts (pDriverData->GARTLinearBase, pDriverData->regMaxAGPLimit)) {
        dbgTracePop();
        return FALSE;
    }

    // set the handle to indicate heap has been created
    pDriverData->nvD3DTexHeapData.dwHandle = 1;

    nvAGPResetHeap();

#ifdef NV_AGP
    char devName[128];
    DWORD res = NvRmAllocRoot(&m_dwRootHandle);
//    DWORD res = NvAllocRoot(pDriverData->ppdev->hDriver, NV01_ROOT_USER, &m_dwRootHandle);
    nvAssert(res == NVOS01_STATUS_SUCCESS);
    *((DWORD*)devName) = 0;
    res = NvRmAllocDevice (m_dwRootHandle, m_dwDeviceHandle, NV01_DEVICE_0, (BYTE*)devName);
    nvAssert(res == NVOS06_STATUS_SUCCESS);
#endif

    dbgTracePop();
    return TRUE;
}

BOOL nvAGPDestroyHeap(void)
{
    dbgTracePush ("DestroyTextureHeap");

    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "nvAGPDestroyHeap");

    D3DDestroyTextureContexts (pDriverData);

    // Can't destroy a heap if there isn't one.
    nvAssert (getDC()->nvD3DTexHeapData.dwHandle);

    if (!(getDC()->nvD3DTexHeapData.dwHandle)) { 
        return TRUE;
    }

    // should only do this if AGP is available
    nvAssert(pDriverData->GARTLinearBase);

    getDC()->nvD3DTexHeapData.dwHandle = 0;

    dbgTracePop();
    return TRUE;
}

//
// nvAGPCombine
//
// walks all of the local agp heap and merge adjacent free blocks
//
void nvAGPCombine
(
    void
)
{
    DWORD      dwMax;
    DWORD      dwCurr;
    AGPHEADER *pCurr;

    // for all blocks
    dwMax = getDC()->dwAGPHeapListMax;
    for (dwCurr = 0,pCurr = HEADERPTR(0); dwCurr < dwMax;)
    {
        if (ISUSED(pCurr->dwFlags))
        {
            // get next block
            DWORD      dwNext = dwCurr + sizeof(AGPHEADER);
            AGPHEADER *pNext = pCurr + 1;

            while ((dwNext < dwMax) && ISAVAILABLE(pNext->dwFlags))
            {
                dwNext += sizeof(AGPHEADER);
                pNext ++;
            }
            if (dwNext >= dwMax) break;

            // test if both are free and we do not cross a discontinuous boundary
            if (ISFREE(pCurr->dwFlags)
             && ISFREE(pNext->dwFlags)
             && ISCONTINUOUS(pNext->dwFlags))
            {
                // consolidate two blocks
                pCurr->dwRealSize += pNext->dwRealSize;
                pCurr->dwMemory    = 0;
                pCurr->dwSize      = 0;

#ifdef NV_AGP
                // there should be no user mapping on a free block
                nvAssert(pCurr->addr.uAddr == 0);
#endif

                // remove "next" entry from active list
                pNext->dwFlags = AGPFLAG_UNUSED;

                // do not increment dwCurr
                continue;
            }
            else
            // test if we have a dummy block - i.e. no real size
            if (ISFREE(pCurr->dwFlags)
             && (pCurr->dwRealSize == 0))
            {
                // remove redundant entry from active list
                pCurr->dwFlags = AGPFLAG_UNUSED;
            }
        }

        // next
        pCurr ++;
        dwCurr += sizeof(AGPHEADER);
    }

#ifdef SANITY
    nvAGPHeapSanity();
#endif
}

//
// nvAGPReclaim
//
// try to free up unsued memory. usually called after a nvAGPCombine for max effect
//
void nvAGPReclaim
(
    void
)
{
    DWORD      dwMax;
    DWORD      dwCurr;
    AGPHEADER *pCurr;

    // for all blocks
    dwMax = getDC()->dwAGPHeapListMax;
    for (dwCurr = 0,pCurr = HEADERPTR(0); dwCurr < dwMax;)
    {
        if (ISUSED(pCurr->dwFlags))
        {
            // get next block
            DWORD      dwNext = dwCurr + sizeof(AGPHEADER);
            AGPHEADER *pNext = pCurr + 1;
            while ((dwNext < dwMax) && ISAVAILABLE(pNext->dwFlags))
            {
                dwNext += sizeof(AGPHEADER);
                pNext ++;
            }
            if (dwNext >= dwMax) pNext = NULL;

            // see if the whole allocated block is available for freeing
            //  - current block must be free and a discontinuous boundary
            //  - next must either not exist or must be a discontinuous boundary
            if (((pNext && ISDISCONTINUOUS(pNext->dwFlags))
              || (!pNext))
             && ISFREE(pCurr->dwFlags)
             && ISDISCONTINUOUS(pCurr->dwFlags))
            {
                // free AGP memory
                FreeAGPHeap (pCurr);

                // remove block from active list
                pCurr->dwFlags = AGPFLAG_UNUSED;
            }
        }

        // next
        pCurr ++;
        dwCurr += sizeof(AGPHEADER);
    }

#ifdef SANITY
    nvAGPHeapSanity();
#endif
}

//
// nvAGPResetHeap
//
// cleans up the current agp heap if possible, and reset as empty
//
void nvAGPResetHeap
(
    void
)
{
    // combine and reclaim as much memory as possible
    nvAGPCombine();
    nvAGPReclaim();

    // hash table
    if (getDC()->dwAGPHashTable)
    {
        FreeIPM ((void*)getDC()->dwAGPHashTable);
    }
    if (getDC()->dwAGPHashTableHead)
    {
        FreeIPM ((void*)getDC()->dwAGPHashTableHead);
    }
    getDC()->dwAGPHashTableHead = 0;
    getDC()->dwAGPHashTable     = 0;
    getDC()->dwAGPHashTableMax  = 0;

    // zero out
    if (getDC()->dwAGPHeapList)
    {
        FreeIPM ((void*)getDC()->dwAGPHeapList);
    }
    getDC()->dwAGPHeapList    = 0;
    getDC()->dwAGPHeapListMax = 0;

    //  mark the heap as valid
    getDC()->bAGPHeapValid = TRUE;
#ifdef NV_AGP
    m_dwRMID = AGP_MEMORY_OBJECT_LO;
    if (m_dwRootHandle) {
        DWORD res = NvRmFree (m_dwRootHandle, NV01_NULL_OBJECT, m_dwRootHandle);
        m_dwRootHandle = 0;
        nvAssert(res == NVOS00_STATUS_SUCCESS);
    }
#endif
}

//
// nvAGPInvalidate
//
// marks the heap as invalid. useful when MS rips the heap out from under us
// with no warning whatsoever. calling this function will prevent all heap
// access until it's been reallocated and reset
//
void nvAGPInvalidate
(
    void
)
{
    getDC()->bAGPHeapValid = FALSE;
}

#ifdef NV_AGP
//
// nvAGPGetUserAddr
//
// return a user space mapping for the supplied AGP address
//
DWORD nvAGPGetUserAddr(DWORD dwAddr)
{
    AGPHASHENTRY *pEntry = nvAGPFindBackPointer(dwAddr);

    if (!pEntry)
    {
        DPF("nvGetUserModeAddr: Surface is not in our memory context");
        nvAssert(0);
        return NULL;
    }

    AGPHEADER *pCurr = HEADERPTR(pEntry->dwAGPListOffset);
    nvAssert(pCurr);

    // check if we already have a user space mapping
    if (pCurr->addr.uAddr) {
        DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "User mapping for %08x already exists at %08x", pCurr->dwMemory, pCurr->addr.uAddr);
        return (DWORD)pCurr->addr.uAddr;
    }

    // create a user space mapping
    nvMapUserSpace(pCurr);

    return (DWORD)pCurr->addr.uAddr;
}

#endif

//
// nvAGPAlloc
//
// allocates agp memory for textures
//
void* nvAGPAlloc
(
    DWORD dwSize
)
{
    DWORD dwRealSize;
    DWORD i;

    nvAssert (getDC()->bAGPHeapValid);

    // calculate how much memory we really need to allocate
    dwRealSize = REALSIZE(dwSize);

    // try to allocate the memory:
    //  pass 1 - see if we can find a large enough block out of existing set
    //  pass 2 - try to combine adjacent free blocks and try pass 1 again
    //  pass 3 - allocate a large enouch chunk and retry pass 1 - this is guaranteed to work
    for (i = 0; i < 3; i++)
    {
        DWORD      dwMax;
        DWORD      dwCurr;
        AGPHEADER *pCurr;

        // find free space
        dwMax = getDC()->dwAGPHeapListMax;
        for (dwCurr = 0,pCurr = HEADERPTR(0); dwCurr < dwMax; pCurr ++,dwCurr += sizeof(AGPHEADER))
        {
            if (ISUSED(pCurr->dwFlags)
             && ISFREE(pCurr->dwFlags))
            {
                // check if aligned block matches exactly (implies that this alloc matches a previous alloc & free)
                if (pCurr->dwSize == dwSize)
                {
                    // update flags
                    pCurr->dwFlags |= AGPFLAG_ALLOCATED;

                    // debug preps
#ifdef DEBUG
                    nvAGPDebugTestSetup (pCurr);
                    pCurr->dwSerial = ++dwSerial;
                    if (dwSerial == dwSerialBreak) __asm int 3;
#endif //DEBUG
                    // add back pointer to hash table
                    nvAGPAddBackPointer (pCurr->dwMemory,pCurr);

                    // debug checks
#ifdef SANITY
                    nvAGPHeapSanity();
#endif
#ifdef STATS
                    nvAGPShowStats();
#endif

#ifdef NV_AGP
                    // no user address should exist yet
                    nvAssert(pCurr->addr.uAddr == 0);
                    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Allocating AGP memory @ %08x", pCurr->dwMemory);
#endif

                    // done
                    return (void*)pCurr->dwMemory;
                }

                // check if we can fit a block that has to be split
                if (pCurr->dwRealSize >= dwRealSize)
                {
                    DWORD      dwSplit;
                    AGPHEADER *pSplit;

                    // get a free header
                    // reinit some variables since the header list may move in memory
                    if (!nvAGPListInsertFree(dwCurr, &dwSplit))
                    {
                        DPF("nvAGPAlloc: nvAGPListInsertFree failed");
                        nvAssert(0);
                        return (void*)ERR_DXALLOC_FAILED;
                    }
                    pSplit = HEADERPTR(dwSplit);
                    pCurr  = HEADERPTR(dwCurr);
                    dwMax  = getDC()->dwAGPHeapListMax;

#ifdef DEBUG
                    pCurr->dwSerial = ++dwSerial;
                    if (dwSerial  == dwSerialBreak) __asm int 3;
#endif //DEBUG

                    // update split block data
                    pSplit->dwFlags      = 0; // this block is always continuous and always free
                    pSplit->dwRealSize   = pCurr->dwRealSize   - dwRealSize;
                    pSplit->dwRealMemory = pCurr->dwRealMemory + dwRealSize;
                    pSplit->dwSize       = 0;
                    pSplit->dwMemory     = 0;
#ifdef NV_AGP
                    pSplit->addr.uAddr   = 0;
#endif

                    // update current block data
                    pCurr->dwRealSize  = dwRealSize;
                    pCurr->dwFlags    |= AGPFLAG_ALLOCATED;
                    pCurr->dwMemory    = (pCurr->dwRealMemory + GAPSIZE + ALIGN - 1) & ~(ALIGN - 1);
                    if ((pCurr->dwMemory - pCurr->dwRealMemory) <= GAPSIZE) pCurr->dwMemory += ALIGN;
                    pCurr->dwSize      = dwSize;

                    // debug preps
#ifdef DEBUG
                    nvAGPDebugTestSetup (pCurr);
#endif //DEBUG

                    // add back pointer to hash table
                    nvAGPAddBackPointer (pCurr->dwMemory,pCurr);

                    // debug checks
#ifdef SANITY
                    nvAGPHeapSanity();
#endif
#ifdef STATS
                    nvAGPShowStats();
#endif

#ifdef NV_AGP
                    // no user address should exist yet
                    nvAssert(pCurr->addr.uAddr == 0);
                    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Allocating AGP memory @ %08x", pCurr->dwMemory);
#endif

                    // done
                    return (void*)pCurr->dwMemory;
                }
            }
        }

        // nothing found
        switch (i)
        {
            case 0:
            {
                // combine free blocks now and try again
                nvAGPCombine();
                break;
            }
            case 1:
            {
                DWORD      dwCurr;
                AGPHEADER *pCurr;
                DWORD      dwNewMemory;
                DWORD      dwNewSize;

                // use this opportunity to free up unused blocks
                //  this can help / speed up the following alloc
                nvAGPReclaim();

                // allocate a new chunk to fit at least this or MINCHUNKSIZE
                dwNewSize   = max(MINCHUNKSIZE,dwRealSize);
#ifdef TIME_ALLOC
                {
                DWORD a = GetTickCount();
                DWORD b;
#endif
                dwNewMemory = AllocAGPHeap(dwNewSize);
#ifdef TIME_ALLOC
                b = GetTickCount();
                DPF ("%d ms", b-a);
                }
#endif
                if (dwNewMemory == ERR_DXALLOC_FAILED)
                {
                    return (void*)ERR_DXALLOC_FAILED;
                }

                // get a free header at end of list
                if (!nvAGPListInsertFree(~0, &dwCurr))
                {
                    DPF("nvAGPAlloc: nvAGPListInsertFree failed");
                    nvAssert(0);
                    return (void*)ERR_DXALLOC_FAILED;
                }
                pCurr = HEADERPTR(dwCurr);

                // populate
#ifdef NV_AGP
                pCurr->dwRMID       = m_dwRMID;
                pCurr->addr.uAddr   = 0;
#endif
                pCurr->dwFlags      = AGPFLAG_DISCONTINUITY;
                pCurr->dwRealMemory = dwNewMemory;
                pCurr->dwRealSize   = dwNewSize;
                pCurr->dwMemory     = 0;
                pCurr->dwSize       = 0;

#ifdef NV_AGP
                // prepare for next alloc
                m_dwRMID++;
#endif

                // free space finder is guaranteed to find enough space for this request
                break;
            }
        }
    }

    // fail utterly
    //  - this cannot really happen but if it does things are pretty insane already
    DPF("nvAGPAlloc: Reality in AGP-Heap land has failed");
    dbgD3DError();
    return (void*)ERR_DXALLOC_FAILED;
}

//
// nvAGPFree
//
// frees agp memory for textures
//
void nvAGPFree
(
    void *pMem
)
{
    if (!getDC()->bAGPHeapValid)
    {
        return;
    }

    // sanity test
    if (IsBadReadPtr(pMem,4))
    {
        // this texture was allocated with our special heap but the context has
        // been destroyed in the mean time so we cannot free thus we ignore it
        DPF("nvAGPFree: invalid request");
        dbgD3DError();
        return;
    }

    // get back pointer
    AGPHASHENTRY *pEntry = nvAGPFindBackPointer((DWORD)pMem);
    if (!pEntry)
    {
        DPF("nvAGPFree: Surface is not in our memory context. May be OK if mode");
        DPF("           switch just occurred. Ignoring.");
        nvAssert(0);
        return;
    }

    AGPHEADER *pCurr = HEADERPTR(pEntry->dwAGPListOffset);
    if (ISALLOC(pCurr->dwFlags))
    {
        DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Freeing AGP memory @ %08x", pMem);
        // free memory
#ifdef DEBUG
        nvAGPDebugTest (pCurr);
#endif
        pCurr->dwFlags &= ~AGPFLAG_ALLOCATED;

#ifdef NV_AGP
        // delete the user space mapping
        if (pCurr->addr.uAddr) {
            nvUnmapUserSpace(pCurr);
            pCurr->addr.uAddr = 0;
        }
#endif

#ifdef DEBUG
#ifdef NV_AGP
        memset ((void*)pCurr->dwRealMemory, 0xDD, pCurr->dwRealSize);
#else
        memset ((void*)AGPMEM_ADDR(pCurr->dwRealMemory), 0xdd, pCurr->dwRealSize);
#endif
#endif

        // remove back pointer
        nvAGPRemoveBackPointer (pEntry);
    }
    else
    {
        DPF("nvAGPFree: Freeing an already free texture!");
        dbgD3DError();
        return;
    }

#ifdef SANITY
    nvAGPHeapSanity();
#endif
#ifdef STATS
    nvAGPShowStats();
#endif
}

//
// nvAGPGetMemory
//
// returns the total amount of memory we have allocated and how much of it
// is free
//
void nvAGPGetMemory
(
    DWORD *pdwTotal,
    DWORD *pdwFree
)
{
    DWORD      dwTotal = 0;
    DWORD      dwFree  = 0;
    DWORD      dwCurr;
    DWORD      dwMax;
    AGPHEADER *pCurr;

    if (getDC()->bAGPHeapValid) {
        
        // try to compact memory
        nvAGPCombine();
        
        // for all blocks
        dwMax = getDC()->dwAGPHeapListMax;
        for (dwCurr = 0, pCurr = HEADERPTR(0); dwCurr < dwMax;)
        {
            if (ISUSED(pCurr->dwFlags))
            {
                dwTotal += pCurr->dwRealSize;
                if (ISFREE(pCurr->dwFlags)) dwFree += pCurr->dwRealSize;
            }
            
            // next
            pCurr ++;
            dwCurr += sizeof(AGPHEADER);
        }
    }

    // done
    *pdwTotal = dwTotal;
    *pdwFree  = dwFree;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvBlit.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       nvBlit.cpp
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

// Convert pusher threshold from word to safe dword value
const int g_iPusherThreshold = (NVPUSHER_THRESHOLD_SIZE >> 1) - 1;

//---------------------------------------------------------------------------
// GetBltStatus32
//      DX callback
DWORD __stdcall GetBltStatus32 (LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus)
{
    dbgTracePush ("GetBltStatus32");

    DDSTARTTICK(SURF4_GETBLTSTATUS);
    nvSetDriverDataPtrFromDDGbl (lpGetBltStatus->lpDD);

    if ( lpGetBltStatus->dwFlags == DDGBS_CANBLT ) {

        // CANBLT: can we add a blt?

        // make sure that we've flipped away from the destination surface
        lpGetBltStatus->ddRVal = getFlipStatus(lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem,
                                               lpGetBltStatus->lpDDSurface->ddsCaps.dwCaps);

        if ( lpGetBltStatus->ddRVal == DD_OK ) {
            if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
                if (!nvEnable32(lpGetBltStatus->lpDD)) {
                    NvReleaseSemaphore(pDriverData);
                    lpGetBltStatus->ddRVal = DDERR_SURFACELOST;
                    DDENDTICK(SURF4_GETBLTSTATUS);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }
            // so there was no flip going on, is there room in the fifo to add a blt?
            getDC()->nvPusher.setSyncChannelFlag();
            lpGetBltStatus->ddRVal = DD_OK;
        }
    }

    else {

        // DONEBLT: is a blt in progress?

        // Some apps call GetBltStatus many times after calling Blit even after they were told that it was done
        if (pDriverData->blitCalled == FALSE) {
            NvReleaseSemaphore(pDriverData);
            lpGetBltStatus->ddRVal = DD_OK;
            DDENDTICK(SURF4_GETBLTSTATUS);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
            if (!nvEnable32(lpGetBltStatus->lpDD)) {
                NvReleaseSemaphore(pDriverData);
                lpGetBltStatus->ddRVal = DDERR_SURFACELOST;
                DDENDTICK(SURF4_GETBLTSTATUS);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }

        /* If a texture surface then just wait for notifier */
        if (lpGetBltStatus->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {

            /*
             * Only check hardware status if we actually use HW to do texture blts.
             */
/*
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_USEHW)
            {
                BOOL bBusy;
                CNvObject *pObj = GET_PNVOBJ(lpGetBltStatus->lpDDSurface);
                DWORD   dwClass = pObj ? pObj->getClass() : CNvObject::NVOBJ_UNKNOWN;

                switch (dwClass) {
                case CNvObject::NVOBJ_SIMPLESURFACE:
                    bBusy = lpGetBltStatus->ddRVal = pObj->getSimpleSurface()->isBusy();
                    break;
                case CNvObject::NVOBJ_TEXTURE:
                    bBusy = lpGetBltStatus->ddRVal = pObj->getTexture()->getSwizzled()->isBusy();
                    break;
                default:
                    bBusy = WaitForIdle(FALSE, FALSE);
                    break;
                } // switch

                if (bBusy) {
                    nvPusherStart(TRUE);
                    lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
                } else {
                    lpGetBltStatus->ddRVal = DD_OK;
                }
            }
            else
*/
            {
                lpGetBltStatus->ddRVal = DD_OK;
            }

            NvReleaseSemaphore(pDriverData);
            DDENDTICK(SURF4_GETBLTSTATUS);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        /* Is there a DMA push blit synchronization in progress ? */
        if (pDriverData->syncDmaRecord.bSyncFlag) { /* if so then check status */

            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                               pDriverData->bltData.dwStatusReferenceCount,
                                               0)) {
                    lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
                }
                else {
                    lpGetBltStatus->ddRVal = DD_OK;
                    pDriverData->syncDmaRecord.bSyncFlag = FALSE;
                    pDriverData->blitCalled = FALSE;
                }
            }
            else {
                if (getDC()->nvPusher.isIdle(TRUE)) {
                    pDriverData->syncDmaRecord.bSyncFlag = FALSE;
                    pDriverData->blitCalled = FALSE;
                    lpGetBltStatus->ddRVal = DD_OK;
                } else {
                    lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
                    // always make sure everything has been pushed off
                    nvPusherStart(TRUE);
                }
            }
        }
        else { /* start a blit synchronization sequence */
            pDriverData->syncDmaRecord.bSyncFlag = TRUE;

            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                pDriverData->bltData.dwStatusReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_LAZY);
                nvPusherStart (TRUE);
                lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
            }
            else {
                if (getDC()->nvPusher.isIdle(TRUE)) {
                    pDriverData->syncDmaRecord.bSyncFlag = FALSE;
                    pDriverData->blitCalled = FALSE;
                    lpGetBltStatus->ddRVal = DD_OK;
                } else {
                    lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
                    // always make sure everything has been pushed off
                    nvPusherStart(TRUE);
                }
            }
        }
    }

    NvReleaseSemaphore(pDriverData);
    DDENDTICK(SURF4_GETBLTSTATUS);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} // GetBltStatus32

//---------------------------------------------------------------------------

void nvCheckQueuedBlits (void)
{
    // max queued frames is regPreRenderLimit (defaults to 3 - PC99 spec)
    DWORD dwMaxQueuedBlits = getDC()->nvD3DRegistryData.regPreRenderLimit;

    // read HW blit #
    DWORD dwCompletedBlit = getDC()->pBlitTracker->get();

    // have we progressed too far?
    while ((getDC()->dwCurrentBlit - dwCompletedBlit) > dwMaxQueuedBlits)
    {
        // kick off buffer
        nvPusherStart (TRUE);
        // wait for HW to catch up
        nvDelay();
        dwCompletedBlit = getDC()->pBlitTracker->get();
    }
}

//---------------------------------------------------------------------------

void nvUpdateBlitTracker (void)
{
    // update frame counters
    getDC()->dwCurrentBlit ++;
    getDC()->pBlitTracker->put (getDC()->dwCurrentBlit);
    // kick off buffer
    nvPusherStart (TRUE);
}

//---------------------------------------------------------------------------
// bltInit
//      Initialize blit globals
void __stdcall bltInit(void)
{
    pDriverData->bltData.dwSystemSurfaceContextDMAIndex = 0;
    pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    pDriverData->bltAGPMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    pDriverData->bltVidMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    pDriverData->bltData.dwLastRop = 0xFFFFFFFF;
    pDriverData->bltData.dwLastColourKey = 0xFFFFFFF0;
    pDriverData->bltData.dwLastColourFormat = 0;
    pDriverData->bltData.dwLastCombinedPitch = 0;
    pDriverData->bltData.dwLastSrcOffset = 0xFFFFFFFF;
    pDriverData->bltData.dwLastDstOffset = 0xFFFFFFFF;
    pDriverData->bltData.dwSystemBltFallback = FALSE;
    pDriverData->bltData.dwLetItThrash = FALSE;
}

//---------------------------------------------------------------------------
// Blit32
//      DX callback.  Uber-function for calling all the blit styles
//
// Hints and rules of thumb
//      - bltSimpleCopy and blt4CCto4CC do not required Surfaces2D to be
//        initialized, all other blit functions do
//      - bltSimpleCopy can handle all combinations of sources and destinations
//        except for system memory to system memory copies
//      - bltSimpleVtoVBlt must have both source and destination is local
//        video memory
//      - Only bltSimpleVtoVBlt can handle colour keys and non-trivial ROPs
//      - bltStrBlt may return NOT_HANDLED
//      - bltStrBlt sources can be in local or system memory
//      - bltStrBlt destination must be in local video memory
//      - Error checks are required for workspace allocation
//      - When using an intermediate workspace, remember to set Surfaces2D
//      - Be careful about using workspaces for multiple things that can't
//        be done in place.  Color keyed S->V and 8 bpp strblts already use
//        local workspaces

#ifdef  STEREO_SUPPORT
#ifdef  PER_PRIMITIVE_SYNC
#define SyncToHw                                \
        StereoSync();               
#else   //PER_PRIMITIVE_SYNC==0
#define SyncToHw
#endif  //PER_PRIMITIVE_SYNC

#define CheckStereoSecondPass                   \
        if (--dwNPasses)                        \
            goto StereoSecondPass;
#else   //STEREO_SUPPORT==0
#define CheckStereoSecondPass
#define SyncToHw
#endif  //STEREO_SUPPORT

#define BLT_ABNORMAL_EXIT                       \
        {                                       \
            SyncToHw;                           \
            if (dst.bDefaultBlitChanged) {                                  \
                nvPushData(0, dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000); \
                nvPushData(1, NV_DD_IMAGE_BLIT);                            \
                nvPusherAdjust(2);                                          \
            }                                           \
        if (bRewriteSurfData) {                                   \
            dst.pGbl->fpVidMem = fpOldVidMem;                           \
            dst.pGbl->lPitch = lOldPitch;                               \
            dst.pGbl->wHeight = wOldHeight;                             \
                dst.pGbl->wWidth = wOldWidth;                               \
            }                                                             \
            CheckStereoSecondPass;              \
            DDENDTICK(SURF4_BLT);               \
            NvReleaseSemaphore(pDriverData);    \
            dbgTracePop();                      \
            return retVal;                      \
        }

#define BLT_EXIT                                                            \
    {                                                                       \
      SyncToHw;                                                             \
      if (dst.bDefaultBlitChanged) {                                        \
            nvPushData(0, dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);     \
            nvPushData(1, NV_DD_IMAGE_BLIT);                                \
            nvPusherAdjust(2);                                              \
            nvPusherStart(TRUE);                                            \
        }                                                                   \
        if (bRewriteSurfData) {                             \
        dst.pGbl->fpVidMem = fpOldVidMem;                               \
        dst.pGbl->lPitch = lOldPitch;                                   \
        dst.pGbl->wHeight = wOldHeight;                                 \
            dst.pGbl->wWidth = wOldWidth;                                   \
        }                                                                   \
        if (dst.bIsLocked)                                                  \
        {                                                                   \
            if (dst.pObj->getClass()==CNvObject::NVOBJ_TEXTURE)             \
            {                                                               \
                if( dst.bUseSwizzle ) {                                     \
                    dst.pObj->getTexture()->getSwizzled()->hwUnlock();      \
                    dst.pObj->getTexture()->getSwizzled()->tagUpToDate();   \
                    dst.pObj->getTexture()->getLinear()->tagOutOfDate();    \
                } else {                                                    \
                    dst.pObj->getTexture()->getLinear()->hwUnlock();        \
                    dst.pObj->getTexture()->getLinear()->tagUpToDate();     \
                    dst.pObj->getTexture()->getSwizzled()->tagOutOfDate();  \
                }                                                           \
            } else                                                          \
                dst.pObj->getSimpleSurface()->hwUnlock();                   \
            nvPusherStart(TRUE);                                            \
            dst.bIsLocked = FALSE;                                          \
        }                                                                   \
        if (src.bIsLocked)                                                  \
        {                                                                   \
            if (src.pObj->getClass()==CNvObject::NVOBJ_TEXTURE)             \
            {                                                               \
                if( src.bUseSwizzle ) {                                     \
                    src.pObj->getTexture()->getSwizzled()->hwUnlock();      \
                    src.pObj->getTexture()->getSwizzled()->tagUpToDate();   \
                    src.pObj->getTexture()->getLinear()->tagOutOfDate();    \
                } else {                                                    \
                    src.pObj->getTexture()->getLinear()->hwUnlock();        \
                    src.pObj->getTexture()->getLinear()->tagUpToDate();     \
                    src.pObj->getTexture()->getSwizzled()->tagOutOfDate();  \
                }                                                           \
            } else                                                          \
                src.pObj->getSimpleSurface()->hwUnlock();                   \
            nvPusherStart(TRUE);                                            \
            src.bIsLocked = FALSE;                                          \
        }                                                                   \
        if (retVal == DDHAL_DRIVER_HANDLED) {                               \
            CheckStereoSecondPass;                                          \
            if (doFlushOnExit) {                                            \
                getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY); \
            }                                                               \
            DDENDTICK(SURF4_BLT);                                           \
            NvReleaseSemaphore(pDriverData);                                \
            dbgTracePop();                                                  \
            return retVal;                                                  \
        }                                                                   \
    }

//---------------------------------------------------------------------------

DWORD __stdcall Blit32( LPDDHAL_BLTDATA pbd )
{
    SURFINFO src, dst, ws;
    DWORD dwPbdFlags;
    DWORD retVal = DDHAL_DRIVER_HANDLED;
    DWORD dwBytesPerPixel;
    BOOL doStretchX, doStretchY, doStretch;
    BOOL doMirrorX, doMirrorY, doMirror;
    BOOL doFlushOnExit;
    BOOL bDoEarlyBlitFallback = FALSE;
    BOOL bStretchLinearFilter = TRUE;
    BOOL bRewriteSurfData = FALSE;
    BOOL bSrcBPPSpecified = FALSE;

    FLATPTR fpOldVidMem = NULL;
    LONG lOldPitch = 0;

#ifdef WINNT
    DWORD wOldHeight = 0;
    DWORD wOldWidth = 0;
#else
    WORD wOldHeight = 0;
    WORD wOldWidth = 0;
#endif

#ifdef  STEREO_SUPPORT
    STEREOBLTPASSINFO StereoBltPass;
    StereoBltPass.dwPass = 0;
    DWORD   dwNPasses = 1;
#endif  //STEREO_SUPPORT

    dbgTracePush ("Blit32");

    DDSTARTTICK(SURF4_BLT);

    nvSetDriverDataPtrFromDDGbl (pbd->lpDD);
    DWORD dwModeBPP = GET_MODE_BPP();

    dwPbdFlags = pbd->dwFlags;

    dwBytesPerPixel = (dwModeBPP + 1) >> 3;

    // force the blit wait flag if requested in the registry
    if (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_FORCEBLITWAITFLAGENABLE_ENABLE) {
        dwPbdFlags |= DDBLT_WAIT;
    }

    // force flush on exit if DDBLT_WAIT flag is set & registry key is enabled
    doFlushOnExit = (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_FLUSHAFTERBLITENABLE_ENABLE) &&
                    (dwPbdFlags & DDBLT_WAIT);

    // get commonly used surface data
    src.pLcl = pbd->lpDDSrcSurface;
    dst.pLcl = pbd->lpDDDestSurface;
    src.dwFourCC = dst.dwFourCC = 0;
    src.dwCaps = dst.dwCaps = 0;
    src.pObj = dst.pObj = NULL;
    src.pGbl = dst.pGbl = NULL;
    src.dwPitch = dst.dwPitch = 0;
    src.dwWidth = dst.dwWidth = 0;
    src.dwHeight = dst.dwHeight = 0;
    src.dwOffset = dst.dwOffset = 0;
    src.fpVidMem = dst.fpVidMem = 0;
    src.isPotentialFault = dst.isPotentialFault = FALSE;
    src.dwBytesPerPixel = dst.dwBytesPerPixel = dwBytesPerPixel;
    src.bUseSwizzle = dst.bUseSwizzle = FALSE;
    src.bIsLocked = dst.bIsLocked = FALSE;
    src.bDefaultBlitChanged = dst.bDefaultBlitChanged = FALSE;

    if(dst.pLcl){
        //have to set this BEFORE we do the
        //becuase it is used to determing the
        //ContextDMA optimization while
        //seting up the src object.
        dst.dwCaps = dst.pLcl->ddsCaps.dwCaps;
    }

    // source info
    if (src.pLcl) {
        src.pObj = GET_PNVOBJ(src.pLcl);
        src.dwCaps = src.pLcl->ddsCaps.dwCaps;
        src.pGbl = src.pLcl->lpGbl;
        src.dwSubRectX = pbd->rSrc.left;
        src.dwSubRectY = pbd->rSrc.top;
        src.dwSubRectWidth = pbd->rSrc.right - src.dwSubRectX;
        src.dwSubRectHeight = pbd->rSrc.bottom - src.dwSubRectY;
        if (src.pGbl) {
            src.fpVidMem = src.pGbl->fpVidMem;
            src.dwPitch = src.pGbl->lPitch;
            src.dwWidth = src.pGbl->wWidth;
            src.dwHeight = src.pGbl->wHeight;
            if (src.pLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) {
                bSrcBPPSpecified = TRUE;
                if (src.pGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
                    src.dwFourCC = src.pGbl->ddpfSurface.dwFourCC;
                    src.dwBytesPerPixel = 2;
                } else {
                    src.dwBytesPerPixel = (src.pGbl->ddpfSurface.dwRGBBitCount + 1) >> 3;
                }
            }
            if (src.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
                if ((src.dwCaps & DDSCAPS_TEXTURE) || (dst.dwCaps & DDSCAPS_TEXTURE)) {
                    // system or AGP memory and not a texture (D3D will handle this)
                    src.dwOffset = 0;
                    src.dwContextDma = 0;
                } else if (pDriverData->bltData.dwSystemBltFallback) {
                    src.dwContextDma = 0;
                    bDoEarlyBlitFallback = TRUE;
                } else {
#ifndef WINNT
                    // don't do this for WINNT because they can sometimes hand us an aliased linear address
                    // to an AGP surface which is nowhere near the GARTLinearBase that we know about
                    if ((src.dwCaps & DDSCAPS_NONLOCALVIDMEM) && pDriverData->GARTLinearBase) {
                        // AGP memory
                        src.dwContextDma = D3D_CONTEXT_DMA_HOST_MEMORY;
                        src.dwOffset = AGPMEM_OFFSET(src.pGbl->fpVidMem);
                    } else {
#endif
                        // system memory
                        src.dwOffset = 0;
                        retVal = bltCreateContextDMA(pbd, &src);
                        if (retVal != DDHAL_DRIVER_HANDLED) {
                            src.dwContextDma = 0;
                            bDoEarlyBlitFallback = TRUE;
                        }
#ifndef WINNT
                    }
#endif
                }
            } else {
                // video memory
                src.dwOffset = VIDMEM_OFFSET(src.pGbl->fpVidMem);
                src.dwContextDma = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
            }
        }
        // do this last, need the invalid one to create a context DMA
        src.pObj = IS_VALID_PNVOBJ(src.pObj) ? src.pObj : NULL;
    }

    // destination info
    if (dst.pLcl) {
        dst.pObj = GET_PNVOBJ(dst.pLcl);
        dst.dwCaps = dst.pLcl->ddsCaps.dwCaps;
        dst.pGbl = dst.pLcl->lpGbl;
        dst.dwSubRectX = pbd->rDest.left;
        dst.dwSubRectY = pbd->rDest.top;
        dst.dwSubRectWidth = pbd->rDest.right - dst.dwSubRectX;
        dst.dwSubRectHeight = pbd->rDest.bottom - dst.dwSubRectY;
        if (dst.pGbl) {
            dst.fpVidMem = dst.pGbl->fpVidMem;
            dst.dwPitch = dst.pGbl->lPitch;
            dst.dwWidth = dst.pGbl->wWidth;
            dst.dwHeight = dst.pGbl->wHeight;
            if (dst.pLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) {
                if (dst.pGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
                    dst.dwFourCC = dst.pGbl->ddpfSurface.dwFourCC;
                    dst.dwBytesPerPixel = 2;
                } else {
                    dst.dwBytesPerPixel = (dst.pGbl->ddpfSurface.dwRGBBitCount + 1) >> 3;
                }
                if (!bSrcBPPSpecified) {
                    src.dwBytesPerPixel = dst.dwBytesPerPixel;
                }
            }
            if (dst.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM) 
                && (dst.dwFourCC!=FOURCC_DXT1) && (dst.dwFourCC!=FOURCC_DXT2)  
                && (dst.dwFourCC!=FOURCC_DXT3) && (dst.dwFourCC!=FOURCC_DXT4) 
                && (dst.dwFourCC!=FOURCC_DXT5)) {
                // system or AGP memory
                if (pDriverData->bltData.dwSystemBltFallback) {
                    dst.dwContextDma = 0;
                    bDoEarlyBlitFallback = TRUE;
                } else {
#ifndef WINNT
                    // don't do this for WINNT because they can sometimes hand us an aliased linear address
                    // to an AGP surface which is nowhere near the GARTLinearBase that we know about
                    if ((dst.dwCaps & DDSCAPS_NONLOCALVIDMEM) && pDriverData->GARTLinearBase) {
                        // AGP memory
                        dst.dwContextDma = D3D_CONTEXT_DMA_HOST_MEMORY;
                        dst.dwOffset = AGPMEM_OFFSET(dst.pGbl->fpVidMem);
                    } else {
#endif
                        // system memory
                        dst.dwOffset = 0;
                        retVal = bltCreateContextDMA(pbd, &dst);
                        if (retVal != DDHAL_DRIVER_HANDLED) {
                            dst.dwContextDma = 0;
                            bDoEarlyBlitFallback = TRUE;
                        }
#ifndef WINNT
                    }
#endif
                }
            } else {
                // video memory
                dst.dwOffset = VIDMEM_OFFSET(dst.pGbl->fpVidMem);
                dst.dwContextDma = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
            }
        }
        // do this last, need the invalid one to create a context DMA
        dst.pObj = IS_VALID_PNVOBJ(dst.pObj) ? dst.pObj : NULL;
    }

    // update frame tracker if appropriate
    if ((dwPbdFlags & DDBLT_LAST_PRESENTATION)
        ||
        // DX7 - if registry key is set, allow at most "regPreRenderLimit" blits to primary with the
        // DDBLT_WAIT flag to queue up. this prevents horrible lag if we queue too many.
        ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_LIMITQUEUEDFBBLITSENABLE_ENABLE) &&
         (dst.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE))))
    {
        nvCheckQueuedBlits();
        nvUpdateBlitTracker();
    }

#ifdef  STEREO_SUPPORT
StereoSecondPass:
        dwNPasses = StereoBltAdjustParameters(src, dst, StereoBltPass);
#endif  //STEREO_SUPPORT

#if (NVARCH >= 0x010)

    // Handle AA
    PNVD3DCONTEXT pContext = NULL;

    if (src.pObj) {
        pContext = nvCelsiusAAFindContext(src.pObj->getSimpleSurface());
    }

    if (!pContext && dst.pObj) {
        pContext = nvCelsiusAAFindContext(dst.pObj->getSimpleSurface());
    }

    if (pContext) {
        CSimpleSurface *pSrc = 0;
        CSimpleSurface *pDst = 0;
        bool bRewriteDst = false;
        DWORD dwWidthScale, dwHeightScale;

        if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) && pContext->kelvinAA.IsEnabled()) {
            if (src.pObj && (src.pObj->getSimpleSurface() == pContext->pRenderTarget)) {
                pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_RT, CKelvinAAState::ACCESS_READ);
            }

            if (dst.pObj && (dst.pObj->getSimpleSurface() == pContext->pRenderTarget)) {
                if (pContext->kelvinAA.IsValid(CKelvinAAState::BUFFER_SRT) && 
                    !bDoEarlyBlitFallback &&
                    !pContext->kelvinAA.CompatibilityMode(CKelvinAAState::APPFLAGS_DOWNSAMPLE_ON_BLIT)) {
                    // Early blit fallback seems to be incompatible with destination rewriting.  This 
                    // should be looked at...

                    // Grant exclusive access
                    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SRT, CKelvinAAState::ACCESS_WRITE);
                    pDst = pContext->kelvinAA.GetSRT();
                    bRewriteDst = true;
                } else {
                    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_RT, CKelvinAAState::ACCESS_WRITE);
                }
            }

            if (src.pObj && (src.pObj->getSimpleSurface() == pContext->pZetaBuffer)) {
                pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_ZB, CKelvinAAState::ACCESS_READ);
            }

            if (dst.pObj && (dst.pObj->getSimpleSurface() == pContext->pZetaBuffer)) {
                if (dwPbdFlags & DDBLT_DEPTHFILL) {
                    // grant exclusive access
                    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SZB, CKelvinAAState::ACCESS_WRITE);
                    pDst = pContext->kelvinAA.GetSZB();
                    bRewriteDst = true;
                } else {
                    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_ZB, CKelvinAAState::ACCESS_WRITE);
                }
            }

            dwWidthScale = pContext->kelvinAA.GetWidthScale();
            dwHeightScale = pContext->kelvinAA.GetHeightScale();
        } else if (pContext->aa.isInit() && (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)) {

            // force AA enabled if registry said so

            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK) // aa enabled
                && ((pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] != D3DANTIALIAS_NONE)
                || (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK))) // aa forced
            {
                // create aa buffers
                if (nvCelsiusAACreate(pContext))
                {
                    // enable AA
                    pContext->aa.setFlags (AASTATE::FLAG_ENABLED);
                }
            }

            if (getDC()->dwAAContextCount >= 1)
            {
                // We don't support parameter rewriting when the source is our render target
                // or Z buffer, we must minify (if necessary)
                if (!pContext->aa.mAppCompat.bBlitSync) {
                    if (src.pObj && src.pObj->getSimpleSurface() == pContext->pRenderTarget) {
                        pContext->aa.Minify(pContext);
                    } else if (src.pObj && src.pObj->getSimpleSurface() == pContext->pZetaBuffer) {
                        pContext->aa.MinifyZ(pContext);
                    }
                }

                // If our destination is our render target or Z buffer, we want to
                // see which buffer is valid, and blit to that.  That way we prevent
                // unnecessary minifications/manifications.
                if (!pContext->aa.mAppCompat.bBlitSync) {
                    if (dst.pObj && dst.pObj->getSimpleSurface() == pContext->pRenderTarget) {
                        pDst = pContext->pRenderTarget;

                        if (!pContext->aa.isRenderTargetValid()) {
                            bRewriteDst = true;
                            pDst = pContext->aa.pSuperRenderTarget;
                        }
                    } else if (dst.pObj && dst.pObj->getSimpleSurface() == pContext->pZetaBuffer) {
                        pDst = pContext->pZetaBuffer;
                        if (!pContext->aa.isZetaBufferValid()) {
                            bRewriteDst = true;
                            pDst = pContext->aa.pSuperZetaBuffer;
                        }
                    }
                } else {
                    // If configuration file says so, we want to force blits to to go to the
                    // render target, not the super render target
                    if (dst.pObj && dst.pObj->getSimpleSurface() == pContext->pRenderTarget) {
                        pContext->aa.Minify(pContext);
                    } else if (dst.pObj && dst.pObj->getSimpleSurface() == pContext->pZetaBuffer) {
                        pContext->aa.MinifyZ(pContext);
                    }

                }

            }

            dwWidthScale = int(pContext->aa.fWidthAmplifier + 0.5f);
            dwHeightScale = int(pContext->aa.fHeightAmplifier + 0.5f);
        }

        if (bRewriteDst && pDst) {
            if ((src.dwSubRectWidth == dst.dwSubRectWidth) &&
                (src.dwSubRectHeight == dst.dwSubRectHeight)) {
                bStretchLinearFilter = FALSE;
            }
            
            dst.dwSubRectX      *= dwWidthScale;
            dst.dwSubRectY      *= dwHeightScale;
            dst.dwSubRectWidth  *= dwWidthScale;
            dst.dwSubRectHeight *= dwHeightScale;
            
            // Make a backup
            bRewriteSurfData = TRUE;
            
            fpOldVidMem = dst.pGbl->fpVidMem;
            lOldPitch = dst.pGbl->lPitch;
            wOldHeight = dst.pGbl->wHeight;
            wOldWidth = dst.pGbl->wWidth;
            
            dst.pGbl->fpVidMem = pDst->getfpVidMem();
            dst.pGbl->lPitch = pDst->getPitch();
            dst.pGbl->wHeight = (WORD)pDst->getHeight();
            dst.pGbl->wWidth = (WORD)pDst->getWidth();
            
            pbd->lpDDDestSurface = dst.pLcl;
            pbd->rDest.left   = dst.dwSubRectX;
            pbd->rDest.top    = dst.dwSubRectY;
            pbd->rDest.right  = dst.dwSubRectX + dst.dwSubRectWidth;
            pbd->rDest.bottom = dst.dwSubRectY + dst.dwSubRectHeight;
            
            dst.pObj = pDst->getWrapper();
            dst.fpVidMem = pDst->getfpVidMem();
            dst.dwOffset = pDst->getOffset();
            dst.dwPitch = pDst->getPitch();
            dst.dwWidth = pDst->getWidth();
            dst.dwHeight = pDst->getHeight();
        }
    }
#endif  // NVARCH >= 0x010

    // set up capability booleans
    doStretchX = (src.dwSubRectWidth != dst.dwSubRectWidth)   ? TRUE : FALSE;
    doStretchY = (src.dwSubRectHeight != dst.dwSubRectHeight) ? TRUE : FALSE;
    doStretch  = doStretchX || doStretchY;


    doMirrorX = (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT) ? TRUE : FALSE;
    doMirrorY = (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)    ? TRUE : FALSE;
    doMirror  = doMirrorX || doMirrorY;

    // trivial rejection
    retVal = bltEarlyErrorCheck(pbd, &src, &dst);
    if (retVal != DDHAL_DRIVER_HANDLED || pbd->ddRVal != DD_OK) {
        BLT_ABNORMAL_EXIT;
    }

    // make sure we get access to all of video memory
    bltUpdateClip(pDriverData);

    // texture manager wants full control before all the sync points below
    // it will check for these in time to not break
    if ((src.dwCaps | dst.dwCaps) & DDSCAPS_TEXTURE) {
        nvAssert((src.pObj && (src.pObj->getClass() == CNvObject::NVOBJ_TEXTURE))
              || (dst.pObj && (dst.pObj->getClass() == CNvObject::NVOBJ_TEXTURE))
              || (src.pObj && (src.pObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE))
              || (dst.pObj && (dst.pObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE)));

        retVal = bltTexture (pbd, &src, &dst, doStretch);
        assert(retVal == DDHAL_DRIVER_HANDLED || retVal == DDHAL_DRIVER_NOTHANDLED || retVal == DDERR_UNSUPPORTED);
        BLT_EXIT;

        // the only texture blit cases which should fall through to here are
        // FOURCC to texture blits, video to system, and system to video texture blits
        if ((src.dwCaps & DDSCAPS_TEXTURE) && (src.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM))) {
            if (pDriverData->bltData.dwSystemBltFallback) {
                src.dwContextDma = 0;
                bDoEarlyBlitFallback = TRUE;
            } else {
                // because we didn't create a context DMA before
#ifndef WINNT
                // don't do this for WINNT because they can sometimes hand us an aliased linear address
                // to an AGP surface which is nowhere near the GARTLinearBase that we know about
                if ((src.dwCaps & DDSCAPS_NONLOCALVIDMEM) && pDriverData->GARTLinearBase) {
                    // AGP memory
                    src.dwContextDma = D3D_CONTEXT_DMA_HOST_MEMORY;
                    src.dwOffset = AGPMEM_OFFSET(src.pGbl->fpVidMem);
                } else {
#endif
                    src.dwOffset = 0;
                    src.pObj = GET_PNVOBJ(src.pLcl);        // need this, invalid or not for creating context DMAs
                    retVal = bltCreateContextDMA(pbd, &src);
                    if (retVal != DDHAL_DRIVER_HANDLED) {
                        src.dwContextDma = 0;
                        bDoEarlyBlitFallback = TRUE;
                    }
                    src.pObj = IS_VALID_PNVOBJ(src.pObj) ? src.pObj : NULL;
#ifndef WINNT
                }
#endif
            }
        }
    }

    // see if the last flip from this surface has completed
    DWORD ddrval = getFlipStatus (dst.fpVidMem, dst.pLcl->ddsCaps.dwCaps);

    // the way we handle failure depends on whether or not they're willing to wait...
    if (dwPbdFlags & DDBLT_WAIT) {
        while (ddrval != DD_OK) {
            NV_SLEEP;
            ddrval = getFlipStatus (dst.fpVidMem, dst.pLcl->ddsCaps.dwCaps);
        }
    }
    else {
        if (ddrval != DD_OK) {
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            BLT_ABNORMAL_EXIT;
        }
    }

    pDriverData->blitCalled = TRUE;
    pDriverData->TwoDRenderingOccurred = 1;

    // make sure we sync with other channels before writing put
    getDC()->nvPusher.setSyncChannelFlag();

#ifdef NVSTATDRIVER
    if (dst.dwCaps & DDSCAPS_PRIMARYSURFACE)
    {
        DDFLIPTICKS(FEBLIT);
    }
#endif

    // set blt state: ROP, pattern, colour key
    bltSetBltState(pbd, &src, &dst);

    // D3D stuff, not sure what this does
    bltControlTraffic(&src, &dst);

#ifndef WINNT
    // On win9x we need to flush system blits only on DX8 or above
    if (global.dwDXRuntimeVersion >= 0x0800)
#endif
    {
        // WIN2K has no system surface synchronization, so flush all system blits
        // from this point onward.  System textures (above this point) can be properly flushed in
        // CreateSurfaceEx, but this does not apply to any other type of system surface
        if ((src.dwCaps | dst.dwCaps) & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
            doFlushOnExit = TRUE;
        }
    }
    // All non-textured video to system blits must be flushed because of DX7/DX8's lack
    // of synchronization on accesses to system surfaces.
    if ((global.dwDXRuntimeVersion >= 0x0700) &&
        (src.dwCaps & (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM)) &&
        (dst.dwCaps & DDSCAPS_SYSTEMMEMORY)) {
        doFlushOnExit = TRUE;
    }

    if (bDoEarlyBlitFallback) {
        goto bltFallback;
    }

    // colorfill (outside the unary check, needs to be fast)
    if (dwPbdFlags & DDBLT_COLORFILL) {
        DWORD dwFillColour = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;
        retVal = bltColourFill(pbd, &dst, dwFillColour);
        BLT_EXIT;
    }

    // unary blit operations (avoid all those if..thens)
    if (src.pLcl == NULL) {
        // zbuffer fill
        if (dwPbdFlags & DDBLT_DEPTHFILL) {
            //We don't need a special case for Z buffer clear
            //Regular color fill would be just fine. The only thing
            //we have to take care of is to scale dwFillDepth properly (Andrei Osnovich).
            if (!(dst.dwCaps & DDSCAPS_ZBUFFER)) {
                pbd->ddRVal = DDERR_INVALIDSURFACETYPE;
                BLT_ABNORMAL_EXIT;
            }
            retVal = bltColourFill(pbd, &dst, ScaleZFillDepth(pbd, &dst));
            BLT_EXIT;
        }

        if (dwPbdFlags & DDBLT_ROP) {
            DWORD dwRop = pbd->bltFX.dwROP >> 16;
            if (dwRop == BLACKNESSINDEX) {
                retVal = bltColourFill(pbd, &dst, 0x00000000);
                BLT_EXIT;
            }
            if (dwRop == WHITENESSINDEX) {
                retVal = bltColourFill(pbd, &dst, 0xFFFFFFFF);
                BLT_EXIT;
            }
            if (dwRop == PATCOPYINDEX) {
                DWORD dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;
                retVal = bltColourFill(pbd, &dst, dwFillColor);
                BLT_EXIT;
            }
            if (dwRop == PATINVERTINDEX) {
                DWORD dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;
                retVal = bltColourFill(pbd, &dst, ~dwFillColor);
                BLT_EXIT;
            }
        }
    }

#if (NVARCH <= 3)
    // HWBUG: in cases where we might run into a DMA read fault, copy everything except the last
    //        line to local memory, and manual copy the last line, then do the op from vidmem to vidmem
    if (src.isPotentialFault) {
        if (pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) goto bltFallback;  // need another ws to handle these cases
        if (!doStretch && !doMirror && ((pbd->bltFX.dwROP >> 16) == SRCCOPYINDEX)) {
            // single pass, directly into the destination
            retVal = bltPotentialFaultHandler(pbd, &src, &dst);
            BLT_EXIT;
        } else {
            // copy into video memory workspace first and then do the op
            ws = src;
            if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                bltPotentialFaultHandler(pbd, &src, &ws);
                src = ws;
                src.isPotentialFault = FALSE;
                // fall through to do second pass
            } else {
                goto bltFallback;
            }
        }
    }
#endif  // NVARCH <= 3

    if ((src.dwCaps & DDSCAPS_SYSTEMMEMORY) && ((src.dwWidth & 0x1) != 0)){
        //NV4/NV10 fix for scaled image -- we overrun context dma for system memory surfaces
        //because we are fetching texels in pairs. -- confirm with Gopal.
        goto bltFallback;
    }

    if (src.dwFourCC) {
        // FOURCC blits
        if (src.dwFourCC == dst.dwFourCC) {
            // FOURCC to FOURCC blits
            if (!doMirror) {
                retVal = blt4CCto4CC(pbd, &src, &dst);
                BLT_EXIT;
            }
        } else {
            if (dst.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
                retVal = DDERR_UNSUPPORTED;
                BLT_ABNORMAL_EXIT;
            }
            retVal = bltStrBlt(pbd, &src, &dst, bStretchLinearFilter);
            BLT_EXIT;
        }
    } else {
        // non-FOURCC blits

        if (dst.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
            if (src.bUseSwizzle) {

                // KThompson's ruminations on why we probably never reach this code...
                // 
                // How can we possibly get here?  I think we can't.  To get here, the source
                // surface has to be a swizzled surface not handled by bltTexture() further
                // above.  I can see two possible causes.  First, 'src.bUseSwizzle' is set 
                // true if all of the following are true:
                //
                //     src.pObj != NULL
                //     src.pObj->getClass()==CNvObject::NVOBJ_TEXTURE
                //     src.bIsLocked
                //     (pTex=src.pObj->getTexture()) != NULL
                //     pTex->getLinear()
                //     pTex->getLinear()->isValid()
                //
                // We could get to this point in the code if all of the above are true
                // (which causes 'src.bUseSwizzle' to be true) and "src.dwCaps&DDSCAPS_TEXTURE"
                // is false (so earlier code bypasses bltTexture()).  This seems unlikely,
                // but not provably impossible.
                //
                // The other way we could get here is if bltTexture() doesn't return
                // DDHAL_DRIVER_HANDLED, which in turn means that nvTextureBltDX7() returns
                // an error condition.  Some oddball situations to look into...
                //
                //     * Can a surface be neither texture nor simple?
                //     * Do "unsupported" blits get here: zero size, unequal src/dest depth,
                //       different src/dest DXT types, unknown FOURCC types etc?
                //
                // ...but keep in mind we still won't reach here if 'bDoEarlyBlitFallback' is
                // true, or other conditions that cause a jump to the 'bltFallback' label.

                // swizzled to unswizzled copy
                DWORD dwLSBIndex, dwMSBIndex, dwLogWidth, dwLogHeight;

                // find log width
                dwLSBIndex = dwMSBIndex = src.dwPitch;
                ASM_LOG2(dwLSBIndex);
                ASM_LOG2_R(dwMSBIndex);
                if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
                if (dwMSBIndex < 5) { dwMSBIndex = 5; }         // lowest allowed pitch is 32
                dwLogWidth = dwMSBIndex;

                // find log height
                dwLSBIndex = dwMSBIndex = src.dwHeight;
                ASM_LOG2(dwLSBIndex);
                ASM_LOG2_R(dwMSBIndex);
                if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
                dwLogHeight = dwMSBIndex;

                nvSwizBlt_cpu_swz2lin(src.fpVidMem, src.dwSubRectX, src.dwSubRectY, dwLogWidth, dwLogHeight,
                                      dst.fpVidMem, dst.dwPitch, dst.dwSubRectX, dst.dwSubRectY,
                                      dst.dwSubRectWidth, dst.dwSubRectHeight, dst.dwBytesPerPixel);
                retVal = DD_OK;
            } else {
                // simple video to system blts
                retVal = bltSimpleCopy(pbd, &src, &dst);
            }
            BLT_EXIT;
        }

        if (doStretch) {
            // strblt cases

            // NV4 has a potential single bit error in the LSBit of each colour component with SCALED_IMAGE,
            //      and will not pass WHQL.  Go to old code in 16 bpp modes
            if (pDriverData->NvDeviceVersion <= NV_DEVICE_VERSION_4 && dst.dwBytesPerPixel == 2) {
                goto bltFallback;
            }

            if (src.fpVidMem == dst.fpVidMem &&
                src.dwContextDma == dst.dwContextDma &&
              !(pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) &&
                dst.dwBytesPerPixel != 1) {
                // overlapping strblt exceptions
                ws = src;
                if (bltAllocWorkSpace(pbd, &ws, BLTWS_PREFERRED_VIDEO, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                    bltSimpleCopy(pbd, &src, &ws);
                    retVal = bltStrBlt(pbd, &ws, &dst, bStretchLinearFilter);
                    BLT_EXIT;
                }
            } else {

                // non-overlapping strblts
                if (pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) {
                    // color keyed strblts
                    // do this in 2 stages, first strblt it to video mem workspace, then do a simple V2V blit
                    ws = dst;
                    if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                        if (bltStrBlt(pbd, &src, &ws, bStretchLinearFilter) == DDHAL_DRIVER_HANDLED) {
                            bltSetBltState(pbd, &ws, &dst);
                            retVal = bltSimpleVtoVBlt(pbd, &ws, &dst);
                            BLT_EXIT;
                        }
                    } else {

                        // error allocating workspace, fall through to old code
                    }

                } else {
                    // unkeyed strblts
                    if ((src.dwSubRectWidth  > (dst.dwSubRectWidth << 1) ||
                         src.dwSubRectHeight > (dst.dwSubRectHeight << 1)) &&
                       ((pbd->bltFX.dwROP >> 16) == SRCCOPYINDEX) &&
                        (dst.dwBytesPerPixel != 1)) {
                        // VIDEO2000 quality optimization: if downscale factor is greater than 2,
                        // then downscale in multiple passes to get more effective taps
                        ws = src;
                        if (src.dwSubRectWidth  > (dst.dwSubRectWidth << 1)) {
                            ws.dwPitch >>= 1;
                            ws.dwWidth = (ws.dwWidth + 1) >> 1;
                            ws.dwSubRectX >>= 1;
                            ws.dwSubRectWidth = (ws.dwSubRectWidth + 1) >> 1;
                        }
                        if (src.dwSubRectHeight > (dst.dwSubRectHeight << 1)) {
                            ws.dwHeight = (ws.dwHeight + 1) >> 1;
                            ws.dwSubRectY >>= 1;
                            ws.dwSubRectHeight = (ws.dwSubRectHeight + 1) >> 1;
                        }
                        ws.dwSubRectHeight <<= 1;  // in case we need to do 3 passes
                        if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                            ws.dwSubRectHeight >>= 1;  // restore height
                            bltStrBlt(pbd, &src, &ws, bStretchLinearFilter);
                            if ((ws.dwSubRectWidth  > (dst.dwSubRectWidth << 1)) ||
                                (ws.dwSubRectHeight > (dst.dwSubRectHeight << 1))) {
                                // more than 4x downscale, lets do this again
                                SURFINFO ws2 = ws;
                                ws.dwOffset += ws.dwSubRectHeight * ws.dwPitch;
                                if (ws2.dwSubRectWidth  > (dst.dwSubRectWidth << 1)) {
                                    ws.dwSubRectX >>= 1;
                                    ws.dwSubRectWidth = (ws.dwSubRectWidth + 1) >> 1;
                                }
                                if (ws2.dwSubRectHeight > (dst.dwSubRectHeight << 1)) {
                                    ws.dwSubRectY >>= 1;
                                    ws.dwSubRectHeight = (ws.dwSubRectHeight + 1) >> 1;
                                }
                                bltStrBlt(pbd, &ws2, &ws, bStretchLinearFilter);
                            }
                            retVal = bltStrBlt(pbd, &ws, &dst, bStretchLinearFilter);
                            BLT_EXIT;
                        }
                    }
                    // simple case
                    retVal = bltStrBlt(pbd, &src, &dst, bStretchLinearFilter);
                    BLT_EXIT;
                }

            }
        } else {    // !doStretch
            // simple blit cases
            if (src.dwCaps & DDSCAPS_LOCALVIDMEM) {
                // video to video
                if (!doMirror) {
                    retVal = bltSimpleVtoVBlt(pbd, &src, &dst);
                    BLT_EXIT;
                }
            } else {
                // system to video
                if (pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) {
                    // colour keyed system to video
                    if (!doMirror) {
                        // do this in 2 stages, first copy it to video mem workspace, then do a simple V2V blit
                        ws = src;
                        if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                            bltSimpleCopy(pbd, &src, &ws);
                            retVal = bltSimpleVtoVBlt(pbd, &ws, &dst);
                            BLT_EXIT;
                        } else {
                            // error allocating workspace, fall through to old code
                        }
                    }
                } else {
                    // unkeyed system to video

                    // NV4 has a potential single bit error in the LSBit of each colour component with SCALED_IMAGE,
                    //      and will not pass WHQL.  Go to old code in 16 bpp modes
                    if (pDriverData->NvDeviceVersion <= NV_DEVICE_VERSION_4 && dst.dwBytesPerPixel == 2) {
                        goto bltFallback;
                    }

                    if ((pbd->bltFX.dwROP >> 16) == SRCCOPYINDEX && !doMirror) {
                        // no stretch, no colour key, no rop, no mirror
                        retVal = bltSimpleCopy(pbd, &src, &dst);
                        BLT_EXIT;
                    } else {
                        retVal = bltStrBlt(pbd, &src, &dst, bStretchLinearFilter);
                        BLT_EXIT;
                    }
                }
            }
        }   // doStretch
    }

bltFallback:
    // all other blt cases, fall back code

    // need to restore these things if we changed them
    if (dst.bDefaultBlitChanged) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);
        nvPushData(1, NV_DD_IMAGE_BLIT);
        nvPusherAdjust(2);
    }

    if (dst.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
        // slow video to system case
        retVal = bltSlowVtoSBlt(pbd, &src, &dst);
        BLT_EXIT;
    } else {
        // slow system to video, or video to video case
        if (src.dwContextDma == dst.dwContextDma && src.dwOffset == dst.dwOffset) {
            // deal with overlapping case
            ws = src;
            if (bltAllocWorkSpace(pbd, &ws, BLTWS_PREFERRED_SYSTEM, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                bltSimpleCopy(pbd, &src, &ws);
                src = ws;
                WaitForIdle(TRUE, TRUE);
            } else {
                retVal = bltSlowStoVBlt(pbd, &src, &dst);
                BLT_EXIT;
            }
        }
        retVal = bltSlowStoVBlt(pbd, &src, &dst);
        BLT_EXIT;
    }

    // should never get to this point, if you do, see slum or drohrer
    DPF("Blit end run");
    nvAssert(FALSE);

    BLT_ABNORMAL_EXIT;

}  // Blit32

// -----------------------------------------------------------------------------
// bltEarlyErrorCheck
//      Does cursory error checking
DWORD __stdcall bltEarlyErrorCheck (LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
    dbgTracePush ("bltEarlyErrorCheck");

    pbd->ddRVal = DD_OK;

    /*
     * This needs to be here for cases where the channel has closed due to
     * a mode switch or some other reason when there is a pending notification
     * which gets lost due to the channel closure. nvEnable32 will deal
     * with clearing the pending notifier.
     */
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(pbd->lpDD)) {
            DPF("BLTERROR: DMA channel lost");
            pbd->ddRVal = DDERR_SURFACELOST;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    // no destination color key
    if (pbd->dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE)) {
        DPF("BLTERROR: destination colour key not supported");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    // trivial reject of zero dimensioned blt
    if (pbd->rDest.right == pbd->rDest.left || pbd->rDest.bottom == pbd->rDest.top) {
        DPF("BLTERROR: trivial reject of zero dimensioned blt");
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // can't do system to system blits
    if ((pSrc->dwCaps & DDSCAPS_SYSTEMMEMORY) && (pDst->dwCaps & DDSCAPS_SYSTEMMEMORY)) {
        DPF("BLTERROR: can't do system to system blits");
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }


    //// h.azar: can't do YUV surface to RGB texture blit for now... this is part of 
    // the VMR support which is implemented in rel20
    // ** this condition will prevent a hang in the VMR DCT450 test
    if (((pSrc->dwFourCC == FOURCC_YUY2) || (pSrc->dwFourCC == FOURCC_UYVY) || (pSrc->dwFourCC == FOURCC_NV12)) && (pDst->dwCaps & DDSCAPS_TEXTURE))
    {
        DPF("BLTERROR: can't do yuv surface to texture blits");
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }


    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltUpdateClip
//      Updates the NV clipper state if necessary
DWORD __stdcall bltUpdateClip(GLOBALDATA *pDriverData)
{
    dbgTracePush ("bltUpdateClip");
    if (pDriverData->ddClipUpdate ||
        pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

        getDC()->nvPusher.push (0,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        getDC()->nvPusher.push (1,NV_DD_IMAGE_BLACK_RECTANGLE);
        getDC()->nvPusher.push (2,dDrawSubchannelOffset(NV_DD_SURFACES) +
                                IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000);
        getDC()->nvPusher.push (3,0);
        getDC()->nvPusher.push (4,asmMergeCoords(NV_MAX_X_CLIP,NV_MAX_Y_CLIP));
        getDC()->nvPusher.push (5,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        getDC()->nvPusher.push (6,NV_DD_SURFACES_2D);

        getDC()->nvPusher.adjust (7);
        getDC()->nvPusher.start  (TRUE);

        pDriverData->dwSharedClipChangeCount++;
        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
        pDriverData->ddClipUpdate = FALSE;
    }
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltDestroyAllContextDMAs
//      Destroys all context DMAs created by bltCreateContextDMA and walks
//      through to entire surface list to adjust the NVObjects
DWORD __stdcall bltDestroyAllContextDMAs(LPDDRAWI_DIRECTDRAW_GBL lpDD)
{
    dbgTracePush ("bltDestroyAllContextDMAs");

    // walk the entire surface list
#ifdef WINNT
    // FIXME: figure out what how to clean up surfaces that do not have a CNvObject
    CNvObject *pObj = global.pNvObjectHead;
    while (pObj) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pObj->getContextDma());
        pObj->setContextDma(0);
        if (pObj->getSimpleSurface() ) pObj->getSimpleSurface()->tagNotAsDynSys();
        pObj = pObj->getNext();
    }
#else
    LPDDRAWI_DDRAWSURFACE_INT pSurfInt;

    for (pSurfInt = lpDD->dsList; pSurfInt != NULL; pSurfInt = pSurfInt->lpLink) {
        LPDDRAWI_DDRAWSURFACE_LCL pSurfLcl = pSurfInt->lpLcl;
        if (pSurfLcl->ddsCaps.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
            CNvObject *pObj = GET_PNVOBJ(pSurfLcl);
            if ((((DWORD)pObj) & MASK_FLOATING_CONTEXT_DMA_ID) == FLOATING_CONTEXT_DMA_ID) {
                NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, (DWORD) pObj);
                SET_PNVOBJ(pSurfLcl, 0);
            } else if (IS_VALID_PNVOBJ(pObj)) {
                NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pObj->getContextDma());
                pObj->setContextDma(0);
                if (pObj->getSimpleSurface() ) pObj->getSimpleSurface()->tagNotAsDynSys();
            }
        }
    }
#endif

    // really make sure
    DWORD dwContextDma;
    for (DWORD i=0; i < pDriverData->bltData.dwSystemSurfaceContextDMAIndex; i+=2) {
        dwContextDma = NV_DD_FLOATING_CONTEXT_DMA_BASE + i;
        // HWFIX: deal with hw hash table bug, swap bits 1 and 2 with 11 and 22 (which are part of the hash function)
        dwContextDma = ((dwContextDma & 0x00000002) << 10) | ((dwContextDma & 0x00000800) >> 10) |
                       ((dwContextDma & 0x00000004) << 20) | ((dwContextDma & 0x00400000) >> 20) |
                       (dwContextDma & ~0x00400806);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, dwContextDma);
    }

    // seem to cause RM errors on next allocation, even though we have previously destroyed them
//    pDriverData->bltData.dwSystemSurfaceContextDMAIndex = 0;

    // free system workspace
    if (pDriverData->bltSysMemInfo.dwLocale == BLTWS_SYSTEM) {
        FreeIPM((void*)pDriverData->bltSysMemInfo.fpVidMem);
        pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    // free AGP workspace
    if (pDriverData->bltAGPMemInfo.dwLocale == BLTWS_AGP) {
        nvAGPFree((void*)pDriverData->bltAGPMemInfo.fpVidMem);
        pDriverData->bltAGPMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltCreateContextDMA
//      Creates a context DMA for system memory surfaces if it doesn't already
//      exist.  Fills in the instance handle in pContextDmaInstance
DWORD __stdcall bltCreateContextDMA(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf)
{
#ifdef WINNT
    // WINNT faults when attempting to free a system surface (out of our control, driver never called) which
    // has a context DMA attached to it.  Creation and destruction of the context DMA within the blit call
    // is way too slow, so just fail all dynamic context DMA allocation and use the fallback code
    return DDHAL_DRIVER_NOTHANDLED;

#else   // win9x

DWORD dwSurfSize;

    dbgTracePush ("bltCreateContextDMA");

    pSurf->dwContextDma = 0;
    if ((DWORD) pSurf->pObj != 1) {
        if ((((DWORD)pSurf->pObj) & MASK_FLOATING_CONTEXT_DMA_ID) == FLOATING_CONTEXT_DMA_ID) {
            pSurf->dwContextDma = (DWORD)pSurf->pObj;
        } else if (pSurf->pObj) {
            pSurf->dwContextDma = pSurf->pObj->getContextDma();
        }
    }

    dwSurfSize = pSurf->dwPitch * pSurf->dwHeight;
    switch (pSurf->dwFourCC) {
    case FOURCC_YV12:
    case FOURCC_420i:
        dwSurfSize += (pSurf->dwPitch >> 1) * (pSurf->dwHeight >> 1) * 2;
        break;

    case FOURCC_YVU9:
    case FOURCC_IF09:
    case FOURCC_IV32:
    case FOURCC_IV31:
        dwSurfSize += (pSurf->dwPitch >> 2) * (pSurf->dwHeight >> 2) * 2;
        break;

    default:
        break;
    }

#if (NVARCH <= 3)
    // HWBUG: If a DMA read is attempted near the end of a system surface, HW will try to
    //        prefetch and may fault past the end of the surface
    if (((pSurf->dwSubRectY + pSurf->dwSubRectHeight) >= (pSurf->dwHeight - (NV10_BLT_READ_AHEAD_BUFFER_SIZE / pSurf->dwPitch))) &&
          IsBadReadPtr((LPVOID)(pSurf->fpVidMem + dwSurfSize + (NV10_BLT_READ_AHEAD_BUFFER_SIZE - 1)), 1)) {
        pSurf->isPotentialFault = TRUE;
    }
#endif  // NVARCH <= 3

#ifdef BLT_VERYSAFE
    // touch each page of the system memory surface to ensure it is paged in
    LPBYTE ptr = (LPBYTE) pSurf->fpVidMem;
    for (DWORD i=0; i<((dwSurfSize+4093)/4096); i++) {
        volatile BYTE bDontOptimizeMe = *ptr;
        ptr += 4096;
    }
#endif

    if (!pSurf->dwContextDma) {

        if ((pDriverData->bltData.dwSystemSurfaceContextDMAIndex >> 1) >= MAX_FLOATING_CONTEXT_DMA) {
            bltDestroyAllContextDMAs(pbd->lpDD);
            pDriverData->bltData.dwSystemSurfaceContextDMAIndex = 0;
#ifdef  SYSTEMBLTFALLBACK
            //Verified that context DMA allocation case still works 3.3 times faster than the
            //SystemBltFallback case. It is up to Sandy to finally decide on this. Andrei O.
            if (!pDriverData->bltData.dwLetItThrash) {
                pDriverData->bltData.dwSystemBltFallback = TRUE;
            }
#endif  //SYSTEMBLTFALLBACK
        }

        pSurf->dwContextDma = NV_DD_FLOATING_CONTEXT_DMA_BASE + pDriverData->bltData.dwSystemSurfaceContextDMAIndex;
        // HWFIX: deal with hw hash table bug, swap bits 1 and 2 with 11 and 22 (which are part of the hash function)
        pSurf->dwContextDma = ((pSurf->dwContextDma & 0x00000002) << 10) | ((pSurf->dwContextDma & 0x00000800) >> 10) |
                              ((pSurf->dwContextDma & 0x00000004) << 20) | ((pSurf->dwContextDma & 0x00400000) >> 20) |
                              (pSurf->dwContextDma & ~0x00400806);

        // careful, DestroySurface is not called for non-texture system surfaces on DX7
        // this means we must rely on DestroyDriver to get rid of these
        if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                pSurf->dwContextDma,
                                NV01_CONTEXT_DMA,
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _PHYSICALITY, _NONCONTIGUOUS) |
                                DRF_DEF(OS03, _FLAGS, _LOCKED, _IN_TRANSIT) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                               (PVOID)pSurf->fpVidMem,
                                dwSurfSize - 1)) {
            // ran out of context DMA's, delete all and try again
            bltDestroyAllContextDMAs(pbd->lpDD);

            // try again
            if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                    pSurf->dwContextDma,
                                    NV01_CONTEXT_DMA,
                                    DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                    DRF_DEF(OS03, _FLAGS, _PHYSICALITY, _NONCONTIGUOUS) |
                                    DRF_DEF(OS03, _FLAGS, _LOCKED, _IN_TRANSIT) |
                                    DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                                   (PVOID)pSurf->fpVidMem,
                                    dwSurfSize - 1)) {
                pSurf->isPotentialFault = TRUE;
                pSurf->dwContextDma = 0;
                dbgTracePop();
                return DDHAL_DRIVER_NOTHANDLED;
            }
        }
        if ((DWORD) pSurf->pObj != 1) {
            if (IS_VALID_PNVOBJ(pSurf->pObj)) {
                pSurf->pObj->setContextDma(pSurf->dwContextDma);
                if (pSurf->pObj->getSimpleSurface() ) pSurf->pObj->getSimpleSurface()->tagAsDynSys();
                //textures are a seperate path
                //vertex buffers can't be blited
                //if this changes, we need to set the correct bits for each type of
                //object since everything doesn't inherit HMH
            } else {
                SET_PNVOBJ(pSurf->pLcl, pSurf->dwContextDma);
            }
        }
        pDriverData->bltData.dwSystemSurfaceContextDMAIndex += 2;
    }

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
#endif  // WINNT
}

// -----------------------------------------------------------------------------
// bltAllocVidMem
//      Video memory allocator
DWORD __stdcall bltAllocVidMem(LPSURFINFO pSurf, DWORD dwSize)
{
    dbgTracePush ("bltAllocVidMem");

    // check for enough space
    if (pDriverData->bltVidMemInfo.dwWSSize < dwSize &&
        pDriverData->bltVidMemInfo.dwLocale == BLTWS_VIDEO) {
        // not enough space, deallocate current video workspace
        NVHEAP_FREE(pDriverData->bltVidMemInfo.fpVidMem);
        pDriverData->bltVidMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    // allocate it
    if (pDriverData->bltVidMemInfo.dwLocale == BLTWS_UNINITIALIZED) {
        DWORD dwStatus;
        NVHEAP_ALLOC(dwStatus, pDriverData->bltVidMemInfo.fpVidMem, dwSize, TYPE_IMAGE);
        if (dwStatus==0) {
            // video mem allocation succeeded
            pDriverData->bltVidMemInfo.dwLocale = BLTWS_VIDEO;
            pDriverData->bltVidMemInfo.dwWSSize = dwSize;
            pDriverData->bltVidMemInfo.dwContextDma = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
            pDriverData->bltVidMemInfo.dwOffset = VIDMEM_OFFSET(pDriverData->bltVidMemInfo.fpVidMem);
        } else {
            // failed to allocate in video memory
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
    }

    pSurf->dwCaps |= DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM;
    pSurf->dwCaps &= ~(DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM);
    pSurf->dwContextDma = pDriverData->bltVidMemInfo.dwContextDma;
    pSurf->dwOffset = pDriverData->bltVidMemInfo.dwOffset;
    pSurf->fpVidMem = pDriverData->bltVidMemInfo.fpVidMem;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltAllocSysMem
//      System memory allocator
DWORD __stdcall bltAllocSysMem(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf, DWORD dwSize)
{
    dbgTracePush ("bltAllocSysMem");

    // check for enough space
    if (pDriverData->bltSysMemInfo.dwWSSize < dwSize &&
        pDriverData->bltSysMemInfo.dwLocale == BLTWS_SYSTEM) {
        // not enough space, deallocate current system workspace
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pDriverData->bltSysMemInfo.dwContextDma);
        FreeIPM((void*)pDriverData->bltSysMemInfo.fpVidMem);
        pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    if (pDriverData->bltSysMemInfo.dwLocale == BLTWS_UNINITIALIZED) {
        pDriverData->bltSysMemInfo.fpVidMem = (DWORD) AllocIPM(dwSize + 4096);
        if (pDriverData->bltSysMemInfo.fpVidMem) {
            // sys mem allocation succeeded
            pDriverData->bltSysMemInfo.dwLocale = BLTWS_SYSTEM;
            pDriverData->bltSysMemInfo.dwWSSize = dwSize;
            pDriverData->bltSysMemInfo.dwOffset = 0;
            pSurf->dwOffset = 0;
            pSurf->fpVidMem = pDriverData->bltSysMemInfo.fpVidMem;
            pSurf->pObj = (CNvObject *) 1;
            if (bltCreateContextDMA(pbd, pSurf) != DDHAL_DRIVER_HANDLED) {
                FreeIPM((void*)pDriverData->bltSysMemInfo.fpVidMem);
                pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
                dbgTracePop();
                return DDHAL_DRIVER_NOTHANDLED;
            }
            pDriverData->bltSysMemInfo.dwContextDma = pSurf->dwContextDma;
            pSurf->isPotentialFault = FALSE;    // we already added 4k to ensure HWBUG does not happen
        } else {
            // failed to allocate in system memory
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
    }

    pSurf->dwCaps |= DDSCAPS_SYSTEMMEMORY;
    pSurf->dwCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM);
    pSurf->fpVidMem = pDriverData->bltSysMemInfo.fpVidMem;
    pSurf->dwOffset = pDriverData->bltSysMemInfo.dwOffset;
    pSurf->dwContextDma = pDriverData->bltSysMemInfo.dwContextDma;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltAllocAGPMem
//      Allocate and AGP workspace
DWORD __stdcall bltAllocAGPMem(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf, DWORD dwSize, LPDDRAWI_DIRECTDRAW_GBL lpDD)
{
    dbgTracePush ("bltAllocAGPMem");

    // check for enough space
    if (pDriverData->bltAGPMemInfo.dwWSSize < dwSize &&
        pDriverData->bltAGPMemInfo.dwLocale == BLTWS_SYSTEM) {
        // not enough space, deallocate current system workspace
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pDriverData->bltAGPMemInfo.dwContextDma);
        nvAGPFree((void*)pDriverData->bltAGPMemInfo.fpVidMem);
        pDriverData->bltAGPMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    if (pDriverData->bltAGPMemInfo.dwLocale == BLTWS_UNINITIALIZED) {
        pDriverData->bltAGPMemInfo.fpVidMem = (DWORD)nvAGPAlloc(dwSize + 4096);
        if (pDriverData->bltAGPMemInfo.fpVidMem != ERR_DXALLOC_FAILED) {
            // sys mem allocation succeeded
            pDriverData->bltAGPMemInfo.dwLocale = BLTWS_SYSTEM;
            pDriverData->bltAGPMemInfo.dwWSSize = dwSize;
            pDriverData->bltAGPMemInfo.dwOffset = 0;
            pSurf->dwOffset = 0;
            pSurf->fpVidMem = pDriverData->bltAGPMemInfo.fpVidMem;
            pSurf->pObj = (CNvObject *) 1;
            if (bltCreateContextDMA(pbd, pSurf) != DDHAL_DRIVER_HANDLED) {
                nvAGPFree((void*)pDriverData->bltAGPMemInfo.fpVidMem);
                pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
                dbgTracePop();
                return DDHAL_DRIVER_NOTHANDLED;
            }
            pDriverData->bltAGPMemInfo.dwContextDma = pSurf->dwContextDma;
            pSurf->isPotentialFault = FALSE;    // we already added 4k to ensure HWBUG does not happen
        } else {
            // failed to allocate in system memory
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
    }

    pSurf->dwCaps |= DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM;
    pSurf->dwCaps &= ~(DDSCAPS_SYSTEMMEMORY | DDSCAPS_LOCALVIDMEM);
    pSurf->dwContextDma = pDriverData->bltAGPMemInfo.dwContextDma;
    pSurf->dwOffset = pDriverData->bltAGPMemInfo.dwOffset;
    pSurf->fpVidMem = pDriverData->bltAGPMemInfo.fpVidMem;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltAllocWorkspace
//      Allocates workspace in video, AGP, or system memory for use by blts.
//      Returns the dwContextDMA and dwOffset members of the SURFINFO structure.
DWORD __stdcall bltAllocWorkSpace(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf, DWORD dwFlags, LPDDRAWI_DIRECTDRAW_GBL lpDD)
{
DWORD dwSize;

    dbgTracePush ("bltAllocWorkSpace");

    // only allocate what is required for the subrectangle
    pSurf->dwWidth = pSurf->dwSubRectWidth;
    pSurf->dwHeight = pSurf->dwSubRectHeight;
    pSurf->dwSubRectX = 0;
    pSurf->dwSubRectY = 0;

    // surface size calculation
    // pitch alignment only required for vidmem surfaces, but do it for all to simplify logic
    switch (pSurf->dwFourCC) {
    case FOURCC_YV12:
    case FOURCC_420i:
        pSurf->dwPitch = (pSurf->dwWidth + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwSize = pSurf->dwPitch * pSurf->dwHeight * 3 / 2 + pSurf->dwPitch;
        break;

    case FOURCC_YVU9:
    case FOURCC_IF09:
    case FOURCC_IV32:
    case FOURCC_IV31:
        pSurf->dwPitch = (pSurf->dwWidth + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwSize = pSurf->dwPitch * pSurf->dwHeight * 9 / 8 + pSurf->dwPitch;
        break;

    case FOURCC_YUY2:
    case FOURCC_UYVY:
    case FOURCC_UYNV:
    case FOURCC_YUNV:
    default:
        pSurf->dwPitch = (pSurf->dwWidth * pSurf->dwBytesPerPixel + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwSize = pSurf->dwPitch * pSurf->dwHeight;
        break;
    }

    if (dwFlags & (BLTWS_PREFERRED_VIDEO | BLTWS_REQUIRED_VIDEO)) {
        if (bltAllocVidMem(pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // failed to allocate in video memory
        if (dwFlags & BLTWS_REQUIRED_VIDEO) {
            // fatal error
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
        // try system memory
        if (bltAllocSysMem(pbd, pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // try AGP memory
        if (bltAllocAGPMem(pbd, pSurf, dwSize, lpDD) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    } else if (dwFlags & (BLTWS_PREFERRED_AGP | BLTWS_REQUIRED_AGP)) {
        // AGP allocation
        if (bltAllocAGPMem(pbd, pSurf, dwSize, lpDD) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // failed to allocate in AGP memory
        if (dwFlags & BLTWS_REQUIRED_AGP) {
            // fatal error
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
        // try system memory
        if (bltAllocSysMem(pbd, pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // try video memory
        if (bltAllocVidMem(pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    } else if (dwFlags & (BLTWS_PREFERRED_SYSTEM | BLTWS_REQUIRED_SYSTEM)) {
        // system memory allocation
        if (bltAllocSysMem(pbd, pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // failed to allocate in system memory
        if (dwFlags & BLTWS_REQUIRED_SYSTEM) {
            // fatal error
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
        // try AGP memory
        if (bltAllocAGPMem(pbd, pSurf, dwSize, lpDD) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // try video memory
        if (bltAllocVidMem(pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    dbgTracePop();
    return DDHAL_DRIVER_NOTHANDLED;
}

// -----------------------------------------------------------------------------
// bltSetSurfaces2D
//      Sets source and destination surface context
DWORD __stdcall bltSetSurfaces2D(LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD dwDstPitch, dwSrcPitch, dwCombinedPitch;
DWORD dwDstOffset, dwSrcOffset, dwColourFormat;

    dbgTracePush("bltSetSurfaces2D");

    dwDstOffset = pDst->dwOffset;
    dwSrcOffset = pSrc->dwOffset;

    // only set surfaces2D if we are going to use it
    if (!pDst->bUseSwizzle && !pSrc->bUseSwizzle) {

        // If dest is in system memory, then we won't actually use this part
        // of surfaces2D and we just need to set it to something that RM won't throw up on
        // If we actually need to fix surface pitch alignment, do it at surface creation
        dwDstPitch = (pDst->dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) ?
                     (pDst->dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad :
                     pDst->dwPitch;

        dwSrcPitch = (pSrc->dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) ?
                     (pSrc->dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad :
                     pSrc->dwPitch;

        nvAssert(dwDstPitch != 0);

        if ((pSrc->pGbl == NULL) || (dwSrcPitch == 0) ||
            (pSrc->dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM))) {
            dwSrcOffset = 0;
            dwSrcPitch = dwDstPitch;
        }
        if (pDst->dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
            dwDstOffset = 0;
            dwDstPitch = dwSrcPitch;
        }
        dwCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;

        if (pDst->dwCaps & DDSCAPS_ZBUFFER) {
            switch (pDst->dwBytesPerPixel) {
            case 3:
            case 4:  dwColourFormat = NV062_SET_COLOR_FORMAT_LE_Y32;    break;
            default: dwColourFormat = NV062_SET_COLOR_FORMAT_LE_Y16;    break;
            }
            nvPushData(0, dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);
            nvPushData(1, NV_DD_SRCCOPY_IMAGE_BLIT);
            nvPusherAdjust(2);
            pDst->bDefaultBlitChanged = TRUE;
        } else {
            switch (pDst->dwBytesPerPixel) {
            case 1:  dwColourFormat = NV062_SET_COLOR_FORMAT_LE_Y8;                 break;
            case 4:  dwColourFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;  break;
            default: dwColourFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;             break;
            }
        }

        // if copy alpha...
        if (!pSrc->dwFourCC &&
            pSrc->dwContextDma == NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY &&
            pDst->dwContextDma == NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY &&
            pDriverData->bltData.dwLastColourKey == 0xFFFFFFFF &&
            pDst->dwBytesPerPixel == 4 &&
            pDriverData->bltData.dwLastRop == SRCCOPYINDEX &&
            pDst->dwSubRectWidth == pSrc->dwSubRectWidth &&
            pDst->dwSubRectHeight == pSrc->dwSubRectHeight &&
         !((pDst->dwCaps | pSrc->dwCaps) & DDSCAPS_TEXTURE)) {
            dwColourFormat = NV062_SET_COLOR_FORMAT_LE_Y32;
        }

        if (pDriverData->bltData.dwLastColourFormat != dwColourFormat ||
            pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
            pDriverData->bltData.dwLastSrcOffset != dwSrcOffset ||
            pDriverData->bltData.dwLastDstOffset != dwDstOffset) {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
            nvPushData(1, dwColourFormat);                  // SetColorFormat
            nvPushData(2, dwCombinedPitch);                 // SetPitch
            nvPushData(3, dwSrcOffset);                     // SetSrcOffset
            nvPushData(4, dwDstOffset);                     // SetDstOffset
            nvPusherAdjust(5);

            pDriverData->bltData.dwLastColourFormat = dwColourFormat;
            pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
            pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
            pDriverData->bltData.dwLastDstOffset = dwDstOffset;

            // also set mono pattern mask when pixel depth changes
            // scaled image and gdi_rect will silently fail unless we set the pattern (?)
            getDC()->nvPusher.push(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            getDC()->nvPusher.push(1, NV_DD_CONTEXT_PATTERN);
            getDC()->nvPusher.push(2, dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_PATTERN_SELECT | 0xC0000);
            getDC()->nvPusher.push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
            switch (pDst->dwBytesPerPixel) {
            case 1:
                getDC()->nvPusher.push(4,NV_ALPHA_1_008);
                getDC()->nvPusher.push(5,NV_ALPHA_1_008);
                break;
            case 4:
                getDC()->nvPusher.push(4,NV_ALPHA_1_032);
                getDC()->nvPusher.push(5,NV_ALPHA_1_032);
                break;
            default:
                getDC()->nvPusher.push(4,NV_ALPHA_1_016);
                getDC()->nvPusher.push(5,NV_ALPHA_1_016);
                break;
            }
            getDC()->nvPusher.adjust(6);
        }

    } else {

        DWORD dwLSBIndex, dwMSBIndex, dwLogWidth, dwLogHeight;

        // find log width
        dwLSBIndex = dwMSBIndex = pDst->dwWidth;
        ASM_LOG2(dwLSBIndex);
        ASM_LOG2_R(dwMSBIndex);
        if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
        dwLogWidth = dwMSBIndex;

        // find log height
        dwLSBIndex = dwMSBIndex = pDst->dwHeight;
        ASM_LOG2(dwLSBIndex);
        ASM_LOG2_R(dwMSBIndex);
        if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
        dwLogHeight = dwMSBIndex;

        // find surface format
        switch (pDst->dwBytesPerPixel) {
            case 2:  dwColourFormat = NV052_SET_FORMAT_COLOR_LE_R5G6B5;    break;
            case 4:  dwColourFormat = NV052_SET_FORMAT_COLOR_LE_A8R8G8B8;  break;
            default: DPF ("illegal format"); dbgD3DError();                break;
        }

        // set up swizzled surface
        // for now, assume destination is always in video memory
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, D3D_CONTEXT_SURFACE_SWIZZLED);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV052_SET_FORMAT | 0x80000);
        nvPushData(3, dwColourFormat     |                  // SetFormat
                      (dwLogWidth << 16) |
                      (dwLogHeight << 24));
        nvPushData(4, dwDstOffset);                         // SetOffset
        nvPusherAdjust(5);
    }

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltSetBltState
//      Sets surfaces context, ROP, and colour key state

DWORD __stdcall bltSetBltState(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD dwRop;

    dbgTracePush("bltSetBltState");

    dwRop = pbd->bltFX.dwROP >> 16;
    if (dwRop != pDriverData->bltData.dwLastRop) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
        nvPushData(1, dwRop);
        nvPusherAdjust(2);
        pDriverData->bltData.dwLastRop = dwRop;
    }

    if (pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) {
        // source key is enabled
        const static DWORD alphaBit[5] = {0, NV_ALPHA_1_008, NV_ALPHA_1_016, NV_ALPHA_1_032, NV_ALPHA_1_032};
        DWORD dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

        if (dwColorKey != pDriverData->bltData.dwLastColourKey) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
            nvPushData(3, (dwColorKey & pDriverData->physicalColorMask) | alphaBit[pDst->dwBytesPerPixel]);
            nvPusherAdjust(4);
            pDriverData->bltData.dwLastColourKey = dwColorKey;
            pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;
        }
    } else {
        // source key is disabled
        if (pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
            nvPushData(3, 0);
            nvPusherAdjust(4);
            pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
            pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;
        }

        // in 32 bpp modes, if no ROP and no colour key and no stretch and not a texture, then copy alpha too
        // WARNING:
        //  - We still won't be able to handle alpha with ROP or colour key.  Luckily this
        //    behaviour is ill-defined and is unlikely that anyone will use it.
        //  - On older NV architectures, alpha does stuff like bypass the gamma table for that
        //    pixel.  So far WHQL tests alpha copying in offscreen memory.  If they try
        //    this in the primary, it could look funny.
        if (!pSrc->dwFourCC &&
            pSrc->dwContextDma == NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY &&
            pDst->dwContextDma == NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY &&
            pDst->dwBytesPerPixel == 4 && dwRop == SRCCOPYINDEX &&
            pDst->dwSubRectWidth == pSrc->dwSubRectWidth &&
            pDst->dwSubRectHeight == pSrc->dwSubRectHeight &&
         !((pDst->dwCaps | pSrc->dwCaps) & DDSCAPS_TEXTURE)) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);
            nvPushData(1, NV_DD_SRCCOPY_IMAGE_BLIT);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000);
            nvPushData(3, NV062_SET_COLOR_FORMAT_LE_Y32);   // SetColorFormat
            nvPusherAdjust(4);
            pDst->bDefaultBlitChanged = TRUE;
            pDriverData->bltData.dwLastColourFormat = NV062_SET_COLOR_FORMAT_LE_Y32;
        }
    }

    // lock destination texture
    if (pDst->pObj && pDst->pObj->getClass()==CNvObject::NVOBJ_TEXTURE && !pDst->bIsLocked) {
        CTexture *pTex;
        pTex = pDst->pObj->getTexture();
        if (pTex && pTex->getSwizzled() && pTex->getSwizzled()->isValid()) {
            pDst->fpVidMem = pTex->getSwizzled()->getAddress();
            pTex->getSwizzled()->hwLock(CSimpleSurface::LOCK_NORMAL);
            pDst->bUseSwizzle = TRUE;
        } else if (pTex && pTex->getLinear() && pTex->getLinear()->isValid()) {
            pDst->fpVidMem = pTex->getLinear()->getAddress();
            pTex->getLinear()->hwLock(CSimpleSurface::LOCK_NORMAL);
            pDst->bUseSwizzle = FALSE;
        } else {
            DPF("Unsupported: Texture Blt Failed --- Destination not textured");
            assert(FALSE);
        }
        pDst->bIsLocked = TRUE;
    }

    // lock source texture
    if (pSrc->pObj && pSrc->pObj->getClass()==CNvObject::NVOBJ_TEXTURE && !pSrc->bIsLocked) {
        CTexture *pTex;
        pTex = pSrc->pObj->getTexture();
        if (pTex && pTex->getSwizzled() && pTex->getSwizzled()->isValid()) {
            pSrc->fpVidMem = pTex->getSwizzled()->getAddress();
            pTex->getSwizzled()->hwLock(CSimpleSurface::LOCK_NORMAL);
            pSrc->bUseSwizzle = TRUE;
        } else if (pTex && pTex->getLinear() && pTex->getLinear()->isValid()) {
            pSrc->fpVidMem = pTex->getLinear()->getAddress();
            pTex->getLinear()->hwLock(CSimpleSurface::LOCK_NORMAL);
            pSrc->bUseSwizzle = FALSE;
        } else {
            DPF("Unsupported: Texture Blt Failed --- Source not textured");
            assert(FALSE);
        }
        pSrc->bIsLocked = TRUE;
    }

    // lock destination system memory surface
    if (pDst->dwCaps & DDSCAPS_SYSTEMMEMORY && pDst->pObj &&
        pDst->pObj->getClass()==CNvObject::NVOBJ_SIMPLESURFACE &&
        !pDst->bIsLocked)
    {
        pDst->pObj->getSimpleSurface()->hwLock(CSimpleSurface::LOCK_NORMAL);
        pDst->bIsLocked = TRUE;
    }

    // lock source system memory surface
    if (pSrc->dwCaps & DDSCAPS_SYSTEMMEMORY && pSrc->pObj &&
        pSrc->pObj->getClass()==CNvObject::NVOBJ_SIMPLESURFACE &&
        !pSrc->bIsLocked)
    {
        pSrc->pObj->getSimpleSurface()->hwLock(CSimpleSurface::LOCK_NORMAL);
        pSrc->bIsLocked = TRUE;
    }

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltControlTraffic
//      D3D function

DWORD __stdcall bltControlTraffic (LPSURFINFO pSrc, LPSURFINFO pDst)
{
    dbgTracePush ("bltControlTraffic");

    if ((getDC()->dwD3DContextCount > 0)
     && (pDriverData->nvD3DPerfData.dwPerformanceStrategy & (PS_CONTROL_TRAFFIC_16 | PS_CONTROL_TRAFFIC_32)))
    {
        CNvObject    *pNvObj;
        PNVD3DCONTEXT pContext;

        // check to see if the source is a z-buffer

        if (pSrc->pLcl)
        {
            if (pSrc->dwCaps & DDSCAPS_ZBUFFER)
            {
                pNvObj = GET_PNVOBJ(pSrc->pLcl);
                if (IS_VALID_PNVOBJ(pNvObj) && pNvObj->hasCTEnabled())
                {
                    pNvObj->tagZBlt();
                    if (pSrc->pGbl)
                    {
                        pNvObj->disableCT();
                        nvCTDecodeBuffer (pNvObj,
                                          VIDMEM_ADDR(pSrc->fpVidMem),
                                          pSrc->pGbl->ddpfSurface.dwRGBBitCount >> 3,
                                          pSrc->pGbl->lPitch,
                                          pSrc->pGbl->wWidth,
                                          pSrc->pGbl->wHeight);
                    }
                }
            }
        }  // if (pSrc->pLcl)...

        // check to see if the dest is either a z-buffer or render target

        if (pDst->pLcl)
        {
            if (pDst->dwCaps & DDSCAPS_ZBUFFER)
            {
                pNvObj = GET_PNVOBJ(pDst->pLcl);
                if (IS_VALID_PNVOBJ(pNvObj) && pNvObj->hasCTEnabled())
                {
                    pNvObj->tagZBlt();
                    if (pDst->pGbl)
                    {
                        pNvObj->disableCT();
                        nvCTDecodeBuffer (pNvObj,
                                          VIDMEM_ADDR(pDst->fpVidMem),
                                          pDst->pGbl->ddpfSurface.dwRGBBitCount >> 3,
                                          pDst->pGbl->lPitch,
                                          pDst->pGbl->wWidth,
                                          pDst->pGbl->wHeight);
                    }
                }
            }
            else
            {
                pNvObj = GET_PNVOBJ(pDst->pLcl);
                pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
                while (pContext)
                {
                    //this used to do checks against pContext->pRenderTarget
                    //however after mode switches the cached pointer to pRenderTarget may be
                    //invalid -- look up the RTHandle's pNvObj instead for this context and see if THEY match
                    //this CAN return NULL and should be OK if it does.
                    CNvObject *pRTObj = nvGetObjectFromHandle(pContext->dwDDLclID, pContext->dwRTHandle, &global.pNvSurfaceLists);
                    if ((pRTObj == pNvObj)){
                        if (pContext->pZetaBuffer)
                        {
                            nvAssert (pContext->pZetaBuffer->getWrapper());
                            if ((pDst->dwSubRectX == 0) && (pDst->dwSubRectY == 0) &&
                                (pDst->dwSubRectHeight == pDst->dwHeight) &&
                                (pDst->dwSubRectWidth == pDst->dwWidth)
                                )
                            {
                                    // Only tag this if we are doing a full blit
                                    // to the renderTarget
                                    pContext->pZetaBuffer->getWrapper()->tagFBlt();
                            }
                        }
                        break;
                    }
                    pContext = pContext->pContextNext;
                }
            }
        }  // if (pDst->pLcl)...

    }

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltPotentialFaultHandler
//      Avoids the read ahead fault that may occur if HW attempts to prefetch
//      beyond memory which is mapped
DWORD __stdcall bltPotentialFaultHandler(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD numBottomLines = min((NV10_BLT_READ_AHEAD_BUFFER_SIZE / pSrc->dwPitch) + 1, pDst->dwSubRectHeight);
DWORD dwLastLine = pSrc->dwSubRectY + pSrc->dwSubRectHeight - numBottomLines;
LPDWORD fpSrcLastLine = (LPDWORD)(pSrc->fpVidMem + dwLastLine * pSrc->dwPitch + pSrc->dwSubRectX * pSrc->dwBytesPerPixel);
LPDWORD fpDstLastLine = (LPDWORD)(VIDMEM_ADDR(pDst->fpVidMem) + dwLastLine * pDst->dwPitch + pDst->dwSubRectX * pDst->dwBytesPerPixel);
DWORD dwLineWidth = pSrc->dwSubRectWidth * pDst->dwBytesPerPixel;

    dbgTracePush ("bltPotentialFaultHandler");

    // copy as much as we can with HW
    pDst->dwSubRectHeight -= numBottomLines;
    if (pDst->dwSubRectHeight) {
        bltSimpleCopy(pbd, pSrc, pDst);
    }
    pDst->dwSubRectHeight += numBottomLines;

    // copy the last few lines with CPU pushing
    for (DWORD j = 0; j<numBottomLines; j++) {
        for (DWORD i = 0; i<(dwLineWidth / 4); i++) {
            *(fpDstLastLine + i) = *(fpSrcLastLine + i);
        }
        switch (dwLineWidth & 0x3) {
        case 1:
            *((LPBYTE)(fpDstLastLine + dwLineWidth / 4)) = *((LPBYTE)(fpSrcLastLine + dwLineWidth / 4));
            break;
        case 2:
            *((LPWORD)(fpDstLastLine + dwLineWidth / 4)) = *((LPWORD)(fpSrcLastLine + dwLineWidth / 4));
            break;
        case 3:
            *((LPWORD)(fpDstLastLine + dwLineWidth / 4)) = *((LPWORD)(fpSrcLastLine + dwLineWidth / 4));
            *((LPBYTE)(fpDstLastLine + dwLineWidth / 4) + 2) = *((LPBYTE)(fpSrcLastLine + dwLineWidth / 4) + 2);
            break;
        case 0:
        default:
            break;
        }
        fpDstLastLine += pDst->dwPitch / 4;
        fpSrcLastLine += pSrc->dwPitch / 4;
    }
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltTexture
//      Texture blits

DWORD __stdcall bltTexture (LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bStretch)
{
    BOOL  bTempSrcObj = FALSE;         // use for system memory source cobj
    BOOL  bTempDstObj = FALSE;         // use for system memory destintation object

    DWORD dwRVal;
    dbgTracePush ("bltTexture");

    // check if this is a system memory surface we've never seen before
    if (pSrc->pLcl && !IS_VALID_PNVOBJ(pSrc->pObj))
    {
        // create temporary nv object for source we haven't seen before
        nvAssert (pSrc->dwCaps & DDSCAPS_SYSTEMMEMORY);
        dwRVal = nvCreateSystemMemorySurface(pSrc->pLcl);
        if (dwRVal != DD_OK)
        {
            pbd->ddRVal = dwRVal;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        pSrc->pObj = GET_PNVOBJ (pSrc->pLcl);
        bTempSrcObj = TRUE;
    }

    // check if this is a system memory surface we've never seen before
    if (pDst->pLcl && !IS_VALID_PNVOBJ(pDst->pObj))
    {
        // create temporary nv object for destination we haven't seen before
        nvAssert (pDst->dwCaps & DDSCAPS_SYSTEMMEMORY);
        dwRVal = nvCreateSystemMemorySurface(pDst->pLcl);
        if (dwRVal != DD_OK)
        {
            pbd->ddRVal = dwRVal;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        pDst->pObj = GET_PNVOBJ (pDst->pLcl);
        bTempDstObj = TRUE;
    }

    #ifdef DEBUG
    // make sure that we and MS still agree about where this thing is
    if (IS_VALID_PNVOBJ(pSrc->pObj)) {
        if (pSrc->pObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE) {
            CSimpleSurface *pSurf = pSrc->pObj->getSimpleSurface();
            if (pSurf->getAddress() != pSrc->fpVidMem) {
                DPF ("Surface addresses differ. NV:0x%08x, MS:0x%08x, handle:0x%08x",
                     pSurf->getAddress(), pSrc->fpVidMem, pSrc->pObj->getHandle());
                nvAssert (0);
            }
        }
    }
    #endif  // DEBUG

    if (pbd->dwFlags & DDBLT_COLORFILL) {
        DWORD dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;
        pbd->ddRVal = nvTextureColorFill (pDst->pObj,
                                          pDst->dwSubRectX, pDst->dwSubRectY,
                                          pDst->dwSubRectWidth, pDst->dwSubRectHeight,
                                          dwFillColor);
    }

    else if (bStretch) {
        if (IS_VALID_PNVOBJ(pSrc->pObj) && (pSrc->pObj->getClass() == CNvObject::NVOBJ_TEXTURE)) {
            pbd->ddRVal = nvTextureStretchBlit (pSrc, pDst);
        } else {
            pbd->ddRVal = DDERR_UNSUPPORTED;
        }
    }

    else {
        D3DBOX srcBox;

        srcBox.Left = pbd->rSrc.left;
        srcBox.Right = pbd->rSrc.right;
        srcBox.Top = pbd->rSrc.top;
        srcBox.Bottom = pbd->rSrc.bottom;
        srcBox.Front = 0;
        srcBox.Back = 1;

        pbd->ddRVal = nvTextureBltDX7 (NULL, pSrc->pObj, pDst->pObj, &srcBox, pbd->rDest.left, pbd->rDest.top, 0, pbd->dwFlags);
    }

    //clean up the dummy src/surface objects
    if (bTempSrcObj) {
        nvDeleteSystemMemorySurface(pSrc->pLcl);
    }

    if (bTempDstObj) {
        nvDeleteSystemMemorySurface(pDst->pLcl);
    }

    dbgTracePop();
    return ((pbd->ddRVal == DD_OK) ? DDHAL_DRIVER_HANDLED : pbd->ddRVal);
}

// -----------------------------------------------------------------------------
// bltColourFill
//      Fill with a solid colour
DWORD __stdcall bltColourFill(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst, DWORD dwFillColour)
{
    dbgTracePush ("bltColourFill");

    bltSetSurfaces2D(pDst, pDst);

    if (pDriverData->bltData.dwLastRop != SRCCOPYINDEX) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
        nvPushData(1, SRCCOPYINDEX);
        nvPusherAdjust(2);
        pDriverData->bltData.dwLastRop = SRCCOPYINDEX;
    }

    nvPushData (0, dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000);
    nvPushData (1, dwFillColour);
    nvPushData (2, asmMergeCoords(pDst->dwSubRectY, pDst->dwSubRectX));
    nvPushData (3, asmMergeCoords(pDst->dwSubRectHeight, pDst->dwSubRectWidth));
    nvPusherAdjust (4);
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// ScaleZFillDepth
//      Scales and returns Z FillDepth value.
DWORD __stdcall ScaleZFillDepth(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst)
{
    __int64 i64FillDepth;

    dbgTracePush ("ScaleZFillDepth");

    nvAssert(pDst);
    nvAssert(pDst->pObj);
    nvAssert(pDst->pObj->getSimpleSurface());

    DWORD dwBPPRequested=pDst->pObj->getSimpleSurface()->getBPPRequested();
    DWORD dwBPP=pDst->pObj->getSimpleSurface()->getBPP();
    DWORD dwFill = pbd->bltFX.dwFillDepth;


    if((dwBPPRequested==2)&&(dwBPP==4))
    {
        // convert 16 bit to 24-bit number
        i64FillDepth = (__int64)((float)dwFill * CELSIUS_Z_SCALE16_INV * CELSIUS_Z_SCALE24);
        i64FillDepth = (i64FillDepth > 0xffffff) ? 0xffffff : i64FillDepth;
        i64FillDepth = (i64FillDepth < 0)        ? 0        : i64FillDepth;
        // the z-buffer occupies the upper 3 bytes.
        dwFill  = (DWORD)i64FillDepth << 8;
    }
    dbgTracePop();
    return dwFill;
}

// -----------------------------------------------------------------------------
// blt4CCto4CC
//      FOURCC to FOURCC blit
//
// Assumptions:
//      - Source and destination have identical FOURCC formats
//      - Source and destination have the same dimensions
//      - The entire surface is being moved, no subrectangles
DWORD __stdcall blt4CCto4CC(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD dwSrcOffset, dwDstOffset;
DWORD dwSrcPitch, dwDstPitch;
DWORD dwSubSample;

    dbgTracePush ("blt4CCto4CC");

    if (!(pbd->dwFlags & DDBLT_ROP) ||
         (pbd->bltFX.dwROP >> 16) != SRCCOPYINDEX) {
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }

    switch (pDst->dwFourCC) {
    case FOURCC_YV12:
    case FOURCC_420i:
    case FOURCC_NV12:
        dwSubSample = 1;
        break;

    case FOURCC_YVU9:
    case FOURCC_IF09:
    case FOURCC_IV32:
    case FOURCC_IV31:
        dwSubSample = 2;
        break;

    case FOURCC_YUY2:
    case FOURCC_UYVY:
    case FOURCC_UYNV:
    case FOURCC_YUNV:
        // everything already moved
        dwSubSample = 0;
        break;

    default:
        pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    dwSrcOffset = pSrc->dwOffset;
    dwSrcPitch  = pSrc->dwPitch;
    dwDstOffset = pDst->dwOffset;
    dwDstPitch  = pDst->dwPitch;
    pDriverData->bltData.dwMTMFIndex ^= 1;

    // move luma
    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    if (pDriverData->bltData.dwMTMFIndex & 0x1) {
        nvPushData(1, NV_DD_GENERIC_MTMF_1);
        pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_1;
    } else {
        nvPushData(1, NV_DD_GENERIC_MTMF_2);
        pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_2;
    }
    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000);
    nvPushData(3, pSrc->dwContextDma);                      // SetContextDmaBufferIn
    nvPushData(4, pDst->dwContextDma);                      // SetContextDmaBufferOut
    nvPushData(5, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
    nvPushData(6, dwSrcOffset);                             // OffsetIn
    nvPushData(7, dwDstOffset);                             // OffsetOut
    nvPushData(8, dwSrcPitch);                              // PitchIn
    nvPushData(9, dwDstPitch);                              // PitchOut
    nvPushData(10, dwSrcPitch);                             // LineLengthIn
    nvPushData(11, pDst->dwHeight);                         // LineCount
    nvPushData(12, 0x101);                                  // Format
    nvPushData(13, NV039_BUFFER_NOTIFY_WRITE_ONLY);         // BufferNotify
    nvPusherAdjust(14);

    // move chroma
    if (dwSubSample > 0) {
        pDriverData->bltData.dwMTMFIndex ^= 1;
        dwSrcOffset += dwSrcPitch * pDst->dwHeight;
        dwDstOffset += dwDstPitch * pDst->dwHeight;
        dwSrcPitch >>= dwSubSample;
        dwDstPitch >>= dwSubSample;

        // move both V and U planes in one shot
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        if (pDriverData->bltData.dwMTMFIndex & 0x1) {
            nvPushData(1, NV_DD_GENERIC_MTMF_1);
            pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_1;
        } else {
            nvPushData(1, NV_DD_GENERIC_MTMF_2);
            pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_2;
        }
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000);
        nvPushData(3, pSrc->dwContextDma);                      // SetContextDmaBufferIn
        nvPushData(4, pDst->dwContextDma);                      // SetContextDmaBufferOut
        nvPushData(5, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        nvPushData(6, dwSrcOffset);                             // OffsetIn
        nvPushData(7, dwDstOffset);                             // OffsetOut
        nvPushData(8, dwSrcPitch);                              // PitchIn
        nvPushData(9, dwDstPitch);                              // PitchOut
        nvPushData(10, dwSrcPitch);                             // LineLengthIn
        nvPushData(11, pDst->dwHeight);                         // LineCount
        nvPushData(12, 0x101);                                  // Format
        nvPushData(13, NV039_BUFFER_NOTIFY_WRITE_ONLY);         // BufferNotify
        nvPusherAdjust(14);
    }
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltSlowVtoSBlt
//      Handles the fallback case when context DMA's are thrashing.  Simple copy,
//      no stretching, no ROPs, no colour key, no FOURCC to RGB
DWORD __stdcall bltSlowVtoSBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD i, j;
FLATPTR fpSrc, fpDst;
DWORD dwWidth, dwWidth1, dwWidth2;

    dbgTracePush ("bltSlowVtoSBlt");

    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

    // calculate source and destination offsets
    fpSrc  = pSrc->fpVidMem + pSrc->dwSubRectY * pSrc->dwPitch;
    fpSrc += (pSrc->dwSubRectX  * pSrc->dwBytesPerPixel);

    fpDst  = pDst->fpVidMem + pDst->dwSubRectY * pDst->dwPitch;
    fpDst += (pDst->dwSubRectX  * pDst->dwBytesPerPixel);

#ifdef WINNT
    if (pSrc->dwCaps & DDSCAPS_LOCALVIDMEM) {
        fpSrc += (DWORD) ppdev->pjFrameBufbase;
    }
    if (pDst->dwCaps & DDSCAPS_LOCALVIDMEM) {
        fpDst += (DWORD) ppdev->pjFrameBufbase;
    }
#endif

    // calculate widths
    // dwWidth1 is the width in DWORDs
    // dwWidth2 is the width in bytes of the rightmost pixel to the nearest 32 bit alignment on the left
    dwWidth = pSrc->dwSubRectWidth * pSrc->dwBytesPerPixel;
    dwWidth1 = dwWidth >> 2;
    dwWidth2 = dwWidth - (dwWidth1 << 2);

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX) {
        DWORD dwSrcPitch = pSrc->dwPitch;
        DWORD dwDstPitch = pDst->dwPitch;
        for (j = 0; j < pDst->dwSubRectHeight; j++) {
            _asm {
                    mov     edi, fpDst
                    mov     esi, fpSrc
                    mov     eax, dwWidth
                    mov     ecx, dwWidth1
                    and     eax, 7
                    shr     ecx, 1
                    jz      checkd

            qloop:  movq    mm0, [esi]
                    add     esi, 8
                    movq    [edi], mm0
                    add     edi, 8
                    dec     ecx
                    jnz     qloop

            checkd: cmp     eax, 4
                    jb      checkw
                    mov     edx, [esi]
                    add     esi, 4
                    sub     eax, 4
                    mov     [edi], edx
                    add     edi, 4
            checkw: cmp     eax, 2
                    jb      checkb
                    mov     dx, [esi]
                    add     esi, 2
                    sub     eax, 2
                    mov     [edi], dx
                    add     edi, 2
            checkb: test    eax, eax
                    jz      endofline
                    mov     dl, [esi]
                    mov     [edi], dl

            endofline:
                    mov     eax, fpSrc
                    mov     ebx, fpDst
                    add     eax, dwSrcPitch
                    add     ebx, dwDstPitch
                    mov     fpSrc, eax
                    mov     fpDst, ebx
            }
        }
        _asm emms;
    } else {
        for (j = 0; j < pDst->dwSubRectHeight; j++) {
            for (i = 0; i < dwWidth1; i++) {
                *((LPDWORD)fpDst + i) = *((LPDWORD)fpSrc + i);
            }
            switch (dwWidth2) {
            case 1: *((LPBYTE)fpDst + (dwWidth1 << 2)) = *((LPBYTE)fpSrc + (dwWidth1 << 2)); break;
            case 2: *((LPWORD)fpDst + (dwWidth1 << 1)) = *((LPWORD)fpSrc + (dwWidth1 << 1)); break;
            case 3: *((LPWORD)fpDst + (dwWidth1 << 1)) = *((LPWORD)fpSrc + (dwWidth1 << 1));
                    *((LPBYTE)fpDst + (dwWidth1 << 2) + 2) = *((LPBYTE)fpSrc + (dwWidth1 << 2) + 2); break;
            default: break;
            }
            fpDst += pDst->dwPitch;
            fpSrc += pSrc->dwPitch;
        }
    }

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltSlowStoVBlt
//      Handles the fallback case when context DMA's are thrashing.  Use stretched_image
//      instead of context DMA's
DWORD __stdcall bltSlowStoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD dwSrcFormat;
DWORD dwSizeIn, dwSizeOut, dwClipOut, dwPointOut;
DWORD dwDeltaX, dwDeltaY;
DWORD dwSrcLineSize;
DWORD i, j;
LPDWORD lpSrcPtr;
DWORD dwAlignAdjust;
DWORD dwDstX, dwDstY;

    dbgTracePush ("bltSlowStoVBlt");

    bltSetSurfaces2D(pSrc, pDst);

    switch (pSrc->dwBytesPerPixel) {
    case 1: dwSrcFormat = NV066_SET_COLOR_FORMAT_LE_X8R8G8B8; break;
    case 2: dwSrcFormat = NV066_SET_COLOR_FORMAT_LE_R5G6B5;   break;
    case 4: dwSrcFormat = NV066_SET_COLOR_FORMAT_LE_X8R8G8B8; break;
    default:
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }

    dwSizeIn  = pSrc->dwSubRectWidth | (pSrc->dwSubRectHeight << 16);
    dwClipOut = pDst->dwSubRectX     | (pDst->dwSubRectY << 16);
    dwSizeOut = pDst->dwSubRectWidth | (pDst->dwSubRectHeight << 16);
    dwDstX    = pDst->dwSubRectX;
    dwDstY    = pDst->dwSubRectY;

    dwDeltaX = (pDst->dwSubRectWidth << 20)  / pSrc->dwSubRectWidth + 1;
    dwDeltaY = (pDst->dwSubRectHeight << 20) / pSrc->dwSubRectHeight + 1;

    if (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT) {
        dwDeltaX = -(int)dwDeltaX;
        pbd->bltFX.dwDDFX &= ~DDBLTFX_MIRRORLEFTRIGHT;
        dwDstX += pDst->dwSubRectWidth + 1;
    }
    if (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN) {
        dwDeltaY = -(int)dwDeltaY;
        pbd->bltFX.dwDDFX &= ~DDBLTFX_MIRRORUPDOWN;
        dwDstY += pDst->dwSubRectHeight + 1;
    }
    dwPointOut = (dwDstY << 20) | (dwDstX << 4);

    if (pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) {
        DWORD dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;
        DWORD dwAlphaMask[5] = { 0xDEADBEAF, NV_ALPHA_1_008, NV_ALPHA_1_016, 0xDEADBEAF, NV_ALPHA_1_032 };
        nvAssert((pDst->dwBytesPerPixel >= 1) && (pDst->dwBytesPerPixel <= 4));

        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) + SET_TRANSCOLOR_OFFSET | 0x40000);
        nvPushData(3, (dwColorKey & pDriverData->physicalColorMask) | dwAlphaMask[pDst->dwBytesPerPixel]);
        nvPusherAdjust(4);
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData(1, NV_DD_GENERIC_STRETCHED_IMAGE);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_STRETCH) | STRETCHED_IMAGE_COLOR_FORMAT_OFFSET | 0x1C0000);
    nvPushData(3, dwSrcFormat);             // SetColorFormat
    nvPushData(4, dwSizeIn);                // SizeIn
    nvPushData(5, dwDeltaX);                // DxDs
    nvPushData(6, dwDeltaY);                // DyDt
    nvPushData(7, dwClipOut);               // ClipPoint
    nvPushData(8, dwSizeOut);               // ClipSize
    nvPushData(9, dwPointOut);              // Point12d4
    nvPusherAdjust(10);

    dwSrcLineSize = pSrc->dwSubRectWidth * pSrc->dwBytesPerPixel;
    lpSrcPtr = (LPDWORD)(pSrc->fpVidMem + pSrc->dwSubRectY * pSrc->dwPitch + pSrc->dwSubRectX * pSrc->dwBytesPerPixel);
#ifdef WINNT
    if (pSrc->dwCaps & DDSCAPS_LOCALVIDMEM) {
        lpSrcPtr = (LPDWORD)((DWORD)lpSrcPtr + (DWORD)ppdev->pjFrameBufbase);
    }
#endif

    for (j = 0, dwAlignAdjust = 0; j < pSrc->dwSubRectHeight; j++) {
        int nBytesRemaining;
        LPDWORD lpData;

        nBytesRemaining = dwSrcLineSize - dwAlignAdjust;
        lpData = (LPDWORD)((DWORD)lpSrcPtr + dwAlignAdjust);
        while (nBytesRemaining > 3)
        {
            DWORD dwChunk, dwIndex;
            // dwChunk is measured in DWORDS
            dwChunk = min(nBytesRemaining >> 2, g_iPusherThreshold); // pusher can't accept more than 63 dwords
            nvPushData(0, dDrawSubchannelOffset(NV_DD_STRETCH) | STRETCHED_IMAGE_COLOR_OFFSET | (dwChunk << 18));
            for (i = 0, dwIndex = 1; i < dwChunk; i++) {
                // shovel data into push buffer
                nvPushData(dwIndex++, *lpData++);
            }
            nvPusherAdjust(dwIndex);
            nBytesRemaining -= dwChunk << 2;
        }
        if (nBytesRemaining) {
            // deal with unaligned lengths
            DWORD dwLastBytes;
            switch (nBytesRemaining) {
            case 1: dwLastBytes = *((LPBYTE)lpData); break;
            case 2: dwLastBytes = *((LPWORD)lpData); break;
            case 3: dwLastBytes = *((LPWORD)lpData) | (*((LPBYTE)lpData + 2) << 16); break;
            default: break;
            }
            if ((j + 1) < pSrc->dwSubRectHeight) {
                // need to pack pixels from next line
                LPDWORD lpNextLine;
                lpNextLine = lpSrcPtr + (pSrc->dwPitch >> 2);
                switch (nBytesRemaining) {
                case 1:
                    dwLastBytes |= ((DWORD)*((LPDWORD)lpNextLine) << 8) | ((DWORD)*((LPBYTE)lpNextLine + 2) << 24);
                    dwAlignAdjust = 3;
                    break;
                case 2:
                    dwLastBytes |= (DWORD)*((LPWORD)lpNextLine) << 16;
                    dwAlignAdjust = 2;
                    break;
                case 3:
                    dwLastBytes |= (DWORD)*((LPBYTE)lpNextLine) << 24;
                    dwAlignAdjust = 1;
                    break;
                default: break;
                }
                if (dwAlignAdjust > dwSrcLineSize) {
                    DWORD dwBytesNeededToPackTheDword = dwAlignAdjust - dwSrcLineSize;
                    lpNextLine += (pSrc->dwPitch >> 2);
                    // very small width line (one pixel), need to pack in pixels from next line(s) too
                    if ((j + 2) < pSrc->dwSubRectHeight) {
                        switch (dwBytesNeededToPackTheDword) {
                        case 1:
                            dwLastBytes &= 0x00FFFFFF;
                            dwLastBytes |= (DWORD)*((LPBYTE)lpNextLine) << 24;
                            dwAlignAdjust = 1;
                            break;
                        case 2:
                            dwLastBytes &= 0x0000FFFF;
                            dwLastBytes |= (DWORD)*((LPWORD)lpNextLine) << 16;
                            dwAlignAdjust = 2;
                            break;
                        }
                    }
                    if (dwAlignAdjust > dwSrcLineSize) {
                        lpNextLine += (pSrc->dwPitch >> 2);
                        if ((j + 3) < pSrc->dwSubRectHeight) {
                            dwLastBytes &= 0x00FFFFFF;
                            dwLastBytes |= (DWORD)*((LPBYTE)lpNextLine) << 24;
                            dwAlignAdjust = 1;
                        }
                        // we skipped two lines
                        lpSrcPtr += (pSrc->dwPitch >> 1);
                        j += 2;
                    } else {
                        // we skipped a line
                        lpSrcPtr += (pSrc->dwPitch >> 2);
                        j++;
                    }
                }
            }
            nvPushData(0, dDrawSubchannelOffset(NV_DD_STRETCH) | STRETCHED_IMAGE_COLOR_OFFSET | 0x40000);
            nvPushData(1, dwLastBytes);
            nvPusherAdjust(2);
        } else if (nBytesRemaining == 0) {
            dwAlignAdjust = 0;
        }
        lpSrcPtr += (pSrc->dwPitch >> 2);
    }
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltSimpleVtoVBlt
//      Simple video to video, no stretch, no mirror blit
DWORD __stdcall bltSimpleVtoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
    dbgTracePush ("bltSimpleVtoVBlt");

    bltSetSurfaces2D(pSrc, pDst);

    nvPushData (0, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
    nvPushData (1, (pSrc->dwSubRectY << 16) | pSrc->dwSubRectX);          // ControlPointIn
    nvPushData (2, (pDst->dwSubRectY << 16) | pDst->dwSubRectX);          // ControlPointOut
    nvPushData (3, (pDst->dwSubRectHeight << 16) | pDst->dwSubRectWidth); // Size
    nvPusherAdjust(4);
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltSimpleCopy
//      Simple rectangular copy.  No rop, no colour key, no bit depth dependency.
//      Will not do system to system copies.
DWORD __stdcall bltSimpleCopy(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD dwSrcOffset, dwDstOffset;

    dbgTracePush ("bltSimpleCopy");

    dwSrcOffset = pSrc->dwOffset + pSrc->dwSubRectY * pSrc->dwPitch + pSrc->dwSubRectX * pSrc->dwBytesPerPixel;
    dwDstOffset = pDst->dwOffset + pDst->dwSubRectY * pDst->dwPitch + pDst->dwSubRectX * pDst->dwBytesPerPixel;
    pDriverData->bltData.dwMTMFIndex ^= 1;   // alternate odd and even

    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    if (pDriverData->bltData.dwMTMFIndex & 0x1) {
        nvPushData(1, NV_DD_GENERIC_MTMF_1);
        pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_1;
    } else {
        nvPushData(1, NV_DD_GENERIC_MTMF_2);
        pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_2;
    }
    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000);
    nvPushData(3, pSrc->dwContextDma);                      // SetContextDmaBufferIn
    nvPushData(4, pDst->dwContextDma);                      // SetContextDmaBufferOut
    nvPushData(5, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
    nvPushData(6, dwSrcOffset);                             // OffsetIn
    nvPushData(7, dwDstOffset);                             // OffsetOut
    nvPushData(8, pSrc->dwPitch);                           // PitchIn
    nvPushData(9, pDst->dwPitch);                           // PitchOut
    nvPushData(10, pDst->dwSubRectWidth * pDst->dwBytesPerPixel); // LineLengthIn
    nvPushData(11, pDst->dwSubRectHeight);                  // LineCount
    nvPushData(12, 0x101);                                  // Format
    nvPushData(13, NV039_BUFFER_NOTIFY_WRITE_ONLY);         // BufferNotify
    nvPusherAdjust(14);
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// blt8bppStrBlt
//      Special case for 8 bpp strblts.  Pixel replication only, no interpolation
DWORD __stdcall blt8bppStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD xAcc, yAcc;
DWORD xInc, yInc;
DWORD i, j;
SURFINFO src, ws;
DWORD ex, why, size;
unsigned iPrecisionFactor = 20;

    dbgTracePush ("blt8bppStrBlt");

    xAcc = yAcc = 0;
    xInc = (pSrc->dwSubRectWidth << iPrecisionFactor)  / pDst->dwSubRectWidth;
    yInc = (pSrc->dwSubRectHeight << iPrecisionFactor) / pDst->dwSubRectHeight;

    // create intermediate workspace
    ws = *pSrc;
    ws.dwSubRectX = 0;
    ws.dwSubRectY = 0;
    ws.dwSubRectWidth  = max(pSrc->dwSubRectWidth, pDst->dwSubRectWidth);
    ws.dwSubRectHeight = max(pSrc->dwSubRectHeight, pDst->dwSubRectHeight);
    ws.dwPitch = (ws.dwWidth + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

    if (pSrc->dwCaps & DDSCAPS_LOCALVIDMEM) {
        // video to video
        ws.dwSubRectHeight *= 2;  // we need 2x as much work space
        if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) != DDHAL_DRIVER_HANDLED) {
            return DDHAL_DRIVER_NOTHANDLED;
        }
        ws.dwSubRectHeight /= 2;  // restore proper height
        ws.dwOffset += ws.dwPitch * ws.dwSubRectHeight;     // leave top half undisturbed for use by blit32
        bltSetSurfaces2D(pSrc, &ws);
    } else {
        // system to video
        ws.dwSubRectHeight *= 3;  // we need 3x as much work space
        if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) != DDHAL_DRIVER_HANDLED) {
            return DDHAL_DRIVER_NOTHANDLED;
        }
        ws.dwSubRectHeight /= 3;  // restore proper height

        // first copy it to video memory
        ws.dwOffset += ws.dwPitch * ws.dwSubRectHeight;     // leave top third undisturbed for use by blit32
        ws.dwSubRectWidth = pSrc->dwSubRectWidth;
        ws.dwSubRectHeight = pSrc->dwSubRectHeight;
        bltSimpleCopy(pbd, pSrc, &ws);
        src = ws;
        pSrc = &src;                                        // mid third of ws is our new source
        ws.dwOffset += ws.dwPitch * ws.dwSubRectHeight;     // bottom third is our ws
        bltSetSurfaces2D(&src, &ws);
    }

    // disable color key
    if (pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
        nvPushData(3, 0);
        nvPusherAdjust(4);
        pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
        pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;
    }

    // first do the horizontal stretch one strip at a time
    // (better for memory bw when upscaling)
    why = pSrc->dwSubRectY << 16;
    size = (pSrc->dwSubRectHeight << 16) | 1;
    for (i=0, j=0; i<pDst->dwSubRectWidth; i++) {
        nvPushData (j++, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
        nvPushData (j++, why | (pSrc->dwSubRectX + (xAcc >> iPrecisionFactor)));// ControlPointIn
        nvPushData (j++, 0 | i);                                      // ControlPointOut
        nvPushData (j++, size);                                       // Size
        xAcc += xInc;
        if (j >= g_iPusherThreshold) {
            nvPusherAdjust(j);
            j = 0;
        }
    }
    if (j) nvPusherAdjust(j);
    nvPusherStart(TRUE);

    // do the vertical stretching
    bltSetSurfaces2D(&ws, pDst);
    ex = pDst->dwSubRectX;
    size = (1 << 16) | pDst->dwSubRectWidth;
    for (i=0, j=0; i<pDst->dwSubRectHeight; i++) {
        nvPushData (j++, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
        nvPushData (j++, ((yAcc >> iPrecisionFactor) << 16) | 0);   // ControlPointIn
        nvPushData (j++, ((pDst->dwSubRectY + i) << 16) | ex);      // ControlPointOut
        nvPushData (j++, size);                                     // Size
        yAcc += yInc;
        if (j >= g_iPusherThreshold) {
            nvPusherAdjust(j);
            j = 0;
        }
    }
    if (j) nvPusherAdjust(j);
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltStrBlt
//      Handles stretchblits, system to video blits, and FOURCC to RGB blits.
//      Does not handle stretched 8 bpp sources, nor color keyed blits.
//      Assumes this is non-overlapping.
DWORD __stdcall bltStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bFilter)
{
DWORD dwSrcFormat;
DWORD dwDeltaX, dwDeltaY;
DWORD dwDstPoint, dwDstSize, dwClipPoint;
DWORD dwSrcPoint, dwSrcWidth, dwSrcSize;
DWORD dwRetVal;

    dbgTracePush ("bltStrBlt");

    switch (pSrc->dwFourCC) {
    case 0:
        switch (pSrc->dwBytesPerPixel) {
        case 1:
            if ((pbd->bltFX.dwROP >> 16) != SRCCOPYINDEX ||
                (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT) ||
                (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)) {
                return DDHAL_DRIVER_NOTHANDLED;
            }
            dwRetVal = blt8bppStrBlt(pbd, pSrc, pDst);
            dbgTracePop();
            return dwRetVal;

        case 2:
            dwSrcFormat = NV063_SET_COLOR_FORMAT_LE_R5G6B5;
            break;

        case 4:
            dwSrcFormat = NV063_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;

        default:
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
        break;

    case FOURCC_YUY2:
    case FOURCC_YUNV:
    case FOURCC_NV12:
        dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8;
        if (pSrc->dwFourCC == FOURCC_NV12) { // Offset to YUY2 portion of surface, convert pitch to YUY2 pitch
            // TODO: make sure surface FOURCC format conversion is up to date before blitting
            pSrc->dwOffset += (pSrc->dwPitch * pSrc->dwHeight);
            pSrc->dwOffset += (pSrc->dwPitch * (pSrc->dwHeight >> 1));
            pSrc->dwOffset += (pSrc->dwPitch * 8) + 256;
            pSrc->dwPitch = (pSrc->dwWidth + 3) & ~3;
            pSrc->dwPitch = ((pSrc->dwPitch << 1) + 127) & ~127;
            // TODO: modify surface height when source is single field 1080i 
        }
        break;

    case FOURCC_UYVY:
    case FOURCC_UYNV:
        dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8;
        break;

    case FOURCC_YV12:
    case FOURCC_420i:
        // TODO: convert YUV12 to YUV422
    case FOURCC_IF09:
    case FOURCC_YVU9:
    case FOURCC_IV32:
    case FOURCC_IV31:
        // TODO: convert YUV9 to YUV422
    default:
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // scaled image doesn't like big subrectangle offsets, adjust
    // NV20 offsets must be aligned to pitch*4
    pSrc->dwOffset += (pSrc->dwSubRectY & 0xFFFFFFFC) * pSrc->dwPitch;
    pSrc->dwSubRectY &= 0x3;
    pSrc->dwOffset += (pSrc->dwSubRectX  * pSrc->dwBytesPerPixel) & ~NV_BYTE_ALIGNMENT_PAD;
    pSrc->dwSubRectX &= (NV_BYTE_ALIGNMENT / pSrc->dwBytesPerPixel) - 1;

    pDst->dwOffset += (pDst->dwSubRectY & 0xFFFFFFFC) * pDst->dwPitch;
    pDst->dwSubRectY &= 0x3;
    pDst->dwOffset += (pDst->dwSubRectX  * pDst->dwBytesPerPixel) & ~NV_BYTE_ALIGNMENT_PAD;
    pDst->dwSubRectX &= (NV_BYTE_ALIGNMENT / pDst->dwBytesPerPixel) - 1;

    bltSetSurfaces2D(pSrc, pDst);

    if (bFilter) {
        if (pDst->dwSubRectWidth <= 1) {
            dwDeltaX = 1 << 20;
        } else {
            dwDeltaX = ((pSrc->dwSubRectWidth - 1) << 20)  / (pDst->dwSubRectWidth - 1);    // 12.20 fixed point
        }
        if (pDst->dwSubRectHeight <= 1) {
            dwDeltaY = 1 << 20;
        } else {
            dwDeltaY = ((pSrc->dwSubRectHeight - 1) << 20) / (pDst->dwSubRectHeight - 1);   // 12.20 fixed point
        }
    } else {
        dwDeltaX = (pSrc->dwSubRectWidth  << 20) / pDst->dwSubRectWidth;    // 12.20 fixed point
        dwDeltaY = (pSrc->dwSubRectHeight << 20) / pDst->dwSubRectHeight;   // 12.20 fixed point
    }
    dwDstPoint = dwClipPoint = (pDst->dwSubRectY << 16) | pDst->dwSubRectX;
    dwDstSize  = (pDst->dwSubRectHeight << 16) | pDst->dwSubRectWidth;
    dwSrcPoint = ((pSrc->dwSubRectY << 16)     | pSrc->dwSubRectX) << 4;
    dwSrcWidth = pSrc->dwSubRectWidth;
    if ((dwSrcWidth + pSrc->dwSubRectX) > 2046) dwSrcWidth = 2046 - pSrc->dwSubRectX; // hardware limit
    dwSrcSize  = ((pSrc->dwSubRectHeight + pSrc->dwSubRectY) << 16) | ((dwSrcWidth + pSrc->dwSubRectX + 1) & ~1);
    // add pixel biases if we are scaling, except when we are using colour key (WHQL issue)
    if (bFilter && !(pbd->dwFlags & DDBLT_KEYSRCOVERRIDE)) {
        if (dwDeltaX != 0x100000) {
            dwSrcPoint = (dwSrcPoint & 0xFFFF0000) | ((dwSrcPoint & 0xFFFF) - 4);
        }
        if (dwDeltaY != 0x100000) {
            dwSrcPoint = ((dwSrcPoint & 0xFFFF0000) - 0x00080000) | (dwSrcPoint & 0xFFFF);
        }
    } else {
        dwSrcPoint += (dwDeltaX >> 17);
        dwSrcPoint += (dwDeltaY >> 17) << 16;
    }

    if (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT) {
        dwDeltaX = -(int)dwDeltaX;
        pbd->bltFX.dwDDFX &= ~DDBLTFX_MIRRORLEFTRIGHT;
        dwSrcPoint = ((dwSrcPoint & 0x0000FFFF) + ((pSrc->dwSubRectWidth + 1) << 4)) | (dwSrcPoint & 0xFFFF0000);
    }
    if (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN) {
        dwDeltaY = -(int)dwDeltaY;
        pbd->bltFX.dwDDFX &= ~DDBLTFX_MIRRORUPDOWN;
        dwSrcPoint = ((dwSrcPoint & 0xFFFF0000) + ((pSrc->dwSubRectHeight + 1) << 20)) | (dwSrcPoint & 0x0000FFFF);
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData(1, NV_DD_SCALED_IMAGE_IID);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    nvPushData(3, pSrc->dwContextDma);      // SetContextDmaImage
    nvPushData(4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_SURFACE_OFFSET | 0x40000);
    if (pDst->bUseSwizzle) {
        nvPushData(5, D3D_CONTEXT_SURFACE_SWIZZLED);    // SetContextSurface
    } else {
        nvPushData(5, NV_DD_SURFACES_2D);               // SetContextSurface
    }
    nvPushData(6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    nvPushData(7, dwSrcFormat);             // SetColorFormat
    nvPushData(8, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    nvPushData(9, dwClipPoint);             // ClipPoint
    nvPushData(10, dwDstSize);              // ClipSize
    nvPushData(11, dwDstPoint);             // ImageOutPoint
    nvPushData(12, dwDstSize);              // ImageOutSize
    nvPushData(13, dwDeltaX);               // DsDx
    nvPushData(14, dwDeltaY);               // DtDy

    nvPushData(15, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    nvPushData(16, dwSrcSize);              // ImageInSize
    if (bFilter) {
        nvPushData(17, (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |     // ImageInFormat
                       (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                       pSrc->dwPitch);
    } else {
        nvPushData(17, (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) |     // ImageInFormat
                       (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                       pSrc->dwPitch);
    }
    nvPushData(18, pSrc->dwOffset);         // ImageInOffset
    nvPushData(19, dwSrcPoint);             // ImageInPoint
    nvPusherAdjust(20);

    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}


#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvCaps.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//  Content:    Routines to export hardware capabilities
//
//  History:
//      Craig Duttweiler    bertrem     10Feb1999   added celsius
//      Craig Duttweiler    bertrem     26Apr2000   added kelvin
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "nv4caps.h"
#include "nvCelsiusCaps.h"
#include "nvKelvinCaps.h"

void nvSetHardwareCaps (void)
{
    dbgTracePush ("nvSetHardwareCaps");

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

        // D3DDEVICEDESC_V1 caps

        memset (&(getDC()->nvD3DDevCaps.dd1Caps), 0, sizeof(D3DDEVICEDESC_V1));

        getDC()->nvD3DDevCaps.dd1Caps.dwSize                            = sizeof(D3DDEVICEDESC_V1);
        getDC()->nvD3DDevCaps.dd1Caps.dwFlags                           = KELVIN_DEVDESC_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dcmColorModel                     = KELVIN_COLORMODEL;
        getDC()->nvD3DDevCaps.dd1Caps.dwDevCaps                         = KELVIN_DEVCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwSize           = sizeof(D3DTRANSFORMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwCaps           = KELVIN_TRANSFORMCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.bClipping                         = KELVIN_3DCLIPPINGCAPS;

        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwSize            = sizeof(D3DLIGHTINGCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwCaps            = KELVIN_LIGHTINGCAPS_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwLightingModel   = D3DLIGHTINGMODEL_RGB;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwNumLights       = KELVIN_MAX_LIGHTS;

        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSize                = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwMiscCaps            = KELVIN_LINECAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwRasterCaps          = KELVIN_LINECAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwZCmpCaps            = KELVIN_LINECAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSrcBlendCaps        = KELVIN_LINECAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwDestBlendCaps       = KELVIN_LINECAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwAlphaCmpCaps        = KELVIN_LINECAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwShadeCaps           = KELVIN_LINECAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureCaps         = KELVIN_LINECAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureFilterCaps   = KELVIN_LINECAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureBlendCaps    = KELVIN_LINECAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureAddressCaps  = KELVIN_LINECAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleWidth        = KELVIN_LINECAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleHeight       = KELVIN_LINECAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSize                 = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwMiscCaps             = KELVIN_TRICAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwRasterCaps           = KELVIN_TRICAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwZCmpCaps             = KELVIN_TRICAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSrcBlendCaps         = KELVIN_TRICAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwDestBlendCaps        = KELVIN_TRICAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwAlphaCmpCaps         = KELVIN_TRICAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwShadeCaps            = KELVIN_TRICAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureCaps          = KELVIN_TRICAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureFilterCaps    = KELVIN_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureBlendCaps     = KELVIN_TRICAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureAddressCaps   = KELVIN_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleWidth         = KELVIN_TRICAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleHeight        = KELVIN_TRICAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceRenderBitDepth            = KELVIN_RENDERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceZBufferBitDepth           = KELVIN_ZBUFFERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxBufferSize                   = KELVIN_MAXBUFFERSIZE;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxVertexCount                  = KELVIN_MAXVERTEXCOUNT;

        // D3DHAL_D3DEXTENDEDCAPS

        memset (&(getDC()->nvD3DDevCaps.d3dExtCaps), 0, sizeof(D3DHAL_D3DEXTENDEDCAPS));

        getDC()->nvD3DDevCaps.d3dExtCaps.dwSize                         = 0;  // to be set later in getDriverInfo
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureWidth              = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureWidth              = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureHeight             = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureHeight             = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureRepeat             = KELVIN_CAPS_MAX_TEXTURE_REPEAT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureAspectRatio        = KELVIN_CAPS_MAX_TEXTURE_ASPECT_RATIO;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxAnisotropy                = KELVIN_CAPS_MAX_ANISOTROPY;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandLeft                = KELVIN_CAPS_GUARD_BAND_LEFT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandTop                 = KELVIN_CAPS_GUARD_BAND_TOP;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandRight               = KELVIN_CAPS_GUARD_BAND_RIGHT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandBottom              = KELVIN_CAPS_GUARD_BAND_BOTTOM;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvExtentsAdjust                = KELVIN_CAPS_EXTENTS_ADJUST;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwStencilCaps                  = KELVIN_CAPS_STENCILOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwFVFCaps                      = KELVIN_CAPS_FVF_CAPS
                                                                            | D3DFVFCAPS_DONOTSTRIPELEMENTS; // bdw: leave here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwTextureOpCaps                = KELVIN_CAPS_TEXTUREOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxTextureBlendStages         = KELVIN_CAPS_MAX_TEXTURE_BLEND_STATES;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxSimultaneousTextures       = KELVIN_CAPS_MAX_SIMULTANEOUS_TEXTURES;

        // BUBGUG still need some data here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxActiveLights              = KELVIN_CAPS_MAX_ACTIVE_LIGHTS;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvMaxVertexW                   = 1.0e10; //as per refrast
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxUserClipPlanes             = KELVIN_CAPS_MAX_USER_CLIP_PLANES_EXPORTED;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxVertexBlendMatrices        = KELVIN_CAPS_MAX_VERTEX_BLEND_MATRICES;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwVertexProcessingCaps         = KELVIN_CAPS_VTXPCAPS;

        // HMH need to get rid of constants
        // set up D3DCAPS8, all the same info, new easier to swallow gelcap form.
        LPDDHALINFO pHalInfo = GET_HALINFO();

        //getDC()->nvD3DDevCaps.dwD3DCap8.DeviceType = ??
        getDC()->nvD3DDevCaps.dwD3DCap8.AdapterOrdinal = 0;

        /* Filled in by run-time */
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps                            = pHalInfo->ddCaps.dwCaps;
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps2                           = pHalInfo->ddCaps.dwCaps2;
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps3                           = 0;
        getDC()->nvD3DDevCaps.dwD3DCap8.PresentationIntervals           = 0;
        getDC()->nvD3DDevCaps.dwD3DCap8.CursorCaps                      = 0;
        /* END Filled in by run-time */

        getDC()->nvD3DDevCaps.dwD3DCap8.DevCaps                         = KELVIN_DEVCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dwD3DCap8.PrimitiveMiscCaps               = KELVIN_TRICAPS_MISC;
        getDC()->nvD3DDevCaps.dwD3DCap8.RasterCaps                      = KELVIN_TRICAPS_RASTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.ZCmpCaps                        = KELVIN_TRICAPS_ZCMP;
        getDC()->nvD3DDevCaps.dwD3DCap8.SrcBlendCaps                    = KELVIN_TRICAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dwD3DCap8.DestBlendCaps                   = KELVIN_TRICAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dwD3DCap8.AlphaCmpCaps                    = KELVIN_TRICAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dwD3DCap8.ShadeCaps                       = KELVIN_TRICAPS_SHADE;
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureCaps                     = KELVIN_TRICAPS_TEXTURE;

        getDC()->nvD3DDevCaps.dwD3DCap8.TextureFilterCaps               = KELVIN_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.CubeTextureFilterCaps           = KELVIN_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureFilterCaps         = KELVIN_TRICAPS_VOLUMETEXFILTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureAddressCaps              = KELVIN_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureAddressCaps        = KELVIN_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dwD3DCap8.LineCaps                        = D3DLINECAPS_TEXTURE     |
                                                                          D3DLINECAPS_ZTEST       |
                                                                          D3DLINECAPS_BLEND       |
                                                                          D3DLINECAPS_ALPHACMP    |
                                                                          D3DLINECAPS_FOG;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureWidth                 = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureHeight                = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVolumeExtent                 = pDriverData->nvD3DPerfData.dwMaxVolumeTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureRepeat                = KELVIN_CAPS_MAX_TEXTURE_REPEAT;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureAspectRatio           = KELVIN_CAPS_MAX_TEXTURE_ASPECT_RATIO;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxAnisotropy                   = KELVIN_CAPS_MAX_ANISOTROPY;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexW                      = 1.0e10; // as per refrast

        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandLeft                   = KELVIN_CAPS_GUARD_BAND_LEFT;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandTop                    = KELVIN_CAPS_GUARD_BAND_TOP;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandRight                  = KELVIN_CAPS_GUARD_BAND_RIGHT;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandBottom                 = KELVIN_CAPS_GUARD_BAND_BOTTOM;
        getDC()->nvD3DDevCaps.dwD3DCap8.ExtentsAdjust                   = KELVIN_CAPS_EXTENTS_ADJUST;

        getDC()->nvD3DDevCaps.dwD3DCap8.StencilCaps                     = KELVIN_CAPS_STENCILOPS;
        getDC()->nvD3DDevCaps.dwD3DCap8.FVFCaps                         = KELVIN_CAPS_FVF_CAPS    |
                                                                          D3DFVFCAPS_DONOTSTRIPELEMENTS; // bdw: leave here
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureOpCaps                   = KELVIN_CAPS_TEXTUREOPS;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureBlendStages           = KELVIN_CAPS_MAX_TEXTURE_BLEND_STATES;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxSimultaneousTextures         = KELVIN_CAPS_MAX_SIMULTANEOUS_TEXTURES;

        getDC()->nvD3DDevCaps.dwD3DCap8.VertexProcessingCaps            = KELVIN_CAPS_VTXPCAPS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxActiveLights                 = KELVIN_CAPS_MAX_ACTIVE_LIGHTS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxUserClipPlanes               = KELVIN_CAPS_MAX_USER_CLIP_PLANES_EXPORTED;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexBlendMatrices          = KELVIN_CAPS_MAX_VERTEX_BLEND_MATRICES;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexBlendMatrixIndex       = 0;  // no indexed (palettized) matrices

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPointSize                    = 64.0f;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPrimitiveCount               = 0xfffff;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexIndex                  = 0xfffff;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxStreams                      = KELVIN_CAPS_MAX_STREAMS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxStreamStride                 = 256;
        getDC()->nvD3DDevCaps.dwD3DCap8.VertexShaderVersion             = D3DVS_VERSION(1, 1);
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexShaderConst            = KELVIN_CAPS_MAX_VSHADER_CONSTS;
        getDC()->nvD3DDevCaps.dwD3DCap8.PixelShaderVersion              = D3DPS_VERSION(1, 1);
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPixelShaderValue             = 1.0f;

        // fix some stuff up
        if (!pDriverData->nvD3DPerfData.dwHaveVolumeTextures) {
            // no volume maps on nv20. hopefully fixed in nv25, etc...
            DWORD dwVolumeCapMask = ~(D3DPTEXTURECAPS_VOLUMEMAP      |
                                      D3DPTEXTURECAPS_VOLUMEMAP_POW2 |
                                      D3DPTEXTURECAPS_MIPVOLUMEMAP);
            getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureCaps &= dwVolumeCapMask;
            getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureCaps  &= dwVolumeCapMask;
            getDC()->nvD3DDevCaps.dwD3DCap8.TextureCaps             &= dwVolumeCapMask;
            getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureFilterCaps  = 0;
            getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureAddressCaps = 0;
        }

        if (!pDriverData->nvD3DPerfData.dwHaveAnisotropic) {
            DWORD dwAnisoCapMask = ~(D3DPTFILTERCAPS_MAGFANISOTROPIC |
                                     D3DPTFILTERCAPS_MINFANISOTROPIC);
            getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureFilterCaps &= dwAnisoCapMask;
            getDC()->nvD3DDevCaps.dwD3DCap8.TextureFilterCaps            &= dwAnisoCapMask;
            getDC()->nvD3DDevCaps.dwD3DCap8.CubeTextureFilterCaps        &= dwAnisoCapMask;
            getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureFilterCaps      &= dwAnisoCapMask;
            getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwRasterCaps &= ~D3DPRASTERCAPS_ANISOTROPY;
            getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwRasterCaps  &= ~D3DPRASTERCAPS_ANISOTROPY;
            getDC()->nvD3DDevCaps.dwD3DCap8.RasterCaps             &= ~D3DPRASTERCAPS_ANISOTROPY;
            getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxAnisotropy = 0;
            getDC()->nvD3DDevCaps.dwD3DCap8.MaxAnisotropy    = 0;
        }

    }

    else
#endif // (NVARCH >= 0x20)

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {

        // D3DDEVICEDESC_V1 caps

        memset (&(getDC()->nvD3DDevCaps.dd1Caps), 0, sizeof(D3DDEVICEDESC_V1));

        getDC()->nvD3DDevCaps.dd1Caps.dwSize                            = sizeof(D3DDEVICEDESC_V1);
        getDC()->nvD3DDevCaps.dd1Caps.dwFlags                           = CELSIUS_DEVDESC_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dcmColorModel                     = CELSIUS_COLORMODEL;
        getDC()->nvD3DDevCaps.dd1Caps.dwDevCaps                         = CELSIUS_DEVCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwSize           = sizeof(D3DTRANSFORMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwCaps           = CELSIUS_TRANSFORMCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.bClipping                         = CELSIUS_3DCLIPPINGCAPS;

        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwSize            = sizeof(D3DLIGHTINGCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwCaps            = CELSIUS_LIGHTINGCAPS_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwLightingModel   = D3DLIGHTINGMODEL_RGB;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwNumLights       = CELSIUS_MAX_LIGHTS;

        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSize                = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwMiscCaps            = CELSIUS_LINECAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwRasterCaps          = CELSIUS_LINECAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwZCmpCaps            = CELSIUS_LINECAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSrcBlendCaps        = CELSIUS_LINECAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwDestBlendCaps       = CELSIUS_LINECAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwAlphaCmpCaps        = CELSIUS_LINECAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwShadeCaps           = CELSIUS_LINECAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureCaps         = CELSIUS_LINECAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureFilterCaps   = CELSIUS_LINECAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureBlendCaps    = CELSIUS_LINECAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureAddressCaps  = CELSIUS_LINECAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleWidth        = CELSIUS_LINECAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleHeight       = CELSIUS_LINECAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSize                 = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwMiscCaps             = CELSIUS_TRICAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwRasterCaps           = CELSIUS_TRICAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwZCmpCaps             = CELSIUS_TRICAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSrcBlendCaps         = CELSIUS_TRICAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwDestBlendCaps        = CELSIUS_TRICAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwAlphaCmpCaps         = CELSIUS_TRICAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwShadeCaps            = CELSIUS_TRICAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureCaps          = CELSIUS_TRICAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureFilterCaps    = CELSIUS_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureBlendCaps     = CELSIUS_TRICAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureAddressCaps   = CELSIUS_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleWidth         = CELSIUS_TRICAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleHeight        = CELSIUS_TRICAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceRenderBitDepth            = CELSIUS_RENDERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceZBufferBitDepth           = CELSIUS_ZBUFFERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxBufferSize                   = CELSIUS_MAXBUFFERSIZE;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxVertexCount                  = CELSIUS_MAXVERTEXCOUNT;

        // D3DHAL_D3DEXTENDEDCAPS

        memset (&(getDC()->nvD3DDevCaps.d3dExtCaps), 0, sizeof(D3DHAL_D3DEXTENDEDCAPS));

        getDC()->nvD3DDevCaps.d3dExtCaps.dwSize                         = 0;  // to be set later in getDriverInfo
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureWidth              = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureWidth              = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureHeight             = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureHeight             = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureRepeat             = CELSIUS_CAPS_MAX_TEXTURE_REPEAT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureAspectRatio        = CELSIUS_CAPS_MAX_TEXTURE_ASPECT_RATIO;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxAnisotropy                = CELSIUS_CAPS_MAX_ANISOTROPY;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandLeft                = CELSIUS_CAPS_GUARD_BAND_LEFT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandTop                 = CELSIUS_CAPS_GUARD_BAND_TOP;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandRight               = CELSIUS_CAPS_GUARD_BAND_RIGHT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandBottom              = CELSIUS_CAPS_GUARD_BAND_BOTTOM;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvExtentsAdjust                = CELSIUS_CAPS_EXTENTS_ADJUST;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwStencilCaps                  = CELSIUS_CAPS_STENCILOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwFVFCaps                      = CELSIUS_CAPS_FVF_CAPS
                                                                            | D3DFVFCAPS_DONOTSTRIPELEMENTS; // bdw: leave here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwTextureOpCaps                = CELSIUS_CAPS_TEXTUREOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxTextureBlendStages         = CELSIUS_CAPS_MAX_TEXTURE_BLEND_STATES;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxSimultaneousTextures       = CELSIUS_CAPS_MAX_SIMULTANEOUS_TEXTURES;

        // BUBGUG still need some data here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxActiveLights              = CELSIUS_CAPS_MAX_ACTIVE_LIGHTS;
        // getDC()->nvD3DDevCaps.d3dExtCaps.dvMaxVertexW                = ??;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxUserClipPlanes             = CELSIUS_CAPS_MAX_USER_CLIP_PLANES;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxVertexBlendMatrices        = CELSIUS_CAPS_MAX_VERTEX_BLEND_MATRICES;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwVertexProcessingCaps         = CELSIUS_CAPS_VTXPCAPS;

        // HMH need to get rid of constants
        LPDDHALINFO pHalInfo = GET_HALINFO();

        //getDC()->nvD3DDevCaps.dwD3DCap8.DeviceType = ??
        getDC()->nvD3DDevCaps.dwD3DCap8.AdapterOrdinal = 0;

        /* Filled in by run-time */
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps                            =  pHalInfo->ddCaps.dwCaps;
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps2                           = pHalInfo->ddCaps.dwCaps2;
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps3                           = 0;
        getDC()->nvD3DDevCaps.dwD3DCap8.PresentationIntervals           = 0;

        getDC()->nvD3DDevCaps.dwD3DCap8.CursorCaps                      = 0;
        /* END Filled in by run-time */
        getDC()->nvD3DDevCaps.dwD3DCap8.DevCaps                         = CELSIUS_DEVCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dwD3DCap8.PrimitiveMiscCaps               = CELSIUS_TRICAPS_MISC;
        getDC()->nvD3DDevCaps.dwD3DCap8.RasterCaps                      = CELSIUS_TRICAPS_RASTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.ZCmpCaps                        = CELSIUS_TRICAPS_ZCMP;
        getDC()->nvD3DDevCaps.dwD3DCap8.SrcBlendCaps                    = CELSIUS_TRICAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dwD3DCap8.DestBlendCaps                   = CELSIUS_TRICAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dwD3DCap8.AlphaCmpCaps                    = CELSIUS_TRICAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dwD3DCap8.ShadeCaps                       = CELSIUS_TRICAPS_SHADE;
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureCaps                     = CELSIUS_TRICAPS_TEXTURE;

        getDC()->nvD3DDevCaps.dwD3DCap8.TextureFilterCaps               = CELSIUS_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.CubeTextureFilterCaps           = CELSIUS_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureFilterCaps         = NULL;
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureAddressCaps              = CELSIUS_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureAddressCaps        = NULL;

        getDC()->nvD3DDevCaps.dwD3DCap8.LineCaps                        = D3DLINECAPS_TEXTURE     |
                                                                          D3DLINECAPS_ZTEST       |
                                                                          D3DLINECAPS_BLEND       |
                                                                          D3DLINECAPS_ALPHACMP    |
                                                                          D3DLINECAPS_FOG         ;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureWidth                 = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureHeight                = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVolumeExtent                 = pDriverData->nvD3DPerfData.dwMaxVolumeTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureRepeat                = CELSIUS_CAPS_MAX_TEXTURE_REPEAT;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureAspectRatio           = CELSIUS_CAPS_MAX_TEXTURE_ASPECT_RATIO;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxAnisotropy                   = CELSIUS_CAPS_MAX_ANISOTROPY;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexW                      = 1.0e10; // as per refrast

        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandLeft                   = CELSIUS_CAPS_GUARD_BAND_LEFT;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandTop                    = CELSIUS_CAPS_GUARD_BAND_TOP;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandRight                  = CELSIUS_CAPS_GUARD_BAND_RIGHT;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandBottom                 = CELSIUS_CAPS_GUARD_BAND_BOTTOM;
        getDC()->nvD3DDevCaps.dwD3DCap8.ExtentsAdjust                   = CELSIUS_CAPS_EXTENTS_ADJUST;

        getDC()->nvD3DDevCaps.dwD3DCap8.StencilCaps                     = CELSIUS_CAPS_STENCILOPS;
        getDC()->nvD3DDevCaps.dwD3DCap8.FVFCaps                         = CELSIUS_CAPS_FVF_CAPS
                                                                        | D3DFVFCAPS_DONOTSTRIPELEMENTS; // bdw: leave here
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureOpCaps                   = CELSIUS_CAPS_TEXTUREOPS;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureBlendStages           = CELSIUS_CAPS_MAX_TEXTURE_BLEND_STATES;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxSimultaneousTextures         = CELSIUS_CAPS_MAX_SIMULTANEOUS_TEXTURES;

        getDC()->nvD3DDevCaps.dwD3DCap8.VertexProcessingCaps            = CELSIUS_CAPS_VTXPCAPS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxActiveLights                 = CELSIUS_CAPS_MAX_ACTIVE_LIGHTS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxUserClipPlanes               = CELSIUS_CAPS_MAX_USER_CLIP_PLANES;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexBlendMatrices          = CELSIUS_CAPS_MAX_VERTEX_BLEND_MATRICES;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexBlendMatrixIndex       = 0;  // no indexed (palettized) matrices

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPointSize                    = 64.0f;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPrimitiveCount               = 0xffff;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexIndex                  = 0xffff;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxStreams                      = CELSIUS_CAPS_MAX_STREAMS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxStreamStride                 = 256;
        getDC()->nvD3DDevCaps.dwD3DCap8.VertexShaderVersion             = D3DVS_VERSION(0, 0);
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexShaderConst            = CELSIUS_CAPS_MAX_VSHADER_CONSTS;
        getDC()->nvD3DDevCaps.dwD3DCap8.PixelShaderVersion              = D3DPS_VERSION(0, 0);
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPixelShaderValue             = 0.0f;

    }

    else
#endif // (NVARCH >= 0x10)

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_DXTRI) {

        // D3DDEVICEDESC_V1 caps

        memset (&(getDC()->nvD3DDevCaps.dd1Caps), 0, sizeof(D3DDEVICEDESC_V1));

        getDC()->nvD3DDevCaps.dd1Caps.dwSize                            = sizeof(D3DDEVICEDESC_V1);
        getDC()->nvD3DDevCaps.dd1Caps.dwFlags                           = NV4_DEVDESC_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dcmColorModel                     = NV4_COLORMODEL;
        getDC()->nvD3DDevCaps.dd1Caps.dwDevCaps                         = NV4_DEVCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwSize           = sizeof(D3DTRANSFORMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwCaps           = NV4_TRANSFORMCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.bClipping                         = NV4_3DCLIPPINGCAPS;

        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwSize            = sizeof(D3DLIGHTINGCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwCaps            = NV4_LIGHTINGCAPS_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwLightingModel   = D3DLIGHTINGMODEL_RGB;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwNumLights       = NV4_MAX_LIGHTS;

        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSize                = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwMiscCaps            = NV4_LINECAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwRasterCaps          = NV4_LINECAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwZCmpCaps            = NV4_LINECAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSrcBlendCaps        = NV4_LINECAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwDestBlendCaps       = NV4_LINECAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwAlphaCmpCaps        = NV4_LINECAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwShadeCaps           = NV4_LINECAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureCaps         = NV4_LINECAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureFilterCaps   = NV4_LINECAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureBlendCaps    = NV4_LINECAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureAddressCaps  = NV4_LINECAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleWidth        = NV4_LINECAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleHeight       = NV4_LINECAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSize                 = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwMiscCaps             = NV4_TRICAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwRasterCaps           = NV4_TRICAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwZCmpCaps             = NV4_TRICAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSrcBlendCaps         = NV4_TRICAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwDestBlendCaps        = NV4_TRICAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwAlphaCmpCaps         = NV4_TRICAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwShadeCaps            = NV4_TRICAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureCaps          = NV4_TRICAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureFilterCaps    = NV4_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureBlendCaps     = NV4_TRICAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureAddressCaps   = NV4_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleWidth         = NV4_TRICAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleHeight        = NV4_TRICAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceRenderBitDepth            = NV4_RENDERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceZBufferBitDepth           = NV4_ZBUFFERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxBufferSize                   = NV4_MAXBUFFERSIZE;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxVertexCount                  = NV4_MAXVERTEXCOUNT;

        // D3DHAL_D3DEXTENDEDCAPS

        memset (&(getDC()->nvD3DDevCaps.d3dExtCaps), 0, sizeof(D3DHAL_D3DEXTENDEDCAPS));

        getDC()->nvD3DDevCaps.d3dExtCaps.dwSize                         = 0;  // to be set later in getDriverInfo
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureWidth              = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureWidth              = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureHeight             = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureHeight             = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureRepeat             = NV4_CAPS_MAX_TEXTURE_REPEAT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureAspectRatio        = NV4_CAPS_MAX_TEXTURE_ASPECT_RATIO;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxAnisotropy                = NV4_CAPS_MAX_ANISOTROPY;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandLeft                = NV4_CAPS_GUARD_BAND_LEFT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandTop                 = NV4_CAPS_GUARD_BAND_TOP;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandRight               = NV4_CAPS_GUARD_BAND_RIGHT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandBottom              = NV4_CAPS_GUARD_BAND_BOTTOM;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvExtentsAdjust                = NV4_CAPS_EXTENTS_ADJUST;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwStencilCaps                  = NV4_CAPS_STENCILOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwFVFCaps                      = NV4_CAPS_FVF_CAPS
                                                                            | D3DFVFCAPS_DONOTSTRIPELEMENTS; // bdw: leave here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwTextureOpCaps                = NV4_CAPS_TEXTUREOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxTextureBlendStages         = NV4_CAPS_MAX_TEXTURE_BLEND_STATES;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxSimultaneousTextures       = NV4_CAPS_MAX_SIMULTANEOUS_TEXTURES;

        // BUBGUG still need some data here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxActiveLights              = NV4_CAPS_MAX_ACTIVE_LIGHTS;
        // getDC()->nvD3DDevCaps.d3dExtCaps.dvMaxVertexW                = ??;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxUserClipPlanes             = NV4_CAPS_MAX_USER_CLIP_PLANES;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxVertexBlendMatrices        = NV4_CAPS_MAX_VERTEX_BLEND_MATRICES;
#ifndef WINNT
        getDC()->nvD3DDevCaps.d3dExtCaps.dwVertexProcessingCaps         = NV4_CAPS_VTXPCAPS;
#endif // WINNT

    }

    else {

        // unhandled hardware
        DPF ("unknown hardware in nvSetHardwareCaps");
        dbgD3DError();

    }

    dbgTracePop();
}

#endif // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvblockmanager.cpp ===
/*
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvBlockManager.cpp                                                *
*   block management/caching/renaming                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Franck Diard/Michael Conrad  21Feb2001  rel20 development            *
*                                                                           *
\***************************************************************************/



#include "nvprecomp.h"

#ifdef MCFD

static CBlockManager g_BM; 
#ifdef DEBUG
BOOL g_renamingEnabled=FALSE;
#endif

// to be relocated

inline DWORD nvGetOffsetFromLinear(DWORD dwLinearAddress)
{
    NV_CFGEX_GET_AGP_OFFSET_PARAMS addr;
    
    addr.linaddr = (void*)dwLinearAddress;
    NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_AGP_OFFSET, &addr, sizeof(addr));
    return addr.offset;
}








/////////////////////////// this code if very preliminary
///////////////m_gpuLocked is used for symmetry checking,
/// it does not mean at alll that the GPU is using something (IsBusy() does)

//// exported function:

BOOL GarbageCollect(DWORD Heap)
{
    return(g_BM.GarbageCollect(Heap));
}

////////////////



void  CVertexBuffer::LockForGPU(DWORD dwAccess)
{   
    m_blockList.LockForGPU(dwAccess);
}

void  CVertexBuffer::UnlockForGPU(void)                      
{    
    m_blockList.UnlockForGPU();
}

void  CVertexBuffer::LockForCPU(DWORD dwAccess, DWORD RenamingPolicy)            
{
    m_blockList.LockForCPU(dwAccess, RenamingPolicy);
    
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvglSetNv20KelvinInvalidateVertexCache (NV_DD_KELVIN);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);
    }
}

void  CVertexBuffer::UnlockForCPU(void)
{
    m_blockList.UnlockForCPU();
}

BOOL  CVertexBuffer::create(DWORD dwSize, DWORD dwAllowedHeaps, DWORD dwPreferredHeap)
{   
    BOOL bCreated=g_BM.CreateBlock(&m_blockList, dwSize, 1, 1, 1, dwAllowedHeaps, dwPreferredHeap, 0);
    
    return (bCreated);
}


BOOL  CVertexBuffer::destroy(void)                      
{   
    destroySuperTriLookAsideBuffer();

    g_BM.FreeList(&m_blockList);
    memset(&m_blockList, 0, sizeof(CBlockList));

    return(TRUE);
}


void  CVertexBuffer::own(DWORD dwAddress, DWORD dwSize, DWORD dwHeapLocation)
{
    BOOL bOwned=g_BM.OwnBlock(&m_blockList, dwAddress, dwSize, 1, dwHeapLocation, FALSE);       // equivalent to Create
}

void  CVertexBuffer::disown(void)
{
    BOOL bDisowned=g_BM.DisownBlock(&m_blockList);
}

void  CVertexBuffer::tagRenameEnable(DWORD dwRenameType, DWORD dwPreAllocCount)
{
    m_blockList.enableRenaming();
} 


DWORD  CVertexBuffer::getAddress()
{ 
    return m_blockList.m_pActive->getAddress(); 
}

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////


BOOL CBlockDescriptor::IsBusy() 
{
    dbgTracePush ("CSimpleSurface::isBusy");
    
    if (m_dwRetireDate)
    {
        
        // check shadow
        if (getDC()->pRefCount->readShadow() >= m_dwRetireDate) {
            dbgTracePop();
            return FALSE;
        }
        
        // read HW and recheck
        if (getDC()->pRefCount->read() >= m_dwRetireDate) {
            dbgTracePop();
            return FALSE;
        }
        
        return TRUE;

    }
    else                // that means that gpulock has not been called, so that's not busy
    {
        dbgTracePop();
        return FALSE;
    }
}


/////////////////////////////////// block list helpers

void  CBlockList::LockForGPU(DWORD dwAccess)                // aka hwlock
{   
    nvAssert(m_pActive); 
    nvAssert(dwAccess);
    nvAssert(!m_gpuLocked);
    nvAssert(m_bOwnMemory);
    
    dbgTracePush ("CBlockList::LockForGPU");
    
    m_gpuLocked=dwAccess;
    
    dbgTracePop();
    
}

void  CBlockList::UnlockForGPU(void)                        // aka hwunlock            
{   
    
    dbgTracePush ("CBlockList::UnlockForGPU");
    // write reference count into push buffer and keep
    //  the value. HW has to reach this point before CPU can
    //  get lock access
    
    //added a check for surfaces that the HW could actually touch
    //should we actually check each surface instead of calling HWUnlock?
    //HMH
    
    nvAssert(m_pActive);
    nvAssert(m_gpuLocked);
    nvAssert(m_bOwnMemory);
    
    if (m_pActive->hwCanRead() || m_pActive->hwCanWrite()) 
    {
        m_pActive->m_dwRetireDate = getDC()->pRefCount->inc (CReferenceCount::INC_LAZY);
    }
    
    m_gpuLocked=0;
    
    dbgTracePop();
}


void CBlockList::LockForCPU(DWORD dwAccess, DWORD dwRenamingCopyPolicy)  // renaming can allow different size
{
    nvAssert(dwAccess);
    nvAssert(m_pActive);
    nvAssert(!m_cpuLocked);
    nvAssert(!m_gpuLocked);
    
    
    m_cpuLocked=dwAccess;
    
    DDSTARTTICK(SURF7_SPINLOCK);
    dbgTracePush ("CBlockList::LockForCPU");
    
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        // if the channel's been destroyed, then everything is retired by definition
        DDENDTICK(SURF7_SPINLOCK);
        dbgTracePop();
        return;
    }
    
    // this is needed to prevent hangs when returning from a full-screen DOS box
    // waiting for a notifier with the FIFO in this state guarantees a hang
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        DPF("CSimpleSurface::destroy: Early exit due to DosOccurred flag");
        dbgTracePop();
        DDENDTICK(SURF7_SPINLOCK);
        return;
    }
    
    if ((dwAccess==CSimpleSurface::LOCK_WRITE))
    {
        if (m_pActive->IsBusy())
        {
            if (m_renaming 
                //&& (m_dwNb <=m_dwMax) 
#ifdef DEBUG
                && g_renamingEnabled
#endif
                )
            {
                Rename(dwRenamingCopyPolicy);      // with copy or not
            }
            else
            {
                getDC()->pRefCount->wait (CReferenceCount::WAIT_PREEMPTIVE, m_pActive->m_dwRetireDate);
                m_pActive->m_dwRetireDate=0;
            }
        }
    }
    
    dbgTracePop();
    DDENDTICK(SURF7_SPINLOCK);
}

void  CBlockList::UnlockForCPU(void)
{
    // nothing to be done, just a symmetric
    dbgTracePush ("CBlockList::UnlockForCPU");
    
    nvAssert(m_pActive);
    nvAssert(m_cpuLocked);
    nvAssert(!m_gpuLocked);
    
    m_cpuLocked=0;
    dbgTracePop();
}


//////////////// Rename should check if some memory is available


BOOL CBlockList::Rename(DWORD dwRenamingCopyPolicy)  // renaming can allow different size
{
    CBlockDescriptor * pNext;
    CBlockDescriptor * pSave;
    BOOL bCreate=FALSE;
    
    nvAssert(m_pActive);
    
    pSave=m_pActive;
    
    if (m_dwNb==1)       //   if we are here, the acitive was busy, so we need to create a new one
        bCreate=TRUE;
    else
    { 
        pNext=m_pActive->m_pNextRenamed;
        
        if (pNext->IsBusy())    // if it is busy, no need to continue
            bCreate=TRUE;
        else
        {
            m_pActive=pNext;
            m_pActive->m_dwRetireDate=0;
            
            if (dwRenamingCopyPolicy==RENAME_POLICY_COPY)
                nvMemCopy((void *)m_pActive->getAddress(), (void *)pSave->getAddress(), m_pActive->getSize());
            
            return(TRUE);
        }
    }
    if (bCreate)
    {
        g_BM.CreateBlock(this,  m_pActive->m_dwPitch, m_pActive->m_dwHeight,        // will set the active to the new one
            m_pActive->m_dwDepth, m_dwBPPGranted, 
            m_dwAllowedHeaps, m_dwPreferredHeap, m_pActive->m_dwAllocFlags);
        
        if (dwRenamingCopyPolicy==RENAME_POLICY_COPY)
            nvMemCopy((void *)m_pActive->getAddress(), (void *)pSave->getAddress(), m_pActive->getSize());
        
    }
    return(TRUE);
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////

CBlockManager::CBlockManager()
{
    memset(this, 0, sizeof(CBlockManager));
    
}

BOOL CBlockManager::GarbageCollect(DWORD dwHeap)
{
    DWORD dwDevice=0;
    
    switch (dwHeap)
    {
        
    case CSimpleSurface::HEAP_VID:
        {
            break;
        }
    case CSimpleSurface::HEAP_AGP:
        {
            break;
        }
    case CSimpleSurface::HEAP_PCI:
        {
            break;
        }
    case CSimpleSurface::HEAP_SYS:
        {
            break;
        }
    default:
        nvAssert(0);
        break;
    }    
    return(TRUE);
}

BOOL CBlockManager::FreeList(CBlockList * BlockList)
{
    return(TRUE);
}

BOOL CBlockManager::AddToCachedBlockList(CBlockDescriptor * ToAdd)
{
    
    DWORD dwDevice=0;           // see later
    
    switch (ToAdd->m_dwHeap)
    {
        
    case CSimpleSurface::HEAP_VID:
        {
            ToAdd->m_pNextGlobal=m_apVIDFirst[dwDevice];
            m_apVIDFirst[dwDevice]=ToAdd;
            break;
        }
    case CSimpleSurface::HEAP_AGP:
        {
            ToAdd->m_pNextGlobal=m_pAGPFirst;
            m_pAGPFirst=ToAdd;
            break;
        }
    case CSimpleSurface::HEAP_PCI:
        {
            ToAdd->m_pNextGlobal=m_pPCIFirst;
            m_pPCIFirst=ToAdd;
            break;
        }
    case CSimpleSurface::HEAP_SYS:
        {
            ToAdd->m_pNextGlobal=m_pSYSFirst;
            m_pSYSFirst=ToAdd;
            break;
        }
    default:
        nvAssert(0);
        break;
    }
    
    m_dwCachedBlocks++;
    
    return(TRUE);
}


//adds a block right after the active one
BOOL CBlockManager::RegisterBlock(CBlockList * BlockList, CBlockDescriptor * ToAdd)
{
    //private list
    
    if (BlockList->m_pActive) 
    {
        ToAdd->m_pNextRenamed=BlockList->m_pActive->m_pNextRenamed;    //forward link
        BlockList->m_pActive->m_pNextRenamed=ToAdd;
        
        ToAdd->m_pPreviousRenamed=BlockList->m_pActive->m_pPreviousRenamed;    //backward link
        BlockList->m_pActive->m_pPreviousRenamed=ToAdd;
    }
    else
    {
        ToAdd->m_pNextRenamed=ToAdd;        // yes it points to itself
        ToAdd->m_pPreviousRenamed=ToAdd;        // yes it points to itself
    }
    
    BlockList->m_pActive=ToAdd;
    BlockList->m_dwNb++;
    
    
    DWORD dwDevice=0;           // see later
    
    //memory accounting and sorting
    
    switch (ToAdd->m_dwHeap)
    {
    case CSimpleSurface::HEAP_VID:
        {
            m_dwAllocatedVIDMemory+=ToAdd->m_dwSize;
            m_adwAllocatedVIDMemoryPerDevice[dwDevice]+=ToAdd->m_dwSize;
            
            ToAdd->m_pNextGlobal=m_apVIDFirst[dwDevice];
            m_apVIDFirst[dwDevice]=ToAdd;
            
            break;
        }
    case CSimpleSurface::HEAP_AGP:
        {
            m_dwAllocatedAGPMemory+=ToAdd->m_dwSize;
            
            ToAdd->m_pNextGlobal=m_pAGPFirst;
            m_pAGPFirst=ToAdd;
            
            break;
        }
    case CSimpleSurface::HEAP_PCI:
        {
            m_dwAllocatedPCIMemory+=ToAdd->m_dwSize;
            
            ToAdd->m_pNextGlobal=m_pPCIFirst;
            m_pPCIFirst=ToAdd;
            
            break;
        }
    case CSimpleSurface::HEAP_SYS:
        {
            m_dwAllocatedSYSMemory+=ToAdd->m_dwSize;
            
            ToAdd->m_pNextGlobal=m_pSYSFirst;
            m_pSYSFirst=ToAdd;
            
            break;
        }
    default:
        nvAssert(0);
        break;
    }
    
    ToAdd->m_pOwner=BlockList;
    
    m_dwActiveBlocks++;
    
    return(TRUE);
}


BOOL CBlockManager::CreateBlock(
                                CBlockList * BlockList,
                                DWORD dwPitch,
                                DWORD dwHeight,
                                DWORD dwDepth,
                                DWORD dwBPPGranted,
                                DWORD dwAllowedHeaps,
                                DWORD dwPreferredHeap,
                                DWORD dwAllocFlags
                                )
{
    
    CBlockDescriptor * NewBlockDesc= new CBlockDescriptor;
    
    BlockList->m_bOwnMemory=TRUE;

    if (AllocateBlock(NewBlockDesc, dwPitch, dwHeight, dwDepth, dwBPPGranted, dwAllowedHeaps, dwPreferredHeap, dwAllocFlags))
    {        
        if (RegisterBlock(BlockList, NewBlockDesc))
        {
            BlockList->m_dwAllowedHeaps=dwAllowedHeaps;             // to create new ones 
            BlockList->m_dwPreferredHeap=dwPreferredHeap;
            BlockList->m_dwBPPGranted=1;
            return(TRUE);           // ideal code path
        }
    }
    else
    {
        nvAssert(0);
    }
    
    delete NewBlockDesc;
    return(FALSE);
    
}

BOOL CBlockManager::OwnBlock(   CBlockList * BlockList,

    DWORD dwAddress,
    DWORD dwPitch,
    DWORD dwHeight,
    DWORD dwHeapLocation,
    BOOL  bOwnMemory )

{

    nvAssert(!bOwnMemory);

    BlockList->m_bOwnMemory=FALSE;

    // tell world
    dbgTracePush ("CBlockManager::OwnBlock[%08x]::own(dwAddress=%08x,dwPitch=%08x,dwH=%08x,dwHeapLoc=%x,bOwnMem=%d)",
                  this, dwAddress, dwPitch, dwHeight, dwHeapLocation, bOwnMemory);
    if (BlockList->m_dwNb)          
        nvAssert(0);             // oula! should reuse the blocklist to own a block
    
    CBlockDescriptor * NewBlockDesc= new CBlockDescriptor;
    
    // assign
    NewBlockDesc->m_dwAddress    = dwAddress;
    NewBlockDesc->m_dwPitch      = dwPitch;
    NewBlockDesc->m_dwHeight     = dwHeight;
    NewBlockDesc->m_dwFlags     &= ~CSimpleSurface::HEAP_LOCATION_MASK;
    NewBlockDesc->m_dwFlags     |= dwHeapLocation;

    NewBlockDesc->m_dwFlags |= CSimpleSurface::FLAG_DONOTOWNMEMORY;

    switch (NewBlockDesc->getHeapLocation())
    {
        case CSimpleSurface::HEAP_VID:
            NewBlockDesc->m_dwOffset = NewBlockDesc->m_dwAddress - VIDMEM_ADDR(pDriverData->BaseAddress);
            break;
        case CSimpleSurface::HEAP_AGP:
#ifdef NV_AGP
            NewBlockDesc->m_dwOffset = nvGetOffsetFromLinear(NewBlockDesc->m_dwAddress);
            DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "CSimpleSurface::Own: offset of AGP address %08x is %08x", NewBlockDesc->m_dwAddress, NewBlockDesc->m_dwOffset);
#else
            NewBlockDesc->m_dwOffset = AGPMEM_OFFSET(m_dwAddress);
#endif
            break;
        case CSimpleSurface::HEAP_PCI:
#ifdef WINNT // WINNT Temp Hack
        if (!getDC()->nvD3DTexHeapData.dwBase)
            NewBlockDesc->m_dwOffset = NewBlockDesc->m_dwAddress - getDC()->nvPusher.getBase();
        else
#endif // WINNT Temp Hack
            NewBlockDesc->m_dwOffset = NewBlockDesc->m_dwAddress - getDC()->nvD3DTexHeapData.dwBase;
            break;
        case CSimpleSurface::HEAP_SYS:
            NewBlockDesc->m_dwOffset = NewBlockDesc->m_dwAddress;
            break;
        default:
            DPF ("unknown context");
            dbgD3DError();
            break;
    }

    BlockList->m_pActive=NewBlockDesc;             // make it active
    BlockList->m_dwNb++;

    dbgTracePop();
    return(TRUE);           // ideal code path
}


BOOL CBlockManager::DisownBlock( CBlockList * BlockList)
{
    dbgTracePush ("CSimpleSurface[%08x]::disown()",this);

    nvAssert(0);        // should not happen now

    dbgTracePop();

    return(TRUE);
}


BOOL CBlockManager::AllocateBlock
(
 CBlockDescriptor * BlockDesc,
 DWORD dwPitch,
 DWORD dwHeight,
 DWORD dwDepth,
 DWORD dwBPPGranted,
 DWORD dwAllowedHeaps,
 DWORD dwPreferredHeap,
 DWORD dwAllocFlags
 )
{
#ifdef DEBUG
    // just so we can see what was asked for when debugging
    DWORD dwOriginalAllowedHeaps  = dwAllowedHeaps;
    DWORD dwOriginalPreferredHeap = dwPreferredHeap;
#endif
    
    // tell world
    dbgTracePush ("CBlockManager::CreateBlock[%08x]::create(dwPitch=%08x,dwHt=%08x,dwDp=%08x,dwAllHeaps=%x,dwPrefHeap=%x,dwFlags=%x)",
        this, dwPitch, dwHeight, dwDepth, dwAllowedHeaps, dwPreferredHeap, dwAllocFlags);
    
    
    DWORD dwSize = dwPitch * dwHeight * dwDepth;

    // Allow for a possible ZERO sized surface
    if (!dwSize) {
        // complain
        DPF ("CSimpleSurface::create: dwSize == 0");
        dbgD3DError();
        // tag surface as invalid
        BlockDesc->m_dwAddress = 0;
        dbgTracePop();
        return (FALSE);
    }
    
    // retire surface (since it is about to exist)
    BlockDesc->m_dwRetireDate = 0;
    
    // no specific preference would start with video memory
    if (dwPreferredHeap == CSimpleSurface::HEAP_NOWHERE) {
        dwPreferredHeap = CSimpleSurface::HEAP_VID;
    }
    
    // if we require tiled memory - override to only allow vid heap
    if (dwAllocFlags & CSimpleSurface::ALLOCATE_TILED) {
        dwAllowedHeaps  = CSimpleSurface::HEAP_VID;
        dwPreferredHeap = CSimpleSurface::HEAP_VID;
    }
    
    // suppress video memory allocation all together if it is overidden
    //  by the registy
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_VIDEOTEXTUREENABLE_MASK) == D3D_REG_VIDEOTEXTUREENABLE_DISABLE)
    {
        dwAllowedHeaps &= ~CSimpleSurface::HEAP_VID;
        if (!dwAllowedHeaps) dwAllowedHeaps = CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_PCI;
    }
    
    BlockDesc->m_dwAllocFlags = dwAllocFlags;
    
    // try to allocate in all allowed memory heaps
    while (dwAllowedHeaps)
    {
        // video
        if (dwAllowedHeaps & dwPreferredHeap & CSimpleSurface::HEAP_VID)
        {
            DWORD dwStatus, dwType;
            
            if (dwAllocFlags & CSimpleSurface::ALLOCATE_TILED)
            {
                dwType = (dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC) ?TYPE_DEPTH :
                        ((dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP) ?
                    ((dwBPPGranted == 2) ? TYPE_DEPTH_COMPR16 : TYPE_DEPTH_COMPR32) : TYPE_IMAGE);
#ifdef WINNT
                NVHEAP_ALLOC_TILED (dwStatus, BlockDesc->m_dwOffset, dwPitch, dwHeight, dwType);
                BlockDesc->m_dwAddress = VIDMEM_ADDR(BlockDesc->m_dwOffset);
#else  // !WINNT
                NVHEAP_ALLOC_TILED (dwStatus, BlockDesc->m_dwAddress, dwPitch, dwHeight, dwType);
#endif // !WINNT
#ifdef DEBUG_SURFACE_PLACEMENT
                m_dwRMAllocFlags = dwType;
#endif
                nvAssert (dwStatus == 0);
            }
            
            else
            {
                dwType = (dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC) ? TYPE_DEPTH :
                        ((dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP) ? ((dwBPPGranted == 2) ?
                        TYPE_DEPTH_COMPR16 : TYPE_DEPTH_COMPR32) : TYPE_TEXTURE);
#ifdef WINNT
                NVHEAP_ALLOC (dwStatus, BlockDesc->m_dwOffset, dwSize, dwType);
                BlockDesc->m_dwAddress = VIDMEM_ADDR(BlockDesc->m_dwOffset);
#else
                NVHEAP_ALLOC (dwStatus, BlockDesc->m_dwAddress, dwSize, dwType);
#endif // WINNT
#ifdef DEBUG_SURFACE_PLACEMENT
                m_dwRMAllocFlags = dwType;
#endif
            }
            
            if (dwStatus == 0) {
                
                // increment count of video memory surfaces allocated.
                pDriverData->DDrawVideoSurfaceCount++;
                BlockDesc->m_dwPitch     = dwPitch;
                BlockDesc->m_dwHeight    = dwHeight;
                BlockDesc->m_dwDepth     = dwDepth;
#ifndef WINNT
                BlockDesc->m_dwOffset    = BlockDesc->m_dwAddress - pDriverData->BaseAddress;
#endif // WINNT
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::HEAP_LOCATION_MASK;
                BlockDesc->m_dwFlags    |= CSimpleSurface::HEAP_VID;
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::FLAG_TILED;
                BlockDesc->m_dwFlags    |= (dwAllocFlags & CSimpleSurface::ALLOCATE_TILED)      ? CSimpleSurface::FLAG_TILED   : 0;
                BlockDesc->m_dwFlags    |= (dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER) ? CSimpleSurface::FLAG_ZBUFFER : 0;
                
#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Vid Surface Alloc: Address:%08x Size:%08x\n", BlockDesc->m_dwAddress,dwSize);
#endif
                
#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_SURFACE_ALLOC surf;
                    surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                    surf.dwCtxDMAHandle       = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
                    surf.dwOffset             = m_dwOffset;
                    surf.dwSize               = getSize();
                    surf.dwAlignment          = 0;
                    surf.dwType               = (dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER) ? CAPTURE_SURFACE_TYPE_ZETA : CAPTURE_SURFACE_TYPE_NORMAL;
                    surf.dwKind               = dwUsageKind;
                    surf.dwSurfaceType        = getFormat();
                    surf.dwIntendedPitch      = dwPitch;
                    surf.dwIntendedHeight     = dwHeight;
                    captureLog (&surf,sizeof(surf));
                }
#endif
                
                BlockDesc->m_dwHeap=CSimpleSurface::HEAP_VID;
                BlockDesc->m_dwSize=dwSize;
                
                dbgTracePop();
                
                return (TRUE);
            }
            
#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Vid Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            // fail - don't try again
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in VID failed");
            dwAllowedHeaps &= ~CSimpleSurface::HEAP_VID;
        }
        
        // agp
        if (dwAllowedHeaps & dwPreferredHeap & CSimpleSurface::HEAP_AGP)
        {
            if (pDriverData->GARTLinearBase)
            {
                // On AGP, allocate call DDRAW to allocate the AGP memory.
                BlockDesc->m_dwAddress = (DWORD)nvAGPAlloc(dwSize);
                if (BlockDesc->m_dwAddress != ERR_DXALLOC_FAILED)
                {
#ifdef NV_AGP
                    BlockDesc->m_dwOffset   = nvGetOffsetFromLinear(BlockDesc->m_dwAddress);
                    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "CSimpleSurface::Create: offset of AGP address %08x is %08x", BlockDesc->m_dwAddress, BlockDesc->m_dwOffset);
#else
                    // at this point m_dwAddress is actually an offset
                    BlockDesc->m_dwAddress  = AGPMEM_ADDR(BlockDesc->m_dwAddress);
                    BlockDesc->m_dwOffset   = AGPMEM_OFFSET(BlockDesc->m_dwAddress);
#endif
                    BlockDesc->m_dwPitch    = dwPitch;
                    BlockDesc->m_dwHeight   = dwHeight;
                    BlockDesc->m_dwDepth    = dwDepth;
                    BlockDesc->m_dwFlags   &= ~CSimpleSurface::HEAP_LOCATION_MASK;
                    BlockDesc->m_dwFlags   |= CSimpleSurface::HEAP_AGP;
                    BlockDesc->m_dwFlags   &= ~CSimpleSurface::FLAG_TILED;
#ifdef DEBUG
                    DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"AGP Surface Alloc: Address:%08x Size:%08x\n",BlockDesc->m_dwAddress,dwSize);
#endif
                    
#ifdef CAPTURE
                    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                        CAPTURE_SURFACE_ALLOC surf;
                        surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                        surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                        surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                        surf.dwCtxDMAHandle       = D3D_CONTEXT_DMA_HOST_MEMORY;
                        surf.dwOffset             = m_dwOffset;
                        surf.dwSize               = getSize();
                        surf.dwAlignment          = 0;
                        surf.dwType               = CAPTURE_SURFACE_TYPE_NORMAL;
                        surf.dwKind               = dwUsageKind;
                        surf.dwSurfaceType        = getFormat();
                        surf.dwIntendedPitch      = dwPitch;
                        surf.dwIntendedHeight     = dwHeight;
                        captureLog (&surf,sizeof(surf));
                    }
#endif
                    
                    BlockDesc->m_dwHeap=CSimpleSurface::HEAP_AGP;
                    BlockDesc->m_dwSize=dwSize;
                    
                    dbgTracePop();
                    
                    return (TRUE);
                }
            }
            // fail - don't try again
#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"AGP Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in AGP failed");
            dwAllowedHeaps &= ~CSimpleSurface::HEAP_AGP;
        }
        
        // pci
        if (dwAllowedHeaps & dwPreferredHeap & CSimpleSurface::HEAP_PCI)
        {
            DWORD dwOffset;
            
            // On PCI, allocate from our internal texture heap.
            dwOffset = nvPCIAlloc(dwSize);
            if (dwOffset)
            {
                BlockDesc->m_dwPitch     = dwPitch;
                BlockDesc->m_dwHeight    = dwHeight;
                BlockDesc->m_dwDepth     = dwDepth;
                BlockDesc->m_dwOffset    = dwOffset;
                BlockDesc->m_dwAddress   = getDC()->nvD3DTexHeapData.dwBase + dwOffset;
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::HEAP_LOCATION_MASK;
                BlockDesc->m_dwFlags    |= CSimpleSurface::HEAP_PCI;
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::FLAG_TILED;
                
#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"PCI Surface Alloc: Address:%08x Size:%08x\n", BlockDesc->m_dwAddress,dwSize);
#endif
                
#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_SURFACE_ALLOC surf;
                    surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                    surf.dwCtxDMAHandle       = D3D_CONTEXT_DMA_HOST_MEMORY;
                    surf.dwOffset             = m_dwOffset;
                    surf.dwSize               = getSize();
                    surf.dwAlignment          = 0;
                    surf.dwType               = CAPTURE_SURFACE_TYPE_NORMAL;
                    surf.dwKind               = dwUsageKind;
                    surf.dwSurfaceType        = getFormat();
                    surf.dwIntendedPitch      = dwPitch;
                    surf.dwIntendedHeight     = dwHeight;
                    captureLog (&surf,sizeof(surf));
                }
#endif
                
                BlockDesc->m_dwHeap=CSimpleSurface::HEAP_PCI;
                BlockDesc->m_dwSize=dwSize;
                
                dbgTracePop();
                
                return (TRUE);
            }
            
#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"PCI Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            
            // fail - don't try again
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in PCI failed");
            dwAllowedHeaps &= ~CSimpleSurface::HEAP_PCI;
        }
        
        // system memory
        if (dwAllowedHeaps & dwPreferredHeap & CSimpleSurface::HEAP_SYS)
        {
#ifdef WINNT
            nvAssert(0);            // we should use this call to allcoate heap memory with win2k
#endif
            // For system memory, allocate from global heap.
            // m_dwOffset keeps the original ptr while
            // m_dwAddress keeps the aligned ptr
            
            
            BlockDesc->m_dwOffset = (DWORD) AllocIPM (dwSize);
            nvAssert (((BlockDesc->m_dwOffset + 31) & ~31) == BlockDesc->m_dwOffset);
            
            if (BlockDesc->m_dwOffset)
            {
                BlockDesc->m_dwPitch     = dwPitch;
                BlockDesc->m_dwHeight    = dwHeight;
                BlockDesc->m_dwDepth     = dwDepth;
                BlockDesc->m_dwAddress   = (BlockDesc->m_dwOffset + 31) & ~31;
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::HEAP_LOCATION_MASK;
                BlockDesc->m_dwFlags    |= CSimpleSurface::HEAP_SYS;
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::FLAG_TILED;
                
#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Alloc: Address:%08x Size:%08x\n", BlockDesc->m_dwAddress,dwSize);
#endif
                
                BlockDesc->m_dwHeap=CSimpleSurface::HEAP_SYS;
                BlockDesc->m_dwSize=dwSize;
                
                dbgTracePop();
                
                return (TRUE);
            }
            
            // fail - don't try again
#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in SYS failed");
            dwAllowedHeaps &= ~CSimpleSurface::HEAP_SYS;
        }
        
        // next
        dwPreferredHeap = (dwPreferredHeap << 1) & CSimpleSurface::HEAP_ANYWHERE;
        if (!dwPreferredHeap) dwPreferredHeap = CSimpleSurface::HEAP_VID;
    }
    
    // not allocated
    //  tag as invalid and fail
    DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface Not allocated");
    BlockDesc->m_dwAddress = 0;
    dbgTracePop();
    return (FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvClear.cpp ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvClear.cpp                                                       *
*   NV4 Buffer Clear routines.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/18/98 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//---------------------------------------------------------------------------

void nvSetClearSurface
(
    DWORD   dwDstOffset,
    DWORD   dwDstPitch,
    DWORD   dwDstFormat,
    DWORD   dwRectFormat,
    DWORD   dwFillValue
)
{
    //DWORD size;

    /*
     * Set the destination surface to be cleared.
     */
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
        //fortunately the NV05E (SOLID_RECTANGLE) surface formats are identical to the
        //NV04A (GDI_RECTANGLE_TEXT) surface formats so they don't need to be remapped here.
        //this is a rather a casual assumption -- if these formats change for NV20 we may
        // need to do modification mapping one to the other.
//        size = sizeSetObject + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat +
//               sizeSet2DSurfacesPitch + sizeSetNv4GDIRectangleTextColorFormat + sizeNv4GDIRectangleTextColorFormat;
        nvglSet2DSurfacesDestination(NV_DD_SURFACES, dwDstOffset);
        nvglSet2DSurfacesColorFormat(NV_DD_SURFACES, dwDstFormat);
        nvglSet2DSurfacesPitch(NV_DD_SURFACES, dwDstPitch, dwDstPitch);
        nvglSetObject(NV_DD_SPARE, D3D_GDI_RECTANGLE_TEXT);
        nvglDrawRopRectAndTextSetColorFormat(NV_DD_SPARE, dwRectFormat);
        nvglDrawRopRectAndTextColor1A(NV_DD_SPARE, dwFillValue);
        pDriverData->dDrawSpareSubchannelObject = D3D_GDI_RECTANGLE_TEXT;
    }
    else{
//        size = sizeSetObject + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat +
//               sizeSet2DSurfacesPitch + sizeSetNv4SolidRectangleColorFormat + sizeNv4SolidRectangleColor;
        nvglSet2DSurfacesDestination(NV_DD_SURFACES, dwDstOffset);
        nvglSet2DSurfacesColorFormat(NV_DD_SURFACES, dwDstFormat);
        nvglSet2DSurfacesPitch(NV_DD_SURFACES, dwDstPitch, dwDstPitch);
        nvglSetObject(NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
        nvglSetNv4SolidRectangleColorFormat(NV_DD_SPARE, dwRectFormat);
        nvglNv4SolidRectangleColor(NV_DD_SPARE, dwFillValue);
        pDriverData->dDrawSpareSubchannelObject = D3D_RENDER_SOLID_RECTANGLE;
    }

}

//---------------------------------------------------------------------------

void nvReset2DSurfaceFormat
(
    void
)
{
    switch (GET_MODE_BPP()) {
    case 8:
        nvglSet2DSurfacesColorFormat(NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_Y8);
        break;
    case 16:
        nvglSet2DSurfacesColorFormat(NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_R5G6B5);
        break;
    default:
        nvglSet2DSurfacesColorFormat(NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
        break;
    }
    return;
}

//---------------------------------------------------------------------------

void nvClearSurfaceRect
(
    DWORD startx,
    DWORD starty,
    DWORD width,
    DWORD height
)
{
    const DWORD dwTetrisWidth = 128;

    /*
     * use tiled (tetris) clear if width >= 1024 and we run nv5 or earlier
     */
    if (width >= 1024)
    {
        /*
         * extract relevant information
         */
        DWORD endx = startx + width;
        DWORD i = 0;

        while (i < endx)
        {
            /*
             * setup band
             */
            DWORD j     = i + dwTetrisWidth;
            DWORD left  = max(i,startx);
            DWORD right = min(j,endx);

            if (right > left)
            {
                /*
                 * Clear the specified rectangle.
                 */
                if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
                    nvglDrawRopRectAndTextPointSize(NV_DD_SPARE, left, starty, (right - left), height);
                }
                else {
                    nvglNv4SolidRectanglePointSize (NV_DD_SPARE, left, starty, (right - left), height);
                }
            }

            /*
             * next
             */
            i = j;
        }

        return;
    }

    /*
     * Clear the specified rectangle.
     */
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
        nvglDrawRopRectAndTextPointSize(NV_DD_SPARE, startx, starty, width, height);
    }
    else {
        nvglNv4SolidRectanglePointSize(NV_DD_SPARE, startx, starty, width, height);
    }
}

//---------------------------------------------------------------------------

// Clear render target and/or zeta-buffer. No explicit support for stencil.

DWORD __stdcall nvClear
(
    LPD3DHAL_CLEARDATA  pcd
)
{
    DWORD dwDstOffset, dwDstPitch;
    DWORD dwRTRectColorFormat, dwRTSurfColorFormat;
    DWORD dwZBRectColorFormat, dwZBSurfColorFormat;

    dbgTracePush ("nvClear");

#ifdef NV_NULL_HW_DRIVER
    pcd->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
#endif

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pcd);

    // Get pointer to global driver data structure.
    nvSetDriverDataPtrFromContext (pContext);

    nvSetD3DSurfaceState (pContext);


    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pContext->pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }

    if ((!pContext->pRenderTarget) || (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED))
    {
        pcd->ddrval = DD_OK;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    DDSTARTTICK(DEVICE_CLEARRENDERZ);

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            pcd->ddrval = DD_OK;
            DDENDTICK(DEVICE_CLEARRENDERZ);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

#if (NVARCH >= 0x010)
    // Create AA buffers if needed
    pContext->aa.Create(pContext);
#endif  // NVARCH >= 0x010

    // Get the format of the renter target being cleared
    if (pContext->pRenderTarget->getBPP() == 2) {
        dwRTRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
        dwRTSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
    }
    else {
        // 32-bit
        dwRTRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
        dwRTSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
    }

    if (pContext->pZetaBuffer) {
        // Get the format of the zeta buffer being cleared
        if (pContext->pZetaBuffer->getBPP() == 2) {
            dwZBRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
            dwZBSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
        }
        else {
            // 32-bit
            dwZBRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
            dwZBSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
        }
    }

    CNvObject *pNvObj = pContext->pZetaBuffer ? pContext->pZetaBuffer->getWrapper() : NULL;
    if (pNvObj)
    {
#ifdef ALTERNATE_STENCIL_MODE
        if ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE) &&
            (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_ALT_STENCIL) &&
            (pcd->dwFlags & D3DCLEAR_ZBUFFER)) {

            if (pContext->pZetaBuffer->getBPP() == 2) pNvObj->tagAltStencilBadSemantics();

            if (pNvObj->hasAltStencilBadSemantics()) {
                pNvObj->tagAltStencilDisabled();
            } else {
                pNvObj->disableCT();
                pNvObj->tagAltStencilEnabled();
            }

            DWORD dwOldClearCount = pContext->dwTotalClearCount;

            pContext->dwTotalClearCount = (pContext->dwTotalClearCount+1) % 256;

            pContext->hwState.celsius.set (NV056_SET_STENCIL_TEST_ENABLE, NV056_SET_STENCIL_TEST_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC,        NV056_SET_STENCIL_FUNC_V_NOTEQUAL);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC_MASK,   0xff);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_MASK,        0xff);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_FAIL,     NV056_SET_STENCIL_OP_FAIL_V_KEEP);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_ZFAIL,    NV056_SET_STENCIL_OP_FAIL_V_REPLACE);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_ZPASS,    NV056_SET_STENCIL_OP_FAIL_V_REPLACE);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC_REF,    dwOldClearCount);

            *(volatile int *)(pDriverData->NvBaseFlat+0x400088) |= 0x40000000;

            if (dwOldClearCount == 0) {
                pcd->dwFlags |= D3DCLEAR_STENCIL;
                pcd->dwFillDepth &= 0xffffff00;
            } else {
                pcd->dwFlags &= ~D3DCLEAR_ZBUFFER;
            }
        } else
#endif
        if ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
             && (((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CONTROL_TRAFFIC_16) && (dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16))
             || ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CONTROL_TRAFFIC_32) && (dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y32))))
        {
            BOOL bOK = TRUE;
            if (pContext->dwDXAppVersion >= 0x0700) {
                bOK = (dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y32)
                   || ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CT_11M) && (pContext->dwEarlyCopyStrategy > 3))
                   || ((pContext->pRenderTarget->getBPP() == 4) && (dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16) && (pContext->dwEarlyCopyStrategy > 3));
            }
            else
            {
                // DX6 or earlier apps - disable CT when using 16 bit z
                bOK = ((dwZBSurfColorFormat != NV042_SET_COLOR_FORMAT_LE_Y16)
                        || ((!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)) && (pContext->dwEarlyCopyStrategy > 0x20)));
            }

            if (((pcd->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET)) == D3DCLEAR_ZBUFFER)
                && (((dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16) && ((pcd->dwFillDepth & 0xffff) == 0xffff)) ||
                    ((dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y32) && ((pcd->dwFillDepth & 0xffffff00) == 0xffffff00)))
                && bOK
                )
            {
                BOOL x = FALSE;

                if (pNvObj->hasCTEnabled())
                {
                    pContext->dwClearCount++;
                    if (pContext->dwClearCount > 1)
                    {
                        pNvObj->tagDblClear();
                    }
                    if (pNvObj->hasBadCTSem())
                    {
                        pNvObj->disableCT();
                    }
                    else
                    {
                        if (pNvObj->isCTDrawPrim())
                        {
                            pNvObj->toggleFrontDrawPrim();
                        }
                        x = TRUE;
                    }
                }
                else
                {
                    if (pNvObj->hasBadCTSem())
                    {
                        pNvObj->disableCT();
                    }
                    else
                    {
                        if (dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
                        {
                            pNvObj->enableCT();
                            if (pcd->dwFillDepth & 0x8000) pNvObj->setCTFront();
                        }
                        else
                        {
                            pNvObj->enableCT();
                            if (pcd->dwFillDepth & 0x80000000) pNvObj->setCTFront();
                        }
                        pNvObj->clearCTDrawPrim();
                        { static int i = 1; if (i) { DPF ("***********************"); i = 0; } }
                    }
                }

#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_KELVIN | NVCLASS_FAMILY_CELSIUS)) {
                    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM  | KELVIN_DIRTY_MISC_STATE;
                    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM | CELSIUS_DIRTY_MISC_STATE;
                }
                else
#endif  // NVARCH >= 0x010
                {
                    NV_FORCE_TRI_SETUP (pContext);
                }

                if (x)
                {
                    pcd->ddrval = DD_OK;
                    DDENDTICK(DEVICE_CLEARRENDERZ);
                    NvReleaseSemaphore(pDriverData);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }
            else
            {
                if (pNvObj->hasCTEnabled())
                {
#if (NVARCH >= 0x010)
                    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_KELVIN | NVCLASS_FAMILY_CELSIUS)) {
                        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM  | KELVIN_DIRTY_MISC_STATE;
                        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM | CELSIUS_DIRTY_MISC_STATE;
                    }
                    else
#endif  // NVARCH >= 0x010
                    {
                        NV_FORCE_TRI_SETUP (pContext);
                    }
                    pNvObj->disableCT();
                }
            }
        }
        else
        {
            pNvObj->disableCT();
            // tri setup forced implicitly
        }
    }



#if (NVARCH >= 0x010)
    if (pContext->aa.isEnabled()) {

        // select large buffer (without magnify)
        nvCelsiusAASelectSuperBuffers (pContext);


        // clear z buffer
        if ((pcd->dwFlags & D3DCLEAR_ZBUFFER) && (pContext->aa.pSuperZetaBuffer))
        {
            DWORD       dwNumRects  = pcd->dwNumRects;
            LPD3DRECT   lpRects     = pcd->lpRects;

            pContext->aa.makeSuperZBValid(pContext);

            DWORD dwFillDepth = pcd->dwFillDepth;
#ifndef STEREO_SUPPORT
            dwDstOffset = pContext->aa.pSuperZetaBuffer->getOffset();
#else   //STEREO_SUPPORT==1
            dwDstOffset = GetStereoOffset(pContext->aa.pSuperZetaBuffer);
#endif  //STEREO_SUPPORT
            dwDstPitch  = pContext->aa.pSuperZetaBuffer->getPitch();

            if (dwNumRects)
            {
                nvSetClearSurface  (dwDstOffset, dwDstPitch, dwZBSurfColorFormat, dwZBRectColorFormat, dwFillDepth);
                while (dwNumRects)
                {
                    DWORD startx, starty;
                    DWORD width, height;

                    /*
                     * Get the next rectangle to clear.
                     */
                    startx = DWORD(0.5f + lpRects->x1 * pContext->aa.fWidthAmplifier);
                    width  = DWORD((lpRects->x2 - lpRects->x1) * pContext->aa.fWidthAmplifier);

                    starty = DWORD(0.5f + lpRects->y1 * pContext->aa.fHeightAmplifier);
                    height = DWORD((lpRects->y2 - lpRects->y1) * pContext->aa.fHeightAmplifier);

                    /*
                     * Use the hardware to do the clear.
                     */
                    nvClearSurfaceRect(startx, starty, width, height);

                    /*
                     * Move to the next rectangle.
                     */
                    lpRects++;
                    dwNumRects--;
                }
            }
        }

        // clear frame buffer
        if ((pcd->dwFlags & D3DCLEAR_TARGET) && (pContext->aa.pSuperRenderTarget))
        {
            DWORD       dwNumRects  = pcd->dwNumRects;
            LPD3DRECT   lpRects     = pcd->lpRects;

            DWORD       dwFillColor;

            pContext->aa.makeSuperBufferValid(pContext);

            if (dwRTSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
                /*
                 * Get the fill color (24bit RGB) and convert it to 16bpp (565) format.
                 */
                dwFillColor = ((pcd->dwFillColor & 0x00F80000) >> 8)
                            | ((pcd->dwFillColor & 0x0000FC00) >> 5)
                            | ((pcd->dwFillColor & 0x000000F8) >> 3);
            else
                dwFillColor = pcd->dwFillColor;

#ifndef STEREO_SUPPORT
            dwDstOffset = pContext->aa.pSuperRenderTarget->getOffset();
#else   //STEREO_SUPPORT==1
            dwDstOffset = GetStereoOffset(pContext->aa.pSuperRenderTarget);
#endif  //STEREO_SUPPORT
            dwDstPitch  = pContext->aa.pSuperRenderTarget->getPitch();

            if (dwNumRects)
            {
                nvSetClearSurface  (dwDstOffset, dwDstPitch, dwRTSurfColorFormat, dwRTRectColorFormat, dwFillColor);

                while (dwNumRects)
                {
                    DWORD startx, starty;
                    DWORD width, height;

                    /*
                     * Get the next rectangle to clear.
                     */
                    startx = DWORD(0.5f + lpRects->x1 * pContext->aa.fWidthAmplifier);
                    width  = DWORD((lpRects->x2 - lpRects->x1) * pContext->aa.fWidthAmplifier);

                    starty = DWORD(0.5f + lpRects->y1 * pContext->aa.fHeightAmplifier);
                    height = DWORD((lpRects->y2 - lpRects->y1) * pContext->aa.fHeightAmplifier);


                    /*
                     * Use the hardware to do the clear.
                     */
                    nvClearSurfaceRect(startx, starty, width, height);

                    /*
                     * Move to the next rectangle.
                     */
                    lpRects++;
                    dwNumRects--;
                }
            }
        }
    }

    else // !pContext->aa.isEnabled()

#endif  // NVARCH >= 0x010

    {
#if (NVARCH >= 0x020)
        CSimpleSurface *pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
        CSimpleSurface *pZetaBuffer = pContext->kelvinAA.GetCurrentZB(pContext);
#else
        CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
        CSimpleSurface *pZetaBuffer = pContext->pZetaBuffer;
#endif


        // conditionally clear the z-buffer
        if ((pcd->dwFlags & D3DCLEAR_ZBUFFER) && pZetaBuffer)
        {

            DWORD dwFillDepth = pcd->dwFillDepth;

            // Normal (not AA)
            {
                DWORD       dwNumRects  = pcd->dwNumRects;
                LPD3DRECT   lpRects     = pcd->lpRects;

#ifndef STEREO_SUPPORT
                dwDstOffset = pZetaBuffer->getOffset();
#else   //STEREO_SUPPORT==1
                dwDstOffset = GetStereoOffset(pZetaBuffer);
#endif  //STEREO_SUPPORT
                dwDstPitch  = pRenderTarget->isSwizzled() ?
                                pRenderTarget->getPitch() : pZetaBuffer->getPitch();
                //syncrhonization marker in case DDRAW wants to do a lock later
                pZetaBuffer->hwLock(CSimpleSurface::LOCK_NORMAL);
                if (dwNumRects)
                {
                    /*
                     * Set the destination surface to be cleared.
                     */
                    nvSetClearSurface(dwDstOffset, dwDstPitch, dwZBSurfColorFormat, dwZBRectColorFormat, dwFillDepth);

                    while (dwNumRects)
                    {
                        DWORD startx, starty;
                        DWORD width, height;

                        /*
                         * Get the next rectangle to clear.
                         */
                        startx = lpRects->x1;
                        starty = lpRects->y1;
                        width  = lpRects->x2 - startx;
                        height = lpRects->y2 - starty;

                        /*
                         * Use the hardware to do the clear.
                         */
                        nvClearSurfaceRect(startx, starty, width, height);

                        /*
                         * Move to the next rectangle.
                         */
                        lpRects++;
                        dwNumRects--;
                    }
                }
                //syncrhonization marker in case DDRAW wants to do a lock later
                pZetaBuffer->hwUnlock();

            }
        }

        // clear the render surface
        if ((pcd->dwFlags & D3DCLEAR_TARGET) && pRenderTarget)
        {
            DWORD       dwFillColor;
            DWORD       dwNumRects  = pcd->dwNumRects;
            LPD3DRECT   lpRects     = pcd->lpRects;

            CNvObject *pNvObj = pContext->pRenderTarget->getWrapper();

            if (!dbgFrontRender) {
                pNvObj->checkClearRT(pContext->dwEarlyCopyStrategy, &pContext->xfmView._41, &pContext->xfmView._42, &pContext->xfmView._43);
                if (pNvObj->doClearRTNone()) goto skip_rt_clear;
            }

            if (dwRTSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
                /*
                 * Get the fill color (24bit RGB) and convert it to 16bpp (565) format.
                 */
                dwFillColor = ((pcd->dwFillColor & 0x00F80000) >> 8)
                            | ((pcd->dwFillColor & 0x0000FC00) >> 5)
                            | ((pcd->dwFillColor & 0x000000F8) >> 3);
            else
                dwFillColor = pcd->dwFillColor;

#ifndef STEREO_SUPPORT
            dwDstOffset = pRenderTarget->getOffset();
#else   //STEREO_SUPPORT==1
            dwDstOffset = GetStereoOffset(pRenderTarget);
#endif  //STEREO_SUPPORT
            dwDstPitch  = pRenderTarget->getPitch();
            //syncrhonization marker in case DDRAW wants to do a lock later
            pRenderTarget->hwLock(CSimpleSurface::LOCK_NORMAL);

            /*
             * Clear the rendering target.
             * Send the correct default objects for all the subchannels
             * just to be safe.
             */
            if (dwNumRects)
            {
                /*
                 * Set the destination surface to be cleared.
                 */
                nvSetClearSurface(dwDstOffset, dwDstPitch, dwRTSurfColorFormat, dwRTRectColorFormat, dwFillColor);
                while (dwNumRects)
                {
                    DWORD startx, starty;
                    DWORD width, height;

                    /*
                     * Get the next rectangle to clear.
                     */
                    startx = lpRects->x1;
                    starty = lpRects->y1;
                    width  = lpRects->x2 - startx;
                    height = lpRects->y2 - starty;

                    if (!dbgFrontRender) {
                        pNvObj->adjustRTCBounds(starty, height);
                    }

                    /*
                     * Use the hardware to do the clear.
                     */
                    nvClearSurfaceRect(startx, starty, width, height);

                    /*
                     * Move to the next rectangle.
                     */
                    lpRects++;
                    dwNumRects--;
                }
            }
            //syncrhonization marker in case DDRAW wants to do a lock later
            pRenderTarget->hwUnlock();
        }
skip_rt_clear:;
    }

    nvReset2DSurfaceFormat();
    pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = 0;
    nvPusherStart (FALSE);

    dbgFlushType (NVDBG_FLUSH_2D);

    pcd->ddrval = DD_OK;
    DDENDTICK(DEVICE_CLEARRENDERZ);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

// clear a surface using a raster operation.

void nvClearSurfaceWithRop (PNVD3DCONTEXT pContext,
                            DWORD dwOffset, DWORD dwPitch,         // offset and pitch of surface to clear
                            LPD3DRECT lpRects, DWORD dwNumRects,   // rectangles to clear
                            DWORD dwAddressMode,                   // 8-bit granularity or 32?
                            DWORD dwROP,                           // raster operation
                            DWORD dwColor0, DWORD dwColor1,        // colors selected by pattern
                            DWORD dwPattern,                       // p=0 selects color0, p=1 selects color1
                            DWORD dwFillValue)                     // source value (fill value)
{
    DWORD dwSurfaceFormat, dwMultiplier;
    DWORD dwX1, dwY1, dwWidth, dwHeight;


    // the real surface depth must be 32. we fake things accordingly
    nvAssert (pContext->pRenderTarget);
    nvAssert (pContext->pRenderTarget->getBPP() == 4);
    nvAssert ((dwAddressMode==8) || (dwAddressMode==32));

    // set up the objects on which D3D_RENDER_SOLID_RECTANGLE depends:
    //      - NV_DD_SURFACES_2D (the target surface)
    //      - NV_DD_CONTEXT_PATTERN
    //      - NV_DD_CONTEXT_ROP
    // BUGBUG most of these are probably already set this way. try pruning this list down

    dwSurfaceFormat = (dwAddressMode==8) ? NV042_SET_COLOR_FORMAT_LE_Y8 : NV042_SET_COLOR_FORMAT_LE_Y32;
    dwMultiplier    = (dwAddressMode==8) ? 2 : 0;  // if we're addressing things by bytes, we multiply coordinates by 4

    nvglSet2DSurfacesColorFormat (NV_DD_SURFACES, dwSurfaceFormat);
    nvglSet2DSurfacesPitch (NV_DD_SURFACES, dwPitch, dwPitch);
    nvglSet2DSurfacesDestination (NV_DD_SURFACES, dwOffset);

    nvglSetObject (NV_DD_SPARE, NV_DD_CONTEXT_PATTERN);
    nvglSetNv4ContextPatternMonochromeFormat (NV_DD_SPARE, NV044_SET_MONOCHROME_FORMAT_LE_M1);
    nvglSetNv4ContextPatternMonochromeShape (NV_DD_SPARE, NV044_SET_MONOCHROME_SHAPE_8X_8Y);
    nvglSetNv4ContextPatternPatternSelect (NV_DD_SPARE, NV044_SET_PATTERN_SELECT_MONOCHROME);
    nvglSetNv4ContextPatternMonochromeColors (NV_DD_SPARE, dwColor0, dwColor1);
    nvglSetNv4ContextPatternMonochromePatterns (NV_DD_SPARE, dwPattern, dwPattern);

    nvglSetRop5 (NV_DD_ROP, dwROP);

    // set up the D3D_RENDER_SOLID_RECTANGLE object
    // BUGBUG most of these are probably already set this way. try pruning this list down

    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
        nvglSetObject (NV_DD_SPARE, D3D_GDI_RECTANGLE_TEXT);
        nvglDrawPatternRectAndTextSetPattern(NV_DD_SPARE, NV_DD_CONTEXT_PATTERN);
        nvglDrawRopRectAndTextSetROP(NV_DD_SPARE, NV_DD_CONTEXT_ROP);
        nvglDrawRopRectAndTextSetSurface(NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglDrawRopRectAndTextSetOperation(NV_DD_SPARE, NV04A_SET_OPERATION_ROP_AND);
        nvglDrawRopRectAndTextColor1A(NV_DD_SPARE, dwFillValue);
    }
    else{
        nvglSetObject (NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
        nvglSetNv4SolidRectanglePattern(NV_DD_SPARE, NV_DD_CONTEXT_PATTERN);
        nvglSetNv4SolidRectangleRop(NV_DD_SPARE, NV_DD_CONTEXT_ROP);
        nvglSetNv4SolidRectangleSurface (NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglSetNv4SolidRectangleOperation (NV_DD_SPARE, NV05E_SET_OPERATION_ROP_AND);
        nvglNv4SolidRectangleColor (NV_DD_SPARE, dwFillValue);
    }

    while (dwNumRects) {

        // get the window coordinates and size
        dwX1 = lpRects->x1;
        dwY1 = lpRects->y1;
        dwWidth  = lpRects->x2 - dwX1;
        dwHeight = lpRects->y2 - dwY1;

#if (NVARCH >= 0x010)
        if (pContext->aa.isEnabled()) {
            if (pContext->aa.isRenderTargetValid()) {
                // Make sure that it's the only one that's valid
                pContext->aa.makeRenderTargetValid(pContext);
            } else {
                float s;
                s        = pContext->aa.fWidthAmplifier;
                dwX1     = DWORD(0.5f + dwX1 * s);
                dwWidth  = DWORD(dwWidth * s + s - 1);
                s        = pContext->aa.fHeightAmplifier;
                dwY1     = DWORD(0.5f + dwY1 * s);
                dwHeight = DWORD(dwHeight * s + s - 1);
            }
        }
#endif  // NVARCH >= 0x010

        // scale x coords by 4 if we've lied to the HW about the surface format
        dwX1    <<= dwMultiplier;
        dwWidth <<= dwMultiplier;

        if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
            nvglDrawRopRectAndTextPointSize (NV_DD_SPARE, dwX1, dwY1, dwWidth, dwHeight);
        }
        else {
            nvglNv4SolidRectanglePointSize (NV_DD_SPARE, dwX1, dwY1, dwWidth, dwHeight);
        }

        lpRects++;
        dwNumRects--;

    }

    // put some key stuff back the way it was
    pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_PATTERN;
    nvglSetObject (NV_DD_SPARE, NV_DD_CONTEXT_PATTERN);
    nvglSetNv4ContextPatternMonochromeColors (NV_DD_SPARE, 0xffffffff, 0xffffffff);

    nvReset2DSurfaceFormat();

    pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = FALSE;

}

//---------------------------------------------------------------------------

void nvValidateClearRects(LPD3DRECT pRects, DWORD dwNumRects)
{
    const maxSize = 4096;

    for(DWORD dwRect = 0; dwRect < dwNumRects; dwRect++) {
        if (pRects[dwRect].x1 > maxSize) pRects[dwRect].x1 = maxSize;
        if (pRects[dwRect].x1 < 0 )      pRects[dwRect].x1 = 0;
        if (pRects[dwRect].x2 > maxSize) pRects[dwRect].x2 = maxSize;
        if (pRects[dwRect].x2 < 0)       pRects[dwRect].x2 = 0;
        if (pRects[dwRect].y1 > maxSize) pRects[dwRect].y1 = maxSize;
        if (pRects[dwRect].y1 < 0)       pRects[dwRect].y1 = 0;
        if (pRects[dwRect].y2 > maxSize) pRects[dwRect].y2 = maxSize;
        if (pRects[dwRect].y2 < 0)       pRects[dwRect].y2 = 0;
    }
}

//---------------------------------------------------------------------------

// DX6 callback for clearing render target, z-buffer and stencil buffer.

DWORD __stdcall nvClear2
(
    LPD3DHAL_CLEAR2DATA pc2d
)
{
    PNVD3DCONTEXT   pContext;
    BOOL            bResetSwizzleTag = FALSE;
    BOOL            bHaveStencil;
    DWORD           dwClear2Flags;
    DWORD           dwFastClearFlags;
    DWORD           dwFillColor = 0;
    DWORD           dwFillDepth = 0;
    DWORD           dwFillStencil = 0;
    DWORD           dwFastFillDepth;
    __int64         i64FillDepth;
    LPD3DRECT       pRects;
    DWORD           dwNumRects;
    CSimpleSurface *pRenderTarget;
    CSimpleSurface *pZetaBuffer;

    dbgTracePush ("nvClear2");

#ifdef NV_NULL_HW_DRIVER
    pc2d->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
#endif

    // get the context
    NV_SET_CONTEXT (pContext, pc2d);
    nvSetDriverDataPtrFromContext (pContext);

    nvValidateClearRects(pc2d->lpRects, pc2d->dwNumRects);

    // force AA enabled if registry said so
#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        pContext->kelvinAA.TestCreation(pContext);
    } else
#endif
#if (NVARCH >= 0x010)
     if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK) // aa enabled
        && ((pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] != D3DANTIALIAS_NONE)
        || (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK))) // aa forced
        {
            // create aa buffers
            if (nvCelsiusAACreate(pContext)) {
                // enable AA
                pContext->aa.setFlags (AASTATE::FLAG_ENABLED);
            }

        }
    }
#endif  // NVARCH >= 0x010

#if (NVARCH >= 0x020)
    pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
    pZetaBuffer = pContext->kelvinAA.GetCurrentZB(pContext);

    CKelvinAAState::AccessType RTAccess, ZBAccess;
 
    if (pc2d->dwNumRects == 1) {
        D3DRECT r = pc2d->lpRects[0];
 
        RTAccess =
            ((pc2d->dwFlags & D3DCLEAR_TARGET) && 
            pContext->pRenderTarget && 
            ((r.x2-r.x1) == (int)pContext->pRenderTarget->getWidth()) &&
            ((r.y2-r.y1) == (int)pContext->pRenderTarget->getHeight())) ?
            CKelvinAAState::ACCESS_WRITE_DISCARD :
            CKelvinAAState::ACCESS_WRITE;
 
        ZBAccess =
            ((pc2d->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)) && 
            pContext->pZetaBuffer && 
            ((r.x2-r.x1) == (int)pContext->pZetaBuffer->getWidth()) &&
            ((r.y2-r.y1) == (int)pContext->pZetaBuffer->getHeight())) ?
            CKelvinAAState::ACCESS_WRITE_DISCARD :
            CKelvinAAState::ACCESS_WRITE;
    } else {
        RTAccess = CKelvinAAState::ACCESS_WRITE;
        ZBAccess = CKelvinAAState::ACCESS_WRITE;
    }
 
    if ((pRenderTarget != pContext->pRenderTarget) && (pc2d->dwFlags & D3DCLEAR_TARGET)) {
        pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SRT, RTAccess);
    }
    if ((pZetaBuffer != pContext->pZetaBuffer) && (pc2d->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL))) {
        pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SZB, ZBAccess);
    }
#else
    pRenderTarget = pContext->pRenderTarget;
    pZetaBuffer = pContext->pZetaBuffer;
#endif

    if ((!pRenderTarget) || getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        pc2d->ddrval = DD_OK;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return(DDHAL_DRIVER_HANDLED);
    }

    nvSetD3DSurfaceState (pContext);

    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }

    // assume things are OK unless we find out otherwise
    pc2d->ddrval = DD_OK;

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    DDSTARTTICK(DEVICE_CLEARALL);

    // Need to make sure that an unfriendly mode switch didn't sneak and not cause
    // us to get re-enabled properly.

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            DDENDTICK(DEVICE_CLEARALL);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    bHaveStencil = nvStencilBufferExists (pContext);

    // sanity check the flags
    dwClear2Flags  = pc2d->dwFlags & D3DCLEAR_TARGET;
    dwClear2Flags |= pZetaBuffer  ? (pc2d->dwFlags & D3DCLEAR_ZBUFFER) : 0;
    dwClear2Flags |= bHaveStencil ? (pc2d->dwFlags & D3DCLEAR_STENCIL) : 0;

    if (pContext->dwRTHandle)
    {
        CNvObject *pRTObj = nvGetObjectFromHandle(pContext->dwDDLclID, pContext->dwRTHandle, &global.pNvSurfaceLists);

        if (pRTObj) {

            // check if render target is a texture
            CTexture *pTexture = pTexture = pRTObj->getTexture();

            if (pTexture) {
                // if we're using the swizzled surface, we could have problems
                if (pContext->pRenderTarget != pTexture->getLinear()) {
                    // check if there are any sub-rects on the list
                    for (DWORD i = 0; i < pc2d->dwNumRects; i++) {
                        if ((pc2d->lpRects[i].x1 | pc2d->lpRects[i].y1)
                         || (pc2d->lpRects[i].y2 != (LONG)pTexture->getHeight())
                         || (pc2d->lpRects[i].x2 != (LONG)pTexture->getWidth())) {
                            break;
                        }
                    }
                    // if we have partial clears or if we're trying to clear z
                    // with mis-matched buffer sizes, resort to linear
                    if ( (i < pc2d->dwNumRects)
                         ||
                         ( (dwClear2Flags & D3DCLEAR_ZBUFFER)
                           &&
                           ((pZetaBuffer->getWidth() > pTexture->getWidth()) ||
                            (pZetaBuffer->getPitch() > (pTexture->getWidth() * pTexture->getBPP())))
                         )
                       )
                    {
                        if (!pTexture->prepareLinearAsRenderTarget()) {
                            // could not create linear surface
                            nvAssert(0);
                        }
                        // set linear surface as new render target
                        pDriverData->bDirtyRenderTarget = TRUE;
                        pContext->pRenderTarget = pTexture->getLinear();
                        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_SURFACE;
                    }
                }
                // update flags
                if (pContext->pRenderTarget == pTexture->getLinear()) {
                    pTexture->getLinear()->tagUpToDate();    // mark linear surface we are about to clear as touched
                    pTexture->getSwizzled()->tagOutOfDate(); // mark linear surface as out of date
                }
                else {
                    pTexture->getSwizzled()->tagUpToDate();  // mark swizzled surface we are about to clear as touched
                    pTexture->getLinear()->tagOutOfDate();   // mark linear surface as out of date
                    if (getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                        // surface is actually swizzled, tag as linear to prevent kelvin invalid state error
                        pContext->pRenderTarget->tagAsLinear();
                        // set flag so that we can reset the true value later
                        bResetSwizzleTag = TRUE;
                        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_SURFACE;
                    }
                }
            }

            else {
                // not a texture
                // store the fill color for use by the logo clear function
                if (dwClear2Flags & D3DCLEAR_TARGET) {
                    pContext->dwLastFillColor = pc2d->dwFillColor;
                    if ((pc2d->lpRects[0].x1 | pc2d->lpRects[0].y1)
                     || (pc2d->lpRects[0].y2 != (LONG)pContext->pRenderTarget->getHeight())
                     || (pc2d->lpRects[0].x2 != (LONG)pContext->pRenderTarget->getWidth())) {
                        pContext->bClearLogo = TRUE;
                    }
                }
            }

        } // if (pRTObj)

    } // if (pContext->dwRTHandle)

    // convert the color to the right format
    if (dwClear2Flags & D3DCLEAR_TARGET) {
        switch (pRenderTarget->getFormat()) {
            case NV_SURFACE_FORMAT_X8R8G8B8:
            case NV_SURFACE_FORMAT_A8R8G8B8:
                dwFillColor = pc2d->dwFillColor;
                break;
            case NV_SURFACE_FORMAT_R5G6B5:
                dwFillColor = ((pc2d->dwFillColor & 0x00F80000) >> 8)
                            | ((pc2d->dwFillColor & 0x0000FC00) >> 5)
                            | ((pc2d->dwFillColor & 0x000000F8) >> 3);
                break;
            case NV_SURFACE_FORMAT_X1R5G5B5:
                dwFillColor = ((pc2d->dwFillColor & 0x00F80000) >> 9)
                            | ((pc2d->dwFillColor & 0x0000F800) >> 6)
                            | ((pc2d->dwFillColor & 0x000000F8) >> 3);
                break;
            default:
                DPF ("unhandled surface format in clear2");
                dbgD3DError();
                dwFillColor = pc2d->dwFillColor;
                break;
        } // switch
    }

    // convert the depth fill to an appropriate fixed-point value
    if (dwClear2Flags & D3DCLEAR_ZBUFFER) {
        if (pZetaBuffer->getBPP() == 2) {
            i64FillDepth = (__int64)((double)pc2d->dvFillDepth * (double)65535.0f);   // convert to 16-bit number
            i64FillDepth = (i64FillDepth > 0xffff) ? 0xffff : i64FillDepth;
            i64FillDepth = (i64FillDepth < 0)      ? 0      : i64FillDepth;
            dwFillDepth  = (DWORD)i64FillDepth;
        }
        else {
            assert (pZetaBuffer->getBPP() == 4);
            i64FillDepth = (__int64)((double)pc2d->dvFillDepth * (double)16777215.0); // convert to 24-bit number
            i64FillDepth = (i64FillDepth > 0xffffff) ? 0xffffff : i64FillDepth;
            i64FillDepth = (i64FillDepth < 0)        ? 0        : i64FillDepth;
            dwFillDepth  = (DWORD)i64FillDepth << 8;  // the z-buffer occupies the upper 3 bytes.
        }
    }

    // if we're clearing stencil, get the fill value and cache it off
    if (dwClear2Flags & D3DCLEAR_STENCIL) {
        dwFillStencil = pc2d->dwFillStencil & 0xff;
        pContext->dwStencilFill = dwFillStencil;
        // i think we could potentially also do something like this if it would help any apps...
        // pContext->bStencilEnabled = FALSE; (rename Enabled => Valid)
        // pContext->hwState.celsius.dwDirtyBits |= CELSIUS_DIRTY_MISC; || NV_FORCE_TRI_SETUP
    }

#if (NVARCH >= 0x020) && defined (KELVIN_CLEAR)

    if (getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

        DWORD   dwEnable;
        DWORD   dwLeft, dwBandLeft;
        DWORD   dwRight, dwBandRight;
        DWORD   dwWidth,dwHeight;
        D3DRECT d3dRect;

        // if no stencil exists, clear the stencil buffer for NV20
        // it's actually faster to clear the stencil buffer every time, than to only clear it one time.
        if (!bHaveStencil && (dwClear2Flags & D3DCLEAR_ZBUFFER)) {
            if (pZetaBuffer->getBPP() == 4) {
                dwClear2Flags |= D3DCLEAR_STENCIL;
                dwFillStencil = 0;
                pContext->dwStencilFill = dwFillStencil;
            }
        }

        nvSetKelvinClearState (pContext);

        if (bResetSwizzleTag) {
            // reset swizzled render target flag
            pContext->pRenderTarget->tagAsSwizzled();
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_SURFACE;
            // temporarily disable z-compression
            pContext->hwState.kelvin.set1 (NV097_SET_COMPRESS_ZBUFFER_EN, NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE);
        }

        // set the clear values
        pContext->hwState.kelvin.set2 (NV097_SET_ZSTENCIL_CLEAR_VALUE,
                                       dwFillDepth | dwFillStencil,
                                       dwFillColor);

        // figure out which surfaces to clear
        dwEnable = (dwClear2Flags & D3DCLEAR_TARGET) ?
                   (DRF_DEF (097, _CLEAR_SURFACE, _R, _ENABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _G, _ENABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _B, _ENABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _A, _ENABLE)) :
                   (DRF_DEF (097, _CLEAR_SURFACE, _R, _DISABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _G, _DISABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _B, _DISABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _A, _DISABLE));

        dwEnable |= DRF_NUM (097, _CLEAR_SURFACE, _Z,       ((dwClear2Flags & D3DCLEAR_ZBUFFER) ? TRUE : FALSE));
        dwEnable |= DRF_NUM (097, _CLEAR_SURFACE, _STENCIL, ((dwClear2Flags & D3DCLEAR_STENCIL) ? TRUE : FALSE));

        // lock surfaces
        if (dwClear2Flags & D3DCLEAR_TARGET) {
            pRenderTarget->hwLock (CSimpleSurface::LOCK_NORMAL);
        }
        if (dwClear2Flags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)) {
            nvAssert (pZetaBuffer);
            pZetaBuffer->hwLock (CSimpleSurface::LOCK_NORMAL);
        }

        // iterate through the rectangles
        pRects     = pc2d->lpRects;
        dwNumRects = pc2d->dwNumRects;

        while (dwNumRects) {

            d3dRect.x1 = (DWORD)(0.5 + pRects->x1*pContext->aa.fWidthAmplifier);
            d3dRect.y1 = (DWORD)(0.5 + pRects->y1*pContext->aa.fHeightAmplifier);
            d3dRect.x2 = (DWORD)(0.5 + pRects->x2*pContext->aa.fWidthAmplifier);
            d3dRect.y2 = (DWORD)(0.5 + pRects->y2*pContext->aa.fHeightAmplifier);

            dwWidth = d3dRect.x2 - d3dRect.x1;
            dwHeight = d3dRect.y2 - d3dRect.y1;
            if (dwWidth && dwHeight) //if there's work to do
            {
            // clear in <=256-byte aligned vertical bands
            if (dwWidth >= KELVIN_TETRIS_THRESHOLD) {

                dwBandLeft = 0;
                while (dwBandLeft < (DWORD)(d3dRect.x2)) {
                    // setup band
                    dwBandRight = dwBandLeft + KELVIN_TETRIS_WIDTH;
                    dwLeft      = max (dwBandLeft,  (DWORD)d3dRect.x1);
                    dwRight     = min (dwBandRight, (DWORD)d3dRect.x2);
                    if (dwRight > dwLeft) {
                        // clear the current sub-rectangle. note that our rects are [a,b) whereas kelvin's are [a,b]
                        pContext->hwState.kelvin.set2 (NV097_SET_CLEAR_RECT_HORIZONTAL,
                                                       (DRF_NUM (097, _SET_CLEAR_RECT_HORIZONTAL, _XMIN, dwLeft) |
                                                        DRF_NUM (097, _SET_CLEAR_RECT_HORIZONTAL, _XMAX, dwRight-1)),
                                                       (DRF_NUM (097, _SET_CLEAR_RECT_VERTICAL,   _YMIN, d3dRect.y1) |
                                                        DRF_NUM (097, _SET_CLEAR_RECT_VERTICAL,   _YMAX, d3dRect.y2-1)));
                        pContext->hwState.kelvin.set1 (NV097_CLEAR_SURFACE, dwEnable);
                    }
                    dwBandLeft = dwBandRight;
                }
            }

            else {
                // clear the whole rectangle at once. note that MS's rects are [a,b) whereas kelvin's are [a,b]
                pContext->hwState.kelvin.set2 (NV097_SET_CLEAR_RECT_HORIZONTAL,
                                               (DRF_NUM (097, _SET_CLEAR_RECT_HORIZONTAL, _XMIN, d3dRect.x1) |
                                                DRF_NUM (097, _SET_CLEAR_RECT_HORIZONTAL, _XMAX, d3dRect.x2-1)),
                                               (DRF_NUM (097, _SET_CLEAR_RECT_VERTICAL,   _YMIN, d3dRect.y1) |
                                                DRF_NUM (097, _SET_CLEAR_RECT_VERTICAL,   _YMAX, d3dRect.y2-1)));
                pContext->hwState.kelvin.set1 (NV097_CLEAR_SURFACE, dwEnable);
            }
            }
            pRects++;
            dwNumRects--;

        }

        // unlock
        if (dwClear2Flags & D3DCLEAR_TARGET) {
            pRenderTarget->hwUnlock();
        }
        if (dwClear2Flags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)) {
            nvAssert (pZetaBuffer);
            pZetaBuffer->hwUnlock();
        }

        if (bResetSwizzleTag) {
#ifndef DISABLE_Z_COMPR
            // enable z-compression again (unless disabled in registry)
            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ZCOMPRESSENABLE_MASK) == D3D_REG_ZCOMPRESSENABLE_ENABLE) {
                pContext->hwState.kelvin.set1 (NV097_SET_COMPRESS_ZBUFFER_EN, NV097_SET_COMPRESS_ZBUFFER_EN_V_ENABLE);
            }
#endif
        }

        DDENDTICK(DEVICE_CLEARALL);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

#endif  // (NVARCH >= 0x020) && defined (KELVIN_CLEAR)

    // figure out what we can fast clear...
    dwFastClearFlags = dwClear2Flags & D3DCLEAR_TARGET;  // we can always fast clear the target

    if (!bHaveStencil) {
        // if there's no stencil buffer, then we can fast clear the z-buffer
        dwFastClearFlags |= dwClear2Flags & D3DCLEAR_ZBUFFER;
        dwFastFillDepth   = dwFillDepth;
    }
    else {
        // if there is a stencil buffer, we can fast clear it and the
        // z-buffer together, but not independantly. we can clear them both if:
        // a. the user has requested both -or-
        // b. the user has requested only z, but the stencil buffer is unused (or clear)
        if ((dwClear2Flags & D3DCLEAR_ZBUFFER) && (dwClear2Flags & D3DCLEAR_STENCIL)) {
            dwFastClearFlags |= D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL;
            dwFastFillDepth   = dwFillDepth | dwFillStencil;
        }
        else if ((dwClear2Flags & D3DCLEAR_ZBUFFER) && (!pContext->bStencilEnabled)) {
            dwFastClearFlags |= D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL;
            dwFastFillDepth   = dwFillDepth | pContext->dwStencilFill;
        }
    }

    // if there's anything to fast clear, go ahead and do it
    if (dwFastClearFlags) {

        D3DHAL_CLEARDATA cd;

        cd.dwhContext  = pc2d->dwhContext;
        cd.dwFlags     = dwFastClearFlags;
        cd.dwFillColor = pc2d->dwFillColor;
        cd.dwFillDepth = dwFastFillDepth;
        cd.lpRects     = pc2d->lpRects;
        cd.dwNumRects  = pc2d->dwNumRects;

        nvClear (&cd);

        pc2d->ddrval = cd.ddrval;

    }

    // see if there's anything left to do. if not, just return.
    dwClear2Flags &= ~dwFastClearFlags;

    if (!dwClear2Flags) {
        DDENDTICK(DEVICE_CLEARALL);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    pRects     = pc2d->lpRects;
    dwNumRects = pc2d->dwNumRects;

#if (NVARCH >= 0x010)
    // handle AA clear
    if (pContext->aa.isEnabled()) {
        // select large buffer (without magnify)
        nvCelsiusAASelectSuperBuffers (pContext);
    }
#endif  // NVARCH >= 0x010

    // at this point, we must have a stencil buffer and be wanting to clear
    // only it OR the z-buffer, but not both.
    nvAssert (bHaveStencil);
    nvAssert (((dwClear2Flags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)) == D3DCLEAR_ZBUFFER) ||
              ((dwClear2Flags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)) == D3DCLEAR_STENCIL));

    // get active zeta buffer
#if (NVARCH >= 0x010)
    if (pContext->aa.isEnabled()) {
        pZetaBuffer = pContext->aa.pSuperZetaBuffer;
    } else
#endif  // NVARCH < 0x010
    {
        pZetaBuffer = pContext->pZetaBuffer;
    }

    DWORD dwPitch  = pRenderTarget->isSwizzled() ?
                     pRenderTarget->getPitch() : pZetaBuffer->getPitch();

    //More D3D Synchronization with clears
    pZetaBuffer->hwLock(CSimpleSurface::LOCK_NORMAL);

    if (dwClear2Flags & D3DCLEAR_ZBUFFER) {
        // we need to clear the z-buffer without stomping on the stencil buffer
        DWORD dwFillDepth0, dwFillDepth1, dwFillDepth2;

        dwFillDepth0 = (dwFillDepth >>  8) & 0xff;
        dwFillDepth1 = (dwFillDepth >> 16) & 0xff;
        dwFillDepth2 = (dwFillDepth >> 24) & 0xff;

        if ((dwFillDepth0 == dwFillDepth1) && (dwFillDepth1 == dwFillDepth2)) {
            // if all three bytes to be written are the same, we can do this with byte masks.
            nvClearSurfaceWithRop (pContext,
#ifndef STEREO_SUPPORT
                                   pZetaBuffer->getOffset(),
#else   //STEREO_SUPPORT==1
                                   GetStereoOffset(pZetaBuffer),
#endif  //STEREO_SUPPORT
                                   dwPitch,
                                   pRects, dwNumRects,
                                   8,                       // clear byte by byte
                                   0x000000cc,              // select src. write enable contingent on pattern's alpha
                                   0x00000000, 0x0000ff00,  // X16A8Y8. a=00 to kill the write, a=ff to enable it
                                   0xeeeeeeee,              // write,write,write,kill repeat
                                   dwFillDepth0);           // X24Y8
        }
        else {
            // we have to do a read-modify-write
            nvClearSurfaceWithRop (pContext,
#ifndef STEREO_SUPPORT
                                   pZetaBuffer->getOffset(),
#else   //STEREO_SUPPORT==1
                                   GetStereoOffset(pZetaBuffer),
#endif  //STEREO_SUPPORT
                                   dwPitch,
                                   pRects, dwNumRects,
                                   32,                      // clear by DWORDs
                                   0x000000ca,              // pattern ? src : dest
                                   0xffffff00, 0x00000000,  // Y32. color0 => write 24 bits, skip 8
                                   0x00000000,              // we always just select the first pattern (color0)
                                   dwFillDepth);            // Y32
        }
    }

    else {
        // we need to clear the stencil buffer without stomping on the z-buffer.
        assert (dwClear2Flags & D3DCLEAR_STENCIL);
        nvClearSurfaceWithRop (pContext,
#ifndef STEREO_SUPPORT
                               pZetaBuffer->getOffset(),
#else   //STEREO_SUPPORT==1
                               GetStereoOffset(pZetaBuffer),
#endif  //STEREO_SUPPORT
                               dwPitch,
                               pRects, dwNumRects,
                               8,                       // clear byte by byte
                               0x000000cc,              // select src. write enable contingent on pattern's alpha
                               0x00000000, 0x0000ff00,  // X16A8Y8. a=00 to kill the write, a=ff to enable it
                               0x11111111,              // kill,kill,kill,write repeat
                               dwFillStencil);          // X24Y8
    }

    pZetaBuffer->hwUnlock();

    DDENDTICK(DEVICE_CLEARALL);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

}  // nvClear2

//---------------------------------------------------------------------------

/*
 * nvCTDecodeBuffer
 *
 * decodes an optimized buffer
 */
void nvCTDecodeBuffer
(
    CNvObject *pNvObj,
    DWORD      dwAddr,
    DWORD      dwBPP,
    DWORD      dwPitch,
    DWORD      dwWidth,
    DWORD      dwHeight
)
{
    /*
     * setup
     */
    extern BYTE nvTexelScratchBuffer[8192]; // reuse nvswiz.c scratch buffer

    DWORD  dwWidthBytes = dwWidth * dwBPP;
    BYTE  *pMem;
    BOOL   bMem;
    DWORD  y;

    if (dwWidthBytes > sizeof(nvTexelScratchBuffer))
    {
        pMem = (unsigned char*)AllocIPM(dwWidthBytes);
        bMem = TRUE;
    }
    else
    {
        pMem = nvTexelScratchBuffer;
        bMem = FALSE;
    }

    /*
     * for all scan lines
     */
    for (y = 0; y < dwHeight; y++)
    {
        DWORD x;

        /*
         * read scan line
         */
        nvMemCopy ((DWORD)pMem,dwAddr,dwWidthBytes);

        /*
         * process line
         */
        if (pNvObj->isCTFront())
        {
            switch (dwBPP)
            {
                case 2:
                {
                    for (x = 0; x < dwWidth; x++)
                    {
                        ((WORD*)pMem)[x] = ((WORD*)pMem)[x] << 1;
                    }
                    break;
                }
                case 4:
                {
                    for (x = 0; x < dwWidth; x++)
                    {
                        ((DWORD*)pMem)[x] = ((DWORD*)pMem)[x] << 1;
                    }
                    break;
                }
            }
        }
        else
        {
            switch (dwBPP)
            {
                case 2:
                {
                    for (x = 0; x < dwWidth; x++)
                    {
                        ((WORD*)pMem)[x] = (~((WORD*)pMem)[x]) << 1;
                    }
                    break;
                }
                case 4:
                {
                    for (x = 0; x < dwWidth; x++)
                    {
                        ((DWORD*)pMem)[x] = (~((DWORD*)pMem)[x]) << 1;
                    }
                    break;
                }
            }
        }

        /*
         * write scan line
         */
        nvMemCopy (dwAddr,(DWORD)pMem,dwWidthBytes);

        /*
         * next
         */
        dwAddr += dwPitch;
    }

    /*
     * done
     */
    if (bMem)
    {
        FreeIPM (pMem);
    }
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvAccess.cpp ===
//======================================================================
// Module:		nvAccess.cpp
// Description:	Generic kernel access routines that are neutral to the calling OS
// 
//  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
//======================================================================

#include "nvprecomp.h"

#ifdef NV_USE_ZW_PFUNCS

NV_ZW_FILE_IO_FUNCS NvZwFileIoFuncs = { NULL, NULL, NULL, NULL };

void NvInitFileIoFuncs( PDEV *ppdev )
{
    DWORD dwReturnStatus, dwReturnSize;

    dwReturnStatus = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_ZW_GET_FILE_IO_FUNCS,
                                         NULL, 0ul,
                                         &NvZwFileIoFuncs, sizeof(NvZwFileIoFuncs),
                                         &dwReturnSize );
}

#endif

void NVAnsiToUnicode(WCHAR *destString, TCHAR *srcString)
{
    int sLen;

    sLen = nvStrLen(srcString) + 1;

    while (sLen)
    {
        *destString = (USHORT)(*(UCHAR *)srcString);
        destString++;
        srcString++;
        sLen--;
    }
}

void NVUnicodeToAnsi(TCHAR *destString, WCHAR *srcString) 
{

    DWORD dwNullCnt = 0;
    DWORD dwPos = 0;

    while (srcString[dwPos] != 0) {
        destString[dwPos] = (UCHAR)srcString[dwPos];
        dwPos++;
    }
    destString[dwPos] = '\0';
}

HANDLE NvCreateFile( LPCTSTR lpFileName,                         // file name
                   DWORD dwDesiredAccess,                      // access mode
                   DWORD dwSharedMode,                          // share mode
                   LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
                   DWORD dwCreationDisposition,                // how to create
                   DWORD dwFlagsAndAttributes,                 // file attributes
                   HANDLE hTemplateFile                        // handle to template file
                   ) {

    HANDLE hFile = INVALID_HANDLE_VALUE;

#ifndef WINNT
    // Standard Win32 file creation
    hFile = CreateFile(lpFileName, dwDesiredAccess, dwSharedMode, lpSecurityAttributes, dwCreationDisposition,
                dwFlagsAndAttributes, hTemplateFile);
#else

    NV_ZW_CREATE_FILE_IN CreateFileIn;
    TCHAR device[64];
    DWORD dwReturnStatus, dwReturnSize = 0ul;

    nvAssert( pDriverData != NULL );
    if( pDriverData == NULL ) return INVALID_HANDLE_VALUE;

    if( ppdev == NULL ) return INVALID_HANDLE_VALUE;

    // Mass parameter conversion

    if (dwDesiredAccess & GENERIC_READ) {
        CreateFileIn.ulDesiredAccess = CreateFileIn.ulDesiredAccess ^ GENERIC_READ;
        CreateFileIn.ulDesiredAccess |= FILE_GENERIC_READ;
    }
    if (dwDesiredAccess & GENERIC_WRITE) {
        CreateFileIn.ulDesiredAccess = CreateFileIn.ulDesiredAccess ^ GENERIC_WRITE;
        CreateFileIn.ulDesiredAccess |= FILE_GENERIC_WRITE;
    }
    if (dwDesiredAccess & GENERIC_EXECUTE) {
        CreateFileIn.ulDesiredAccess = CreateFileIn.ulDesiredAccess ^ GENERIC_EXECUTE;
        CreateFileIn.ulDesiredAccess |= FILE_GENERIC_EXECUTE;
    }

    // get string name and make it Unicode, with the device path (\??\c:\booyah.txt, etc...)
    nvSprintf( device, TEXT("\\??\\%s"), lpFileName);

    NVAnsiToUnicode(CreateFileIn.pwcObjectBuffer, device);
    CreateFileIn.uiObjectName.Length = (USHORT)nvStrLen(device)*sizeof(WCHAR);
    CreateFileIn.uiObjectName.MaximumLength = 256*sizeof(WCHAR);
    CreateFileIn.uiObjectName.Buffer = CreateFileIn.pwcObjectBuffer;
    InitializeObjectAttributes(&CreateFileIn.ObjectAttributes, &CreateFileIn.uiObjectName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    CreateFileIn.liAllocationSize.QuadPart = 0;

    CreateFileIn.ulShareAccess = dwSharedMode;

    //CreationDisposition
    if (dwCreationDisposition == CREATE_NEW)
        CreateFileIn.ulCreateDisposition = FILE_CREATE;
    else if (dwCreationDisposition == CREATE_ALWAYS)
        CreateFileIn.ulCreateDisposition = FILE_SUPERSEDE;
    else if (dwCreationDisposition == OPEN_EXISTING)
        CreateFileIn.ulCreateDisposition = FILE_OPEN;
    else if (dwCreationDisposition == OPEN_ALWAYS)
        CreateFileIn.ulCreateDisposition = FILE_OPEN_IF;
    else if (dwCreationDisposition == TRUNCATE_EXISTING)
        CreateFileIn.ulCreateDisposition = FILE_OVERWRITE;

    CreateFileIn.ulDesiredAccess = dwDesiredAccess;

    CreateFileIn.ulCreateOptions = FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT;

    CreateFileIn.pvEaBuffer = NULL;
    CreateFileIn.ulEaLength = 0ul;

#ifdef NV_USE_ZW_PFUNCS
    if( NvZwFileIoFuncs.pvZwCreateFile == NULL ) {
        // Init the function pointers
        NvInitFileIoFuncs( ppdev );
        if( NvZwFileIoFuncs.pvZwCreateFile == NULL )
            return NULL;
    }

    {
        IO_STATUS_BLOCK IoBlock;
        dwReturnStatus = NvZwFileIoFuncs.pvZwCreateFile( &hFile,
                                       CreateFileIn.ulDesiredAccess,
                                       &CreateFileIn.ObjectAttributes,
                                       &IoBlock,
                                       &CreateFileIn.liAllocationSize,
                                       CreateFileIn.ulFileAttributes,
                                       CreateFileIn.ulShareAccess,
                                       CreateFileIn.ulCreateDisposition,
                                       CreateFileIn.ulCreateOptions,
                                       CreateFileIn.pvEaBuffer,
                                       CreateFileIn.ulEaLength );
    }
#else
    dwReturnStatus = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_ZW_CREATE_FILE,
                                         &CreateFileIn, sizeof(CreateFileIn),
                                         &hFile, sizeof(hFile),
                                         &dwReturnSize );
#endif


    if( dwReturnStatus )
        hFile = INVALID_HANDLE_VALUE;
#endif

    return hFile;

} // NvCreateFile


BOOL NvCloseHandle(HANDLE hFile) {

    BOOL bRes = FALSE;
#ifndef WINNT
    bRes = CloseHandle(hFile);
#else
    DWORD dwReturnStatus, dwReturnSize = 0ul;

    nvAssert( pDriverData != NULL );
    if( pDriverData == NULL ) return FALSE;

    if( ppdev == NULL ) return FALSE;


#ifdef NV_USE_ZW_PFUNCS
    if( NvZwFileIoFuncs.pvZwClose == NULL ) {
        // Init the function pointers
        NvInitFileIoFuncs( ppdev );
        if( NvZwFileIoFuncs.pvZwClose == NULL )
            return NULL;
    }

    dwReturnStatus = NvZwFileIoFuncs.pvZwClose( hFile );
#else
    dwReturnStatus = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_ZW_CLOSE_HANDLE,
                                         &hFile, sizeof(hFile),
                                         NULL, 0ul,
                                         &dwReturnSize );
#endif

    if( dwReturnStatus )
        bRes = FALSE;
    else
        bRes = TRUE;
#endif

    return bRes;
} // NvCloseHandle


BOOL NvWriteFile( HANDLE hFile,                    // handle to file
                LPCVOID lpBuffer,                // data buffer
                DWORD nNumberOfBytesToWrite,     // number of bytes to write
                LPDWORD lpNumberOfBytesWritten,  // number of bytes written
                LPOVERLAPPED lpOverlapped        // overlapped buffer
                ) 
{
    BOOL bRes;


#ifndef WINNT
    bRes = WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
#else
    NV_ZW_RW_FILE_IN WriteFileIn;
    DWORD dwReturnStatus, dwReturnSize = 0ul;

    nvAssert( pDriverData != NULL );
    if( pDriverData == NULL ) return FALSE;

    if( ppdev == NULL ) return TRUE;

    WriteFileIn.pvFileHandle = hFile;
    WriteFileIn.pvEvent = NULL;
    WriteFileIn.pvApcRoutine = NULL;
    WriteFileIn.pvApcContext = NULL;
    WriteFileIn.pvBuffer = (LPVOID)lpBuffer;
    WriteFileIn.ulLength = nNumberOfBytesToWrite;

    if (lpOverlapped != NULL) {
        WriteFileIn.liByteOffset.QuadPart = lpOverlapped->Offset;
    }
    else {
        WriteFileIn.liByteOffset.QuadPart = 0ul;
    }

    WriteFileIn.pvKey = NULL;

#ifdef NV_USE_ZW_PFUNCS
    if( NvZwFileIoFuncs.pvZwWriteFile == NULL ) {
        // Init the function pointers
        NvInitFileIoFuncs( ppdev );
        if( NvZwFileIoFuncs.pvZwWriteFile == NULL )
            return FALSE;
    }

    {
        IO_STATUS_BLOCK IoBlock;
        dwReturnStatus = NvZwFileIoFuncs.pvZwWriteFile( WriteFileIn.pvFileHandle,
                                                        WriteFileIn.pvEvent,
                                                        WriteFileIn.pvApcRoutine,
                                                        WriteFileIn.pvApcContext,
                                                        &IoBlock,
                                                        WriteFileIn.pvBuffer,
                                                        WriteFileIn.ulLength,
                                                        &WriteFileIn.liByteOffset,
                                                        WriteFileIn.pvKey );
    }
#else
    dwReturnStatus = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_ZW_WRITE_FILE,
                                        &WriteFileIn, sizeof(WriteFileIn),
                                        NULL, 0,
                                        &dwReturnSize );
#endif

    if (dwReturnStatus) {
        bRes = FALSE;
        *lpNumberOfBytesWritten = 0;
    }
    else {
        bRes = TRUE;
        *lpNumberOfBytesWritten = nNumberOfBytesToWrite;
    }
#endif
    
    return bRes;
} // NvWriteFile

BOOL NvReadFile(HANDLE hFile,                // handle to file
                LPVOID lpBuffer,             // data buffer
                DWORD nNumberOfBytesToRead,  // number of bytes to read
                LPDWORD lpNumberOfBytesRead, // number of bytes read
                LPOVERLAPPED lpOverlapped    // overlapped buffer
                )  
{
    BOOL bRes;

#ifndef WINNT
    bRes = ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
#else
    NV_ZW_RW_FILE_IN ReadFileIn;
    DWORD dwReturnStatus, dwReturnSize = 0ul;

    nvAssert( pDriverData != NULL );
    if( pDriverData == NULL ) return FALSE;

    if( ppdev == NULL ) return FALSE;

    // Convert To NT style params.
    if (lpOverlapped != NULL) {
        ReadFileIn.liByteOffset.QuadPart = lpOverlapped->Offset;
    }

    ReadFileIn.pvFileHandle = hFile;
    ReadFileIn.pvApcContext = NULL;
    ReadFileIn.pvApcRoutine = NULL;
    ReadFileIn.pvBuffer = lpBuffer;
    ReadFileIn.pvEvent = NULL;
    ReadFileIn.pvKey = NULL;
    ReadFileIn.ulLength = nNumberOfBytesToRead;

#ifdef NV_USE_ZW_PFUNCS
    if( NvZwFileIoFuncs.pvZwReadFile == NULL ) {
        // Init the function pointers
        NvInitFileIoFuncs( ppdev );
        if( NvZwFileIoFuncs.pvZwReadFile == NULL )
            return FALSE;
    }

    {
        IO_STATUS_BLOCK IoBlock;
        dwReturnStatus = NvZwFileIoFuncs.pvZwReadFile( ReadFileIn.pvFileHandle,
                                                       ReadFileIn.pvEvent,
                                                       ReadFileIn.pvApcRoutine,
                                                       ReadFileIn.pvApcContext,
                                                       &IoBlock,
                                                       ReadFileIn.pvBuffer,
                                                       ReadFileIn.ulLength,
                                                       &WriteFileIn.liByteOffset,
                                                       ReadFileIn.pvKey );
    }
#else
    dwReturnStatus = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_ZW_READ_FILE,
                                        &ReadFileIn, sizeof(ReadFileIn),
                                        NULL, 0,
                                        &dwReturnSize );
#endif

    if (dwReturnStatus) {
        bRes = FALSE;
        *lpNumberOfBytesRead = 0;
    }
    else {
        bRes = TRUE;
        *lpNumberOfBytesRead = nNumberOfBytesToRead;
    }

#endif

    return bRes;
}



BOOL NvDeviceIoControl(
  HANDLE hDevice,              // handle to device
  DWORD dwIoControlCode,       // operation control code
  LPVOID lpInBuffer,           // input data buffer
  DWORD nInBufferSize,         // size of input data buffer
  LPVOID lpOutBuffer,          // output data buffer
  DWORD nOutBufferSize,        // size of output data buffer
  LPDWORD lpBytesReturned,     // byte count
  LPOVERLAPPED lpOverlapped    // overlapped information
)
{
    BOOL bRes;
#ifndef WINNT
    bRes =  DeviceIoControl(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned,
                            lpOverlapped);
#else
    NTSTATUS status;
    NV_ZW_DEVICE_IO_CONTROL_FILE ZwDeviceIoControl;

    nvAssert( pDriverData != NULL );
    if( pDriverData == NULL ) return false;

    if( ppdev == NULL ) return false;

    ZwDeviceIoControl.hDevice = hDevice;
    ZwDeviceIoControl.ulIoControlCode = dwIoControlCode;
    ZwDeviceIoControl.pvInputBuffer = lpInBuffer;
    ZwDeviceIoControl.ulInputBufferSize = nInBufferSize;

#ifdef NV_USE_ZW_PFUNCS
    if( NvZwFileIoFuncs.pvZwDeviceIoControlFile == NULL ) {
        // Init the function pointers
        NvInitFileIoFuncs( ppdev );
        if( NvZwFileIoFuncs.pvZwDeviceIoControlFile == NULL )
            return false;
    }

    {
        IO_STATUS_BLOCK IoBlock;
        dwReturnStatus = NvZwFileIoFuncs.pvZwDeviceIoControlFile( hDevice,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &IoBlock,
                                                dwIoControlCode,
                                                lpInBuffer,
                                                nInBufferSize,
                                                lpOutBuffer,
                                                nOutBufferSize );
    }
#else
    status = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_CONTROL_DEVICE,
                                 &ZwDeviceIoControl, sizeof(ZwDeviceIoControl),
                                 lpOutBuffer, nOutBufferSize,
                                 lpBytesReturned );
#endif


    if (status == STATUS_SUCCESS) {
        bRes = true;
    }
    else {
        *lpBytesReturned = 0ul;
        bRes = false;
    }

#endif

    return bRes;
}

#pragma warning(disable: 4035)

DWORD NvGetTickCount()
{
#ifndef WINNT
    return GetTickCount();
#else
    __asm {
            mov     edx, 07ffe0000h
            mov     eax, [edx]
            mul     dword ptr [edx+4]
            shrd    eax,edx,18h
    };
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvbenchmark.cpp ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvBenchmark.cpp
//   Utility class for benchmarking and profiling purposes
//
//  History:
//      Menelaos Levas   1/30/2001
//
//
//
//
/********************************************************************/



#include "nvprecomp.h"
#ifdef NV_PROFILE_DP2OPS

char opLookupTable[D3D_DP2OP_MAX+1][64] =
{
    " ",                                           //  0
    "D3DDP2OP_POINTS",                              //  1
    "D3DDP2OP_INDEXEDLINELIST",                     //  2
    "D3DDP2OP_INDEXEDTRIANGLELIST",                 //  3
    "D3DDP2OP_RESERVED0",                           //  4
    " ",                                           //  5
    " ",                                           //  6
    " ",                                           //  7
    "D3DDP2OP_RENDERSTATE",                         //  8
    " ",                                           //  9
    " ",                                           // 10
    "D3DDP2OP_END",                                 // 11
    " ",                                           // 12
    " ",                                           // 13
    " ",                                           // 14
    "D3DDP2OP_LINELIST",                            // 15
    "D3DDP2OP_LINESTRIP",                           // 16
    "D3DDP2OP_INDEXEDLINESTRIP",                    // 17
    "D3DDP2OP_TRIANGLELIST",                        // 18
    "D3DDP2OP_TRIANGLESTRIP",                       // 19
    "D3DDP2OP_INDEXEDTRIANGLESTRIP",                // 20
    "D3DDP2OP_TRIANGLEFAN",                         // 21
    "D3DDP2OP_INDEXEDTRIANGLEFAN",                  // 22
    "D3DDP2OP_TRIANGLEFAN_IMM",                     // 23
    "D3DDP2OP_LINELIST_IMM",                        // 24
    "D3DDP2OP_TEXTURESTAGESTATE",                   // 25
    "D3DDP2OP_INDEXEDTRIANGLELIST2",                // 26
    "D3DDP2OP_INDEXEDLINELIST2",                    // 27
    "D3DDP2OP_VIEWPORTINFO",                        // 28
    "D3DDP2OP_WINFO",                               // 29
    "D3DDP2OP_SETPALETTE",                          // 30
    "D3DDP2OP_UPDATEPALETTE",                       // 31
    "D3DDP2OP_ZRANGE",                              // 32
    "D3DDP2OP_SETMATERIAL",                         // 33
    "D3DDP2OP_SETLIGHT",                            // 34
    "D3DDP2OP_CREATELIGHT",                         // 35
    "D3DDP2OP_SETTRANSFORM",                        // 36
    "D3DDP2OP_EXT",                                 // 37
    "D3DDP2OP_TEXBLT",                              // 38
    "D3DDP2OP_STATESET",                            // 39
    "D3DDP2OP_SETPRIORITY",                         // 40
    "D3DDP2OP_SETRENDERTARGET",                     // 41
    "D3DDP2OP_CLEAR",                               // 42
    "D3DDP2OP_SETTEXLOD",                           // 43
    "D3DDP2OP_SETCLIPPLANE",                        // 44
    "D3DDP2OP_CREATEVERTEXSHADER",                  // 45
    "D3DDP2OP_DELETEVERTEXSHADER",                  // 46
    "D3DDP2OP_SETVERTEXSHADER",                     // 47
    "D3DDP2OP_SETVERTEXSHADERCONST",                // 48
    "D3DDP2OP_SETSTREAMSOURCE",                     // 49
    "D3DDP2OP_SETSTREAMSOURCEUM",                   // 50
    "D3DDP2OP_SETINDICES",                          // 51
    "D3DDP2OP_DRAWPRIMITIVE",                       // 52
    "D3DDP2OP_DRAWINDEXEDPRIMITIVE",                // 53
    "D3DDP2OP_CREATEPIXELSHADER",                   // 54
    "D3DDP2OP_DELETEPIXELSHADER",                   // 55
    "D3DDP2OP_SETPIXELSHADER",                      // 56
    "D3DDP2OP_SETPIXELSHADERCONST",                 // 57
    "D3DDP2OP_CLIPPEDTRIANGLEFAN",                  // 58
    "D3DDP2OP_DRAWPRIMITIVE2",                      // 59
    "D3DDP2OP_DRAWINDEXEDPRIMITIVE2",               // 60
    "D3DDP2OP_DRAWRECTSURFACE",                     // 61
    "D3DDP2OP_DRAWTRISURFACE",                      // 62
    "D3DDP2OP_VOLUMEBLT",                           // 63
    "D3DDP2OP_BUFFERBLT",                           // 64
    "D3DDP2OP_MULTIPLYTRANSFORM"                    // 65
};

char opTypes[D3D_DP2OP_MAX+1] = 
{
    0,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    1,
    1,
    0,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    1,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    1,
    2,
    2,
    2,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2
};


DWORD CBenchmark::resetData() {
    for (DWORD i = 0; i <= D3D_DP2OP_MAX; i++) {
        dwCallsCountTable[i] = 0;
        dwPrimsCountTable[i] = 0;
    }

    dwDrawingCalls = 0;
    dwStateCalls = 0;
    dwDrawingPrimCount = 0; 
    dwStatePrimCount = 0;
    dwCurrentFrame = 0;
    dwHWStateChanges = 0;
    dwStateBlocks = 0;
    dwDrawBlocks = 0;
    dwLastType = 0;

    dwStartPut = 0;
    dwHWStateChangeSize = 0;
    dwActiveTextures = 0;    
    dwLastPrimCount = 0;

    for (i = 0; i < 5; i++) 
        dwTexPrims[i] = 0;
    for (i = 0; i < 13; i++) 
        dwHWChanged[i] = 0;

    for (i = 0; i < 8192; i++)
        dwStateBits[i] = 0;
    
    return 0;
}

DWORD CBenchmark::logData(DWORD dwCommand, DWORD dwPrimCount) {
    dwCallsCountTable[dwCommand]++;
    dwPrimsCountTable[dwCommand] += dwPrimCount;
    if (opTypes[dwCommand] == 1) {
        dwDrawingCalls++;
        if (dwPrimCount > 1) {
            dwDrawingPrimCount += dwPrimCount;
            dwLastPrimCount = dwPrimCount;
        }
        if (dwLastType == 2)
            dwDrawBlocks++;
    }
    else if (opTypes[dwCommand] == 2) {
        dwStateCalls++;
        dwStatePrimCount += dwPrimCount;
        if (dwLastType == 1)
            dwStateBlocks++;
    }

    dwLastType = opTypes[dwCommand];

    return 0;
}

DWORD CBenchmark::logDrawPrimitive(DWORD dwCount) {
//    primitives += wCount;
    dwDrawingPrimCount += dwCount;
    dwLastPrimCount = dwCount;

    return 0;
}

DWORD CBenchmark::beginHWStateChange(DWORD dwFlags, DWORD dwPut) {

    dwStartPut = dwPut;    
    
#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        dwFlags &= KELVIN_DIRTY_REALLY_FILTHY;
        dwStateBits[dwFlags >> 16]++;
        if (dwFlags & KELVIN_DIRTY_COMBINERS_COLOR) dwHWChanged[0]++; 
        if (dwFlags & KELVIN_DIRTY_COMBINERS_SPECFOG) dwHWChanged[1]++;
        if (dwFlags & KELVIN_DIRTY_CONTROL0) dwHWChanged[2]++;
        if (dwFlags & KELVIN_DIRTY_DEFAULTS) dwHWChanged[3]++;
        if (dwFlags & KELVIN_DIRTY_FVF) dwHWChanged[4]++;
        if (dwFlags & KELVIN_DIRTY_LIGHTS) dwHWChanged[5]++;
        if (dwFlags & KELVIN_DIRTY_MISC_STATE) dwHWChanged[6]++;
        if (dwFlags & KELVIN_DIRTY_SURFACE) dwHWChanged[7]++;
        if (dwFlags & KELVIN_DIRTY_TEXTURE_STATE) { dwHWChanged[8]++; dwActiveTextures = 0; }
        if (dwFlags & KELVIN_DIRTY_TEXTURE_TRANSFORM) dwHWChanged[9]++;
        if (dwFlags & KELVIN_DIRTY_TRANSFORM) dwHWChanged[10]++;
        if (dwFlags & KELVIN_DIRTY_VERTEX_SHADER) dwHWChanged[11]++;
        if (dwFlags & KELVIN_DIRTY_PIXEL_SHADER) dwHWChanged[12]++;        
    } else
#endif
#if (NVARCH >= 0x010)
    {
        dwFlags &= CELSIUS_DIRTY_REALLY_FILTHY;
        if (dwFlags & CELSIUS_DIRTY_COMBINERS) dwHWChanged[0]++; 
        if (dwFlags & CELSIUS_DIRTY_SPECFOG_COMBINER) dwHWChanged[1]++;
        if (dwFlags & CELSIUS_DIRTY_CONTROL0) dwHWChanged[2]++;
        if (dwFlags & CELSIUS_DIRTY_DEFAULTS) dwHWChanged[3]++;
        if (dwFlags & CELSIUS_DIRTY_FVF) dwHWChanged[4]++;
        if (dwFlags & CELSIUS_DIRTY_LIGHTS) dwHWChanged[5]++;
        if (dwFlags & CELSIUS_DIRTY_MISC_STATE) dwHWChanged[6]++;
        if (dwFlags & CELSIUS_DIRTY_SURFACE) dwHWChanged[7]++;
        if (dwFlags & CELSIUS_DIRTY_TEXTURE_STATE) dwHWChanged[8]++;
        if (dwFlags & CELSIUS_DIRTY_TEXTURE_TRANSFORM) dwHWChanged[9]++;
        if (dwFlags & CELSIUS_DIRTY_TRANSFORM) dwHWChanged[10]++;
        if (dwFlags & CELSIUS_DIRTY_TL_MODE) dwHWChanged[11]++;
        if (dwFlags & CELSIUS_DIRTY_PIXEL_SHADER) dwHWChanged[12]++;    
    }
#endif

    dwHWStateChanges++;
    return 0;
}

DWORD CBenchmark::endHWStateChange(DWORD dwPut) {
    if (dwPut > dwStartPut)
        dwHWStateChangeSize += dwPut - dwStartPut;
    else 
        dwHWStateChangeSize += pDriverData->nvPusher.getBase() + pDriverData->nvPusher.getSize() - dwStartPut +
                                dwPut - pDriverData->nvPusher.getBase();

    dwTexPrims[dwActiveTextures] += dwLastPrimCount;

    return 0;
}

DWORD CBenchmark::incActiveTextures() {
    dwActiveTextures++;
    return 0;
} 

DWORD CBenchmark::outputData(DWORD dwFlags) {
    if ((dwFlags & OUTPUT_FRAMECOUNT) > dwCurrentFrame) {
        dwCurrentFrame++;
        return 0;
    }

    if (dwFlags & OUTPUT_ALL_DP2OPS) {
        for (DWORD i = 0; i <= D3D_DP2OP_MAX; i++) { 
            if ((opTypes[i] != 0) && (dwCallsCountTable[i] != 0)) 
                PF("%s: calls: %d, prims: %d, average: %f", opLookupTable[i], 
                    dwCallsCountTable[i], dwPrimsCountTable[i], 
                    dwPrimsCountTable[i]/((float)dwCallsCountTable[i]));
        }
        PF("*************************************************************");
    }

    if (dwFlags & OUTPUT_TOTALS) {
        PF("TOTALS:");
        PF("Total drawing calls: %d, prims: %d, average: %f",
            dwDrawingCalls, dwDrawingPrimCount, dwDrawingPrimCount/((float)dwDrawingCalls));

        if (dwTexPrims[0] > 0)
            PF("Untextured prims: %d (%f)", dwTexPrims[0], 100*dwTexPrims[0]/(float)dwDrawingPrimCount);
        if (dwTexPrims[1] > 0)
            PF("Single textured prims: %d (%f)", dwTexPrims[1], 100*dwTexPrims[1]/(float)dwDrawingPrimCount);
        if (dwTexPrims[2] > 0)
            PF("Dual textured prims: %d (%f)", dwTexPrims[2], 100*dwTexPrims[2]/(float)dwDrawingPrimCount);
        if (dwTexPrims[3] > 0)
            PF("Triple textured prims: %d (%f)", dwTexPrims[3], 100*dwTexPrims[3]/(float)dwDrawingPrimCount);
        if (dwTexPrims[4] > 0)
            PF("Quad textured prims: %d (%f)", dwTexPrims[4], 100*dwTexPrims[4]/(float)dwDrawingPrimCount);

        PF("Total state calls: %d, prims: %d, average: %f",
            dwStateCalls, dwStatePrimCount, dwStatePrimCount/((float)dwStateCalls));
        PF("Total uninterrupted drawing blocks: %d, average size: %f", dwDrawBlocks, dwDrawingPrimCount/(float)dwStateBlocks);
        PF("Total uninterrupted state blocks: %d, average size: %f", dwStateBlocks, dwStatePrimCount/(float)dwStateBlocks);
        PF("*************************************************************");  
    }

    if (dwFlags & OUTPUT_HWSTATE_CHANGES) { 
#if (NVARCH >= 0x020)
        PF("HW STATE BITS:");
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            for (int i = 0; i < 8191; i++) 
            {
                if (dwStateBits[i] )
                {
                    DWORD state = i;
                    state <<= 16;
                    if (state & KELVIN_DIRTY_COMBINERS_COLOR)
                        PF("KELVIN_DIRTY_COMBINERS_COLOR |");
                    if (state & KELVIN_DIRTY_COMBINERS_SPECFOG)
                        PF("KELVIN_DIRTY_COMBINERS_SPECFOG |");
                    if (state & KELVIN_DIRTY_CONTROL0)
                        PF("KELVIN_DIRTY_CONTROL0 |");
                    if (state & KELVIN_DIRTY_DEFAULTS)
                        PF("KELVIN_DIRTY_DEFAULTS |");
                    if (state & KELVIN_DIRTY_FVF)
                        PF("KELVIN_DIRTY_FVF |");
                    if (state & KELVIN_DIRTY_LIGHTS)
                        PF("KELVIN_DIRTY_LIGHTS |");
                    if (state & KELVIN_DIRTY_MISC_STATE)
                        PF("KELVIN_DIRTY_MISC_STATE |");
                    if (state & KELVIN_DIRTY_SURFACE)
                        PF("KELVIN_DIRTY_SURFACE |");
                    if (state & KELVIN_DIRTY_TEXTURE_STATE)
                        PF("KELVIN_DIRTY_TEXTURE_STATE |");
                    if (state & KELVIN_DIRTY_TEXTURE_TRANSFORM)
                        PF("KELVIN_DIRTY_TEXTURE_TRANSFORM |");
                    if (state & KELVIN_DIRTY_TRANSFORM)
                        PF("KELVIN_DIRTY_TRANSFORM |");
                    if (state & KELVIN_DIRTY_VERTEX_SHADER)
                        PF("KELVIN_DIRTY_VERTEX_SHADER |");
                    if (state & KELVIN_DIRTY_PIXEL_SHADER)
                        PF("KELVIN_DIRTY_PIXEL_SHADER |");
                    PF("  %d", dwStateBits[i]); PF("");

                
                }
            }
        }
        if (dwStateBits[8191]) 
        {
            PF("KELVIN_DIRTY_REALLY_FILTHY: %d", dwStateBits[8191]);
        }
#endif

        PF("HW STATE CHANGES:");
        PF("Total HW state change pushbuffer size: %d, average per block: %f", 
            dwHWStateChangeSize, dwHWStateChangeSize/(float)dwStateBlocks); 
        PF("Total HW state changes: %d", dwHWStateChanges);
        PF("Color combiner state changes: %d", dwHWChanged[0]);
        PF("Specfog state changes: %d", dwHWChanged[1]);
        PF("Control0 state changes: %d", dwHWChanged[2]);
        PF("Defaults state changes: %d", dwHWChanged[3]);
        PF("FVF state changes: %d", dwHWChanged[4]);
        PF("Lights state changes: %d", dwHWChanged[5]);
        PF("Misc state changes: %d", dwHWChanged[6]);
        PF("Surface state changes: %d", dwHWChanged[7]);
        PF("Texture state changes: %d", dwHWChanged[8]);
        PF("Texture transform state changes: %d", dwHWChanged[9]);        
        PF("Transform state changes: %d", dwHWChanged[10]);
        PF("TL/Vertex shader state changes: %d", dwHWChanged[11]);
        PF("Pixel Shader state changes: %d", dwHWChanged[12]);
        PF("*************************************************************");
    }

    dwCurrentFrame = 0;

    if (dwFlags & CLEAR_DATA)
        resetData();

    return 0;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvComp.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvComp.cpp                                                        *
*   NV4 Triangle Inner Loop Compiler                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 08/27/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#define SPECULARPERFORMANCEFIX

#if (NVARCH >= 0x04)

/*****************************************************************************

  Inner loop strategy:

  * Inner loops are built on demand. Their uniqueness depends on the current
    render state, the platform it is run on and the currently selected FVF.
    The dispatch table associates these keys with the entry points to loops.

  * The inner loops themselves always assumes an indexed triangle list. All
    other cases generate appropriate indices on the fly

  * Singles and Quads have special cases that do not bother with the cache or
    with culling.

  * FVF cases are faster than non FVF if they have less elements - this is
    because we have unique FVF routines instead of generic ones

*****************************************************************************/

#include "x86.h"
#include "nvILHash.h"

/*
 * switches
 */
//#define INSTRUMENTED        // instrument inner loops
//#define PLOT                // plot data instead of printing it - instrumented only
//#define NOVERTEXCACHE       // do not use HW vertex cache
//#define NOLAUNCH            // do not launch triangles
#define CHECKVCTWICE        // check vertex cache in two places before missing
//#define NOSPECIALCASE       // suppress special tri & quad code paths
#define NOSKIP              // suppress skipping on prefetch
//#define NOCULLING           // suppress SW cull check
//#define PRINT_NAME          // prints ilcFlags for every primitive batch
//#define PRINT_NAME_ON_BUILD // prints name of primitive when it is built
#define NOCOMPRESSOVERHEAD  // do not use overhead compression

/*
 * flags
 */
#define MASK_FOG            0x00000003
#define MASK_PRIM           0x0000000c
#define FLAG_INDEXED        0x00000010
#define FLAG_DX6            0x00000020
#define FLAG_FIXEDWBUF      0x00000040
#define FLAG_SPECULAR       0x00000080
#define FLAG_ZFOG           0x00000100
#define FLAG_ZFP            0x00000200
#define FLAG_ZBP            0x00000400
#define FLAG_DIRECT         0x00000800 // DO NOT MODIFY - call setup or aa - depends on NV_FIXED_FUNCTION_INDEX in nvvxmac.h
#define FLAG_FLAT           0x00001000

#define FLAG_BASIC          0x00000000
#define FLAG_MMX            0x10000000
#define FLAG_KATMAI         0x20000000
#define FLAG_AMD            0x40000000

#define MASK_TABLE          0x000007ff // dwDrawPrimitiveTable is this big - we use it as a hash table

#define VD_FLAG_INDEXED     0x00000001

/*
 * macros
 */
#define ISLIST(x)           ((((x) & MASK_PRIM) == 0) || (((x) & MASK_PRIM) == 12))
#define ISSTRIP(x)          (((x) & MASK_PRIM) == 4)
#define ISFAN(x)            (((x) & MASK_PRIM) == 8)
#define ISLEGACY(x)         (((x) & MASK_PRIM) == 12)

#define ISFOGLIN(x)         (((x) & MASK_FOG) == 3)
#define ISFOGEXP(x)         (((x) & MASK_FOG) == 1)
#define ISFOGEXP2(x)        (((x) & MASK_FOG) == 2)

#define ISFLAT(x)           ((x) & FLAG_FLAT)
#define ISSPECULAR(x)       ((x) & FLAG_SPECULAR)

#define KNIMEM(x)           ((((DWORD)&((*(KATMAI_STATE*)global.kni).x[0])) + 15) & ~15)

/*
 * types
 */
typedef (__stdcall *PFNINNERLOOP)(void);

/*
 * aliases
 */
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#ifdef VTUNE_SUPPORT
void nvVTuneMemoryImage        (void);
void nvVTuneModifyAccessRights (void);
#endif //VTUNE_SUPPORT

/*
 * short-lived globals
 */
DWORD ilcFlags;
DWORD label_cache;

#ifdef DEBUG

#if 0 // DO NOT DELETE - valuable z-buffer blt code
static DWORD table[256];
static DWORD max = 0;

DWORD __inline mapZtoColor (DWORD c)
{
/*
    double t = ((double)c) / ((double)0xffffffff);
    double r = (t > 0.5) ? sin((t - .5) * .5 * 3.141592653) : 0.0;
    double g = sin(t * 3.141592653);
    double b = (t < .5 ) ? cos(t * .5 * 3.141592653) : 0.0;

    return (((DWORD)(r * 255.0)) << 16)
         | (((DWORD)(g * 255.0)) <<  8)
         | (((DWORD)(b * 255.0)) <<  0);
*/

    static DWORD color = 0x40;

    DWORD i;
    for (i = 0; i < max; i += 2)
    {
        if (table[i] == c)
        {
            return table[i+1];
        }
    }

    table[max]     = c;
    table[max + 1] = color;

    max += 2;
    color += 0x40;

    return table[max-1];
}
#endif

void __stdcall ILCDebug_flushTriangle (void)
{
#ifndef NV_NULL_HW_DRIVER
    getDC()->nvPusher.setPut(global.nvCachedPut);
#endif
    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
    global.nvCachedPut       = getDC()->nvPusher.getPut();
    global.nvCachedThreshold = getDC()->nvPusher.getThreshold();

#if 0 // DO NOT DELETE - valuable z-buffer blt code
    {
        DWORD y;
        DWORD x;
        DWORD line  = pContext->dwSurfaceAddr + (320 / 2) * 4;
        DWORD zline = pContext->ZBufferAddr;

        for (y = 0; y < 280; y++)
        {
            DWORD addr = line;
            DWORD zaddr = zline;

            for (x = 0; x < 320; x++)
            {
                *(DWORD*)addr = mapZtoColor(*(DWORD*)zaddr);
                addr += 4;
                zaddr += 4;
            }

            line  += pContext->surfacePitch.wColorPitch;
            zline += pContext->surfacePitch.wZetaPitch;
        }

    }
    {
        DWORD i;

        DPF ("table:");
        for (i = 0; i < max; i += 2)
        {
            DPF ("%08x -> %08x",table[i],table[i+1]);
        }
    }
    __asm int 3;
#endif
}
#endif // DEBUG

#if defined(DEBUG) || defined(NVSTATDRIVER)
void __stdcall ILCDebug_showVertex (DWORD *pdwAddr)
{
    dbgDisplayVertexData (FALSE, pdwAddr);
}

#endif

#ifdef INSTRUMENTED
/*
 * ILCDebug_plot
 *
 * plot a pixel
 */
void ILCDebug_plot
(
    int x,
    int y,
    int c
)
{
    DWORD addr = 0xb0000 + 0x2000 * (y & 3) + 90 * (y / 4) + (x / 8);
    DWORD bit  = 0x80 >> (x & 7);

    switch (c)
    {
        case 0: *(BYTE*)addr |= bit;
                break;
        case 1: if ((x & 1) ^ (y & 1)) *(BYTE*)addr |= bit;
                                  else *(BYTE*)addr &= ~bit;
                break;
        case 2: if (!((x & 1) && (y & 1))) *(BYTE*)addr |= bit;
                                      else *(BYTE*)addr &= ~bit;
                break;
    }
}

/*
 * ILCDebug_hline
 *
 * draw a line
 */
void ILCDebug_hline
(
    int y
)
{
    DWORD addr = 0xb0000 + 0x2000 * (y & 3) + 90 * (y / 4);
    int x;
    for (x = 0; x < 720; x += 8)
    {
        *(BYTE*)addr |= 0x07;
        addr++;
    }
}

/*
 * ILCDebug_vline
 *
 * draw a line
 */
void ILCDebug_vline
(
    int x
)
{
    int y;
    for (y = 0; y < 348; y += 4)
    {
        ILCDebug_plot (x,y,0);
    }
}

/*
 * ILCDebug_cls
 *
 * set graphics mode and clear debug monitor
 */
void ILCDebug_cls
(
    void
)
{
    static int program[] =
    {
        0x3bf,1,
        0x3b8,0,
        0x3b4,0,  0x3b5,0x35,
        0x3b4,1,  0x3b5,0x2d,
        0x3b4,2,  0x3b5,0x2e,
        0x3b4,3,  0x3b5,0x07,
        0x3b4,4,  0x3b5,0x5b,
        0x3b4,5,  0x3b5,0x02,
        0x3b4,6,  0x3b5,0x57,
        0x3b4,7,  0x3b5,0x57,
        0x3b4,8,  0x3b5,0x02,
        0x3b4,9,  0x3b5,0x03,
        0x3b4,10, 0x3b5,0x00,
        0x3b4,11, 0x3b5,0x00,
        0x3b8,0x2a  // 0xaa for page 1
    };

    /*
     * set mode
     */
    {
        int i;

        for (i = 0; i < sizeof(program) / sizeof(int); i += 2)
        {
            _outp ((WORD)program[i],(BYTE)program[i+1]);
        }
    }

    /*
     * cls
     */
    memset ((void*)0xb0000,0,32768);

    /*
     * draw grid
     */
    {
        float i;

        for (i = 0.0f; i < 348.0f; i += 348.0f / 8.0f) // 100Mb / div
        {
            ILCDebug_hline (347 - (int)i);
        }
        for (i = 0.0f; i < 720.0f; i += 720.0f / 4.0f) // 16kb / div
        {
            ILCDebug_vline ((int)i);
        }
    }
}

/*
 * ILCDebug_inspectXMM
 *
 * dumps xmm state so I can se what it is doing
 */
static DWORD xmmState[4*8];
void __stdcall ILCDebug_inspectXMM
(
    DWORD dwLine
)
{
    for (DWORD i=0; i < 8; i++) {
        DPF ("XMM%d: %08x %08x %08x %08x", i,xmmState[i*4+3],xmmState[i*4+2],xmmState[i*4+1],xmmState[i*4+0]);
    }
    DPF ("Line %d", dwLine);
}

#define xBREAK_XMM                                       \
{                                                        \
    xMOVUPS_i128_r ((DWORD)(xmmState +  0),rXMM0)        \
    xMOVUPS_i128_r ((DWORD)(xmmState +  4),rXMM1)        \
    xMOVUPS_i128_r ((DWORD)(xmmState +  8),rXMM2)        \
    xMOVUPS_i128_r ((DWORD)(xmmState + 12),rXMM3)        \
    xMOVUPS_i128_r ((DWORD)(xmmState + 16),rXMM4)        \
    xMOVUPS_i128_r ((DWORD)(xmmState + 20),rXMM5)        \
    xMOVUPS_i128_r ((DWORD)(xmmState + 24),rXMM6)        \
    xMOVUPS_i128_r ((DWORD)(xmmState + 28),rXMM7)        \
    xPUSHAD                                              \
    xPUSH_imm   (__LINE__)                               \
    xMOV_rm_imm (rmREG(rEAX),(DWORD)ILCDebug_inspectXMM) \
    xCALL_rm    (rmREG(rEAX))                            \
    xPOPAD                                               \
    xINT3                                                \
}

#endif  // INSTRUMENTED

#ifdef DEBUG

/*
 * ILCDebug_printLine
 *
 * debug helper to print break point line to debugger
 */
void __stdcall ILCDebug_printLine
(
    DWORD dwLine
)
{
    DPF ("Line %d", dwLine);
}
#define xBREAK { xPUSHAD xMOV_rm_imm (rmREG(rEBX),(DWORD)ILCDebug_printLine) xPUSH_imm (__LINE__) xCALL_rm (rmREG(rEBX)) xPOPAD xINT3 }

#endif

#if defined(PRINT_NAME) || defined(PRINT_NAME_ON_BUILD)
/*
 * ILCDebug_printName
 *
 * prints the current innerloop name
 */
void ILCDebug_printName
(
    DWORD dwFlags,
    DWORD dwVertexType,
    DWORD dwTextureOrder
)
{
    DPF ("flags=%08x fvf=%08x order=%08x", dwFlags,dwVertexType,dwTextureOrder);
}
#endif

/*
 * ILCCompile_mul
 *
 * multiplies the given register with the given constant
 *  tries to be cycle smart
 */
void ILCCompile_mul
(
    DWORD reg,
    DWORD num
)
{
    DWORD start = ilcCount;
    DWORD startnum = num;
    DWORD ops   = 0;

    // this gets very unhappy if num=0
    nvAssert (num != 0);

    for (;;)
    {
        /*
         * multiple of 9
         */
        if (((num / 9) * 9) == num)
        {
            xLEA_r_rm (reg,rmSIB) xSIB(reg,reg,x8)
            num /= 9;
            ops ++;
            continue;
        }

#if 0
        /*
         * multiple of 7
         */
        if (((num / 7) * 7) == num)
        {
            DWORD r2 = (reg == rEAX) ? rEBX : rEAX;
            xPUSH_r     (r2)
            xMOV_r_rm   (r2,rmREG(reg))
            xSHL_rm_imm8(rmREG(reg),3)  // n*8
            xSUB_r_rm   (reg,rmREG(r2)) // n*8-n
            xPOP_r      (r2)
            num /= 7;
            ops += 5;
            continue;
        }
#endif

        /*
         * multiple of 5
         */
        if (((num / 5) * 5) == num)
        {
            xLEA_r_rm (reg,rmSIB) xSIB(reg,reg,x4)
            num /= 5;
            ops ++;
            continue;
        }

        /*
         * multiple of 3
         */
        if (((num / 3) * 3) == num)
        {
            xLEA_r_rm (reg,rmSIB) xSIB(reg,reg,x2)
            num /= 3;
            ops ++;
            continue;
        }

        /*
         * power of 2, but not 1
         */
        if ((num > 1) && !(num & (num - 1)))
        {
            DWORD log = ~0;
            while (num) { log ++; num >>= 1; }
            xSHL_rm_imm8(rmREG(reg),log)
            ops ++;
            num = 1;
            break;
        }

        /*
         * all others
         */
        break;
    }

    /*
     * if it took too many ops or if we could not
     *  decompose it, replace with IMUL
     */
    if ((num != 1) || (ops >= 5))
    {
        ilcCount = start;
        xIMUL_r_r_imm (reg,reg,startnum)
    }
}

#ifdef WINNT
/*
 * ILCCompile_checkValid
 *
 * check if index is still valid (NT requirement)
 */
void ILCCompile_checkValid
(
    DWORD reg
)
{
    DWORD label;

    xCMP_r_i32  (reg,mMEM32(global.dwMaxVertexOffset))
    xLABEL      (label)
    xJL         (0)

    xXOR_r_rm   (reg,rmREG(reg))

    xTARGET_b8  (label)
}
#endif

/*
 * calculate fog values
 *  KATMAI uses SIMD to do the whole triangle at once
 *  - after computing fog it leaves the results in dwFogValue ready to be
 *    used by subsequent vertex copy cycles
 *  - if we have the special quad case, we need to do four verts at a time
 *  ALL OTHERS uses the slow per-vertex method described later
 */
void ILCCompile_KatmaiFog
(
    BOOL  bQuadCase
)
{
    DWORD offset = (ilcFlags & FLAG_ZFOG) ? 8 : 12; // z or rhw

    // get z or rhw values for the three vertices
    xMOV_r_i32 (rEAX,mMEM32(global.dwVertex0))
     xMOV_r_i32 (rEBX,mMEM32(global.dwVertex1))
      xMOV_r_i32 (rECX,mMEM32(global.dwVertex2))
       if (bQuadCase)
       {
            xMOV_r_i32 (rEDX,mMEM32(global.pVertices))
       }
    xMOV_r_rm  (rEAX,rmIND8(rEAX)) xOFS8 (offset)
     xMOV_r_rm  (rEBX,rmIND8(rEBX)) xOFS8 (offset)
      xMOV_r_rm  (rECX,rmIND8(rECX)) xOFS8 (offset)
       if (bQuadCase)
       {
            xMOV_r_rm  (rEDX,rmIND8(rEDX)) xOFS8 (offset)
       }
    xMOV_i32_r (KNIMEM(fRHW) + 0,rEAX)
     xMOV_i32_r (KNIMEM(fRHW) + 4,rEBX)
      xMOV_i32_r (KNIMEM(fRHW) + 8,rECX)
       if (bQuadCase)
       {
            xMOV_i32_r (KNIMEM(fRHW) + 12,rEDX)
       }

    // get xmm0 = ZFOG ? z : (1 / rhw)
    xMOVAPS_r_i128 (rXMM0,KNIMEM(fRHW))
    if (!(ilcFlags & FLAG_ZFOG))
    {
        xRCPPS_r_rm (rXMM0,rmREG(rXMM0)) // w <= (1 / rhw)
    }

    if (ISFOGLIN(ilcFlags))
    {
        // linear fog, scale: xmm1 = (end - xmm0) * scale
        xMOVAPS_r_i128 (rXMM1,KNIMEM(fFogTableEnd))
        xSUBPS_r_rm    (rXMM1,rmREG(rXMM0))
        xMULPS_r_i128  (rXMM1,KNIMEM(fFogTableLinearScale))

        // clamp
//        xMAXPS_r_i128  (rXMM1,KNIMEM(fZero))
//        xMINPS_r_i128  (rXMM1,KNIMEM(fOne))
    }
    else
    {
        // exp and exp2 fog, scale: xmm0 *= density
        xMULPS_r_i128  (rXMM0,KNIMEM(fFogTableDensity))

        // exp2 muls with itself, xmm0 *= xmm0
        if (ISFOGEXP2(ilcFlags))
        {
            xMULPS_r_rm (rXMM0,rmREG(rXMM0))
        }

        // xmm1 = approx(e ^ xmm0)
        xMOV_rm_imm    (rmREG(rEBX),0x3f800000)
        xMULPS_r_i128  (rXMM0,KNIMEM(fFogC2))
        xCVTPS2PI_r_rm (rMM0,rmREG(rXMM0))
        xMOVHLPS_r_r   (rXMM0,rmREG(rXMM0))
        xCVTPS2PI_r_rm (rMM1,rmREG(rXMM0))
        xMOVQ_i64_r    (KNIMEM(dwFogValue) + 0,rMM0)
        xMOVQ_i64_r    (KNIMEM(dwFogValue) + 8,rMM1)
        xADD_i32_r     (KNIMEM(dwFogValue) + 0,rEBX)
        xADD_i32_r     (KNIMEM(dwFogValue) + 4,rEBX)
        xADD_i32_r     (KNIMEM(dwFogValue) + 8,rEBX)
        if (bQuadCase)
        {
            xADD_i32_r (KNIMEM(dwFogValue) + 12,rEBX)
        }
        xMOVAPS_r_i128 (rXMM1,KNIMEM(dwFogValue))
    }

    // convert to 8 bit integer
    xMULPS_r_i128  (rXMM1,KNIMEM(f255))
    xMAXPS_r_i128  (rXMM1,KNIMEM(fZero))
    xMINPS_r_i128  (rXMM1,KNIMEM(f255))
    xCVTPS2PI_r_rm (rMM0,rmREG(rXMM1))
    xMOVHLPS_r_r   (rXMM1,rmREG(rXMM1))
    xCVTPS2PI_r_rm (rMM1,rmREG(rXMM1))
    xMOVQ_i64_r    (KNIMEM(dwFogValue) + 0,rMM0)
    xMOVQ_i64_r    (KNIMEM(dwFogValue) + 8,rMM1)
    xEMMS
}

/*
 * ILCCompile_vertex
 *
 * copy vertex into push buffer
 *  ebx has hw address to load into when pos == ~0
 *  if pos == (~0 - 1) then we will not load the hw address (caller must do it)
 *  if pos == 0x8000000? then we plan to load them amount of vertices specified
 *  in the low nybble. 0x80000001 has the same effect as ~0.
 *  vertex must be in ebx
 */
void ILCCompile_vertex
(
    PNVD3DCONTEXT pContext,
    DWORD vertexNumber,     // 0,1,2 or 3 for quad
    DWORD vertexAddress,
    DWORD pos,
    BOOL  bAllowVertexCache,
    DWORD dwArbitrationLevel,
    BOOL  bQuadCase
)
{
    PNVD3DMULTITEXTURESTATE pTriangleState = (PNVD3DMULTITEXTURESTATE)&pContext->mtsState;
    DWORD index;
    BOOL  bRHW        = FALSE;
    DWORD size        = (ilcFlags & FLAG_DX6) ? 11 : 9;
    BOOL  bSkipHWAddr = (pos == 0xfffffffe);

    // get pusher address
    if (bAllowVertexCache)
    {
        xPUSH_r    (rEDI)
        xMOV_r_i32 (rEDI,mMEM32(global.nvCachedPut))
    }
    else
    {
        if (dwArbitrationLevel == 0)
        {
            xMOV_r_i32 (rEDI,mMEM32(global.nvCachedPut))
        }
    }

    if ((dwArbitrationLevel == 0)
     && (ilcFlags & MASK_FOG)
     && (ilcFlags & FLAG_KATMAI))
    {
        if (pos == ~0)
        {
            xPUSH_r (rEBX)
        }
        ILCCompile_KatmaiFog(bQuadCase);
        if (pos == ~0)
        {
            xPOP_r (rEBX)
        }
    }

    // load method into ebx
    if (bSkipHWAddr)
    {
        xLEA_r_rm (rEDI,rmIND8(rEDI)) xOFS8(-4) // spoof offsets to make up for missing header
    }
    else
    {
        if ((pos == ~0) || ((pos & ~0xf) == 0x80000000))
        {
            pos = (pos == ~0) ? 1 : (pos & 15);
            if (ilcFlags & FLAG_DX6)
            {
                DWORD or = 0xe400 | ((40 * pos) << 16); // dx6 class specific
                ILCCompile_mul (rEBX,40);
                xOR_rm_imm  (rmREG(rEBX),or)
            }
            else
            {
                DWORD or = 0xe400 | ((32 * pos) << 16); // dx5 class specific
                ILCCompile_mul (rEBX,32);
                xOR_rm_imm  (rmREG(rEBX),or)
            }
        }
        else
        {
            xMOV_rm_imm (rmREG(rEBX),((ilcFlags & FLAG_DX6) ? (0x0028e400 | pos * 40)
                                                            : (0x0020e400 | pos * 32)))
        }
    }

    // point to vertex
    xMOV_r_i32 (rEDX,vertexAddress)

    /*------------------------------------------------------------------------
     * special cases
     *-----------------------------------------------------------------------*/

    if ( (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)
     &&  (ilcFlags & FLAG_KATMAI)
     && !(ilcFlags & (FLAG_DX6 | MASK_FOG | FLAG_FLAT | FLAG_FIXEDWBUF | FLAG_ZFOG | FLAG_ZFP | FLAG_ZBP)))
    {
        // P3 DX5 TL vertex
        xMOVLPS_r_rm (rXMM0,rmIND (rEDX))
        xMOVHPS_r_rm (rXMM0,rmIND8 (rEDX)) xOFS8(8)
        xMOVLPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8(16)
        xMOVHPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8(24)
        if (!bSkipHWAddr)
        {
            xMOV_rm_r    (rmIND (rEDI),rEBX)
        }
        xMOVLPS_rm_r (rmIND8(rEDI),rXMM0) xOFS8( 4)
        xMOVHPS_rm_r (rmIND8(rEDI),rXMM0) xOFS8( 12)
        xMOVLPS_rm_r (rmIND8(rEDI),rXMM1) xOFS8(20)
        xMOVHPS_rm_r (rmIND8(rEDI),rXMM1) xOFS8(28)
        goto vertexDone;
    }

    /*------------------------------------------------------------------------
     * generic case
     *-----------------------------------------------------------------------*/

    // read x,y,z,[w]
    if (pContext->pCurrentVShader->getFVF() & D3DFVF_XYZRHW)
    {
        xMOV_r_rm (rECX,rmIND(rEDX))
        xMOV_r_rm (rEBP,rmIND8(rEDX)) xOFS8 (4)
        xMOV_r_rm (rEAX,rmIND8(rEDX)) xOFS8 (8)
    }
    else
    {
        xXOR_r_rm (rECX,rmREG(rECX))        // default x = 0.0f
        xXOR_r_rm (rEBP,rmREG(rEBP))        // default y = 0.0f
        xXOR_r_rm (rEAX,rmREG(rEAX))        // default z = 0.0f
    }

    // write method, x,y,z,[w]
    if (!bSkipHWAddr)
    {
        xMOV_rm_r (rmIND(rEDI),rEBX)
    }
    xMOV_rm_r (rmIND8(rEDI),rECX) xOFS8 (4)
    xMOV_rm_r (rmIND8(rEDI),rEBP) xOFS8 (8)

    // write z
    if (ilcFlags & (FLAG_ZFP | FLAG_ZBP))
    {
        xPUSH_r (rEAX)

        if (ilcFlags & FLAG_ZFP)
        {
            // clamp z to 1.0f
            xCMP_rm_imm  (rmREG(rEAX),0x3f800000)
            xSETG_rm8    (rmREG(rBL))
            xSHR_rm_imm8 (rmREG(rEBX),1)
            xSBB_r_rm    (rEBX,rmREG(rEBX))     // ebx = (eax > 1.0f) ? -1 : 0

            xMOV_r_rm    (rECX,rmREG(rEBX))
            xNOT_rm      (rmREG(rECX))          // ecx = (eax > 1.0f) ? 0 : -1

            xAND_rm_imm  (rmREG(rEBX),0x3f800000)
            xAND_r_rm    (rEAX,rmREG(rECX))
            xOR_r_rm     (rEAX,rmREG(rEBX))
        }

        if (ilcFlags & FLAG_ZBP)
        {
            /*
             * clamp z to 0.0f
             */
            xMOV_r_rm    (rEBX,rmREG(rEAX))
            xSHL_rm_imm8 (rmREG(rEBX),1)
            xSBB_r_rm    (rEBX,rmREG(rEBX))     // ebx = (eax <= -0.0f) ? -1 : 0
            xNOT_rm      (rmREG(rEBX))          // ebx = (eax <= -0.0f) ? 0 : -1
            xAND_r_rm    (rEAX,rmREG(rEBX))
        }

        xMOV_i32_r   (mMEM32(global.dwTemp),rEAX)

        /*
         * optimize
         */
        xFLD_i32  (mMEM32(global.dwTemp))
        xFMUL_i32 (mMEM32(global.fCTC1));
        if (ilcFlags & FLAG_ZBP)
        {
            xFLD1
            xFSUBRP_st (rST1);
        }
        xFSTP_rm  (rmIND8(rEDI)) xOFS8 (12)

        xPOP_r (rEAX)
    }
    else
    {
        xMOV_rm_r (rmIND8(rEDI),rEAX) xOFS8 (12)
    }

    /*
     * read rhw
     */
    index = 12;
    if (pContext->pCurrentVShader->getFVF() & D3DFVF_XYZRHW)
    {
        xMOV_r_rm (rEBX,rmIND8(rEDX)) xOFS8 (index) index += 4;
    }
    else
    {
        xMOV_rm_imm (rmREG(rEBX), FP_ONE_BITS) // default rhw == 1.0f
    }

    /*
     * read color
     */
    if (pContext->pCurrentVShader->getFVF() & D3DFVF_DIFFUSE)
    {
        if (ilcFlags & FLAG_FLAT)
        {
            xMOV_r_i32 (rECX,mMEM32(global.dwFlatColor)) index += 4;
        }
        else
        {
            xMOV_r_rm  (rECX,rmIND8(rEDX)) xOFS8 (index) index += 4;
        }
    }
    else
    {
        xMOV_rm_imm (rmREG(rECX),0xffffffff) // default color == rgba(1,1,1,1)
    }

    /*
     * read specular
     */
    if (pContext->pCurrentVShader->getFVF() & D3DFVF_SPECULAR)
    {
        xMOV_r_rm (rEBP,rmIND8(rEDX)) xOFS8 (index) index += 4;

        /*
         * apply flat specular
         */
        if (ilcFlags & FLAG_FLAT)
        {
            xAND_rm_imm (rmREG(rEBP),0xff000000)
            xOR_r_i32   (rEBP,mMEM32(global.dwFlatSpecular))
        }
    }
    else
    {
        xMOV_rm_imm (rmREG(rEBP),0xff000000) // default specular == rgba(0,0,0,1)
    }

    /*
     * apply fog
     *  KATMAI uses already prepared values
     *  ALL OTHERS uses the slow per-vertex method
     *  - it uses z which is in eax or rhw which is in ebx to finally
     *    modify specular in ebp.
     */
    if (ilcFlags & MASK_FOG)
    {
        if (ilcFlags & FLAG_KATMAI)
        {
            /*
             * incorporate fog into specular component
             */
            xMOV_r_i32   (rEAX,KNIMEM(dwFogValue) + 4 * vertexNumber)
            xAND_rm_imm  (rmREG(rEBP),0x00ffffff)
            xSHL_rm_imm8 (rmREG(rEAX),24)
            xOR_r_rm     (rEBP,rmREG(rEAX))
        }
        else
        {
            /*
             * generic case - compute fog value
             */
            BOOL isExp2 = ISFOGEXP2(ilcFlags);
            BOOL isLin  = ISFOGLIN(ilcFlags);

            /*
             * save RHW and free up ebx for general use
             */
            xPUSH_r      (rEBX)
            xPUSH_r      (rEDX)
            xMOV_i32_r   (KNIMEM(fRHW),rEBX)
            bRHW = TRUE;

            /*
             * st(0) = (global.dvWNear == 1.0f) ? z : approx(1.0 / rhw)
             */
            if (ilcFlags & FLAG_ZFOG)
            {
                xMOV_i32_r   (mMEM32(global.dwTemp),rEAX)   // z - eax is free now
                xFLD_i32     (mMEM32(global.dwTemp))
            }
            else
            {
                xNEG_rm      (rmREG(rEBX))
                xADD_rm_imm  (rmREG(rEBX),0x3f800000*2)     // 2 * asint(1.0f) - rhw
                xMOV_i32_r   (mMEM32(global.dwTemp),rEBX)
                xFLD_i32     (mMEM32(global.dwTemp))
                xFLD_st      (rST0)
                xFMUL_i32    (KNIMEM(fRHW))
                xFLD_i32     (KNIMEM(fFogC1))
                xFSUBRP_st   (rST1)
                xFMULP_st    (rST1)
            }

            if (isLin)
            {
                DWORD fix11,fix12;
                DWORD fix21,fix22;

                /*
                 * (st(0) >= pContext->fogData.fFogTableEnd) ? 0.0f
                 */
                xFCOM_i32  (KNIMEM(fFogTableEnd))
                xFNSTSW
                xSAHF
                xLABEL     (fix11)
                xJB        (0)

                xFFREE_st  (rST0)
                xFINCSTP
                xFLDZ

                xLABEL     (fix12)
                xJMP       (0)

                /*
                 * else (st(1) <= pContext->fogData.fFogTableStart) ? 1.0f
                 */
                xTARGET_b8 (fix11)

                xFCOM_i32  (KNIMEM(fFogTableStart))
                xFNSTSW
                xSAHF
                xLABEL     (fix21)
                xJA        (0)

                xFFREE_st  (rST0)
                xFINCSTP
                xFLD1

                xLABEL     (fix22)
                xJMP       (0)


                /*
                 * else st(0) = (fFogTableEnd - st(0)) * fFogTableLinearScale
                 */
                xTARGET_b8 (fix21)

                xFLD_i32   (KNIMEM(fFogTableEnd))
                xFSUBRP_st (rST1)
                xFMUL_i32  (KNIMEM(fFogTableLinearScale))

                xTARGET_jmp (fix12)
                xTARGET_jmp (fix22)
            }
            else
            {
                /*
                 * st(0) *= fFogTableDensity
                 */
                xFMUL_i32  (KNIMEM(fFogTableDensity))

                if (isExp2)
                {
                    /*
                     * st(0) *= st(0)
                     */
                    xFMUL_st (rST0)
                }

                /*
                 * st(0) = exp( st(0) )
                 */
                xMOV_rm_imm (rmREG(rEBX),0x3f800000)
                xFMUL_i32   (KNIMEM(fFogC2))
                xFISTP_i32  (mMEM32(global.dwTemp))
                xADD_i32_r  (mMEM32(global.dwTemp),rEBX)
                xFLD_i32    (mMEM32(global.dwTemp))
            }

            /*
             * eax = int8bits ( st(0) ) << 24
             */
            xFLD1
            xFADDP_st    (rST1)
            xFSTP_i32    (mMEM32(global.dwTemp))
            xMOV_r_i32   (rEBX,mMEM32(global.dwTemp))

            xCMP_rm_imm  (rmREG(rEBX),0x3f800000)
            xSETG_rm8    (rmREG(rDL))
            xSHR_rm_imm8 (rmREG(rEDX),1)
            xSBB_r_rm    (rEAX,rmREG(rEAX))

            xCMP_rm_imm  (rmREG(rEBX),0x40000000)
            xSETGE_rm8   (rmREG(rDL))
            xSHR_rm_imm8 (rmREG(rEDX),1)
            xSBB_r_rm    (rEDX,rmREG(rEDX))

            xSHL_rm_imm8 (rmREG(rEBX),9)
            xOR_r_rm     (rEBX,rmREG(rEDX))
            xAND_r_rm    (rEBX,rmREG(rEAX))
            xAND_rm_imm  (rmREG(rEBX),0xff000000)

            /*
             * update specular
             */
            xAND_rm_imm  (rmREG(rEBP),0x00ffffff)
            xOR_r_rm     (rEBP,rmREG(rEBX))

            xPOP_r       (rEDX)
            xPOP_r       (rEBX)
        }
    }

    /*
     * apply fixed w-buffer scale to ebx
     */
    if (ilcFlags & FLAG_FIXEDWBUF)
    {
        if (!bRHW)
        {
            xMOV_i32_r   (KNIMEM(fRHW),rEBX)
            bRHW = TRUE;
        }

        xFLD_i32   (KNIMEM(fRHW))
        xFMUL_i32  ((DWORD)&global.fRWFar)
        xFSTP_i32  (KNIMEM(fRHW))
        xMOV_r_i32 (rEBX,KNIMEM(fRHW))
    }

    /*
     * read tu0
     */
    if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_TEXCOORD0]))
    {
        DWORD ofs = index + pTriangleState->dwUVOffset[0];
        xMOV_r_rm (rEAX,rmIND8(rEDX)) xOFS8 (ofs)
    }
    else
    {
        xXOR_r_rm (rEAX,rmREG(rEAX))        // default tu0 = 0.0f
    }

    /*
     * write rhw, color, specular, tu0
     */
    xMOV_rm_r (rmIND8(rEDI),rEBX) xOFS8 (16)
    xMOV_rm_r (rmIND8(rEDI),rECX) xOFS8 (20)
    xMOV_rm_r (rmIND8(rEDI),rEBP) xOFS8 (24)
    xMOV_rm_r (rmIND8(rEDI),rEAX) xOFS8 (28)

    /*
     * read tv0
     */
    if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_TEXCOORD0]))
    {
        DWORD ofs = index + pTriangleState->dwUVOffset[0] + 4;
        xMOV_r_rm (rEBX,rmIND8(rEDX)) xOFS8 (ofs)
    }
    else
    {
        xXOR_r_rm (rEBX,rmREG(rEBX))        // default tv0 = 0.0f
    }

    /*
     * read tu1, tv1
     */
    if (ilcFlags & FLAG_DX6)
    {
        DWORD dwTCIndex = pTriangleState->dwUVOffset[1] / (2*sizeof(D3DVALUE));
        DWORD dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        if (pContext->pCurrentVShader->bVAExists (dwVAIndex))
        {
            DWORD ofs = index + pTriangleState->dwUVOffset[1];
            xMOV_r_rm (rECX,rmIND8(rEDX)) xOFS8 (ofs)
            xMOV_r_rm (rEBP,rmIND8(rEDX)) xOFS8 (ofs + 4)
        }
        else
        {
            xXOR_r_rm (rECX,rmREG(rECX))        // default tu1 = 0.0f
            xXOR_r_rm (rEBP,rmREG(rEBP))        // default tv1 = 0.0f
        }
    }

    /*
     * write tv0, tu1, tv1
     */
    xMOV_rm_r (rmIND8(rEDI),rEBX) xOFS8 (32)
    if (ilcFlags & FLAG_DX6)
    {
        xMOV_rm_r (rmIND8(rEDI),rECX) xOFS8 (36)
        xMOV_rm_r (rmIND8(rEDI),rEBP) xOFS8 (40)
    }

vertexDone:
#if defined(DEBUG) || defined(NVSTATDRIVER)
    xPUSHAD
    xMOV_rm_imm (rmREG(rEBX),(DWORD)ILCDebug_showVertex)
    xLEA_r_rm   (rEAX,rmIND8(rEDI)) xOFS8(4)
    xPUSH_r     (rEAX)
    xCALL_rm    (rmREG(rEBX))
    xPOPAD
#endif

    /*
     * update pusher
     */
    xLEA_r_rm  (rEDI,rmIND8(rEDI)) xOFS8(size * 4) // update pusher base

    /*
     * done
     */
    if (bAllowVertexCache)
    {
        xMOV_i32_r (mMEM32(global.nvCachedPut),rEDI)
        xPOP_r     (rEDI)
    }
    else
    {
        if (dwArbitrationLevel == 2)
        {
            xMOV_i32_r (mMEM32(global.nvCachedPut),rEDI)
        }
    }
}

/*
 * ILCCompile_testCache
 *
 * test if the given index is in the vertex cache
 *   the index is used and if the cache is missed we branch to label.
 *   this code expects ILCCompile_missCache to reside at label
 *  - ecx has HW vc index on exit
 *  - ebx must have the post-arbitration index loaded on entry
 */
void ILCCompile_testCache
(
    DWORD indexAddress,
    DWORD label
)
{
    /*
     * get original index, or vc serial number and test for a cache hit
     */
    xMOV_r_i32   (rEAX,indexAddress)
    xOR_r_i32    (rEAX,mMEM32(global.dwVertexSN))
    xCMP_r_rm    (rEAX,rmSIB) xSIBID(rEBX,x4) xOFS32 (mMEM32(global.dwVertexCache)) // cmp eax,[vc + ebx*4]
    xJNZ32       (label)
    xMOV_r_rm    (rECX,rmREG(rEBX))
#ifdef CHECKVCTWICE
    xTARGET_b32  (label_cache)
#endif
}

/*
 * ILCCompile_missCache
 *
 * finish work on a cache miss. see ILCCompile_testCache
 * ebx has HW vertex location
 */
void ILCCompile_missCache
(
    void
)
{
    /*
     * setup cache variables
     */
#ifdef CHECKVCTWICE
    DWORD cacheSize = (ilcFlags & FLAG_DX6) ? 7 : 15;
    DWORD arbAdd    = (ilcFlags & FLAG_DX6) ? 3 : 7;
#endif

    /*
     * see if we missed because of arbitration (2% likelyhood)
     */
#ifdef CHECKVCTWICE
    xMOV_r_rm   (rECX,rmREG(rEBX))
    xADD_rm_imm (rmREG(rECX),arbAdd)
    xAND_rm_imm (rmREG(rECX),cacheSize)
    xCMP_r_rm   (rEAX,rmSIB) xSIBID(rECX,x4) xOFS32 (mMEM32(global.dwVertexCache)) // cmp eax,[vc + ecx*4]
    xLABEL      (label_cache)
    xJZ32       (0)
#endif

    /*
     * we really missed - load vertex
     */
    xMOV_rm_r   (rmSIB,rEAX) xSIBID(rEBX,x4) xOFS32 (mMEM32(global.dwVertexCache)) // mov [vc + ebx*4],eax
}

/*
 * ILCCompile_loadVertex
 *
 * loads a vertex unless it is already cached
 */
void ILCCompile_loadVertex
(
    PNVD3DCONTEXT pContext,
    DWORD vertex,
    DWORD vertexAddress,
    DWORD indexAddress,
    BOOL  bAllowVertexCache,
    DWORD dwArbitrationLevel    // 0 - none, 1 - check v0, 2 - check v0 & v1
)
{
    // setup cache variables
    DWORD cacheSize = (ilcFlags & FLAG_DX6) ? 7 : 15;
    DWORD arbAdd    = (ilcFlags & FLAG_DX6) ? 3 : 7;

    DWORD l1,l2;

    // check cache
    if (bAllowVertexCache)
    {
        // find index and map directly on to cache
        xMOV_r_i32   (rEBX,indexAddress)
        xAND_rm_imm  (rmREG(rEBX),cacheSize)

        /*
         * arbitrate vertex
         *  at this point ebx will has the intended index
         *  at exit it will have a valid and usable index
         */
        switch (dwArbitrationLevel)
        {
            case 1:
            {
                DWORD l1,l2;

                xMOV_r_rm   (rEAX,rmREG(rEDI))
                xSHR_rm_imm8(rmREG(rEAX),8)
                xLABEL      (l1)
                xJMP        (0)
                 xLABEL      (l2)
                 xADD_rm_imm (rmREG(rEBX),arbAdd)
                 xAND_rm_imm (rmREG(rEBX),cacheSize)
                xTARGET_jmp (l1)
                xCMP_r_rm   (rEAX,rmREG(rEBX))
                xJZ         (l2)
                break;
            }
            case 2:
            {
                DWORD l1,l2;

                xMOV_r_rm   (rECX,rmREG(rEDI))
                xMOV_r_rm   (rEAX,rmREG(rEDI))
                xSHR_rm_imm8(rmREG(rECX),4)
                xSHR_rm_imm8(rmREG(rEAX),8)
                xAND_rm_imm (rmREG(rECX),cacheSize)
                xLABEL      (l1)
                xJMP        (0)
                 xLABEL      (l2)
                 xADD_rm_imm (rmREG(rEBX),arbAdd)
                 xAND_rm_imm (rmREG(rEBX),cacheSize)
                xTARGET_jmp (l1)
                xCMP_r_rm   (rEAX,rmREG(rEBX))
                xJZ         (l2)
                xCMP_r_rm   (rECX,rmREG(rEBX))
                xJZ         (l2)
                break;
            }
        }

        // jump over copy code to the vertex cache hit test
        xLABEL (l1)
        xJMP   (0)

        // cache miss - prepare to copy
        xLABEL (l2)
        ILCCompile_missCache();
        xPUSH_r (rEBX)
    }

    // copy vertex
    ILCCompile_vertex (pContext, vertex, vertexAddress, bAllowVertexCache ? ~0/*ebx*/ : vertex,
                       bAllowVertexCache, dwArbitrationLevel, FALSE);

    // more cache checking
    if (bAllowVertexCache)
    {
        DWORD l3;
        xPOP_r      (rECX) // HW vc location
        xLABEL      (l3)
        xJMP        (0)
        xTARGET_jmp (l1)
        ILCCompile_testCache (indexAddress,l2); // ebx has post-arb index
        if ((dwArbitrationLevel == 0)
         && (ilcFlags & MASK_FOG)
         && (ilcFlags & FLAG_KATMAI))
        {
            xPUSH_r (rECX)
            ILCCompile_KatmaiFog(FALSE);
            xPOP_r  (rECX)
        }
        xTARGET_jmp (l3)

        // update launch code
        xSHL_rm_imm8(rmREG(rECX),8)
        xSHR_rm_imm8(rmREG(rEDI),4)
        xOR_r_rm    (rEDI,rmREG(rECX))
    }
}

#ifndef NOCOMPRESSOVERHEAD

/*
 * ILCCompile_testInLine
 *
 * tests whether two vertices can be loaded together
 */
void ILCCompile_testInLine
(
    DWORD index0,
    DWORD index1
)
{
    DWORD and = (ilcFlags & FLAG_DX6) ? 7 : 15;

    xMOV_r_i32  (rEAX,index0)
     xMOV_r_i32  (rEBX,index1)
    xAND_rm_imm (rmREG(rEAX),and)
     xAND_rm_imm (rmREG(rEBX),and)
    xSUB_r_rm   (rEBX,rmREG(rEAX))
}

/*
 * ILCCompile_testCached
 *
 * test if the given index is cached and then tag is as loaded
 */
void ILCCompile_testCached
(
    DWORD index
)
{
    DWORD and = (ilcFlags & FLAG_DX6) ? 7 : 15;

    xMOV_r_i32  (rEAX,index)
    xMOV_r_rm   (rEBX,rmREG(rEAX))
    xAND_rm_imm (rmREG(rEAX),and)
    xOR_r_i32   (rEBX,mMEM32(global.dwVertexSN))
    xCMP_r_rm   (rEBX,rmSIB) xSIBID(rEAX,x4) xOFS32 (mMEM32(global.dwVertexCache)) // cmp ebx,[vc + eax*4]
    xMOV_rm_r   (rmSIB,rEBX) xSIBID(rEAX,x4) xOFS32 (mMEM32(global.dwVertexCache)) // mov [vc + eax*4],ebx
}

/*
 * ILCCompile_loadTriangle
 *
 * loads a whole indexed triangle. tries to be smart about load overhead
 * - leaves launch code in edi
 */
void ILCCompile_loadTriangle
(
    void
)
{
    DWORD l00,l01,l02,l03,l04,l05,l06,l07;
    DWORD l08,l09,l10,l11,l12,l13;
    DWORD l20,l21,l22,l23,l24;
    DWORD and = (ilcFlags & FLAG_DX6) ? 7 : 15;

    /*
     * main test tree
     */
    ILCCompile_testInLine (mMEM32(global.dwIndex0),mMEM32(global.dwIndex1));
    xLABEL (l20)
    xJZ32  (0)
    xDEC_rm (rmREG(rEBX))
    xLABEL (l00)
    xJNZ32 (0)

    ILCCompile_testInLine (mMEM32(global.dwIndex1),mMEM32(global.dwIndex2));
    xLABEL (l21)
    xJZ32  (0)
    xDEC_rm (rmREG(rEBX))
    xLABEL (l01)
    xJNZ32 (0)

    ILCCompile_testCached (mMEM32(global.dwIndex1));
    xLABEL (l03)
    xJZ32 (0)

    ILCCompile_testCached (mMEM32(global.dwIndex0));
    xLABEL (l02)
    xJZ32 (0)

    ILCCompile_testCached (mMEM32(global.dwIndex2));
    xLABEL (l04)
    xJZ32 (0)

    /*
     * 1,2,3
     */
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex0))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xMOV_r_rm   (rEDI,rmREG(rEBX))
    xINC_rm     (rmREG(rEAX))
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    xADD_rm_imm (rmREG(rEAX),16)
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (0,mMEM32(global.dwVertex0),0x80000003,TRUE,0,FALSE);
    ILCCompile_vertex (1,mMEM32(global.dwVertex1),0xfffffffe,TRUE,0,FALSE);
    ILCCompile_vertex (2,mMEM32(global.dwVertex2),0xfffffffe,TRUE,0,FALSE);
    xLABEL (l05)
    xJMP   (0)

    /*
     * second test tree
     */
    xTARGET_b32 (l00)

    ILCCompile_testInLine (mMEM32(global.dwIndex1),mMEM32(global.dwIndex2));
    xLABEL (l22)
    xJZ32  (0)
    xDEC_rm (rmREG(rEBX))
    xLABEL (l06)
    xJNZ32 (0)

    xTARGET_b32 (l02)

    ILCCompile_testCached (mMEM32(global.dwIndex1));
    xLABEL (l07)
    xJZ32 (0)

    ILCCompile_testCached (mMEM32(global.dwIndex2));
    xLABEL (l08)
    xJZ32 (0)

    /*
     * 1+2,3
     */
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex0))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEDI,rmREG(rEBX))
    ILCCompile_vertex (0,mMEM32(global.dwVertex0),0x80000001,TRUE,0,FALSE);
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex1))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    xADD_rm_imm (rmREG(rEAX),16)
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (1,mMEM32(global.dwVertex1),0x80000002,TRUE,0,FALSE);
    ILCCompile_vertex (2,mMEM32(global.dwVertex2),0xfffffffe,TRUE,0,FALSE);
    xLABEL (l09)
    xJMP   (0)

    /*
     * third test tree
     */
    xTARGET_b32 (l01)

    // v0 and v2 can still content - test & handle properly
    ILCCompile_testInLine (mMEM32(global.dwIndex0),mMEM32(global.dwIndex2));
    xLABEL (l24)
    xJZ32  (0)

    ILCCompile_testCached (mMEM32(global.dwIndex1));
    xLABEL (l11)
    xJZ32 (0)

    ILCCompile_testCached (mMEM32(global.dwIndex0));
    xLABEL (l10)
    xJZ32 (0)

    xTARGET_b32 (l04)

    /*
     * 1,2+3
     */
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex0))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xMOV_r_rm   (rEDI,rmREG(rEBX))
    xINC_rm     (rmREG(rEAX))
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (0,mMEM32(global.dwVertex0),0x80000002,TRUE,0,FALSE);
    ILCCompile_vertex (1,mMEM32(global.dwVertex1),0xfffffffe,TRUE,0,FALSE);
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex2))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xSHL_rm_imm8(rmREG(rEAX),8)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (2,mMEM32(global.dwVertex2),0x80000001,TRUE,0,FALSE);
    xLABEL (l12)
    xJMP   (0)

    /*
     * fourth test tree
     */
    xTARGET_b32 (l03)
    xTARGET_b32 (l06)
    xTARGET_b32 (l07)
    xTARGET_b32 (l08)
    xTARGET_b32 (l10)
    xTARGET_b32 (l11)

    // v0 and v2 can still content - test & handle properly
    ILCCompile_testInLine (mMEM32(global.dwIndex0),mMEM32(global.dwIndex2));
    xLABEL (l23)
    xJZ32  (0)

    /*
     * 1+2+3
     */
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex0))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEDI,rmREG(rEBX))
    ILCCompile_vertex (0,mMEM32(global.dwVertex0),0x80000001,TRUE,0,FALSE);
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex1))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (1,mMEM32(global.dwVertex1),0x80000001,TRUE,0,FALSE);
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex2))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xSHL_rm_imm8(rmREG(rEAX),8)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (2,mMEM32(global.dwVertex2),0x80000001,TRUE,0,FALSE);
    xLABEL (l13)
    xJMP   (0)

    /*
     * 1+2+3 with arbitration
     */
    xTARGET_b32 (l20)
    xTARGET_b32 (l21)
    xTARGET_b32 (l22)
    xTARGET_b32 (l23)
    xTARGET_b32 (l24)

    ILCCompile_loadVertex (0,mMEM32(global.dwVertex0),mMEM32(global.dwIndex0),TRUE,0);
    ILCCompile_loadVertex (1,mMEM32(global.dwVertex1),mMEM32(global.dwIndex1),TRUE,1);
    ILCCompile_loadVertex (2,mMEM32(global.dwVertex2),mMEM32(global.dwIndex2),TRUE,2);

    /*
     * done
     */
    xTARGET_jmp (l05)
    xTARGET_jmp (l09)
    xTARGET_jmp (l12)
    xTARGET_jmp (l13)
}

#endif // !NOCOMPRESSOVERHEAD

/*
 * ILCCompile_getFlatComponents
 *
 * load the appropriate flat shaded components. uses eax and ecx
 */
void ILCCompile_getFlatComponents
(
    PNVD3DCONTEXT pContext
)
{
    /*
     * flat shading always takes the 1st vertex unless it is a
     *  fan which takes the second
     */
    DWORD addr = (ISFAN(ilcFlags)) ? mMEM32(global.dwVertex1)
                                   : mMEM32(global.dwVertex0);

    if (pContext->pCurrentVShader->getFVF() & D3DFVF_DIFFUSE)
    {
        /*
         * load address
         */
        if (ISSTRIP(ilcFlags))
        {
            xMOV_r_i32  (rEAX,mMEM32(global.dwStripSense))
            xMOV_r_rm   (rEAX,rmIND32(rEAX)) xOFS32(addr)
        }
        else
        {
            xMOV_r_i32  (rEAX,addr)
        }
        /*
         * prepare color
         */
        xMOV_r_rm   (rECX,rmIND8(rEAX)) xOFS8(pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]))
        xMOV_i32_r  (mMEM32(global.dwFlatColor),rECX)
    }
    if (pContext->pCurrentVShader->getFVF() & D3DFVF_SPECULAR)
    {
        /*
         * load address if we do not have it yet
         */
        if (!(pContext->pCurrentVShader->getFVF() & D3DFVF_DIFFUSE))
        {
            if (ISSTRIP(ilcFlags))
            {
                xMOV_r_i32  (rEAX,mMEM32(global.dwStripSense))
                xMOV_r_rm   (rEAX,rmIND32(rEAX)) xOFS32(addr)
            }
            else
            {
                xMOV_r_i32  (rEAX,addr)
            }
        }
        /*
         * prepare specular
         */
        xMOV_r_rm   (rECX,rmIND8(rEAX)) xOFS8(pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]))
        xAND_rm_imm (rmREG(rECX),0x00ffffff)
        xMOV_i32_r  (mMEM32(global.dwFlatSpecular),rECX)
    }
}


/*
 * ILCCompile_specularCheck
 *
 * checks if we can disable HW specular if primitives do not use it
 */
void ILCCompile_specularCheck
(
    PNVD3DCONTEXT pContext
)
{
    BOOL  bAlwaysOff = !(pContext->pCurrentVShader->getFVF() & D3DFVF_SPECULAR);
    DWORD l1,l2,l3;
#ifdef SPECULARPERFORMANCEFIX
    DWORD l4;
#endif

    /*
     * get specular components
     */
    if (!bAlwaysOff)
    {
        xMOV_r_i32   (rEAX,mMEM32(global.dwVertex0))
        xMOV_r_i32   (rEBX,mMEM32(global.dwVertex1))
        xMOV_r_i32   (rECX,mMEM32(global.dwVertex2))
        xMOV_r_rm    (rEAX,rmIND8(rEAX)) xOFS8 (pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]))
        xOR_r_rm     (rEAX,rmIND8(rEBX)) xOFS8 (pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]))
        xOR_r_rm     (rEAX,rmIND8(rECX)) xOFS8 (pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]))
        xTEST_rm_imm (rmREG(rEAX),0x00fcfcfc)
        xLABEL       (l1)
        xJZ          (0)    // no specular

#ifdef SPECULARPERFORMANCEFIX
        //short circuit the setting of specular on if it is already on
        xMOV_r_i32   (rEAX,mMEM32(global.dwSpecularState))
        xTEST_rm_imm (rmREG(rEAX),0x00000001)
        xLABEL       (l4)
        xJNZ         (0)
        /*
         * turn specular on & reset threshold
         */
        xMOV_r_i32   (rEAX,mMEM32(global.nvCachedPut))
        xMOV_r_i32   (rEBX,mMEM32(global.dwBlendRegister))
        xMOV_rm_imm  (rmREG(rECX),((1<<2)<<16) | (NV_DD_SPARE<<13) | NV054_BLEND)
        xMOV_rm_r    (rmIND(rEAX),rECX)
        xLEA_r_rm    (rEAX,rmIND8(rEAX)) xOFS8(8)
        xMOV_rm_r    (rmIND8(rEAX),rEBX) xOFS8(-4)
        xMOV_i32_r   (mMEM32(global.nvCachedPut),rEAX)
        xMOV_rm_imm  (rmREG(rEBX),1)
        xMOV_i32_r   (mMEM32(global.dwSpecularState),rEBX)
        xTARGET_b8   (l4)
        xMOV_rm_imm  (rmREG(rEBX),5)
        xMOV_i32_r   (mMEM32(global.dwSpecularCount),rEBX)

        xLABEL       (l2)
        xJMP         (0)
#else
        xMOV_r_i32   (rEAX,mMEM32(global.nvCachedPut))
        xMOV_r_i32   (rEBX,mMEM32(global.dwBlendRegister))
        xMOV_rm_imm  (rmREG(rECX),((1<<2)<<16) | (NV_DD_SPARE<<13) | NV054_BLEND)
        xMOV_rm_r    (rmIND(rEAX),rECX)
        xLEA_r_rm    (rEAX,rmIND8(rEAX)) xOFS8(8)
        xMOV_rm_r    (rmIND8(rEAX),rEBX) xOFS8(-4)
        xMOV_i32_r   (mMEM32(global.nvCachedPut),rEAX)
        xMOV_rm_imm  (rmREG(rEBX),5)
        xMOV_i32_r   (mMEM32(global.dwSpecularCount),rEBX)

        xLABEL       (l2)
        xJMP         (0)
#endif
        /*
         * decrement threshold
         */
        xTARGET_b8 (l1)
        xMOV_r_i32 (rEAX,mMEM32(global.dwSpecularCount))
        xDEC_rm    (rmREG(rEAX))
        xMOV_i32_r (mMEM32(global.dwSpecularCount),rEAX)
        xLABEL     (l3)
        xJNZ       (0)
    }

    /*
     * turn specular off
     */
    xMOV_r_i32   (rEAX,mMEM32(global.nvCachedPut))
    xMOV_r_i32   (rEBX,mMEM32(global.dwBlendRegister))
    xMOV_rm_imm  (rmREG(rECX),((1<<2)<<16) | (NV_DD_SPARE<<13) | NV054_BLEND)
    xAND_rm_imm  (rmREG(rEBX),0xffff0fff)
    xMOV_rm_r    (rmIND(rEAX),rECX)
    xLEA_r_rm    (rEAX,rmIND8(rEAX)) xOFS8(8)
    xMOV_rm_r    (rmIND8(rEAX),rEBX) xOFS8(-4)
    xMOV_i32_r   (mMEM32(global.nvCachedPut),rEAX)
#ifdef SPECULARPERFORMANCEFIX
    xMOV_rm_imm  (rmREG(rEBX),0)
    xMOV_i32_r   (mMEM32(global.dwSpecularState),rEBX)
#endif

    if (!bAlwaysOff)
    {
        xTARGET_b8  (l3)
        xTARGET_jmp (l2)
    }
}

/*
 * ILCCompile_cullcheck
 *
 * do a cull check on the triangle loaded in dwVertex0..2
 * code ends with the z flag set to indicate culled (do not draw)
 */
void ILCCompile_cullcheck
(
    void
)
{
    /*
     * compute cross product
     */
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        /*
         * katmai
         */
        xMOV_r_i32       (rEAX,mMEM32(global.dwVertex0))
        xMOV_r_i32       (rEBX,mMEM32(global.dwVertex1))
        xMOV_r_i32       (rECX,mMEM32(global.dwVertex2))

        xMOVLPS_r_rm     (rXMM0,rmIND(rEAX))
        xMOVLPS_r_rm     (rXMM1,rmIND(rEBX))
        xSHUFPS_r_rm_imm (rXMM0,rmREG(rXMM0),0x44)          // xmm0: y0     x0      y0      x0
        xMOVHPS_r_rm     (rXMM1,rmIND(rECX))                // xmm1: y2     x2      y1      x1

        xSUBPS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: y2-y0  x2-x0   y1-y0   x1-x0
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: y2-y0  x2-x0   x1-x0   y1-y0

        xMOVHLPS_r_r     (rXMM0,rXMM1)                      // xmm0: ?      ?       y2-y0   x2-x0
        xMULPS_r_rm      (rXMM0,rmREG(rXMM1))               // xmm0: ?      ?       (x1-x0)*(y2-y0) (y1-y0)*(x2-x0)

        xMOVAPS_r_rm     (rXMM1,rmREG(rXMM0))
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)

        xSUBSS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)-(y1-y0)*(x2-x0)
        xMOVSS_i32_r     (mMEM32(global.dwTemp),rXMM1)
        xMOV_r_i32       (rEAX,mMEM32(global.dwTemp))
        xXOR_r_i32       (rEAX,mMEM32(global.dwCullMask1))
        xTEST_r_i32      (rEAX,mMEM32(global.dwCullMask2))
    }
    else
#if 0
// Not ready yet -- NickT
    if (global.dwCPUFeatureSet & FS_3DNOW)
    {
        /*
         * 3dnow
         */
        xMOV_r_i32(rEAX,mMEM32(global.dwVertex0))
        xMOV_r_i32(rEBX,mMEM32(global.dwVertex1))
        xMOV_r_i32(rECX,mMEM32(global.dwVertex2))

        xFEMMS                                      // Switch to 3dnow mode

        xMOVQ_r_rm(rMM0,rmIND(rEAX))                // mm0 =             Y0|X0
        xMOVQ_r_rm(rMM1,rmIND(rEBX))                // mm1 =             Y1|X1
        xMOVQ_r_rm(rMM2,rmIND(rECX))                // mm2 =             Y2|X2

        xPFSUB_r_rm(rMM1,rmREG(rMM0))               // mm1 =          Y1-Y0|X1-X0
        xPFSUB_r_rm(rMM2,rmREG(rMM0))               // mm2 =          Y2-Y0|X1-X0
        xMOVQ_r_rm(rMM0,rmREG(rMM1))                // mm0 =          Y1-Y0|X1-X0

        xPUNPCKLDQ_r_rm(rMM1,rmREG(rMM1))           // mm1 =          X1-X0|X1-Y0
        xPUNPCKHDQ_r_rm(rMM0,rmREG(rMM1))           // mm0 =          X1-X0|Y1-Y0

        xPFMUL_r_rm(rMM0,rmREG(rMM2))               // mm0 = (X1-X0)(Y2-Y0)|(Y1-Y0)(X2-X0)
        xMOVQ_r_rm(rMM1,rmREG(rMM0))                // mm1 = (X1-X0)(Y2-Y0)|(Y1-Y0)(X2-X0)

        xPUNPCKHDQ_r_rm(rMM1,rmREG(rMM1))           // mm1 =           xxxx|(X1-X0)(Y2-Y0)
        xPFSUB_r_rm(rMM1,rmREG(rMM0))               // mm1 =           xxxx|(X1-X0)(Y2-Y0)-(Y1-Y0)(X2-X0)

        xMOVD_r_rm(rEAX,rmREG(rMM1))                // EAX = (X1-X0)(Y2-Y0)-(Y1-Y0)(X2-X0)

        xFEMMS                                      // Switch out of 3dnow mode

        xXOR_r_i32 (rEAX,mMEM32(global.dwCullMask1))
        xTEST_r_i32(rEAX,mMEM32(global.dwCullMask2))
    }
    else
#endif
    {
        /*
         * generic
         */
        xMOV_r_i32 (rEAX,mMEM32(global.dwVertex0))  //
        xFLD_rm32  (rmIND(rEAX))                    // X0
        xMOV_r_i32 (rEBX,mMEM32(global.dwVertex1))  //
        xFLD_rm32  (rmIND(rEBX))                    // X1 | X0
        xFXCH_st   (rST1)                           // X0 | X1
        xFSUBP_st  (rST1)                           // X1-X0
        xMOV_r_i32 (rECX,mMEM32(global.dwVertex2))  //
        xFLD_rm32  (rmIND8(rECX)) xOFS8(4)          // Y2 | X1-X0
        xFXCH_st   (rST1)                           // X1-X0 | Y2
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | X1-X0 | Y2
        xFXCH_st   (rST1)                           // X1-X0 | Y0 | Y2
        xFLD_rm32  (rmIND(rECX))                    // X2 | X1-X0 | Y0 | Y2
        xFXCH_st   (rST3)                           // Y2 | X1-X0 | Y0 | X2
        xFLD_rm32  (rmIND(rEAX))                    // X0 | Y2 | X1-X0 | Y0 | X2
        xFXCH_st   (rST3)                           // Y0 | Y2 | X1-X0 | X0 | X2
        xFSUBP_st  (rST1)                           // Y2-Y0 | X1-X0 | X0 | X2
        xFXCH_st   (rST3)                           // X2 | X1-X0 | X0 | Y2-Y0
        xFLD_rm32  (rmIND8(rEBX)) xOFS8(4)          // Y1 | X2 | X1-X0 | X0 | Y2-Y0
        xFXCH_st   (rST3)                           // X0 | X2 | X1-X0 | Y1 | Y2-Y0
        xFSUBP_st  (rST1)                           // X2-X0 | X1-X0 | Y1 | Y2-Y0
        xFXCH_st   (rST3)                           // Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFXCH_st   (rST2)                           // X1-X0 | Y2-Y0 | Y0 | Y1 | X2-X0
        xFMULP_st  (rST1)                           // (X1-X0)(Y2-Y0) | Y0 | Y1 | X2-X0
        xFXCH_st   (rST1)                           // Y0 | (X1-X0)(Y2-Y0) | Y1 | X2-X0
        xFSUBP_st  (rST2)                           // (X1-X0)(Y2-Y0) | Y1-Y0 | X2-X0
        xFXCH_st   (rST2)                           // X2-X0 | Y1-Y0 | (X1-X0)(Y2-Y0)
        xFMULP_st  (rST1)                           // (X2-X0)(Y1-Y0) | (X1-X0)(Y2-Y0)
        xFSUBP_st  (rST1)                           // (X1-X0)(Y2-Y0)-(X2-X0)(Y1-Y0)
        xFSTP_i32  (mMEM32(global.dwTemp))
        xMOV_r_i32 (rEAX,mMEM32(global.dwTemp))
        xXOR_r_i32 (rEAX,mMEM32(global.dwCullMask1))
        xTEST_r_i32(rEAX,mMEM32(global.dwCullMask2))
    }
}

void ILCCompile_GetSpace (void)
{
#ifndef NV_NULL_HW_DRIVER
    getDC()->nvPusher.setPut (global.nvCachedPut);
#endif
    nvPusherAdjust (0);
    global.nvCachedPut       = getDC()->nvPusher.getPut();
    global.nvCachedThreshold = getDC()->nvPusher.getThreshold();
}


/*
 * ILCCompileCode
 *
 * Returns the entry point of a loop that will emit triangles in the format
 * specified. fvfData is implicitly passed
 */
DWORD ILCCompileCode
(
    PNVD3DCONTEXT pContext,
    DWORD dwFlags
)
{
    DWORD label_entry;
    DWORD label_outerLoop;
    DWORD label_innerLoop;
    DWORD label_reserveSpace1;
    DWORD label_reserveSpace2;
    DWORD label_reserveSpace3;
    DWORD label_tri;
    DWORD label_quad;
    DWORD label_exit;
#ifndef NOSKIP
    DWORD label_skipFetch;
#endif
    DWORD label_culled;

#ifdef NOVERTEXCACHE
    BOOL  bAllowVertexCache = FALSE;
#else
    BOOL  bAllowVertexCache = (dwFlags & FLAG_FLAT) ? FALSE : TRUE;
#endif

    /*
     * setup
     */
    ilcFlags = dwFlags;

    /*------------------------------------------------------------------------
     * entry
     *-----------------------------------------------------------------------*/

    /*
     * align entry point
     */
    while (ilcCount & 31) { xINT3 }
    xLABEL (label_entry)

/*
if (ilcFlags == 0x30001018) { xINT3 }
/**/

    /*
     * save important registers
     */
    xPUSH_r (rEBX)
    xPUSH_r (rESI)
    xPUSH_r (rEDI)
    xPUSH_r (rEBP)

    /*
     * break into special cases
     */
#ifndef NOSPECIALCASE
    xMOV_r_i32  (rEDI,mMEM32(global.dwPrimCount))
    xCMP_rm_imm (rmREG(rEDI),1)
    xLABEL      (label_tri)
    xJZ32       (0)
    if (!ISLIST(ilcFlags) && !(ilcFlags & FLAG_FLAT))
    {
        xCMP_rm_imm (rmREG(rEDI),2)
        xLABEL      (label_quad)
        xJZ32       (0)
    }
#endif

    /*
     * zero out some values
     */
    xXOR_r_rm  (rEAX,rmREG(rEAX))
    xMOV_i32_r (mMEM32(global.dwStripSense),rEAX)

    /*
     * invalidate vertex cache
     */
    xMOV_r_i32 (rEAX,(DWORD)&global.dwVertexSN)
    xADD_rm_imm(rmREG(rEAX),0x10000)
    xMOV_i32_r ((DWORD)&global.dwVertexSN,rEAX)

    /*
     * setup outer loop
     */
    if (ISLIST(ilcFlags))
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * do nothing
             */
        }
        else
        {
            /*
             * setup first three vertices and indices
             */
            xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)

            bAllowVertexCache = FALSE;
        }
    }
    else
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * setup first two indices and vertices
             */
            xMOV_r_i32  (rEAX,mMEM32(global.pIndices))
            xMOV_r_rm   (rEBX,rmIND(rEAX))
            xMOV_r_rm   (rECX,rmREG(rEBX))
            xSHR_rm_imm8(rmREG(rECX),16)
            xMOV_i32_r  (mMEM32(global.dwIndex1),rECX)
            ILCCompile_mul (rECX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rECX);
#endif
            xMOV_r_i32  (rEDX,mMEM32(global.pVertices))
            xAND_rm_imm (rmREG(rEBX),0xffff)
            xMOV_i32_r (mMEM32(global.dwIndex0),rEBX)
            ILCCompile_mul (rEBX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEBX);
#endif
            xLEA_r_rm   (rEBX,rmSIB) xSIB(rEBX,rEDX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEBX)
            xLEA_r_rm   (rEAX,rmIND8(rEAX)) xOFS8(4)
            xLEA_r_rm   (rECX,rmSIB) xSIB(rECX,rEDX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex1),rECX)
            xMOV_i32_r  (mMEM32(global.pIndices),rEAX)
        }
        else
        {
            /*
             * setup all indices and vertices
             */
            xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)

            xXOR_r_rm  (rEAX,rmREG(rEAX))
            xMOV_i32_r (mMEM32(global.dwIndex0),rEAX)
            xINC_rm    (rmREG(rEAX))
            xMOV_i32_r (mMEM32(global.dwIndex1),rEAX)
            xINC_rm    (rmREG(rEAX))
            xMOV_i32_r (mMEM32(global.dwIndex2),rEAX)
        }
    }

    /*------------------------------------------------------------------------
     * outer loop
     *-----------------------------------------------------------------------*/

    xMOV_r_i32  (rEAX,mMEM32(global.dwPrimCount))
    label_outerLoop = ilcCount;

    /*
     * figure out how many primitives to put in a batch
     *  - dwPrimBatchCount = min(n, dwPrimCount)
     *     with n = (prim is list) ? 32 : 96
     *  - dwPrimCount -= dwPrimBatchCount
     *  - if it is less than 8 prims, we do not bother prefetching
     *  - edi still has primcount from tri & quad check above
     */
#ifndef NOSKIP
    {
        DWORD skipAmount = 8;

        xMOV_i32_r  (mMEM32(global.dwPrimBatchCount),rEDI)
        xXOR_r_rm   (rEAX,rmREG(rEAX))
        xCMP_rm_imm (rmREG(rEDI),skipAmount)
        xSETLE_rm8  (rmREG(rAL))
        xDEC_rm     (rmREG(rEAX))
        xAND_r_i32  (rEAX,mMEM32(global.dwPrimCount))
        xCMP_rm_imm (rmREG(rEDI),skipAmount)
        xMOV_i32_r  (mMEM32(global.dwPrimCount),rEAX)
        xLABEL      (label_skipFetch)
        xJLE32      (0)
    }
#endif
    {
        DWORD n = ISLIST(ilcFlags) ? 32 : 96;

        xXOR_r_rm   (rEBX,rmREG(rEBX))
        xCMP_rm_imm (rmREG(rEAX),n)
        xLEA_r_rm   (rEAX,rmIND8(rEAX)) xOFS8(-(int)n)  // eax = count - n
        xSETG_rm8   (rmREG(rBL))                        // ebx = count > n ? 1 : 0
        xDEC_rm     (rmREG(rEBX))                       // ebx = count > n ? 0 : ~0
        xAND_r_rm   (rEBX,rmREG(rEAX))                  // ebx = count > n ? 0 : count - n
        xADD_rm_imm (rmREG(rEBX),n)                     // ebx = count > n ? n : count
        xMOV_i32_r  (mMEM32(global.dwPrimBatchCount),rEBX)
        xNEG_rm     (rmREG(rEBX))
        xLEA_r_rm   (rmREG(rEAX),rmSIB8) xSIB(rEAX,rEBX,x1) xOFS8(n)
        xMOV_i32_r  (mMEM32(global.dwPrimCount),rEAX)
    }

    /*------------------------------------------------------------------------
     * fetcher
     *-----------------------------------------------------------------------*/

    /*
     * compute # of vertices involved in batch
     *  - this is 3 * dwPrimBatchCount for normal lists,
     *    and dwPrimBatchCount for strip & fans
     *  - result is in edx
     */
    xMOV_r_i32 (rEDX,mMEM32(global.dwPrimBatchCount))
    if (ISLIST(ilcFlags))
    {
        xLEA_r_rm (rEDX,rmSIB) xSIB(rEDX,rEDX,x2)
    }

    /*
     * fetch into L1
     *  - fetch indices first if we have indexed primitives
     */
    if (ilcFlags & FLAG_INDEXED)
    {
        DWORD l1,l2;
        DWORD i,j;

        /*
         * touch indices
         */
        if (ISLEGACY(ilcFlags))
        {
            xMOV_r_i32  (rECX,mMEM32(global.dwPrimBatchCount))
            xSHL_rm_imm8(rmREG(rECX),2)
        }
        else
        {
            xLEA_r_rm (rECX,rmSIB) xSIB(rEDX,rEDX,x1)
        }
        xMOV_r_i32  (rEBX,mMEM32(global.pIndices))
        xLABEL      (l1)
         xCMP_rm_imm (rmREG(rECX),4)
         xLABEL      (l2)
         xJL         (0)
         xMOV_r_rm   (rEAX,rmIND(rEBX))
         xSUB_rm_imm (rmREG(rECX),32)
         xLEA_r_rm   (rEBX,rmIND8(rEBX)) xOFS8(32)
        xJNZ        (l1)
        xTARGET_b8  (l2)

        /*
         * touch vertices
         */
        xMOV_r_i32  (rEBX,mMEM32(global.pIndices))
        xMOV_r_i32  (rECX,mMEM32(global.pVertices))
        xLABEL      (l1)
         xXOR_r_rm   (rEAX,rmREG(rEAX))
    x16r xMOV_r_rm   (rAX,rmIND(rEBX))
         xLEA_r_rm   (rEBX,rmIND8(rEBX)) xOFS8(2)
        ILCCompile_mul (rEAX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
         ILCCompile_checkValid (rEAX);
#endif
         xDEC_rm     (rmREG(rEDX))
         xMOV_r_rm   (rEBP,rmSIB) xSIB(rEAX,rECX,x1)
         i = pContext->pCurrentVShader->getStride();
         j = 32;
         while (i > 32)
         {
            xMOV_r_rm   (rEBP,rmSIB8) xSIB(rEAX,rECX,x1) xOFS8(j)
            j += 32;
            i -= 32;
         }
        xJNZ32 (l1)
    }
    else
    {
        DWORD l1,l2;

        /*
         * touch vertices
         */
        xMOV_r_i32  (rECX,mMEM32(global.pVertices))
        ILCCompile_mul (rEDX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
        ILCCompile_checkValid (rEDX);
#endif
        xLABEL      (l1)
         xCMP_rm_imm (rmREG(rEDX),4)
         xLABEL      (l2)
         xJL         (0)
         xMOV_r_rm   (rEAX,rmIND(rECX))
         xSUB_rm_imm (rmREG(rEDX),32)
         xLEA_r_rm   (rECX,rmIND8(rECX)) xOFS8(32)
        xJNZ        (l1)
        xTARGET_b8  (l2)
    }

    /*------------------------------------------------------------------------
     * pusher
     *-----------------------------------------------------------------------*/
#ifndef NOSKIP
    xTARGET_b32 (label_skipFetch)
#endif

    /*
     * inner loop start
     */
    xLABEL (label_innerLoop)

    /*
     * use indices to generate vertex addresses
     */
    if (ISLIST(ilcFlags))
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * load indices and compute vertex addresses
             *  - read 3 indices and compute vertex = base + index * stride
             *  - increment pIndices
             */
            xMOV_r_i32  (rEBX,mMEM32(global.pIndices))
            xMOV_r_rm   (rECX,rmIND(rEBX))
            xMOV_r_rm   (rEDX,rmREG(rECX))
            xAND_rm_imm (rmREG(rECX),0xffff)
            xMOV_i32_r  (mMEM32(global.dwIndex0),rECX)
            xSHR_rm_imm8(rmREG(rEDX),16)
            xMOV_i32_r  (mMEM32(global.dwIndex1),rEDX)
            ILCCompile_mul (rECX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rECX);
#endif
            xMOV_r_rm   (rEAX,rmIND8(rEBX)) xOFS8 (4)
            xLEA_r_rm   (rEBX,rmIND8(rEBX)) xOFS8 (ISLEGACY(ilcFlags) ? 8 : 6)
            xAND_rm_imm (rmREG(rEAX),0xffff)
            xMOV_i32_r  (mMEM32(global.pIndices),rEBX)
            ILCCompile_mul (rEDX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEDX);
#endif
            xMOV_i32_r  (mMEM32(global.dwIndex2),rEAX)
            ILCCompile_mul (rEAX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEAX);
#endif
            xMOV_r_i32  (rEBX,mMEM32(global.pVertices))
            xLEA_r_rm   (rECX,rmSIB) xSIB(rECX,rEBX,x1)
            xLEA_r_rm   (rEDX,rmSIB) xSIB(rEDX,rEBX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex0),rECX)
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rEAX,rEBX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex1),rEDX)
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)
        }
        else
        {
            /*
             * do nothing
             */
        }
    }
    else
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * load index for third vertex
             */
            xXOR_r_rm   (rECX,rmREG(rECX))
            xMOV_r_i32  (rEBX,mMEM32(global.pIndices))
       x16r xMOV_r_rm   (rCX,rmIND(rEBX))
            xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
            xLEA_r_rm   (rEBX,rmIND8(rEBX)) xOFS8 (2)
            xMOV_i32_r  (mMEM32(global.dwIndex2),rECX)
            ILCCompile_mul (rECX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rECX);
#endif
            xMOV_i32_r  (mMEM32(global.pIndices),rEBX)
            xLEA_r_rm   (rECX,rmSIB) xSIB(rEAX,rECX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex2),rECX)
        }
        else
        {
            /*
             * do nothing
             */
        }
    }

    /*
     * reserve space in push buffer
     *  - always make space for 4 full dx6 triangles at a time
     *  - this will save on overhead when put chases get
     */
    {
        DWORD l1;

        xMOV_r_i32  (rEAX,mMEM32(global.nvCachedThreshold))
        xMOV_r_i32  (rECX,mMEM32(global.nvCachedPut))
        xMOV_r_i32  (rEBX,mMEM32(ilcData))
        xLABEL      (l1)
        xADD_rm_imm (rmREG(rEBX),0)
        xCMP_r_rm   (rECX,rmREG(rEAX))
        xLABEL      (label_reserveSpace1)
        xJGE32      (0)
        *(DWORD*)(ilcData + l1 + 2) = ilcCount;
    }

    /*
     * copy data to pushbuffer
     *  - we use the vertex cache if we can
     *  - edi will contain the launch codes
     */
    if (bAllowVertexCache)
    {
        xXOR_r_rm (rEDI,rmREG(rEDI))
    }

    /*
     * do cull check
     */
#ifndef NOCULLING
    ILCCompile_cullcheck();
    xLABEL (label_culled)
    xJZ32  (0)
#endif

    //
    // MUSH
    //

    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_MUSH)
    {
        xFLD_i32  (mMEM32(global.dwTemp))
        xFADD_i32 (mMEM32(global.fTotalPixelsTimes2))
        xFSTP_i32 (mMEM32(global.fTotalPixelsTimes2))
    }

    /*
     * get flat shaded colors
     */
    if (ilcFlags & FLAG_FLAT)
    {
        ILCCompile_getFlatComponents (pContext);
    }

    /*
     * check specular
     */
    if (!(ilcFlags & FLAG_DX6) && (ilcFlags & FLAG_SPECULAR))
    {
        ILCCompile_specularCheck (pContext);
    }

    /*
     * copy
     */
#ifndef NOCOMPRESSOVERHEAD
    if (bAllowVertexCache)
    {
        ILCCompile_loadTriangle();
    }
    else
    {
#endif //!NOCOMPRESSOVERHEAD
        ILCCompile_loadVertex (pContext,0,mMEM32(global.dwVertex0),mMEM32(global.dwIndex0),bAllowVertexCache,0);
        ILCCompile_loadVertex (pContext,1,mMEM32(global.dwVertex1),mMEM32(global.dwIndex1),bAllowVertexCache,1);
        ILCCompile_loadVertex (pContext,2,mMEM32(global.dwVertex2),mMEM32(global.dwIndex2),bAllowVertexCache,2);
#ifndef NOCOMPRESSOVERHEAD
    }
#endif //!NOCOMPRESSOVERHEAD

    /*
     * launch triangle
     */
#ifndef NOLAUNCH
    xMOV_r_i32  (rEBX,mMEM32(global.nvCachedPut))
    if (!bAllowVertexCache)
    {
        xMOV_rm_imm (rmREG(rEDI),0x210)
    }
    xMOV_rm_imm (rmREG(rEAX),((ilcFlags & FLAG_DX6) ? 0x0004e540 : 0x0004e600))
    xMOV_rm_r   (rmIND(rEBX),rEAX)
    xLEA_r_rm   (rEBX,rmIND8(rEBX)) xOFS8(8)
    xMOV_rm_r   (rmIND8(rEBX),rEDI) xOFS8(-4)
    xMOV_i32_r  (mMEM32(global.nvCachedPut),rEBX)
#endif
#ifdef DEBUG
    xPUSHAD
    xMOV_rm_imm (rmREG(rEBX),(DWORD)ILCDebug_flushTriangle)
    xCALL_rm    (rmREG(rEBX))
    xPOPAD
#endif

#ifndef NOCULLING
    xTARGET_b32 (label_culled)
#endif

    /*
     * update indices and vertices for next primitive
     */
    if (ISLIST(ilcFlags))
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * do nothing
             */
        }
        else
        {
            /*
             * update vertices
             */
            xMOV_r_i32  (rEAX,mMEM32(global.dwVertex2))
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)
        }
    }
    else
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            if (ISSTRIP(ilcFlags))
            {
                /*
                 * update strip for culling sense
                 */
                xMOV_r_i32  (rEBX,mMEM32(global.dwStripSense))
                xMOV_r_i32  (rEAX,mMEM32(global.dwVertex2))
                xMOV_rm_r   (rmIND32(rEBX),rEAX) xOFS32(mMEM32(global.dwVertex0))

                xMOV_r_i32  (rEAX,mMEM32(global.dwIndex2))
                xMOV_rm_r   (rmIND32(rEBX),rEAX) xOFS32(mMEM32(global.dwIndex0))
                xXOR_rm_imm (rmREG(rEBX),4)
                xMOV_i32_r  (mMEM32(global.dwStripSense),rEBX)
            }
            else
            {
                /*
                 * update indices and vertices for fan
                 */
                xMOV_r_i32  (rEAX,mMEM32(global.dwVertex2))
                xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)

                xMOV_r_i32  (rEAX,mMEM32(global.dwIndex2))
                xMOV_i32_r  (mMEM32(global.dwIndex1),rEAX)
            }
        }
        else
        {
            if (ISSTRIP(ilcFlags))
            {
                /*
                 * update indices and vertices for strip
                 */
                xMOV_r_i32  (rEBX,mMEM32(global.dwStripSense))
                xMOV_r_i32  (rEAX,mMEM32(global.dwVertex2))
                xMOV_rm_r   (rmIND32(rEBX),rEAX) xOFS32(mMEM32(global.dwVertex0))
                xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
                xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)

                xMOV_r_i32  (rEAX,mMEM32(global.dwIndex2))
                xMOV_rm_r   (rmIND32(rEBX),rEAX) xOFS32(mMEM32(global.dwIndex0))
                xINC_rm     (rmREG(rEAX))
                xXOR_rm_imm (rmREG(rEBX),4)
                xMOV_i32_r  (mMEM32(global.dwIndex2),rEAX)
                xMOV_i32_r  (mMEM32(global.dwStripSense),rEBX)
            }
            else
            {
                /*
                 * update indices and vertices for fan
                 */
                xMOV_r_i32  (rEAX,mMEM32(global.dwVertex2))
                xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
                xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
                xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)

                xMOV_r_i32  (rEAX,mMEM32(global.dwIndex2))
                xMOV_i32_r  (mMEM32(global.dwIndex1),rEAX)
                xINC_rm     (rmREG(rEAX))
                xMOV_i32_r  (mMEM32(global.dwIndex2),rEAX)
            }
        }
    }

    /*
     * loop back for next primitive
     */
    xMOV_r_i32 (rEAX,mMEM32(global.dwPrimBatchCount))
    xDEC_rm    (rmREG(rEAX))
    xMOV_i32_r (mMEM32(global.dwPrimBatchCount),rEAX)
    xJNZ32     (label_innerLoop)

    /*
     * loop back for next batch
     */
    xMOV_r_i32 (rEAX,mMEM32(global.dwPrimCount))
    xTEST_r_rm (rEAX,rmREG(rEAX))
    xJNZ32     (label_outerLoop) // eax has dwPrimCount loaded already

    /*------------------------------------------------------------------------
     * exit
     *-----------------------------------------------------------------------*/
    xLABEL     (label_exit)

    /*
     * reset HW specular state
     */
    if (!(ilcFlags & FLAG_DX6) && (ilcFlags & FLAG_SPECULAR))
    {
        /*
         * turn specular on
         */
        xMOV_r_i32   (rEAX,mMEM32(global.nvCachedPut))
        xMOV_r_i32   (rEBX,mMEM32(global.dwBlendRegister))
        xMOV_rm_imm  (rmREG(rECX),((1<<2)<<16) | (NV_DD_SPARE<<13) | NV054_BLEND)
        xMOV_rm_r    (rmIND(rEAX),rECX)
        xLEA_r_rm    (rEAX,rmIND8(rEAX)) xOFS8(8)
        xMOV_rm_r    (rmIND8(rEAX),rEBX) xOFS8(-4)
        xMOV_i32_r   (mMEM32(global.nvCachedPut),rEAX)
#ifdef SPECULARPERFORMANCEFIX
        xMOV_rm_imm  (rEAX,1)
        xMOV_i32_r   (mMEM32(global.dwSpecularState),rEAX)
#endif
    }

    /*
     * restore registers
     */
    xPOP_r (rEBP)
    xPOP_r (rEDI)
    xPOP_r (rESI)
    xPOP_r (rEBX)
    xRET

#ifndef NOSPECIALCASE
    /*------------------------------------------------------------------------
     * single triangle
     *-----------------------------------------------------------------------*/
    while (ilcCount & 31) { xINT3 }
    xTARGET_b32 (label_tri)

    /*
     * reserve space in push buffer
     *  - always make space for 4 full dx6 triangles at a time
     *  - this will save on overhead when put chases get
     */
    {
        DWORD l1;

        xMOV_r_i32  (rEAX,mMEM32(global.nvCachedThreshold))
        xMOV_r_i32  (rECX,mMEM32(global.nvCachedPut))
        xMOV_r_i32  (rEBX,mMEM32(ilcData))
        xLABEL      (l1)
        xADD_rm_imm (rmREG(rEBX),0)
        xCMP_r_rm   (rECX,rmREG(rEAX))
        xLABEL      (label_reserveSpace2)
        xJGE32      (0)
        *(DWORD*)(ilcData + l1 + 2) = ilcCount;
    }

    if (ilcFlags & FLAG_INDEXED)
    {
        /*
         * read indices and compute vertex offsets
         */
        xMOV_r_i32  (rEAX,mMEM32(global.pIndices))
        xMOV_r_rm   (rEBX,rmIND(rEAX))
        xMOV_r_rm   (rECX,rmREG(rEBX))
        xAND_rm_imm (rmREG(rEBX),0xffff)
        xSHR_rm_imm8(rmREG(rECX),16)
        xMOV_r_rm   (rEDX,rmIND8(rEAX)) xOFS8(4)
        ILCCompile_mul (rEBX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
        ILCCompile_checkValid (rEBX);
#endif
        ILCCompile_mul (rECX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
        ILCCompile_checkValid (rECX);
#endif
        xAND_rm_imm (rmREG(rEDX),0xffff)
        xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
        ILCCompile_mul (rEDX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
        ILCCompile_checkValid (rEDX);
#endif
        xLEA_r_rm   (rEBX,rmSIB) xSIB(rEBX,rEAX,x1)
        xMOV_i32_r  (mMEM32(global.dwVertex0),rEBX)
        xMOV_r_rm   (rEBX,rmIND(rEBX))
        xLEA_r_rm   (rECX,rmSIB) xSIB(rECX,rEAX,x1)
        xMOV_i32_r  (mMEM32(global.dwVertex1),rECX)
        xMOV_r_rm   (rEBX,rmIND(rECX))
        xLEA_r_rm   (rEDX,rmSIB) xSIB(rEDX,rEAX,x1)
        xMOV_i32_r  (mMEM32(global.dwVertex2),rEDX)
        xMOV_r_rm   (rEBX,rmIND(rEDX))
    }
    else
    {
        /*
         * compute vertex offsets
         */
        xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
        xMOV_i32_r  (mMEM32(global.dwVertex0),rEAX)
        xMOV_r_rm   (rEBX,rmIND(rEAX))
        xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
        xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
        xMOV_r_rm   (rEBX,rmIND(rEAX))
        xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
        xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)
        xMOV_r_rm   (rEBX,rmIND(rEAX))
    }
    /*
     * get flat shaded colors
     */
    if (ilcFlags & FLAG_FLAT)
    {
        ILCCompile_getFlatComponents (pContext);
    }
    /*
     * copy
     */
    ILCCompile_vertex (pContext,0,mMEM32(global.dwVertex0),0,FALSE,0/*edi = global.nvCachedPut*/,FALSE);
    ILCCompile_vertex (pContext,1,mMEM32(global.dwVertex1),1,FALSE,1,FALSE);
    ILCCompile_vertex (pContext,2,mMEM32(global.dwVertex2),2,FALSE,1,FALSE);
    /*
     * launch triangle, edi still has global.nvCachedPut
     */
#ifndef NOLAUNCH
    xMOV_rm_imm (rmREG(rEBX),0x210)
    xMOV_rm_imm (rmREG(rEAX),((ilcFlags & FLAG_DX6) ? 0x0004e540 : 0x0004e600))
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
    xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(-4)
    xMOV_i32_r  (mMEM32(global.nvCachedPut),rEDI)
#endif
#ifdef DEBUG
    xPUSHAD
    xMOV_rm_imm (rmREG(rEBX),(DWORD)ILCDebug_flushTriangle)
    xCALL_rm    (rmREG(rEBX))
    xPOPAD
#endif
    xJMP        (label_exit)

    /*------------------------------------------------------------------------
     * quad
     *-----------------------------------------------------------------------*/
    if (!ISLIST(ilcFlags) && !(ilcFlags & FLAG_FLAT))
    {
        while (ilcCount & 31) { xINT3 }
        xTARGET_b32 (label_quad)
        /*
         * reserve space in push buffer
         *  - always make space for 4 full dx6 triangles at a time
         *  - this will save on overhead when put chases get
         */
        {
            DWORD l1;

            xMOV_r_i32  (rEAX,mMEM32(global.nvCachedThreshold))
            xMOV_r_i32  (rECX,mMEM32(global.nvCachedPut))
            xMOV_r_i32  (rEBX,mMEM32(ilcData))
            xLABEL      (l1)
            xADD_rm_imm (rmREG(rEBX),0)
            xCMP_r_rm   (rECX,rmREG(rEAX))
            xLABEL      (label_reserveSpace3)
            xJGE32      (0)
            *(DWORD*)(ilcData + l1 + 2) = ilcCount;
        }

        /*
         * we compute the 4 vertices into dwVertex0, 1, 2 and pVertices
         */
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * read indices and compute vertex offsets
             */
            xMOV_r_i32  (rEAX,mMEM32(global.pIndices))
            xMOV_r_rm   (rEBX,rmIND(rEAX))
            xMOV_r_rm   (rECX,rmREG(rEBX))
            xAND_rm_imm (rmREG(rEBX),0xffff)
            xSHR_rm_imm8(rmREG(rECX),16)
            xMOV_r_rm   (rEDX,rmIND8(rEAX)) xOFS8(4)
            ILCCompile_mul (rEBX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEBX);
#endif
            ILCCompile_mul (rECX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rECX);
#endif
            xMOV_r_rm   (rEBP,rmREG(rEDX))
            xAND_rm_imm (rmREG(rEDX),0xffff)
            xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
            ILCCompile_mul (rEDX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEDX);
#endif
            xSHR_rm_imm8(rmREG(rEBP),16)
            xLEA_r_rm   (rEBX,rmSIB) xSIB(rEBX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEBX)
            xMOV_r_rm   (rEBX,rmIND(rEBX))
            xMOV_r_rm   (rEBX,rmREG(rEBP))
            xLEA_r_rm   (rECX,rmSIB) xSIB(rECX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex1),rECX)
            xMOV_r_rm   (rECX,rmIND(rECX))
            ILCCompile_mul (rEBX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEBX);
#endif
            xLEA_r_rm   (rEDX,rmSIB) xSIB(rEDX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEDX)
            xMOV_r_rm   (rECX,rmIND(rEDX))
            xLEA_r_rm   (rEBX,rmSIB) xSIB(rEBX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.pVertices),rEBX)
            xMOV_r_rm   (rECX,rmIND(rEBX))
        }
        else
        {
            /*
             * compute vertex offsets
             */
            xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEAX)
            xMOV_r_rm   (rEBX,rmIND(rEAX))
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
            xMOV_r_rm   (rEBX,rmIND(rEAX))
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)
            xMOV_r_rm   (rEBX,rmIND(rEAX))
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.pVertices),rEAX)
            xMOV_r_rm   (rEBX,rmIND(rEAX))
        }

        /*
         * copy
         */
        ILCCompile_vertex (pContext,0,mMEM32(global.dwVertex0),0,FALSE,0/*edi = global.nvCachedPut*/,TRUE);
        ILCCompile_vertex (pContext,1,mMEM32(global.dwVertex1),1,FALSE,1,TRUE);
        ILCCompile_vertex (pContext,2,mMEM32(global.dwVertex2),2,FALSE,1,TRUE);
        ILCCompile_vertex (pContext,3,mMEM32(global.pVertices),3,FALSE,1,TRUE);
        /*
         * launch triangle, edi still has global.nvCachedPut
         */
#ifndef NOLAUNCH
        xMOV_rm_imm (rmREG(rEBX),(ISSTRIP(ilcFlags) ? 0x312210 : 0x320210))
        xMOV_rm_imm (rmREG(rEAX),((ilcFlags & FLAG_DX6) ? 0x0004e540 : 0x0004e600))
        xMOV_rm_r   (rmIND(rEDI),rEAX)
        xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
        xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(-4)
        xMOV_i32_r  (mMEM32(global.nvCachedPut),rEDI)
#endif
#ifdef DEBUG
        xPUSHAD
        xMOV_rm_imm (rmREG(rEBX),(DWORD)ILCDebug_flushTriangle)
        xCALL_rm    (rmREG(rEBX))
        xPOPAD
#endif
        xJMP        (label_exit)
    }
#endif //!NOSPECIALCASE

    /*------------------------------------------------------------------------
     * reserveSpace
     *-----------------------------------------------------------------------*/
    /*
     * align entry point
     */
    while (ilcCount & 31) { xINT3 }
    xTARGET_b32 (label_reserveSpace1)
#ifndef NOSPECIALCASE
    xTARGET_b32 (label_reserveSpace2)
    if (!ISLIST(ilcFlags) && !(ilcFlags & FLAG_FLAT))
    {
        xTARGET_b32 (label_reserveSpace3)
    }
#endif
    {
        xPUSH_r    (rEBX) // return address
        xMOV_rm_imm(rmREG(rEBX),(DWORD)ILCCompile_GetSpace)
        xCALL_rm   (rmREG(rEBX)) // ebx, edi and esi should be preserved if compiler follow its own rules
        xRET
    }

    /*
     * done
     */
    return label_entry;
}


/****************************************************************************
 * C helper code                                                            *
 ****************************************************************************/

/*
 * TriangleSetup only choose the major things like:
 *      dx5 or dx6
 *      fog
 *      basic, mmx or katmai
 *      fixed wbuffer
 *
 * TriangleDispatch deal with:
 *      indexed vs non-indexed
 *      fvf vs non fvf
 *      list,strip,fan
 */

/*
 * ILCGrowTo
 *
 * grows ilcData to asked for (or larger) size
 */
void ILCGrowTo
(
    DWORD dwNeed
)
{
#ifdef VTUNE_SUPPORT
    if (!ilcMax)
    {
        nvVTuneModifyAccessRights();
        ilcData = (BYTE*)((DWORD)nvVTuneMemoryImage + 36);
        ilcMax =  *(DWORD*)(ilcData - 4);
    }
    else if (dwNeed > ilcMax)
    {
        DPF ("*** maximum block size overrun. adjust size ***");
        __asm int 3;
    }
#else //!VTUNE_SUPPORT
    /*
     * determine how much memory we need
     */
    if (dwNeed > ilcMax)
    {
        /*
         * grow
         */
#ifdef DEBUG
        DWORD ilcOld = ilcMax;
#endif
        ilcMax  = (dwNeed + 4095) & ~4095;
        // if this fails we are truly screwed
        void* pNewILC;
        if (!ReallocIPM(ilcData, ilcMax, &pNewILC))
        {
            DPF("ILCGrowTo: ReallocIPM failed - we are truly screwed");
        }
        else
        {
            ilcData = (BYTE*)pNewILC;
        }
#ifdef DEBUG
        if (!ilcData)
        {
            DPF ("Memory allocation failed - things are going to go terribly wrong now");
            _asm int 3
        }

        memset (ilcData+ilcOld,0xcc,ilcMax-ilcOld);
#endif
    }
#endif //!VTUNE_SUPPORT
}

/*
 * nvDX5TriangleSetup
 *
 * DX5 triangle setup
 */
void __stdcall nvDX5TriangleSetup
(
    PNVD3DCONTEXT pContext,
    DWORD  dwPrimCount,
    LPWORD pIndices,
    LPBYTE pVertices
)
{
    /*
     * if we have state changes, compute HW state now
     */
    if (pContext->bStateChange)
    {
        nvSetHardwareState (pContext);
    }

    /*
     * Send the context state down to the hardware.
     */
    nvSetDx5TriangleState(pContext);

    pContext->dwFunctionLookup = NV_FOG_MODE
                               | ((pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT) ? FLAG_FLAT : 0)
 #ifndef FLOAT_W
                               | ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)      ? FLAG_FIXEDWBUF : 0)
 #endif
                               | ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE] == TRUE)     ? FLAG_SPECULAR : 0)
                               | ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX)                ? FLAG_MMX    : 0)
                               | ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)             ? FLAG_KATMAI : 0);

    if (pContext->pZetaBuffer)
    {
        CNvObject *pNvObj = pContext->pZetaBuffer->getWrapper();
        if (pNvObj->hasCTEnabled())
        {
            pContext->dwFunctionLookup |= pNvObj->isCTFront() ? FLAG_ZFP
                                                              : FLAG_ZBP;
        }
    }

    return;
}

/*
 * nvDX6TriangleSetup
 *
 * DX6 triangle setup
 */
void __stdcall nvDX6TriangleSetup
(
    PNVD3DCONTEXT pContext,
    DWORD  dwPrimCount,
    LPWORD pIndices,
    LPBYTE pVertices
)
{
    /*
     * setup HW if needed
     */
    if (pContext->bStateChange)
    {
        nvSetMultiTextureHardwareState (pContext);
        if (!pContext->bUseDX6Class)
        {
            /*
             * The number of texture stages was reduced to 1.
             * Use DX5 Class instead of DX6 class.
             */
            nvDX5TriangleSetup(pContext,dwPrimCount,pIndices,pVertices);
            return;
        }
    }
    nvSetDx6MultiTextureState(pContext);

    /*
     * calc appropriate render function
     */
    pContext->dwFunctionLookup = NV_FOG_MODE
                                      | ((pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT) ? FLAG_FLAT : 0)
 #ifndef FLOAT_W
                                      | ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)      ? FLAG_FIXEDWBUF : 0)
 #endif
                                      | ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE] == TRUE)     ? FLAG_SPECULAR : 0)
                                      | ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX)    ? FLAG_MMX    : 0)
                                      | ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI) ? FLAG_KATMAI : 0)
                                      | FLAG_DX6;

    if (pContext->pZetaBuffer)
    {
        CNvObject *pNvObj = pContext->pZetaBuffer->getWrapper();
        if (pNvObj->hasCTEnabled())
        {
            pContext->dwFunctionLookup |= pNvObj->isCTFront() ? FLAG_ZFP
                                                              : FLAG_ZBP;
        }
    }

    return;
}

/*
 * nvTriangleDispatch
 *
 * calls the triangle inner loop code
 *  - if it does not exist yet, build it
 */
void __stdcall nvTriangleDispatch
(
    NV_INNERLOOP_ARGLIST
)
{
    DWORD dwFLUI;
    DWORD dwOffset;
    DWORD dwTextureOrder;

    if (!dwCount) return; // do not waste time (or crash code that assume real work to be done)

    LPBYTE pVertices = (LPBYTE)(pContext->ppDX8Streams[0]->getAddress() + pContext->dp2.dwTotalOffset);
    LPWORD pIndices  = (LPWORD)(pContext->dp2.dwIndices);
    DWORD  dwStrides = nv4DP2OpToStride[pContext->dp2.dwDP2Prim];

    /*
    {
        extern BOOL nvPusherDisassemblerEnable;
        nvPusherDisassemblerEnable = 1;
    }
    */

    /*
     * get function pointer
     */
    dwFLUI = pContext->dwFunctionLookup;

    /*
     * if we have to call a fixed function, do it now
     *  current fixed functions are
     *      nvTriangleSetup
     *      nvAACapturePrimitive
     */
    if (dwFLUI & FLAG_DIRECT)
    {
        switch (dwFLUI)
        {
            case NV_AA_FUNCTION_INDEX:
            {
                return;
            }
            case NV_SETUP_FUNCTION_INDEX:
            {
                /*
                 * We need to call the correct state setup code based on what the application DX level is
                 * here if the hardware state has been changed, since a previous call to the hardware setup
                 * code has already potentially changed the DX5/DX6 object usage flag.
                 * DX6 applications must always start out calling the DX6 state setup code to insure the
                 * proper rendering state is used for hardware setup.
                 */
                if (pContext->bStateChange) {
                    ((pContext->dwDXAppVersion >= 0x0600) ? nvDX6TriangleSetup
                                                          : nvDX5TriangleSetup) (pContext,dwCount,pIndices,pVertices);
                }
                else {
                    (pContext->bUseDX6Class ? nvDX6TriangleSetup
                                            : nvDX5TriangleSetup) (pContext,dwCount,pIndices,pVertices);
                }

                /*
                 * reset dwFLUI
                 */
                dwFLUI = pContext->dwFunctionLookup;

                /*
                 * fall through so we can draw the primitives except for AA
                 */
                if (dwFLUI & FLAG_DIRECT) return;

                break;
            }
        }
    }

    /*
     * compute proper Lookup Index (LUI).
     *  nvTriangleSetup can only choose the major things like:
     *      dx5 or dx6
     *      fog
     *      (basic, mmx or katmai - determined at startup)
     *
     *  here we have to modify the pointer to deal with:
     *      indexed vs non-indexed
     *      fvf vs non fvf
     *      list,strip,fan
     */
    dwFLUI |= (pIndices ? FLAG_INDEXED : 0)
           |  ((dwStrides >> 24) << 2);
    if (dwFLUI & MASK_FOG)
    {
        dwFLUI |= (((pContext->surfaceViewport.dvWNear == 1.0f)
                 && (pContext->surfaceViewport.dvWFar  == 1.0f)) ? FLAG_ZFOG : 0);
    }

    /*
     * get function pointer
     */
    {
        PNVD3DMULTITEXTURESTATE pTriangleState = (PNVD3DMULTITEXTURESTATE)&pContext->mtsState;
        DWORD     dwIndex  = (pContext->pCurrentVShader->getFVF() + dwFLUI + (dwFLUI >> 12) + (dwFLUI >> 24)) & MASK_TABLE;
        CILHashEntry *pRec = (CILHashEntry*)dwDrawPrimitiveTable[dwIndex];

        dwTextureOrder = (pTriangleState->dwUVOffset[0] << 0)
                       | (pTriangleState->dwUVOffset[1] << 4);

#ifdef PRINT_NAME
        ILCDebug_printName (dwFLUI,fvfData.dwVertexType,dwTextureOrder);
#endif //PRINT_NAME

        /*
         * find proper loop
         */
        while (pRec)
        {
            if (pRec->match(dwFLUI, pContext->pCurrentVShader->getFVF(), dwTextureOrder))
            {
                dwOffset = pRec->getOffset();
                break;
            }
            pRec = pRec->getNext();
        }

        /*
         * not found?
         */
        if (!pRec)
        {
#ifdef PRINT_NAME_ON_BUILD
            ILCDebug_printName (dwFLUI,fvfData.dwVertexType,dwTextureOrder);
#endif //PRINT_NAME_ON_BUILD

            /*
             * build inner loop
             */
            dwOffset = ILCCompileCode(pContext, dwFLUI);
            pRec = new CILHashEntry (dwFLUI,
                                     pContext->pCurrentVShader->getFVF(),
                                     dwTextureOrder,
                                     dwOffset,
                                     (CILHashEntry*)dwDrawPrimitiveTable[dwIndex]);
            if (!pRec)
            {
                // out of memory
                DPF ("nvTriangleDispatch - out of memory");
                return;
            }
            dwDrawPrimitiveTable[dwIndex] = (DWORD)pRec;
        }
    }

    /*
     * set up inner loop variables
     */
    global.nvCachedPut       = getDC()->nvPusher.getPut();
    global.nvCachedThreshold = getDC()->nvPusher.getThreshold();
    global.dwPrimCount       = dwCount;
    global.pVertices         = (DWORD)pVertices;
    global.pIndices          = (DWORD)pIndices;
    global.fRWFar            = pContext->surfaceViewport.dvRWFar;
    global.dwSpecularCount   = 5;
    global.dwSpecularState   = 0;
    global.dwBlendRegister   = pContext->ctxInnerLoop.dwBlend;
#ifndef NOCULLING
    global.dwCullMask1 = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
    global.dwCullMask2 = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? 0xffffffff : 0x80000000;
#endif

    if (dwFLUI & MASK_FOG)
    {
        global.pKNI->fFogTableDensity[0]     = pContext->fogData.fFogTableDensity;
        global.pKNI->fFogTableLinearScale[0] = pContext->fogData.fFogTableLinearScale;
        global.pKNI->fFogTableStart[0]       = pContext->fogData.fFogTableStart;
        global.pKNI->fFogTableEnd[0]         = pContext->fogData.fFogTableEnd;

        if (dwFLUI & FLAG_KATMAI)
        {
            #define PROP(x) x[1] = x[2] = x[3] = x[0]
            PROP(global.pKNI->fFogTableDensity);
            PROP(global.pKNI->fFogTableLinearScale);
            PROP(global.pKNI->fFogTableStart);
            PROP(global.pKNI->fFogTableEnd);
        }
    }

    if (pContext->pZetaBuffer)
    {
        CNvObject *pNvObj = pContext->pZetaBuffer->getWrapper();
        if (pNvObj->hasCTEnabled())
        {
            if ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      != D3DZB_TRUE)
             || (pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] != TRUE))
            {
                pNvObj->tagCTZE();
            }
        }
        pNvObj->setCTDrawPrim();
    }

#ifdef PIX1
    {
        typedef struct
        {
            float x,y,z,rhw;
            DWORD c,s;
            float u0,v0,u1,v1;
        } SPECIAL;

        static SPECIAL vx0 = {0.0f,0.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };
        static SPECIAL vx1 = {1.0f,0.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };
        static SPECIAL vx2 = {0.0f,1.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };

        DWORD dwCount = (dwFLUI & LUIFLAG_DX6) ? (sizeDx5TriangleTLVertex * 3)
                                               : (sizeDx6TriangleTLVertex * 3);
        DWORD dwSize  = (dwFLUI & LUIFLAG_DX6) ? 40 : 32;
        DWORD dwCode  = (dwFLUI & LUIFLAG_DX6) ? 0x0028e400 : 0x0020e400;
        DWORD dwBase  = (dwFLUI & LUIFLAG_DX6) ? 5 : 13;

        nvPushData (0, dwCode + dwBase * dwSize);
        for (i=0; i < dwSize>>2; i++)
            nvPushData (i+1, (DWORD *)(&vx0)[i]);
        nvPusherAdjust (dwSize>>2 + 1);

        dwBase ++;

        nvPushData (0, dwCode + dwBase * dwSize);
        for (i=0; i < dwSize>>2; i++)
            nvPushData (i+1, (DWORD *)(&vx1)[i]);
        nvPusherAdjust (dwSize>>2 + 1);

        dwBase ++;

        nvPushData (0, dwCode + dwBase * dwSize);
        for (i=0; i < dwSize>>2; i++)
            nvPushData (i+1, (DWORD *)(&vx2)[i]);
        nvPusherAdjust (dwSize>>2 + 1);

    }
#endif //PIX1

    //
    // setup mush instrumentation
    //
    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_MUSH)
    {
        global.fTotalPixelsTimes2 = 0.0f;
    }

    /*
     * draw it
     */
#ifdef INSTRUMENTED
    {
#ifdef PLOT
        static BOOL first = 1;
#endif
        __int64 time1;
        __int64 time2;
        DWORD   put1 = (DWORD)global.nvCachedPut;
        DWORD   put2;

#ifdef PLOT
        if (first)
        {
            ILCDebug_cls();
            first = 0;
        }
#endif

        __asm
        {
            pushad
            rdtsc
            mov [dword ptr time1 + 0],eax
            mov [dword ptr time1 + 4],edx
            popad
        }
#endif //INSTRUMENTED

    //
    // call inner loop
    //
    ((PFNINNERLOOP)(ilcData + dwOffset))();
#ifndef NV_NULL_HW_DRIVER
    getDC()->nvPusher.setPut (global.nvCachedPut);
#endif

#ifdef INSTRUMENTED
        __asm
        {
            pushad
            rdtsc
            mov [dword ptr time2 + 0],eax
            mov [dword ptr time2 + 4],edx
            popad
        }

        put2 = (DWORD)global.nvCachedPut;

        if (put2 > put1)
        {
            static double total = 0.0f;
            static double count = 0.0f;
            static double min   = 1e20f;
            static double max   = 0.0f;
#ifndef WINNT   // WINNT timer routines need a larger datatype
            static DWORD  last  = 0;
#else   // WINNT
            LONGLONG last = 0;
#endif  // WINNT

            double bps = (double)(put2 - put1) * (double)(500.0) / (double)(time2 - time1);
#ifndef WINNT   // WINNT timer routines need a larger datatype
            DWORD now;
#else   // WINNT
            LONGLONG now;
#endif  // WINNT

            //global.nvCachedPut = put1;

            if (bps < min)
            {
                min = bps;
                if (0)//(min < 5.0f)
                {
                    DWORD cycles = (DWORD)(time2 - time1);
                    DWORD bytes  = (DWORD)(put2  - put1);
                    DPF ("*** low: %d bytes, %d cycles, %d cycles / byte", bytes,cycles,cycles/bytes);
                }
            }
            if (bps > max)
            {
                max = bps;
                if (0)//(max > 250.0f)
                {
                    DWORD cycles = (DWORD)(time2 - time1);
                    DWORD bytes  = (DWORD)(put2  - put1);
                    DPF ("*** high: %d bytes, %d cycles, %d cycles / byte", bytes,cycles,cycles/bytes);
                }
            }

            total += bps;
            count += 1.0f;

#ifdef PLOT
            {
                double x = 720.0 / (64.0 * 1024.0) * (double)(put2 - put1);
                double y = 347.0 - (348.0 / 800.0 * bps);
                int    c = 0;
                if (dwFLUI & MASK_FOG)  c = 1;
                if (dwFLUI & FLAG_FLAT) c = 2;

                if (y < 0.0)   y = 0.0;
                if (x > 719.0) x = 719.0;

                ILCDebug_plot ((int)x,(int)y,c);
                DPF ("%d %d", (int)x,(int)y);
            }
#else
#ifndef WINNT   // Can't macroize this one
            now = GetTickCount();
#else   // WINNT
            EngQueryPerformanceCounter(&now);
#endif  // WINNT

            if ((now - last) > 1500)
            {
                DPF ("%08x: cnt:%d bps:%d max:%d min:%d\n",
                     ((DWORD)global.nvCachedPut - (DWORD)getDC()->nvPusher.getBase()),
                     (DWORD)count,
                     (DWORD)(total / count),
                     (DWORD)max,
                     (DWORD)min);
                last  = now;
                total = 0.0f;
                count = 0.0f;
                max   = 0.0f;
                min   = 1e20f;
            }
#endif
        }
    }
#endif //INSTRUMENTED

    nvPusherAdjust (0);

    //
    // wrap up mush instrumentation
    //
    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_MUSH)
    {
        //
        // program delay
        //
        double fdScale  = (GET_MODE_BPP() > 16) ? 2 : 1;
        double fdPixels = fabs(global.fTotalPixelsTimes2) * 0.5;
        double fdMin1   = dwCount * 16.0;
        double fdMin2   = fdPixels * ((dwFLUI & FLAG_DX6) ? 1.0 : 0.5);
        double fdWait;
        if (fdMin1 > fdMin2)
        {
            // setup bound
            fdWait = fdScale * global.fdClockPerTri * dwCount - fdMin1;
        }
        else
        {
            // fill bound
            fdWait = fdScale * global.fdClockPerPixel * fdPixels - fdMin2;
        }
        // send to HW (assume dx5/dx6 triangle selected)
        if (fdWait >= 25.0)
        {
            // send wait
            DWORD dwWait = DWORD(fdWait);
            nvPushData (0,(1 << 18) | (NV_DD_SPARE << 13) | NV054_STALL_PIPE);
            nvPushData (1,dwWait);
            nvPusherAdjust (2);
            // make HW look busy
            /*
            for (int i = 0; i < 25; i++)
            {
                nvPushData (0,(1 << 18) | (NV_DD_SPARE << 13) | NV054_NO_OPERATION);
                nvPushData (1,dwWait);
                nvPusherAdjust (2);
            }
            */
        }
    }

    /*
    if (dwFLUI & FLAG_DX6)
    {
        DPF ("6");
    }
    else
    {

        DWORD drfValueFilter;
        DWORD drfValueSpec;
        DWORD drfValueAlpha;
        DWORD drfValueFog;
        drfValueFilter = DRF_VAL(054, _FILTER, _TEXTUREMIN, pContext->ctxInnerLoop.dwFilter);
        drfValueSpec = DRF_VAL(054, _BLEND, _SPECULARENABLE, pContext->ctxInnerLoop.dwBlend);
        drfValueAlpha = DRF_VAL(054, _BLEND, _ALPHABLENDENABLE, pContext->ctxInnerLoop.dwBlend);
        drfValueFog = DRF_VAL(054, _BLEND, _FOGENABLE, pContext->ctxInnerLoop.dwBlend);

        if ((drfValueFilter == NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST) ||
            (drfValueFilter == NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR)) {
            DPF ("T");

        } else if (drfValueSpec == NV054_BLEND_SPECULARENABLE_TRUE) {
            DPF ("s");
        } else if (drfValueAlpha == NV054_BLEND_ALPHABLENDENABLE_TRUE &&
                   drfValueFog == NV054_BLEND_FOGENABLE_TRUE) {
            DPF ("a");
        } else {
            DPF ("_");
        }
    }
//*/

}


/*****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************/

DWORD nvBuildCustomCopyRoutine
(
    DWORD dwCount
)
{
    // cannot return zero offset (special meaning)
    if (!ilcCount) { xINT3 };

    // align to 32 byte boundary
    while (ilcCount & 31) { xINT3 }

    DWORD label_entry;
    xLABEL (label_entry)

    // get src & dest
    xPUSH_r     (rEDI)
    xPUSH_r     (rESI)
    xMOV_r_rm   (rEDI,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (12)
    xMOV_r_rm   (rESI,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (16)

    // do copy
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
    {
        //
        // WNI copy
        //
        DWORD i = 0;
        while (dwCount >= 64)
        {
            xMOVSD_r_rm     (rXMM0,rmIND8(rESI)) xOFS8(i +  0)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM0) xOFS8(i +  0)
            xMOVSD_r_rm     (rXMM1,rmIND8(rESI)) xOFS8(i +  8)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM1) xOFS8(i +  8)

            xMOVSD_r_rm     (rXMM2,rmIND8(rESI)) xOFS8(i + 16)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM2) xOFS8(i + 16)
            xMOVSD_r_rm     (rXMM3,rmIND8(rESI)) xOFS8(i + 24)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM3) xOFS8(i + 24)

            xMOVSD_r_rm     (rXMM4,rmIND8(rESI)) xOFS8(i + 32)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM4) xOFS8(i + 32)
            xMOVSD_r_rm     (rXMM5,rmIND8(rESI)) xOFS8(i + 40)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM5) xOFS8(i + 40)

            xMOVSD_r_rm     (rXMM6,rmIND8(rESI)) xOFS8(i + 48)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM6) xOFS8(i + 48)
            xMOVSD_r_rm     (rXMM7,rmIND8(rESI)) xOFS8(i + 56)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM7) xOFS8(i + 56)
            dwCount -= 64;
            i       += 64;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 16)
        {
            xMOVSD_r_rm     (rXMM0,rmIND8(rESI)) xOFS8(i)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM0) xOFS8(i)
            xMOVSD_r_rm     (rXMM0,rmIND8(rESI)) xOFS8(i+8)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM0) xOFS8(i+8)
            dwCount -= 16;
            i       += 16;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 8)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(i + 4)
            xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(i + 4)
            dwCount -= 8;
            i       += 8;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 4)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            dwCount -= 4;
            i       += 4;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        if (dwCount)
        {
            xADD_rm_imm (rmREG(rESI),i)
            xADD_rm_imm (rmREG(rEDI),i)
            xMOV_rm_imm (rmREG(rECX),dwCount)
            xREP xMOVSB
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        //
        // KNI copy
        //
        DWORD i = 0;
        while (dwCount >= 64)
        {
            xMOVLPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(i +  0)
            xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(i +  8)
            xMOVLPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(i + 16)
            xMOVHPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(i + 24)
            xMOVLPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(i + 32)
            xMOVHPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(i + 40)
            xMOVLPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(i + 48)
            xMOVHPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(i + 56)
            xMOVLPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(i +  0)
            xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(i +  8)
            xMOVLPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(i + 16)
            xMOVHPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(i + 24)
            xMOVLPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(i + 32)
            xMOVHPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(i + 40)
            xMOVLPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(i + 48)
            xMOVHPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(i + 56)
            dwCount -= 64;
            i       += 64;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 16)
        {
            xMOVLPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(i)
            xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(i+8)
            xMOVLPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(i)
            xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(i+8)
            dwCount -= 16;
            i       += 16;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 8)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(i + 4)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(i + 4)
            dwCount -= 8;
            i       += 8;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 4)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            dwCount -= 4;
            i       += 4;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        if (dwCount)
        {
            xADD_rm_imm (rmREG(rESI),i)
            xADD_rm_imm (rmREG(rEDI),i)
            xMOV_rm_imm (rmREG(rECX),dwCount)
            xREP xMOVSB
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
    {
        //
        // Athlon copy
        //
        bool needFemms = false;
        if (dwCount >= 16)
        {
            xFEMMS
            needFemms = true;
        }
        DWORD i = 0;
        while (dwCount >= 64)
        {
            xMOVQ_r_rm  (rMM0, rmIND8(rESI)) xOFS8(i + 0)
            xMOVQ_r_rm  (rMM1, rmIND8(rESI)) xOFS8(i + 8)
            xMOVQ_r_rm  (rMM2, rmIND8(rESI)) xOFS8(i + 16)
            xMOVQ_r_rm  (rMM3, rmIND8(rESI)) xOFS8(i + 24)
            xMOVQ_r_rm  (rMM4, rmIND8(rESI)) xOFS8(i + 32)
            xMOVQ_r_rm  (rMM5, rmIND8(rESI)) xOFS8(i + 40)
            xMOVQ_r_rm  (rMM6, rmIND8(rESI)) xOFS8(i + 48)
            xMOVQ_r_rm  (rMM7, rmIND8(rESI)) xOFS8(i + 56)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM0) xOFS8(i + 0)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM1) xOFS8(i + 8)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM2) xOFS8(i + 16)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM3) xOFS8(i + 24)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM4) xOFS8(i + 32)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM5) xOFS8(i + 40)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM6) xOFS8(i + 48)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM7) xOFS8(i + 56)
            dwCount -= 64;
            i       += 64;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 16)
        {
            xMOVQ_r_rm  (rMM0, rmIND8(rESI)) xOFS8(i + 0)
            xMOVQ_r_rm  (rMM1, rmIND8(rESI)) xOFS8(i + 8)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM0) xOFS8(i + 0)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM1) xOFS8(i + 8)
            dwCount -= 16;
            i       += 16;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 8)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(i + 4)
            xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(i + 4)
            dwCount -= 8;
            i       += 8;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 4)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            dwCount -= 4;
            i       += 4;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        if (dwCount)
        {
            xADD_rm_imm (rmREG(rESI),i)
            xADD_rm_imm (rmREG(rEDI),i)
            xMOV_rm_imm (rmREG(rECX),dwCount)
            xREP xMOVSB
        }

        if (needFemms)
        {
            xFEMMS
        }
    }
    else
    {
        //
        // normal 8086 copy
        //
        DWORD dwWordCount = dwCount / 4;
        if (dwWordCount)
        {
            xMOV_rm_imm (rmREG(rECX),dwWordCount)
            xREP xMOVSD
        }
        dwCount &= 3;
        if (dwCount)
        {
            xMOV_rm_imm (rmREG(rECX),dwCount)
            xREP xMOVSB
        }
    }

    // done
    xPOP_r      (rESI)
    xPOP_r      (rEDI)
    xRET

    return label_entry;
}


DWORD nvBuildCustomCopyRoutineMisAligned
(
)
{
    // cannot return zero offset (special meaning)
    if (!ilcCount) { xINT3 };

    // align to 32 byte boundary
    while (ilcCount & 31) { xINT3 }

    DWORD label_entry;
    xLABEL (label_entry)

    // get src & dest
    xPUSH_r     (rEDI)
    xPUSH_r     (rESI)
    xPUSH_r     (rEBX)
    xMOV_r_rm   (rEDI,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (16)
    xMOV_r_rm   (rESI,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (20)
    xMOV_r_rm   (rECX,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (24)

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
    {
        xFEMMS
    }
    else
    {
        xEMMS
    }

    DWORD line_size = 64;       //todo: base this on the cpu type
    DWORD distance =  2*64;      //todo: base this on the cpue type
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        distance = 5 * 64;

    xMOV_r_rm   (rEDX, rmREG(rESI))
    xAND_rm_imm (rmREG(rEDX), ~(line_size-1))
    xPREFETCH_rm8   (1, rmIND8(rEDX), 0)
    xPREFETCH_rm8   (1, rmIND8(rEDX), 64)
    xADD_rm_imm (rmREG(rEDX), distance)
    xMOV_r_rm   (rEBX, rmREG(rEDI))
    xMOV_rm_imm (rmREG(rEAX), line_size)
    xAND_rm_imm (rmREG(rEBX), line_size-1)
    xSUB_r_rm   (rEAX, rmREG(rEBX))
    xAND_rm_imm (rmREG(rEAX), line_size-1)
    xTEST_r_rm  (rEAX, rmREG(rEAX))


    DWORD copyloop;
    DWORD aligned;
    xLABEL  (aligned)
    xJZ32   (0)

    xMOV_r_rm   (rECX, rmREG(rEAX))
    xREP    xMOVSB
    xMOV_r_rm   (rECX,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (24)
    xSUB_r_rm   (rECX, rmREG(rEAX))
    DWORD finishup;
    xCMP_rm_imm (rmREG(rECX), 64)
    xLABEL  (finishup)
    xJL32   (0)

    xTARGET_b32 (aligned)
    xLABEL (copyloop)
    xPREFETCH_rm8   (1, rmIND8(rEDX), 0)

    xMOVQ_r_rm  (rMM0, rmIND(rESI))
    xMOVQ_r_rm  (rMM1, rmIND8(rESI)) xOFS8(8)
    xMOVQ_r_rm  (rMM2, rmIND8(rESI)) xOFS8(16)
    xMOVQ_r_rm  (rMM3, rmIND8(rESI)) xOFS8(24)
    xMOVQ_r_rm  (rMM4, rmIND8(rESI)) xOFS8(32)
    xMOVQ_r_rm  (rMM5, rmIND8(rESI)) xOFS8(40)
    xMOVQ_r_rm  (rMM6, rmIND8(rESI)) xOFS8(48)
    xMOVQ_r_rm  (rMM7, rmIND8(rESI)) xOFS8(56)
    xADD_rm_imm (rmREG(rESI), 64)
    xMOVNTQ_rm_r (rmIND(rEDI), rMM0)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM1) xOFS8(8)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM2) xOFS8(16)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM3) xOFS8(24)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM4) xOFS8(32)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM5) xOFS8(40)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM6) xOFS8(48)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM7) xOFS8(56)
    xADD_rm_imm (rmREG(rEDI), 64)
    xADD_rm_imm (rmREG(rEDX), 64)
    xSUB_rm_imm (rmREG(rECX), 64)
    xCMP_rm_imm (rmREG(rECX), 64)
    xJG32   (copyloop)

    xTARGET_b32(finishup)
    xTEST_r_rm  (rECX, rmREG(rECX))
    DWORD done;
    xLABEL  (done)
    xJLE    (0)

    xREP    xMOVSB

    xTARGET_b8(done)

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
    {
        xFEMMS
    }
    else
    {
        xEMMS
    }
    xPOP_r      (rEBX)
    xPOP_r      (rESI)
    xPOP_r      (rEDI)
    xRET

    return label_entry;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvdbgsurf.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDbgSurf.cpp
//      Debug surface placement
//
// **************************************************************************
//
//  History:
//      Scott Kephart           01Dec00         NV20 development
//
// **************************************************************************


#include "nvprecomp.h"
#pragma hdrstop

#ifdef DEBUG_SURFACE_PLACEMENT

void CSurfaceDebug::Init()
{
    surf_cnt = 0;
    bInitialized = true;
    pHWRegisters = reinterpret_cast<BYTE *>(pDriverData->NvBaseFlat);
}    


void CSurfaceDebug::Destroy()
{

    DumpSurfaceInfo();
    bInitialized = false;
}    

void CSurfaceDebug::SetFrontBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff && surf_cnt < (CSD_MAX_SURFACES)) 
    {
        Surfaces[surf_cnt].SurfaceType = FrontBuffer;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = false;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
}    

void CSurfaceDebug::SetBackBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff  && (surf_cnt < CSD_MAX_SURFACES))
    {
        Surfaces[surf_cnt].SurfaceType = BackBuffer;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = false;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
}    

void CSurfaceDebug::SetZBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff && (surf_cnt < CSD_MAX_SURFACES)) 
    {
        Surfaces[surf_cnt].SurfaceType = Z_Buffer;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = false;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
    
}    

void CSurfaceDebug::ReCreateZBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff && (surf_cnt < CSD_MAX_SURFACES)) 
    {
        Surfaces[surf_cnt].SurfaceType = Z_Buffer;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = true;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
    
}    

void CSurfaceDebug::SetAARenderBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff && (surf_cnt < CSD_MAX_SURFACES)) 
    {
        Surfaces[surf_cnt].SurfaceType = AA_RenderTarget;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = false;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
}    

void CSurfaceDebug::SetAAZBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff && (surf_cnt < CSD_MAX_SURFACES)) 
    {
        Surfaces[surf_cnt].SurfaceType = AA_Z_Buffer;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = false;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
}    

void CSurfaceDebug::DeleteSurface(CSimpleSurface *pBuff)
{
    for (int i = 0; i < surf_cnt; i++) 
    {
        if (Surfaces[i].pSurf == pBuff)
        {
            Surfaces[i].Deleted = true;
            break;
        }
    }
}    


// ToDo: Write this function!
void CSurfaceDebug::ValidateSurfacePlacement()
{
    return;
}    

void CSurfaceDebug::DumpCSimpleSurface(CSimpleSurface *p)
{
    DWORD bytes_written;
    DWORD flags;

    wsprintf(outbuf, "    LinAddr: 0x%08x\r\n", p->getAddress());
    NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    wsprintf(outbuf, "    Offset: 0x%08x\r\n", p->getOffset());
    NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    wsprintf(outbuf, "    Pitch: 0x%08x\r\n", p->getPitch());
    NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    wsprintf(outbuf, "    Height: 0x%08x\r\n", p->getHeight());
    NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    flags = p->getFlags();
    if (flags & CSimpleSurface::FLAG_TILED) 
    {
        wsprintf(outbuf, "    Tiled\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    }
    if (flags & CSimpleSurface::FLAG_ZBUFFER) 
    {
        wsprintf(outbuf, "    ZBuffer\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    }
    flags = p->getAllocFlags();
    if (flags & CSimpleSurface::ALLOCATE_SIMPLE) 
    {
        wsprintf(outbuf, "    ALLOCATE_SIMPLE\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
        
    }
    if (flags & CSimpleSurface::ALLOCATE_TILED) 
    {
        wsprintf(outbuf, "    ALLOCATE_TILED\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
        
    }
#if (NVARCH >= 0x20)
    if (flags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC) 
    {
        wsprintf(outbuf, "    ALLOCATE_AS_ZBUFFER_UNC\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
        
    }
    if (flags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP) 
    {
        wsprintf(outbuf, "    ALLOCATE_AS_ZBUFFER_CMP\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
        
    }
#endif 
    if (flags & CSimpleSurface::ALLOCATE_AS_ZBUFFER) 
    {
        wsprintf(outbuf, "    ALLOCATE_AS_ZBUFFER\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
        
    }
    flags = p->getRMAllocFlags();

    switch (flags)
    {
    case TYPE_TEXTURE:
        wsprintf(outbuf, "    TYPE_TEXTURE\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
       break;
    case TYPE_IMAGE:
        wsprintf(outbuf, "    TYPE_IMAGE\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
       break;
    case TYPE_DEPTH:
        wsprintf(outbuf, "    TYPE_DEPTH\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
       break;
#if (NVARCH >= 0x20)
    case TYPE_DEPTH_COMPR16:
        wsprintf(outbuf, "    TYPE_DEPTH_COMPR16\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
       break;
    case TYPE_DEPTH_COMPR32:
        wsprintf(outbuf, "    TYPE_DEPTH_COMPR32\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
       break;
#endif 
    default:
        break;
    }

}    

void CSurfaceDebug::DumpSurfaceInfo()
{
    static char *SurfName[] =
    {
        "Front Buffer",
        "Back Buffer",
        "Z Buffer",
        "AA Render Target",
        "AA Z Buffer"
    };
    DWORD bytes_written;
    static char filetemp[] = "\\Surf%03i.txt";
    wsprintf(outbuf, filetemp, FileNum++);
    CSDFile=NvCreateFile(outbuf,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (CSDFile > 0) 
        bFileOpen = true;
    else 
        bFileOpen = false;
    
    if (bFileOpen)
    {
        

        for (int i = 0 ; i < surf_cnt; i++)
        {
            wsprintf(outbuf, "%s:\r\n", SurfName[Surfaces[i].SurfaceType]);
            NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
            if (Surfaces[i].Deleted) 
            {
                wsprintf(outbuf, "*** Deleted Surface:\r\n");
                NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
            }
            if (Surfaces[i].ReCreated) 
            {
                wsprintf(outbuf, "*** Recreated Surface:\r\n");
                NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
            }
            DumpCSimpleSurface(&Surfaces[i].Surf);
            
        }

    }
    
    if (bFileOpen)
    {
        if (!NvCloseHandle (CSDFile)) 
        {
            __asm int 3;
        }
        CSDFile = 0;
        bFileOpen = false;
    }
}    

void CSurfaceDebug::REG_WR32(DWORD addr, DWORD data)
{
    pHWRegisters[addr] = data;    
}    

void CSurfaceDebug::REG_RD32(DWORD addr, DWORD &data)
{
    data = pHWRegisters[addr];    
}    

void CSurfaceDebug::RDI_REG_WR32(DWORD select, DWORD addr, DWORD data)
{
//     REG_WR32(NV_PGRAPH_RDI_INDEX,       
//              DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, select) |    
//              DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, addr));     
//     REG_WR32(NV_PGRAPH_RDI_DATA, data);                         
    
}    

void CSurfaceDebug::RDI_REG_RD32(DWORD select, DWORD addr, DWORD &data)
{
//     REG_WR32(NV_PGRAPH_RDI_INDEX,       
//              DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, select) |    
//              DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, addr));     
//     data = REG_RD32(NV_PGRAPH_RDI_DATA);                        
    
}    
#endif // DEBUG_SURFACE_PLACEMENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvDefVB.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDefVB.cpp
//      default vertex buffer code
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        15Jun00         creation
//
// **************************************************************************

#include "nvprecomp.h"
#pragma hdrstop

//---------------------------------------------------------------------------

BOOL CDefaultVB::create
(
    DWORD dwHeap,
    DWORD dwSize
)
{
    dbgTracePush ("CDefaultVB::create");

    BOOL bRes = m_pVertexBuffer->create (dwSize, dwHeap, dwHeap);
    m_pRefCountMap->create (0, TRUE);

    m_dwCurrentOffset = 0;
    m_dwTotalVerticesSincePut = 0;

    dbgTracePop();
    return bRes;
}

//---------------------------------------------------------------------------

BOOL CDefaultVB::destroy
(
    void
)
{
    dbgTracePush ("CDefaultVB::destroy");

    m_pRefCountMap->destroy();
    m_pVertexBuffer->destroy();

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::getHeap (void)
{
    return (m_pVertexBuffer->getHeapLocation());
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::getAddress (void)
{
    return (m_pVertexBuffer->getAddress());
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::getSize (void)
{
    return (m_pVertexBuffer->getSize());
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::getOffset (void)
{
    return (m_pVertexBuffer->getOffset());
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::getCachedOffset (void)
{
    return (m_pRefCountMap->getCached());
}

//---------------------------------------------------------------------------

void CDefaultVB::updateOffset
(
    DWORD dwOffset
)
{
    m_dwCurrentOffset = dwOffset;
}

//---------------------------------------------------------------------------

void CDefaultVB::updateMap
(
    void
)
{
    m_pRefCountMap->put (m_dwCurrentOffset);
}

//---------------------------------------------------------------------------

// wait for space in the default vertex buffer
//
// int  isize - size of the memory block required (should not exceed VBSize / 4)
// BOOL bWait - if FALSE, return immediately when there is no space (doesn't work yet - must be TRUE)
//
// return value - offset to the requested memory block
//              - ~0 if bWait is FALSE and hardware is busy

DWORD CDefaultVB::waitForSpace
(
    int iSize, BOOL bWait
)
{
    // prepare some variables
    int iVBSize      = m_pVertexBuffer->getSize();
    int iVBOffset    = m_dwCurrentOffset;
    int iVBGetOffset = m_pRefCountMap->get();
    int iVBThreshold = (iVBOffset < iVBGetOffset) ? (iVBGetOffset - iSize)
                                                  : (iVBSize      - iSize);

        #ifdef NV_PROFILE_DEFVB
            int iGet = getDC()->pDefaultVBRefCountMap->get();
            nvpLogEvent (NVP_E_PRIM);
            nvpLogCount (NVP_C_PUT,iVBOffset);
            nvpLogCount (NVP_C_GET,iGet);
            nvpLogCount (NVP_C_FREECOUNT,iVBThreshold);
        #endif

    // wait for space
    BOOL bFirst = TRUE;
    while (iVBOffset > iVBThreshold)
    {
        // do we need to wrap around?
        if (iVBOffset >= int(iVBSize - iSize))
        {
            nvPusherStart(TRUE);
            iVBGetOffset = dispatchWrapAround (iVBOffset);
            iVBOffset    = 0;
        }
        else
        {
            // if we are not wrapping, write put now. this will ensure that there is a put
            // after the last batch of vertices which will prevent unnecessary delays when
            // waiting for free space later
            if (bFirst)
            {
                m_pRefCountMap->put(iVBOffset);
                m_dwTotalVerticesSincePut = 0;
                nvPusherStart (TRUE);
            }
        }

        // read HW get
        if (bFirst)
        {
            bFirst = FALSE;
        }
        else
        {
            if (!bWait) return ~0;
            nvDelay();
        }

        // get new threshold
        iVBGetOffset = m_pRefCountMap->get();
        iVBThreshold = (iVBOffset < iVBGetOffset) ? (iVBGetOffset - iSize)
                                                  : (iVBSize      - iSize);
    }

    // return offset into default vertex buffer
    return (iVBOffset);
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::dispatchWrapAround
(
    int iVBOffset
)
{
    // read get pointer
    int  iVBGetOffset  = m_pRefCountMap->get();
    BOOL bPutChasesGet = iVBOffset < iVBGetOffset;

    // make certain get has advanced far enough such that we do not
    //  scribble over batched data
    if (bPutChasesGet)
    {
        // if put is already chasing get, then get must wrap around
        //  and advance away from zero so that we do not discard
        //  a whole buffer of vertices. when we are done here, get
        //  will be chasing put
        for (; (iVBOffset < iVBGetOffset) && m_pRefCountMap->isBusy();)
        {
            nvDelay();
            iVBGetOffset = m_pRefCountMap->get();
        }
    }

    // we are about to go from running away from get, to put chasing get.
    //  in order not to discard a full buffer, we have to make certain
    //  that get is not zero. we may have to help get become not zero
    //  in case nothing else was pipelined since.
    if (!iVBGetOffset)
    {
        m_pRefCountMap->put (iVBOffset);
        nvPusherStart (TRUE);
        iVBGetOffset = m_pRefCountMap->get();
        for (; (!iVBGetOffset) && m_pRefCountMap->isBusy();)
        {
            nvDelay();
            iVBGetOffset = m_pRefCountMap->get();
        }
    }

    // write wrap around
    m_pRefCountMap->put (0);
    m_dwTotalVerticesSincePut = 0;
    nvPusherStart (TRUE);

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvglSetNv20KelvinInvalidateVertexCache (NV_DD_KELVIN);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);
    }
#endif

    // done
    return (iVBGetOffset);
}

//---------------------------------------------------------------------------

CDefaultVB::CDefaultVB
(
    void
)
{
    dbgTracePush ("CDefaultVB::CDefaultVB");

    m_pVertexBuffer = new CVertexBuffer;
    m_pRefCountMap  = new CReferenceCountMap<10>;

    dbgTracePop();
}

//---------------------------------------------------------------------------

CDefaultVB::~CDefaultVB
(
    void
)
{
    dbgTracePush ("CDefaultVB::~CDefaultVB");

    if (m_pVertexBuffer) delete m_pVertexBuffer;
    if (m_pRefCountMap)  delete m_pRefCountMap;

    dbgTracePop();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvEnable.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//---------------------------------------------------------------------------

// attempt allocation and return if unsuccessful

#define NVDD_ALLOCOBJECT(channel, handle, class)                                            \
{                                                                                           \
    DWORD dwStatus;                                                                         \
    dwStatus = NvRmAllocObject (pDriverData->dwRootHandle, (channel), (handle), (class));   \
    if (dwStatus != NVOS05_STATUS_SUCCESS) {                                                \
        dbgTracePop();                                                                      \
        return (FALSE);                                                                     \
    }                                                                                       \
}

//---------------------------------------------------------------------------

void nvCreateVidHeapVarsAndPseudoNotifier (void)
{
    dbgTracePush ("nvCreateVidHeapVarsAndPseudoNotifier");

    // The heap is already consistent. Everyone makes their allocations
    // through the RM. Hence, the heap variables can be initted simply.
    // It is simply all of video memory!
    //
    // Unfortunately, WHQL thinks that right after a DirectDraw init
    // (i.e. a CreateDriverObject) or right after a modeset, the video
    // heap total and free should be equal and complains with a failure
    // if they are not. Hence, I am going to set both the total and the
    // free to be the amount of free memory available for DirectX. This
    // is not perfect, since either people may be making allocations from
    // the video heap directly from the RM and hence video memory
    // "disappears" faster than an app might expect it to, but too bad.
    NVHEAP_INFO ();
    pDriverData->BaseAddress    = HeapParams.address;
    pDriverData->VideoHeapBase  = pDriverData->BaseAddress;
    pDriverData->VideoHeapTotal = HeapParams.total;

#ifdef WINNT
    // For Win2K, include any memory currently in use by the GDI driver as
    // being available for DX usage. The driver defers freeing the GDI alloc'd
    // memory until it is required for a DX memory allocation.
    pDriverData->VideoHeapFree  = HeapParams.free + ppdev->cbGdiHeap;
#else // !WINNT
    pDriverData->VideoHeapFree  = HeapParams.free;
#endif // !WINNT

    // This is what the VideoHeapEnd should be
    // pDriverData->VideoHeapEnd   = HeapParams.address + HeapParams.total - 1;
    // However, for right now, the way other code in this driver works,
    // I have to make the VideoHeapEnd end in FFF, so let's massage it some.
    pDriverData->VideoHeapEnd = ((HeapParams.address + HeapParams.total) & ~0xFFF) - 1;

    dbgTracePop();
}

//---------------------------------------------------------------------------

// Allocate DMA notifiers and pixel/texel buffers
//
// Request 8 pages (NV_DD_COMMON_DMA_BUFFER_SIZE bytes) of memory.
// Allows 2 buffers where 1 buffer can use
// (NV_DD_COMMON_DMA_BUFFER_SIZE - (sizeof(NvNotification) << 5))/2 bytes
// with up to 32 separate notifiers at the beginning of the buffer.
//
// Actual memory allocation done in 16 bit portion of driver.

BOOL nvEnableNotifiers (void)
{
    dbgTracePush ("nvEnableNotifiers");

    NvNotification *pNotifiers = (NvNotification *)pDriverData->NvCommonDmaBufferFlat;

    // Notifier[0]
    pDriverData->pDmaDmaToMemNotifierFlat           = &pNotifiers[0];

    // Notifier[1] actually [0 - 1]
    pDriverData->pDmaBufferNotifierFlat             = &pNotifiers[0];

    // Notifier[2]
    pDriverData->pGenericScaledImageNotifier        = &pNotifiers[2];

    // Notifier[3]
    pDriverData->pDmaPusherSyncNotifierFlat         = &pNotifiers[3];

    // Notifier[5]
    pDriverData->pDmaSyncNotifierFlat               = &pNotifiers[5];

    // Notifier[6-7]
    pDriverData->pPioColourControlEventNotifierFlat = &pNotifiers[6];

    // Notifier[8]
    pDriverData->pPioCombinerEventNotifierFlat      = &pNotifiers[8];

    // Notifier memory [9 - 25] available for use

    // On NV4 Notifier[26 - 30], on NV10 Notifier[26 - 28]
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        pDriverData->pPioFlipOverlayNotifierFlat    = (NvNotification*)(pDriverData->NvVideoNotifierBuffer + (sizeof(NvNotification) * (16 + 8 + 2)));
    }
    else {
        pDriverData->pPioFlipOverlayNotifierFlat    = &pNotifiers[16 + 8 + 2];
    }

    // On NV4 Notifier[32 - 36], on NV10 Notifier[32 - 40]
    // multi-head: head0 uses [32 - 40], head1 uses [48 - 56], etc.
    pDriverData->pDmaFlipPrimaryNotifierFlat            = &pNotifiers[32];

    // Scanline buffer starts after array of 32 notifiers
    pDriverData->NvScanlineBufferFlat = pDriverData->NvCommonDmaBufferFlat + NV_DD_NOTIFIER_BLOCK_SIZE;

    NvNotification *pDmaDmaToMemNotifier           = pDriverData->pDmaDmaToMemNotifierFlat;
    NvNotification *pDmaPusherSyncNotifier         = pDriverData->pDmaPusherSyncNotifierFlat;
    NvNotification *pDmaSyncNotifier               = pDriverData->pDmaSyncNotifierFlat;
    NvNotification *pDmaFlipPrimaryNotifier        = pDriverData->pDmaFlipPrimaryNotifierFlat;
    NvNotification *pPioFlipOverlayNotifier        = pDriverData->pPioFlipOverlayNotifierFlat;
    NvNotification *pPioColourControlEventNotifier = pDriverData->pPioColourControlEventNotifierFlat;
    NvNotification *pPioCombinerEventNotifier      = pDriverData->pPioCombinerEventNotifierFlat;

    // Deal with possible mode change during pending flip
    if ((volatile)pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) {
        long countDown = 0x200000;
        while (((volatile)pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) && (--countDown > 0));
    }
    // Deal with possible mode change during pending flip
    if ((volatile)pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS) {
        long countDown = 0x200000;
        while (((volatile)pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS) && (--countDown > 0));
    }
    // Deal with possible mode change during pending flip
    if ((volatile)pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) {
        long countDown = 0x200000;
        while (((volatile)pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) && (--countDown > 0));
    }
    // Deal with possible mode change during pending flip
    if ((volatile)pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS) {
        long countDown = 0x200000;
        while (((volatile)pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS) && (--countDown > 0));
    }

    // clear all status flags before first use
    pDmaDmaToMemNotifier->status = 0;
    pDriverData->pGenericScaledImageNotifier->status = 0;
    pDmaSyncNotifier->status = 0;

    pDmaFlipPrimaryNotifier[0].status = 0;
    pDmaFlipPrimaryNotifier[1].status = 0;
    pDmaFlipPrimaryNotifier[2].status = 0;

    pPioFlipOverlayNotifier[0].status = 0;
    pPioFlipOverlayNotifier[1].status = 0;
    pPioFlipOverlayNotifier[2].status = 0;

    pPioColourControlEventNotifier->status = 0;
    pPioCombinerEventNotifier->status = 0;

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

//
//    nvCreateNotifers ()
//    This routine creates all the notifiers to be used by DirectDraw.
//    Basically they are the notifiers and the scanline buffer.
//

DWORD __stdcall nvCreateNotifiers (void)
{
    dbgTracePush ("nvCreateNotifiers");

    DWORD dwSize = NV_DD_COMMON_DMA_BUFFER_SIZE + 0x1000 - 1;

    // Allocate memory for a bunch of notifiers and the scanline buffer.
    if (!pDriverData->NvCommonDmaBufferFlat) {
        pDriverData->NvCommonDmaBufferFlat = (DWORD)AllocIPM(dwSize);
        if (!pDriverData->NvCommonDmaBufferFlat) {
            dbgTracePop();
            return FALSE;
        }
    }

    // NV10 has some extra things
//    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
        pDriverData->NvVideoNotifierBuffer = pDriverData->NvCommonDmaBufferFlat + NV_DD_COMMON_DMA_BUFFER_SIZE;

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) pDriverData->NvCommonDmaBufferFlat,
                             sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) pDriverData->NvCommonDmaBufferFlat, NV_DD_COMMON_DMA_BUFFER_SIZE - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY),
                             (PVOID) pDriverData->NvCommonDmaBufferFlat, NV_DD_COMMON_DMA_BUFFER_SIZE - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) pDriverData->NvCommonDmaBufferFlat,
                             2 * sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_SCALED_IMAGE_CONTEXT_IID,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) (pDriverData->NvCommonDmaBufferFlat + 2 * sizeof(NvNotification)),
                             sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) (pDriverData->NvCommonDmaBufferFlat + 3 * sizeof(NvNotification)),
                             2 * sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) (pDriverData->NvCommonDmaBufferFlat + 5 * sizeof(NvNotification)),
                             sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) (pDriverData->NvCommonDmaBufferFlat + 6 * sizeof(NvNotification)),
                             2 * sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_PIO_COMBINER_EVENT_NOTIFIER,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) (pDriverData->NvCommonDmaBufferFlat + 8 * sizeof(NvNotification)),
                             sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    for(DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead++) {
        if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                                 NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY + dwHead,
                                 NV01_CONTEXT_DMA,
                                 DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                                 (PVOID) (pDriverData->NvCommonDmaBufferFlat + (32 + 16 * dwHead) * sizeof(NvNotification)),
                                 9 * sizeof(NvNotification) - 1)) {
            dbgTracePop();
            return FALSE;
        }
    }

    dbgTracePop();
    return TRUE;
}

//---------------------------------------------------------------------------

//
//    nvDestroyNotifiers ()
//
//    This routine destroys all the DMA contexts used by DirectDraw
//    Basically they are the notifiers and the scanline buffer
//

DWORD __stdcall nvDestroyNotifiers (void)
{
    dbgTracePush ("nvDestroyNotifiers");

    // free dma contexts
    // free dma contexts
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_SCALED_IMAGE_CONTEXT_IID);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_PIO_COMBINER_EVENT_NOTIFIER);

    for(DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead++)
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY + dwHead);

    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY);

    dbgTracePop();
    return TRUE;
}

//---------------------------------------------------------------------------

BOOL nvCreateDACObjects (DWORD dwChannel, DWORD dwHandle)
{
    dbgTracePush ("nvCreateDAC");

    // create the best NV_DD_VIDEO_LUT_CURSOR_DAC object we can
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_007C_DAC) {
        for (DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
            NV07C_ALLOCATION_PARAMETERS nv07cAllocParms;
            nv07cAllocParms.logicalHeadId = dwHead;
#ifndef WINNT
            if (pDriverData->dwDesktopState != NVTWINVIEW_STATE_DUALVIEW) {
                // RM needs physical head, map logical to physical
                NVTWINVIEWDATA twinData;
                twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
                twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
                twinData.dwCrtc   = nv07cAllocParms.logicalHeadId;
                MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
                nv07cAllocParms.logicalHeadId = twinData.dwCrtc;
            }
#endif
            // Logically, this next line of code should be executed.
            // It maps the logical head number to a physical one.
            // The other pieces of code that deal with this object
            // probably compensate for this irregularity.    PG 04/09/2001
            //nv07cAllocParms.logicalHeadId = ppdev->ulDeviceDisplay[dwHead];
            if (NvRmAlloc (pDriverData->dwRootHandle, dwChannel,
                           dwHandle + dwHead, NV15_VIDEO_LUT_CURSOR_DAC,
                           &nv07cAllocParms) != NVOS21_STATUS_SUCCESS) {
                dbgTracePop();
                return (FALSE);
            }
        }
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0067_DAC) {
        NVDD_ALLOCOBJECT (dwChannel, dwHandle, NV10_VIDEO_LUT_CURSOR_DAC);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0049_DAC) {
        NVDD_ALLOCOBJECT (dwChannel, dwHandle, NV05_VIDEO_LUT_CURSOR_DAC);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0046_DAC) {
        NVDD_ALLOCOBJECT (dwChannel, dwHandle, NV04_VIDEO_LUT_CURSOR_DAC);
    }
    else {
        DPF ("hardware doesn't seem to support any flavor of the VIDEO_LUT_CURSOR_DAC class!");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // clear the flip counters and the notifiers associated therewith
    for (DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        pDriverData->dwCurrentFlip[dwHead]   = 0;
        pDriverData->dwCompletedFlip[dwHead] = 0;
    }

    // clear the flip-primary notifier memory
    memset((void*)pDriverData->pDmaFlipPrimaryNotifierFlat, 0, pDriverData->dwHeads * 16 * sizeof(NvNotification));

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableDDraw (void)
{
    DWORD dwPixelDepth;

    dbgTracePush ("nvAllocateDDrawObjects");

    dwPixelDepth = getDC()->dwEnablePixelDepth;

    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_CONTEXT_ROP, NV3_CONTEXT_ROP);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_CONTEXT_PATTERN, NV4_CONTEXT_PATTERN);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_IMAGE_BLACK_RECTANGLE, NV1_IMAGE_BLACK_RECTANGLE);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_CONTEXT_COLOR_KEY, NV4_CONTEXT_COLOR_KEY);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_CONTEXT_BETA4, NV4_CONTEXT_BETA);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_ROP_GDI_RECT_AND_TEXT, NV4_GDI_RECTANGLE_TEXT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_GENERIC_STRETCHED_IMAGE, (pDriverData->fDeviceHasDitheringControl ?
                                                                     NV05_STRETCHED_IMAGE_FROM_CPU :
                                                                     NV04_STRETCHED_IMAGE_FROM_CPU));
    DWORD dwScaledImageFromMemClass;
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        pDriverData->fDeviceHasDitheringControl = TRUE;
        dwScaledImageFromMemClass = NV10_SCALED_IMAGE_FROM_MEMORY;
    } else if (pDriverData->fDeviceHasDitheringControl) {
        pDriverData->fDeviceHasDitheringControl = TRUE;
        dwScaledImageFromMemClass = NV05_SCALED_IMAGE_FROM_MEMORY;
    } else {
        pDriverData->fDeviceHasDitheringControl = FALSE;
        dwScaledImageFromMemClass = NV4_SCALED_IMAGE_FROM_MEMORY;
    }
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SCALED_IMAGE_IID, dwScaledImageFromMemClass);

    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_IMAGE_BLIT, NV4_IMAGE_BLIT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SRCCOPY_IMAGE_BLIT, NV4_IMAGE_BLIT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT, NV4_IMAGE_BLIT);

    // create the best NV_DD_SURFACES_2D we can
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0062_CTXSURF2D) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SURFACES_2D, NV10_CONTEXT_SURFACES_2D);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0042_CTXSURF2D) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SURFACES_2D, NV4_CONTEXT_SURFACES_2D);
    }
    else {
        DPF ("hardware doesn't seem to support any CONTEXT_SURFACES_2D class!");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // create the best NV_DD_INDEXED_IMAGE_FROM_CPU we can
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0064_IDXIMAGE) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_INDEXED_IMAGE_FROM_CPU, NV05_INDEXED_IMAGE_FROM_CPU);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0060_IDXIMAGE) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_INDEXED_IMAGE_FROM_CPU, NV04_INDEXED_IMAGE_FROM_CPU);
    }
    else {
        DPF ("hardware doesn't seem to support any INDEXED_IMAGE class!");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // make sure we have the correct desktop state, this can change if the user presses the f8 hotkey
    // on mobile systems
#ifdef WINNT
    pDriverData->dwDesktopState = ppdev->TwinView_State;
#else
    NVTWINVIEWDATA twinViewData;
    memset(&twinViewData, 0, sizeof(twinViewData));
    twinViewData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinViewData.dwAction = NVTWINVIEW_ACTION_SETGET_STATE;
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, 0, NULL, sizeof(twinViewData), (char*)&twinViewData);
    nvAssert(twinViewData.dwSuccess);
    pDriverData->dwDesktopState = twinViewData.dwState;
#endif

    // initialise and reset the frame tracker
    getDC()->pBlitTracker->create(0, FALSE);
    getDC()->dwCurrentBlit = 0;

    // create the regular set of DAC objects
    if (!nvCreateDACObjects (NV_DD_DEV_DMA, NV_DD_VIDEO_LUT_CURSOR_DAC)) {
        dbgTracePop();
        return (FALSE);
    }

    // create another set of DAC object for the secondary DAC channel used on nv20
#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        if (!nvCreateDACObjects (NV_DD_DEV_DAC, NV_DD_VIDEO_LUT_CURSOR_DAC_2)) {
            dbgTracePop();
            return (FALSE);
        }
    }
#endif
#endif

    if (dwPixelDepth == 8) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_P_V_SHARED_VIDEO_COLORMAP, NV_PATCHCORD_VIDEO);
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SHARED_VIDEO_COLORMAP, NV_VIDEO_COLORMAP);
    }

    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_GENERIC_MTMF_1, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_GENERIC_MTMF_2, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_SINK, NV_VIDEO_SINK);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableContextDMAs (void)
{
    dbgTracePush ("nvAllocateContextDMAs");

    // Free any existing dynamic context dma objects
    if (pDriverData->dwVidMemCtxDmaSize != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);
        pDriverData->dwVidMemCtxDmaSize = 0;
    }

    if (pDriverData->dwMCIDCTAGPCtxDmaSize[0] != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY);
        pDriverData->dwMCIDCTAGPCtxDmaSize[0] = 0;
    }

    if (pDriverData->dwMCIDCTAGPCtxDmaSize[1] != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, NV_DD_DMA_FLOATING_MC_IDCT1_CONTEXT_DMA_FROM_MEMORY);
        pDriverData->dwMCIDCTAGPCtxDmaSize[1] = 0;
    }

    if (pDriverData->dwMCIDCTAGPCtxDmaSize[2] != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, NV_DD_DMA_FLOATING_MC_IDCT2_CONTEXT_DMA_FROM_MEMORY);
        pDriverData->dwMCIDCTAGPCtxDmaSize[2] = 0;
    }

    if (pDriverData->dwMCIDCTAGPCtxDmaSize[3] != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, NV_DD_DMA_FLOATING_MC_IDCT3_CONTEXT_DMA_FROM_MEMORY);
        pDriverData->dwMCIDCTAGPCtxDmaSize[3] = 0;
    }

    // Allocate our video memory context dmas
    pDriverData->dwVidMemCtxDmaSize = (DWORD)(pDriverData->VideoHeapEnd - pDriverData->BaseAddress);

    NvRmAllocContextDma(pDriverData->dwRootHandle,
                        NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(pDriverData->BaseAddress),
                        pDriverData->dwVidMemCtxDmaSize);

    NvRmAllocContextDma(pDriverData->dwRootHandle,
                        NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(pDriverData->BaseAddress),
                        pDriverData->dwVidMemCtxDmaSize);

    NvRmAllocContextDma(pDriverData->dwRootHandle,
                        NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(pDriverData->BaseAddress),
                        pDriverData->dwVidMemCtxDmaSize);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvInitDDrawObjects (void)
{
    dbgTracePush ("nvInitDDrawObjects");

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = GET_HALINFO();

    DWORD dwPixelDepth = getDC()->dwEnablePixelDepth;

    nvPushData (0,dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000);
    nvPushData (1,NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_IMAGE) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (3,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPushData (4,dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData (5,NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (6,dDrawSubchannelOffset(NV_DD_STRETCH) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (7,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPushData (8,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (9,NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (10,dDrawSubchannelOffset(NV_DD_SPARE) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (11,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPushData (12,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (13,NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (14,dDrawSubchannelOffset(NV_DD_SPARE) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (15,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPusherAdjust (16);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
    nvPushData (3,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (4,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
    nvPushData (5,NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

    nvPushData (6,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
    nvPushData (7,NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (8,dDrawSubchannelOffset(NV_DD_SURFACES) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
    nvPushData (9,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (10,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
    nvPushData (11,NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

    nvPushData (12,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000);
    nvPushData (13,NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (14,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
    nvPushData (15,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (16,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
    nvPushData (17,NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

    nvPushData (18,dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);
    nvPushData (19,NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (20,dDrawSubchannelOffset(NV_DD_BLIT) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
    nvPushData (21,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (22,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
    nvPushData (23,NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

    nvPusherAdjust (24);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_GENERIC_MTMF_1);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (3,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPushData (4,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
    nvPushData (5,NV_DD_GENERIC_MTMF_2);
    nvPushData (6,dDrawSubchannelOffset(NV_DD_SURFACES) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (7,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPusherAdjust(8);

    for (DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        // initialize LUT-cursor-DAC object
        nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
        nvPushData (1,NV_DD_VIDEO_LUT_CURSOR_DAC + dwHead);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV067_SET_CONTEXT_DMA_NOTIFIES | 0x1C0000);
        nvPushData (3,NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY + dwHead);
        nvPushData (4,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image a
        nvPushData (5,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image b
        nvPushData (6,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT a
        nvPushData (7,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT b
        nvPushData (8,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor a
        nvPushData (9,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor b
        nvPushData (10,dDrawSubchannelOffset(NV_DD_ROP) + NV067_SET_DAC(0) | 0x40000);
        nvPushData (11,asmMergeCoords(GET_MODE_WIDTH(), GET_MODE_HEIGHT()));
        nvPusherAdjust (12);
    }

    /*
     * Connect buffer patch objects
     */
    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000);
    nvPushData (1,NV_DD_SURFACES_2D);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV042_SET_COLOR_FORMAT | 0x40000);

    if (dwPixelDepth == 8) {
        nvPushData (3,NV042_SET_COLOR_FORMAT_LE_Y8);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_Y8;
    }
    else if (dwPixelDepth == 16) {
        nvPushData (3,NV042_SET_COLOR_FORMAT_LE_R5G6B5);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
    }
    else {
        nvAssert (dwPixelDepth == 32);
        nvPushData (3,NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
    }

    nvPushData (4,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV042_SET_CONTEXT_DMA_IMAGE_SOURCE | 0x80000);
    nvPushData (5,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvPushData (6,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvPushData (7,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV042_SET_PITCH | 0xC0000);
    nvPushData (8,(pHalInfo->vmiData.lDisplayPitch << 16) | pHalInfo->vmiData.lDisplayPitch);
    nvPushData (9,0);
    nvPushData (10,0);
    pDriverData->bltData.dwLastCombinedPitch = (pHalInfo->vmiData.lDisplayPitch << 16) |
                                          pHalInfo->vmiData.lDisplayPitch;
    pDriverData->bltData.dwLastSrcOffset = 0;
    pDriverData->bltData.dwLastDstOffset = 0;

    nvPusherAdjust (11);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_IMAGE_BLIT);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_CONTEXT_COLOR_KEY | 0x40000);
    nvPushData (3,NV_DD_CONTEXT_COLOR_KEY);
//       NV_DD_IMAGE_BLACK_RECTANGLE);  // messes up D3D surface clip
    nvPushData (4,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_CONTEXT_PATTERN | 0x80000);
    nvPushData (5,NV_DD_CONTEXT_PATTERN);
    nvPushData (6,NV_DD_CONTEXT_ROP);
    nvPushData (7,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_OPERATION | 0x40000);
    nvPushData (8,NV05F_SET_OPERATION_ROP_AND);
    nvPushData (9,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_CONTEXT_SURFACES | 0x40000);
    nvPushData (10,NV_DD_SURFACES_2D);

    nvPusherAdjust (11);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_SRCCOPY_IMAGE_BLIT);
//   nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) +
//       NV05F_SET_CONTEXT_COLOR_KEY | 0x40000);   // destination alpha not supported if context color key set
//   nvPushData (3,NV_DD_CONTEXT_COLOR_KEY);
//       NV_DD_IMAGE_BLACK_RECTANGLE);  // messes up D3D surface clip
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_OPERATION | 0x40000);
    nvPushData (3,NV05F_SET_OPERATION_SRCCOPY);
    nvPushData (4,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_CONTEXT_SURFACES | 0x40000);
    nvPushData (5,NV_DD_SURFACES_2D);

    nvPusherAdjust (6);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_SCALED_IMAGE_IID);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_CONTEXT_DMA_NOTIFIES | 0x80000);
    nvPushData (3,NV_DD_SCALED_IMAGE_CONTEXT_IID);
    nvPushData (4,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY); // SetContextDmaImage
    nvPushData (5,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_CONTEXT_PATTERN | 0x80000);
    nvPushData (6,NV_DD_CONTEXT_PATTERN);
    nvPushData (7,NV_DD_CONTEXT_ROP);
    nvPushData (8,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_OPERATION | 0x40000);
    nvPushData (9,NV063_SET_OPERATION_ROP_AND);
    nvPushData (10,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_CONTEXT_SURFACE | 0x40000);
    nvPushData (11,NV_DD_SURFACES_2D);
    nvPushData (12,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_COLOR_FORMAT | 0x40000);
    nvPushData (13,((dwPixelDepth==16) ? NV063_SET_COLOR_FORMAT_LE_R5G6B5 : NV063_SET_COLOR_FORMAT_LE_X8R8G8B8));

    if (pDriverData->fDeviceHasDitheringControl) {
        nvPushData (14,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_COLOR_CONVERSION | 0x40000);
        nvPushData (15,NV063_SET_COLOR_CONVERSION_TRUNCATE);
        nvPusherAdjust (16);
    }
    else {
        nvPusherAdjust (14);
    }

    nvPushData (0,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
    nvPushData (1,NV_DD_GENERIC_STRETCHED_IMAGE);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_SURFACES) | NV066_SET_CONTEXT_COLOR_KEY | 0xC0000);
    nvPushData (3,NV_DD_CONTEXT_COLOR_KEY);
    nvPushData (4,NV_DD_CONTEXT_PATTERN);
    nvPushData (5,NV_DD_CONTEXT_ROP);
    nvPushData (6,dDrawSubchannelOffset(NV_DD_SURFACES) | NV066_SET_OPERATION | 0x40000);
    nvPushData (7,NV066_SET_OPERATION_ROP_AND);
    nvPushData (8,dDrawSubchannelOffset(NV_DD_SURFACES) | NV066_SET_CONTEXT_SURFACE | 0x40000);
    nvPushData (9,NV_DD_SURFACES_2D);
    nvPushData (10,dDrawSubchannelOffset(NV_DD_SURFACES) | NV066_SET_COLOR_FORMAT | 0x40000);
    /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
    /* Must be set to a legal value but hardware ignores it otherwise */
    nvPushData (11,NV066_SET_COLOR_FORMAT_LE_X8R8G8B8);
    nvPusherAdjust (12);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000);
    nvPushData (1,NV_DD_IMAGE_FROM_CPU);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV061_SET_CONTEXT_COLOR_KEY | 0x100000);
    nvPushData (3,NV_DD_CONTEXT_COLOR_KEY);
    nvPushData (4,NV_DD_IMAGE_BLACK_RECTANGLE);
    nvPushData (5,NV_DD_CONTEXT_PATTERN);
    nvPushData (6,NV_DD_CONTEXT_ROP);
    nvPushData (7,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV061_SET_CONTEXT_SURFACE | 0x40000);
    nvPushData (8,NV_DD_SURFACES_2D);
    nvPushData (9,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV061_SET_OPERATION | 0x80000);
    nvPushData (10,NV061_SET_OPERATION_ROP_AND);

    if (dwPixelDepth == 8) {
        // Y8 color format assumed by hardware when destination surface in 8bpp mode
        // Must be set to a legal value but hardware ignores it otherwise
        nvPushData (11,NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
    }
    else if (dwPixelDepth == 16) {
        nvPushData (11,NV061_SET_COLOR_FORMAT_LE_R5G6B5);
    }
    else {
        nvAssert (dwPixelDepth == 32);
        nvPushData (11,NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
    }

    nvPusherAdjust (12);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData (1,NV_DD_INDEXED_IMAGE_FROM_CPU);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_STRETCH) + NV064_SET_CONTEXT_DMA_LUT | 0x40000);
    nvPushData (3,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvPushData (4,dDrawSubchannelOffset(NV_DD_STRETCH) + NV064_SET_CONTEXT_CLIP_RECTANGLE | 0x40000);
    nvPushData (5,NV_DD_IMAGE_BLACK_RECTANGLE);
    nvPushData (6,dDrawSubchannelOffset(NV_DD_STRETCH) + NV064_SET_CONTEXT_SURFACE | 0x40000);
    nvPushData (7,NV_DD_SURFACES_2D);
    nvPushData (8,dDrawSubchannelOffset(NV_DD_STRETCH) + NV064_SET_COLOR_CONVERSION | 0x40000);
    nvPushData (9,NV064_SET_COLOR_CONVERSION_TRUNCATE);
    nvPushData (10,dDrawSubchannelOffset(NV_DD_STRETCH) + NV064_SET_OPERATION | 0x80000);
    nvPushData (11,NV064_SET_OPERATION_SRCCOPY);
    nvPushData (12,NV064_SET_COLOR_FORMAT_LE_X8R8G8B8);

    nvPusherAdjust (13);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000);
    nvPushData (1,NV_DD_ROP_GDI_RECT_AND_TEXT);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV04A_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (3,NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (4,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV04A_SET_CONTEXT_PATTERN | 0x80000);
    nvPushData (5,NV_DD_CONTEXT_PATTERN);
    nvPushData (6,NV_DD_CONTEXT_ROP);
    nvPushData (7,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV04A_SET_CONTEXT_SURFACE | 0x40000);
    nvPushData (8,NV_DD_SURFACES_2D);
    nvPushData (9,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV04A_SET_OPERATION | 0xC0000);
    nvPushData (10,NV04A_SET_OPERATION_ROP_AND);

    if (dwPixelDepth == 8) {
        // Y8 color format assumed by hardware when destination surface in 8bpp mode
        // Must be set to a legal value but hardware ignores it otherwise
        nvPushData (11,NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8);
    }
    else if (dwPixelDepth == 16) {
        nvPushData (11,NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5);
    }
    else {
        nvAssert (dwPixelDepth == 32);
        nvPushData (11,NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8);
    }

    nvPushData (12,NV04A_SET_MONOCHROME_FORMAT_CGA6_M1);

    nvPusherAdjust (13);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000);
    nvPushData (1,NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_IMAGE) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
    nvPushData (3,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (4,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
    nvPushData (5,NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY);

    nvPusherAdjust (6);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData (1,NV_DD_CONTEXT_COLOR_KEY);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_STRETCH) + NV057_SET_COLOR_FORMAT | 0x80000);

    if (dwPixelDepth == 8) {
        // A8Y8 color format assumed by hardware when destination surface in 8bpp mode
        // Must be set to a legal value but hardware ignores it otherwise
        nvPushData (3,NV057_SET_COLOR_FORMAT_LE_A8R8G8B8);
    }
    else if (dwPixelDepth == 16) {
        nvPushData (3,NV057_SET_COLOR_FORMAT_LE_A16R5G6B5);
    }
    else {
        nvAssert (dwPixelDepth == 32);
        nvPushData (3,NV057_SET_COLOR_FORMAT_LE_A8R8G8B8);
    }

    nvPushData (4,0);

    nvPusherAdjust (5);
    pDriverData->bltData.dwLastColourKey = 0xFFFFFFF0;    // invalidate

    // Pattern is currently only used for overlay video UV masking so
    // always set it's color format to 8 bit indexed.
    nvPushData (0,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (1,NV_DD_CONTEXT_PATTERN);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_COLOR_FORMAT | 0x80000);
    // A8Y8 color format assumed by hardware when destination surface in 8bpp mode
    // Must be set to a legal value but hardware ignores it otherwise
    nvPushData (3,NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
    nvPushData (4,NV044_SET_MONOCHROME_FORMAT_CGA6_M1);
    nvPushData (5,dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_PATTERN_SELECT | 0xC0000);
    nvPushData (6,NV044_SET_PATTERN_SELECT_MONOCHROME);

    if (dwPixelDepth == 8) {
        nvPushData (7,NV_ALPHA_1_008);
        nvPushData (8,NV_ALPHA_1_008);
    }
    else if (dwPixelDepth == 16) {
        nvPushData (7,NV_ALPHA_1_016);
        nvPushData (8,NV_ALPHA_1_016);
    }
    else {
        nvPushData (7,NV_ALPHA_1_032);
        nvPushData (8,NV_ALPHA_1_032);
    }

    nvPusherAdjust (9);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_IMAGE_BLACK_RECTANGLE);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV019_SET_POINT | 0x80000);
    nvPushData (3,0);
    nvPushData (4,asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP));

    nvPusherAdjust (5);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_CONTEXT_ROP);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
    nvPushData (3,NV_DD_SURFACES_2D);
    nvPushData (4,dDrawSubchannelOffset(NV_DD_SURFACES) + NV042_SET_PITCH | 0xC0000);
    nvPushData (5,(pHalInfo->vmiData.lDisplayPitch << 16) | pHalInfo->vmiData.lDisplayPitch);
    nvPushData (6,0);
    nvPushData (7,0);

    nvPushData (8,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000);
    nvPushData (9,NV_DD_ROP_GDI_RECT_AND_TEXT);
    nvPushData (10,dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);
    nvPushData (11,NV_DD_IMAGE_BLIT);
    nvPushData (12,dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000);
    nvPushData (13,NV_DD_IMAGE_FROM_CPU);
    nvPushData (14,dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData (15,NV_DD_GENERIC_STRETCHED_IMAGE);

    nvPusherAdjust (16);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) + NV043_SET_ROP5 | 0x40000);
    nvPushData (1,0x00000000);
    pDriverData->bltData.dwLastRop = 0;

    // Force rectangle portion of patch to be validated (assures no RM interrupts on Lock calls)
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV04A_COLOR1_A | 0xC0000);
    nvPushData (3,0);
    nvPushData (4,0);
    nvPushData (5,0);

    // Force Blit to be instantiated
    nvPushData (6,dDrawSubchannelOffset(NV_DD_BLIT) + NV05F_CONTROL_POINT_IN | 0x40000);
    nvPushData (7,0);

    nvPusherAdjust (8);

    // flush cached values
    pDriverData->bltData.dwLastRop = 0xFFFFFFFF;
    pDriverData->bltData.dwLastColourKey = 0xFFFFFFF0;
    pDriverData->bltData.dwLastColourFormat = 0;
    pDriverData->bltData.dwLastCombinedPitch = 0;
    pDriverData->bltData.dwLastSrcOffset = 0xFFFFFFFF;
    pDriverData->bltData.dwLastDstOffset = 0xFFFFFFFF;

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableD3D (void)
{
    dbgTracePush ("nvEnableD3D");

    // the push buffer should have already been created at this point
    if (!getDC()->nvPusher.isValid()) {
        dbgTracePop();
        return (FALSE);
    }

    // Create the swizzled surface context.     NV 0x052
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_009E_CTXSURFSWZ) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CONTEXT_SURFACE_SWIZZLED, NV15_CONTEXT_SURFACE_SWIZZLED);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0052_CTXSURFSWZ){
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CONTEXT_SURFACE_SWIZZLED, NV04_CONTEXT_SURFACE_SWIZZLED);
    }
    else {
        DPF("Creation of D3D_CONTEXT_SURFACE_SWIZZLED object failed");
        dbgD3DError();
    }

    // create the best 3D surface context we can
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0093_CTXSURF3D) {
            NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CONTEXT_SURFACES_ARGB_ZS, NV10_CONTEXT_SURFACES_3D);
        }
        else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0053_CTXSURF3D) {
            NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CONTEXT_SURFACES_ARGB_ZS, NV04_CONTEXT_SURFACES_ARGB_ZS);
        }
        else {
            DPF("Creation of context surface 3d object failed");
            dbgD3DError();
        }
    }

    // create the best 3D rendering class we can
#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) {
#ifdef SPOOF_KELVIN
        // allocate a kelvin object for the sake of the trace file. this will fail. ignore return value.
        NvRmAllocObject (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_KELVIN_PRIMITIVE, NV20_KELVIN_PRIMITIVE);
#else
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_KELVIN_PRIMITIVE, NV20_KELVIN_PRIMITIVE);
#endif
        DPF_LEVEL(NVDBG_LEVEL_INFO, "HW supports NV20 Kelvin class");
    } else
#endif
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CELSIUS_PRIMITIVE, NV11_CELSIUS_PRIMITIVE);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "HW supports NV11 Celsius class");
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0096_CELSIUS) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CELSIUS_PRIMITIVE, NV15_CELSIUS_PRIMITIVE);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "HW supports NV15 Celsius class");
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0056_CELSIUS) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CELSIUS_PRIMITIVE, NV10_CELSIUS_PRIMITIVE);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "HW supports NV10 Celsius class");
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0094_DX5TRI |
                                                       NVCLASS_0095_DX6TRI)) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_DX5_TEXTURED_TRIANGLE, NV10_DX5_TEXTURED_TRIANGLE);
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_DX6_MULTI_TEXTURE_TRIANGLE, NV10_DX6_MULTI_TEXTURE_TRIANGLE);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0054_DX5TRI |
                                                       NVCLASS_0055_DX6TRI)) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_DX5_TEXTURED_TRIANGLE, NV04_DX5_TEXTURED_TRIANGLE);
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_DX6_MULTI_TEXTURE_TRIANGLE, NV04_DX6_MULTI_TEXTURE_TRIANGLE);
    }
    else {
        DPF ("blech. HW doesn't seem to support any 3D rendering classes");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // celsius's default state is the OGL view vector
    getDC()->bD3DViewVector = FALSE;

    // create RenderSolid rectangles or GDI rectangles for clearing
    // the z-buffer and rendering surfaces.
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_RENDER_SOLID_RECTANGLE, NV4_RENDER_SOLID_RECTANGLE);
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_RENDER_SOLID_RECTANGLE_2, NV4_RENDER_SOLID_RECTANGLE);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_004A_GDIRECT) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_GDI_RECTANGLE_TEXT, NV4_GDI_RECTANGLE_TEXT);
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_GDI_RECTANGLE_TEXT_2, NV4_GDI_RECTANGLE_TEXT);
    }
    else {
        DPF ("hardware supports neither D3D_GDI_RECTANGLE_TEXT nor NV4_RENDER_SOLID_RECTANGLE");
        dbgD3DError();
    }

    // create Scaled Image From Memory object for texture swizzling
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0089_SCALEDIMG) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_SCALED_IMAGE_FROM_MEMORY, NV10_SCALED_IMAGE_FROM_MEMORY);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0063_SCALEDIMG) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_SCALED_IMAGE_FROM_MEMORY, NV05_SCALED_IMAGE_FROM_MEMORY);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0077_SCALEDIMG) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_SCALED_IMAGE_FROM_MEMORY, NV04_SCALED_IMAGE_FROM_MEMORY);
    }
    else {
        DPF ("hardware supports no form of SCALED_IMAGE_FROM_MEMORY");
        dbgD3DError();
    }

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableHeaps (void)
{
    BOOL bRes;

    dbgTracePush ("nvEnableHeaps");

    if (pDriverData->GARTLinearBase) {
        bRes = nvAGPCreateHeap();
        if (bRes) {
            dbgTracePop();
            return bRes;
        }
        // AGP doesn't seem to be working, disable it
#if defined(WINNT) && !defined(NV_AGP)
        NvWin2KUnmapAgpHeap(pDriverData);
#endif
        pDriverData->GARTLinearBase = 0;
    }

    bRes = nvPCICreateHeap();

    dbgTracePop();
    return bRes;
}

//---------------------------------------------------------------------------

BOOL nvDisableHeaps (void)
{
    BOOL bRes;

    dbgTracePush ("nvDisableHeaps");

#if IS_WIN9X
    // Purge the heap of all DirectX allocations.
    // If things are cleaned up as they should be, there shouldn't be anything
    // to purge and this will therefore generate an "error" message from the RM.
//    NVHEAP_PURGE();
#endif

    if (pDriverData->GARTLinearBase) {
        bRes = nvAGPDestroyHeap();
    } else {
        bRes = nvPCIDestroyHeap();
    }

    dbgTracePop();
    return bRes;
}

//---------------------------------------------------------------------------

BOOL nvInitD3DObjects (void)
{
    dbgTracePush ("nvInitD3DObjects");

    // DO NOT REMOVE - test code to override tiling
    // NvRmConfigSetEx (pDriverData->dwRootHandle,pDriverData->dwDeviceIDNum,NV_CFGEX_DISABLE_TETRIS_TILING,0,0);

    // Hook up the ARGB_ZS surface context.
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {
        nvglSetObject(NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);
        nvglSetRenderTargetContexts(NV_DD_SPARE,
                                    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                                    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    }

    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
        // Hook up GDI Rectangle.
        nvglSetObject                      (NV_DD_SPARE, D3D_GDI_RECTANGLE_TEXT);
        nvglDrawRopRectAndTextSetSurface   (NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglDrawRopRectAndTextSetOperation (NV_DD_SPARE, NV04A_SET_OPERATION_SRCCOPY);

        // Hook up GDI Rectangle 2.
        nvglSetObject                        (NV_DD_SPARE, D3D_GDI_RECTANGLE_TEXT_2);
        nvglDrawRopRectAndTextSetSurface     (NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglDrawRopRectAndTextSetOperation   (NV_DD_SPARE, NV04A_SET_OPERATION_SRCCOPY);
        nvglDrawRopRectAndTextSetColorFormat (NV_DD_SPARE, NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8);
    }
    else {
        // Hook up the Render Solid Rectangle.
        nvglSetObject                     (NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
        nvglSetNv4SolidRectangleSurface   (NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglSetNv4SolidRectangleOperation (NV_DD_SPARE, NV05E_SET_OPERATION_SRCCOPY);

        // Hook up Render Solid Rectangle 2.
        nvglSetObject      (NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE_2);
        nvglSetNv4SolidRectangleSurface (NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglSetStartMethod (0,NV_DD_SPARE, NV05E_SET_OPERATION,1);
        nvglSetData        (1,             NV05E_SET_OPERATION_SRCCOPY);
        nvglSetStartMethod (2,NV_DD_SPARE, NV05E_SET_COLOR_FORMAT,1);
        nvglSetData        (3,             NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8);
        nvglAdjust         (4);
    }

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        // some bare bones initialization: put the thing in its channel and set up for notifers
        nvglSetObject (NV_DD_KELVIN, D3D_KELVIN_PRIMITIVE);
        nvglSetNv20KelvinNotifierContextDMA (NV_DD_KELVIN, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        // some bare bones initialization: put the thing in its channel and set up for notifers
        nvglSetObject (NV_DD_CELSIUS, D3D_CELSIUS_PRIMITIVE);
        nvglSetNv10CelsiusNotifierContextDMA (NV_DD_CELSIUS, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    }
    else
#endif
    {
        // no celsius or kelvin class. hook up DX5 / DX6 stuff

        // Hook up the Dx5 Textured Triangle.
        nvglSetObject(NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
        // Contexts. System/AGP goes to context A, Video Memory goes to context B.
        nvglSetDx5TriangleContexts(NV_DD_SPARE, D3D_CONTEXT_DMA_HOST_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
        // Rendering surface
        nvglSetDx5TriangleSurface(NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);
        // Notify context.
        nvglSetStartMethod(0, NV_DD_SPARE, NV054_SET_CONTEXT_DMA_NOTIFIES, 1);
        nvglSetData       (1, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
        nvglAdjust        (2);

        // Hook up the Dx6 Multi Textured Triangle.
        nvglSetObject(NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
        // System/AGP goes to context A, Video Memory goes to context B.
        nvglSetDx6TriangleContexts(NV_DD_SPARE, D3D_CONTEXT_DMA_HOST_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
        // Rendering surface
        nvglSetDx6TriangleSurface(NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);
        // Plug in the notify context.
        nvglSetStartMethod(0, NV_DD_SPARE, NV055_SET_CONTEXT_DMA_NOTIFIES, 1);
        nvglSetData       (1, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
        nvglAdjust        (2);
    }

    pDriverData->dwMostRecentHWUser = MODULE_ID_NONE;

    // Hook up the swizzled surface context.
    nvglSetObject(NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurfaceContextImage(NV_DD_SPARE, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    // Hook up the scaled image from memory object.
    // - Set the source image context.
    // - Set the destination surface context.
    // - Set operation
    nvglSetObject                     (NV_DD_SPARE, D3D_SCALED_IMAGE_FROM_MEMORY);
    nvglSetScaledImageContextImage    (NV_DD_SPARE, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvglSetScaledImageContextSurface  (NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetScaledImageOperation       (NV_DD_SPARE, NV077_SET_OPERATION_SRCCOPY);

    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvInitRefCounts (void)
{
    DWORD dwIndex;

    dbgTracePush ("nvInitRefCounts");

    // Clear motion comp reference counts
    for (dwIndex = 0; dwIndex < 8; dwIndex++) {
        pDriverData->nvMCSurfaceFlags[dwIndex].dwMCMotionCompReferenceCount = 0;
        pDriverData->nvMCSurfaceFlags[dwIndex].dwMCFormatCnvReferenceCount = 0;
        pDriverData->nvMCSurfaceFlags[dwIndex].dwMCCompositeReferenceCount = 0;
        pDriverData->nvMCSurfaceFlags[dwIndex].dwMCTemporalFilterReferenceCount = 0;
    }
    for (dwIndex = 0; dwIndex < 4; dwIndex++) {
        pDriverData->dwMCNVIDSurfaceReferenceCount[dwIndex] = 0;
    }

    // initialize ref count and frame tracker
    DWORD dwTimeOut = (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ?
                          50 :
                          (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) ?
                              50 :
                              1;
    getDC()->pRefCount->create (dwTimeOut);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableOverlay (void)
{
    NvU8 bRestoreOverlaySurfaces;
    NvU32 uiSubchannel = NULL;
    NvU32 uiClassID    = NULL;

    dbgTracePush ("nvEnableOverlay");

    bRestoreOverlaySurfaces = (pDriverData->vpp.dwOverlaySurfaces && pDriverData->vpp.dwOverlayFSOvlHeadSaved != 0xFFFFFFFF);

    // Set up default values for device version < NV10

    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_20)
    {
        uiSubchannel = NV_DD_KELVIN;
        uiClassID    = D3D_KELVIN_PRIMITIVE;
    }
    else if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
    {
        uiSubchannel = NV_DD_CELSIUS;
        uiClassID    = D3D_CELSIUS_PRIMITIVE;
    }

    if (!VppEnable(
       &pDriverData->vpp,
#ifdef WINNT
       ppdev,
#else
       NULL,
#endif
       &pDriverData->nvPusher,
       NV_DD_DEV_DMA,
       uiClassID,   // Class ID
       uiSubchannel,// Sub channel
       &pDriverData->dwMostRecentHWUser,
       NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
       NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,
       NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,
       NV_DD_VIDEO_LUT_CURSOR_DAC,  // Up to pDriverData->dwHeads of these... @mjl@ pass dwHeads
       NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER,
       D3D_CONTEXT_SURFACE_SWIZZLED,
       NV_DD_CONTEXT_BETA4,
       NV_DD_SURFACES_2D,
       NV_DD_SURFACES,           // Subchannel holding a 2D surface object
       NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT,
       NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT,
       NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT,

       0,
       NV_DD_CONTEXT_PATTERN,
       NV_DD_CONTEXT_ROP,
       NV_DD_CONTEXT_COLOR_KEY,
       NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW,

       pDriverData->pDmaFlipPrimaryNotifierFlat,
       pDriverData->pDmaPusherSyncNotifierFlat,
       pDriverData->pPioColourControlEventNotifierFlat,

       D3D_CONTEXT_SURFACES_ARGB_ZS,
       D3D_DX6_MULTI_TEXTURE_TRIANGLE,
       NV_DD_IMAGE_BLACK_RECTANGLE,

       NV_DD_ROP_RECT_AND_TEXT, // Subchannel holding RECT_AND_TEXT object
       NV_DD_ROP,               // Subchannel holding ROP object
       NV_DD_SPARE              // spare subchannel
       ))
    {
        dbgTracePop();
        return FALSE;
    }

    if (bRestoreOverlaySurfaces) // we interrupted an app which had open overlays, recreate those objects
    {
#ifdef IS_WIN9X
        DWORD dwSaveCurrentHead = pDXShare->dwHeadNumber;
        pDXShare->dwHeadNumber = pDriverData->vpp.dwOverlayFSOvlHeadSaved;
#endif
        VppCreateOverlay(&pDriverData->vpp);
        VppCreateFSMirror(&pDriverData->vpp, pDriverData->vpp.dwOverlayFSSrcWidth, pDriverData->vpp.dwOverlayFSSrcHeight);

#ifdef IS_WIN9X
        pDXShare->dwHeadNumber = dwSaveCurrentHead;
#endif
    }

//    VppReadRegistry(pVpp);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableSemaphores (void)
{
    dbgTracePush ("nvEnableSemaphores");

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    // set up the second DAC and other semaphore-related stuff
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        if (!getDC()->nvSemaphoreManager.create()) {
            DPF ("failed to create semaphore manager");
            dbgTracePop();
            return (FALSE);
        }

        if (!getDC()->nvFlipper.create()) {
            DPF ("failed to create flipper");
            dbgTracePop();
            return (FALSE);
        }

        // set up kelvin
        nvglSetObject (NV_DD_SPARE, D3D_KELVIN_PRIMITIVE);
        nvPushData (0, (0x00040000 | (NV_DD_SPARE << 13) | NV097_SET_CONTEXT_DMA_SEMAPHORE));
        nvPushData (1, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_IN_MEMORY);    // must be read-write
        nvPusherAdjust (2);

        // set up the LUT-cursor-DAC objects
        for (DWORD dwHead=0; dwHead < pDriverData->dwHeads; dwHead++) {
            getDC()->nvPusherDAC.push ( 0, (0x00040000 | (NV_DD_SUBCH_DAC << 13)));
            getDC()->nvPusherDAC.push ( 1, NV_DD_VIDEO_LUT_CURSOR_DAC_2 + dwHead);
            getDC()->nvPusherDAC.push ( 2, (0x00200000 | (NV_DD_SUBCH_DAC << 13) | NV07C_SET_CONTEXT_DMA_NOTIFIES));
            getDC()->nvPusherDAC.push ( 3, NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
            getDC()->nvPusherDAC.push ( 4, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // image a
            getDC()->nvPusherDAC.push ( 5, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // image b
            getDC()->nvPusherDAC.push ( 6, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // LUT a
            getDC()->nvPusherDAC.push ( 7, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // LUT b
            getDC()->nvPusherDAC.push ( 8, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // cursor a
            getDC()->nvPusherDAC.push ( 9, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // cursor b
            getDC()->nvPusherDAC.push (10, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);  // semaphore (must be read only)
            getDC()->nvPusherDAC.push (11, (0x00040000 | (NV_DD_SUBCH_DAC << 13) | NV07C_SET_DAC(0)));
            getDC()->nvPusherDAC.push (12, asmMergeCoords (GET_MODE_WIDTH(), GET_MODE_HEIGHT()));
            getDC()->nvPusherDAC.adjust (13);
        }

        // set up the 3D channel
        nvPushData (0, (0x00040000 | (NV_DD_SPARE << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
        nvPushData (1, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);  // must be read only
        nvPusherAdjust (2);

        // set up the DAC channel
        getDC()->nvPusherDAC.push (0, (0x00040000 | (NV_DD_SUBCH_DAC << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
        getDC()->nvPusherDAC.push (1, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);  // must be read only
        getDC()->nvPusherDAC.adjust (2);
    }
#endif
#endif

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// nvEnable32()
// create push puffer, channels, and objects

BOOL nvEnable32
(
    LPDDRAWI_DIRECTDRAW_GBL  // not used
)
{
    dbgTracePush ("nvEnable32");

    nvAssert (!global.b16BitCode);

    pDriverData->bltData.dwSystemBltFallback = FALSE;

    if (getDC()->dwEnableStatus == CDriverContext::DC_ENABLESTATUS_PENDINGDISABLE) {
        // we tried to disable before but couldn't. disable now.
        nvDisable32();
    }

    if (getDC()->dwEnableStatus == CDriverContext::DC_ENABLESTATUS_ENABLED) {
        // we're already enabled
        dbgTracePop();
        return (TRUE);
    }

    if ((pDriverData->dwFullScreenDOSStatus & (FSDOSSTATUS_RECOVERYNEEDED_D3D | FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) &&
        (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE))) {
        // currently in full screen DOS. don't allow channel to be enabled
        dbgTracePop();
        return (FALSE);
    }

    getDisplayDuration();

#ifdef CAPTURE
    // move to the next capture file
    captureFileInc();
#endif

#ifdef NV_AGP
    if (ppdev->bAgp) {
        NvRmConfigGet(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFG_AGP_LINEAR_BASE, &pDriverData->GARTLinearBase);
        NvRmConfigGet(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFG_AGP_PHYS_BASE,   &pDriverData->GARTPhysicalBase);
    } else {
        pDriverData->GARTLinearBase   = 0;
        pDriverData->GARTPhysicalBase = 0;
    }
    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "nvEnable32: GARTLinearBase = %08x, GARTPhysicalBase = %08x", pDriverData->GARTLinearBase, pDriverData->GARTPhysicalBase);
#else
#ifdef WINNT
    if (pDriverData->GARTPhysicalBase && !pDriverData->GARTLinearBase)
    {
        NvWin2KMapAgpHeap(pDriverData);
    }
#endif // WINNT
#endif

    if (pDriverData->bltVidMemInfo.dwLocale == BLTWS_VIDEO) {
        NVHEAP_FREE (pDriverData->bltVidMemInfo.fpVidMem);
        pDriverData->bltVidMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    pmDeleteAllProcesses(pDriverData);

    // we used to purge the heap here - this breaks NV11 running multiple apps since the heap
    // would then be purged whenever the second device is enumerated.
    // a heap purge should not be necessary - any special cleanup should only clean out what is
    // really needed.
    // NVHEAP_PURGE ();

    if (!nvEnableHeaps()) {
        DPF ("could not enable heaps");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // allocate a push buffer
    if (!getDC()->nvPusher.allocate (NV_DD_DEV_DMA)) {
        DPF ("failed to allocate push buffer");
        dbgTracePop();
        return (FALSE);
    }

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        if (!getDC()->nvPusherDAC.allocate (NV_DD_DEV_DAC)) {
            DPF ("failed to allocate DAC push buffer");
        }
    }
#endif
#endif

    // fetch and cache off the pixel depth so we know what to disable later
    DWORD dwPixelDepth = GET_MODE_BPP();
    getDC()->dwEnablePixelDepth = dwPixelDepth;

    nvCreateVidHeapVarsAndPseudoNotifier();

    if (!nvCreateNotifiers()) {
        DPF ("failed to create notifiers");
        dbgD3DError();
        dbgTracePop();
        return FALSE;
    }

    if (!nvEnableNotifiers()) {
        DPF ("failed to enable notifiers");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvEnableContextDMAs()) {
        DPF ("could not enable context DMAs");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvEnableDDraw()) {
        DPF ("could not enable ddraw");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvInitDDrawObjects()) {
        DPF ("could not initialize ddraw objects");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvEnableD3D()) {
        DPF ("could enable D3D");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvInitD3DObjects()) {
        DPF ("could not initialize d3d objects");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvInitRefCounts()) {
        DPF ("could not initialize ref counts");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvEnableOverlay()) {
        DPF ("could not enable overlay");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    dbgFlushType (NVDBG_FLUSH_SETUP);

    DWORD dwHeap = getDC()->nvPusher.getHeap();

    if (getDC()->nvD3DPerfData.dwRecommendedStageBufferSize) {
        if (!getDC()->defaultVB.create (dwHeap, getDC()->nvD3DPerfData.dwRecommendedStageBufferSize)) {
            DPF ("failed to create default vertex buffer");
            dbgD3DError();
        }
    }

    if (!nvEnableSemaphores()) {
        DPF ("could not enable semaphores");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvTextureDefaultAlloc()) {
        DPF ("could not create default textures");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // Make final subchannel assignments

    // 0 - NV_DD_ROP
    nvglSetObject (NV_DD_ROP, NV_DD_CONTEXT_ROP);
    // 1 - NV_DD_SURFACES
    nvglSetObject (NV_DD_SURFACES, NV_DD_SURFACES_2D);
    // 2 - NV_DD_ROP_RECT_AND_TEXT
    nvglSetObject (NV_DD_ROP_RECT_AND_TEXT, NV_DD_ROP_GDI_RECT_AND_TEXT);
    // 3 - NV_DD_BLIT
    nvglSetObject (NV_DD_BLIT, NV_DD_IMAGE_BLIT);
    // 4 - NV_DD_IMAGE
    nvglSetObject (NV_DD_IMAGE, NV_DD_IMAGE_FROM_CPU);
    // 5 - NV_DD_STRETCH
    nvglSetObject (NV_DD_STRETCH, NV_DD_GENERIC_STRETCHED_IMAGE); // NOTE! This subchannel is NOT fixed.  Do a set before use!
    // 6 - NV_DD_CELSIUS
    // 6 - NV_DD_KELVIN
#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvglSetObject (NV_DD_KELVIN, D3D_KELVIN_PRIMITIVE);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvglSetObject (NV_DD_CELSIUS, D3D_CELSIUS_PRIMITIVE);
    }
#endif
    // 7 - NV_DD_SPARE
    pDriverData->dDrawSpareSubchannelObject = 0;

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        // the RM does not set the celsius defaults reliably. failure to init the
        // eye direction vector here will cause D3D HAL fog to fail (e.g. dolphin)
        nvglSetNv10CelsiusEyeDirection(NV_DD_CELSIUS, 0.f, 0.f, 1.f);
    }

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        // set default objects on the DAC channel
        getDC()->nvPusherDAC.push (0, (0x00040000 | (NV_DD_SUBCH_DAC << 13)));
        getDC()->nvPusherDAC.push (1, NV_DD_VIDEO_LUT_CURSOR_DAC_2);
        getDC()->nvPusherDAC.adjust (2);
    }
#endif
#endif

    // figure out which channel we're on
    getDC()->nvPusher.flush (FALSE, CPushBuffer::FLUSH_WITH_DELAY);
    getDC()->nvPusher.waitForOtherChannels();

    NvNotification *npDmaSyncNotifier = pDriverData->pDmaSyncNotifierFlat;

    DWORD dwIndex = 0xffffffff;
    pDriverData->dwDDDmaPusherChannelIndex = 1;

    while (dwIndex != pDriverData->dwDDDmaPusherChannelIndex) {

        pDriverData->dwDDDmaPusherChannelIndex = dwIndex;
        npDmaSyncNotifier->status = NV_IN_PROGRESS;

        nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
        nvPushData (1,0);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
        nvPushData (3,0);
        nvPusherAdjust (4);
        nvPusherStart  (TRUE);

        while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

        NV_DD_GET_DMA_CHANNEL_INDEX (dwIndex);
    }

    pDriverData->dwDDDmaPusherChannelMask = 1 << pDriverData->dwDDDmaPusherChannelIndex;

    // Perform any re-enabling of D3D.
    nvD3DRecover();

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    pDriverData->DDrawVideoSurfaceCount = 0;

    pDriverData->ddClipUpdate = TRUE;

    // All active floating DMA contexts have been reset
    pDriverData->fNvActiveFloatingContexts = 0;

    // Make sure overlay owner checking is enabled
    pDriverData->vpp.overlayRelaxOwnerCheck = 0;

    // need to do this again here cuz WINNT doesn't call buildddhalinfo16
    pDriverData->physicalColorMask = (dwPixelDepth == 8) ?
                                         0x000000ff :
                                         (dwPixelDepth == 16) ?
                                             0x0000ffff :
                                             0x00ffffff;

    // Initialize primary surface pointer
    pDriverData->CurrentVisibleSurfaceAddress = GET_PRIMARY_ADDR();

    // No DMA push blit synchronizations currently in progress
    pDriverData->syncDmaRecord.bSyncFlag = FALSE;

    // flush now because if we do a mode change without doing anything, then when
    // the push buffer gets re-enabled, we may attempt to flush crap
    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_HEAVY_POLLING);
#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        getDC()->nvPusherDAC.flush (TRUE, CPushBuffer::FLUSH_HEAVY_POLLING);
    }
#endif
#endif

    // Initialize the flip history
    //    Cannot be all zeros as that is a valid surface address on NT
    {
        memset(&pDriverData->flipHistory,0xff,sizeof(pDriverData->flipHistory));
        pDriverData->flipHistory.dwIndex = 0;
    }


    getDC()->dwEnableStatus = CDriverContext::DC_ENABLESTATUS_ENABLED;

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

void nvDisableD3D
(
    void
)
{
    dbgTracePush ("nvDisableD3D");

    // Destroy the objects.

    //which of these is preferred? NV20 gets GDIRECT
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_RENDER_SOLID_RECTANGLE);
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_RENDER_SOLID_RECTANGLE_2);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_004A_GDIRECT) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_GDI_RECTANGLE_TEXT);
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_GDI_RECTANGLE_TEXT_2);
    }
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_SCALED_IMAGE_FROM_MEMORY);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_CONTEXT_SURFACE_SWIZZLED);

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_KELVIN_PRIMITIVE);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_CELSIUS_PRIMITIVE);
    }
    else
#endif
    {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_DX5_TEXTURED_TRIANGLE);
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_CONTEXT_SURFACES_ARGB_ZS);
    }

    dbgTracePop();
}

//---------------------------------------------------------------------------

// nvDisable32()
// destroy objects, close channels, and free the push buffer

BOOL __stdcall nvDisable32()
{
    DWORD dwPixelDepth, dwHead;

    dbgTracePush ("nvDisable32");

    if (getDC()->dwEnableStatus == CDriverContext::DC_ENABLESTATUS_DISABLED) {
        // we're already disabled
        dbgTracePop();
        return (TRUE);
    }

    // flush the push buffers before we start destroying stuff
    if (getDC()->nvPusher.isValid()) {
        // make sure we sync all other channels before shutdown
        getDC()->nvPusher.waitForOtherChannels();
        getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_HEAVY_POLLING);
    }

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        if (getDC()->nvPusherDAC.isValid()) {
            // make sure we sync all other channels before shutdown
            getDC()->nvPusherDAC.waitForOtherChannels();
            getDC()->nvPusherDAC.flush (TRUE, CPushBuffer::FLUSH_HEAVY_POLLING);
        }
    }
#endif
#endif

    if (global.b16BitCode) {
        // we need to disable things but cannot. we'll do it at the next opportunity
        getDC()->dwEnableStatus = CDriverContext::DC_ENABLESTATUS_PENDINGDISABLE;
        // in the meantime, we're not allowed to use the push buffer
        getDC()->nvPusher.invalidate();
        dbgTracePop();
        return (FALSE);
    }

    if (pDriverData->vpp.dwOverlaySurfaces) {
        // application isn't really done with overlays, something has happened like a mode switch or AGP heap moved
        pDriverData->vpp.dwOverlayFSOvlHeadSaved = pDriverData->vpp.dwOverlayFSOvlHead;
        VppDestroyFSMirror(&pDriverData->vpp);
        VppDestroyOverlay(&pDriverData->vpp);
    } else {
        pDriverData->vpp.dwOverlayFSOvlHeadSaved = 0xFFFFFFFF;
    }

    VppDisable(&pDriverData->vpp);  // Free objects...

    // get the cached value since bi.biBitCount may be different from what it was at enable time
    dwPixelDepth = getDC()->dwEnablePixelDepth;

    // destroy the default VB
    getDC()->defaultVB.destroy();

    getDC()->pRefCount->destroy();
    getDC()->pBlitTracker->destroy();

    nvTextureDefaultFree();

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        getDC()->nvFlipper.destroy();
        getDC()->nvSemaphoreManager.destroy();
    }
#endif
#endif

    // Destroy the D3D objects
    nvDisableD3D();

    for(dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_LUT_CURSOR_DAC + dwHead);
    }

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        for(dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
            NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DAC, NV_DD_VIDEO_LUT_CURSOR_DAC_2 + dwHead);
        }
    }
#endif
#endif

    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_CONTEXT_ROP);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_CONTEXT_PATTERN);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_IMAGE_BLACK_RECTANGLE);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_CONTEXT_COLOR_KEY);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_ROP_GDI_RECT_AND_TEXT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_IMAGE_FROM_CPU);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_INDEXED_IMAGE_FROM_CPU);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_GENERIC_STRETCHED_IMAGE);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SCALED_IMAGE_IID);

    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_IMAGE_BLIT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SRCCOPY_IMAGE_BLIT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SURFACES_2D);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_GENERIC_MTMF_1);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_GENERIC_MTMF_2);

    // free the push buffer
    getDC()->nvPusher.free();

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        getDC()->nvPusherDAC.free();
    }
#endif
#endif

    nvDestroyNotifiers();

    // destroy the texture heap (AGP or PCI) and associated contexts
    nvDisableHeaps();

    // Release all outstanding AGP heap allocations
    //   The DX AGP heap allocations are only valid on 1 head in multiheaded systems.
    //   If we do not free all allocations now, we'll attempt to in nvEnable and that
    //   may be while DX is being enabled on the head WITHOUT the AGP heap -- causes crash.
    nvAGPResetHeap();

    getDC()->dwEnableStatus = CDriverContext::DC_ENABLESTATUS_DISABLED;

    dbgTracePop();
    return (TRUE);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvdbg_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvDbg_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\src\nvDbg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvContext.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvContext.cpp                                                     *
*   Hardware specific context management routines.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/97 - reorganized.                 *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"


#if (NVARCH >= 0x04)

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CDriverContext  ********************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CDriverContext::create
 *
 * init NVDD32 local context
 */
void CDriverContext::create
(
    void
)
{
    dbgTracePush ("CDriverContext::create");

    dwGlobalStructSize = sizeof(*this);

    // instantiate some objects
    pRefCount    = new CReferenceCount;
    pBlitTracker = new CReferenceCountMap<5>;

    dbgTracePop();
}

/*****************************************************************************
 * CDriverContext::destroy
 *
 * kill NVDD32 local context
 */
void CDriverContext::destroy (void)
{
    dbgTracePush ("CDriverContext::destroy");

    if (pRefCount)    delete pRefCount;
    if (pBlitTracker) delete pBlitTracker;

    dbgTracePop();
}

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  exports  ***************************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

// set up the default viewport based on the current render target
// (if there is one). note that the caller is responsible for setting
// celsius drity bits as appropriate

BOOL nvSetSurfaceViewport
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvSetSurfaceViewport");

    pContext->surfaceViewport.clipHorizontal.wX = 0;
    pContext->surfaceViewport.clipVertical.wY   = 0;

    CSimpleSurface *pRenderTarget;

#if (NVARCH >= 0x020)
    pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
#else
    pRenderTarget = pContext->pRenderTarget;
#endif // NVARCH == 0x020

    if (pRenderTarget) {
        pContext->surfaceViewport.clipHorizontal.wWidth = (WORD)pRenderTarget->getWidth();
        pContext->surfaceViewport.clipVertical.wHeight  = (WORD)pRenderTarget->getHeight();
    }

    else {
        pContext->surfaceViewport.clipHorizontal.wWidth = 0;
        pContext->surfaceViewport.clipVertical.wHeight  = 0;
    }

    // initialize near/far values so when applications request a W buffer but
    // don't set a W range we don't kill off the Ws in the transform setup
    pContext->surfaceViewport.dvWNear   = 0.0f; // these default values from MS D3D device interface source
    pContext->surfaceViewport.dvWFar    = 1.0f; // which takes a projection matrix and computes near/far
    pContext->surfaceViewport.dvInvWFar = 1.0f; // values and if there is some error it punts and set to 0.0/1.0
                                                // thus our initial values here

    // now calulate the dvRWFar value
    nvCalcRWFar (pContext);

    dbgTracePop();
    return (TRUE);
}

//--------------------------------------------------------------------------

// used on DX6 to refresh the surface info after a flip has swapped the fpVidMem values

void nvRefreshSurfaceInfo (PNVD3DCONTEXT pContext)
{
    dbgTracePush ("nvRefreshSurfaceInfo");

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

#ifdef DEBUG
    if (dbgFrontRender) {
        pContext->pRenderTarget = &(dbgFrontRenderSurface);
    }
    else
#endif
    {
        LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl = (LPDDRAWI_DDRAWSURFACE_LCL)pContext->pRenderTarget->getWrapper()->getHandle();
        pContext->pRenderTarget->setAddress(pDDSLcl->lpGbl->fpVidMem);
    }

    if (pContext->pZetaBuffer) {
        LPDDRAWI_DDRAWSURFACE_LCL pDDSLclZ =  (LPDDRAWI_DDRAWSURFACE_LCL)pContext->pZetaBuffer->getWrapper()->getHandle();
        pContext->pZetaBuffer->setAddress(pDDSLclZ->lpGbl->fpVidMem);
    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SURFACE;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_SURFACE;
#endif
    pDriverData->bDirtyRenderTarget = TRUE;

    dbgTracePop();
}

//-------------------------------------------------------------------------

BOOL nvSetupContext
(
    PNVD3DCONTEXT pContext
)
{
    DWORD i;

    dbgTracePush ("nvSetupContext");

    // set the viewport based on the current render target
    nvSetSurfaceViewport (pContext);

    // Set the default rendering state for the context.
    // The defaults come from the final DX5 D3D DDK Documentation.
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESS]     = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_WRAPU]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_WRAPV]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]           = D3DFILL_SOLID;
    pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE]          = D3DSHADE_GOURAUD;
    pContext->dwRenderState[D3DRENDERSTATE_LINEPATTERN]        = 0;
    pContext->dwRenderState[D3DRENDERSTATE_MONOENABLE]         = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ROP2]               = R2_COPYPEN;
    pContext->dwRenderState[D3DRENDERSTATE_PLANEMASK]          = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]    = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_LASTPIXEL]          = TRUE;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAG]         = D3DFILTER_NEAREST;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMIN]         = D3DFILTER_NEAREST;
    pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]           = D3DBLEND_ONE;
    pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]          = D3DBLEND_ZERO;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND]    = D3DTBLEND_MODULATE;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]           = D3DCULL_CCW;
    pContext->dwRenderState[D3DRENDERSTATE_ZFUNC]              = D3DCMP_LESSEQUAL;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]           = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]          = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]       = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]   = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE]           = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SUBPIXEL]           = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SUBPIXELX]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_STIPPLEDALPHA]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]           = 0;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]       = D3DFOG_NONE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLESTART]      = 1;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEEND]        = 100;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]    = 1;
    pContext->dwRenderState[D3DRENDERSTATE_STIPPLEENABLE]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_BORDERCOLOR]        = 0;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU]    = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV]    = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]              = 0;
    pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ANISOTROPY]         = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FLUSHBATCH]         = FALSE;

    // Enable the Z-Buffer if there is one attached.
    if (pContext->pZetaBuffer) {
        pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      = TRUE;
        pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] = TRUE;
    }
    else {
        pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      = FALSE;
        pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] = FALSE;
    }

    pContext->dwRenderState[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT] = TRUE;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]                = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]               = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]                = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]                = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]                 = 0;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]                = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]           = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]              = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP0]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP1]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP2]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP3]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP4]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP5]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP6]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP7]                      = 0;

    // initialize transform and lighting state
    // BUGBUG i don't really know what the defaults are. set to 0 for now
    pContext->dwRenderState[D3DRENDERSTATE_CLIPPING]                   = 0;
    pContext->dwRenderState[D3DRENDERSTATE_LIGHTING]                   = 0;
    pContext->dwRenderState[D3DRENDERSTATE_EXTENTS]                    = 0;
    pContext->dwRenderState[D3DRENDERSTATE_AMBIENT]                    = 0;
    pContext->dwRenderState[D3DRENDERSTATE_FOGVERTEXMODE]              = D3DFOG_NONE;
    pContext->dwRenderState[D3DRENDERSTATE_COLORVERTEX]                = 0;
    pContext->dwRenderState[D3DRENDERSTATE_LOCALVIEWER]                = 0;
    pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS]           = 0;
    pContext->dwRenderState[D3DRENDERSTATE_COLORKEYBLENDENABLE]        = 0;
    pContext->dwRenderState[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_SPECULARMATERIALSOURCE]     = 0;
    pContext->dwRenderState[D3DRENDERSTATE_AMBIENTMATERIALSOURCE]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE]     = 0;

    // DX8 additions
    pContext->dwRenderState[D3DRS_POINTSIZE_MIN]                       = FP_ONE_BITS;
    pContext->dwRenderState[D3DRS_POINTSIZE_MAX]                       = FP_ONE_BITS;
    pContext->dwRenderState[D3DRS_POINTSIZE]                           = FP_ONE_BITS;
    pContext->dwRenderState[D3DRS_POINTSCALE_A]                        = FP_ONE_BITS;
    pContext->dwRenderState[D3DRS_POINTSCALE_B]                        = 0;
    pContext->dwRenderState[D3DRS_POINTSCALE_C]                        = 0;
    pContext->dwRenderState[D3DRS_COLORWRITEENABLE]                    = (D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_RED |
                                                                          D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE);

    // Initialize the texture stages.  Stage 1-7 are all defaulted to disabled.
    // Stage 0 is defaulted for no texturing.
    DWORD dwLODBias0 = nvTranslateLODBias (0);

    for (i = 0; i < 8; i++) {
        pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP]      = 0;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSU]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSV]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_MAGFILTER]       = D3DTFG_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MINFILTER]       = D3DTFN_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MIPFILTER]       = D3DTFP_POINT;
        pContext->tssState[i].dwValue[D3DTSS_COLOROP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG2]       = D3DTA_CURRENT;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAOP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG2]       = D3DTA_CURRENT;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT00]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT01]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT10]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT11]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_TEXCOORDINDEX]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BORDERCOLOR]     = 0x00000000;
        pContext->tssState[i].dwValue[D3DTSS_MIPMAPLODBIAS]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXMIPLEVEL]     = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXANISOTROPY]   = 1;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLSCALE]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLOFFSET]  = 0;
        pContext->tssState[i].dwHandle                        = 0;
        pContext->tssState[i].dwLODBias                       = dwLODBias0;
    }

    // a couple things that are different for stage 0
    pContext->tssState[0].dwValue[D3DTSS_COLOROP] = D3DTOP_MODULATE;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG1;

    pContext->dwStageCount       = 1;
    pContext->bUseDX6Class       = FALSE;
    pContext->bUseTBlendSettings = FALSE;

    pContext->bStencilEnabled = FALSE;
    pContext->dwStencilFill   = 0;

    for (i=0;i<NV_CAPS_MAX_STREAMS;i++) {
        pContext->ppDX8Streams[i]=NULL;
    }
    pContext->dwStreamDMACount = 0;

    // Force an initial state load.
    pContext->bStateChange = TRUE;
    NV_FORCE_TRI_SETUP (pContext);

    dbgTracePop();
    return(TRUE);
}

//-------------------------------------------------------------------------

void nvInitTLData (PNVD3DCONTEXT pContext)
{
    pContext->pLightArray = NULL;
    pContext->dwLightArraySize = 0;

    // initialize the texture transform matrices and flags
    for (DWORD i=0; i<8; i++) {
        nvMemCopy(&pContext->tssState[i].mTexTransformMatrix,
                  &matrixIdent, sizeof(D3DMATRIX));
        pContext->tssState[i].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS] = D3DTTFF_DISABLE;
    }

    // clear all clip planes to 0. MS says this is the default.
    memset (pContext->ppClipPlane, 0, D3DMAXUSERCLIPPLANES * 4 * sizeof(D3DVALUE));
}

//-------------------------------------------------------------------------

#if (NVARCH >= 0x010)

void nvInitCommonData (PNVD3DCONTEXT pContext)
{
    // init common hardware state
    pContext->hwState.dwDirtyFlags                          = CELSIUS_DIRTY_REALLY_FILTHY | KELVIN_DIRTY_REALLY_FILTHY;
    pContext->hwState.dwStateFlags                          = 0;
    pContext->hwState.dwNumActiveCombinerStages             = 0;
    pContext->hwState.dwNextAvailableTextureUnit            = 0;
    pContext->hwState.dwFogSource                           = 0;
    pContext->hwState.dvZScale                              = 1.0f;
    pContext->hwState.dvInvZScale                           = 1.0f;

    pContext->hwState.alphacull_mode                        = 0;

    pContext->hwState.SuperTri.SuperTriInit(pContext);
    pContext->hwState.SuperTri.setStrategy();
}

//-------------------------------------------------------------------------

void nvInitCelsiusData (PNVD3DCONTEXT pContext)
{
    // init common hardware state
    nvInitCommonData (pContext);

    // initialize celsius state
    for (DWORD i = 0; i < CELSIUS_NUM_TEXTURES; i++) {
        pContext->hwState.dwTexUnitToTexStageMapping[i]     = CELSIUS_UNUSED;
        pContext->hwState.dwTextureUnitStatus       [i]     = CELSIUS_TEXUNITSTATUS_IDLE;
        pContext->hwState.pTextureInUse             [i]     = NULL;
    }

    for (i = 0; i < CELSIUS_NUM_COMBINERS; i++) {
        pContext->hwState.dwColorICW[i] = 0;
        pContext->hwState.dwColorOCW[i] = 0;
        pContext->hwState.dwAlphaICW[i] = 0;
        pContext->hwState.dwAlphaOCW[i] = 0;
        pContext->hwState.specfog_cw[i] = 0;
    }

    pContext->hwState.celsius.dwZEnable                     = D3DZB_FALSE;
    pContext->hwState.celsius.pfnVertexCopy                 = NULL;

    // set up some commonly used programs that allow us to pack 2 D3D stages into one combiner stage

    // list of two-stage modes that cannot be compacted:
    // (so you don't have to bother thinking about them again... :)  )
    //      TSS Mask 0      TSS Mask 1      interpretation
    //      ----------      ----------      --------------
    //      0x90020820      0xb0220820      tex*dif,dif                  | a_dif*cur+(1-a_dif)*tex,cur
    //      0x90400400      0x90410400      tex*dif,disable              | tex*cur,disable
    //      0x90400400      0x90411040      tex*dif,disable              | tex*cur,tex*dif
    //      0x90400400      0x94410400
    //      0x90400400      0xb4410400
    //      0x90400840      0x90410400      tex*dif,tex                  | tex*cur,disable
    //      0x90400840      0xb4410c01
    //      0x90401040      0x90411040      tex*dif,tex*dif              | tex*cur,tex*dif
    //      0x90401040      0x94411c41      tex*dif,tex*dif              | 2*tex*cur,tex+cur
    //      0x90401043      0xc0411c41      tex*dif,tex*fac              | a_cur*tex+(1-a_cur)*cur,tex+cur
    //      0x90400c00      0x10410840      tex*dif,dif                  | [tex]*cur,tex
    //      0x90410400      0x90411040      tex*cur,disable              | tex*cur,tex*dif
    //      0x90410840      0x90410400      tex*cur,tex                  | tex*cur,disable
    //      0x90620840      0x90220820      fac*tex,tex                  | cur*tex,cur
    //      0xb8403840      0x9c200c00      a_fac*tex+(1-a_fac)*dif,same | dif+cur,diffuse
    //      0xb8403840      0x9c201c20      a_fac*tex+(1-a_fac)*dif,same | dif+cur,dif+cur
    //      0xe0440840      0x90410400      tex.spec,tex                 | tex*cur,disable

    // list of two-stage modes that COULD be compacted, but are so idiotic
    // that it's not worth wasting the space to store them
    //      TSS Mask 0      TSS Mask 1      interpretation
    //      ----------      ----------      --------------
    //      0x10401040      0x10411041      [tex]*dif,[tex]*dif          | [tex]*cur,[tex]*cur
    //      0x10401040      0x34410400      [tex]*dif,[tex]*dif          | [a_tex]*[tex]+(1-[a_tex])*cur,disable

    // note: in the above, [tex] denotes a reference to a texture that doesn't exist

    // some common 15-bit masks for reference (16th bit is X):
    // 0x0400 = disabled
    // 0x0820 = select current
    // 0x0840 = select texture
    // 0x0c00 = select diffuse
    // 0x0c01 = select current
    // 0x1002 = modulate diffuse / texture
    // 0x1022 = modulate current / texture
    // 0x1040 = modulate texture / diffuse
    // 0x1041 = modulate texture / current
    // 0x1043 = modulate texture / factor
    // 0x1062 = modulate factor / texture
    // 0x1440 = modulate2x texture / diffuse
    // 0x1441 = modulate2x texture / current
    // 0x1c20 = add current / diffuse
    // 0x1c41 = add texture / current
    // 0x2141 = addsigned texture(complement) / current
    // 0x3022 = blend_diffuse_alpha current / texture = a_dif*cur + (1-a_dif)*tex
    // 0x3441 = blend_texture_alpha texture / current
    // 0x3840 = blend_factor_alpha texture / diffuse

    // for relevant D3D definitions, link to D3DTEXTUREOP

    PCELSIUSCOMBINERPROGRAM pProgram;

    // color:  tex0 * tex1
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400400;
    pProgram->dwTSSMask1 = 0x90410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08090000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  2 * tex0 * tex1
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400400;
    pProgram->dwTSSMask1 = 0x94410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08090000;
    pProgram->dwColorOCW[0] = 0x00010c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex0 + tex1
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400400;
    pProgram->dwTSSMask1 = 0x9c410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08200920;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  alpha_tex1 * tex1 + (1-alpha_tex1) * tex0
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400400;
    pProgram->dwTSSMask1 = 0xb4410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x19093908;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex0 * tex1
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400840;
    pProgram->dwTSSMask1 = 0x90410c00;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08090000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex0 * tex1
    // alpha:  tex0
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400840;
    pProgram->dwTSSMask1 = 0x90410c01;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08090000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x18200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex1
    // alpha:  dif*tex0
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88401002;
    pProgram->dwTSSMask1 = 0x88400820;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x09200000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14180000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex1 * diffuse
    // alpha:  tex0
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x90400840;
    pProgram->dwTSSMask1 = 0x90400400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x09040000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x18200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  (tex0 * diffuse) + tex1
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x90400400;
    pProgram->dwTSSMask1 = 0x9c410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08040920;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  (tex0 * diffuse) + tex1
    // alpha:  tex0
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x90400840;
    pProgram->dwTSSMask1 = 0x9c410c01;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08040920;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x18200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex0 * diffuse
    // alpha:  tex0
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x90410840;
    pProgram->dwTSSMask1 = 0x10410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = CELSIUS_UNUSED;
    pProgram->dwColorICW[0] = 0x08040000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x18200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  2 * tex0 * diffuse
    // alpha:  tex0 + (1-tex1) - 0.5
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x90410840;
    pProgram->dwTSSMask1 = 0x10410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = CELSIUS_UNUSED;
    pProgram->dwColorICW[0] = 0x08040000;
    pProgram->dwColorOCW[0] = 0x00010c00;
    pProgram->dwAlphaICW[0] = 0x20392018;
    pProgram->dwAlphaOCW[0] = 0x00008c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);


}

#endif  // NVARCH >= 0x010

//-------------------------------------------------------------------------

#if (NVARCH >= 0x020)

void nvInitKelvinData (PNVD3DCONTEXT pContext)
{
    // init common hardware state
    nvInitCommonData (pContext);

    for (DWORD i = 0; i < KELVIN_NUM_TEXTURES; i++) {
        pContext->hwState.dwTexUnitToTexStageMapping[i] = KELVIN_UNUSED;
        pContext->hwState.dwTextureUnitStatus       [i] = KELVIN_TEXUNITSTATUS_IDLE;
        pContext->hwState.pTextureInUse             [i] = NULL;
    }

    for (i = 0; i < KELVIN_NUM_COMBINERS; i++) {
        pContext->hwState.dwColorICW[i] = 0;
        pContext->hwState.dwColorOCW[i] = 0;
        pContext->hwState.dwAlphaICW[i] = 0;
        pContext->hwState.dwAlphaOCW[i] = 0;
    }

    pContext->hwState.specfog_cw[0] = 0;
    pContext->hwState.specfog_cw[1] = 0;
}

#endif

//-------------------------------------------------------------------------

// recover D3D after fullscreen DOS box, power saving mode, etc.

void nvD3DRecover (void)
{
    PNVD3DCONTEXT pContext;

    dbgTracePush ("nvD3DRecover");

#if (NVARCH >= 0x010)
    pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext) {
        // We need to recreate our AA buffers
        nvCelsiusAADestroy(pContext);
        pContext = pContext->pContextNext;
    }
#endif  // NVARCH >= 0x010

    // Force reset of D3D rendering target and z-buffer.
    pDriverData->bDirtyRenderTarget = TRUE;
    pDriverData->dwCurrentContextHandle  = 0;

    // force reprogram of celsius/kelvin objects
    getDC()->dwLastHWContext = NULL;

    // clear recovery flag
    pDriverData->dwFullScreenDOSStatus &= ~FSDOSSTATUS_RECOVERYNEEDED_D3D;

    dbgTracePop();
}

//-------------------------------------------------------------------------

// recover ddraw after fullscreen DOS box, power saving mode, etc.

void nvDDrawRecover (void)
{
BOOL isOverlayActive;

    dbgTracePush ("nvDDrawRecover");

    NvNotification *pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;
    pPioFlipOverlayNotifier[1].status = 0;
    pPioFlipOverlayNotifier[2].status = 0;

    LPDDHALINFO pHalInfo = GET_HALINFO();
    pHalInfo->ddCaps.dwCurrVisibleOverlays = 0;

    pDriverData->vpp.dwOverlayOwner = 0;
    pDriverData->vpp.overlayRelaxOwnerCheck = 1;

    isOverlayActive = (pDriverData->vpp.dwOverlayFSOvlHead != 0xFFFFFFFF);
    if (isOverlayActive) {
        VppDestroyFSMirror(&(pDriverData->vpp));
        VppDestroyOverlay(&pDriverData->vpp);
    }

    // clear recovery flag
    pDriverData->dwFullScreenDOSStatus &= ~FSDOSSTATUS_RECOVERYNEEDED_DDRAW;

    if (isOverlayActive) {
        VppCreateOverlay(&pDriverData->vpp);
        VppCreateFSMirror(&pDriverData->vpp, pDriverData->vpp.dwOverlayFSSrcWidth, pDriverData->vpp.dwOverlayFSSrcHeight);
    }

    dbgTracePop();
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvDP2ops.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvDP2ops.cpp                                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    bertrem     02June99    created                 *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//#define INSTRUMENT       // display information about DP2 surfaces
#ifdef WINNT
#define VALIDATE_PARAMS  // validate vertex data to make sure it's in range
#endif

#ifdef  NV_NULL_DRIVER_DYNAMIC
DWORD NullDriverBits = 0;
inline BOOL NullBitSet(DWORD token)
{
    return (NullDriverBits & (1 << token));
}
#endif //NV_NULL_DRIVER_DYNAMIC

nvDP2FunctionTable nvDP2SetFuncs =
{
    NULL,                               //   0  invalid
    nvDP2Points,                        //   1  D3DDP2OP_POINTS
    nvDP2IndexedLineList,               //   2  D3DDP2OP_INDEXEDLINELIST
    nvDP2IndexedTriangleList,           //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    NULL,                               //   4  invalid
    NULL,                               //   5  invalid
    NULL,                               //   6  invalid
    NULL,                               //   7  invalid
    nvDP2SetRenderState,                //   8  D3DDP2OP_RENDERSTATE
    NULL,                               //   9  NULL
    NULL,                               //  10  invalid
    nvDP2StreamEnd,                     //  11  legacy end-of-buffer marker
    NULL,                               //  12  invalid
    NULL,                               //  13  invalid
    NULL,                               //  14  invalid
    nvDP2LineList,                      //  15  D3DDP2OP_LINELIST
    nvDP2LineStrip,                     //  16  D3DDP2OP_LINESTRIP
    nvDP2IndexedLineStrip,              //  17  D3DDP2OP_INDEXEDLINESTRIP
    nvDP2TriangleList,                  //  18  D3DDP2OP_TRIANGLELIST
    nvDP2TriangleStrip,                 //  19  D3DDP2OP_TRIANGLESTRIP
    nvDP2IndexedTriangleStrip,          //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    nvDP2TriangleFan,                   //  21  D3DDP2OP_TRIANGLEFAN
    nvDP2IndexedTriangleFan,            //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    nvDP2TriangleFanImm,                //  23  D3DDP2OP_TRIANGLEFAN_IMM
    nvDP2LineListImm,                   //  24  D3DDP2OP_LINELIST_IMM
    nvDP2SetTextureStageState,          //  25  D3DDP2OP_TEXTURESTAGESTATE
    nvDP2IndexedTriangleList2,          //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    nvDP2IndexedLineList2,              //  27  D3DDP2OP_INDEXEDLINELIST2
    nvDP2SetViewport,                   //  28  D3DDP2OP_VIEWPORTINFO
    nvDP2SetWRange,                     //  29  D3DDP2OP_WINFO
    nvDP2SetPalette,                    //  30  D3DDP2OP_SETPALETTE
    nvDP2UpdatePalette,                 //  31  D3DDP2OP_UPDATEPALETTE
    nvDP2SetZRange,                     //  32  D3DDP2OP_ZRANGE
    nvDP2SetMaterial,                   //  33  D3DDP2OP_SETMATERIAL
    nvDP2SetLight,                      //  34  D3DDP2OP_SETLIGHT
    nvDP2CreateLight,                   //  35  D3DDP2OP_CREATELIGHT
    nvDP2SetTransform,                  //  36  D3DDP2OP_SETTRANSFORM
    nvDP2Extension,                     //  37  D3DDP2OP_EXT
    nvDP2TexBlt,                        //  38  D3DDP2OP_TEXBLT
    nvDP2StateSet,                      //  39  D3DDP2OP_STATESET
    nvDP2SetPriority,                   //  40  D3DDP2OP_SETPRIORITY
    nvDP2SetRenderTarget,               //  41  D3DDP2OP_SETRENDERTARGET
    nvDP2Clear,                         //  42  D3DDP2OP_CLEAR
    nvDP2SetTexLOD,                     //  43  D3DDP2OP_SETTEXLOD
    nvDP2SetClipPlane,                  //  44  D3DDP2OP_SETCLIPPLANE
    nvDP2CreateVertexShader,            //  45  D3DDP2OP_CREATEVERTEXSHADER
    nvDP2DeleteVertexShader,            //  46  D3DDP2OP_DELETEVERTEXSHADER
    nvDP2SetVertexShader,               //  47  D3DDP2OP_SETVERTEXSHADER
    nvDP2SetVertexShaderConst,          //  48  D3DDP2OP_SETVERTEXSHADERCONST
    nvDP2SetStreamSource,               //  49  D3DDP2OP_SETSTREAMSOURCE
    nvDP2SetStreamSourceUM,             //  50  D3DNTDP2OP_SETSTREAMSOURCEUM
    nvDP2SetIndices,                    //  51  D3DDP2OP_SETINDICES
    nvDP2DrawPrimitive,                 //  52  D3DDP2OP_DRAWPRIMITIVE
    nvDP2DrawIndexedPrimitive,          //  53  D3DDP2OP_DRAWINDEXEDPRIMITIVE
    nvDP2CreatePixelShader,             //  54  D3DDP2OP_CREATEPIXELSHADER
    nvDP2DeletePixelShader,             //  55  D3DDP2OP_DELETEPIXELSHADER
    nvDP2SetPixelShader,                //  56  D3DDP2OP_SETPIXELSHADER
    nvDP2SetPixelShaderConst,           //  57  D3DNTDP2OP_SETPIXELSHADERCONST
    nvDP2ClippedTriangleFan,            //  58  D3DNTDP2OP_CLIPPEDTRIANGLEFAN
    nvDP2DrawPrimitive2,                //  59  D3DNTDP2OP_DRAWPRIMITIVE2
    nvDP2DrawIndexedPrimitive2,         //  60  D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2
    nvDP2DrawRectSurface,               //  61  D3DNTDP2OP_DRAWRECTSURFACE
    nvDP2DrawTriSurface,                //  62  D3DNTDP2OP_DRAWTRISURFACE
    nvDP2VolumeBlt,                     //  63  D3DDP2OP_VOLUMEBLT
    nvDP2BufferBlt,                     //  64  D3DDP2OP_BUFFERBLT
    nvDP2MultiplyTransform
};

nvDP2FunctionTable nvDP2RecordFuncs =
{
    NULL,                               //   0  invalid
    NULL,                               //   1  D3DDP2OP_POINTS
    NULL,                               //   2  D3DDP2OP_INDEXEDLINELIST
    NULL,                               //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    NULL,                               //   4  invalid
    NULL,                               //   5  invalid
    NULL,                               //   6  invalid
    NULL,                               //   7  invalid
    nvDP2RecordSetRenderState,          //   8  D3DDP2OP_RENDERSTATE
    NULL,                               //   9  invalid
    NULL,                               //  10  invalid
    NULL,                               //  11  invalid
    NULL,                               //  12  invalid
    NULL,                               //  13  invalid
    NULL,                               //  14  invalid
    NULL,                               //  15  D3DDP2OP_LINELIST
    NULL,                               //  16  D3DDP2OP_LINESTRIP
    NULL,                               //  17  D3DDP2OP_INDEXEDLINESTRIP
    NULL,                               //  18  D3DDP2OP_TRIANGLELIST
    NULL,                               //  19  D3DDP2OP_TRIANGLESTRIP
    NULL,                               //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    NULL,                               //  21  D3DDP2OP_TRIANGLEFAN
    NULL,                               //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    NULL,                               //  23  D3DDP2OP_TRIANGLEFAN_IMM
    NULL,                               //  24  D3DDP2OP_LINELIST_IMM
    nvDP2RecordSetTextureStageState,    //  25  D3DDP2OP_TEXTURESTAGESTATE
    NULL,                               //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    NULL,                               //  27  D3DDP2OP_INDEXEDLINELIST2
    nvDP2RecordSetViewport,             //  28  D3DDP2OP_VIEWPORTINFO
    nvDP2RecordSetWRange,               //  29  D3DDP2OP_WINFO
    NULL,                               //  30  D3DDP2OP_SETPALETTE
    NULL,                               //  31  D3DDP2OP_UPDATEPALETTE
    nvDP2RecordSetZRange,               //  32  D3DDP2OP_ZRANGE
    nvDP2RecordSetMaterial,             //  33  D3DDP2OP_SETMATERIAL
    nvDP2RecordSetLight,                //  34  D3DDP2OP_SETLIGHT
    NULL,                               //  35  D3DDP2OP_CREATELIGHT
    nvDP2RecordSetTransform,            //  36  D3DDP2OP_SETTRANSFORM
    nvDP2RecordExtension,               //  37  D3DDP2OP_EXT
    NULL,                               //  38  D3DDP2OP_TEXBLT
    nvDP2StateSet,                      //  39  D3DDP2OP_STATESET
    NULL,                               //  40  D3DDP2OP_SETPRIORITY
    NULL,                               //  41  D3DDP2OP_SETRENDERTARGET
    NULL,                               //  42  D3DDP2OP_CLEAR
    NULL,                               //  43  D3DDP2OP_SETTEXLOD
    nvDP2RecordSetClipPlane,            //  44  D3DDP2OP_SETCLIPPLANE
    NULL,                               //  45  D3DDP2OP_CREATEVERTEXSHADER
    NULL,                               //  46  D3DDP2OP_DELETEVERTEXSHADER
    nvDP2RecordSetVertexShader,         //  47  D3DDP2OP_SETVERTEXSHADER
    nvDP2RecordSetVertexShaderConst,    //  48  D3DDP2OP_SETVERTEXSHADERCONST
    nvDP2RecordSetStreamSource,         //  49  D3DDP2OP_SETSTREAMSOURCE
    nvDP2RecordSetStreamSourceUM,       //  50  D3DNTDP2OP_SETSTREAMSOURCEUM
    nvDP2RecordSetIndices,              //  51  D3DDP2OP_SETINDICES
    NULL,                               //  52  D3DDP2OP_DRAWPRIMITIVE
    NULL,                               //  53  D3DDP2OP_DRAWINDEXEDPRIMITIVE
    NULL,                               //  54  D3DDP2OP_CREATEPIXELSHADER
    NULL,                               //  55  D3DDP2OP_DELETEPIXELSHADER
    nvDP2RecordSetPixelShader,          //  56  D3DDP2OP_SETPIXELSHADER
    nvDP2RecordSetPixelShaderConst,     //  57  D3DNTDP2OP_SETPIXELSHADERCONST
    NULL,                               //  58  D3DNTDP2OP_CLIPPEDTRIANGLEFAN
    NULL,                               //  59  D3DNTDP2OP_DRAWPRIMITIVE2
    NULL,                               //  60  D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2
    NULL,                               //  61  D3DNTDP2OP_DRAWRECTSURFACE
    NULL,                               //  62  D3DNTDP2OP_DRAWTRISURFACE
    NULL,                               //  63  D3DDP2OP_VOLUMEBLT
    NULL,                               //  64  D3DDP2OP_BUFFERBLT
    nvDP2RecordMultiplyTransform        //  65  D3DDP2OP_BUFFERBLT
};

nvDP2FunctionTable nvDP2CaptureFuncs =
{
    NULL,                               //   0  invalid
    NULL,                               //   1  D3DDP2OP_POINTS
    NULL,                               //   2  D3DDP2OP_INDEXEDLINELIST
    NULL,                               //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    NULL,                               //   4  invalid
    NULL,                               //   5  invalid
    NULL,                               //   6  invalid
    NULL,                               //   7  invalid
    nvDP2CaptureSetRenderState,         //   8  D3DDP2OP_RENDERSTATE
    NULL,                               //   9  invalid
    NULL,                               //  10  invalid
    NULL,                               //  11  invalid
    NULL,                               //  12  invalid
    NULL,                               //  13  invalid
    NULL,                               //  14  invalid
    NULL,                               //  15  D3DDP2OP_LINELIST
    NULL,                               //  16  D3DDP2OP_LINESTRIP
    NULL,                               //  17  D3DDP2OP_INDEXEDLINESTRIP
    NULL,                               //  18  D3DDP2OP_TRIANGLELIST
    NULL,                               //  19  D3DDP2OP_TRIANGLESTRIP
    NULL,                               //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    NULL,                               //  21  D3DDP2OP_TRIANGLEFAN
    NULL,                               //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    NULL,                               //  23  D3DDP2OP_TRIANGLEFAN_IMM
    NULL,                               //  24  D3DDP2OP_LINELIST_IMM
    nvDP2CaptureSetTextureStageState,   //  25  D3DDP2OP_TEXTURESTAGESTATE
    NULL,                               //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    NULL,                               //  27  D3DDP2OP_INDEXEDLINELIST2
    nvDP2CaptureSetViewport,            //  28  D3DDP2OP_VIEWPORTINFO
    nvDP2CaptureSetWRange,              //  29  D3DDP2OP_WINFO
    NULL,                               //  30  D3DDP2OP_SETPALETTE
    NULL,                               //  31  D3DDP2OP_UPDATEPALETTE
    nvDP2CaptureSetZRange,              //  32  D3DDP2OP_ZRANGE
    nvDP2CaptureSetMaterial,            //  33  D3DDP2OP_SETMATERIAL
    nvDP2CaptureSetLight,               //  34  D3DDP2OP_SETLIGHT
    NULL,                               //  35  D3DDP2OP_CREATELIGHT
    nvDP2CaptureSetTransform,           //  36  D3DDP2OP_SETTRANSFORM
    nvDP2CaptureExtension,              //  37  D3DDP2OP_EXT
    NULL,                               //  38  D3DDP2OP_TEXBLT
    nvDP2StateSet,                      //  39  D3DDP2OP_STATESET
    NULL,                               //  40  D3DDP2OP_SETPRIORITY
    NULL,                               //  41  D3DDP2OP_SETRENDERTARGET
    NULL,                               //  42  D3DDP2OP_CLEAR
    NULL,                               //  43  D3DDP2OP_SETTEXLOD
    nvDP2CaptureSetClipPlane,           //  44  D3DDP2OP_SETCLIPPLANE
    NULL,                               //  45  D3DDP2OP_CREATEVERTEXSHADER
    NULL,                               //  46  D3DDP2OP_DELETEVERTEXSHADER
    nvDP2CaptureSetVertexShader,        //  47  D3DDP2OP_SETVERTEXSHADER
    nvDP2CaptureSetVertexShaderConst,   //  48  D3DDP2OP_SETVERTEXSHADERCONST
    nvDP2CaptureSetStreamSource,        //  49  D3DDP2OP_SETSTREAMSOURCE
    nvDP2CaptureSetStreamSourceUM,      //  50  D3DNTDP2OP_SETSTREAMSOURCEUM
    nvDP2CaptureSetIndices,             //  51  D3DDP2OP_SETINDICES
    NULL,                               //  52  D3DDP2OP_DRAWPRIMITIVE
    NULL,                               //  53  D3DDP2OP_DRAWINDEXEDPRIMITIVE
    NULL,                               //  54  D3DDP2OP_CREATEPIXELSHADER
    NULL,                               //  55  D3DDP2OP_DELETEPIXELSHADER
    nvDP2CaptureSetPixelShader,         //  56  D3DDP2OP_SETPIXELSHADER
    nvDP2CaptureSetPixelShaderConst,    //  57  D3DNTDP2OP_SETPIXELSHADERCONST
    NULL,                               //  58  D3DNTDP2OP_CLIPPEDTRIANGLEFAN
    NULL,                               //  59  D3DNTDP2OP_DRAWPRIMITIVE2
    NULL,                               //  60  D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2
    NULL,                               //  61  D3DNTDP2OP_DRAWRECTSURFACE
    NULL,                               //  62  D3DNTDP2OP_DRAWTRISURFACE
    NULL,                               //  63  D3DDP2OP_VOLUMEBLT
    NULL,                               //  64  D3DDP2OP_BUFFERBLT
    NULL
};

//-------------------------------------------------------------------------

LPNVFVFINDEXEDPRIM fnFillModeIndexedTriangle[] =
{
    nvTriangleDispatch,  // illegal index, render solid by default
    nvPointIndexedTriangle,
    nvWireframeIndexedTriangle,
    nvTriangleDispatch
};

LPNVFVFDRAWPRIM fnFillModeNonIndexedTriangle[] =
{
    nvTriangleDispatch,  // illegal index, render solid by default
    nvPointNonIndexedTriangle,
    nvWireframeNonIndexedTriangle,
    nvTriangleDispatch
};

//---------------------------------------------------------------------------

HRESULT nvDP2Points (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_POINTNONINDEXEDTRI);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2Points");

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((lpPrim + (wCommandCount * sizeof(D3DHAL_DP2POINTS))) > pCommandBufferEnd) {
        DPF ("commands run beyond end of command buffer in nvDP2Points");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_POINTNONINDEXEDTRI);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    for (DWORD i=0; i < wCommandCount; i++) {

        pContext->dp2.dwDP2Prim     = D3DDP2OP_POINTS;
        pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wVStart;
        pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
        pContext->dp2.dwIndices     = NULL;
        pContext->dp2.dwIndexStride = 0;

        WORD wCount = ((LPD3DHAL_DP2POINTS)lpPrim)->wCount;

#ifdef VALIDATE_PARAMS
        // parameter validation (our responsibility under winNT)
        if ((pContext->dp2.dwTotalOffset + (wCount * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
            DPF ("vertices run beyond end of vertex buffer in nvDP2Points");
            dbgD3DError();
            dbgTracePop();
            DDENDTICK(PRIM_POINTNONINDEXEDTRI);
            return (DDERR_INVALIDPARAMS);
        }
#endif

#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            nvKelvinDispatchNonIndexedPrimitive (pContext, wCount);
        }
        else
#endif
#if (NVARCH >= 0x010)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            nvCelsiusDispatchNonIndexedPrimitive (pContext, wCount);
        }
        else
#endif
        {
            nvHWLockTextures (pContext);
            if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
                nvDrawPointList (pContext, wCount);
            }
            else {
                nvFVFDrawPointList (pContext, wCount);
            }
            nvHWUnlockTextures (pContext);
        }

        lpPrim += sizeof(D3DHAL_DP2POINTS);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2POINTS, wCommandCount, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_POINTNONINDEXEDTRI);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style non-indexed line list.

HRESULT nvDP2LineList (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_DRAWLINELISTNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2LineList");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_LINELIST;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2LINELIST)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pContext->dp2.dwTotalOffset + (2 * wCommandCount * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2LineList");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINELISTNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvDrawLine (pContext, wCommandCount);
        }
        else {
            nvFVFDrawLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2LINELIST, 1, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINELISTNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

//  Old Execute Buffer RenderPrimitive style indexed line list.

HRESULT nvDP2IndexedLineList (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim;

    DDSTARTTICK(PRIM_DRAWLINELISTINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedLineList");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDLINELIST;
    pContext->dp2.dwVStart      = 0;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->dp2.dwIndices     = (DWORD)pIndices;
    pContext->dp2.dwIndexStride = 2;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + (2 * wCommandCount * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedLineList");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINELISTINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvIndexedLine (pContext, wCommandCount);
        }
        else {
            nvFVFIndexedLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2INDEXEDLINELIST, wCommandCount, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINELISTINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOneIndexedPrimitive style indexed line list.

HRESULT nvDP2IndexedLineList2 (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

    DDSTARTTICK(PRIM_DRAWLINELISTINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedLineList2");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDLINELIST2;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + (2 * wCommandCount * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedLineList2");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINELISTINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvIndexedLine (pContext, wCommandCount);
        }
        else {
            nvFVFIndexedLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2INDEXEDLINELIST, wCommandCount, sizeof(D3DHAL_DP2STARTVERTEX));

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINELISTINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style in-line command buffer non-indexed line list.

HRESULT nvDP2LineListImm (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pVertices     = lpPrim;

    DDSTARTTICK(PRIM_DRAWLINELISTNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2LineListImm");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_LINELIST;
    pContext->dp2.dwVStart      = 0;
    pContext->dp2.dwTotalOffset = 0;
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

    // Make sure command buffer is DWORD aligned for immediate line list vertices.
    pVertices = (LPBYTE)(((DWORD)pVertices + 3) & ~3);

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if (((DWORD)pVertices + (2 * wCommandCount * pContext->pCurrentVShader->getStride())) > (DWORD)pCommandBufferEnd) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2LineListImm");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINELISTNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    CVertexBuffer  tempVB;
    CVertexBuffer *pIncomingVB;
    DWORD          dwIncomingDMACount;

    // cache incoming vertex buffer and temporarily override it with a new one containing the immediate mode data
    pIncomingVB        = pContext->ppDX8Streams[0];
    dwIncomingDMACount = pContext->dwStreamDMACount;

    tempVB.own ((DWORD)pVertices, 2*wCommandCount*pContext->pCurrentVShader->getStride(), CSimpleSurface::HEAP_SYS);
    tempVB.setVertexStride (pContext->pCurrentVShader->getStride());
    pContext->ppDX8Streams[0] = &tempVB;
    pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, 1);

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvDrawLine (pContext, wCommandCount);
        }
        else {
            nvFVFDrawLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]  = pIncomingVB;
    pContext->dwStreamDMACount = dwIncomingDMACount;

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif

    NEXTINSTRUCTION((*ppCommands), BYTE, ((wCommandCount + 1) * pContext->pCurrentVShader->getStride()), 0);
    // Realign next command since vertices are dword aligned
    (*ppCommands) = (LPD3DHAL_DP2COMMAND)(( ((DWORD)(*ppCommands)) + 3 ) & ~ 3);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINELISTNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style non-indexed line strip.

HRESULT nvDP2LineStrip (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_DRAWLINESTRIPNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2LineStrip");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_LINESTRIP;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pContext->dp2.dwTotalOffset + ((wCommandCount+1) * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2LineStrip");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINESTRIPNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvDrawLine (pContext, wCommandCount);
        }
        else {
            nvFVFDrawLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2LINESTRIP, 1, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINESTRIPNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOneIndexedPrimitive style indexed line strip.

HRESULT nvDP2IndexedLineStrip (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

    DDSTARTTICK(PRIM_DRAWLINESTRIPINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedLineStrip");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDLINESTRIP;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + ((wCommandCount+1) * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedLineStrip");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINESTRIPINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvIndexedLine (pContext, wCommandCount);
        }
        else {
            nvFVFIndexedLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), WORD, wCommandCount + 1, sizeof(D3DHAL_DP2STARTVERTEX));

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINESTRIPINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style non-indexed triangle list.

HRESULT nvDP2TriangleList (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_DRAWTRILISTNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2TriangleList");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLELIST;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2TRIANGLELIST)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_TRIANGLELIST)) {
        NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLELIST, 1, 0);
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pContext->dp2.dwTotalOffset + (3 * wCommandCount * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2TriangleList");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWTRILISTNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeNonIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLELIST, 1, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWTRILISTNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// old style RenderPrimitive Execute Buffer entry.

HRESULT nvDP2IndexedTriangleList (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim;

    DDSTARTTICK(PRIM_DRAWTRILISTINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedTriangleList");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST;
    pContext->dp2.dwVStart      = 0;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_INDEXEDTRIANGLELIST)) {
        NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2INDEXEDTRIANGLELIST, wCommandCount, 0);
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + (4 * wCommandCount * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedTriangleList");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWTRILISTINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        // if we're in wireframe mode, we have to heed edge flags...
        ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
         nvKelvinDispatchLegacyWireframePrimitive :
         nvKelvinDispatchIndexedPrimitive) (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        // if we're in wireframe mode, we have to heed edge flags...
        ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
         nvCelsiusDispatchLegacyWireframePrimitive :
         nvCelsiusDispatchIndexedPrimitive) (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2INDEXEDTRIANGLELIST, wCommandCount, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWTRILISTINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------
// DX5 style DrawOneIndexedPrimitive indexed triangle strip.
HRESULT nvDP2IndexedTriangleList2 (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

    DDSTARTTICK(PRIM_DRAWTRILISTINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedTriangleList2");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST2;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_INDEXEDTRIANGLELIST2)) {
        NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2INDEXEDTRIANGLELIST2, wCommandCount, sizeof(D3DHAL_DP2STARTVERTEX));
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + (3 * wCommandCount * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedTriangleList2");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWTRILISTINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2INDEXEDTRIANGLELIST2, wCommandCount, sizeof(D3DHAL_DP2STARTVERTEX));

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWTRILISTINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style non-indexed triangle strip.

HRESULT nvDP2TriangleStrip (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_DRAWSTRIPSOLIDNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2TriangleStrip");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLESTRIP;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2TRIANGLESTRIP)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_TRIANGLESTRIP)) {
        NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLESTRIP, 1, 0);
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pContext->dp2.dwTotalOffset + ((wCommandCount+2) * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2TriangleStrip");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWSTRIPSOLIDNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeNonIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLESTRIP, 1, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWSTRIPSOLIDNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOneIndexedPrimitive style indexed triangle strip.

HRESULT nvDP2IndexedTriangleStrip (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

    DDSTARTTICK(PRIM_DRAWSTRIPSOLIDINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedTriangleStrip");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLESTRIP;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_INDEXEDTRIANGLESTRIP)) {
        NEXTINSTRUCTION((*ppCommands), WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + ((wCommandCount+2) * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedTriangleStrip");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWSTRIPSOLIDINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWSTRIPSOLIDINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style non-indexed triangle fan.

HRESULT nvDP2TriangleFan (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_DRAWFANSOLIDNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2TriangleFan");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2TRIANGLEFAN)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_TRIANGLEFAN)) {
        NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLEFAN, 1, 0);
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pContext->dp2.dwTotalOffset + ((wCommandCount+2) * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2TriangleFan");
        dbgD3DError();
        DDENDTICK(PRIM_DRAWFANSOLIDNONINDEXED);
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeNonIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLEFAN, 1, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWFANSOLIDNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOneIndexedPrimitive style indexed triangle fan.

HRESULT nvDP2IndexedTriangleFan (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

    DDSTARTTICK(PRIM_DRAWFANSOLIDINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedTriangleFan");

    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLEFAN;
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_INDEXEDTRIANGLEFAN)) {
        NEXTINSTRUCTION((*ppCommands), WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + ((wCommandCount+2) * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedTriangleFan");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWFANSOLIDINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWFANSOLIDINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// Inline command buffer non-indexed triangle fans. Similar to DX5 style DrawOnePrimitive.

HRESULT nvDP2TriangleFanImm (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    LPBYTE pVertices     = lpPrim + sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
           pVertices     = (LPBYTE)(((DWORD)pVertices + 3) & ~3);

    DDSTARTTICK(PRIM_DRAWFANSOLIDNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2TriangleFanImm");

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_TRIANGLEFAN_IMM)) {
        NEXTINSTRUCTION((*ppCommands), BYTE, ((wCommandCount + 2) * fvfData.dwVertexStride), sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN_IMM;
    pContext->dp2.dwVStart      = 0;
    pContext->dp2.dwTotalOffset = 0;
    pContext->dp2.dwEdgeFlags   = ((LPD3DHAL_DP2TRIANGLEFAN_IMM)lpPrim)->dwEdgeFlags;
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if (((DWORD)pVertices + ((wCommandCount+2) * pContext->pCurrentVShader->getStride())) > (DWORD)pCommandBufferEnd) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2TriangleFanImm");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWFANSOLIDNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

    CVertexBuffer  tempVB;
    CVertexBuffer *pIncomingVB;
    DWORD          dwIncomingDMACount;

    // cache incoming vertex buffer and temporarily override it with a new one containing the immediate mode data
    pIncomingVB        = pContext->ppDX8Streams[0];
    dwIncomingDMACount = pContext->dwStreamDMACount;

    tempVB.own ((DWORD)pVertices, (wCommandCount+2)*pContext->pCurrentVShader->getStride(), CSimpleSurface::HEAP_SYS);
    tempVB.setVertexStride (pContext->pCurrentVShader->getStride());
    pContext->ppDX8Streams[0] = &tempVB;
    pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, 1);

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        // if we're in wireframe mode, we have to heed edge flags...
        ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
         nvKelvinDispatchLegacyWireframePrimitive :
         nvKelvinDispatchNonIndexedPrimitive) (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {

#ifdef WINNT    // setup for NT bounds checking, save current value
        DWORD temp = global.dwMaxVertexOffset;
        global.dwMaxVertexOffset = (wCommandCount + 2) * pContext->pCurrentVShader->getStride();
#endif

        // if we're in wireframe mode, we have to heed edge flags...
        ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
         nvCelsiusDispatchLegacyWireframePrimitive :
         nvCelsiusDispatchNonIndexedPrimitive) (pContext, wCommandCount);

#ifdef WINNT    // restore previous value
         global.dwMaxVertexOffset = temp;
#endif
    }

    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeNonIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]  = pIncomingVB;
    pContext->dwStreamDMACount = dwIncomingDMACount;

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif

    NEXTINSTRUCTION((*ppCommands), BYTE, ((wCommandCount + 2) * pContext->pCurrentVShader->getStride()), sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));
    // Realign next command since vertices are dword aligned and store # of primitives before affecting the pointer
    (*ppCommands) = (LPD3DHAL_DP2COMMAND)((((DWORD)(*ppCommands)) + 3 ) & ~ 3);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWFANSOLIDNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetRenderState (NV_DP2FUNCTION_ARGLIST)
{
    WORD    wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE  lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD   i, dwState, dwValue;
    HRESULT ddrval = D3D_OK;

    dbgTracePush ("nvDP2SetRenderState");

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((lpPrim + (wCommandCount * sizeof(D3DHAL_DP2POINTS))) > pCommandBufferEnd) {
        DPF ("commands run beyond end of command buffer in nvDP2SetRenderState");
        dbgD3DError();
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Run through the render state list.
    nvAssert (wCommandCount != 0);

    for (i = 0; i < wCommandCount; i++) {

        dwState = ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->RenderState;
        dwValue = ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->dwState;
        lpPrim += sizeof(D3DHAL_DP2RENDERSTATE);

        if (IS_OVERRIDE(dwState)) {
            DWORD override = GET_OVERRIDE(dwState);
            if (((override - 1) >> DWORD_SHIFT) >= (MAX_STATE >> DWORD_SHIFT))
            {
                DPF("Invalid state override\n");
                dbgD3DError();
                continue;
            }
            if (dwValue) {
                DPF_LEVEL (NVDBG_LEVEL_INFO,
                           "nvDrawPrimitives2 - setting override for state %08x",
                           override);
                STATESET_SET(pContext->overrides, override);
            }
            else {
                DPF_LEVEL (NVDBG_LEVEL_INFO,
                           "nvDrawPrimitives2, clearing override for state %08x",
                           override);
                STATESET_CLEAR(pContext->overrides, override);
            }
            continue;
        }
        if (STATESET_ISSET(pContext->overrides, dwState)) {
            DPF_LEVEL (NVDBG_LEVEL_INFO,
                       "nvDrawPrimitives2, state %08x is overridden, ignoring",
                       dwState);
            continue;
        }
        if ((pContext->dwDXAppVersion < 0x700)
         && pdwDP2RStates)
        {
            // state blocks are broken in the runtime of we write this state back

            pdwDP2RStates[dwState] = dwValue;
        }

        nvSetContextState (pContext, dwState, dwValue, &ddrval);

        // Want to show that the application has set texturemapblend renderstate even if
        // it's the same as the last time.
        if (dwState == D3DRENDERSTATE_TEXTUREMAPBLEND)
        {
            pContext->bUseTBlendSettings = TRUE;
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_COMBINERS;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_COLOR;
#endif
        }

    }

    // If the state has changed force a hardware state load.
    if (pContext->bStateChange) {
        // If this is a DX6 application, then force hardware steup through
        // the DX6 hardware setup routine, even if there is only one stage.
        pContext->bUseDX6Class = (pContext->dwDXAppVersion >= 0x0600);
        NV_FORCE_TRI_SETUP(pContext);
    }

    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvSetRenderState failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2RENDERSTATE, wCommandCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    return (ddrval);
}

//-------------------------------------------------------------------------------------

HRESULT nvDP2SetTextureStageState (NV_DP2FUNCTION_ARGLIST)
{
    WORD    wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE  lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    BOOL    bTSSChanged;
    DWORD   i, dwStage, dwState, dwValue;
    HRESULT ddrval = D3D_OK;

    dbgTracePush ("nvDP2SetTextureStageState");

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((lpPrim + (wCommandCount * sizeof(D3DHAL_DP2POINTS))) > pCommandBufferEnd) {
        DPF ("commands run beyond end of command buffer in nvDP2SetTextureStageState");
        dbgD3DError();
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }
#endif

    bTSSChanged = FALSE;

    for (i = 0; i < wCommandCount; i++) {

        dwStage = (DWORD)((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->wStage;
        dwState = ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->TSState;
        dwValue = ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->dwValue;

        if (dbgShowState & NVDBG_SHOW_RENDER_STATE)
            DPF("Texture Stage State Change - Stage: %d, State: %d, Value: %d", dwStage, dwState, dwValue);

        switch (dwState) {

            case D3DTSS_TEXTUREMAP:  // 0
                // assert that no texture has been set via D3DRENDERSTATE_TEXTUREHANDLE
                nvAssert (pContext->tssState[0].dwHandle == 0);
                //check to see if the current streams/rendertarget/Z/textures need to be unlocked
                if(pContext->dwHWUnlockAllPending){ //HMH
                    nvHWUnlockTextures (pContext);
                    // need to mark all streams as in use by hardware...
                    nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
                    pContext->dwHWUnlockAllPending=FALSE;
                }
                // Turn the texture handle into a texture pointer.
                if (dwValue) {
                    DWORD dwTranslatedValue;
                    if (global.dwDXRuntimeVersion >= 0x0700) {
                        dwTranslatedValue = (DWORD) nvGetObjectFromHandle (pContext->dwDDLclID, dwValue, &global.pNvSurfaceLists);
                    }
                    else {
                        dwTranslatedValue = dwValue | 0x80000000;
                    }
                    if (pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP] != dwTranslatedValue) {
                        pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP] = dwTranslatedValue;
                        bTSSChanged = TRUE;
                    }
                }
                else {
                    if (pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP]) {
                        pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP] = dwValue;
                        bTSSChanged = TRUE;
                    }
                }
                break;

            case D3DTSS_COLOROP:    // 1
            case D3DTSS_COLORARG1:  // 2
            case D3DTSS_COLORARG2:  // 3
            case D3DTSS_ALPHAOP:    // 4
            case D3DTSS_ALPHAARG1:  // 5
            case D3DTSS_ALPHAARG2:  // 6
            case D3DTSS_COLORARG0:  // 6
            case D3DTSS_ALPHAARG0:  // 6
                if ((pContext->tssState[dwStage].dwValue[dwState] != dwValue) || (pContext->bUseTBlendSettings)) {
                    pContext->tssState[dwStage].dwValue[dwState] = dwValue;
                    bTSSChanged = TRUE;
                    pContext->bUseTBlendSettings = FALSE;
                }
                break;

            case D3DTSS_ADDRESS:  // 12
                if ((pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSU] != dwValue) ||
                    (pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSV] != dwValue)) {
                    pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSU] = dwValue;
                    pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSV] = dwValue;
                    bTSSChanged = TRUE;
                }
                break;

            case D3DTSS_MIPMAPLODBIAS:  // 19
                if (pContext->tssState[dwStage].dwValue[D3DTSS_MIPMAPLODBIAS] != dwValue) {
                    pContext->tssState[dwStage].dwValue[D3DTSS_MIPMAPLODBIAS] = dwValue;
                    pContext->tssState[dwStage].dwLODBias = nvTranslateLODBias (dwValue);
                    bTSSChanged = TRUE;
                }
                break;

            default:
                nvAssert (dwState <= D3D_TEXSTAGESTATE_MAX);
                if (pContext->tssState[dwStage].dwValue[dwState] != dwValue) {
                    pContext->tssState[dwStage].dwValue[dwState] = dwValue;
                    bTSSChanged = TRUE;
                }
                break;

        } // switch

        nvAssert (dwState <= D3D_TEXSTAGESTATE_MAX);
        if (bTSSChanged) {
            #if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[dwState];
                pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[dwState];
            #endif
        }

        lpPrim += sizeof (D3DHAL_DP2TEXTURESTAGESTATE);

    } // for (i...

    // If the state has changed force a hardware state load.
    if (bTSSChanged) {
        // If this is a DX6 application, then force hardware steup through
        // the DX6 hardware setup routine, even if there is only one stage.
        pContext->bUseDX6Class  = (pContext->dwDXAppVersion >= 0x0600);
        pContext->bStateChange = TRUE;
        NV_FORCE_TRI_SETUP(pContext);
    }

    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvSetTSS failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TEXTURESTAGESTATE, wCommandCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDTICKOFFSET(dwState+D3D_NUM_RENDERSTATES, dwValue);
    return (ddrval);
}

//-------------------------------------------------------------------------------------

HRESULT nvDP2SetViewport (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;
    WORD   wX, wY, wWidth, wHeight;

    DDSTARTTICK(DEVICE7_SETVIEWPORT);
    dbgTracePush ("nvDP2SetViewport");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    wX      = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwX & 0x0000FFFF);
    wY      = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwY & 0x0000FFFF);
    wWidth  = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwWidth & 0x0000FFFF);
    wHeight = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwHeight & 0x0000FFFF);

    if ((pContext->surfaceViewport.clipHorizontal.wX != wX)         ||
        (pContext->surfaceViewport.clipVertical.wY != wY)           ||
        (pContext->surfaceViewport.clipHorizontal.wWidth != wWidth) ||
        (pContext->surfaceViewport.clipVertical.wHeight != wHeight)) {

        pContext->surfaceViewport.clipHorizontal.wX     = wX;
        pContext->surfaceViewport.clipVertical.wY       = wY;
        pContext->surfaceViewport.clipHorizontal.wWidth = wWidth;
        pContext->surfaceViewport.clipVertical.wHeight  = wHeight;

#if (NVARCH >= 0x020)
        pContext->hwState.dwDirtyFlags  |= KELVIN_DIRTY_TRANSFORM;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
#endif
        if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
            !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN))
        {
            nvSetD3DSurfaceViewport(pContext);
        }
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2VIEWPORTINFO, 1, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETVIEWPORT);
    return (D3D_OK);
}

//-------------------------------------------------------------------------------------

void nvSetWRange(PNVD3DCONTEXT pContext, D3DVALUE dvWNear, D3DVALUE dvWFar)
{
    pContext->surfaceViewport.dvWNear = dvWNear;
    pContext->surfaceViewport.dvWFar  = dvWFar;

    // If the WFar value is 0.0, then set a default based on the z-buffer precision.
    if (pContext->surfaceViewport.dvWFar == 0.0f) {
        pContext->surfaceViewport.dvWNear = 0.0f;
        if (pContext->pZetaBuffer && pContext->pZetaBuffer->getBPP() == 2) {
            pContext->surfaceViewport.dvWFar = (D3DVALUE) getDC()->nvD3DRegistryData.regfWScale16;
        }
        else {
            pContext->surfaceViewport.dvWFar = (D3DVALUE) getDC()->nvD3DRegistryData.regfWScale24;
        }
    }

    nvCalcRWFar(pContext);

    // calculate the inverse
    nvAssert (pContext->surfaceViewport.dvWFar != 0.0f);
    pContext->surfaceViewport.dvInvWFar = 1.0f / pContext->surfaceViewport.dvWFar;

    nvDetermineEarlyCopyStrategy(pContext);
    pContext->hwState.SuperTri.setStrategy();

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TRANSFORM | KELVIN_DIRTY_TRANSFORM);
#endif

    // determine if fog source is Z or W
    if ((*(DWORD *)&(pContext->surfaceViewport.dvWNear) == FP_ONE_BITS) &&
        (*(DWORD *)&(pContext->surfaceViewport.dvWFar)  == FP_ONE_BITS)) {
        pContext->hwState.dwFogSource = CHardwareState::FOG_SOURCE_Z;
    }
    else {
        pContext->hwState.dwFogSource = CHardwareState::FOG_SOURCE_W;
    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_SPECFOG_COMBINER | KELVIN_DIRTY_VERTEX_SHADER);
#endif
}

//-------------------------------------------------------------------------------------

HRESULT nvDP2SetWRange (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(DEVICE7_SETWRANGE);
    dbgTracePush ("nvDP2SetWRange");

    nvSetWRange(pContext, ((LPD3DHAL_DP2WINFO)lpPrim)->dvWNear, ((LPD3DHAL_DP2WINFO)lpPrim)->dvWFar);

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2WINFO, 1, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETWRANGE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetPalette(NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD  hr     = DD_OK;

    DDSTARTTICK(SURF7_SETPALETTE);
    dbgTracePush ("nvDP2SetPalette");

    // on DX7 we get spurious and calls to this function with totally bogus data. just ignore them
    if (global.dwDXRuntimeVersion >= 0x0800) {

        LPD3DHAL_DP2SETPALETTE pSetPalette = (LPD3DHAL_DP2SETPALETTE)lpPrim;

        nvAssert (pSetPalette->dwPaletteHandle != 0);   //maybe a delete call?
        nvAssert (pSetPalette->dwSurfaceHandle != 0);   //maybe a delete call?

        CNvObject *pSurfObj = nvGetObjectFromHandle (pContext->dwDDLclID, pSetPalette->dwSurfaceHandle, &global.pNvSurfaceLists);
        CNvObject *pPalObj  = nvGetObjectFromHandle (pContext->dwDDLclID, pSetPalette->dwPaletteHandle, &global.pNvPaletteLists);

        nvAssert(pSurfObj);  // we should get a surface mapping back.

        if (!pSurfObj) {
            NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETPALETTE, (*ppCommands)->wStateCount, 0);
            dbgTracePop();
            DDENDTICK(SURF7_SETPALETTE);
            return DDERR_INVALIDPARAMS;
        }

        CSimpleSurface* pNvPalette;

        // if the palette object didn't already exists create and add it to the list
        // there is a problem here in that I'm not sure how to detach a palette once its been
        // attached.  The application says to set it to NULL -- but I receive palette handles here
        // so detaching a palette may be a bit problematic
        if (pPalObj == NULL) {

#ifndef WINNT
            //this is a hack cause I don't have a ddslcl to get a pid from here???
            //I don't get create calls like I do for surfaces and must lazily create
            //the palette surfaces at the last moment.  Make it match the surfaces PID.
            pPalObj = new CNvObject (pSurfObj->getPID());
#else
            pPalObj = new CNvObject (0);
#endif
            assert (pPalObj); // todo - handle properly
            PNV_OBJECT_LIST pNvPL = nvFindObjectList(pContext->dwDDLclID, &global.pNvPaletteLists);
            nvAddObjectToList (pNvPL, pPalObj, pSetPalette->dwPaletteHandle);

            pNvPalette = new CSimpleSurface();

            assert (pNvPalette); // todo - handle properly
            if (!pNvPalette->create (4, 256, 1, 4,                                         // pitch, height, depth, BPP
                                     CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP,  // Allowed Heaps
                                     CSimpleSurface::HEAP_VID,                             // Preferred heaps
                                     CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                    ,CAPTURE_SURFACE_KIND_PALETTE
#endif
                                     )) {
                pPalObj->setObject(CNvObject::NVOBJ_PALETTE, pNvPalette);

                // if failed to allocate a surface move the buffer ptr and return an error
                NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETPALETTE, (*ppCommands)->wStateCount, 0);
                dbgTracePop();
                DDENDTICK(SURF7_SETPALETTE);
                return (DDERR_NOPALETTEATTACHED);
            }

            if (pSetPalette->dwPaletteFlags & DDRAWIPAL_ALPHA) {
                pNvPalette->tagHasAlpha();
            }

            // wrap the new surface(palette) with the nvobject(pPalObj)
            pPalObj->setObject(CNvObject::NVOBJ_PALETTE, pNvPalette);
        }

        else {

            pNvPalette = pPalObj->getPaletteSurface();

        }

        // bind the created palette to the texture.
        CTexture *pTex = pSurfObj->getTexture();

        if (pTex) {
            if (pTex->isPalettized()) {
                if (pTex->getBPP() == 1) { // 1 byte -- 8bit palette
                    pSurfObj->setPalette (pPalObj);
                    DPF_LEVEL (NVDBG_LEVEL_PALETTE, "Palette attach succeeded: surfHandle=%x palHandle=%x (%08x)\n",
                               pSetPalette->dwSurfaceHandle,
                               pSetPalette->dwPaletteHandle,
                               pPalObj->getPaletteSurface()->getAddress());
                }
                else{
                    DPF ("nvDP2SetPalette: Non 8-bit palettes not yet supported");
                    hr = DDERR_NOT8BITCOLOR;
                }
                if (pNvPalette->hasAlpha()) {
                    pTex->tagHasAlpha();
                }
                else {
                    pTex->tagHasNoAlpha();
                }
            }
            else {
                DPF_LEVEL (NVDBG_LEVEL_PALETTE, "Surface not palettized: pnvobj=%08x surfhandle=%d palhandle=%d\n",
                           pSurfObj, pSetPalette->dwSurfaceHandle, pSetPalette->dwPaletteHandle);
                hr = DDERR_NOTPALETTIZED;
            }
        }

        else {
            DPF_LEVEL (NVDBG_LEVEL_PALETTE, "ignoring request to attach palette to nontexture. pnvobj=%08x surfhandle=%d palhandle=%d\n",
                       pSurfObj, pSetPalette->dwSurfaceHandle, pSetPalette->dwPaletteHandle);
        }

    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETPALETTE, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(SURF7_SETPALETTE);
    return (hr);
}

//---------------------------------------------------------------------------

HRESULT nvDP2UpdatePalette(NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD  hr     = DD_OK;

    DDSTARTTICK(SURF7_UPDATEPALETTE);
    dbgTracePush ("nvDP2UpdatePalette");

    // check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }

    LPD3DHAL_DP2UPDATEPALETTE pUpdatePalette = (LPD3DHAL_DP2UPDATEPALETTE)lpPrim;

    // on DX7 we get spurious and calls to this function with totally bogus data. just ignore them
    if (global.dwDXRuntimeVersion >= 0x0800) {


        CNvObject *pPalObj = nvGetObjectFromHandle (pContext->dwDDLclID, pUpdatePalette->dwPaletteHandle, &global.pNvPaletteLists);

        //we should never see a null palette object because it should have been created before
        //ANY updates to a palette would occur
        assert(pPalObj);

        // To handle the case where this gets called after SetPalette that recieved an invalid
        // surface object.  This causes a Palette object to not be created, which would make the
        // line after this conditional GPF.
        if (!pPalObj) {
            dbgTracePop();
            NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2UPDATEPALETTE, (*ppCommands)->wStateCount, (DWORD)pUpdatePalette->wNumEntries * sizeof(PALETTEENTRY));
            DDENDTICK(SURF7_UPDATEPALETTE);
            return DDERR_INVALIDPARAMS;
        }

        CSimpleSurface* pNvPalette = (CSimpleSurface *)pPalObj->getPaletteSurface();

        if (!pNvPalette->getAddress()) {
            if (!pNvPalette->create (4, 256, 1, 4,                                         // pitch, height, depth, BPP
                                     CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP,  // Allowed Heaps
                                     CSimpleSurface::HEAP_VID,                             // Preferred heaps
                                     CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                    ,CAPTURE_SURFACE_KIND_PALETTE
#endif
                                     )) {
                dbgTracePop();
                NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2UPDATEPALETTE, (*ppCommands)->wStateCount, (DWORD)pUpdatePalette->wNumEntries*sizeof(PALETTEENTRY));
                DDENDTICK(SURF7_UPDATEPALETTE);
                return DDERR_INVALIDPARAMS;
            }
        }

        // we should now have a valid pNvSurface to work with
        nvAssert(pNvPalette);

        // COPY THE PALETTE INFORMATION

        // an assumption is made here that the palette entry size is the same as the 4BBP size
        // according to HW docs I have, we ALWAYS load a 256 entry (the only size we support) and it is
        // pulled from memory as a 1Kb block.  So even if we support a 'smaller' palette the HW will
        // still pull 1Kb in so allocate space for it -- don't want memory faults
        BYTE *pDest, *pSrc;
        pDest = LPBYTE(pNvPalette->getAddress() + sizeof(PALETTEENTRY) * pUpdatePalette->wStartIndex);
        pSrc  = ((LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND) +
                         (((*ppCommands)->wStateCount) * sizeof(D3DHAL_DP2UPDATEPALETTE)) +
                         //offset by the start index
                         sizeof(PALETTEENTRY) * pUpdatePalette->wStartIndex);

        // this is an 8 bit palette we should never copy more than 256 entries
        assert(pUpdatePalette->wStartIndex + pUpdatePalette->wNumEntries <= 256);

        DDLOCKINDEX(NVSTAT_LOCK_PALETTE);
        pNvPalette->cpuLock(CSimpleSurface::LOCK_NORMAL);

        if (pNvPalette->hasAlpha()) {
            for (int i = 0; i < pUpdatePalette->wNumEntries; i++) {
                pDest[0] = pSrc[2];
                pDest[1] = pSrc[1];
                pDest[2] = pSrc[0];
                pDest[3] = pSrc[3];
                pSrc += 4; pDest += 4;
            }
        } else {
            for (int i = 0; i < pUpdatePalette->wNumEntries; i++) {
                pDest[0] = pSrc[2];
                pDest[1] = pSrc[1];
                pDest[2] = pSrc[0];
                pDest[3] = 0xFF; // stomp alpha
                pSrc += 4; pDest += 4;
            }
        }
        pNvPalette->cpuUnlock();

#if (NVARCH >= 0x010)
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE;
#endif
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2UPDATEPALETTE, (*ppCommands)->wStateCount, (DWORD)pUpdatePalette->wNumEntries * sizeof(PALETTEENTRY));

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(SURF7_UPDATEPALETTE);
    return (hr);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetZRange (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2ZRANGE pZRange;

    DDSTARTTICK(DEVICE7_SETZRANGE);
    dbgTracePush ("nvDP2SetZRange");

    // Keep only the last viewport notification
    pZRange = (D3DHAL_DP2ZRANGE *)((*ppCommands) + 1) + ((*ppCommands)->wStateCount - 1);

    if ((pContext->surfaceViewport.dvMinZ != pZRange->dvMinZ) ||
        (pContext->surfaceViewport.dvMaxZ != pZRange->dvMaxZ)) {
        // Update T&L viewport state
        pContext->surfaceViewport.dvMinZ = pZRange->dvMinZ;
        pContext->surfaceViewport.dvMaxZ = pZRange->dvMaxZ;
    }

    assert(pContext->surfaceViewport.dvMinZ >=0 && pContext->surfaceViewport.dvMinZ <= 1.0);
    assert(pContext->surfaceViewport.dvMaxZ >=0 && pContext->surfaceViewport.dvMaxZ <= 1.0);
    assert(pContext->surfaceViewport.dvMinZ < pContext->surfaceViewport.dvMaxZ);

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2ZRANGE, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETZRANGE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetMaterial (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETMATERIAL pSetMat;

    DDSTARTTICK(DEVICE7_SETMATERIAL);
    dbgTracePush ("nvDP2SetMaterial");

    // Keep only the last material notification
    pSetMat = (D3DHAL_DP2SETMATERIAL *)((*ppCommands) + 1) + ((*ppCommands)->wStateCount - 1);

    if (memcmp (&(pContext->Material), pSetMat, sizeof(D3DMATERIAL7))) {
        pContext->Material = *(D3DMATERIAL7 *)pSetMat;
#if (NVARCH >= 0x010)
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_LIGHTS;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_LIGHTS;
#endif
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETMATERIAL, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETMATERIAL);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetLight (NV_DP2FUNCTION_ARGLIST)
{
#if (NVARCH >= 0x010)

    HRESULT hr = D3D_OK;
    WORD wNumSetLight = (*ppCommands)->wStateCount;
    LPD3DHAL_DP2SETLIGHT pSetLight;
    D3DLIGHT7 *pLightData;
    DWORD dwTotalStride;
    int i;

    DDSTARTTICK(DEVICE7_SETLIGHT);
    dbgTracePush ("nvDP2SetLight");

    dwTotalStride = sizeof(D3DHAL_DP2COMMAND);
    pSetLight = (LPD3DHAL_DP2SETLIGHT)((*ppCommands) + 1);
    pLightData = NULL;

    for (i=0; i < wNumSetLight; i++)
    {
        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);
        DWORD dwIndex = pSetLight->dwIndex;

        // Assert that create was not called here
        assert (dwIndex < pContext->dwLightArraySize);

        switch (SETLIGHT_DATATYPE(pSetLight)) {
            case D3DHAL_SETLIGHT_ENABLE:
                nvLightEnable(&(pContext->pLightArray[dwIndex]),
                              &(pContext->lighting.pActiveLights));
                break;
            case D3DHAL_SETLIGHT_DISABLE:
                nvLightDisable(&(pContext->pLightArray[dwIndex]),
                               &(pContext->lighting.pActiveLights));
                break;
            case D3DHAL_SETLIGHT_DATA:
                pLightData = (D3DLIGHT7 *)((LPBYTE)pSetLight + dwStride);
                dwStride += sizeof(D3DLIGHT7);
                hr |= nvLightSetLight (&(pContext->pLightArray[pSetLight->dwIndex]), pLightData);
                break;
            default:
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "Unknown SetLight command");
                hr |= DDERR_INVALIDPARAMS;
                break;
        }

//        if (hr != D3D_OK) return(hr); //can't do this because it hoses DP2 processing

        dwTotalStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight + dwStride);
    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_LIGHTS;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_LIGHTS;
#endif

    if (hr != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2SetLight failed");
    (*ppCommands) = (LPD3DHAL_DP2COMMAND)((LPBYTE)(*ppCommands) + dwTotalStride);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETLIGHT);
    return (hr);

#else  // !(NVARCH >= 0x010)

    DPF ("got unexpected call to SetLight in driver with no T&L support");
    DDENDTICK(DEVICE7_SETLIGHT);
    return (~D3D_OK);

#endif  // !(NVARCH >= 0x010))

}

//---------------------------------------------------------------------------

HRESULT nvDP2CreateLight (NV_DP2FUNCTION_ARGLIST)
{

#if (NVARCH >= 0x010)

    WORD wNumCreateLight = (*ppCommands)->wStateCount;
    LPD3DHAL_DP2CREATELIGHT pCreateLight = (LPD3DHAL_DP2CREATELIGHT)((*ppCommands) + 1);
    HRESULT hr = D3D_OK;

    DDSTARTTICK(DEVICE7_CREATELIGHT);
    dbgTracePush ("nvDP2CreateLight");

    for (DWORD i=0; i<wNumCreateLight; i++, pCreateLight++)
    {
        // If the index is not already allocated, grow the light array
        // by REF_LIGHTARRAY_GROWTH_SIZE
        if (pCreateLight->dwIndex >= pContext->dwLightArraySize)
        {
            hr = nvGrowLightArray (pContext, pCreateLight->dwIndex);
            if (hr != D3D_OK) return (hr);
        }
    }

    if (hr != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2CreateLight failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2CREATELIGHT, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDSTARTTICK(DEVICE7_CREATELIGHT);
    return (hr);

#else  // !(NVARCH >= 0x010)

    DPF ("got unexpected call to CreateLight in driver with no T&L support");
    DDSTARTTICK(DEVICE7_CREATELIGHT);
    return (~D3D_OK);

#endif  // (NVARCH >= 0x010))

}

//---------------------------------------------------------------------------

HRESULT nvDP2SetTransform (NV_DP2FUNCTION_ARGLIST)
{

#if (NVARCH >= 0x010)

    LPD3DHAL_DP2SETTRANSFORM   pSetXfrm;
    WORD                       wNumXfrms;
    D3DTRANSFORMSTATETYPE      xfrmType;
    D3DMATRIX                  *pMat;
    BOOL                       bSetIdentity;
    DWORD                      dwxfrmType, i, dwStage;

    DDSTARTTICK(DEVICE7_SETTRANSFORM);
    dbgTracePush ("nvDP2SetTransform");

    pSetXfrm = (LPD3DHAL_DP2SETTRANSFORM)((*ppCommands) + 1);
    wNumXfrms = (*ppCommands)->wStateCount;

    for (i=0; i < (int) wNumXfrms; i++) {

        xfrmType = pSetXfrm->xfrmType;
        pMat     = &pSetXfrm->matrix;
        // BUGBUG is there a define for 0x80000000?
        bSetIdentity = (xfrmType & 0x80000000) != 0;
        dwxfrmType   = (DWORD)xfrmType & (~0x80000000);

        switch (dwxfrmType) {

            case D3DTRANSFORMSTATE_WORLD_DX7:
            case D3DTS_WORLD:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmWorld[0]), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                nvMemCopy (&(pContext->xfmWorld[0]), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TRANSFORM |
                                                   CELSIUS_DIRTY_LIGHTS);
                pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TRANSFORM |
                                                   KELVIN_DIRTY_LIGHTS);
#endif
                break;

            case D3DTRANSFORMSTATE_WORLD1_DX7:
            case D3DTS_WORLD1:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmWorld[1]), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                nvMemCopy (&(pContext->xfmWorld[1]), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
                break;

            case D3DTRANSFORMSTATE_WORLD2_DX7:
            case D3DTS_WORLD2:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmWorld[2]), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                nvMemCopy (&(pContext->xfmWorld[2]), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x020)
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
                break;

            case D3DTRANSFORMSTATE_WORLD3_DX7:
            case D3DTS_WORLD3:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmWorld[3]), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                nvMemCopy (&(pContext->xfmWorld[3]), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x020)
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
                break;

            case D3DTRANSFORMSTATE_VIEW:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmView), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                nvMemCopy (&(pContext->xfmView), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
#if STATE_OPTIMIZE
                pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TRANSFORM |
                                                   CELSIUS_DIRTY_LIGHTS);
                pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TRANSFORM |
                                                   KELVIN_DIRTY_LIGHTS);

                // Only set texture state if we're doing TEXGEN -- D3DTSS_TCI_CAMERASPACENORMAL
                // Setting texture state is a HEAVY operation, especially on Kelvin

                if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_TEXSTATENEEDSINVMV)
                    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE;

                if (pContext->hwState.dwStateFlags & KELVIN_FLAG_TEXSTATENEEDSINVMV)
                    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE;

#else
                pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TEXTURE_STATE |
                                                   CELSIUS_DIRTY_TRANSFORM |
                                                   CELSIUS_DIRTY_LIGHTS);
                pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TEXTURE_STATE |
                                                   KELVIN_DIRTY_TRANSFORM |
                                                   KELVIN_DIRTY_LIGHTS);
#endif
#endif
                break;

            case D3DTRANSFORMSTATE_PROJECTION:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmProj), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
#ifdef  STEREO_SUPPORT
                if (STEREO_ENABLED)
                {
                    pMat = SetStereoProjection(pMat, pContext);
                }
#endif  //STEREO_SUPPORT
                nvMemCopy (&(pContext->xfmProj), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
                if (pContext->dwDXAppVersion == 0x800) {
                    // Due to a bug in the runtime, SetWRange is not called for pure HAL
                    // apps in DX8. As a result, we have to determine if fog source is Z
                    // or W from the projection matrix. The pure HAL did not exit for DX7
                    // or before, and the bug is fixed in DX8.1, so we only need to worry
                    // about DX8.
                    if ((*(DWORD *)&(pMat->_14) == 0) &&
                        (*(DWORD *)&(pMat->_24) == 0) &&
                        (*(DWORD *)&(pMat->_34) == 0) &&
                        (*(DWORD *)&(pMat->_44) == FP_ONE_BITS)) {
                        pContext->hwState.dwFogSource = CHardwareState::FOG_SOURCE_Z;
                    }
                    else {
                        pContext->hwState.dwFogSource = CHardwareState::FOG_SOURCE_W;
                    }
                    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_SPECFOG_COMBINER | KELVIN_DIRTY_VERTEX_SHADER);
                }

                // set the WNear and WFar values from the supplied projection
                if ((pMat->_33 == pMat->_34) || (pMat->_33 == 0.0f))
                {
                    DPF("Cannot compute WNear and WFar from the supplied projection");
                    DPF("Setting wNear to 0.0 and wFar to 1.0");
                    nvSetWRange(pContext, 0.0, 1.0);
                } else {
                    nvSetWRange(pContext,
                                pMat->_44 - pMat->_43 / pMat->_33 * pMat->_34,
                                (pMat->_44 - pMat->_43) / (pMat->_33 - pMat->_34) * pMat->_34 + pMat->_44);
                }

                break;

            case D3DTRANSFORMSTATE_TEXTURE0:
            case D3DTRANSFORMSTATE_TEXTURE1:
            case D3DTRANSFORMSTATE_TEXTURE2:
            case D3DTRANSFORMSTATE_TEXTURE3:
            case D3DTRANSFORMSTATE_TEXTURE4:
            case D3DTRANSFORMSTATE_TEXTURE5:
            case D3DTRANSFORMSTATE_TEXTURE6:
            case D3DTRANSFORMSTATE_TEXTURE7:
                dwStage = xfrmType - D3DTRANSFORMSTATE_TEXTURE0;
                if (bSetIdentity) {
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->tssState[dwStage].mTexTransformMatrix), &matrixIdent, sizeof(D3DMATRIX)))
                    break;
#endif
                    nvMemCopy (&pContext->tssState[dwStage].mTexTransformMatrix, &matrixIdent, sizeof(D3DMATRIX));
                }
                else {
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->tssState[dwStage].mTexTransformMatrix), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                    nvMemCopy (&pContext->tssState[dwStage].mTexTransformMatrix, pMat, sizeof(D3DMATRIX));
                }
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_TRANSFORM;
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_TRANSFORM;
#endif
                break;

            default:
                DPF_LEVEL (NVDBG_LEVEL_INFO,"Ignoring unknown transform type in SetXfrm");
                break;

        }  // switch (dwxfrmType)

        pSetXfrm++;

    } // for...

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETTRANSFORM, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETTRANSFORM);
    return (D3D_OK);

#else  // !(NVARCH >= 0x010)

    DPF ("got unexpected call to SetTransform in driver with no T&L support");
    DDENDTICK(DEVICE7_SETTRANSFORM);
    return (~D3D_OK);

#endif  // (NVARCH >= 0x010))

}

//---------------------------------------------------------------------------

HRESULT nvDP2Extension (NV_DP2FUNCTION_ARGLIST)
{
    // nada for now
    DPF ("DP2Extension called. doing nothing");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2EXT, (*ppCommands)->wStateCount, 0);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// wrapper routine to interface the DX7 DP2 token TEXBLT with the original Blit32 callback
// note that one DP2_TEXBLT command can handle multiple blits and/or entire mipmap chains

HRESULT nvDP2TexBlt (NV_DP2FUNCTION_ARGLIST)
{
    DDSTARTTICK(SURF7_TEXTUREBLIT);
    dbgTracePush ("nvDP2TexBlt");

#ifdef NO_DP2_TEX

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2TEXBLT, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    DDENDTICK(SURF7_TEXTUREBLIT);
    return (D3D_OK);

#endif

    DWORD dwNumBlits = (*ppCommands)->wStateCount;
    LPD3DHAL_DP2TEXBLT pTexBltData = (LPD3DHAL_DP2TEXBLT) ((*ppCommands) + 1);

    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }

    for (DWORD i=0; i < dwNumBlits; i++) {
        if (pTexBltData->dwDDDestSurface) {
            CNvObject* pSrcObj = nvGetObjectFromHandle (pContext->dwDDLclID, pTexBltData->dwDDSrcSurface, &global.pNvSurfaceLists);
            CNvObject* pDstObj = nvGetObjectFromHandle (pContext->dwDDLclID, pTexBltData->dwDDDestSurface, &global.pNvSurfaceLists);

            RECTL rectSrc  = pTexBltData->rSrc;
            POINT pointDst = pTexBltData->pDest;
            DWORD dwFlags  = pTexBltData->dwFlags;

            BOOL bRVal = FALSE;

            CTexture* pDstTexture = pDstObj->getTexture();

            // check if this was previously auto-paletized and revert if needed
            BOOL bFullSurface = (!(pointDst.x & pointDst.y)
                             && ((rectSrc.right - rectSrc.left) == (LONG)pDstTexture->getWidth())
                             && ((rectSrc.bottom - rectSrc.top) == (LONG)pDstTexture->getHeight()));

            nvAutoPaletteCheckAndRevert(pDstTexture, bFullSurface);

            BOOL bPalettable = (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_AUTOPALETTE) // requested
                            && !pDstTexture->isReused()             // haven't done this one before
                            && !pDstTexture->isDXT()                // not DXT
                            && !pDstTexture->isCubeMap()            // not a cube map (we get separate blits for each face)
                            && (pDstTexture->getBPP() == 4)         // 32 bit only
                            && (bFullSurface)                       // full surface blit
                            && (pDstTexture->getWidth() >= 32)      // greater than 32x32
                            && (pDstTexture->getHeight() >= 32)
                            // we should be able to handle AGP too, but not multistage AGP & VID together due to hardware limitations
                            // this can be fixed by copying the AGP palette temporariliy to the free memory above the vid palette
                            && (pDstTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_VID)
                            && (pSrcObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE) // source must be sysmem surface
                            && !pContext->bSeenTriangles;   // Don't palettize if we've started 3d rendering.

            if (bPalettable) {
                // try a paletteBlt
                bRVal = nvPaletteBlt(pSrcObj, pDstTexture);
                if (!bRVal) {
                    pDstTexture->tagUnpalettized(); // tag so we don't try palettizing this texture again
                }
            }

            if (!bRVal) {
                // do a normal blit
                while (1) {
                    // the source is either a texture or a simple surface, get its width
                    nvAssert (pSrcObj->getTexture() || pSrcObj->getSimpleSurface());
                    DWORD dwSrcWidth = pSrcObj->getTexture() ? pSrcObj->getTexture()->getWidth()
                        : pSrcObj->getSimpleSurface()->getWidth();

                    // MS requires us to blt only from the matching level onwards (DCT300)
                    if (dwSrcWidth == pDstObj->getTexture()->getWidth()) {
                        D3DBOX boxSrc;

                        boxSrc.Left = rectSrc.left;
                        boxSrc.Right = rectSrc.right;
                        boxSrc.Top = rectSrc.top;
                        boxSrc.Bottom = rectSrc.bottom;
                        boxSrc.Front = 0;
                        boxSrc.Back = 1;

                        DWORD dwRV = nvTextureBltDX7 (pContext, pSrcObj, pDstObj, &boxSrc, pointDst.x, pointDst.y, 0, dwFlags);
                        if (dwRV != DD_OK) {
                            DPF_LEVEL (NVDBG_LEVEL_ERROR,"D3D: nvTexBltDP2 failed");
                            NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2TEXBLT, (*ppCommands)->wStateCount, 0);
                            dbgTracePop();
                            return (DDERR_GENERIC);
                        }
                        pDstObj = pDstObj->getAttachedA();
                    }

                    pSrcObj = pSrcObj->getAttachedA();

                    // terminate if we have reached the end of either mipmap chain
                    if (!pSrcObj || !pDstObj) break;

                    // according to MS, this is the algorithm we're supposed to use
                    // for coming up with the next rectangle. originally i was just doing
                    // a plain >> 1. the ++ changes the degeneration of rects and keeps
                    // them from ever going to zero. (in other words, we always update the
                    // 1x1 mipmap, no matter what sub-rect we started with.)
                    rectSrc.top    >>= 1;
                    rectSrc.left   >>= 1;
                    rectSrc.bottom ++;
                    rectSrc.bottom >>= 1;
                    rectSrc.right  ++;
                    rectSrc.right  >>= 1;

                    pointDst.x     >>= 1;
                    pointDst.y     >>= 1;
                }
            }
        }
#ifdef TEX_MANAGE
        // whith driver managed textures enabled, a NULL dest handle means load src texture into video memory
        else {
            CTexture* pTexture = nvGetObjectFromHandle (pContext->dwDDLclID, pTexBltData->dwDDSrcSurface)->getTexture();
            nvAssert (pTexture);
            if (pTexture->isManaged()) {
                // if the texture is in system memory, we have to bring it into video or AGP
                if (pTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_SYS) {
                    BOOL bSuccess = nvTexManageFetch (pContext, pTexture);
                    nvAssert (bSuccess);
                }
                else {
                    // just make a note of the fact that we've touched this texture
                    nvTexManageTouch (pContext, pTexture->getBaseTexture());
                }
            }
        }
#endif

        // next blit
        pTexBltData++;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2TEXBLT, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_2D);

    dbgTracePop();
    DDENDTICK(SURF7_TEXTUREBLIT);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2StateSet (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT retval;
    LPD3DHAL_DP2STATESET pStateSetOp = (LPD3DHAL_DP2STATESET)((*ppCommands) + 1);

    DDSTARTTICK(DEVICE7_STATESET);
    dbgTracePush ("nvDP2StateSet");

#ifdef DEBUG
    static int iNestDepth = 0;
#endif

    switch (pStateSetOp->dwOperation) {
        case D3DHAL_STATESETBEGIN:
#ifdef DEBUG
            iNestDepth++;
            DPF_LEVEL(NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetBegin (%d)",iNestDepth);
            nvAssert (iNestDepth == 1); // state blocks cannot be nested
#endif
            retval = stateSetBegin (pContext, pStateSetOp->dwParam);
            break;
        case D3DHAL_STATESETEND:
#ifdef DEBUG
            DPF_LEVEL (NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetEnd (%d)",iNestDepth);
            iNestDepth--;
#endif
            retval = stateSetEnd (pContext);
            break;
        case D3DHAL_STATESETDELETE:
            DPF_LEVEL (NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetDelete");
            retval = stateSetDelete (pContext, pStateSetOp->dwParam);
            break;
        case D3DHAL_STATESETEXECUTE:
            DPF_LEVEL (NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetExecute");
            retval = stateSetExecute (pContext, pStateSetOp->dwParam);
            break;
        case D3DHAL_STATESETCAPTURE:
            DPF_LEVEL (NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetCapture");
            retval = stateSetCapture (pContext, pStateSetOp->dwParam);
            break;
        case D3DHAL_STATESETCREATE:
            DPF_LEVEL (NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetCreate");
            retval = stateSetCreate (pContext, pStateSetOp->dwParam, pStateSetOp->sbType);
            break;
        default:
            DPF ("unhandled / unknown stateset operation");
            dbgD3DError();
            retval = DDERR_INVALIDPARAMS;
            break;
    }

    if (retval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: DP2OP_STATESET failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2STATESET, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    DDENDTICK(DEVICE7_STATESET);
    return (retval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetPriority (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETPRIORITY   pDp2PriorityData;
    DWORD                     i;

    DDSTARTTICK(SURF7_SETPRIORITY);
    dbgTracePush ("nvDP2SetPriority");

    pDp2PriorityData = (LPD3DHAL_DP2SETPRIORITY)((*ppCommands)+1);

    for (i=0; i<(*ppCommands)->wStateCount; i++) {
        CNvObject *pObj = nvGetObjectFromHandle (pContext->dwDDLclID, pDp2PriorityData->dwDDSurface, &global.pNvSurfaceLists);
        CTexture  *pTexture = pObj->getTexture();
        assert (pTexture);
        pTexture->setPriority (pDp2PriorityData->dwPriority);
        pDp2PriorityData++;
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETPRIORITY, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(SURF7_SETPRIORITY);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetRenderTarget (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETRENDERTARGET pSRTData;
    HRESULT hr;

    DDSTARTTICK(DEVICE7_SETRENDERTARGET);
    dbgTracePush ("nvDP2SetRenderTarget");

    // Get new data by ignoring all but the last structure
    pSRTData = (LPD3DHAL_DP2SETRENDERTARGET)((*ppCommands) + 1) + ((*ppCommands)->wStateCount - 1);

    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }

    hr = nvSetRenderTargetDX7 (pContext, pSRTData->hRenderTarget, pSRTData->hZBuffer);

    //AA Fix -- when we do a Flip for AA we traverse the pcontext list to execute the flip on the
    //proper super buffers.  Sometimes we have apps that have multiple pcontexts pointing to
    //the rendertargets.  When we do the lookup in the flip -- we get the first one in the list,
    //rather than 'current' one.  In an attempt to make them match anytime the SRT target is
    //set move the pcontext to the head of that list.  Ideally we should only ever do this once.
    PNVD3DCONTEXT pHead = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    if (pContext != pHead) {
        pContext->pContextPrev->pContextNext = pContext->pContextNext;
        if (pContext->pContextNext) {
            pContext->pContextNext->pContextPrev = pContext->pContextPrev;
        }
        pContext->pContextPrev = NULL;
        pContext->pContextNext = pHead;
        pHead->pContextPrev = pContext;

        (PNVD3DCONTEXT)getDC()->dwContextListHead =pContext;
    }

    if (hr != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2SetRenderTarget failed");
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETRENDERTARGET, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETRENDERTARGET);
    return (hr);
}

//---------------------------------------------------------------------------

// clear via DP2 token, valid post-DX7.
// basically this is just a wrapper for the old clear routines,
// serving to translate the new data structure to the old
// one before passing it on down.

HRESULT nvDP2Clear (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2CLEAR pDp2ClearData = (LPD3DHAL_DP2CLEAR)((*ppCommands)+1);
    D3DHAL_CLEAR2DATA c2d;
    D3DRECT rect;

    dbgTracePush ("nvDP2Clear");

    c2d.dwhContext = (DWORD) pContext;
    c2d.dwFlags = pDp2ClearData->dwFlags;
    c2d.dwFillColor = pDp2ClearData->dwFillColor;

#ifdef  NV_NULL_DRIVER_DYNAMIC_
    c2d.dwFlags |= D3DCLEAR_TARGET;
    c2d.dwFillColor = 0x818181; //Grey - to be able to see garbage
#endif //NV_NULL_DRIVER_DYNAMIC

    c2d.dvFillDepth = pDp2ClearData->dvFillDepth;
    c2d.dwFillStencil = pDp2ClearData->dwFillStencil;

    c2d.dwNumRects = (*ppCommands)->wStateCount;

    // only pay attention to this flag if there is no list (WHQL clear test)
    if ((c2d.dwNumRects == 0) && (c2d.dwFlags & D3DCLEAR_COMPUTERECTS)) {
        // assume we want to clear the entire rendertarget - this may need to be extended
        c2d.dwNumRects = 1;
        c2d.lpRects = &rect;
        rect.x1 = pContext->surfaceViewport.clipHorizontal.wX;
        rect.y1 = pContext->surfaceViewport.clipVertical.wY;
        rect.x2 = pContext->surfaceViewport.clipHorizontal.wWidth + rect.x1;
        rect.y2 = pContext->surfaceViewport.clipVertical.wHeight + rect.y1;
    } else {
        // yet another gratuitous change by MS requires translation.
        // for now we can get away with a cast because these two structures
        // happen to order things the same way. i hesitate to attribute
        // this to any intelligence on MS's part. if they ever whimsically
        // re-order the elements in either structure, we'll be screwed and
        // have to translate rectangle by rectangle, vertex by vertex.
        // compute clear rectangle if required
        c2d.lpRects = (LPD3DRECT) pDp2ClearData->Rects;
    }

    nvClear2 (&c2d);

    // put the rendering surface back to where it belongs since the DP2
    // clear may be interleaved with DP2 triangle rendering operations
    // is this really necessary?
    // nvSetD3DSurfaceState(pContext);

    if (c2d.ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2Clear failed");
    NEXTINSTRUCTION ((*ppCommands), RECT, (*ppCommands)->wStateCount-1, sizeof(D3DHAL_DP2CLEAR));

    dbgFlushType (NVDBG_FLUSH_2D);

    dbgTracePop();
    return (c2d.ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetTexLOD (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETTEXLOD pDp2TexLODData = (LPD3DHAL_DP2SETTEXLOD)((*ppCommands)+1);

    dbgTracePush ("nvDP2SetTexLOD");

    // nada for now
    DPF ("DP2SetTexLOD called. doing nothing");

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETTEXLOD, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetClipPlane (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETCLIPPLANE pDp2ClipPlaneData;
    DWORD                    count, index;
    D3DVALUE                 *pClipPlane;

    DDSTARTTICK(DEVICE7_SETCLIPPLANE);
    dbgTracePush ("nvDP2SetClipPlane");

    pDp2ClipPlaneData = (LPD3DHAL_DP2SETCLIPPLANE)((*ppCommands)+1);

    for (count=0; count<(*ppCommands)->wStateCount; count++) {

        index = pDp2ClipPlaneData->dwIndex;
        if (index > D3DMAXUSERCLIPPLANES) {
            DPF ("clipplane index %d exceeded D3DMAXUSERCLIPPLANES in nvDP2SetClipPlane", index);
            pDp2ClipPlaneData ++;
            continue;
        }

        pClipPlane = pContext->ppClipPlane[index];

        pClipPlane[0] = pDp2ClipPlaneData->plane[0];
        pClipPlane[1] = pDp2ClipPlaneData->plane[1];
        pClipPlane[2] = pDp2ClipPlaneData->plane[2];
        pClipPlane[3] = pDp2ClipPlaneData->plane[3];

        pDp2ClipPlaneData ++;

    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE;
#endif  // NVARCH >= 0x010

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETCLIPPLANE, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETCLIPPLANE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2StreamEnd (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2StreamEnd");
    *ppCommands = LPD3DHAL_DP2COMMAND(pCommandBufferEnd);
    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CreateVertexShader (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2CREATEVERTEXSHADER *lpCreateVShader;
    DWORD dwSize = 0;

    dbgTracePush ("nvDP2CreateVertexShader");

    for (DWORD count = 0; count < (*ppCommands)->wStateCount; count++)
    {
        lpCreateVShader = (D3DHAL_DP2CREATEVERTEXSHADER *)(lpPrim);

        // We should not be getting CreateVertexShader for FVFs.
        nvAssert( lpCreateVShader->dwHandle & 0x1 );

        if (lpCreateVShader->dwHandle & 0x1)
        {
    #ifndef WINNT
            //this is a hack cause I don't have a ddslcl to get a pid from here???
            //I don't get create calls like I do for surfaces and must lazily create
            //the shaders at the last moment.  Make it match the context's PID.
            CNvObject *pObj = new CNvObject (pContext->pid);
    #else
            CNvObject *pObj = new CNvObject (0);
    #endif
            CVertexShader *pVertexShader = new CVertexShader();

            // code vertex shader
            pVertexShader->create (pContext,
                                   lpCreateVShader->dwHandle,
                                   lpCreateVShader->dwDeclSize,
                                   lpCreateVShader->dwCodeSize,
                                   (DWORD *)((LPBYTE)lpCreateVShader + sizeof(D3DHAL_DP2CREATEVERTEXSHADER)),
                                   (DWORD *)((LPBYTE)lpCreateVShader + lpCreateVShader->dwDeclSize + sizeof(D3DHAL_DP2CREATEVERTEXSHADER)));

            pObj->setObject(CNvObject::NVOBJ_VERTEXSHADER, pVertexShader);
            PNV_OBJECT_LIST pNvList = nvFindObjectList(pContext->dwDDLclID, &global.pNvVShaderLists);
            nvAddObjectToList(pNvList, pObj, lpCreateVShader->dwHandle);
        }

        lpPrim += sizeof(D3DHAL_DP2CREATEVERTEXSHADER) +
                  lpCreateVShader->dwDeclSize +
                  lpCreateVShader->dwCodeSize;
        dwSize += lpCreateVShader->dwDeclSize +
                  lpCreateVShader->dwCodeSize;
    }

#ifdef KPFS
    pDriverData->nvKelvinPM.flush();
#endif
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2CREATEVERTEXSHADER, (*ppCommands)->wStateCount, dwSize);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DeleteVertexShader (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2VERTEXSHADER *lpDeleteVShader = (D3DHAL_DP2VERTEXSHADER *)(lpPrim);

    dbgTracePush ("nvDP2DeleteVertexShader");

    for (DWORD count = 0; count < (*ppCommands)->wStateCount; count++)
    {
        CNvObject *pNvObj;

        // We should not be getting DeleteVertexShader for FVFs.
        nvAssert( lpDeleteVShader->dwHandle & 0x1 );

        if( lpDeleteVShader->dwHandle & 0x1 )
        {
            pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, lpDeleteVShader->dwHandle, &global.pNvVShaderLists);

            // check if this is the active vertex shader
            if (pContext->pCurrentVShader == pNvObj->getVertexShader())
            {
                // restore the default vertex shader
                CNvObject *pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, 0, &global.pNvVShaderLists);
                pContext->pCurrentVShader = pNvObj->getVertexShader();
            }

            // delete it
            nvClearObjectListEntry(pNvObj, &global.pNvVShaderLists);
            pNvObj->release();
        }

        // next shader
        lpDeleteVShader++;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2VERTEXSHADER, (*ppCommands)->wStateCount,0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetVertexShader (NV_DP2FUNCTION_ARGLIST)
{
    DWORD count;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD dwHandle       = ((LPD3DHAL_DP2VERTEXSHADER)lpPrim)->dwHandle;
    CVertexShader *pVertexShader;
#if STATE_OPTIMIZE
    CVertexShader *pPrevVertexShader;
#endif

    dbgTracePush ("nvDP2SetVertexShader");

    // if we get a handle of 0 -- unbind the current vertex shader
    if (dwHandle == 0)
    {
        // the default shader (handle 0) was created in nvContextCreate
        CNvObject *pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, 0, &global.pNvVShaderLists);
        pContext->pCurrentVShader = pNvObj->getVertexShader();
        pContext->pCurrentVShader->reset();
        NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2VERTEXSHADER, (*ppCommands)->wStateCount,0);
        dbgTracePop();
        return (D3D_OK);
    }

    //since we can't have more than one active shader, spin through list to the last one
    for (count = 1; count<(*ppCommands)->wStateCount; count++, lpPrim += sizeof(D3DHAL_DP2VERTEXSHADER));
    CNvObject *pNvObj;

    if (dwHandle & 0x1)
    {
        pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, dwHandle, &global.pNvVShaderLists);

        // code vertex shader
        nvAssert(pNvObj);
        pVertexShader = pNvObj->getVertexShader();
        nvAssert(pVertexShader);

        if (pVertexShader->hasConstants()) {
            nvAssert(pContext->pVShaderConsts);
            // copy the constants from the shader to the context storage
            for (int i=0; i < D3DVS_CONSTREG_MAX_V1_1;) {
                char numConsts = pVertexShader->m_numConsts[i];
                if (numConsts) {
                    VSHADERREGISTER *pConst = &pVertexShader->m_vertexShaderConstants[i];
#ifdef DEBUG
                    // debug stuff
                    for (char j=0; j < numConsts; j++) {
                        DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "Set const from VS [%d] = (%f, %f, %f, %f)",
                                   i+j, pConst[j].x, pConst[j].y, pConst[j].z, pConst[j].w);
                    }
#endif
                    memcpy (&(pContext->pVShaderConsts->vertexShaderConstants[i]),
                            pConst, numConsts * sizeof(VSHADERREGISTER));
                    i += numConsts;
                }
                else {
                    i ++;
                }
            }
        }

#ifdef DEBUG
        if (pVertexShader->hasProgram()) {
            DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "Set Vertex Shader %02d", dwHandle);
            for (DWORD dwReg = 0; dwReg < 16; dwReg++) {
                if (pVertexShader->bVAExists(dwReg)) {
                    DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "reg: %02d , stream: %02d, type: %d, offset %02x, src: %x, flag: %d",
                               dwReg, pVertexShader->getVAStream(dwReg), pVertexShader->getVAType(dwReg),
                               pVertexShader->getVAOffset(dwReg), pVertexShader->getVASrc(dwReg), pVertexShader->getVAFlag(dwReg));
                }
            }
        }
#endif

    }
    else {
        // The handle is actually an FVF. We don't want to use an FVF as a handle,
        // because numerically they can get quite large.
        DWORD dwFVF = dwHandle;

        dwHandle = CVertexShader::getHandleFromFvf( dwFVF );
        pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, dwHandle, &global.pNvVShaderLists);

        // create an FVF vertex shader if it doesn't already exist
        if (pNvObj == NULL) {
#ifndef WINNT
            pNvObj = new CNvObject (pContext->pid);
#else
            pNvObj = new CNvObject (0);
#endif
            pVertexShader = new CVertexShader();
            pVertexShader->create (pContext, dwFVF, dwHandle);
            pNvObj->setObject (CNvObject::NVOBJ_VERTEXSHADER, pVertexShader);
            PNV_OBJECT_LIST pNvList = nvFindObjectList (pContext->dwDDLclID, &global.pNvVShaderLists);
            nvAddObjectToList (pNvList, pNvObj, dwHandle);
        }
        else
        { // Just temporary until the hash stuff works.
            pVertexShader = pNvObj->getVertexShader();
            pVertexShader->create (pContext, dwFVF, dwHandle);
        }
    }

    nvAssert(pNvObj != NULL);

#if STATE_OPTIMIZE
    // TODO: (SK) This may be a bit conservative -- we may not need to check the previous
    // vertex shader
    pPrevVertexShader = pContext->pCurrentVShader;
#endif

    pContext->pCurrentVShader = pVertexShader;
    pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, NV_CAPS_MAX_STREAMS);

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        DWORD dwPTFlag = (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader)) ? KELVIN_FLAG_PASSTHROUGHMODE : 0;

#if STATE_OPTIMIZE
        // TODO: (SK) This may be a bit conservative -- we may not need to check the previous
        // vertex shader
        if (pContext->pCurrentVShader->hasProgram() || pPrevVertexShader->hasProgram())
        {
            // TODO: (SK) Do we really need all this state?
            pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_PASSTHROUGHMODE;
            pContext->hwState.dwStateFlags |= dwPTFlag;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_SPECFOG
                                           |  KELVIN_DIRTY_VERTEX_SHADER
                                           |  KELVIN_DIRTY_FVF
                                           |  KELVIN_DIRTY_LIGHTS
                                           |  KELVIN_DIRTY_TRANSFORM
                                           |  KELVIN_DIRTY_MISC_STATE;
        }
        else
        {
            pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_PASSTHROUGHMODE;
            pContext->hwState.dwStateFlags |= dwPTFlag;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_VERTEX_SHADER
                                           |  KELVIN_DIRTY_FVF
                                           |  KELVIN_DIRTY_TRANSFORM;           //wish I didn't have to set this...

        }
#else
        pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_PASSTHROUGHMODE;
        pContext->hwState.dwStateFlags |= dwPTFlag;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_SPECFOG
                                       |  KELVIN_DIRTY_VERTEX_SHADER
                                       |  KELVIN_DIRTY_FVF
                                       |  KELVIN_DIRTY_LIGHTS
                                       |  KELVIN_DIRTY_TRANSFORM
                                       |  KELVIN_DIRTY_MISC_STATE;
#endif

    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        DWORD dwPTFlag = (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader)) ? CELSIUS_FLAG_PASSTHROUGHMODE : 0;
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_PASSTHROUGHMODE;
        pContext->hwState.dwStateFlags |= dwPTFlag;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE
                                       |  CELSIUS_DIRTY_FVF
                                       |  CELSIUS_DIRTY_TRANSFORM
                                       |  CELSIUS_DIRTY_CONTROL0
                                       |  CELSIUS_DIRTY_SPECFOG_COMBINER;
    }
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2VERTEXSHADER, (*ppCommands)->wStateCount,0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetVertexShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETVERTEXSHADERCONST *lpSetVShaderConst;
    DWORD   dwExtraBytes=0,count;

    dbgTracePush ("nvDP2SetVertexShaderConst");


    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        lpSetVShaderConst = (D3DHAL_DP2SETVERTEXSHADERCONST *)(lpPrim);
        VSHADERREGISTER *pConst = (VSHADERREGISTER*)(lpPrim + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST));
    
        nvAssert((lpSetVShaderConst->dwRegister + lpSetVShaderConst->dwCount) <= D3DVS_CONSTREG_MAX_V1_1);
        nvAssert(pContext->pVShaderConsts);

#ifdef DEBUG
        // debug stuff
        for (DWORD i = 0; i < lpSetVShaderConst->dwCount; i++)
        {
            DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "Set VS const [%d] = (%f, %f, %f, %f)",
                       lpSetVShaderConst->dwRegister + i, pConst[i].x, pConst[i].y, pConst[i].z, pConst[i].w);
        }
#endif
    
        memcpy (&(pContext->pVShaderConsts->vertexShaderConstants[lpSetVShaderConst->dwRegister]),
                pConst, lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER));
        
        dwExtraBytes += lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER);   
        
        lpPrim += (lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER) ) + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST);
    }
#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) 
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_VERTEX_SHADER;
    }
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETVERTEXSHADERCONST, (*ppCommands)->wStateCount, dwExtraBytes);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CreatePixelShader (NV_DP2FUNCTION_ARGLIST)
{
    D3DHAL_DP2CREATEPIXELSHADER *lpCreatePShader;
    CNvObject      *pObj;
    CPixelShader   *pPShader;
    WORD            wCount;
    LPBYTE          lpPrim  = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    PNV_OBJECT_LIST pNvList = nvFindObjectList(pContext->dwDDLclID, &global.pNvPShaderLists);
    DWORD           dwSize  = 0;

    dbgTracePush ("nvDP2CreatePixelShader");

    for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++)
    {
        lpCreatePShader = (D3DHAL_DP2CREATEPIXELSHADER *)(lpPrim);
#ifndef WINNT
        //this is a hack cause I don't have a ddslcl to get a pid from here???
        //I don't get create calls like I do for surfaces and must lazily create
        //the palette surfaces at the last moment.  Make it match the surfaces PID.
        pObj  =  new CNvObject (pContext->pid);
#else
        pObj  =  new CNvObject (0);
#endif
        pPShader = new CPixelShader();
        pPShader->create (pContext, lpCreatePShader->dwHandle,lpCreatePShader->dwCodeSize, (DWORD *)(lpPrim+sizeof(D3DHAL_DP2CREATEPIXELSHADER) ));
        pObj->setObject (CNvObject::NVOBJ_PIXELSHADER, pPShader);

        nvAddObjectToList(pNvList ,pObj, lpCreatePShader->dwHandle);
        lpPrim += sizeof(D3DHAL_DP2CREATEPIXELSHADER) +
        lpCreatePShader->dwCodeSize;
        dwSize += lpCreatePShader->dwCodeSize;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2CREATEPIXELSHADER, (*ppCommands)->wStateCount, dwSize );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DeletePixelShader (NV_DP2FUNCTION_ARGLIST)
{

    WORD   wCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2PIXELSHADER *lpDeletePShader = (D3DHAL_DP2PIXELSHADER *)(lpPrim);

    dbgTracePush ("nvDP2DeletePixelShader");

    for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++)
    {
        CNvObject *pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, lpDeletePShader->dwHandle, &global.pNvPShaderLists);
        nvClearObjectListEntry(pNvObj, &global.pNvPShaderLists);
        pNvObj->release();
        lpDeletePShader++;
    }
    //need to make sure it isn't active Pixel Shader...
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2PIXELSHADER, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetPixelShader (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    pContext->pLastPShader = pContext->pCurrentPShader;

    dbgTracePush ("nvDP2SetPixelShader");

    DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "nvDP2SetPixelShader: handle=%d", ((LPD3DHAL_DP2PIXELSHADER)lpPrim)->dwHandle);

    for (wCount=1; wCount<(*ppCommands)->wStateCount; wCount++,lpPrim += sizeof(D3DHAL_DP2PIXELSHADER) );

    if (((LPD3DHAL_DP2PIXELSHADER)lpPrim)->dwHandle) {
        CNvObject *pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, ((LPD3DHAL_DP2PIXELSHADER)lpPrim)->dwHandle, &global.pNvPShaderLists);
        pContext->pCurrentPShader = pNvObj->getPixelShader();

    } else if (pContext->pCurrentPShader) {
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_REALLY_FILTHY;
        } else
#endif
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_REALLY_FILTHY;
            }
#endif

        pContext->pCurrentPShader = 0;
    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_PIXEL_SHADER;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_PIXEL_SHADER;
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2PIXELSHADER, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetStreamSource (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE                     lpPrim         = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETSTREAMSOURCE *lpStreamSource = (D3DHAL_DP2SETSTREAMSOURCE *)(lpPrim);
    WORD                       wCount;
    CNvObject                 *pObj;
#if STATE_OPTIMIZE
    bool                       bChanged       = false;
#endif

    dbgTracePush ("nvDP2SetStreamSource");

    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if (pContext->dwHWUnlockAllPending) { //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }

    for (wCount=0; wCount< (*ppCommands)->wStateCount; wCount++)
    {
        if (lpStreamSource->dwVBHandle && (lpStreamSource->dwStream < 16)) //temporary check to avoid pixelshader bug
        {
            pObj = nvGetObjectFromHandle (pContext->dwDDLclID, lpStreamSource->dwVBHandle, &global.pNvSurfaceLists);
            if (pContext->ppDX8Streams[lpStreamSource->dwStream] != pObj->getVertexBuffer() ||
                pContext->ppDX8Streams[lpStreamSource->dwStream] &&
                pContext->ppDX8Streams[lpStreamSource->dwStream]->getVertexStride() != lpStreamSource->dwStride
                )
            {
            pContext->ppDX8Streams[lpStreamSource->dwStream] = pObj->getVertexBuffer();
            pContext->ppDX8Streams[lpStreamSource->dwStream]->setVertexStride(lpStreamSource->dwStride);

            DPF_LEVEL(NVDBG_LEVEL_INFO,
            "SetStreamSource Stream: [%d] Handle: %d VB:%08x (%08x)", lpStreamSource->dwStream,
                      lpStreamSource->dwVBHandle,
                      (DWORD)(pContext->ppDX8Streams[lpStreamSource->dwStream]),
                      pContext->ppDX8Streams[lpStreamSource->dwStream]->getAddress());
#if STATE_OPTIMIZE
            bChanged = true;
#endif
           }
#ifdef DEBUG
            else {
                nvAssert(pContext->ppDX8Streams[lpStreamSource->dwStream]->getVertexStride() == lpStreamSource->dwStride);
#if STATE_OPTIMIZE
                bChanged = true;
#endif
            }
#endif

        }
        else
        {
            // invalidate streams
            pContext->ppDX8Streams[lpStreamSource->dwStream] = 0;
        }
        lpStreamSource++;
    }

    pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, NV_CAPS_MAX_STREAMS);

    CVertexShader *pVertexShader = pContext->pCurrentVShader;
    CVertexBuffer *pVertexBuffer = pContext->ppDX8Streams[pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])];
    if (pVertexBuffer)
    {
        if (pVertexBuffer->isModified() && !pVertexBuffer->isDynamic()
            && (pVertexBuffer->getLockCount() == 1) && !pVertexBuffer->getSuperTriLookAsideBuffer())
        {
            // check more supertri criteria...
#ifdef MCFD
            if ((pVertexBuffer->hwCanRead())) {
#else
            if ((pVertexBuffer->getSurface()->hwCanRead())) {
#endif
                pVertexBuffer->prepareSuperTriLookAsideBuffer();
            }
        }
    }

#if (NVARCH >= 0x010)
#if STATE_OPTIMIZE
    if (bChanged)
    {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF
                                       | CELSIUS_DIRTY_LIGHTS
                                       | CELSIUS_DIRTY_TEXTURE_STATE
                                       | CELSIUS_DIRTY_TEXTURE_TRANSFORM;

        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF
                                       | KELVIN_DIRTY_TEXTURE_TRANSFORM;

        if (pContext->dwRenderState[D3DRENDERSTATE_COLORVERTEX])
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_LIGHTS;

// (SK) These two may need to be set, mainly DIRTY_TEXTURE_STATE. If the
// texture state finds that dwNumTexCoordsNeeded != pContext->hwState.dwNumTexCoordsNeeded
// or
// pContext->hwState.dwTexCoordIndices != dwTexCoordIndices, it sets
// KELVIN_DIRTY_FVF. But we set that bit above anyway...

//             pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE;

    }
#else
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF
                                   | CELSIUS_DIRTY_LIGHTS
                                   | CELSIUS_DIRTY_TEXTURE_STATE
                                   | CELSIUS_DIRTY_TEXTURE_TRANSFORM;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF
                                   | KELVIN_DIRTY_LIGHTS
                                   | KELVIN_DIRTY_TEXTURE_STATE
                                   | KELVIN_DIRTY_TEXTURE_TRANSFORM;
#endif
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETSTREAMSOURCE, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetStreamSourceUM (NV_DP2FUNCTION_ARGLIST)
{
    WORD                         wCount;
    LPBYTE                       lpPrim           = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETSTREAMSOURCEUM *lpStreamSourceUM = (D3DHAL_DP2SETSTREAMSOURCEUM *)(lpPrim);

    dbgTracePush ("nvDP2SetStreamSourceUM");

    //this sets a certain stream to use the passed in pointer for it's data
    //this information is not persistant across DP2 calls, so we can just use the "disposible" VB

    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }
    for (wCount=0; wCount< (*ppCommands)->wStateCount; wCount++,lpStreamSourceUM++)
    {
        pContext->ppDX8Streams[lpStreamSourceUM->dwStream] = getDC()->defaultSysVB.getVB();
        pContext->ppDX8Streams[lpStreamSourceUM->dwStream]->setVertexStride(lpStreamSourceUM->dwStride);

        //BUG! this COULD cause a problem.  If the user ever passed in AGP or video memory (impossible currently)
        // we would calculate the surface offset incorrectly in the nvsurface.h.  Since this is guaranteed to be
        // user accessible system memory, as of 5/31/00, we are safe.
        //but this could cause a memory leak/clean-up issue.  I'll check HMH.
        pContext->ppDX8Streams[lpStreamSourceUM->dwStream]->own ((DWORD)pContext->pVertexDataUM,
                                                                 pContext->dwVertexDataLengthUM,
                                                                 CSimpleSurface::HEAP_SYS);

    }

    pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, NV_CAPS_MAX_STREAMS);

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF
                                   | CELSIUS_DIRTY_LIGHTS
                                   | CELSIUS_DIRTY_TEXTURE_STATE
                                   | CELSIUS_DIRTY_TEXTURE_TRANSFORM;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF
                                   | KELVIN_DIRTY_LIGHTS
                                   | KELVIN_DIRTY_TEXTURE_STATE
                                   | KELVIN_DIRTY_TEXTURE_TRANSFORM;
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETSTREAMSOURCEUM, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetIndices (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE     lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    CNvObject *pObj;
    WORD       wCount;

    dbgTracePush ("nvDP2SetIndices");

    for (wCount=1; wCount<(*ppCommands)->wStateCount; wCount++,lpPrim += sizeof(D3DHAL_DP2SETINDICES) );
    if (((LPD3DHAL_DP2SETINDICES)lpPrim)->dwVBHandle > 0 )
    {
        pObj = nvGetObjectFromHandle (pContext->dwDDLclID, ((LPD3DHAL_DP2SETINDICES)lpPrim)->dwVBHandle, &global.pNvSurfaceLists );
#if (NVARCH >= 0x010)
        pContext->pIndexBuffer = pObj->getVertexBuffer();
        pContext->pIndexBuffer->setVertexStride(((LPD3DHAL_DP2SETINDICES)lpPrim)->dwStride);
#endif
    }
    else
    {
        //better not use indexed prims
#if (NVARCH >= 0x010)
        pContext->pIndexBuffer = NULL;
#endif
    }
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETINDICES, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawPrimitive (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE                    lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2DRAWPRIMITIVE lpDPCommand = (LPD3DHAL_DP2DRAWPRIMITIVE)(lpPrim);
    WORD                      wCount;

    static DWORD PrimTypeToDP2[] = {
        0,
        D3DDP2OP_POINTS,
        D3DDP2OP_LINELIST,
        D3DDP2OP_LINESTRIP,
        D3DDP2OP_TRIANGLELIST,
        D3DDP2OP_TRIANGLESTRIP,
        D3DDP2OP_TRIANGLEFAN
    };

    dbgTracePush ("nvDP2DrawPrimitive");

    pContext->dp2.dwVertexBufferOffset = 0;
#if WINNT
    global.dwMaxVertexOffset = 0xFFFFFFFF;  // temp, need to fix for WHQL HMH
#endif

    CVertexShader *pVertexShader = pContext->pCurrentVShader;

    // If the last call to SetVertexShader passed in a handle of 0, we can't draw anything.
    nvAssert( pVertexShader->getHandle() || pVertexShader->getFVF() );
    // The FVF shader needs to have a non-null stream 0.
    nvAssert( !pVertexShader->isFvfShader() || (pContext->ppDX8Streams[0] != NULL) );

    if( (pContext->pCurrentVShader->getHandle() || pContext->pCurrentVShader->getFVF() ) &&
        (!pVertexShader->isFvfShader() || (pContext->ppDX8Streams[0] != NULL))  )
    {
        for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++,lpDPCommand++)
        {
            pContext->dp2.dwDP2Prim     = PrimTypeToDP2[lpDPCommand->primType];
            pContext->dp2.dwVStart      = lpDPCommand->VStart;
            pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
            pContext->dp2.dwIndices     = NULL;
            pContext->dp2.dwIndexStride = 0;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                nvKelvinDispatchNonIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
            } else
#endif
#if (NVARCH >= 0x010)
            {
                // force Celsius Vertex Shaders into inline inner loops
                nvCelsiusDispatchNonIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
            }
#endif
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWPRIMITIVE, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawIndexedPrimitive (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE                           lpPrim      = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE lpDPCommand = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)(lpPrim);
    WORD                             wCount;

    static DWORD PrimTypeToDP2[] = {
        0,
        D3DDP2OP_POINTS,  //this should work since stride etc is the same.... HMH
        D3DDP2OP_INDEXEDLINELIST,
        D3DDP2OP_INDEXEDLINESTRIP,
        D3DDP2OP_INDEXEDTRIANGLELIST2,
        D3DDP2OP_INDEXEDTRIANGLESTRIP,
        D3DDP2OP_INDEXEDTRIANGLEFAN
    };

    dbgTracePush ("nvDP2DrawIndexedPrimitive");

    pContext->dp2.dwVertexBufferOffset = 0;

#if WINNT
    global.dwMaxVertexOffset = 0xFFFFFFFF;  //temp, need to fix for WHQL HMH
#endif

    CVertexShader *pVertexShader = pContext->pCurrentVShader;

    // If the last call to SetVertexShader passed in a handle of 0, we can't draw anything.
    nvAssert( pVertexShader->getHandle() || pVertexShader->getFVF() );
    // The FVF shader needs to have a non-null stream 0.
    nvAssert( !pVertexShader->isFvfShader() || (pContext->ppDX8Streams[0] != NULL) );

    if( (pContext->pCurrentVShader->getHandle() || pContext->pCurrentVShader->getFVF() ) &&
        (!pVertexShader->isFvfShader() || (pContext->ppDX8Streams[0] != NULL))  )
    {
        for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++,lpDPCommand++)
        {
            pContext->dp2.dwDP2Prim     = PrimTypeToDP2[lpDPCommand->primType];
            pContext->dp2.dwVStart      = lpDPCommand->BaseVertexIndex;
            pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
            pContext->dp2.dwIndices     = pContext->pIndexBuffer->getAddress() + pContext->pIndexBuffer->getVertexStride()*lpDPCommand->StartIndex;
            pContext->dp2.dwIndexStride = pContext->pIndexBuffer->getVertexStride();

#ifdef NV_PROFILE_DP2OPS
            pDriverData->pBenchmark->logDrawPrimitive((WORD)lpDPCommand->PrimitiveCount);
#endif

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                nvKelvinDispatchIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
            } else
#endif
#if (NVARCH >= 0x010)
            {
                nvCelsiusDispatchIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
            }
#endif
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWINDEXEDPRIMITIVE, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetPixelShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD dwExtraBytes=0,count;
    
    dbgTracePush ("nvDP2SetPixelShaderConst");

    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        LPD3DHAL_DP2SETPIXELSHADERCONST lpConstInfo = (D3DHAL_DP2SETPIXELSHADERCONST *)(lpPrim);
        D3DCOLORVALUE *lpConsts = (D3DCOLORVALUE *)(lpPrim + sizeof(D3DHAL_DP2SETPIXELSHADERCONST) );

        for (DWORD i=0; i<lpConstInfo->dwCount; i++) {
            DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "nvDP2SetPixelShaderConst: idx=%d, a=%f, r=%f, g=%f, b=%f",
                      lpConstInfo->dwRegister+i, lpConsts[i].a, lpConsts[i].r, lpConsts[i].g, lpConsts[i].b);
            pContext->pixelShaderConsts[lpConstInfo->dwRegister+i] = lpConsts[i];
        }
        lpPrim += 4*4*lpConstInfo->dwCount + sizeof(D3DHAL_DP2SETPIXELSHADERCONST);
        dwExtraBytes += 4*4*lpConstInfo->dwCount;
    }
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_PIXEL_SHADER;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_PIXEL_SHADER;
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETPIXELSHADERCONST, (*ppCommands)->wStateCount, dwExtraBytes );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2ClippedTriangleFan (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    WORD   wCount;

    dbgTracePush ("nvDP2ClippedTriangleFan");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;
    pContext->dp2.dwVStart      = 0;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#if WINNT
    global.dwMaxVertexOffset = 0xFFFFFFFF;  // temp, need to fix for WHQL HMH
#endif

    for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++)
    {
        pContext->dp2.dwVertexBufferOffset = ((LPD3DHAL_CLIPPEDTRIANGLEFAN)lpPrim)->FirstVertexOffset;
        pContext->dp2.dwEdgeFlags          = ((LPD3DHAL_CLIPPEDTRIANGLEFAN)lpPrim)->dwEdgeFlags;

#if (NVARCH >= 0x20)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            // if we're in wireframe mode, we have to heed edge flags...
            ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
                nvKelvinDispatchLegacyWireframePrimitive :
                nvKelvinDispatchNonIndexedPrimitive) (pContext, ((LPD3DHAL_CLIPPEDTRIANGLEFAN)lpPrim)->PrimitiveCount);
        }
        else
#endif
#if (NVARCH >= 0x10)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            // force Celsius Vertex Shaders into inline inner loops
            // if we're in wireframe mode, we have to heed edge flags...
            ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
                nvCelsiusDispatchLegacyWireframePrimitive :
                nvCelsiusDispatchNonIndexedPrimitive) (pContext, ((LPD3DHAL_CLIPPEDTRIANGLEFAN)lpPrim)->PrimitiveCount);
        }
#endif

        lpPrim += sizeof (D3DHAL_CLIPPEDTRIANGLEFAN);
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_CLIPPEDTRIANGLEFAN, (*ppCommands)->wStateCount, 0 );

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawPrimitive2 (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE                     lpPrim      = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2DRAWPRIMITIVE2 lpDPCommand = (LPD3DHAL_DP2DRAWPRIMITIVE2)(lpPrim);
    WORD                       wCount;

    static DWORD PrimTypeToDP2[] = {
        0,
        D3DDP2OP_POINTS,
        D3DDP2OP_LINELIST,
        D3DDP2OP_LINESTRIP,
        D3DDP2OP_TRIANGLELIST,
        D3DDP2OP_TRIANGLESTRIP,
        D3DDP2OP_TRIANGLEFAN
    };

    dbgTracePush ("nvDP2DrawPrimitive2");

    pContext->dp2.dwVStart             = 0;

#if WINNT
    global.dwMaxVertexOffset = 0xFFFFFFFF;  //temp, need to fix for WHQL HMH
#endif

    for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++,lpDPCommand++)
    {
        pContext->dp2.dwDP2Prim            = PrimTypeToDP2[lpDPCommand->primType];
        pContext->dp2.dwVertexBufferOffset = lpDPCommand->FirstVertexOffset;
        pContext->dp2.dwTotalOffset        = pContext->dp2.dwVertexBufferOffset;
        pContext->dp2.dwIndices            = NULL;
        pContext->dp2.dwIndexStride        = 0;

#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            nvKelvinDispatchNonIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
        } else
#endif
#if (NVARCH >= 0x010)
        {
            nvCelsiusDispatchNonIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
        }
#endif
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWPRIMITIVE2, (*ppCommands)->wStateCount, 0 );

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawIndexedPrimitive2 (NV_DP2FUNCTION_ARGLIST)
{

    LPBYTE                            lpPrim      = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 lpDPCommand = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)(lpPrim);
    WORD                              wCount;

    static DWORD PrimTypeToDP2[] = {
        0,
        D3DDP2OP_POINTS,  //this should work since stride etc is the same.... HMH
        D3DDP2OP_INDEXEDLINELIST,
        D3DDP2OP_INDEXEDLINESTRIP,
        D3DDP2OP_INDEXEDTRIANGLELIST2,
        D3DDP2OP_INDEXEDTRIANGLESTRIP,
        D3DDP2OP_INDEXEDTRIANGLEFAN
    };

    dbgTracePush ("nvDP2DrawIndexedPrimitive2");

    pContext->dp2.dwVStart             = 0;

#if WINNT
    global.dwMaxVertexOffset = 0xFFFFFFFF;  //temp, need to fix for WHQL HMH
#endif
    for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++,lpDPCommand++)
    {
        pContext->dp2.dwDP2Prim            = PrimTypeToDP2[lpDPCommand->primType];
        pContext->dp2.dwVertexBufferOffset = lpDPCommand->BaseVertexOffset;
        pContext->dp2.dwTotalOffset        = pContext->dp2.dwVertexBufferOffset;
        pContext->dp2.dwIndices            = pContext->pIndexBuffer->getAddress() + lpDPCommand->StartIndexOffset;
        pContext->dp2.dwIndexStride        = pContext->pIndexBuffer->getVertexStride();

#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            nvKelvinDispatchIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
        } else
#endif
#if (NVARCH >= 0x010)
        {
            // force Celsius Vertex Shaders into inline inner loops
            // bug bug maybe? BaseVertexOffset is supposed to be able to be negative.  Since it's an unsigned
            // int, I think this is pretty hard, but it could cause issues.
            nvCelsiusDispatchIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
        }
#endif
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWINDEXEDPRIMITIVE2, (*ppCommands)->wStateCount, 0 );

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawRectSurface (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2DrawRectSurface");
    WORD wNumDrawRect = (*ppCommands)->wStateCount;
    LPBYTE lpPrim     = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DWORD dwSize = 0;
    FLOAT *pfSegs = NULL;
    D3DRECTPATCH_INFO *pRSInfo = NULL;

    // this flag causes celsius state to compute a tessellator style vertex format
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        pContext->hwState.dwDirtyFlags  |= KELVIN_DIRTY_FVF;
        //TODO: make this smarter we are always forcing dirty now.  NOT good.
        nvSetKelvinState (pContext);
        //dirty FVF again so regular DP2 ops get reinitialized
        pContext->hwState.dwDirtyFlags  |= KELVIN_DIRTY_FVF;
    }
    else {
/*      pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
        //TODO: make this smarter we are always forcing dirty now.  NOT good.
        nvSetCelsiusState (pContext);
        //dirty FVF again so regular DP2 ops get reinitialized
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE;
        pContext->hwState.dwDirtyFlags  |= CELSIUS_DIRTY_FVF;*/
        return(D3D_OK);
    }

    for (int i = 0; i < wNumDrawRect; i++) {
        LPD3DHAL_DP2DRAWRECTPATCH lpRectSurface = (LPD3DHAL_DP2DRAWRECTPATCH)(lpPrim);
        lpPrim += sizeof(D3DHAL_DP2DRAWRECTPATCH);

        if(lpRectSurface->Flags & RTPATCHFLAG_HASSEGS){
            pfSegs = (FLOAT *)lpPrim;
            lpPrim += sizeof(FLOAT)*4;
            dwSize += sizeof(FLOAT)*4;
        }
        if(lpRectSurface->Flags & RTPATCHFLAG_HASINFO){
            pRSInfo = (D3DRECTPATCH_INFO *)lpPrim;
            lpPrim += sizeof(D3DRECTPATCH_INFO);
            dwSize += sizeof(D3DRECTPATCH_INFO);
        }

#ifdef HOSURF_ENABLE
        nvDrawRectSurface(pContext, lpRectSurface->Handle, pfSegs, pRSInfo);
#endif
        pfSegs = NULL;
        pRSInfo = NULL;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWRECTPATCH, (*ppCommands)->wStateCount, dwSize );

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawTriSurface (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2DrawTriSurface");

    WORD wNumDrawRect = (*ppCommands)->wStateCount;
    LPBYTE lpPrim     = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    //this flag causes celsius state to compute a tessellator style vertex format
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
        //TODO: make this smarter we are always forcing dirty now.  NOT good.
        nvSetKelvinState (pContext);
        //dirty FVF again so regular DP2 ops get reinitialized
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    }
    else
    {
/*        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
        //TODO: make this smarter we are always forcing dirty now.  NOT good.
        nvSetCelsiusState (pContext);
        //dirty FVF again so regular DP2 ops get reinitialized
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF; */
    return(D3D_OK);
    }

    DWORD dwSize = 0;
    FLOAT *pfSegs = NULL;
    D3DTRIPATCH_INFO *pTSInfo = NULL;
    for( int i = 0; i < wNumDrawRect; i++ ){
        LPD3DHAL_DP2DRAWTRIPATCH lpTriSurface = (LPD3DHAL_DP2DRAWTRIPATCH)(lpPrim);
        lpPrim += sizeof(D3DHAL_DP2DRAWTRIPATCH);

        if(lpTriSurface->Flags & RTPATCHFLAG_HASSEGS){
            pfSegs = (FLOAT *)lpPrim;
            lpPrim += sizeof(FLOAT)*3;
            dwSize += sizeof(FLOAT)*3;
        }
        if(lpTriSurface->Flags & RTPATCHFLAG_HASINFO){
            pTSInfo = (D3DTRIPATCH_INFO *)lpPrim;
            lpPrim += sizeof(D3DTRIPATCH_INFO);
            dwSize += sizeof(D3DTRIPATCH_INFO);
        }

        nvDrawTriSurface(pContext, lpTriSurface->Handle, pfSegs, pTSInfo); //-- not implemented yet

        pfSegs = NULL;
        pTSInfo = NULL;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWTRIPATCH, (*ppCommands)->wStateCount, dwSize );

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2VolumeBlt (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2VOLUMEBLT *lpBlitParam = (D3DHAL_DP2VOLUMEBLT *)(lpPrim);
    DWORD dwNumBlits = (*ppCommands)->wStateCount;

    dbgTracePush ("nvDP2VolumeBlit");

    for (DWORD i=0; i<dwNumBlits; i++) {

        if (lpBlitParam->dwDDDestSurface) {

            CNvObject* pSrcObj = nvGetObjectFromHandle (pContext->dwDDLclID, lpBlitParam->dwDDSrcSurface, &global.pNvSurfaceLists);
            CNvObject* pDstObj = nvGetObjectFromHandle (pContext->dwDDLclID, lpBlitParam->dwDDDestSurface, &global.pNvSurfaceLists);

            D3DBOX box = lpBlitParam->srcBox;
            DWORD dwDestX = lpBlitParam->dwDestX;
            DWORD dwDestY = lpBlitParam->dwDestY;
            DWORD dwDestZ = lpBlitParam->dwDestZ;

            while (1) {
                nvTextureBltDX7(pContext, pSrcObj, pDstObj, &box, dwDestX, dwDestY, dwDestZ, lpBlitParam->dwFlags);

                pSrcObj = pSrcObj->getAttachedA();

                pDstObj = pDstObj->getAttachedA();

                if (!pSrcObj || !pDstObj) break;

                box.Top    >>= 1;
                box.Left   >>= 1;
                box.Front  >>= 1;
                box.Bottom ++;
                box.Bottom >>= 1;
                box.Right  ++;
                box.Right  >>= 1;
                box.Back   ++;
                box.Back   >>= 1;

                dwDestX >>= 1;
                dwDestY >>= 1;
                dwDestZ >>= 1;
            }

            lpBlitParam++;
        }
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2VOLUMEBLT, (*ppCommands)->wStateCount, 0 );

    dbgFlushType (NVDBG_FLUSH_2D);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2BufferBlt (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2BUFFERBLT *lpBltData = (D3DHAL_DP2BUFFERBLT *)(lpPrim);
    BOOL bIsFullBlit;

    dbgTracePush ("nvDP2BufferBlit");

    //ASSUMPTIONS:
    //lpBltData->rSrc.Offset and lpBltData->rSrc.Size are byte quantities
    //src is a system memory vertexbuffer

    //QUESTION: What can be passed in dwFlags?

    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }

    CNvObject* pSrcObj = nvGetObjectFromHandle (pContext->dwDDLclID, lpBltData->dwDDSrcSurface, &global.pNvSurfaceLists);
    CNvObject* pDstObj = nvGetObjectFromHandle (pContext->dwDDLclID, lpBltData->dwDDDestSurface, &global.pNvSurfaceLists);
    bIsFullBlit = FALSE;

    //assert that pSrc exists and the requested blit does not exceed src size
    nvAssert (pSrcObj && pSrcObj->getVertexBuffer());
    DWORD dwSrcSize = pSrcObj->getVertexBuffer()->getSize();
    nvAssert (dwSrcSize >= lpBltData->rSrc.Offset+lpBltData->rSrc.Size);

    //assert that pDst exists and the requested blit does not exceed dst size
    nvAssert (pDstObj && pDstObj->getVertexBuffer());
    DWORD dwDstSize = pDstObj->getVertexBuffer()->getSize();
    if(dwDstSize == lpBltData->dwOffset) bIsFullBlit = TRUE;
    nvAssert (dwDstSize >= lpBltData->dwOffset + lpBltData->rSrc.Size);

    //blind memcpy for now.  With managed vertex buffers (which should always be on)
    //we aren't ever supposed to see this call.
    BYTE *pbSrc, *pbDst;
    pbSrc = (BYTE*)pSrcObj->getVertexBuffer()->getAddress();
    pbDst = (BYTE*)pDstObj->getVertexBuffer()->getAddress();

#ifdef MCFD
    pSrcObj->getVertexBuffer()->LockForCPU(CSimpleSurface::LOCK_READ);
#else
    pSrcObj->getVertexBuffer()->cpuLock(CSimpleSurface::LOCK_NORMAL);
#endif
    /*if(bIsFullBlit) pDstObj->getVertexBuffer()->cpuLock(CSimpleSurface::LOCK_RENAME);
    else*/

#ifdef MCFD
    pDstObj->getVertexBuffer()->LockForCPU(CSimpleSurface::LOCK_WRITE);
#else
    pDstObj->getVertexBuffer()->cpuLock(CSimpleSurface::LOCK_NORMAL);
#endif

    if(pbSrc == pbDst)
        //possible overlap use memmove.
        memmove(pbDst + lpBltData->dwOffset, pbSrc + lpBltData->rSrc.Offset, lpBltData->rSrc.Size);
    else
        memcpy(pbDst + lpBltData->dwOffset, pbSrc + lpBltData->rSrc.Offset, lpBltData->rSrc.Size);

#ifdef MCFD
    pSrcObj->getVertexBuffer()->UnlockForCPU();
    pDstObj->getVertexBuffer()->UnlockForCPU();
#else
    pSrcObj->getVertexBuffer()->cpuUnlock();
    pDstObj->getVertexBuffer()->cpuUnlock();
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2BUFFERBLT, 1, 0 );

    dbgFlushType (NVDBG_FLUSH_2D);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2MultiplyTransform (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2MULTIPLYTRANSFORM *lpMultTrans = (D3DHAL_DP2MULTIPLYTRANSFORM *)(lpPrim);
    D3DMATRIX Result;
    DWORD dwxfrmType   = (DWORD)lpMultTrans->xfrmType & (~0x80000000);
    DWORD dwStage;

    dbgTracePush ("nvDP2MultiplyTransform");

    switch (lpMultTrans->xfrmType) {

        case D3DTRANSFORMSTATE_WORLD_DX7:
        case D3DTS_WORLD:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmWorld[0]) );
            nvMemCopy (&(pContext->xfmWorld[0]), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TRANSFORM |
                                               CELSIUS_DIRTY_LIGHTS);
            pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TRANSFORM |
                                               KELVIN_DIRTY_LIGHTS);
#endif
            break;

        case D3DTRANSFORMSTATE_WORLD1_DX7:
        case D3DTS_WORLD1:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmWorld[1]) );
            nvMemCopy (&(pContext->xfmWorld[1]), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
            break;

        case D3DTRANSFORMSTATE_WORLD2_DX7:
        case D3DTS_WORLD2:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmWorld[2]) );
            nvMemCopy (&(pContext->xfmWorld[2]), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x020)
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
            break;

        case D3DTRANSFORMSTATE_WORLD3_DX7:
        case D3DTS_WORLD3:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmWorld[3]) );
            nvMemCopy (&(pContext->xfmWorld[3]), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x020)
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
            break;

        case D3DTRANSFORMSTATE_VIEW:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmView) );
            nvMemCopy (&(pContext->xfmView), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TEXTURE_STATE |
                                               CELSIUS_DIRTY_TRANSFORM |
                                               CELSIUS_DIRTY_LIGHTS);
            pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TEXTURE_STATE |
                                               KELVIN_DIRTY_TRANSFORM |
                                               KELVIN_DIRTY_LIGHTS);
#endif
            break;

        case D3DTRANSFORMSTATE_PROJECTION:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmProj) );
#ifdef  STEREO_SUPPORT
            if (STEREO_ENABLED)
            {

                Result = *(SetStereoProjection(&Result, pContext));
            }
#endif  //STEREO_SUPPORT
            nvMemCopy (&(pContext->xfmProj), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
            break;

        case D3DTRANSFORMSTATE_TEXTURE0:
        case D3DTRANSFORMSTATE_TEXTURE1:
        case D3DTRANSFORMSTATE_TEXTURE2:
        case D3DTRANSFORMSTATE_TEXTURE3:
        case D3DTRANSFORMSTATE_TEXTURE4:
        case D3DTRANSFORMSTATE_TEXTURE5:
        case D3DTRANSFORMSTATE_TEXTURE6:
        case D3DTRANSFORMSTATE_TEXTURE7:
            dwStage = lpMultTrans->xfrmType - D3DTRANSFORMSTATE_TEXTURE0;
            if (!( lpMultTrans->xfrmType & 0x80000000)) { //set identity??
                MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->tssState[dwStage].mTexTransformMatrix) );
                nvMemCopy (&pContext->tssState[dwStage].mTexTransformMatrix, &Result, sizeof(D3DMATRIX));
            }
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_TRANSFORM;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_TRANSFORM;
#endif
            break;

        default:
            DPF_LEVEL (NVDBG_LEVEL_INFO,"Ignoring unknown transform type in MultiplyXfrm");
            break;

    }  // switch (dwxfrmType)

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2MULTIPLYTRANSFORM, 1, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------
// DP2 Recording Functions
//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetRenderState (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetRenderState");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) + (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2RENDERSTATE);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordRenderState failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2RENDERSTATE, (*ppCommands)->wPrimitiveCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetTextureStageState (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetTextureStageState");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) + (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordTSS failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TEXTURESTAGESTATE, (*ppCommands)->wPrimitiveCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetViewport (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetViewport");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2VIEWPORTINFO));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordViewport failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2VIEWPORTINFO, 1, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetWRange (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetWRange");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2WINFO));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordWRange failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2WINFO, 1, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetZRange (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetZRange");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2ZRANGE));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordZRange failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2ZRANGE, (*ppCommands)->wStateCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetMaterial (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetMaterial");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2SETMATERIAL));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordMaterial failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETMATERIAL, (*ppCommands)->wStateCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetLight (NV_DP2FUNCTION_ARGLIST)
{
    WORD wNumSetLight;
    LPD3DHAL_DP2SETLIGHT pSetLight;
    DWORD i, dwStride, dwTotalStride;
    DWORD ddrval;

    dbgTracePush ("nvDP2RecordSetLight");

    wNumSetLight = (*ppCommands)->wStateCount;
    dwTotalStride = sizeof(D3DHAL_DP2COMMAND);
    pSetLight = (LPD3DHAL_DP2SETLIGHT)((*ppCommands) + 1);

    for (i=0; i<wNumSetLight; i++)
    {
        dwStride = sizeof (D3DHAL_DP2SETLIGHT);

        switch (SETLIGHT_DATATYPE(pSetLight)) {
            case D3DHAL_SETLIGHT_ENABLE:
                break;
            case D3DHAL_SETLIGHT_DISABLE:
                break;
            case D3DHAL_SETLIGHT_DATA:
                dwStride += sizeof(D3DLIGHT7);
                break;
        }

        dwTotalStride += dwStride;
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight + dwStride);
    }

    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwTotalStride);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordSetLight failed");
    (*ppCommands) = (LPD3DHAL_DP2COMMAND)((LPBYTE)(*ppCommands) + dwTotalStride);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetTransform (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetTransform");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2SETTRANSFORM);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordSetTransform failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETTRANSFORM, (*ppCommands)->wStateCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordExtension (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordExtension");

    DWORD ddrval = D3D_OK;
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2EXT, (*ppCommands)->wStateCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetClipPlane (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetClipPlane");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2SETCLIPPLANE);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordSetClipPlane failed");
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETCLIPPLANE, (*ppCommands)->wStateCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetVertexShader (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetVertexShader");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2VERTEXSHADER));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2RecordSetVertexShader failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2VERTEXSHADER, 1, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetVertexShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD ddrval,count ;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) ;
    D3DHAL_DP2SETVERTEXSHADERCONST *lpSetVShaderConst;


    dbgTracePush ("nvDP2RecordSetVertexShaderConst");

    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        lpSetVShaderConst = (D3DHAL_DP2SETVERTEXSHADERCONST *)(lpPrim);
        dwSize += lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER) + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST);   
        lpPrim += (lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER) ) + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST);
    
    
    }
        ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
        if (ddrval != D3D_OK) 
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2RecordSetVertexShaderConst failed");
        }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETVERTEXSHADERCONST, 0, (dwSize - sizeof(D3DHAL_DP2COMMAND) )); //dwSize has everything

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetStreamSource (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetStreamSource");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) + (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2SETSTREAMSOURCE);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordRenderState failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETSTREAMSOURCE, (*ppCommands)->wPrimitiveCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetStreamSourceUM (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetStreamSourceUM");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) + (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2SETSTREAMSOURCE);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordRenderState failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETSTREAMSOURCEUM, (*ppCommands)->wPrimitiveCount, 0);

    //this is not a valid call because the UM needs to be mapped on a per call basis
    nvAssert(0);
    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetIndices (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetIndices");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2SETINDICES));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2RecordSetIndices failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETINDICES, 1, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetPixelShader (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetPixelShader");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2PIXELSHADER));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordSetPixelShader failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2PIXELSHADER, 1, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetPixelShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD dwExtraBytes=0,dwSize=sizeof(D3DHAL_DP2COMMAND),ddrval,count;
    

    dbgTracePush ("nvDP2RecordSetPixelShaderConst");

    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        LPD3DHAL_DP2SETPIXELSHADERCONST lpConstInfo = (D3DHAL_DP2SETPIXELSHADERCONST *)(lpPrim);

        lpPrim += 4*4*lpConstInfo->dwCount + sizeof(D3DHAL_DP2SETPIXELSHADERCONST);
        dwSize += 4*4*lpConstInfo->dwCount + sizeof(D3DHAL_DP2SETPIXELSHADERCONST);
        dwExtraBytes += 4*4*lpConstInfo->dwCount;
    }
    
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordRenderState failed");

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETPIXELSHADERCONST, (*ppCommands)->wStateCount, dwExtraBytes );
    recordDebugMarker (pContext);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordMultiplyTransform (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2MULTIPLYTRANSFORM *lpMultTrans = (D3DHAL_DP2MULTIPLYTRANSFORM *)(lpPrim);

    dbgTracePush ("nvDP2MultiplyTransform");

    nvAssert(0);
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2MULTIPLYTRANSFORM, 1, 0 );

    recordDebugMarker (pContext);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------
// DP2 Capture Functions
//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetRenderState (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE  lpPrim;
    DWORD   i, dwState;

    dbgTracePush ("nvDP2CaptureSetRenderState");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    // Run through the render state list and pull values from current context.
    for (i = 0; i < (*ppCommands)->wPrimitiveCount; i++) {
        dwState = ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->RenderState;
        if (dwState == D3DRENDERSTATE_TEXTUREHANDLE) {
            // BUGBUG
            DPF ("ack. this is messed up. need to back-translate texture handle");
        }
        ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->dwState = pContext->dwRenderState[dwState];
        lpPrim += sizeof(D3DHAL_DP2RENDERSTATE);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2RENDERSTATE, (*ppCommands)->wPrimitiveCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetTextureStageState (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE  lpPrim;
    BOOL    bFilterChanged, bTSSChanged;
    DWORD   i, dwStage, dwState;
    HRESULT ddrval = D3D_OK;

    dbgTracePush ("nvDP2CaptureSetTextureStageState");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    bFilterChanged = FALSE;
    bTSSChanged = FALSE;

    for (i = 0; i < (*ppCommands)->wPrimitiveCount; i++) {
        dwStage = (DWORD)((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->wStage;
        dwState = ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->TSState;
        if (dwState == D3DTSS_TEXTUREMAP) {
            // BUGBUG
            DPF ("ack. this is messed up. need to back-translate texture handle");
        }
        ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->dwValue = pContext->tssState[dwStage].dwValue[dwState];
        lpPrim += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TEXTURESTAGESTATE, (*ppCommands)->wPrimitiveCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetViewport (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;

    dbgTracePush ("nvDP2CaptureSetViewport");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    ((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwX      = pContext->surfaceViewport.clipHorizontal.wX;
    ((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwY      = pContext->surfaceViewport.clipVertical.wY;
    ((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwWidth  = pContext->surfaceViewport.clipHorizontal.wWidth;
    ((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwHeight = pContext->surfaceViewport.clipVertical.wHeight;

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2VIEWPORTINFO, 1, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetWRange (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;

    dbgTracePush ("nvDP2CaptureSetWRange");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    ((LPD3DHAL_DP2WINFO)lpPrim)->dvWNear = pContext->surfaceViewport.dvWNear;
    ((LPD3DHAL_DP2WINFO)lpPrim)->dvWFar  = pContext->surfaceViewport.dvWFar;

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2WINFO, 1, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetZRange (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2ZRANGE pZRange;

    dbgTracePush ("nvDP2CaptureSetZRange");

    // we only care about the last zrange they set
    pZRange = (D3DHAL_DP2ZRANGE *)((*ppCommands) + 1) + ((*ppCommands)->wStateCount - 1);
    pZRange->dvMinZ = pContext->surfaceViewport.dvMinZ;
    pZRange->dvMaxZ = pContext->surfaceViewport.dvMaxZ;

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2ZRANGE, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetMaterial (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETMATERIAL pSetMat;

    dbgTracePush ("nvDP2CaptureSetMaterial");

    // we only care about the last material they set
    pSetMat = (D3DHAL_DP2SETMATERIAL *)((*ppCommands) + 1) + ((*ppCommands)->wStateCount - 1);
    *(D3DMATERIAL7 *)pSetMat = pContext->Material;

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETMATERIAL, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetLight (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT hr = D3D_OK;
    WORD wNumSetLight = (*ppCommands)->wStateCount;
    LPD3DHAL_DP2SETLIGHT pSetLight;
    D3DLIGHT7 *pLightData;
    DWORD dwTotalStride;
    int i;

    dbgTracePush ("nvDP2CaptureSetLight");

    dwTotalStride = sizeof(D3DHAL_DP2COMMAND);
    pSetLight = (LPD3DHAL_DP2SETLIGHT)((*ppCommands) + 1);
    pLightData = NULL;

    for (i=0; i < wNumSetLight; i++) {

        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);
        DWORD dwIndex  = pSetLight->dwIndex;

        // Assert that create was not called here
        assert (dwIndex < pContext->dwLightArraySize);

        switch (SETLIGHT_DATATYPE(pSetLight)) {
            case D3DHAL_SETLIGHT_ENABLE:
            case D3DHAL_SETLIGHT_DISABLE:
                if (nvLightIsEnabled(&(pContext->pLightArray[dwIndex]))) {
                    SETLIGHT_DATATYPE(pSetLight) = D3DHAL_SETLIGHT_ENABLE;
                }
                else {
                    SETLIGHT_DATATYPE(pSetLight) = D3DHAL_SETLIGHT_DISABLE;
                }
                break;
            case D3DHAL_SETLIGHT_DATA:
                pLightData = (D3DLIGHT7 *)((LPBYTE)pSetLight + dwStride);
                *pLightData = pContext->pLightArray[pSetLight->dwIndex].Light7;
                dwStride += sizeof(D3DLIGHT7);
                break;
            default:
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "Unknown SetLight command");
                hr = DDERR_INVALIDPARAMS;
        }

        dwTotalStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight + dwStride);
    }

    if (hr != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2SetLight failed");
    (*ppCommands) = (LPD3DHAL_DP2COMMAND)((LPBYTE)(*ppCommands) + dwTotalStride);

    dbgTracePop();
    return (hr);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetTransform (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETTRANSFORM   pSetXfrm;
    WORD                       wNumXfrms;
    D3DTRANSFORMSTATETYPE      xfrmType;
    D3DMATRIX                  *pMat;
    DWORD                      dwXfrmType, i, dwStage;

    dbgTracePush ("nvDP2CaptureSetTransform");

    pSetXfrm = (LPD3DHAL_DP2SETTRANSFORM)((*ppCommands) + 1);
    wNumXfrms = (*ppCommands)->wStateCount;

    for (i=0; i < (int) wNumXfrms; i++) {

        xfrmType   = pSetXfrm->xfrmType;
        dwXfrmType = (DWORD)xfrmType & (~0x80000000);
        pMat       = &pSetXfrm->matrix;

        switch (dwXfrmType) {

            case D3DTRANSFORMSTATE_WORLD_DX7:
            case D3DTS_WORLD:
                nvMemCopy (pMat, &(pContext->xfmWorld[0]), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_WORLD1_DX7:
            case D3DTS_WORLD1:
                nvMemCopy (pMat, &(pContext->xfmWorld[1]), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_WORLD2_DX7:
            case D3DTS_WORLD2:
                nvMemCopy (pMat, &(pContext->xfmWorld[2]), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_WORLD3_DX7:
            case D3DTS_WORLD3:
                nvMemCopy (pMat, &(pContext->xfmWorld[3]), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_VIEW:
                nvMemCopy (pMat, &(pContext->xfmView), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_PROJECTION:
                nvMemCopy (pMat, &(pContext->xfmProj), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_TEXTURE0:
            case D3DTRANSFORMSTATE_TEXTURE1:
            case D3DTRANSFORMSTATE_TEXTURE2:
            case D3DTRANSFORMSTATE_TEXTURE3:
            case D3DTRANSFORMSTATE_TEXTURE4:
            case D3DTRANSFORMSTATE_TEXTURE5:
            case D3DTRANSFORMSTATE_TEXTURE6:
            case D3DTRANSFORMSTATE_TEXTURE7:
                dwStage = dwXfrmType - D3DTRANSFORMSTATE_TEXTURE0;
                nvMemCopy (pMat, &pContext->tssState[dwStage].mTexTransformMatrix, sizeof(D3DMATRIX));
                break;
            default:
                DPF_LEVEL (NVDBG_LEVEL_INFO,"Ignoring unknown transform type in SetXfrm");
                break;

        }  // switch (dwxfrmType)

        pSetXfrm++;

    } // for...

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETTRANSFORM, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureExtension (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2CaptureExtension");

    DWORD ddrval = D3D_OK;
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2EXT, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetClipPlane (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETCLIPPLANE pDp2ClipPlaneData;
    DWORD                    count, index;
    D3DVALUE                 *pClipPlane;

    dbgTracePush ("nvDP2CaptureSetClipPlane");

    pDp2ClipPlaneData = (LPD3DHAL_DP2SETCLIPPLANE)((*ppCommands)+1);

    for (count=0; count<(*ppCommands)->wStateCount; count++) {

        index = pDp2ClipPlaneData->dwIndex;
        if (index > D3DMAXUSERCLIPPLANES) {
            DPF ("clipplane index %d exceeded D3DMAXUSERCLIPPLANES in nvDP2CaptureSetClipPlane", index);
            pDp2ClipPlaneData ++;
            continue;
        }

        pClipPlane = pContext->ppClipPlane[index];

        pDp2ClipPlaneData->plane[0] = pClipPlane[0];
        pDp2ClipPlaneData->plane[1] = pClipPlane[1];
        pDp2ClipPlaneData->plane[2] = pClipPlane[2];
        pDp2ClipPlaneData->plane[3] = pClipPlane[3];

        pDp2ClipPlaneData ++;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETCLIPPLANE, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetVertexShader (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;

    dbgTracePush ("nvDP2CaptureSetVertexShader");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    
    ((LPD3DHAL_DP2VERTEXSHADER)lpPrim)->dwHandle = pContext->pCurrentVShader->isFvfShader() ?
        pContext->pCurrentVShader->getFVF():
        pContext->pCurrentVShader->getHandle();

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2VERTEXSHADER, 1, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetVertexShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETVERTEXSHADERCONST *lpSetVShaderConst;
    DWORD   dwExtraBytes=0,count;

    dbgTracePush ("nvDP2CaptureSetVertexShaderConst");


    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        lpSetVShaderConst = (D3DHAL_DP2SETVERTEXSHADERCONST *)(lpPrim);
        VSHADERREGISTER *pConst = (VSHADERREGISTER*)(lpPrim + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST));
    
        nvAssert(pContext->pVShaderConsts);
        nvAssert((lpSetVShaderConst->dwRegister + lpSetVShaderConst->dwCount) <= D3DVS_CONSTREG_MAX_V1_1);
        
        memcpy (pConst,
                &(pContext->pVShaderConsts->vertexShaderConstants[lpSetVShaderConst->dwRegister]),
                lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER));
        
        dwExtraBytes += lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER);   
        
        lpPrim += (lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER) ) + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETVERTEXSHADERCONST, (*ppCommands)->wStateCount, dwExtraBytes);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetStreamSource (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETSTREAMSOURCE *lpStreamSource = (D3DHAL_DP2SETSTREAMSOURCE *)(lpPrim);
    DWORD count;

    dbgTracePush ("nvDP2CaptureSetStreamSource");

    for (count=0; count< (*ppCommands)->wStateCount; count++)
    {
        if (pContext->ppDX8Streams[lpStreamSource->dwStream])
        {
            lpStreamSource->dwVBHandle = pContext->ppDX8Streams[lpStreamSource->dwStream]->getWrapper()->getHandle();
        }
        lpStreamSource++;
    }
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETSTREAMSOURCE, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetStreamSourceUM (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETSTREAMSOURCE *lpStreamSource = (D3DHAL_DP2SETSTREAMSOURCE *)(lpPrim);
    DWORD count;

    dbgTracePush ("nvDP2CaptureSetStreamSourceUM");

    for (count=0; count< (*ppCommands)->wStateCount; count++)
    {
        lpStreamSource->dwStream = 0; //need help here HMH
        lpStreamSource->dwVBHandle = 0; //need help here HMH
        lpStreamSource++;
    }
    //this is not a valid call because the UM needs to be mapped on a per call basis
    nvAssert(0);
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETSTREAMSOURCE, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetIndices (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;

    dbgTracePush ("nvDP2CaptureSetIndices");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    if (pContext->pIndexBuffer) {
        ((LPD3DHAL_DP2SETINDICES)lpPrim)->dwVBHandle = pContext->pIndexBuffer->getWrapper()->getHandle(); //need help here HMH
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETINDICES, 1, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetPixelShader (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;

    dbgTracePush ("nvDP2CaptureSetPixelShader");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    if (pContext->pCurrentPShader) {
        ((LPD3DHAL_DP2PIXELSHADER)lpPrim)->dwHandle = pContext->pCurrentPShader->getHandle();
    }
    else
    {
        ((LPD3DHAL_DP2PIXELSHADER)lpPrim)->dwHandle = 0;
    }
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2PIXELSHADER, 1, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetPixelShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD dwExtraBytes=0,count;
    
    dbgTracePush ("nvDP2SetPixelShaderConst");

    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        LPD3DHAL_DP2SETPIXELSHADERCONST lpConstInfo = (D3DHAL_DP2SETPIXELSHADERCONST *)(lpPrim);
        D3DCOLORVALUE *lpConsts = (D3DCOLORVALUE *)(lpPrim + sizeof(D3DHAL_DP2SETPIXELSHADERCONST) );

        for (DWORD i=0; i<lpConstInfo->dwCount; i++) {
            lpConsts[i] = pContext->pixelShaderConsts[lpConstInfo->dwRegister+i];
        }
        lpPrim += 4*4*lpConstInfo->dwCount + sizeof(D3DHAL_DP2SETPIXELSHADERCONST);
        dwExtraBytes += 4*4*lpConstInfo->dwCount;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETPIXELSHADERCONST, (*ppCommands)->wStateCount, dwExtraBytes );

    dbgTracePop();
    return (D3D_OK);
}

#endif // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvdp2help.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDP2Help.cpp
//      helper routines for DP2 operations
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        08Nov00         created
//
// **************************************************************************

#include "nvprecomp.h"
#pragma hdrstop

//-------------------------------------------------------------------------

void __stdcall nvWireframeIndexedTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    dbgTracePush ("nvWireframeIndexedTriangle (%d,%x)", pContext->dp2.dwDP2Prim, dwCount);

    DDSTARTTICK(PRIM_WIREFRAMEINDEXEDTRI);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, dwCount);

    if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
        nvIndexedWireframeTriangle (NV_INNERLOOP_ARGS);
    }
    else {
        nvFVFIndexedWireframeTriangle (NV_INNERLOOP_ARGS);
    }
    DDENDTICK(PRIM_WIREFRAMEINDEXEDTRI);

    dbgTracePop();
}

//-------------------------------------------------------------------------

void __stdcall nvPointIndexedTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    dbgTracePush ("nvPointIndexedTriangle (%d,%x)", pContext->dp2.dwDP2Prim, dwCount);

    DDSTARTTICK(PRIM_POINTINDEXEDTRI);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, dwCount);

    if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
        nvIndexedPointTriangle (NV_INNERLOOP_ARGS);
    }
    else {
        nvFVFIndexedPointTriangle (NV_INNERLOOP_ARGS);
    }
    DDENDTICK(PRIM_POINTINDEXEDTRI);

    dbgTracePop();
}

//-------------------------------------------------------------------------

void __stdcall nvWireframeNonIndexedTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    dbgTracePush ("nvWireframeNonIndexedTriangle (%d,%x)", pContext->dp2.dwDP2Prim, dwCount);

    DDSTARTTICK(PRIM_WIREFRAMENONINDEXEDTRI);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, dwCount);

    if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
        nvDrawWireframeTriangle (NV_INNERLOOP_ARGS);
    }
    else {
        nvFVFDrawWireframeTriangle (NV_INNERLOOP_ARGS);
    }
    DDENDTICK(PRIM_WIREFRAMENONINDEXEDTRI);

    dbgTracePop();
}

//-------------------------------------------------------------------------

void __stdcall nvPointNonIndexedTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    dbgTracePush ("nvPointNonIndexedTriangle (%d,%x)", pContext->dp2.dwDP2Prim, dwCount);

    DDSTARTTICK(PRIM_POINTNONINDEXEDTRI);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, dwCount);

    if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
        nvDrawPointTriangle (NV_INNERLOOP_ARGS);
    }
    else {
        nvFVFDrawPointTriangle (NV_INNERLOOP_ARGS);
    }
    DDENDTICK(PRIM_POINTNONINDEXEDTRI);

    dbgTracePop();
}

//-------------------------------------------------------------------------------------

void nvCalcRWFar (PNVD3DCONTEXT pContext)
{
    if ((getDC()->nvD3DRegistryData.regW16Format == D3D_REG_WFORMAT_FIXED) ||
        (getDC()->nvD3DRegistryData.regW32Format == D3D_REG_WFORMAT_FIXED)) {
        // For fixed point W-Buffers, always set dvRWFar to the specified WFar value.
        pContext->surfaceViewport.dvRWFar = pContext->surfaceViewport.dvWFar;
    }
    else {
        // For floating point W-Buffers, dvRWFar gets calculated slightly differently
        // for 16-bit buffers vs 24 bit buffers.
        if (pContext->pZetaBuffer) {
            if (pContext->pZetaBuffer->getBPP() == 2) {
                // 16 Bit W-Buffer.
                pContext->surfaceViewport.dvRWFar = pContext->surfaceViewport.dvWFar * (1.0f / 256.0f);
            }
            else {
                // 24 Bit W-Buffer.
                pContext->surfaceViewport.dvRWFar = 1.0f;
                // pContext->surfaceViewport.dvRWFar = 1.0f / (2 ** 127); // alternate
            }
        }
        else {
            // we don't have a render target yet
            pContext->surfaceViewport.dvRWFar = 1.0f;
        }
    }
}

//---------------------------------------------------------------------------

BOOL nvPaletteBlt (CNvObject *pSrcObj, CTexture *pDstTexture)
{
    CNvObject *pOrigSrcObj = pSrcObj;
    // get palette address and 64 byte align
    DWORD      pPalAddr    = (pDstTexture->getSwizzled()->getAddress() + pDstTexture->getSwizzled()->getSize() / 2 + 63) & ~63;

    dbgTracePush ("nvPaletteBlt");

    // determine the new texture format and create palette builder object
    CPaletteBuilder palBuilder;

    DWORD dwNewFormat, dwOriginalFormat = pDstTexture->getLinear()->getFormat();
    DWORD dwPalType;

    switch(dwOriginalFormat)
    {
        case NV_SURFACE_FORMAT_A8R8G8B8:
            dwPalType   = PT_8888;
            dwNewFormat = NV_SURFACE_FORMAT_I8_A8R8G8B8;
            break;
        case NV_SURFACE_FORMAT_X8R8G8B8:
            dwPalType   = PT_X888;
            dwNewFormat = NV_SURFACE_FORMAT_I8_A8R8G8B8;
            break;
        default:
            // unhandled texture format
            DPF_LEVEL(NVDBG_LEVEL_PALETTE, "nvPaletteBlt: Unhandled autopalettization texture format");
            dbgTracePop();
            return FALSE;
    }

    BOOL bRVal = palBuilder.initTable(dwPalType);
    if (!bRVal) {
        palBuilder.freeTable(dwPalType);
        dbgTracePop();
        return FALSE;
    }

    // pass 1 - extract the palette

    do {
        // get source surface
        CSimpleSurface* pSrcSurface = pSrcObj->getSimpleSurface();

        bRVal = palBuilder.buildTable(dwPalType,
                                      pSrcSurface->getAddress(),
                                      pSrcSurface->getWidth(), pSrcSurface->getHeight());
        if (!bRVal) {
            palBuilder.freeTable(dwPalType);
            dbgTracePop();
            return FALSE;
        }

        pSrcObj = pSrcObj->getAttachedA();

    } while (pSrcObj); // terminate if we have reached the end of the mipmap chain

    // lock the destination surface
    pDstTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);

    // optimise the palette
    bRVal = palBuilder.palettize(dwPalType,(BYTE*)pPalAddr);
    if (!bRVal) {
        palBuilder.freeTable(dwPalType);
        dbgTracePop();
        return FALSE;
    }

    // pass 2 - convert the texture

    // get the original source object
    pSrcObj = pOrigSrcObj;

    DWORD dwWidth     = pDstTexture->getWidth();
    DWORD dwHeight    = pDstTexture->getHeight();
    DWORD dwLogWidth  = pDstTexture->getLogWidth();
    DWORD dwLogHeight = pDstTexture->getLogHeight();
    DWORD dwDestBaseAddr = pDstTexture->getSwizzled()->getAddress();
    DWORD dwOffset = 0;

    do {
        // get source surface
        CSimpleSurface* pSrcSurface = pSrcObj->getSimpleSurface();

        palBuilder.apply (dwPalType, pSrcSurface->getAddress(), dwDestBaseAddr + dwOffset,
                          dwWidth, dwLogWidth, dwHeight, dwLogHeight);

        dwOffset += dwWidth * dwHeight;
        if (dwLogWidth)  dwLogWidth--;
        if (dwLogHeight) dwLogHeight--;
        dwWidth  = 1 << dwLogWidth;
        dwHeight = 1 << dwLogHeight;

        pSrcObj = pSrcObj->getAttachedA();

    } while (pSrcObj); // terminate if we have reached the end of either mipmap chain

#ifdef CAPTURE
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        CAPTURE_MEMORY_WRITE memwr;
        memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
        memwr.dwCtxDMAHandle       = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
        memwr.dwOffset             = pDstTexture->getSwizzled()->getOffset();
        memwr.dwSize               = pDstTexture->getSwizzled()->getSize();
        captureLog (&memwr, sizeof(memwr));
        captureLog ((void*)dwDestBaseAddr, memwr.dwSize);
    }
#endif

    // set the pixel formats, flag and cleanup
    pDstTexture->setOriginalFormat(dwOriginalFormat);
    if (pDstTexture->hasColorKey() && (dwOriginalFormat == NV_SURFACE_FORMAT_X8R8G8B8)) {
        pDstTexture->setColorKey(pDstTexture->getColorKey() | 0xFF000000); // fix colour-key alpha
    }
    pDstTexture->setFormat(dwNewFormat);
    DWORD pPalOffset = (pDstTexture->getSwizzled()->getOffset() + pDstTexture->getSwizzled()->getSize() / 2 + 63) & ~63;
    pDstTexture->setAutoPaletteOffset(pPalOffset);
    pDstTexture->tagAutoPalettized();
    pDstTexture->cpuUnlockSwz();
    palBuilder.freeTable(dwPalType);

    dbgTracePop();
    return TRUE;
}

//---------------------------------------------------------------------------

BOOL nvUnpalettize (CNvObject *pDstObj)
{
    CTexture *pTexture = pDstObj->getTexture();

    dbgTracePush ("nvUnpalettize");

    // get palette address and 64 byte align
    DWORD dwAddr   = pTexture->getSwizzled()->getAddress();
    DWORD pPalAddr = (dwAddr + pTexture->getSwizzled()->getSize() / 2 + 63) & ~63;
    DWORD dwBPP    = pTextu