    buf, *expect);
      return 0;
    }
    expect++;
  }
  ifs >> buf;
  if (strcmp(buf, append_string)) {
    DbgPrint( "Read '%s', expected '%s'\n",
      buf, append_string);
    return 0;
  }
  return 1;
}

/**********************************************************************/
/*                                                                    */
/* create_datafile                                                    */
/*                                                                    */
/* This routine writes the known data into the data file.             */
/*                                                                    */
/* Return:                                                            */
/*                                                                    */
/*    1   success                                                     */
/*    0   failure for some reason                                     */
/*                                                                    */
/**********************************************************************/

static int create_datafile(const char * filename)
{
  ofstream ofs(filename, ios::out|ios::trunc);
  if (!ofs.good()) {
    extern int errno;
    DbgPrint( "Cannot open data file to write it.\n");
    DbgPrint( "errno is %d.\n",errno);
    return 0;
  }

  const char ** expect = expected_data;
  while (*expect)
    ofs << *expect++ << "\n";
  return 1;
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\fstream3.c ===
/* @(#)File: fstream3.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual Select Code 307-145
    < Appendix A-4, Stream I/O Library Manual Pages, 

>WHAT:  < FSTREAM(3C++) Manual page dated 14 June 1989
    < This stream class is for use in performing file I/O.
    < They use the filebuf class.
    <
    < Test ofstream and ifstream constructors of no arguments
    <
    < 0.  Test ofstream::ofstream()
    < 1.  Test ifstream::ifstream()

>HOW:   < 0,1. Construct fstreams and verify that they are not open
    <      since they have no associated file.

>MODS:  < 07/02/90, DRE: Changed definition of failure() to a prototype.
    <    Included "testhead.h" instead of "testhead.h"
    < Vers 1.0, date: 3/5/90: Created DRE

>BUGS:  < Bugs or system dependencies: none known.

======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
#endif 
#include "testhead.h"


static char progname[] = "fstream3()";     

/*--------------------------------------------------------------------*/
void fstream3_main()                 
{
    setup();

/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the fstream classes.\n");
    DbgPrint("Test the ofstream::ofstream() constructor.\n");

    {
        ofstream ofs;

        if (ofs.rdbuf()->is_open()) 
        failure("The ofstream thinks a file is open.");
    }

    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();          

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the fstream classes.\n");
    DbgPrint("Test the ifstream::ifstream() constructor.\n");

    {
        ifstream ifs;

        if (ifs.rdbuf()->is_open()) 
        failure("The ifstream thinks a file is open.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  

}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ios3.c ===
/* @(#)File: ios3.C     Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests format control function setf(b,f) as well     >
    < as the functions controlling the format components "width"    >
    < "precision" and "fill".                   >

>HOW:   < These functions either set or return the value of a format    >
    < variable of the class ios.                    >
    < The general test strategy is to use a value setting function  >
    < to set the variable to each of the possible values, and check >
    < with the value returning function that the variable actually  >
    < has the value we set it too.  This procedure allows to check  >
    < the two values against one another.               >

    < 0. Use setf(b,f) to set the format and flags() to check it.   >
    < 1. Check the return value of setf(b,f) is the old format.     >

    < 2. Use fill(c) to set the fill char and fill() to check it.   >
    < 3. Check the return value of fill(c) is the old fill char.    >

    < 4. Use width(c) to set the width and width() to check it. >
    < 5. Check the return value of width(c) is the old width.   >

    < 6. Use precision(c) to set the precision and precision()  >
    <    to check it.                       >
    < 7. Check the return value of precision(c) is the old      >
    <    precision.                         >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ios3()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#endif

// global variable declarations
static streambuf * sb;     //creates an empty buffer
static ios s(sb);      // creates a stream using the empty buffer

static long old_format, new_format;
/*--------------------------------------------------------------------*/
ios3_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

#if defined(USING_OLD_IOS)

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test function setf(b, f)");

    s.flags(0l);        // clear all bits of format
    old_format = 0l;
    long setf_val;

    for (int i= 0; i<31; i++)
        {setf_val = s.setf(~0l, 1l<< i);
        if (setf_val != old_format)
            {local_flag = FAILED;
            DbgPrint("\tsetf(b,f) returnd %lx instead of %lx\n",
                    setf_val, old_format);
            }
        new_format = old_format | (1l << i);
        if (s.flags() != new_format)
            {local_flag = FAILED;
            DbgPrint( "\tformat is %lx instead of %lx\n",
                    s.flags(), new_format);
            }
        old_format = new_format;
        }

#endif 

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

#if defined(USING_OLD_IOS)

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test function setf(b, f)");

    s.flags(~0l);       // set all bits of format
    old_format = ~0l;
    long unsetf_val;

    for (i= 0; i<31; i++)
        {unsetf_val = s.setf(0l, 1l << i);
        if (unsetf_val != old_format)
            {local_flag = FAILED;
            DbgPrint("\tsetf(b,f) returnd %lx instead of %lx\n",
                    unsetf_val, old_format);
            }
        new_format = old_format & ~(1l << i);
        if (s.flags() != new_format)
            {local_flag = FAILED;
            DbgPrint( "\tformat is %lx instead of %lx\n",
                    s.flags(), new_format);
            }
        old_format = new_format;
        }

#endif 

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check fill(c) against fill()");

    s.fill(0);
    if (s.fill() != 0)
        fail("could not set fill to all zeroes");

    s.fill(~0);
    if (s.fill() != ~0)
        fail("could not set fill to all ones");

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check the return value of fill(c) is the previous value");

    s.fill(0);
    if (s.fill(~0) != 0)
        fail("unexpected high bit in return value");
    if (s.fill(0) != ~0)
        fail("unexpected low bit in return value");

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check width(c) against width()");

    s.width(0);
    if (s.width() != 0)
        fail("could not set width to all zeroes");

    s.width(~0);
    if (s.width() != ~0)
        fail("could not set width to all ones");

        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check the return value of width(c) is the previous value");

    s.width(0);
    if (s.width(~0) != 0)
        fail("unexpected high bit in return value");
    if (s.width(0) != ~0)
        fail("unexpected low bit in return value");

        blexit();
/*--------------------------------------------------------------------*/
block6: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check precision(c) against precision()");

    s.precision(0);
    if (s.precision() != 0)
        fail("could not set precision to all zeroes");

    s.precision(~0);
    if (s.precision() != ~0)
        fail("could not set precision to all ones");

        blexit();
/*--------------------------------------------------------------------*/
block7: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check the return value of precision(c) is the previous value");

    s.precision(0);
    if (s.precision(~0) != 0)
        fail("unexpected high bit in return value");
    if (s.precision(0) != ~0)
        fail("unexpected low bit in return value");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail();      
        return 0;
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ios2.c ===
/* @(#)File: ios2.C     Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the format state functions of class ios   >

>HOW:   < These functions either set or return the value of the format  >
    < variable of class ios.                    >

    < 0. Use flags(long) to set format to a given value and use     >
    <    flags() to check format was set to that value.     >

    < 1. Check that the return value of flags(long) is the old  >
    <    value of format.                       >

    < 2. Check that the function setf can be used to set to one >
    <    each bit of the format variable.  Also check the return    >
    <    value of setf (old value of format) is correct.        >

    < 3. Check that the function unsetf can be used to set to zero  >
    <    each bit of the format variable.  Also check the return    >
    <    value of unsetf (old value of format) is correct.      >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ios2()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

// global variable declarations
#if defined(USING_OLD_IOS)
static streambuf * sb;     //creates an empty buffer
static ios s(sb);      // creates a stream using the empty buffer
#else
static char        buf[10];
istrstream  s(buf);
#endif 

static long old_format, new_format;

#if defined(USING_OLD_IOS)
#define LONG_5 0x55555555l
#define LONG_A 0xaaaaaaaal
#else
#define LONG_5 0x5555
#define LONG_A 0x7aaa
#endif 
/*--------------------------------------------------------------------*/
void ios2_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Testing member function flags()");

    s.flags(LONG_5);
    s.flags(LONG_A);
    if (s.flags() != LONG_A)
        fail("unexpected value in test # 1");
    s.flags(LONG_5);
    if (s.flags() != LONG_5)
        fail("unexpected value in test # 2");

    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Testing member function flags(long)");

    s.flags(LONG_5);
    if (s.flags(LONG_A) != LONG_5)
        fail("unexpected value in test # 1");
    if (s.flags(LONG_5) != LONG_A)
        fail("unexpected value in test # 2");

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Testing member function setf()");

    s.flags(0l);        // clear all bits of format
    old_format = 0l;
    long setf_val;

#if defined(USING_OLD_IOS)
    for (int i= 0; i<31; i++)
#else
    for (int i= 0; i<15; i++)
#endif 
        {setf_val = s.setf(1l << i);
        if (setf_val != old_format)
            {local_flag = FAILED;
            DbgPrint( "\tsetf() returned %lx instead of %lx\n",
                    setf_val, old_format);
            }
        new_format = old_format | (1l << i);
        if (s.flags() != new_format)
            {local_flag = FAILED;
            DbgPrint( "\tformat is %lx instead of %lx\n",
                    s.flags(), new_format);
            }
        old_format = new_format;
        }

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Testing member function unsetf()");

#if defined(USING_OLD_IOS)
    s.flags(~0l);       // set all bits of format
    old_format = ~0l;
#else
    s.flags(~0 & ios::_Fmtmask);        // set all bits of format
    old_format = ~0 & ios::_Fmtmask;
#endif 
    long unsetf_val;

#if defined(USING_OLD_IOS)
    for (i= 0; i<31; i++)
#else
    for (i= 0; i<15; i++)
#endif 
        {
#if defined(USING_OLD_IOS)
        unsetf_val = s.unsetf(1l << i);
#else
        unsetf_val = s.flags();
        s.unsetf(1l << i);
#endif 
        if (unsetf_val != old_format)
            {local_flag = FAILED;
            DbgPrint("\tunsetf() returned %lx instead of %lx\n",
                    unsetf_val, old_format);
            }
        new_format = old_format & ~(1l << i);
        if (s.flags() != new_format)
            {local_flag = FAILED;
            DbgPrint( "\tformat is %lx instead of %lx\n",
                    s.flags(), new_format);
            }
        old_format = new_format;
        }

        blexit();
/*--------------------------------------------------------------------*/
        anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\fstream2.c ===
/* @(#)File: fstream_2.C    Version: 1.0    Date: 09/27/90            */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual Select Code 307-145
    < Appendix A-4, Stream I/O Library Manual Pages, 

>WHAT:  < FSTREAM(3C++) Manual page dated 14 June 1989
    < This stream class is for use in performing file I/O.
    < They use the filebuf class.
    <
    < 0.  Opening an output file with the ios::in mode bit
    <     prevents truncation.
    <
    < CLEAN UP --- After the last block the output file is removed.


>HOW:   < 0. Give the data file known contents. Then close it and
    <    reopen it for output with ios::in. Then close it.
    <    Verify that the contents have not been altered.
    <

>MODS:  < 07/02/90, DRE: Changed definition of failure() to a prototype.
    <    Included "testhead.h" instead of "testhead.h"
    < Vers 1.0, date: 3/2/90: Created DRE

>BUGS:  < This test uses the tmpnam() ANSI C library routine to
    < obtain a temporary file name, thus it is ANSI C dependent.

======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
#endif 
#include <fcntl.h>
#include <stdio.h>
#include "remove.h"

#include "testhead.h"


static char progname[] = "fstream2()";

    // Copy known data into the data file

static int create_datafile(const char * filename);

    // This function reads the input file stream and checks that its 
    // contents match the expected contents.

static int verify_ifs(ifstream * pifs);

/**********************************************************************/
/*                                                                    */
/* This test uses a data file that it reads. The name of              */
/* the file is stored in the datfile variable.                        */
/*                                                                    */
/**********************************************************************/

static char filenamebuf[L_tmpnam];

static const char * datfile = tmpnam(filenamebuf);

/*--------------------------------------------------------------------*/
fstream2_main()                  
{
    setup();

/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, FSTREAM(3C++) manual page.\n");
    DbgPrint("ios::in: Opening an output file with this bit\n");
    DbgPrint("prevents truncation.\n");

    if (create_datafile(datfile)) {
        ofstream ofs(datfile, ios::out|ios::in);

        if (!ofs.rdbuf()->is_open()) 
        failure("Cannot open data file.");
        else {
        ofs.close();            // Close it 
        ifstream ifs(datfile);  // Reopen it
        if (!ifs.rdbuf()->is_open()) 
            failure("Cannot reopen data file.");
        else
            if (!verify_ifs(&ifs))
            failure("File has wrong contents.");
        }
        // Remove the data file
        remove(datfile);
    } else {
        failure("Cannot create data file: can't run test.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
    return 0;
}                   


/**********************************************************************/
/*                                                                    */
/* This is the data the test writes to its input file.                */
/*                                                                    */
/**********************************************************************/

static const char * expected_data[] = {
    "aaaaaaaaaa",
    "bbbbbbbbbb",
    "0123456789",
    0
};

/**********************************************************************/
/*                                                                    */
/* verify_ifs                                                         */
/*                                                                    */
/* This routine reads the input file and verifies it contains the     */
/* expected data.                                                     */
/*                                                                    */
/* Return:                                                            */
/*                                                                    */
/*    1   correct data                                                */
/*    0   incorrect data                                              */
/*                                                                    */
/* Side-effect:                                                       */
/*                                                                    */
/*    The current file read/write position is undefined after this    */
/*    routine.                                                        */
/*                                                                    */
/**********************************************************************/

static int verify_ifs(ifstream * pifs)
{
    const char ** expect = expected_data;
    const int bufsize = 128;
    char buf[bufsize];

    while (*expect) {
        *pifs >> buf;
        if (strcmp(buf, *expect)) {
            DbgPrint( "Read '%s', expected '%s'\n",
                buf, *expect);
            return 0;
        }
        expect++;
    }
    return 1;
}

/**********************************************************************/
/*                                                                    */
/* create_datafile                                                    */
/*                                                                    */
/* This routine writes the known data into the data file.             */
/*                                                                    */
/* Return:                                                            */
/*                                                                    */
/*    1   success                                                     */
/*    0   failure for some reason                                     */
/*                                                                    */
/**********************************************************************/

static int create_datafile(const char * filename)
{
    ofstream ofs(filename, ios::out|ios::trunc);
    if (!ofs.good()) {
        extern int errno;
        DbgPrint( "Cannot open data file to write it.\n");
        DbgPrint( "errno is %d.\n",errno);
        return 0;
    }

    const char ** expect = expected_data;
    while (*expect)
        ofs << *expect++ << "\n";
    return 1;
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ios4.c ===
/* @(#)File: ios4.C     Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file test the following member functions of the class    >
    < ios: bitalloc(), xalloc(), iword(int), pword(int), rdbuf().   >

>HOW:   < The function bitalloc() returns a long with a single      >
    < previously unallocated bit set in the format variable.    >

    < 0. Ask for as many bits as possible and check that it does    >
    <    not return more than the total number of bits in a long    >
    <    variable (generally 32).  Make the requests using the  >
    <    syntax ios::bitalloc().                    >

    < 1. The function bitalloc() is a static member function.   >
    <    Check that when no more bits are available following the   >
    <    requests made in block 0, requests made from any object    >
    <    of class ios cannot be honored either.         >

    < 2. The function xalloc() returns a previously unassigned  >
    <    index into an array of words for use as a format variable. >
    <    Check that 2 consecutive calls to xalloc() do not return   >
    <    the same value.                        >

    < 3. Create a derived class of ios called ios2.  Check that >
    <    requesting a new format word usingg ios2::xalloc() does    >
    <    not return one of the values returned by ios::xalloc() >
    <    in block 2.                        >

    < 4. iword(int i) and pword(int i) both return a reference to   >
    <    the user defined word whose index is i.  The return type   >
    <    is the only difference.  Check that a type cast of the     >
    <    return value of iword(i) yields the same value as pword(i).>

    < 5. Check that rdbuf() returns a pointer to the streambuf  >
    <    associated with the ios s when s was constructed.      >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ios4()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#endif

// global variable declarations
static streambuf * sb;     //creates an empty buffer
static ios s(sb);      // creates a stream using the empty buffer

/*--------------------------------------------------------------------*/
ios4_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

#if defined(USING_OLD_IOS)

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test function bitalloc()");

    int long_size = 8 * sizeof (long);

    for (int i= 0; i<long_size; i++)
        ios::bitalloc();

    if (ios::bitalloc())
        fail ("unexpected unallocated bit in format variable");

#endif 

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

#if defined(USING_OLD_IOS)

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test function bitalloc()");

    if (s.bitalloc())
        fail ("unexpected unallocated bit in format variable");

#endif 

    blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check function xalloc() does not return twice the same value");

    int i1, i2;

    i1 = ios::xalloc();
    i2 = ios::xalloc();

    if (i1 == i2)
        fail ("reallocation of the same format word");

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check function xalloc() does not return twice the same value");
    print("even if you call it from a different derived class of ios");

    class ios2 : public ios {};

    int i3 = ios2::xalloc();

    if ((i3 == i1) || (i3 == i2))
        fail ("reallocation of the same format word");

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check that iword(i) and pword(i) return the same value");

    if (s.pword(i1) != ((void *) s.pword(i1)))
        fail ("iword() and pword() return different values");

        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check that s.rdbuf() returns the streambuf coupled with s at");
    print("the time of construction of s");

    if (s.rdbuf() != sb)
        fail("unexpected streambuf pointer");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail();      
        return 0;
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ios6.c ===
/* @(#)File: ios6.C     Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file checks the default values of the format components  >
    < "fill", "width" and "precision".              >

>HOW:   < These values are checked using the member functions of the    >
    < class ios which return the value of a format component.       >

    < 0. Check the default value of the precision component is 6    >
    <    using the member function precision().         >

    < 1. Check the default value of the width component is 0    >
    <    using the member function width().             >

    < 2. Check the default value of the fill character is the space >
    <    using the member function fill().              >

    < Block 3 and 4 test that as described in the AT&T manual,  >
    < the width component is reset to 0 after each insertion or     >
    < extraction.                           >

    < 3. Set the width to a non-zero value.  Output a value.    >
    <    Check that the width is reset to 0 following the write.    >

    < 4. Set the width to a non-zero value.  Output a value.    >
    <    Check that the width is reset to 0 following the write.    >

    < 5. Check that the numeric inserters do not truncate values    >
    <    so they will fit in the selected field width.      >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < AT&T library bug:  Block 4 fails.  The width does not reset   >
    < to the default value (zero) following an insertion from an    >
    < input stream.                         >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ios6()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

// global variable declarations

/*--------------------------------------------------------------------*/
ios6_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check that the default precision is 6");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream

    if (s.precision() != 6)
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check that the default width is 0");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream

    if (s.width() != 0)
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check the default fill character is the space");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream

    if (s.fill() != ' ')
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check that the width is reset to 0 following an insertion");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.width(4);     // set the width;

    s << 4;         // first write should be padded
    if (s.width() != 0)
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check that the width is reset to 0 following an extraction");

    {static char buf[10] = "1";;
    istrstream s(buf, 8);   // create an iostream
    s.width(4);     // set the width;

    int i;

    s >> i;         // do an extraction
#if defined(USING_OLD_IOS)
    if (s.width() != 0)
        fail ("unexpected result");
#endif 
    }

        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Check that the numeric inserters do not truncate values"); 
    print("so they will fit in the selected field width");

    {char buf[10];
    ostrstream s(buf, 8);   // create a stream
    s.width(1);     // set the width

    s << 16;        // write to stream a string longer than width
    if (strncmp(buf, "16", 2))
        fail ("unexpected result");
    }

        blexit();
/*--------------------------------------------------------------------*/
    anyfail();
    return 0;
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ios5.c ===
/* @(#)File: ios5.C     Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the manipulator that set the format control   >
    < enumerators dec, hex and oct.                 >

>HOW:   < In each block, use the manipulator to set the format flag     >
    < to one of the enumerators, then use flags() to check the  >
    < manipulator worked properly.                  >

    < 0. Set the dec enumerator with >>.                >
    < 1. Set the dec enumerator with <<.                >
    < 2. Set the hex enumerator with >>.                >
    < 3. Set the hex enumerator with <<.                >
    < 4. Set the oct enumerator with >>.                >
    < 5. Set the oct enumerator with <<.                >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ios5()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <iomanip.h>
#else
#include <iostream>
#include <iomanip>
#endif

// global variable declarations
#if defined(USING_OLD_IOS)

static streambuf * sb;     //creates an empty buffer
static iostream  s(sb);        // creates a stream using the empty buffer

#else
static streambuf * sb;     //creates an empty buffer
istream     is(sb);
ostream     os(sb);
#endif

/*--------------------------------------------------------------------*/
void ios5_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Set the format flag to ios::dec with the manipulator >>");

#if defined(USING_OLD_IOS)

    s.unsetf(~0l);      // clear all bits of the flag.
    s>>dec;         // set the format field
    if (s.flags() != ios::dec)
        fail ("manipulator failed");

#else

    is.unsetf(~0l);     // clear all bits of the flag.
    is >> dec;          // set the format field
    if (is.flags() != ios::dec)
        fail ("manipulator failed");

#endif
        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Set the format flag to ios::dec with the manipulator <<");

#if defined(USING_OLD_IOS)

    s.unsetf(~0l);      // clear all bits of the flag.
    s<<dec;         // set the format field
    if (s.flags() != ios::dec)
        fail ("manipulator failed");

#else

    os.unsetf(~0l);     // clear all bits of the flag.
    os<<dec;            // set the format field
    if (os.flags() != ios::dec)
        fail ("manipulator failed");

#endif 
        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Set the format flag to ios::hex with the manipulator >>");

#if defined(USING_OLD_IOS)
    s.unsetf(~0l);      // clear all bits of the flag.
    s>>hex;         // set the format field
    if (s.flags() != ios::hex)
        fail ("manipulator failed");
#else
    is.unsetf(~0l);     // clear all bits of the flag.
    is>>hex;            // set the format field
    if (is.flags() != ios::hex)
        fail ("manipulator failed");
#endif
        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Set the format flag to ios::hex with the manipulator <<");

#if defined(USING_OLD_IOS)
    s.unsetf(~0l);      // clear all bits of the flag.
    s<<hex;         // set the format field
    if (s.flags() != ios::hex)
        fail ("manipulator failed");
#else
    os.unsetf(~0l);     // clear all bits of the flag.
    os<<hex;            // set the format field
    if (os.flags() != ios::hex)
        fail ("manipulator failed");
#endif 
        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Set the format flag to ios::oct with the manipulator >>");

#if defined(USING_OLD_IOS)
    s.unsetf(~0l);      // clear all bits of the flag.
    s>>oct;         // set the format field
    if (s.flags() != ios::oct)
        fail ("manipulator failed");
#else
    is.unsetf(~0l);     // clear all bits of the flag.
    is>>oct;            // set the format field
    if (is.flags() != ios::oct)
        fail ("manipulator failed");
#endif 
        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Set the format flag to ios::oct with the manipulator <<");

#if defined(USING_OLD_IOS)
    s.unsetf(~0l);      // clear all bits of the flag.
    s<<oct;         // set the format field
    if (s.flags() != ios::oct)
        fail ("manipulator failed");
#else
    os.unsetf(~0l);     // clear all bits of the flag.
    os<<oct;            // set the format field
    if (os.flags() != ios::oct)
        fail ("manipulator failed");
#endif 
        blexit();
/*--------------------------------------------------------------------*/
        anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\iosenum1.c ===
/* @(#)File: iosenum1.C     Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the values of the enumerators in the class    >
    < ios's "io_state" and "seek_dir" enumerations.         >

>HOW:   < Each block tests the value of one enumerator.         >

    < Check the io_state enumerators:               >
    < 0. goodbit is 0                       >
    < 1. eofbit  is 1                       >
    < 2. failbit is 2                       >
    < 3. badbit  is 4                       >

    < Check the seek_dir enumerators:               >
    < 4. beg is 0                           >
    < 5. cur is 1                           >
    < 6. end is 2                           >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < In the June 9 version of the ATT documentation, the io_state  >
    < enumeration is improperly documented  in the IOS(3C++)    >
    < man page.  The proper documentation on io_state is to be  >
    < found on page 3-5 of the library manual's section 3 on    >
    < iostream examples.                        >
========================================================================*/
#include "testhead.h"     

static char progname[] = "iosenum1()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#endif

// global variable declarations
/*--------------------------------------------------------------------*/
void iosenum1_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator goodbit of the io_state enumeration");

    if (ios::goodbit != 0)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator eofbit of the io_state enumeration");

    if (ios::eofbit != 1)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator failbit of the io_state enumeration");

    if (ios::failbit != 2)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator badbit of the io_state enumeration");

    if (ios::badbit != 4)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator beg of the seek_dir enumeration");

    if (ios::beg != 0)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator cur of the seek_dir enumeration");

    if (ios::cur != 1)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block6: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator end of the seek_dir enumeration");

    if (ios::end != 2)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\iosenum4.c ===
/* @(#)File: iosenum4.C     Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyuppercase 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the values of some enumerators in the class   >
    < ios's format control enumeration.  The rest of the        >
    < enumerators in this enumeration are tested in iosenum3.C  >

>HOW:   < Each block tests the value of one enumerator.         >

    < 0. showbase is 0200                       >
    < 1. showpoint is 0400                      >
    < 2. uppercase is 01000                     >
    < 3. showpos is 02000                       >
    < 4. scientific is 04000                    >
    < 5. fixed is 010000                        >
    < 6. unitbuf is 020000                      >
    < 7. stdio is 040000                        >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "iosenum4()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#endif

// global variable declarations
/*--------------------------------------------------------------------*/
void iosenum4_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();

#if defined(USING_OLD_IOS)

/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator showbase of the format control enumeration");

    if (ios::showbase!= 0200)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator showpoint of the format control enumeration");

    if (ios::showpoint != 0400)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator uppercase of the format control enumeration");

    if (ios::uppercase != 01000)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator showpos of the format control enumeration");

    if (ios::showpos != 02000)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator scientific of the format control enumeration");

    if (ios::scientific != 04000)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator fixed of the format control enumeration");

    if (ios::fixed != 010000)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block6: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator unitbuf of the format control enumeration");

    if (ios::unitbuf != 020000)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block7: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator stdio of the format control enumeration");

    if (ios::stdio != 040000)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
#endif 
        anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istream1.c ===
/* @(#)File: istream1.C    Version: 1.1    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream and ostream
    < classes. ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the input/output operations of the stream classes.
    < 
    < 0. get() returns a single character....
    <
    < 1. get() returns EOF. ios::failbit is never set.
    <
    < 2. gcount() returns the number of characters read in the
    <    last unformatted input.
    <
    < 3. gcount() returns the number of characters read in the
    <    last unformatted input. In this test we try 
    <    to read more bytes than are present.
    <
    < 4. get(char *, int, char) extracts characters stopping
    <    at a delimiter. The delimiter defaults to '\n'.
    <
    < 5. get(char *, int, char) extracts characters stopping
    <    at a delimiter. The delimiter may be specified.
    <
    < 6. get(char &) gets a single character.
    <

>HOW:   < The program uses a strstreambuf to hold data.
    <
    < 0.  Write a known string to a buffer. Then read the first
    <     character of the buffer with get. Verify the character.
    <
    < 1. Cause the buffer to be empty. Try and read the first 
    <    character. Verify that get() returns EOF.
    <    Verify that ios::failbit is not set.
    < 
    < 2. Compare gcount() to the length of a string read into 
    <    a buffer.
    < 
    < 3. Compare gcount() to the length of a string read into 
    <    a buffer, noting that we tried to read more bytes than
    <    were present.
    <
    < 4. Use get to read a string and verify that the string
    <    is correct.
    <
    < 5. Same as 4 but with a different delimiter.
    <
    < 6. Use get(char &) and verify the character.
    <

>MODS:  < Changed "testhead.h" to "testhead.h"
    <    Changed definition of failure() to a prototype.
    < Vers 1.1, date: 5/31/90: DRE
    <   Added the check to block 1 that ios::failbit is not set.
    < Vers 1.0, date: 3/2/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    <
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif
#include "testhead.h"    


static char progname[] = "istream1()";

    // The character buffer used by the streambuf.
static const int len = 1024;
static char strbuf[len];
    // A second buffer for I/O
static char buf[len];
static const char * ptr;

    // Write a null-terminated string into a strstreambuf
    // Don't write the NULL.
static int write(strstreambuf & sb, const char * s)
{
    while (*s)
    if (sb.sputc(*s++) == EOF) 
        return EOF;
    return 0;
}

/*--------------------------------------------------------------------*/
void istream1_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page.\n");
    DbgPrint("Testing get(), not at EOF.\n");

    {
        strstreambuf sb(strbuf,len,strbuf);
        ptr = "Hello";
        if (write(sb,ptr) != EOF) {
            istream is(&sb);
            char c;
            if (!is.good())
                failure("Couldn't open stream buffer.");
            else 
                if ((c = is.get()) == EOF) 
                    failure("Couldn't read character.");
                else if (c != *ptr)
                    failure("Read wrong character.");
        }
        else
            failure("Write to test-buffer failed.");
    }

    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page.\n");
    DbgPrint("Testing get() from a strstreambuf at EOF.\n");

    {
        strstreambuf sb;
        istream is(&sb);
        if (!is.good())
        failure("Couldn't open data file.");
        else {
        char c;
        if ((c=is.get()) != EOF) {
            failure("Didn't return EOF.");
            DbgPrint("Got %c(%d).",c,c);
        }
#if defined(USING_OLD_IOS)
        if (is.rdstate() & ios::failbit)
            failure("ios::failbit was set.");
#else
        if (!(is.rdstate() & ios::failbit))
            failure("ios::failbit was not set.");
#endif 
        }
    }
    
    
    blexit();
/*--------------------------------------------------------------------*/
block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page.\n");
    DbgPrint("Testing gcount() after a read.\n");
    
    {
        strstreambuf sb(strbuf,len,strbuf);
        ptr = "Hello";
        if (write(sb,ptr) != EOF) {
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else {
            *buf = 0;
            is.read(buf,5);
            if (!is)
            failure("Couldn't read string.");
            else
            if (((size_t)is.gcount()) != strlen(ptr)) {
                failure("gcount() gives wrong count.");
                DbgPrint( "gcount(%d), strlen(%d)\n",
                    is.gcount(), strlen(ptr));
            }
        }
        }
        else
            failure("Write to test-buffer failed.");
    }

    blexit();
/*--------------------------------------------------------------------*/
block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page.\n");
    DbgPrint("Testing gcount() after a too large read.\n");
    
    {
        strstreambuf sb;
        ptr = "Hello";
        if (write(sb,ptr) != EOF) {
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data file.");
        else {
            *buf = '\0';
            is.read(buf,len);
            if (((size_t)is.gcount()) != strlen(ptr)) {
                failure("gcount() gives wrong count.");
                DbgPrint( "gcount(%d), strlen(%d)\n",
                    is.gcount(), strlen(ptr));
            }
        }
        }
        else
        failure("Write to test-buffer failed.");
    }

    blexit();
/*--------------------------------------------------------------------*/
block4: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page.\n");
    DbgPrint("get(char *, int, char) reads to a delimiter.\n");
    
    {
        strstreambuf sb(strbuf,len,strbuf);
        ptr = "word1 word2 word3\n";
        if (write(sb,ptr) != EOF) {
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data file.");
        else {
            *buf = 0;
            is.get(buf,len,'\n');
            strcat(buf,"\n");
            if (strcmp(buf,ptr)) {
            failure("Got the wrong string.");
            DbgPrint("Expected '%s', got '%s'.\n",
                ptr, buf);
            }
        }
        }
        else
        failure("Write to test-buffer failed.");
    }

    blexit();
/*--------------------------------------------------------------------*/
block5: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page.\n");
    DbgPrint("get(char *, int, char) reads to a delimiter.\n");
    DbgPrint("This time change the delimiter.\n");
    
    {
        strstreambuf sb(strbuf,len,strbuf);
        ptr = "word1 word2 word3\n";
        if (write(sb,ptr) != EOF) {
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data file.");
        else {
            *buf = 0;
            is.get(buf,len,' ');  // new delimiter ' '
            if (strcmp(buf,"word1")) {
            failure("Got the wrong string.");
            DbgPrint("Expected '%s', got '%s'.\n",
                "word1", buf);
            }
        }
        }
        else
        failure("Write to test-buffer failed.");
    }

    blexit();
/*--------------------------------------------------------------------*/
block6: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page.\n");
    DbgPrint("get(char &) extracts a single character.\n");
    
    {
        strstreambuf sb(strbuf,len,strbuf);
        ptr = "Goodbye\n";
        if (write(sb,ptr) != EOF) {
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data file.");
        else {
            char c;
            is.get(c);
            if (c != *ptr)
                failure("Got the wrong character.");
        }
        }
        else
        failure("Write to test-buffer failed.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istream2.c ===
/* @(#)File: istream2.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream and ostream
    < classes. ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the input operations of the istream classes.
    < 
    < 0. getline(char *, int, char) reads characters and a delimiter
    <
    < 1. same but with a different delimiter
    <
    < 2. When the delimiter and the trailing \0 character would
    <    overflow the array the delimiter is not read. The 
    <    delimiter is left in the stream.
    <

>HOW:   < The input tests work by writing something to a strstreambuf 
    < with non-stream I/O followed by reading it back with stream I/O.
    < The output tests work in the reverse direction.
    <
    < 0. Use getline to read a string up to and including a \n.
    <    However getline() does not appear to store the 
    <    delimiter in the buffer. So do a get() to get the
    <    next character and verify that it is the character
    <    following the delimiter.
    <
    < 1. Same as 1 but with a non-default delimiter.
    < 
    < 2. Read a string where the delimiter would not leave room in
    <    the array for the trailing \0, then verify that a get()
    <    returns the delimiter.
    < 

>MODS:  < Vers 1.0, date: 3/2/90 Created: DRE

>BUGS:  < None known.
    
======================================================================*/

/***************************************************************************
Micorosoft Revision History:

    Date        emailname       description
----------------------------------------------------------------------------
    02-23-95    a-timke         Conflict with var 'small' due from system
                                header rpcndr.h.
----------------------------------------------------------------------------
****************************************************************************/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <strstrea.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"    


static char progname[] = "istream2()";

    // Write a null-terminated string into a strstreambuf
    // Don't write the NULL.
static int write(strstreambuf & sb, const char * s)
{
    while (*s)
    if (sb.sputc(*s++) == EOF) 
        return EOF;
    return 0;
}

    // The character buffer used for I/O.
static const int len = 1024;
static char buf[len];
static const char * ptr;

/*--------------------------------------------------------------------*/
void istream2_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: getline().\n");
    DbgPrint("Testing getline(), read string and delimiter.\n");

    {
        strstreambuf sb;
        ptr = "Hello Goodbye \n1\n";
        const char * part = "Hello Goodbye ";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
        failure("Couldn't open data buffer.");
        else  {
        *buf = 0;
        is.getline(buf,len);    // default delimiter '\n'
        if (strcmp(buf,part) || is.get() != '1')
            failure("Extracted wrong string.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: getline().\n");
    DbgPrint("Testing getline(), read string and delimiter.\n");
    DbgPrint("Specify non-default delimiter.\n");

    {
        ptr = "Hello Goodbye \n";
        const char * part = "Hello";
        strstreambuf sb;
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
        failure("Couldn't open data buffer.");
        else  {
        *buf = 0;
        is.getline(buf,len,' '); // delimiter ' '
        if (strcmp(buf,part) || is.get() != 'G') {
            failure("Extracted wrong string.");
            DbgPrint("Got '%s', expected '%s'\n",
            buf,part);
        }
        }
    }
    
    blexit();
/*--------------------------------------------------------------------*/
block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: getline().\n");
    DbgPrint("Testing getline() filling the buffer.\n");
    
    {
        ptr = "Hello\nGoodbye\n";
        const int k_nSmall = 6;
        const char * smallptr = "Hello";    // 5 chars plus '\0'
        strstreambuf sb;
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
        failure("Couldn't open data buffer.");
        else  {
        *buf = '\0';
        is.getline(buf,k_nSmall); 
#if defined(USING_OLD_IOS)
        if (strcmp(buf,smallptr) || is.get() != '\n') {
#else
            if (strcmp(buf,smallptr)) {         // '\n' is eaten.
#endif 
            failure("Extracted wrong string.");
            DbgPrint("Got '%s', expected '%s'\n",
            buf,smallptr);
        }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/

    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\iosenum3.c ===
/* @(#)File: iosenum3.C     Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the values of some enumerators in the class   >
    < ios's format control enumeration.  The rest of the        >
    < enumerators in this enumeration are tested in iosenum4.C  >

>HOW:   < Each block tests the value of one enumerator.         >

    < 0. skipws is 1                        >
    < 1. left is 2                          >
    < 2. right is 4                         >
    < 3. internal is 010                        >
    < 4. dec is 020                         >
    < 5. oct is 040                         >
    < 6. hex is 0100                        >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "iosenum3()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#endif

// global variable declarations
/*--------------------------------------------------------------------*/
void iosenum3_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
#if defined(USING_OLD_IOS)

/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator skipws of the format control enumeration");

    if (ios::skipws!= 1)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator left of the format control enumeration");

    if (ios::left != 2)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator right of the format control enumeration");

    if (ios::right != 4)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator internal of the format control enumeration");

    if (ios::internal != 010)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator dec of the format control enumeration");

    if (ios::dec != 020)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator oct of the format control enumeration");

    if (ios::oct != 040)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
block6: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test enumerator hex of the format control enumeration");

    if (ios::hex != 0100)
        fail ("incorrect enumerator value");

        blexit();
/*--------------------------------------------------------------------*/
#endif
        anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\iosenum5.c ===
/* @(#)File: iosenum5.C     Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyuppercase 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, IOS(3C++)        >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests the constant static members used to collec-   >
    < tively identify a collection of format bits.          >

>HOW:   < Each block tests one such static member.          >

    < 0. The manual states (p.4) that "the fields left, right and   >
    <    internal are collectively identified by the static member  >
    <    ios::adjustfield."  This statement is interpreted as   >
    <    saying that adjustfield == left | right | internal.  This  >
    <    block checks that is true.                 >

    < 1. The manual states (p.4) that "the fields dec, oct and  >
    <    hex are collectively identified by the static member   >
    <    ios::basefield."  This statement is interpreted as     >
    <    saying that basefield == dec | oct | hex.  This block  >
    <    checks that is true.                   >

    < 2. The manual states (p.5) that "the fields scientific and
    <    fixed are collectively identified by the static member >
    <    ios::floatfield."  This statement is interpreted as    >
    <    saying that floatfield == scientific | fixed.  This block  >
    <    checks that is true.                   >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "iosenum5()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#endif

// global variable declarations
/*--------------------------------------------------------------------*/
void iosenum5_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test that ios:: adjustfield collectively identifies");
    print("ios::left, ios::right, ios::internal.");

    if (ios::adjustfield != (ios::left | ios::right | ios::internal))
        fail ("unexpected value");

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test that ios:: basefield collectively identifies");
    print("ios::dec, ios::oct, ios::hex.");

    if (ios::basefield != (ios::dec | ios::oct | ios::hex))
        fail ("unexpected value");

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, IOS(3C++)");
    print("Test that ios:: floatfield collectively identifies");
    print("ios::scientific and ios::fixed.");

    if (ios::floatfield != (ios::scientific | ios::fixed))
        fail ("unexpected value");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istream5.c ===
/* @(#)File: istream5.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream and ostream
    < classes. ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the input operations of the istream classes.
    < 
    < 0. Putback can be used to put back the last character
    <    extracted from a stream. Get character with get().
    < 
    < 1. Get character with read.
    <
    < 2. Get character with >>
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < 0-2. Get a character, put it back, and get it again.
    <      Verify the character is the same. The blocks differ
    <      in how they get the character, get(), read() or >>.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/3/90 Created: DRE

>BUGS:  < None known.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "istream5()";

/*--------------------------------------------------------------------*/
void istream5_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: peek().\n");
    DbgPrint("Putback can unget the last extracted character.\n");
    DbgPrint("Extracting a character with istream::get().\n");

    {
        char c = 'A';
        strstreambuf sb;
        sb.sputc(c);
        istream is(&sb);
        if (!is.good())
        failure("Couldn't open data buffer.");
        else  {
        if (is.get() != c)
            failure("Got wrong character.");
        else {
            is.putback(c);
            if (is.get() != c)
            failure("After putback() got wrong character.");
        }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: peek().\n");
    DbgPrint("Putback can unget the last extracted character.\n");
    DbgPrint("Extracting a character with istream::read().\n");

    {
        const char c = 'B';
        char new_c;
        strstreambuf sb;
        sb.sputc(c);
        istream is(&sb);
        if (!is.good())
        failure("Couldn't open data buffer.");
        else  {
        is.read(&new_c,1);
        if (is.gcount() != 1)
            failure("Couldn't read a character.");
        else if (new_c != c)
            failure("Read wrong character.");
        else {
            is.putback(new_c);
            is.read(&new_c,1);
            if (is.gcount() != 1)
            failure("Couldn't read a character after putback.");
            else if (new_c != c)
            failure("After putback() got wrong character.");
        }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: peek().\n");
    DbgPrint("Putback can unget the last extracted character.\n");
    DbgPrint("Extracting a character with istream::operator>>(char &).\n");

    {
        const char c = 'B';
        char new_c;
        strstreambuf sb;
        sb.sputc(c);
        istream is(&sb);
        if (!is.good())
        failure("Couldn't open data buffer.");
        else  {
        is >> new_c;
        if (!is)
            failure("Couldn't read a character.");
        else if (new_c != c)
            failure("Read wrong character.");
        else {
            is.putback(new_c);
            is >> new_c;
            if (!is)
            failure("Couldn't read a character after putback.");
            else if (new_c != c)
            failure("After putback() got wrong character.");
        }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/

    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istream4.c ===
/* @(#)File: istream4.C    Version: 1.0    Date: 11/20/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream and ostream
    < classes. ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the input operations of the istream classes.
    < 
    < 0. Peek returns the next character without extracting it.
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < 0. Peek at a character and then extract it to verify that
    <    the peek did not extract the character.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/2/90 Created: DRE

>BUGS:  < None known.
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "istream4()";

    // Write a null-terminated string into a strstreambuf
    // Don't write the NULL.
static int write(strstreambuf & sb, const char * s)
{
    while (*s)
    if (sb.sputc(*s++) == EOF) 
        return EOF;
    return 0;
}

    // The character buffer used for I/O.
static const int len = 1024;
static const char * ptr;

/*--------------------------------------------------------------------*/
void istream4_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: peek().\n");
    DbgPrint("Peek() returns a byte without extracting it.\n");

    ptr = "0123456789\n";
    strstreambuf sb;
    write(sb,ptr);
    char c;
    istream is(&sb);
    if (!is.good())
        failure("Couldn't open data buffer.");
    else  {
        c = is.peek();
        if (is.get() != c || c != *ptr)
            failure("Didn't peek correctly.");
    }

    blexit();
/*--------------------------------------------------------------------*/

    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istream3.c ===
/* @(#)File: istream3.C    Version: 1.1    Date: 11/20/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream class.
    < ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the input operations of the istream classes.
    < 
    < 0. ignore(int n, int delim) extracts and throws away up to
    <    n characters.
    <
    < 1. ignore(int n, int delim) stops if delim is extracted.
    <

>HOW:   < The program uses a strstreambuf for its stream buffer.
    <
    < 0. Ignore some characters and check that a subsequent
    <    get() operation returns the correct character.
    <
    < 1. Ignore some characters but have a delimiter in the input
    <    before the limit is reached. Verify that the next character
    <    read is the correct one.
    < 

>MODS:  < Vers 1.1, date: 05/31/90 DRE Corrected some printfs
    < Vers 1.0, date: 03/02/90 DRE created

>BUGS:  < None known.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "istream3()";

    // Write a null-terminated string into a strstreambuf
    // Don't write the NULL.
static int write(strstreambuf & sb, const char * s)
{
    while (*s)
    if (sb.sputc(*s++) == EOF) 
        return EOF;
    return 0;
}

    // The character buffer used for I/O.
static const int len = 1024;
static const char * ptr;

/*--------------------------------------------------------------------*/
void istream3_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: ignore().\n");
    DbgPrint("Testing ignore(), extract/discard characters.\n");

    int count = 6;
    ptr = "Hello Goodbye \n1\n";
    char c = ptr[count];

    {
        strstreambuf sb;
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
        failure("Couldn't open data file.");
        else  {
        is.ignore(count,'\n');  
        if (is.get() != c)
            failure("Ignored wrong characters.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: ignore().\n");
    DbgPrint("Testing ignore(), extract/discard characters.\n");
    DbgPrint("Ignore should stop after a delimiter.\n");

    ptr = "Hello Goodbye \n1\n";
    char delim = 'o';
    c = ' ';

    {
        strstreambuf sb;
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
        failure("Couldn't open data file.");
        else  {
        is.ignore(count,delim); 
        if (is.get() != c)
            failure("Ignored wrong characters.");
        }
    }
    
    blexit();
/*--------------------------------------------------------------------*/

    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istream6.c ===
/* @(#)File: istream6.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream and ostream
    < classes. ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the seek/tell operations of the istream classes.
    < 
    < These tests use the seekg positioning member to adjust
    < the get pointer of the streambuf. 
    <
    < 0. Positioning at the beginning of the buffer after reading
    <    a few bytes.
    < 
    < 1. Positioning at the beginning of the buffer after EOF.
    < 
    < 2. Positioning at the end of the buffer before any reads.
    <
    < 2. Positioning at the end of the buffer after reading a few 
    <    characters.
    <
    < 4. Positioning at a known spot in the buffer.
    <
    < 5. Positioning at an offset from the beginning.
    <
    < 6. Positioning at an offset from the end.
    <
    < 7. Positioning at an offset from the end. This time without
    <    extracting any characters before seeking.
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < 0. Put something into the buffer. Read a few bytes remembering
    <    the first one read. Seek to the beginning, reread and check
    <    the first byte.
    <
    < 1. Put something into the buffer. Remember the first byte and
    <    extract to EOF. Seek to the beginning, reread and check
    <    the first byte. This block uses an istrstream.
    <
    < 2. Jump to the end of the buffer and try to read. Should return
    <    EOF. Uses an istrstream.
    < 
    < 3. Same as 2 but read a few characters first.
    < 
    < 4. Read a few characters. Use tellg() to record the current 
    <    position. Extract and remember the next character. Extract
    <    a few more characters. Jump to the recorded position. Extract
    <    a character and verify it's the same as the remembered one.
    <
    < 5. Read three characters and save the third. Then read several
    <    more. Then reposition to 2 off the beginning and try to read
    <    the saved character.
    <
    < 6. Jump to -1 off the end and check what character we find.
    <
    < 7. Same as 6 except we don't extract a character before the
    <    seek. Use an istrstream.

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < 3/4/90: Modified three blocks to use istrstreams instead of
    < istreams. One still fails, block 1, the other 2 succeed.
    < Vers 1.0, date: 3/3/90 Created: DRE

>BUGS:  < The Stream library fails block 1. After reading a strstreambuf
    < the EOF and seeking to the beginning, the next read still
    < yields EOF.
    <
    
======================================================================*/

#if defined(USING_OLD_IOS)
    #include <iostream.h>
#else
    #include <iostream>
    #include <strstream>
#endif

#include "testhead.h"


static char progname[] = "istream6()";

// Write a null-terminated string into a strstreambuf
// Don't write the NULL.
static int write(strstreambuf & sb, const char * s)
{
    while (*s)
        if (sb.sputc(*s++) == EOF)
            return EOF;
    return 0;
}

static char * ptr;
static char c;

/*--------------------------------------------------------------------*/
void istream6_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: seekg().\n");
    DbgPrint("Seeking to the start of the buffer after extracting.\n");

    {
        strstreambuf sb;
        char remembered_char;
        ptr = "0123456789";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> remembered_char;
            if (remembered_char != *ptr)
                failure("Didn't extract correct character.");
            else
            {
            // Extract a few extra characters
                is >> c;
                is >> c;
                is >> c;
                if (!is)
                    failure("Errors during extraction.");
                else
                {
                    is.seekg(0,ios::beg);
                    if (is.get() != remembered_char)
                        failure("After seek got wrong character.");
                }
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: seekg().\n");
    DbgPrint("Seeking to the start of the buffer after EOF.\n");

    {
        char remembered_char;
        ptr = "0123456789";
        istrstream is(ptr);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> remembered_char;
            if (remembered_char != *ptr)
                failure("Didn't extract correct character.");
            else
            {
            // Extract a few extra characters
                while ((c = is.get()) != EOF)
                    ;
#if !defined(USING_OLD_IOS)
                is.clear();
#endif 
                if (is.seekg(0,ios::beg) == NULL)
                    failure("Error on seek.");
                else
                    if ((c = is.get()) != remembered_char)
                {
                    failure("After seek got wrong character.");
                    DbgPrint("Got %c(%d), not %c\n",c,c,*ptr);
                }
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: seekg().\n");
    DbgPrint("Seek to the end of the buffer and try to read.\n");

    {
        ptr = "0123456789";
        istrstream is(ptr);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is.seekg(0,ios::end);
            if ((c = is.get()) != EOF)
            {
                failure("After seeking to end didn't read EOF.");
                DbgPrint( "Got character %d(%c).\n",c,c);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: seekg().\n");
    DbgPrint("Read a few, then seek to the end of the buffer\n");
    DbgPrint("and try to read.\n");

    {
        strstreambuf sb;
        ptr = "0123456789";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> c;
            is >> c;
            is.seekg(0,ios::end);
            if ((c = is.get()) != EOF)
            {
                failure("After seeking to end didn't read EOF.");
                DbgPrint( "Got character %d(%c).\n",c,c);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: tellg().\n");
    DbgPrint("Use tellg() to return to a position.\n");

    {
        strstreambuf sb;
        streampos savepos;
        char savechar;
        ptr = "0123456789";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> c;
            is >> c;
            savepos = is.tellg();
            is >> savechar;
            is >> c;
            is >> c;
            is.seekg(savepos);
            is >> c;
            if (c != savechar)
                failure("After seek to saved position read different char.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block5: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: seekg().\n");
    DbgPrint("Jump to an offset from the beginning.\n");

    {
        strstreambuf sb;
        char savechar;
        ptr = "0123456789";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> c;
            is >> c;
            is >> savechar;
            is >> c;
            is >> c;
            is >> c;
            is.seekg(2,ios::beg);
            is >> c;
            if (c != savechar)
                failure("After seek to 2 after beginning read wrong char.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block6: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: seekg().\n");
    DbgPrint("Jump to an offset from the end.\n");

    {
        strstreambuf sb;
        ptr = "0123456789";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> c;
            is.seekg(-1,ios::end);
            is >> c;
            if (c != ptr[strlen(ptr)-1])
            {
                failure("After seek to 1 before end read wrong char.");
                DbgPrint("Read %c(%d), wanted %c\n",
                        c, c, ptr[strlen(ptr)-1]);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block7: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: seekg().\n");
    DbgPrint("Jump to an offset from the end.\n");
    DbgPrint("Don't extract any characters first.\n");

    {
        ptr = "0123456789";
        istrstream is(ptr);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is.seekg(-1,ios::end);
            is >> c;
            if (c != ptr[strlen(ptr)-1])
            {
                failure("After seek to 1 before end read wrong char.");
                DbgPrint("Read %c(%d), wanted %c\n",
                        c, c, ptr[strlen(ptr)-1]);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istream8.c ===
/* @(#)File: istream8.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream and ostream
    < classes. ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the istream manipulators.
    <
    < 0. ws extracts whitespace characters
    <
    < 1. dec sets the conversion base format flag to 10.
    <
    < 2. oct sets the conversion base format flag to 8.
    <
    < 3. hex sets the conversion base format flag to 16.
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < 0. Write a string with leading whitespace to a buffer.
    <    Extract the whitespace with the manipulator. Then
    <    verify that the next character is correct.
    <
    < 1. Clear the basefield bits. Then set them to 10 with the
    <    dec manipulator and check them.
    <
    < 2. Set the base to 8 with the oct manipulator and check it.
    <
    < 3. Set the base to 16 with the hex manipulator and check it.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/4/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    <
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "istream8()"; 

// Write a null-terminated string into a strstreambuf
// Don't write the NULL.
static int write(strstreambuf & sb, const char * s)
{
    while (*s)
        if (sb.sputc(*s++) == EOF)
            return EOF;
    return 0;
}

/*--------------------------------------------------------------------*/
void istream8_main()                  
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: Manipulators.\n");
    DbgPrint("Testing the ws manipulator.\n");

    {
        char * ptr = " \t\nabc";
        strstreambuf sb;
        write(sb,ptr);
        istream is(&sb);
        if (!is)
            failure("Can not attach stream to buffer.");
        else
        {
            is >> ws;
            char c;
            is >> c;
            if (c == ' ' || c == '\t' || c == '\n')
                failure("Didn't extract whitespace.");
            else if (c != 'a')
                failure("Got wrong character.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: Manipulators.\n");
    DbgPrint("Testing the dec manipulator.\n");

    {
        strstreambuf sb;
        istream is(&sb);
        if (!is)
            failure("Can not attach stream to buffer.");
        else
        {
            is.setf(0,ios::basefield);
            is >> dec;
            if (! (is.setf(0,ios::basefield) & ios::dec))
            {
            // A failure here means one of two things:
            //   1) the bit was not set, or,
            //   2) setf() returned the wrong value.
                failure("ios::dec apparently not set.");
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: Manipulators.\n");
    DbgPrint("Testing the oct manipulator.\n");

    {
        strstreambuf sb;
        istream is(&sb);
        if (!is)
            failure("Can not attach stream to buffer.");
        else
        {
            is >> oct;
            if (! (is.setf(0,ios::basefield) & ios::oct))
                failure("ios::oct apparently not set.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: Manipulators.\n");
    DbgPrint("Testing the hex manipulator.\n");

    {
        strstreambuf sb;
        istream is(&sb);
        if (!is)
            failure("Can not attach stream to buffer.");
        else
        {
            is >> hex;
            if (! (is.setf(0,ios::basefield) & ios::hex))
                failure("ios::hex apparently not set.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istream7.c ===
/* @(#)File: istream7.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream class:
    < ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the formatted input operations.
    < 
    < 0.  operator>>(char *) extracts characters until it reaches
    <     a whitespace. It does not extract the whitespace. 
    < 
    < 1.  operator>>(unsigned char *) same as previous block.
    < 
    < 2.  operator>>(char *): if width() is nonzero it is taken to  
    <     to be the size of the array and no more than width-1
    <     characters are extracted.
    < 
    < 3.  operator>>(char &)
    < 
    < 4.  operator>>(unsigned char &)
    < 
    < 5.  operator>>(short &) The string may have a leading '-'
    <
    < 6.  operator>>(short &) The string may have a leading '+'
    <
    < 7.  operator>>(int &) The string may represent a hex number
    <
    < 8.  operator>>(unsigned int &) The string may represent an 
    <     octal number
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < Tests 0-8 all put a known string in the buffer,
    <       then extract it an verify its value.
    <
    < 0.  Write some words into a buffer then use the extraction
    <     operator to remove the first one. Then use get() to 
    <     read the whitespace following the first word. Verify
    <     the word read.
    <
    < 1.  Same as previous block but with a buffer pointer of
    <     type unsigned char *.
    <
    < 2.  Extract a string but first set the width of the istream
    <     so that it can't extract the whole string. Verify that
    <     it extracts the correct number of characters.
    <
    < 3.  Extract and check a character
    <
    < 4.  Extract and check an unsigned character
    <
    < 5.  Extract and check a short, make it negative
    <
    < 6.  Extract and check an unsigned short, make it positive.
    <     The manual page does not indicate that unsigned variables
    <     can not be converted from signed strings.
    <
    < 7.  Extract and check a hex integer. If none of the base bits
    <     are set the normal C++ number base conventions are followed.
    <     So the number is stored in the form 0x????. So we turn off all
    <     of the ios::basefield bits.
    <
    < 8.  Extract and check a octal int. The basefield bits are turned off.

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/4/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    <
    
======================================================================*/

#if defined(USING_OLD_IOS)
    #include <iostream.h>
#else
    #include <iostream>
    #include <strstream>
#endif

#include "testhead.h"


static char progname[] = "istream7()";

// Write a null-terminated string into a strstreambuf
// Don't write the NULL.
static int write(strstreambuf & sb, const char * s)
{
    while (*s)
        if (sb.sputc(*s++) == EOF)
            return EOF;
    return 0;
}

static char * ptr;

/*--------------------------------------------------------------------*/
void istream7_main()                  
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(char *).\n");

    {
        strstreambuf sb;
        char inbuf[128];
        ptr = "word1\tword2\tword3\n";  // tabs are whitespace
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is.width(128);
            is >> inbuf;
            if (strcmp(inbuf,"word1"))
                failure("Extracted wrong word.");
            else
                // Extract a few extra characters
                if (is.get() != '\t')
                    failure("After extracting string didn't get() whitespace.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(unsigned char *).\n");

    {
        strstreambuf sb;
        unsigned char inbuf[128];
        ptr = "word3\tword4\tword5\n";  // tabs are whitespace
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is.width(128);
            is >> inbuf;
            if (strcmp((const char *)inbuf,"word3"))
                failure("Extracted wrong word.");
            else
                // Extract a few extra characters
                if (is.get() != '\t')
                failure("After extracting string didn't get() whitespace.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(char *) with width.\n");

    {
        strstreambuf sb;
        char inbuf[128];
        ptr = "word6\tword7\tword8\n";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is.width(2);
            is >> inbuf;
            if (strcmp(inbuf,"w"))
            {
                failure("Extracted wrong word.");
                DbgPrint("Got '%s' not '%s'\n",inbuf,"w");
            }
            else
                // Extract a few extra characters
                if (is.get() != 'o')
                failure("After extracting string didn't get() right character.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(char &).\n");

    {
        strstreambuf sb;
        char c;
        ptr = "abcdefghijklmnopqrstuvwxyz";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> c;
            if (c != *ptr)
            {
                failure("Extracted wrong character.");
                DbgPrint("Got '%c'(%d) not '%c'(%d)\n",
                        c, c, *ptr, *ptr);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(unsigned char &).\n");

    {
        strstreambuf sb;
        unsigned char c;
        ptr = "abcdefghijklmnopqrstuvwxyz";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> c;
            if (c != *ptr)
            {
                failure("Extracted wrong character.");
                DbgPrint("Got '%c'(%d) not '%c'(%d)\n",
                        c, c, *ptr, *ptr);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block5: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(short &).\n");

    {
        strstreambuf sb;
        short s;
        ptr = "-123 456 789";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> s;
            if (s != -123)
            {
                failure("Extracted wrong number.");
                DbgPrint("Got %d not %d\n", s, 123);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block6: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(unsigned short &).\n");

    {
        strstreambuf sb;
        unsigned short s;
        ptr = "+123 456 789";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> s;
            if (s != 123)
            {
                failure("Extracted wrong number.");
                DbgPrint("Got %d not %d\n", s, 123);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block7: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(int &) formatted in hex.\n");
    DbgPrint("All formatting bits turned off.\n");

    {
        strstreambuf sb;
        int i;
        ptr = "0x9f8A 654 321";
        write(sb,ptr);
        istream is(&sb);
        is.setf(0,ios::basefield);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> i;
            if (i != 0x9f8A)
            {
                failure("Extracted wrong number.");
                DbgPrint("Got %d not %d\n", i, 0x9f8A);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block8: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(unsigned int &) formatted in octal.\n");
    DbgPrint("All formatting bits turned off.\n");

    {
        strstreambuf sb;
        unsigned int i;
        ptr = "01234 654 321";
        write(sb,ptr);
        istream is(&sb);
        is.setf(0,ios::basefield);   // Turn off formatting bits
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> i;
            if (i != 01234)
            {
                failure("Extracted wrong number.");
                DbgPrint("Got %d not %d\n", i, 01234);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istreama.c ===
/* @(#)File: istreamA.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream class:
    < ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the formatted input operations.
    < 
    < 0. ins >> x always returns ins.
    <
    < 1. ins >> x sets badbit if it can't extract any characters.
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < All these tests put a known string in the buffer,
    <       then extract it an verify its value.
    <
    < 0. Extract a char. Check that the return value equals the stream.
    <
    < 1. Extract more characters than are available and look for badbit.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 5/12/90 Created: DRE

>BUGS:  < Block 1 is failed by cfront 2.0 and its libraries.
    < The ISTREAM(3C++) manual page dated June 14, 1989 says
    < with regards to `cin >> x': ``ios::badbit indicates that
    < attempts to extract characters failed.'' 
    < When the cause of the failure is EOF then that does not happen.
    < Instead it sets eofbit and failbit. This seems like appropriate
    < behavior, however it diverges from the written specification,
    < therefore users should be notified. For that reason this test
    < is included even though it is the manual page that is wrong,
    < not the software.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "istreamA()";

// Write a null-terminated string into a strstreambuf
// Don't write the NULL.
static int write(strstreambuf & sb, const char * s)
{
    while (*s)
        if (sb.sputc(*s++) == EOF)
            return EOF;
    return 0;
}

static char * ptr;

/*--------------------------------------------------------------------*/
void istreama_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>> returns the stream.\n");

    {
        strstreambuf sb;
        char c;
        ptr = "01234 654 321";
        write(sb,ptr);
        istream is(&sb);
        if ((is >> c) != is)
            failure("Extraction expression has wrong value.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>> sets ios::badbit if extraction\n");
    DbgPrint("fails.\n");

    {
        strstreambuf sb;
        char c;
        ptr = "0";
        write(sb,ptr);
        istream is(&sb);
        is >> c;
        is >> c;
#if defined(USING_OLD_IOS)
        if ((is.rdstate() & ios::badbit) == 0)
        {
            failure("ios::badbit not set.");
            DbgPrint( "State is 0x%x\n", is.rdstate());
        }
#else 
        if ((is.rdstate() & ios::failbit) == 0)
        {
            failure("ios::failbit not set.");
            DbgPrint( "State is 0x%x\n", is.rdstate());
        }
#endif 
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istream9.c ===
/* @(#)File: istream9.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream class:
    < ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the formatted input operations.
    < 
    < 0.  operator>>(long &), forcing hex representation
    <     octal number
    <
    < 1. operator>>(unsigned long &), forcing octal
    <
    < 2. operator>>(float &)
    <
    < 3. operator>>(double &)
    <
    < 4. operator>>(streambuf *) takes characters out of the 
    <     istream and inserts them into the streambuf.
    <
    < 5. operator>>(int) sets ios::failbit if there are no digits
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < All these tests put a known string in the buffer,
    <       then extract it an verify its value.
    <
    < 0. Extract and check a hex long. Turn on hex base.
    <
    < 1. Extract and check an octal unsigned long. Turn on octal base.
    <
    < 2. Extract and check a float. We must not use the float as a 
    <    constant in the comparison with the extracted value. Instead
    <    we must use another float variable. Otherwise, the float
    <    constant is promoted to double and we might possibly compare
    <    incorrectly. This happens if the particular float chosen is
    <    not exactly representable in a float on the current architecture.
    <
    < 3. Extract and check a double. 
    <
    < 4. Extract into a strstreambuf and then get the characters out of the
    <    buffer.
    <
    < 5. Try and extract an int when there are no digits, then check that
    <    failbit is set.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/4/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "istream9()";

// Write a null-terminated string into a strstreambuf
// Don't write the NULL.
static int write(strstreambuf & sb, const char * s)
{
    while (*s)
        if (sb.sputc(*s++) == EOF)
            return EOF;
    return 0;
}

static char * ptr;

/*--------------------------------------------------------------------*/
void istream9_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(long &) formatted in hex.\n");
    DbgPrint("Turning on hex format bit.\n");

    {
        strstreambuf sb;
        long l;
        ptr = "01234 654 321";
        write(sb,ptr);
        istream is(&sb);
        // Turn on hex format, could also use a manipulator
        is.setf(ios::hex,ios::basefield);    
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> l;
            if (l != 0x01234)
            {
                failure("Extracted wrong number.");
                DbgPrint("Got %d not %d\n", l, 0x01234);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(unsigned long &) formatted in octal.\n");
    DbgPrint("Turning on octal format bit.\n");

    {
        strstreambuf sb;
        unsigned long l;
        ptr = "678 654 321";
        write(sb,ptr);
        istream is(&sb);
        // Turn on hex format, could also use a manipulator
        is.setf(ios::oct,ios::basefield);    
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> l;
            if (l != 067)
            {
                failure("Extracted wrong number.");
                DbgPrint("Got %d not %d\n", l, 067);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(float &).\n");

    {
        strstreambuf sb;
        float result = (float)-678.123;
        float f;
        ptr = "-678.123 654.0 321";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> f;
            if (f != result)
            {
                failure("Extracted wrong number.");
                DbgPrint("Got %f not %f\n", f, result);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(double &).\n");

    {
        strstreambuf sb;
        double result = +6.78e2;
        double d;
        ptr = "+6.78e2 654.0 321";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> d;
            if (d != result)
            {
                failure("Extracted wrong number.");
                DbgPrint("Got %l not %l\n", d, result);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(streambuf *).\n");

    {
        strstreambuf sb;
        strstreambuf dest;
        char buf[10];
        ptr = "abc";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            is >> &dest;
            dest.sgetn(buf,3);
            buf[3] = 0;
            if (strcmp(buf,ptr))
                failure("Failed to extract right string.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block5: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>>(int&) on bad data.\n");

    {
        strstreambuf sb;
        ptr = "a123 xyz\n";
        write(sb,ptr);
        istream is(&sb);
        if (!is.good())
            failure("Couldn't open data buffer.");
        else
        {
            int i;
            is >> i;
            if (!is.fail())
                failure("Failed to set ios::failbit.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istreamb.c ===
/* @(#)File: istreamB.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream class:
    < ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the unformatted input operations.
    < 
    < 0. ins.get(ptr,len,delim) sets failbit if it hits EOF 
    <    before extracting any characters.
    <
    < 1. Assignment of a streambuf* to an istream_withassign
    <    associates the buffer with the stream and initializes
    <    the entire buffer's state.
    <
    < 2. Assignment of an istream* to an istream_withassign 
    <    associates the formers streambuf with the latter,
    <    and reinitializes the latter's state.
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < 0. Extract from an empty buffer with get and look for failbit.
    <
    < 1. Assign a streambuf* to an istream_withassign and check 
    <    the state.
    <
    < 2. Perform the assignment and check the state.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 5/12/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "istreamB()";

/*--------------------------------------------------------------------*/
void istreamb_main()                  
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing operator>> returns the stream.\n");

    {
        strstreambuf sb;
        char ptr[10];
        istream is(&sb);
        is.get(ptr,10,'\n');
        if ((is.rdstate() & ios::failbit) == 0)
            failure("Failbit not set.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          
#if defined(USING_OLD_IOS)

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Assigning a streambuf* to an istream_withassign.\n");

    {
        char ptr[10];
        strstreambuf sb;
        strstreambuf sb2;
        istream_withassign is;
        long oldflags;

        is = &sb;
        if (is.rdbuf() != &sb)
            failure("strstreambuf not associated with istream.");
        oldflags = is.flags();
        // Set the error flag
        is.get(ptr,10,'\n');
        // Verify the error state
        if ((is.rdstate() & ios::failbit) == 0)
            failure("Failbit not set.");
        // Change some flags
        is.flags(oldflags | ios::right | ios::showbase | ios::unitbuf | ios::showpos);
        is = &sb2;
        // Error state should be cleared.
        if (is.rdstate() & ios::failbit)
            failure("Failbit not reset.");
        // Flags should be reset
        if (is.flags() != oldflags)
            failure("Flags not reset.");
    }
#endif 
    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          
#if defined(USING_OLD_IOS)

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Assigning an istream* to an istream_withassign.\n");

    {
        char ptr[10];
        strstreambuf sb;
        strstreambuf sb2;
        istream src(&sb);
        istream src2(&sb2);
        istream_withassign is;
        long oldflags;

        is = src;
        if (is.rdbuf() != src.rdbuf())
            failure("correct streambuf not associated with istream.");
        oldflags = is.flags();
        // Set the error flag
        is.get(ptr,10,'\n');
        // Verify the error state
        if ((is.rdstate() & ios::failbit) == 0)
            failure("Failbit not set.");
        // Change some flags
        is.flags(oldflags | ios::right | ios::showbase | ios::unitbuf | ios::showpos);
        is = src2;
        if (is.rdbuf() != src2.rdbuf())
            failure("second correct streambuf not associated with istream.");
        // Error state should be cleared.
        if (is.rdstate() & ios::failbit)
            failure("Failbit not reset.");
        // Flags should be reset
        if (is.flags() != oldflags)
            failure("Flags not reset.");
    }
#endif 
    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\istreamc.c ===
/* @(#)File: istreamC.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream class:
    < ISTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the unformatted input operations.
    < 
    < 0. With the exception listed below extraction operators
    <    that use format state do not change the format state.
    <
    < 1. Extraction operators that use width reset it.
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < 0. Extract with format and check that format is not unset.
    <
    < 1. Verify that width gets reset after use.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 5/12/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <strstrea.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "istreamC()";

// Write a null-terminated string into a strstreambuf
// Don't write the NULL.
static int write(strstreambuf & sb, const char * s)
{
    while (*s)
        if (sb.sputc(*s++) == EOF)
            return EOF;
    return 0;
}

/*--------------------------------------------------------------------*/
void istreamc_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("Testing that format is not changed when used.\n");

    {
        strstreambuf sb;
        int i;

        write(sb,"0x1f 0x2e\n");
        istream is(&sb);

#if defined(USING_OLD_IOS)
        is.flags(is.flags() | ios::hex);
#else
        is.setf(ios::hex, ios::basefield); // otherwise both ios::dec and
                                           // ios::hex would be set.
#endif 
        if ((is.flags() & ios::hex) == 0)
            failure("Hex flag not set.");
        is >> i;
        if (i != 0x1f)
            failure("Extracted wrong value for first integer.");
        if ((is.flags() & ios::hex) == 0)
            failure("Hex flag reset.");
        is >> i;
        if (i != 0x2e)
            failure("Extracted wrong value for second integer.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: formatted input.\n");
    DbgPrint("After use the width flag is reset to zero.\n");

    {
        char ptr[10];
        strstreambuf sb;
        write(sb,"abcdefg");
        istream is(&sb);

        is.width(1);
        if (is.width(1) != 1)
            failure("Width not set to 1.");
        is >> ptr;
        if (is.width(1) != 0)
            failure("Width was reset.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\manip1.c ===
/* @(#)File: manip1.C    Version: 1.0    Date: 01/02/91               */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular user-defined
    < manipulators. MANIP(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the ability to define manipulators
    < There was one other test in this file but it caused
    < a nonrecoverable compiler error. It was moved to
    < the file manip2.C so that these tests could still
    < compile and run.
    < 
    < 0. A non-parameterized istream manipulator.
    <    Define an istream manipulator to turn off skipws.
    <
    < 1. A non-parameterized ostream manipulator.
    <    Define an ostream manipulator to insert a space.
    <
    < 2. A parameterized ostream manipulator.
    <    Define an ostream manipulator to insert n spaces.
    <
>HOW:   < 0. Define the manipulator. The read from an istream
    <    one string that contains whitespace. Verify that the
    <    whitespace is removed by default. Use the manipulator to 
    <    turn off skipws. Then reread the string and verify the
    <    whitespace is present. The stream buffer used is a
    <    strstreambuf for convenience.
    <
    < 1. Use the manipulator to insert a space and verify the 
    <    result.
    <
    < 2. Use the manipulator to insert several spaces and verify 
    <    the result.

>MODS:  < 11/8/90, DRE: Updated BUGS comments for 2.1.
    < 07/02/90, DRE: Change definition of failure() to a prototype.
    < 5/5/90, dre, changed some comments
    < Vers 1.0, date: 3/6/90 Created: DRE

>BUGS:  < No bugs or system dependencies known in Cfront 2.0.
    < Cfront 2.1 fails block 0 of this test.
    <
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <iomanip.h>
#else
#include <iostream>
#include <iomanip>
#include <ostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "manip1()";

/**********************************************************************/
/*                                                                    */
/* noskipws                                                           */
/*                                                                    */
/* An istream manipulator to turn off skipws.                         */
/*                                                                    */
/**********************************************************************/

istream & noskipws(istream & i)
{
    i.flags(i.flags() & ~ios::skipws);
    return i;
}

/**********************************************************************/
/*                                                                    */
/* sp                                                                 */
/*                                                                    */
/* An ostream manipulator to insert a space into the ostream.         */
/*                                                                    */
/**********************************************************************/
/*
ostream & sp(ostream & o)
{
    return o << ' ';
}
*/
/**********************************************************************/
/*                                                                    */
/* sp(n)                                                              */
/*                                                                    */
/* An ostream manipulator to insert n spaces into the ostream.        */
/*                                                                    */
/**********************************************************************/

#if defined(USING_OLD_IOS)
ostream & sp(ostream & o, int nspaces)
#else
void __cdecl _sp(ostream& o, int nspaces)
#endif 
{
    int i;

    for (i=0; i<nspaces; i++)
        o << ' ';

#if defined(USING_OLD_IOS)
    return o;
#endif 
}

#if defined(USING_OLD_IOS)
OMANIP (int) sp(int n)
{
    return OMANIP(int)(sp,n);
}
#else
//!mmalone: this doesn't work and should? monte carlo 6548.
#ifndef _XBOX
_Smanip<int> __cdecl sp(int n) {return _Smanip<int>(&_sp, n);}
#endif
#endif 
/*--------------------------------------------------------------------*/
void manip1_main()                  
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("MANIP(3C++) manual page dated 14 June 1989.\n");
    DbgPrint("Use an istream manipulator to turn off skipws\n");

    {
        const char * ptr = "abc def ghi\n";
        const char * result = "abcdefghi";
        char buf[128];

        // First make sure that skipping whitespace works
        {
            strstreambuf sb;
            istream is(&sb);
            is.flags(is.flags() | ios::skipws);
            sb.sputn(ptr,strlen(ptr)+1);
            char * p = buf;
            while (is >> *p++)
                ;
            if (!strcmp(buf,ptr))
                failure("Istream is not skipping whitespace.");
            else if (strcmp(buf,result))
                failure("Istream is not yielding expected result.");
        }
#if defined(USING_OLD_IOS)

        // Now test the manipulator
        if (local_flag != FAILED)
        {
            strstreambuf sb;
            istream is(&sb);
            is.flags(is.flags() | ios::skipws);
            sb.sputn(ptr,strlen(ptr)+1);
            char * p = buf;
            is >> noskipws;

            while (is >> *p++)
                ;
            if (!strcmp(buf,result))
                failure("Manipulator did not work.");
            else if (strcmp(buf,ptr))
            {
                failure("Didn't get expected result.");
                DbgPrint("Wanted '%s', got '%s'.\n",ptr,buf);
            }
        }
#endif 
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("MANIP(3C++) manual page dated 14 June 1989.\n");
    DbgPrint("Use an ostream manipulator to insert a space.\n");

    {
#if defined(USING_OLD_IOS)

        char buf[128];
        strstreambuf sb;
        ostream os(&sb);

        if (!(os << 'a' << sp << 'b' << '\0'))
            failure("Insertion failed.");
        else if (sb.sgetn(buf,4) != 4)
            failure("Couldn't read characters.");
        else if (strcmp(buf,"a b"))
            failure("Got wrong string.");
#endif 
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("MANIP(3C++) manual page dated 14 June 1989.\n");
    DbgPrint("Use an ostream manipulator to insert n spaces.\n");

    {
#if defined(USING_OLD_IOS)

        char buf[128];
        strstreambuf sb;
        ostream os(&sb);

        if (!(os << 'a' << sp(3) << 'b' << '\0'))
            failure("Insertion failed.");
        else if (sb.sgetn(buf,6) != 6)
            failure("Couldn't read characters.");
        else if (strcmp(buf,"a   b"))
            failure("Got wrong string.");
#endif 
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\manip3.c ===
/* @(#)File: manip3.C       Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, MANIP(3C++)      >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < This file tests format control manipulators setiosflags(long) >
    < and resetiosflags(long) as well as the manipulators that  >
    < control the format components "width", "fill" and "precision".>
    < In this file, all the manipulators are tested using the >>    >
    < operator.  The tests with operator << are in file manip2.C    >

>HOW:   < These manipulators can set the format variables to any given  >
    < value.  The tests use the corresponding function that allows  >
    < to get the value of the format variables to check they were   >
    < set to the proper values by the manipulators.         >

    < 0. Check manipulator setiosflags(long).           >
    < 1. Check manipulator resetiosflags(long).         >
    < 2. Check manipulator setfill(int).                >
    < 3. Check manipulator setw(int).               >
    < 4. Check manipulator setprecision(int).           >

>MODS:  < Version 1.0 created by HK on 3/4/90.              >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "manip3()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <iomanip.h>
#else
#include <iostream>
#include <iomanip>
#endif 

// global variable declarations
streambuf * sb;     //creates an empty buffer sb
ostream o(sb);      //creates an output stream using sb

long new_format;
/*--------------------------------------------------------------------*/
void manip3_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, MANIP(3C++)");
    print("Test manipulator setiosflags(long) with operator <<");

    o.flags(0l);        // clear all bits of format
    new_format = 0l;

    for (int i= 0; i<31; i++)
        {o << setiosflags(1l<< i);
#if defined(USING_OLD_IOS)
        new_format = new_format | (1l << i);
#else
        new_format |= (1l << i) & ios_base::_Fmtmask;
#endif
        if (o.flags() != new_format)
            {local_flag = FAILED;
            DbgPrint( "\tformat is %lx instead of %lx\n",
                    o.flags(), new_format);
            }
        }

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, MANIP(3C++)");
    print("Test manipulator resetiosflags(long) with operator <<");

    o.flags(~0l);       // set all bits of format
    new_format = ~0l;

    for (i= 0; i<31; i++)
        {o << resetiosflags(1l<< i);
        new_format = new_format & ~(1l << i);
#if defined(USING_OLD_IOS)
        if (o.flags() != new_format)
#else
        if (o.flags() != (new_format & ios_base::_Fmtmask))
#endif 
            {local_flag = FAILED;
            DbgPrint( "\tformat is %lx instead of %lx\n",
                    o.flags(), new_format);
            }
        }

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, MANIP(3C++)");
    print("Test manipulator setfill(int) with operator <<");

    o << setfill((char)0);
    if (o.fill() != 0)
        fail("could not set fill to all zeroes");

    o << setfill((char)~0);
    if (o.fill() != ~0)
        fail("could not set fill to all ones");

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, MANIP(3C++)");
    print("Test manipulator setw(int) with operator <<");

    o << setw(0);
    if (o.width() != 0)
        fail("could not set width to all zeroes");

    o << setw(~0);
    if (o.width() != ~0)
        fail("could not set width to all ones");

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, MANIP(3C++)");
    print("Test manipulator setprecision(int) with operator <<");

    o << setprecision(0);
    if (o.precision() != 0)
        fail("could not set precision to all zeroes");

    o << setprecision(~0);
    if (o.precision() != ~0)
        fail("could not set precision to all ones");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\manip4.c ===
/* @(#)File: manip4.C		Version: 1.0		Date:09/27/90	*/
/* CVS-CC, C++ Validation Suite						*/
/* Copyright 1989, Perennial, All Rights Reserved			*/
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, MANIP(3C++)		>
	< in AT&T C++ Language System 2.0, May 89.  Select Code 307-145	>

>WHAT:  < This file tests format control manipulators setiosflags(long)	>
	< and resetiosflags(long) as well as the manipulators that	>
	< control the format components "width", "fill" and "precision".>
	< In this file, all the manipulators are tested using the <<	>
	< operator.  The tests with operator >> are in file manip1.C	>

>HOW:   < These manipulators can set the format variables to any given	>
	< value.  The tests use the corresponding function that allows	>
	< to get the value of the format variables to check they were	>
	< set to the proper values by the manipulators.			>

	< 0. Check manipulator setiosflags(long).			>
	< 1. Check manipulator resetiosflags(long).			>
	< 2. Check manipulator setfill(int).				>
	< 3. Check manipulator setw(int).				>
	< 4. Check manipulator setprecision(int).			>

>MODS:  < Version 1.0 created by HK on 3/4/90.				>

>BUGS:  < None known.							>
========================================================================*/
#include "testhead.h"     

static char progname[] = "manip4()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
	local_flag =FAILED;
	DbgPrint( "\tFAILURE: %s\n", str);
	}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <iomanip.h>
#else
#include <iostream>
#include <iomanip>
#endif 

// global variable declarations
streambuf * sb;		//creates an empty buffer sb
istream i(sb);		//creates an input stream using sb

long new_format;
/*--------------------------------------------------------------------*/
manip4_main()                                  /***** BEGINNING OF MAIN. *****/
{

        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

	print("REF: AT&T C++ Library Manual, Appendix A, MANIP(3C++)");
	print("Test manipulator setiosflags(long) with operator >>");

	i.flags(0l);		// clear all bits of format
	new_format = 0l;

	for (int j= 0; j<31; j++)
		{i >> setiosflags(1l<< j);
		new_format = new_format | (1l << j);
		if (i.flags() != new_format)
			{local_flag = FAILED;
			DbgPrint( "\tformat is %lx instead of %lx\n",
					i.flags(), new_format);
			}
		}

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      

	print("REF: AT&T C++ Library Manual, Appendix A, MANIP(3C++)");
	print("Test manipulator resetiosflags(long) with operator >>");

	i.flags(~0l);		// set all bits of format
	new_format = ~0l;

	for (j= 0; j<31; j++)
		{i >> resetiosflags(1l<< j);
		new_format = new_format & ~(1l << j);
		if (i.flags() != new_format)
			{local_flag = FAILED;
			DbgPrint( "\tformat is %lx instead of %lx\n",
					i.flags(), new_format);
			}
		}

        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

	print("REF: AT&T C++ Library Manual, Appendix A, MANIP(3C++)");
	print("Test manipulator setfill(int) with operator >>");

	i >> setfill(0);
	if (i.fill() != 0)
		fail("could not set fill to all zeroes");

	i >> setfill(~0);
	if (i.fill() != ~0)
		fail("could not set fill to all ones");

        blexit();
/*--------------------------------------------------------------------*/
block3: blenter();                      

	print("REF: AT&T C++ Library Manual, Appendix A, MANIP(3C++)");
	print("Test manipulator setw(int) with operator >>");

	i >> setw(0);
	if (i.width() != 0)
		fail("could not set width to all zeroes");

	i >> setw(~0);
	if (i.width() != ~0)
		fail("could not set width to all ones");

        blexit();
/*--------------------------------------------------------------------*/
block4: blenter();                      

	print("REF: AT&T C++ Library Manual, Appendix A, MANIP(3C++)");
	print("Test manipulator setprecision(int) with operator >>");

	i >> setprecision(0);
	if (i.precision() != 0)
		fail("could not set precision to all zeroes");

	i >> setprecision(~0);
	if (i.precision() != ~0)
		fail("could not set precision to all ones");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\osfx2.c ===
/* @(#)File: osfx2.C    Version: 1.0    Date: 09/27/90                */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ios and ostream
    < classes: IOS(3C++), OSTREAM(3C++) pages dated June 14, 1989.

>WHAT:  < Testing buffering and buffer flushing of the osfx() member
    < function and the stdio flag.
    < 
    < 0. If ios::stdio is set on an ostream then stdout and stderr 
    <    are flushed after every insertion.

>HOW:   < 0. Reopen stdout on a file. Open an ostream on another file.
    <    Set ios::stdio in the ostream. Write a few bytes to stdout.
    <    Insert into the stream. Read the file and check that the
    <    data was flushed.

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 4/30/90: Created: dre

>BUGS:  < The cfront 2.0 library fails this test. Stdout is not 
    < flushed upon the insertion. Adding a flush() confirms this 
    < fact.
    <
*/
/*====================================================================*/
/*                              osfx2.C                               */
/*====================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
#endif
#include "remove.h"

#include "testhead.h"


static char progname[] = "osfx2()";

static char * _string = "abc";
const int buflen = 256;
static char buf[buflen];
static FILE * fpw;
static FILE * fpr;

/*--------------------------------------------------------------------*/
void osfx2_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
block0: blenter();          

#if defined(USING_OLD_IOS)

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page, class ostream.\n");
    DbgPrint("Checking semantics of the osfx member function.\n");
    DbgPrint("Testing ``stdio'' buffering.\n");

    /* We do the check with an ofstream */

    char * _string = "abc";
    char nam1[L_tmpnam];
    char nam2[L_tmpnam];
    tmpnam(nam1);
    tmpnam(nam2);

    freopen(nam1, "w", stdout);
    ofstream os(nam2);
    os.flags(os.flags() | ios::stdio);
    DbgPrint(_string);
    os << "garbage";
    /* Stdout should have been flushed. */
    FILE * fpr = fopen(nam1, "r");
    /* fflush(stdout); */
    if (fread(buf, sizeof(*buf), strlen(_string), fpr) != strlen(_string))
        failure("Failed to read the data.");
    else
        if (strcmp(buf,_string))
            failure("Read the wrong data.");
    fclose(fpr);
    remove(nam1);
    remove(nam2);
#endif
    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\manip2.c ===
/* @(#)File: manip2.C    Version: 1.0    Date: 09/27/90               */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
	=================== TESTPLAN SEGMENT ===================
>KEYS:	< AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
	< I/O Library Manual pages, In particular user-defined
	< manipulators. MANIP(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the ability to define manipulators
	<
	< 0. A parameterized istream manipulator.
	<    Define an istream manipulator to read an int that may
	<    have a suffix. Taken from Iostream examples, Manipulators,
	<    AT&T Document 307-145 Chapter 3. 
	<
>HOW:	< 0. Define the manipulator and use it to read two ints
        <    out of a strstreambuf, verify the resulting values. 
	<    One should have been multiplied by 1024.

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
	<    Include "testhead.h" rather than "testhead.h"
	< 5/5/90: dre: changed some comments
	< Vers 1.0, 3/6/90: dre: created

>BUGS:  < Some 2.1 cfronts fail to compile this.

======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <iomanip.h>
#else
#include <iostream>
#include <iomanip>
#endif

#include "testhead.h"


static char progname[] = "manip2()";

/**********************************************************************/
/*                                                                    */
/* in_t(int&)                                                         */
/*                                                                    */
/* An istream manipulator to read an int with an optional suffix      */
/* of 'k' to mean multiply by 1024. See the banner to this            */
/* file for the source of this manipulator.                           */
/*                                                                    */
/**********************************************************************/

typedef int & Iref;

IOMANIPdeclare(Iref) ;

istream & in_k(istream & i, int & n)
{
    // Extract an integer, if suffix is present multiply by 1024
    i >> n;
    if (i.peek() == 'k') {
	i.ignore(1);
	n *= 1024;
    }
    return i;
}

IAPP(Iref) in_k = in_k;

/*--------------------------------------------------------------------*/
manip2_main()					
{
	setup();
/*--------------------------------------------------------------------*/
block0:	blenter();			

	DbgPrint("REF: AT&T Library Reference February 1990\n");
	DbgPrint("Appendix A-4: Testing I/O Streams.\n");
	DbgPrint("MANIP(3C++) manual page dated 14 June 1989.\n");
	DbgPrint("Use an istream manipulator to read an int\n");
	DbgPrint("with a suffix.\n");

	int n;
	{
		streambuf sb;
		istream is(&sb);
		sb.sputn("123 ",5);
		is >> in_k(n);
		if (n != 123)
			failure("Read wrong number without suffix.");
	}
	{
		streambuf sb;
		istream is(&sb);
		sb.sputn("123k ",5);
		is >> in_k(n);
		if (n != 123*1024)
			failure("Read wrong number with suffix.");
	}

	blexit();
/*--------------------------------------------------------------------*/
	anyfail();	
}					

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\manip5.c ===
/* @(#)File: manip5.C    Version: 1.0    Date: 01/02/91               */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, Manipulators.
    < OSTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing predefined manipulators:
    <
    < 0. ends
    <
    < 1. flush
    <
>HOW:   < 0. Use an ostream to write to a character array.
    <    Insert an ``ends'' and check that a NULL character
    <    was written.
    <
    < 1. Use an ostream to write to a file.
    <    Check by reading through a separate file pointer that
    <    inserting ``flush'' flushes the file.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    < Vers 1.0, date: 5/4/90 Created: DRE

>BUGS:  < Some 2.1 Cfronts fail to execute this test.
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>
#else
#include <strstream>
#include <iostream>
#include <fstream>
#endif
#include "remove.h"

#include "testhead.h"

static char progname[] = "manip5()";
/*--------------------------------------------------------------------*/
void manip5_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) manual page dated 14 June 1989.\n");
    DbgPrint("Testing ends manipulator.\n");

    {
        strstreambuf sb;
        ostream os(&sb);
        os << ends;
        char c = 'A';
        sb.sgetn(&c,1);
        if (c)
        failure("Could not extract the NULL.");
    }

    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) manual page dated 14 June 1989.\n");
    DbgPrint("Testing the flush manipulator.\n");

    char fname[L_tmpnam], iobuf[128];
    char * data = "this is it";
//The following two lines were introduced for troubleshooting. LX:04252000
	char commandLine[256];
	int removeRC;
    tmpnam(fname);
    ofstream os(fname);

	sprintf(commandLine,"attrib %s\n",fname);

    os << data; // data probably wasn't written yet, it's buffered

    FILE * fp = fopen(fname, "r");

    if (fp == NULL)
        failure("Cannot open output file for reading.");
    else if (fread(iobuf, sizeof(*iobuf), 3, fp) == 0) { 
        // Now flush, reread, and verify the data is written.
        os << flush;
        if (fgets(iobuf, 128, fp) != iobuf) 
            failure("Still couldn't read the data after flushing.");
        else if (strcmp(iobuf,data))
            failure("Read wrong data.");
    } else
        DbgPrint("Data wasn't buffered so it can't be flushed.");
    
	os.close(); //LX:04252000
    fclose(fp);

//Line below was introduced for troubleshooting. Deactivate it when appropriate.
	/* system(commandLine); */
    removeRC=remove(fname);

if (removeRC) DbgPrint("manip5.c (%d): file %s could not be removed. \nBeware of garbage in the root dir!\n",__LINE__, fname);

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\osfx.c ===
/* @(#)File: osfx.C    Version: 1.0    Date: 09/27/90                 */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ios and ostream
    < classes: IOS(3C++), OSTREAM(3C++) pages dated June 14, 1989.

>WHAT:  < Testing buffering and buffer flushing of the osfx() member
    < function and the unitbuf and stdio flags.
    < 
    < 0. Test that the unitbuf flag exists.
    < 
    < 1. Test that the stdio flag exists.
    <
    < 2. If ios::unitbuf is set then stream::osfx() flushes the
    <    stream after every insertion.
    <

>HOW:   < 0-1. Set the flag in stdio and verify it's set. This is really
    <      just a compile test to verify that the identifier is 
    <      defined. We test the behavior next.
    <
    < 2. Open a stream on a temporary file. Set the flag and 
    <    some data into the stream. Don't insert a newline and
    <    don't flush the stream. Open the file through a file 
    <    pointer and check the data.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 4/30/90: Created: dre

>BUGS:  < No bugs or system dependencies known.
    <
*/
/*====================================================================*/
/*                              osfx.C                                */
/*====================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
#endif

#include "remove.h"

#include "testhead.h"


static char progname[] = "osfx()";

static char * _string = "abc";
const int buflen = 256;
static char buf[buflen];
static FILE * fpw;
static FILE * fpr;

/*--------------------------------------------------------------------*/
void osfx_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS(3C++) Manual Page, class ios.\n");
    DbgPrint("Testing existance of the unitbuf flag.\n");

    long flags = cout.flags();
    cout.flags(flags | ios::unitbuf);
    if ((cout.flags() & ios::unitbuf) == 0)
        failure("ios::unitbuf flag not set.");
    /* Essentially if it compiles it succeeds */

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          
#if defined(USING_OLD_IOS)

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS(3C++) Manual Page, class ios.\n");
    DbgPrint("Testing existance of the stdio flag.\n");

    flags = cout.flags();
    cout.flags(flags | ios::stdio);
    if ((cout.flags() & ios::stdio) == 0)
        failure("ios::stdio flag not set.");
    /* Essentially if it compiles it succeeds */
#endif 

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page, class ostream.\n");
    DbgPrint("Checking semantics of the osfx member function.\n");
    DbgPrint("Testing ``unitbuf'' buffering.\n");

    /* We do the check with an ofstream */

    char * fname = tmpnam(0);
    { 
        ofstream os(fname);
        if (!os)
        {
            failure("Could not create ofstream on file.");
            goto end2;
        }

        flags = os.flags();
        os.flags(flags | ios::unitbuf);
        os << _string;
        if (!os)
        {
            failure("Could not insert data.");
            goto end2;
        }

        /* Reopen the file and verify the data was written */
        /* These are the important tests. */
        fpr = fopen(fname, "r");
        if (fread(buf, sizeof(*buf), strlen(_string), fpr) != strlen(_string))
            failure("Failed to read the data.");
        else
            if (strcmp(buf,_string))
            failure("Read the wrong data.");
        fclose(fpr);
    }
    end2:
    remove(fname);

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ofstream.c ===
/* @(#)File: ofstream.C    Version: 1.0    Date: 11/20/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual Select Code 307-145
    < Appendix A-4, Stream I/O Library Manual Pages, 

>WHAT:  < FSTREAM(3C++) Manual page dated 14 June 1989
    < This stream class is for use in performing file I/O.
    < They use the filebuf class.
    <
    < Test ofstream constructors and attach
    <
    < 0.  Test ofstream::ofstream(char * filename)
    < 1.  Test ofstream::ofstream(int fd)
    < 2.  Test ofstream::ofstream(int fd, char * buf, int bufsize)
    < 3.  Test the ofstream::attach() member
    <
    < CLEAN UP --- After the last block the output file is removed.


>HOW:   < 0-2. Construct ofstreams using the four constructors.
    <      Verify that when the file argument is valid the file
    <      is opened. Write data to the file and read it back to
    <      verify.
    < 3.   Attach a file descriptor and verify the stream is open.
    <      Write and verify the file contents.

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/1/90: Created DRE

>BUGS:  < SYSTEM DEPENDENCIES:
    <
    <   These tests hit constructors or member functions
    <   that take file descriptor arguments, so they are Unix dependent.
    <   This test is dependent on the ANSI C libraries because it
    <   uses the tmpnam() and remove() stdio routines.
    <
======================================================================*/

/***************************************************************************
Micorosoft Revision History:

    Date        emailname       description
----------------------------------------------------------------------------
    03-01-95    a-timke         Replaced oldnames with ANSI versions.
----------------------------------------------------------------------------
****************************************************************************/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
#endif
#include <fcntl.h>
#include <stdio.h>
#include <io.h>
//#include <osfcn.h>
#include "remove.h"

#include "testhead.h"


static char progname[] = "ofstream()";

    // This function reads the input file stream and checks that its 
    // contents match the expected contents.

static int verify_ifs(ifstream * pifs);

    // This function writes an output file and then reads back 
    // and checks the contents.

int verify_ofs(ofstream * pofs, const char * filename);

/**********************************************************************/
/*                                                                    */
/* This test uses a data file that it reads and copies. The name of   */
/* the file is stored in the datfile variable. It also writes an      */
/* output file for testing file output.                               */
/*                                                                    */
/**********************************************************************/

static char namebuf1[L_tmpnam], namebuf2[L_tmpnam];

static const char * datfile = tmpnam(namebuf1);
static const char * outfile = tmpnam(namebuf2);

/*--------------------------------------------------------------------*/
void ofstream_main()                 
{
    setup();

/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the fstream classes.\n");
    DbgPrint("Test the ofstream::ofstream(char *) constructor.\n");

    {
#if defined(USING_OLD_IOS)
        ofstream ofs(outfile,ios::out);
#else
        ofstream ofs(outfile,ios::out|ios::trunc);
#endif
        if (ofs.good()) {
        if (!verify_ofs(&ofs,outfile))
            failure("Wrote wrong data.");
        ofs.close();
        }
        else
        failure("Error on file open.");
    }
    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();          

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the fstream classes.\n");
    DbgPrint("Test the ofstream::ofstream(int) constructor.\n");

    {
#if defined(USING_OLD_IOS)
        int fd;
        fd = _open(outfile, O_WRONLY);

        if (fd == -1) {
        local_flag = FAILED;
        extern int errno;
        DbgPrint( "%s : %s %d!\n", 
            progname, 
            "Non-C++ error: open system call failed, errno",
            errno);
        }
        else {
        ofstream ofs(fd);
        if (ofs.good()) {
            if (!verify_ofs(&ofs, outfile))
            failure("Wrote wrong data.");
            ofs.close();
        }
        else
            failure("Error on file open.");
        }
#endif
    }

    blexit();
/*--------------------------------------------------------------------*/
block2: blenter();          

    DbgPrint("REF: AT&T Library Manual Appendix A-4, Stream\n");
    DbgPrint("I/O Library, testing the fstream classes.\n");
    DbgPrint("Test the ofstream::ofstream(int, char*, int)\n");
    DbgPrint("constructor.\n");

    {
#if defined(USING_OLD_IOS)
        int fd;
        fd = _open(outfile, O_WRONLY);
        if (fd == -1) {
        local_flag = FAILED;
        extern int errno;
        DbgPrint( "%s : %s %d!\n", 
            progname, 
            "Non-C++ error: open system call failed, errno",
            errno);
        }
        else {
        const int bufsiz = 128;
        char buf[bufsiz];
        ofstream ofs(fd, buf, bufsiz);
        if (ofs.good()) {
            if (!verify_ofs(&ofs, outfile))
            failure("Wrote wrong data.");
            ofs.close();
        }
        else
            failure("Error on file open.");
        }
#endif
    }

    blexit();
/*--------------------------------------------------------------------*/
block3: blenter();          

    DbgPrint("%s%s%s",
        "REF: AT&T Library Manual Appendix A-4, Stream\n",
        "I/O Library, testing the fstream classes.\n",
        "Attaching a file descriptor to an ofstream.\n");
    
    {
#if defined(USING_OLD_IOS)

        int fd;
        
        fd = _open(outfile, O_WRONLY);
        if (fd == -1) {
        local_flag = FAILED;
        extern int errno;
        DbgPrint( "%s : %s %d!\n", 
            progname, 
            "Non-C++ error: open system call failed, errno",
            errno);
        }
        else {
        ofstream ofs;
        ofs.attach(fd);
        if (ofs.good()) {
            if (!verify_ofs(&ofs, outfile))
            failure("Wrote wrong data.");
            ofs.close();
        }
        else
            failure("Error on file open.");
        }
#endif
    }
        
    blexit();
/*--------------------------------------------------------------------*/
    remove(outfile);
    remove(datfile);
    anyfail();  

}                   


/**********************************************************************/
/*                                                                    */
/* This is the data the test expects to find in its input file.       */
/*                                                                    */
/**********************************************************************/

static const char * expected_data[] = {
    "aaaaaaaaaa",
    "bbbbbbbbbb",
    "0123456789",
    0
};

/**********************************************************************/
/*                                                                    */
/* verify_ifs                                                         */
/*                                                                    */
/* This routine reads the input file and verifies it contains the     */
/* expected data.                                                     */
/*                                                                    */
/* Return:                                                            */
/*                                                                    */
/*    1   correct data                                                */
/*    0   incorrect data                                              */
/*                                                                    */
/* Side-effect:                                                       */
/*                                                                    */
/*    The current file read/write position is undefined after this    */
/*    routine.                                                        */
/*                                                                    */
/**********************************************************************/

static int verify_ifs(ifstream * pifs)
{
    const char ** expect = expected_data;
    const int bufsize = 128;
    char buf[bufsize];

    while (*expect) {
        *pifs >> buf;
        if (strcmp(buf, *expect)) {
            DbgPrint( "Read '%s', expected '%s'\n",
                buf, *expect);
            return 0;
        }
        expect++;
    }
    return 1;
}

/**********************************************************************/
/*                                                                    */
/* verify_ofs                                                         */
/*                                                                    */
/* This routine verifies an output fstream. It writes the expected    */
/* contents into the file. Then it reopens the file as an input       */
/* stream and verifies the contents.                                  */
/*                                                                    */
/* Return:                                                            */
/*                                                                    */
/*    1   wrote correct data                                          */
/*    0   wrote incorrect data                                        */
/*                                                                    */
/* Side-effect:                                                       */
/*                                                                    */
/*    The current file read/write position is undefined after this    */
/*    routine.                                                        */
/*                                                                    */
/**********************************************************************/

int verify_ofs(ofstream * pofs, const char * filename)
{
    const char ** expect = expected_data;
    const int bufsize = 128;

    // Write the data
    while (*expect) 
        *pofs << *expect++ << "\n";
    
    pofs->flush();

    // Reopen the file for input
    ifstream ifs(filename);
    if (!ifs.good()) {
        DbgPrint( "Can't open out file for input\n");
        return 0;
    }

    // Verify the contents that were written
    return verify_ifs(&ifs);
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ostream1.c ===
/* @(#)File: ostream1.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ostream class, 
    < OSTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the output operations of the stream classes.
    < 
    < 0. put() writes a single character....
    <
    < 1. write(const char *, int) writes the characters 
    <
    < 2. write(const char *, int) can write NULL characters '\0'
    <

>HOW:   < The program uses a strstreambuf to hold data.
    <
    < 0.  Write a known string to a buffer. Then read the first
    <     character of the buffer with get. Verify the character.
    <
    < 1. Write a string and verify it's in the buffer.
    <
    < 2. Same as 1 but include '\0' characters in the string.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/5/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    <
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <strstrea.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "ostream1()";

    // The character buffer used by the streambuf.
static const int len = 1024;
static char strbuf[len];
    // A second buffer for I/O
static char buf[len];
static const char * ptr;

    // Read n bytes out of the strstreambuf.
int read(strstreambuf & sb, char * p, int n)
{
    return sb.sgetn(p,n) == n;
}

/*--------------------------------------------------------------------*/
void ostream1_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page.\n");
    DbgPrint("Testing put().\n");

    {
        strstreambuf sb(strbuf,len,strbuf);
        ostream os(&sb);
        char out_c = 'X';

        if (!os.good()) 
        failure("Cannot attach ostream to strstreambuf.");
        else 
        if (!os.put(out_c))
            failure("Cannot insert byte into ostream.");
        else 
            if (sb.sgetn(buf,1) != 1)
            failure("Can't extract the byte from the streambuf.");
            else
            if (*buf != out_c)
                failure("Extracted wrong character.");
    }

    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page.\n");
    DbgPrint("Testing write() of a string.\n");

    {
        strstreambuf sb(strbuf,len,strbuf);
        ostream os(&sb);
        char * ptr = "This is a test string.\n";

        if (!os.good()) 
        failure("Cannot attach ostream to strstreambuf.");
        else 
        if (!os.write(ptr,(streamsize) strlen(ptr)+1)) /*LX:10131999 cast to (streamsize)   */
            failure("Cannot insert string into ostream.");
        else 
            if (((size_t)sb.sgetn(buf,(streamsize) strlen(ptr)+1)) != strlen(ptr)+1)
            failure("Can't extract the string from the streambuf.");
            else
            if (strcmp(buf,ptr))
                failure("Extracted wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page.\n");
    DbgPrint("Testing write() of a buffer with NULL chars.\n");

    {
        strstreambuf sb(strbuf,len,strbuf);
        ostream os(&sb);
        const int ptr_len = 50;
        static char ptr[len] = "This \0 is \0 a \0 test \0 string.\n";

        if (!os.good()) 
        failure("Cannot attach ostream to strstreambuf.");
        else 
        if (!os.write(ptr,len))
            failure("Cannot insert string into ostream.");
        else 
            if (sb.sgetn(buf,len) != len)
            failure("Can't extract the string from the streambuf.");
            else
            if (memcmp(buf,ptr,len))
                failure("Extracted wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ostream7.c ===
/* @(#)File: ostream7.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ostream class.
    < OSTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the format flags of formatted output.
    < 
    < 0. operator<<(int) with hex format
    <
    < 1. operator<<(int) with oct format
    <
    < 2. operator<<(int) with hex format set through a manipulator
    <
    < 3. operator<<(int) with oct format set through a manipulator
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < These tests write a known value into the buffer,
    < then read it back and verify it. They write the float
    < to a second, local buffer and then compare the buffers.
    <
    < 0.   Set the mode format to hex. Then,
    <      write an int into the buffer as a hex. Then read it
    <      out into a string and string compare with the same 
    <      value written into another buffer.
    <
    < 1.   Set the mode format to octal, then,
    <      Write an int into the buffer as a hex. Then read it
    <      out into a string and string compare with the same 
    <      value written into another buffer.
    <
    < 2,3. These tests are identical to 0 and 1 except that the
    <      base is changed through a manipulator rather than
    <      by through the ios::setf() function.

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/5/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <strstrea.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "ostream7()";

static char * ptr;
const int len = 512;
static char buf[len];
static char buf2[len];

/*--------------------------------------------------------------------*/
void ostream7_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(int) in hex.\n");

    {
        strstreambuf sb;
        int x = 56780;
        sprintf(buf2,"%x",x);
        ostream os(&sb);
        os.setf(ios::hex,ios::basefield);
        if (!os.good())
            failure("Cannot open data buffer.");
        else if (!(os << x << '\0'))
            failure("Cannot insert the value.");
        else if (((size_t)sb.sgetn(buf,(int)strlen(buf2)+1)) != strlen(buf2)+1)
/*LX:10131999 added cast to (int) for 64-bit friendliness */
            failure("Cannot read back the value plus '\\0'.");
        else
            if (strcmp(buf,buf2))
        {
            failure("Wrote wrong string.");
            DbgPrint("Got %s, wanted %s\n",buf,buf2);
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(int) in octal.\n");

    {
        strstreambuf sb;
        int x = 65432;
        sprintf(buf2,"%o",x);
        ostream os(&sb);
        os.setf(ios::oct,ios::basefield);
        if (!os.good())
            failure("Cannot open data buffer.");
        else if (!(os << x << '\0'))
            failure("Cannot insert the value.");
        else if (((size_t)sb.sgetn(buf,(int)strlen(buf2)+1)) != strlen(buf2)+1)
/*LX:10131999 added cast to (int) for 64-bit friendliness */
            failure("Cannot read back the value plus '\\0'.");
        else
            if (strcmp(buf,buf2))
        {
            failure("Wrote wrong string.");
            DbgPrint("Got %s, wanted %s\n",buf,buf2);
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(int) with hex manipulator.\n");

    {
        strstreambuf sb;
        int x = 56780;
        sprintf(buf2,"%x",x);
        ostream os(&sb);
        if (!os.good())
            failure("Cannot open data buffer.");
        else if (!(os << hex << x << '\0'))
            failure("Cannot insert the value.");
        else if (((size_t)sb.sgetn(buf,(int)strlen(buf2)+1)) != strlen(buf2)+1)
/*LX:10131999 added cast to (int) for 64-bit friendliness */
            failure("Cannot read back the value plus '\\0'.");
        else
            if (strcmp(buf,buf2))
        {
            failure("Wrote wrong string.");
            DbgPrint("Got %s, wanted %s\n",buf,buf2);
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(int) with oct manipulator.\n");

    {
        strstreambuf sb;
        int x = 65432;
        sprintf(buf2,"%o",x);
        ostream os(&sb);
        if (!os.good())
            failure("Cannot open data buffer.");
        else if (!(os << oct << x << '\0'))
            failure("Cannot insert the value.");
        else if (((size_t)sb.sgetn(buf,(int)strlen(buf2)+1)) != strlen(buf2)+1)
/*LX:10131999 added cast to (int) for 64-bit friendliness */
            failure("Cannot read back the value plus '\\0'.");
        else
            if (strcmp(buf,buf2))
        {
            failure("Wrote wrong string.");
            DbgPrint("Got %s, wanted %s\n",buf,buf2);
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ostream8.c ===
/* @(#)File: ostream8.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ostream class.
    < OSTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing formatted output.
    < 
    < 0. Test the endl manipulator.
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < 0.   Write two integers separated by an endl and read
    <      it out of the buffer to be sure its correct.

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/5/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "ostream8()";

static char * ptr;
const int len = 512;
static char buf[len];
static char buf2[len];

/*--------------------------------------------------------------------*/
void ostream8_main()                  
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing the endl manipulator.\n");

    {
        strstreambuf sb;
        int i1 = 17;
        int i2 = 34;
        sprintf(buf2,"%d\n%d",i1,i2);
        ostream os(&sb);
        if (!os.good())
            failure("Cannot open data buffer.");
        else if (!(os << i1 << endl << i2 << '\0'))
            failure("Cannot insert the values.");
        else if (((size_t)sb.sgetn(buf,(int)strlen(buf2)+1)) != strlen(buf2)+1)
/*LX:10131999 added cast to (int) for 64-bit friendliness */
            failure("Cannot read back the value plus '\\0'.");
        else
            if (strcmp(buf,buf2))
        {
            failure("Wrote wrong string.");
            DbgPrint("Got %s, wanted %s\n",buf,buf2);
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ostream5.c ===
/* @(#)File: ostream5.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ostream class.
    < OSTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the formatted output operations.
    < 
    < 0. operator<<(float) 
    <
    < 1. operator<<(double)
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < These tests write a known value into the buffer,
    < then read it back and verify it. They write the float
    < to a second, local buffer and then compare the buffers.

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/5/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "ostream5()"; 

static char * ptr;
const int len = 512;
static char buf[len];
static char buf2[len];

/*--------------------------------------------------------------------*/
void ostream5_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(float).\n");

    {
        strstreambuf sb;
        float x = (float)1234.56;
        size_t n; /*LX:10131999 /int/size_t for 64-bit friendliness */
        sprintf(buf2,"%2.2f",x);
        ostream os(&sb);
        if (!os.good())
        failure("Couldn't open data buffer.");
        else if (!(os << x << '\0'))
        failure("Could not insert the float.");
        else if ((size_t)(n = sb.sgetn(buf,(streamsize) strlen(buf2)+1)) != strlen(buf2)+1) 
/*LX:10131999 added cast to (streamsize) for 64-bit friendliness */
        failure("Could not read back int plus '\\0'.");
        else if (memcmp(buf2,buf,strlen(buf2)+1)) 
        failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(double).\n");

    {
        strstreambuf sb;
        double x = 7890.12;
        size_t n; /*LX:10131999 /int/size_t for 64-bit friendliness */
        sprintf(buf2,"%3.2lf",x);
        ostream os(&sb);
        if (!os.good())
        failure("Couldn't open data buffer.");
        else if (!(os << x << '\0'))
        failure("Could not insert the double.");
        else if ((size_t)(n = sb.sgetn(buf,(int)strlen(buf2)+1)) != strlen(buf2)+1) {
/*LX:10131999 added cast to (int) for 64-bit friendliness */
        failure("Could not read back int plus '\\0'.");
        DbgPrint("Got %s(%d)\n",buf,n);
        DbgPrint("Wanted %s(%d)\n",buf2,strlen(buf2)+1);
        }
        else if (memcmp(buf2,buf,strlen(buf2)+1)) {
        failure("Wrote wrong string.");
        DbgPrint("Got %s(%d)\n",buf,n);
        DbgPrint("Wanted %s(%d)\n",buf2,strlen(buf2)+1);
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ostream2.c ===
/* @(#)File: ostream2.C    Version: 1.0    Date: 01/02/91             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ostream class,
    < OSTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the seek/tell operations of the ostream classes.
    < 
    < These tests use the seekp positioning member to adjust
    < the put pointer of the streambuf. 
    <
    < 0. Positioning at the beginning of the buffer and writing again
    <    after writing a few bytes. 
    < 
    < 1. Positioning at the end of the buffer and appending data.

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < 0. Write into the buffer, seek back to the beginning and write
    <    again. Verify that the data was overwritten.
    <
    < 1. Put data into the buffer independently of the ostream.
    <    Then seekp the ostream to the end of the buffer and write
    <    data. Verify it was appended.

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    < Vers 1.0, date: 3/5/90 Created: DRE

>BUGS:  < The library fails block 1. The seek to the end of the
    < strstreambuf does not succeed.
    <
    < These tests assume that no actual physical file be
    < associated with the ostream.  May be incorrect. - RFG
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "ostream2()"; 

const int len = 512;
static char buf[len];

static char * ptr;
static char c;

/*--------------------------------------------------------------------*/
void ostream2_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: seekp().\n");
    DbgPrint("Using seekp() to rewrite data.\n");

    {
        const char * s1 = "This is string 1";
        const char * s2 = "12345667889980923 This is string 2.\n";
        strstreambuf sb;
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << s1))
            failure("Couldn't write data first time.");
        else if (!os.seekp(0,ios::beg))
            failure("Couldn't seek to beginning of ostream.");
        else if (!(os << s2))
            failure("Couldn't write data second time.");
        // The string obtained by sgetn is not NULL terminated.
        else if (((size_t)sb.sgetn(buf,len)) != strlen(s2))
            failure("Read wrong amount of data from buffer.");
        else if (memcmp(buf,s2,strlen(s2)))
            failure("Read wrong string from buffer.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: seekp().\n");
    DbgPrint("Using seekp() to append data.\n");

    {
        const char * s1 = "This is string 1";
        const char * s2 = "12345667889980923 This is string 2.\n";
        strstreambuf sb(len);
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
#if defined(USING_OLD_IOS)
        else if (sb.sputn(s1,strlen(s1) != strlen(s1)))
#else
        else if (((size_t)sb.sputn(s1,(int) strlen(s1))) != strlen(s1))
	/* LX:10131999 added cast to (int) for 64-bit friendliness */
#endif 
            failure("Couldn't write first string.");
        else if (!os.seekp(0,ios::end))
            failure("Couldn't seek to end of ostream.");
        else if (!(os << s2))
            failure("Couldn't write second string.");
        // The string obtained by sgetn is not NULL terminated.
        else if (((size_t)sb.sgetn(buf,len)) != strlen(s1) + strlen(s2))
            failure("Read wrong amount of data from buffer.");
        else if (memcmp(buf,s1,strlen(s1)) || memcmp(buf+strlen(s1),s2,strlen(s2)))
            failure("Read wrong data from buffer.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ostream6.c ===
/* @(#)File: ostream6.C    Version: 1.0    Date: 09/27/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ostream class.
    < OSTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the formatted output operations.
    < 
    < 0. operator<<(void *) 
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < These tests write a known value into the buffer,
    < then read it back and verify it. They write the float
    < to a second, local buffer and then compare the buffers.
    <
    < 0. The manual page says that values of type void * are
    <    converted to integers and written in hexadecimal. So
    <    after reading the value into a string it is compared to
    <    the pointer value written as a %x into a buffer.
    <

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/5/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "ostream6()";

static char * ptr;
const int len = 512;
static char buf[len];
static char buf2[len];

/*--------------------------------------------------------------------*/
void ostream6_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(void *).\n");

    {
        strstreambuf sb;
        void * p = (void*) 0x1234;
#if defined(USING_OLD_IOS)
        sprintf(buf2,"0x%x",p);
#else
        sprintf(buf2,"%p",p);
#endif 
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << p << '\0'))
            failure("Could not insert the pointer.");
        else if (((size_t)sb.sgetn(buf,(int)strlen(buf2)+1)) != strlen(buf2)+1)
/*LX:10131999 added cast to (int) for 64-bit friendliness */
            failure("Could not read back the pointer plus '\\0'.");
        else
        {
            if (buf[1] == 'X') buf[1] = 'x';
            if (strcmp(buf,buf2))
            {
                failure("Wrote wrong string.");
                DbgPrint("Got %s, wanted %s\n",buf,buf2);
            }
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ostream4.c ===
/* @(#)File: ostream4.C    Version: 1.0    Date: 11/08/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ostream class.
    < OSTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the formatted output operations.
    < 
    < 0. operator<<(int) 
    <
    < 1. operator<<(int) with a negative value
    <
    < 2. operator<<(unsigned int) 
    <
    < 3. operator<<(long) 
    <
    < 4. operator<<(long) with a negative value
    <
    < 5. operator<<(unsigned long) 
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < All these tests write a known value into the buffer,
    <       then read it back and verify it.

>MODS:  < 11/8/90, DRE: Added 2.1 BUGS comment.
    < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/5/90 Created: DRE

>BUGS:  < No bugs or system dependencies known as far as cfront 2.0
    < Cfront 2.1 fails block 1 and 4 of the test.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <strstrea.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "ostream4()";

static char * ptr;
const int len = 512;
static char buf[len];

/*--------------------------------------------------------------------*/
void ostream4_main()                 
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(int).\n");

    {
        strstreambuf sb;
        int i = 1234;
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << i << '\0'))
            failure("Could not insert the int.");
        else if (sb.sgetn(buf,4) != 4)
            failure("Could not read back int plus '\\0'.");
        else if (memcmp("1234",buf,4))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(int) with a negative.\n");

    {
        strstreambuf sb;
        int n, s = -5678;
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << s << '\0'))
            failure("Could not insert the int.");
        else if ((n = sb.sgetn(buf,5)) != 5)
        {
            failure("Could not read back int plus '\\0'.");
            DbgPrint( "Wanted %d chars, got %d\n", 5, n);
        }
        else if (memcmp("-5678",buf,5))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(unsigned int).\n");

    {
        strstreambuf sb;
        unsigned int s = 4321;
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << s << '\0'))
            failure("Could not insert the int.");
        else if (sb.sgetn(buf,4) != 4)
            failure("Could not read back int plus '\\0'.");
        else if (memcmp("4321",buf,4))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(long).\n");

    {
        strstreambuf sb;
        long s = 2345;
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << s << '\0'))
            failure("Could not insert the long.");
        else if (sb.sgetn(buf,4) != 4)
            failure("Could not read back long plus '\\0'.");
        else if (memcmp("2345",buf,4))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(long) with a negative.\n");

    {
        strstreambuf sb;
        long s = -4567;
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << s << '\0'))
            failure("Could not insert the long.");
        else if (sb.sgetn(buf,5) != 5)
            failure("Could not read back long plus '\\0'.");
        else if (memcmp("-4567",buf,5))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block5: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(unsigned long).\n");

    {
        strstreambuf sb;
        unsigned long s = 7654;
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << s << '\0'))
            failure("Could not insert the long.");
        else if (sb.sgetn(buf,4) != 4)
            failure("Could not read back long plus '\\0'.");
        else if (memcmp("7654",buf,4))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ostream3.c ===
/* @(#)File: ostream3.C    Version: 1.1    Date: 01/02/91             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ostream class.
    < OSTREAM(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the formatted output operations.
    < 
    < 0.  operator<<(char *) writes characters until it reaches
    <     a NULL. It does not write the '\0' character.
    < 
    < 1.  operator<<(unsigned char *) same as previous block.
    < 
    < 2.  operator<<(char)
    < 
    < 3.  operator<<(unsigned char)
    < 
    < 4.  operator<<(short) 
    <
    < 5.  operator<<(short), the variable may be negative
    <
    < 6.  operator<<(unsigned short)
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < Tests 0-6 all put a known value in the buffer,
    <       then read out and verify it.
    <
    < 0.  Write some words into a buffer then use the writeion
    <     operator to remove the first one. Then use get() to 
    <     read the whitespace following the first word. Verify
    <     the word read.
    <
    < 1.  Same as previous block but with a buffer pointer of
    <     type unsigned char *.
    <
    < 2.  Write a couple characters then read them back and verify.
    <
    < 3.  Same as 2 with unsigned characters.
    <
    < 4.  Write and check a positive short.
    <
    < 5.  Write and check a negative short.
    <
    < 6.  Write and check an unsigned short.
    <

>MODS:  < Vers 1.1, 01/02/91: RFG - Added code to pinpoint Cfront bug.
    < 07/02/90, DRE: Change definition of failure() to a prototype.
    < 3/12/90: dre: The initial revision had neglected to explain
    <     why the library fails block 1. Added the paragraph below to
    <     explain the problem.
    < Vers 1.0, date: 3/5/90 Created: DRE

>BUGS:  < The library fails block 1. This block tests the insertion
    < on a pointer of type (unsigned char *). The operator should
    < insert the string into the buffer, treating the pointer just
    < as if it were a (char *). Instead it treats the pointer the 
    < same way it treats a (void *). It writes the value of the 
    < pointer, i.e., the address of the string, into the buffer in
    < hexadecimal.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "ostream3()";

static char * ptr;
const int len = 512;
static char buf[len];

/*--------------------------------------------------------------------*/
void ostream3_main()                  
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(char *).\n");

    {
        strstreambuf sb;
        ptr = "word1\tword2\tword3\n";  // tabs are whitespace
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << ptr))
            failure("Could not insert string.");
        else if (((size_t)sb.sgetn(buf,(int) strlen(ptr))) != strlen(ptr))
/*LX:10131999 added cast to (int) for 64-bit friendliness */
            failure("Could not read back string.");
        else if (memcmp(ptr,buf,strlen(ptr)))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(unsigned char *).\n");

    {
        size_t i; /*LX:10131999 int/size_t for 64-bit friendliness */
        strstreambuf sb;
        ptr = "word1\t1word2\tword3\n"; // tabs are whitespace
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << (unsigned char *) ptr))
            failure("Could not insert string.");
        else if ((i = sb.sgetn(buf,(int)strlen(ptr))) != strlen(ptr))
/*LX:10131999 added cast to (int) for 64-bit friendliness */
        {
            DbgPrint( "Count = %d\n", i);
            failure("Could not read back string.");
        }
        else if (memcmp(ptr,buf,strlen(ptr)))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(char).\n");

    {
        strstreambuf sb;
        ptr = "abc";
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << ptr[0]))
            failure("Could not insert first character.");
        else if (!(os << ptr[1]))
            failure("Could not insert second character.");
        else if (!(os << ptr[2]))
            failure("Could not insert third character.");
        else if (!(os << ptr[3]))
            failure("Could not insert '\\0' character.");
        else if (((size_t)sb.sgetn(buf,(int)strlen(ptr)+1)) != strlen(ptr)+1)
/*LX:10131999 added cast to (int) for 64-bit friendliness */
            failure("Could not read back string plus '\\0'.");
        else if (memcmp(ptr,buf,strlen(ptr)+1))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(unsigned char).\n");

    {
        strstreambuf sb;
        ptr = "abc";
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << (unsigned char) (ptr[0])))
            failure("Could not insert first character.");
        else if (!(os << (unsigned char) (ptr[1])))
            failure("Could not insert second character.");
        else if (!(os << (unsigned char) (ptr[2])))
            failure("Could not insert third character.");
        else if (!(os << (unsigned char) (ptr[3])))
            failure("Could not insert '\\0' character.");
        else if (((size_t)sb.sgetn(buf,(int)strlen(ptr)+1)) != strlen(ptr)+1)
/*LX:10131999 added cast to (int) for 64-bit friendliness */
            failure("Could not read back string plus '\\0'.");
        else if (memcmp(ptr,buf,strlen(ptr)+1))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(short).\n");

    {
        strstreambuf sb;
        short s = 123;
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << s << '\0'))
            failure("Could not insert the short.");
        else if (sb.sgetn(buf,4) != 4)
            failure("Could not read back short plus '\\0'.");
        else if (memcmp("123",buf,4))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block5: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(short) with a negative.\n");

    {
        strstreambuf sb;
        short s = -123;
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << s << '\0'))
            failure("Could not insert the short.");
        else if (sb.sgetn(buf,5) != 5)
            failure("Could not read back short plus '\\0'.");
        else if (memcmp("-123",buf,5))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block6: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: formatted output.\n");
    DbgPrint("Testing operator<<(unsigned short).\n");

    {
        strstreambuf sb;
        unsigned short s = 123;
        ostream os(&sb);
        if (!os.good())
            failure("Couldn't open data buffer.");
        else if (!(os << s << '\0'))
            failure("Could not insert the short.");
        else if (sb.sgetn(buf,4) != 4)
            failure("Could not read back short plus '\\0'.");
        else if (memcmp("123",buf,4))
            failure("Wrote wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\p15036.c ===
/* File: P15036.C    Version: 1.3    Date: 05/27/92
 * CVS-C++, C++ Validation Suite
 * Section: 15  Type: P - Positive Execution Test
 * Copyright 1992, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:  ISO/ANSI C++ draft, X3J16/92-0023.
        15 Exception Handling
        15.6 Special Functions
        15.6.1 The terminate() Function

>REL:   EH Phase II and later

>WHAT:  "Occasionally, exception handling must be abandoned for less
        subtle error handling techniques.  For example,
            - when the exception handling mechanism cannot find a
            handler for a thrown exception, 
            - when the exception handling mechanism finds the
            stack corrupted, [untestable] or
            - when a destructor called during stack unwinding caused by
            an exception tries to exit using an exception .

        In such cases,
            void terminate();
        is called; ... "

        This file only tests the case "when a destructor called during
        stack unwinding caused by an exception tries to exit using an
        exception."

>HOW:   Define a destructor for a thrown class that tries to exit
        using an exception.  Verify that terminate() gets invoked.

>NOTE:  None
======================================================================*/

#include "tsthd.h"        /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */

static char prgnam[] = "P15036.C";

class C {
    public:
        C() { }
        ~C() { throw 'a'; }
};

static void eh_term(void)
{
        blexit();
        anyfail(1);
        CreateExitFile();
}

/*--------------------------------------------------------------------*/
int p15036_main(void)
{
        setup();
        eh_traps();             // set_terminate() and set_unexpected() 
        set_terminate(&eh_term);
/*--------------------------------------------------------------------*/
        blenter();      /* block 00 */

        fprintf(logfp,
          "REF: ISO/ANSI C++ draft, X3J16/92-0023.\n");
        fprintf(logfp, "15 Exception Handling, 15.6 Special Functions, ");
        fprintf(logfp, "15.6.1 The terminate() Function\n");
        fprintf(logfp, 
          "During unwinding, destructor cannot exit using an exception\n");

        try {
                C c;
                throw 1;
        }
        catch (int) {
                failure("Destructor was not invoked");
        }
        catch (char) {
                failure("Destructor exited using an exception");
        }
        catch (...) {
                failure("Throw caught by wrong handler");
        }
        failure("terminate() was not called");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail(1);      
        return 0;
}

#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\remove.h ===
/*
 * Our development environment does not have the ANSI C remove
 * library routine defined. Therefore this header file defines
 * remove to be unlink; this makes the test Unix dependent.
 *
 * When compiling with ANSI C libraries this may be commented out.
 */

//#include <osfcn.h>

#if 0

//ANSI to NON-ANSI function definitions:
#ifndef remove
#define	remove(x) unlink(x)
#endif

#else

//NON-ANSI to ANSI function definitions:
#ifndef open
#define	open _open
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\sbuf1.c ===
/* @(#)File: sbuf1.C        Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)       >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Testing the "get" related functions of class strstreambuf.    >
    < This class is derived from the base class streambuf in which  >
    < the tested functions are originally defined.  The tested  >
    < functions are not redefined in strstreambuf, so this file >
    < is actually testing functions of streambuf.           >

>HOW:   < Declare a strtreambuf object and initialize the buffer with   >
    < a given test pattern.  Each block is used to test the     >
    < behaviour of a "get" related function.            >
    
    < 0. Test in_avail()                        >
    < 1. Test sgetc()                       >
    < 2. Test sbumpc()                      >
    < 3. Test snextc()                      >
    < 4. Test stossc()                      >
    < 5. Test sgetn() on a partial fetch (leave some chars in buf)  >
    < 6. Test sgetn() on a complete fetch (no chars left)       >
    
>MODS:  < Version 1.0 created by HK.                    >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "sbuf1()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <strstrea.h>
#else
#include <iostream>
#include <strstream>
#endif

// global variable declarations
static char msg[] = "Hi there!";   // test pattern
static char * bmsg = msg;          // marks base of pattern
static char * emsg = msg - 1 + strlen(msg);    // marks end of pattern

static char buf[20]="Hi there!";   // array used as stream's buffer
                // initialized with test pattern
static char tmp[20];   // array used to get strings into
static char *cp = msg;

static strstreambuf in(buf, (int) strlen(buf), 0);   // create strstreambuf
/*LX:10131999 added cast to (int) for 64-bit friendliness. Should be safe. */
/*--------------------------------------------------------------------*/
void sbuf1_main()                                  /***** BEGINNING OF MAIN. *****/
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing in_avail()");
    if ((size_t)(in.in_avail()) != strlen(buf))
        fail("unexpected return value");

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sgetc()");
    if (in.sgetc() != *bmsg)
        fail ("unexpected char");

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sbumpc()");
    if (in.sbumpc() != *bmsg)
        fail ("unexpected char");

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing snextc()");
    if (in.snextc() != *(bmsg+2))
        fail ("unexpected char");

    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing stossc()");
    in.stossc();
    if (in.sgetc() != *(bmsg+3))
        fail ("unexpected char");

    blexit();
/*--------------------------------------------------------------------*/
    block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sgetn()");
    strcpy(tmp, "");
    in.sgetn(tmp, 3);
    if (strncmp( msg+3, tmp, 3))
        fail("unexpected string");

    blexit();
/*--------------------------------------------------------------------*/
    block6: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sgetn() when requesting more char's than are available");
    in.sgetn(tmp+3, (streamsize) strlen(msg));
/*LX:10131999 added cast to (int) for 64-bit friendliness */
    if (strcmp(msg+3, tmp))
        fail("unexpected string");

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\p15038.c ===
/* File: P15038.C    Version: 2.6    Date: 05/27/92
 * CVS-C++, C++ Validation Suite
 * Section: 15	Type: P - Positive Execution Test
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:	ISO/ANSI C++ draft, X3J16/92-0023.
	15 Exception Handling.
	15.6 Special Functions.
	15.6.1 The terminate() Function.

>REL:	EH Phase I and later.

>WHAT:	"The previous function given to set_terminate() will be
	the return value;  this enables users to implement a stack
	strategy for using terminate()."

>HOW:	Call set_terminate() N+1 times, each with a unique
	function address, and verify that set_terminate()
	returns the previous address each time.

>NOTE:	None.
======================================================================*/
#include "tsthd.h"     	  /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */

static char prgnam[] = "P15038.C";

static void eh_term0(void) { }
static void eh_term1(void) { }
static void eh_term2(void) { }
static void eh_term3(void) { }

/*--------------------------------------------------------------------*/
int p15038_main(void)
{
	PFV ret;

        setup();
        eh_traps();
/*--------------------------------------------------------------------*/
	blenter();	/* block 00 */

        fprintf(logfp,
	  "REF: ISO/ANSI C++ draft, X3J16/92-0023.\n");
        fprintf(logfp,
	  "15 Exception Handling, 15.6.1 The terminate() Function\n");
        fprintf(logfp,
	  "The previous function given to set_terminate() is returned\n");

	set_terminate (&eh_term0);

	ret = set_terminate (&eh_term1);
	if (ret != &eh_term0)
	    failure ("&eh_term0() not returned.");
	else
	{
	    ret = set_terminate (&eh_term2);
	    if (ret != &eh_term1)
	        failure ("&eh_term1() not returned.");
	    else
	    {
	        ret = set_terminate (&eh_term3);
	        if (ret != &eh_term2)
	            failure ("&eh_term2() not returned.");
	    }
	}

        blexit();
/*--------------------------------------------------------------------*/
	anyfail(1);      
        return 0;
}


#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\p15037.c ===
/* File: P15037.C    Version: 2.7    Date: 09/08/92
 * CVS-C++, C++ Validation Suite
 * Section: 15  Type: P - Positive Execution Test
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:  ISO/ANSI C++ draft, X3J16/92-0023.
        15 Exception Handling.
        15.6 Special Functions.
        15.6.1 The terminate() Function.

>REL:   EH Phase I and later.

>WHAT:  "... terminate() calls the last function given as an
        argument to set_terminate():
        
                typedef void (*PFV) ();
                PFV set_terminate (PFV); "

>HOW:   Pass the function foo() as the last argument to 
        set_terminate().  Cause a call to terminate()
        by throwing an exception, with no corresponding 
        handler.

>NOTE:  None.
======================================================================*/
#include "tsthd.h"        /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */

static char prgnam[] = "P15037.C";

class C {};
static C c;

static void f00(void)
{
        try {
                throw c;
        }
        catch (float) {
                failure("Throw caught by wrong handler");
        }
}

void old_eh_term(void)
{
        failure("terminate() called old_eh_term() instead of eh_term()");
        blexit();
        anyfail(1);
        CreateExitFile();
}

static void eh_term(void)
{
        blexit();
        anyfail(1);
        CreateExitFile();
}

/*--------------------------------------------------------------------*/
int p15037_main(void)
{
        setup();
        eh_traps();
        set_terminate (&old_eh_term);
        set_terminate (&eh_term);
/*--------------------------------------------------------------------*/
        blenter();      /* block 00 */

        fprintf(logfp,
          "REF: ISO/ANSI C++ draft, X3J16/92-0023.\n");
        fprintf(logfp,
         "15 Exception Handling, 15.6.1 The terminate() Function\n");
        fprintf(logfp,
          "terminate() calls the last function given as an argument\n");
        fprintf(logfp,
          "to set_terminate()\n");

        f00();
        failure ("terminate() did not call any function");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail(1);      
        return 0;
}

#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\sbuf3.c ===
/* @(#)File: sbuf3.C        Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)       >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Testing the "put" related functions of class strstreambuf.    >
    < This class is derived from the base class streambuf in which  >
    < the tested functions are originally defined.  The tested  >
    < functions are not redefined in strstreambuf, so this file >
    < is actually testing functions of streambuf.           >

>HOW:   < Declare a strtreambuf object and initialize the buffer with   >
    < a given test pattern.  Each block is used to test the     >
    < behaviour of a "put" related function.            >
    
    < 0. Test out_waiting() on empty buffer             >
    < 1. Test sputc()                       >
    < 2. Test sputn()                       >
    < 3. Test out_waiting() on full buffer              >
    < 4. Test sputc() at the end of buffer (no space left)      >
    < 5. Test sputn() at the end of buffer (no space left)      >
    
>MODS:  < Version 1.0 created by HK.                    >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "sbuf3()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif
// global variable declarations

static char msg[] = "Hi there!";    // test pattern
static char * bmsg = msg;          // marks base of pattern
static char * emsg = msg - 1 + strlen(msg);    // marks end of pattern

static char buf[10];
static strstreambuf out(buf, (int) strlen(msg), buf);
/*LX:10131999 added cast to (int) for 64-bit friendliness */

/*--------------------------------------------------------------------*/
void sbuf3_main()                                  /***** BEGINNING OF MAIN. *****/
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();                      

#if defined(USING_OLD_IOS)

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing out_waiting() on empty buffer");
    if (out.out_waiting() != 0)
        fail("unexpected return value");
#endif
    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sputc()");
    if (out.sputc(*msg) == EOF)
        fail ("unexpected error");
    if (*buf != *msg)
        fail ("unexpected char");

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sputn()");
    if (out.sputn(msg+1, (streamsize) strlen(msg) -1) == EOF)
/*LX:10131999 added cast to (int) for 64-bit friendliness */
        fail ("unexpected error");
    if (strcmp(buf, msg))
        fail ("unexpected string");

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();                      

#if defined(USING_OLD_IOS)

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing out_waiting()");
    if (out.out_waiting() != strlen(msg))
        fail("unexpected return value");
#endif
    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sputc() at end of buffer");
    if (out.sputc( '$') != EOF)
        fail ("unexpected success of sputc()");

    blexit();
/*--------------------------------------------------------------------*/
    block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sputn() at end of buffer");
    if (out.sputn( "$$$", 2) != 0)
        fail ("unexpected success of sputn()");

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();      
}                                       /******** END OF MAIN. ********/



#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\p15071.c ===
/* File: P15071.C    Version: 1.1    Date: 08/18/92
 * CVS-C++, C++ Validation Suite
 * Section: 15  Type: P - Positive Execution Test
 * Copyright 1992, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:  ISO/ANSI C++ draft, X3J16/92-0060.  15.6.1 The terminate() Function

>REL:   EH Phase III and later

>WHAT:  "Occasionally, exception handling must be abandoned for less
        subtle error handling techniques.  For example,
            - when the exception handling mechanism cannot find a
            handler for a thrown exception, 
            - when the exception handling mechanism finds the
            stack corrupted, [untestable] or
            - when a destructor called during stack unwinding caused by
            an exception tries to exit using an exception .

        In such cases,
            void terminate();
        is called; ... "

        This file only tests the case "when the exception handling
        mechanism cannot find a handler for a thrown exception".

        Assertion:
        When the exception handling mechanism cannot find a handler
        for a thrown exception, the function terminate() is called.

>HOW:   Throw an exception in a try-block for which no handler is
        provided.  Verify that terminate() gets invoked.

>NOTE:  None
======================================================================*/

#include "tsthd.h"        /* Perennial test suite header file */
#include "tsteh.h"        /* Perennial exception handling header */

static char prgnam[] = "P15071.C";

static void eh_term(void)
{
        blexit();
        anyfail(1);
        CreateExitFile();
}

/*--------------------------------------------------------------------*/
int p15071_main(void)
{
        setup();
        eh_traps();             // set_terminate() and set_unexpected() 
        set_terminate(&eh_term);
/*--------------------------------------------------------------------*/
        blenter();      /* block 00 */

        fprintf(logfp, "REF: ISO/ANSI C++ draft, X3J16/92-0060. 15.6.1 The terminate() Function\n");
        fprintf(logfp, "terminate() is called if no handler can be found.\n");

        try {
                throw 1;
        }
        catch (char) {
                failure("control passed to wrong handler");
        }
        failure("terminate() was not called");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail(1);      
        return 0;
}

#include "scaffold.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\sbuf2.c ===
/* @(#)File: sbuf2.C        Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)       >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Testing the "get" related functions of class strstreambuf.    >
    < This class is derived from the base class streambuf in which  >
    < the tested functions are originally defined.  The tested  >
    < functions are not redefined in strstreambuf, so this file >
    < is actually testing functions of streambuf.           >
    < Most tests in this file check the functions behavior at the   >
    < of the buffer (No characters left to fetch).          >

>HOW:   < Declare a strtreambuf object and initialize the buffer with   >
    < a given test pattern.  Do an sgetn() to fetch all available   >
    < chars out of the buffer.  Each block is used to test the  >
    < behaviour of a "get" related function.            >
    
    < 0. Test in_avail() at the end of buffer           >
    < 1. Test sgetc() at the end of buffer              >
    < 2. Test sbumpc() at the end of buffer             >
    < 3. Test snextc() at the end of buffer             >
    < 4. Test sputbackc()                       >
    < 5. Test sputbackc() at the beginning of the buffer (no chars  >
    <    left to put back)                      >
    < 6. Test snextc() when only one char is left to fetch.  The    >
    <    expected return value is EOF.              >
    < 7. Test stossc() at the end of buffer.  It should have no >
    <    effect.                            >
    
>MODS:  < Version 1.0 created by HK.                    >

>BUGS:  < ATT library bug:                      >
    <   stossc() behaves incorrectly at the end of the buffer.  >
    <   It continues moving the get pointer ahead even though   >
    <   the end of buffer has been reached.  This behaviour >
    <   is contrary to what is described in the ATT library >
    <   manual (stossc() should have no effect).        >
    <   As a result of that, the ATT compiler fails block 7.    >
========================================================================*/
#include "testhead.h"     

static char progname[] = "sbuf2()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
// global variable declarations
#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <strstrea.h>
#else
#include <iostream>
#include <strstream>
#endif

#define debug DbgPrint
#define NULL 0

static char msg[] = "Hi there!";    // test pattern
static char * bmsg = msg;          // marks base of pattern
static char * emsg = msg - 1 + strlen(msg);    // marks end of pattern

static char buf[20]= "Hi there!";
static strstreambuf in(buf, (int)strlen(buf));
/*LX:10131999 added cast to (int) for 64-bit friendliness */

static char tmp[20];
int c;
static char *cp = msg;

/*--------------------------------------------------------------------*/
void sbuf2_main()                                 /***** BEGINNING OF MAIN. *****/
{
    setup();
    in.sgetn(tmp, (int) strlen(msg)+5);   // read all char's to end of buffer
/*LX:10131999 added cast to (int) for 64-bit friendliness */

/*--------------------------------------------------------------------*/
    block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing in_avail() at end of buffer");
    if (in.in_avail() != 0)
        fail ("unexpected value");

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sgetc() at end of buffer");
    if (in.sgetc() != EOF)
        fail ("unexpected success of sgetc()");

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sbumpc() at end of buffer");
    if (EOF != (c= in.sbumpc()))
        fail ("unexpected sbumpc() success");

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing snextc() at end of buffer");
    if (EOF != (c= in.sbumpc()))
        fail ("unexpected sbumpc() success");

    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sputbackc()");
    for (cp = emsg ; cp >= bmsg ; cp--)
    {if (in.sputbackc(*cp) == EOF)
            fail("unexpected EOF");
    }
    if (strcmp(buf, msg))
        fail ("unexpected string");

    blexit();
/*--------------------------------------------------------------------*/
    block5: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing sputbackc() at beginning of string");
    if (EOF != in.sputbackc(*cp))
        fail ("unexpected sputbackc() success");

    blexit();
/*--------------------------------------------------------------------*/
    block6: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing snextc() when only one char is left to fetch");
    in.sgetn(tmp, (streamsize)strlen(msg) -1);
/*LX:10131999 added cast to (streamsize) for 64-bit friendliness */
    if (EOF != in.snextc())
        fail("unexpected success of snextc()");

    blexit();
/*--------------------------------------------------------------------*/
    block7: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PUB(3C++)");
    print("testing stossc() at end of string");
    in.sbumpc();
    in.stossc();
    in.stossc();
// PROBLEM: got out of the buffer area !
    for (cp = emsg ; cp >= bmsg ; cp--)
    {if (in.sputbackc(*cp) == EOF)
            fail("unexpected EOF");
    }
    in.sputbackc('*');
    if ((in.sputbackc('$') != EOF) || ((size_t)(in.in_avail()) > strlen(msg)))
        fail("unexpected string");

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\peren_another.c ===
/*=========================================================================*/
/* File  another.C    Version: 2.0.2    Date: 1/20/91                      */
/* Copyright 1985 - 1991, Perennial, All Rights Reserved                   */
/*                              another.C                                  */
/*=========================================================================*/
/*
	Included in this file are the support functions used in generating
test programs for the PERENNIAL C++ Validation Suite:

		blenter()	enter a block in a test program
		blexit()	exit a block in a test program
		failure(reason)	set failure condition for current block
				   and display diagnostic message ``reason''
		failure(reason, int, int)	an alternate format
		separate()	begin a test program
		anyfail()	end a test program
		errmesg()	exit test program with diagnostic
		pend()		controls various output streams
		debug()		useful during developement
		ipostcall()	post an integer result in standard format
		fpostcall() 	post a floating point result in standard format
		spostcall()	post a string result in standard format
		lpostcall()	post a long result in standard format


	MODIFIED: Dec 22, 1989 by Paul Stone
		Added compile_it() and get_output().

	MODIFIED: Jun 25, 1990 by Daniel Edelson
		Added failure() function.
		Removed two comment-ed out #include's
		Included <iostream.h> instead of <stream.h>
	
	MODIFIED: Aug 1, 1990 by Daniel Edelson
		Removed some commented-out, unused code or redundant code. 
		Removed commented-out function issu().
	
	MODIFIED: Aug 7, 1990 by Daniel Edelson
		Added stdarg (varargs) support to failure().
	
	MODIFIED: Aug 16, 1990 by Daniel Edelson
		Removed all references to the useless ``buffname''
		variable including erroneous references to the literal
		file ``buffname''. Included <stdlib.h> rather than <libc.h>.
		Included <errno.h> and removed extern int errno declaration. 
		Recommend routine get_output() be recoded to use library
		I/O rather than system call I/O.
	
	MODIFIED: Aug 17, 1990 by Daniel Edelson
		Recoded routine pend() to be more efficient: to avoid 
		unnecessary (useless) calls to system() and to use library
		I/O rather than sytem("cat filename") to display the
		log file. Modified function compile_it() to use 
		the remove() to delete files rather than 
		system("rm file..."). Systems that don't support the ANSI
		routine remove(char *) should define remove to be unlink.
		Bracketed the call to getenv() with conditional compilation
		based on XCOMPILE so that it can be removed for embedded
		systems whose runtime environment does not support an
		environment. Added conditional compilation around the
		error_suite functionality so that it can be removed
		when it is not desired. This is required for systems that
		lack system() in the runtime library.
		   *** Recommend get_output() be recoded ***
		   *** to use ANSI Library I/O rather    ***
		   *** than system call raw I/O.         ***

	MODIFIED: Sep 10, 1990 by Daniel Edelson
		Caused the results directory to be obtained from 
		a file named ``rslt_dir'' rather than from the environment.
		This is because free-standing ANSI C systems are not
		required to provide getenv(). Recoded some routines to
		use <stdio> library i/o rather than raw system call I/O.
	
	MODIFIED: Oct 11, 1990 by Daniel Edelson
		Changed failure(char * ...) to failure(char *, ...) to conform
		to ANSI C. The file now compiles under either ANSI C or C++.
		Removed the printfs from pend() to make the bahavior the same
		as that of the ANSI C scaffold. Removed the function cat() 
		because with pend() gutted it's no longer used.
    
	MODIFIED: Oct 25, 1990 by Paul Stone
		Removed references to tmp2.out file (err_msg suite).
	
	MODIFIED: Jan 20, 1991 by Daniel Edelson, Version 2.0.2
		Changed failure() so that it ONLY takes a (char *) argument.
		The old version invoked vsprintf() which non-ANSI-C
		platforms need not have. Also provided an overloaded
		function that takes a char * and two ints because
		a couple of testcases expect that.


Copyright 1984-91, PERENNIAL INC., ALL RIGHTS RESERVED
=============================================================================*/

/******************************************************************************
MS changes:
20-Mar-1991 mattheww		temp=stdout
22-Mar-1991 mattheww            comment out overloaded failure() definition
27-Jul-1992 bos                 added changes for Windows testing;  see sections
                                  separated by MICROSOFT CHANGES
******************************************************************************/

#include <stdio.h>
#include <errno.h>
#include <string.h>

#include "testhead.h"

/************************** MICROSOFT CHANGES ******************************/
#ifndef PEREN_TEST
#ifdef _WINDOWS
static char test[] = "CVSCC";
#endif
#endif
/************************** MICROSOFT CHANGES ******************************/



#define  PASSED 0
#define  FAILED 1
#define  ERROR -1 
#define  FATAL -2
#define  TRUE   1
#define  FALSE  0

#define  DFAIL  0
#define  DPASS  1
#define  DTERS  2
#define  DVERB  3
#define  DDEBUG 4

#define PMODE 0644

#if TERS                         
#define COMPILE_FLAG  DTERS
#endif

#if DEBUG
#define COMPILE_FLAG  DDEBUG
#endif

#if VERB
#define COMPILE_FLAG  DVERB
#endif

#if PASS 
#define COMPILE_FLAG  DPASS
#endif

#if FAIL
#define COMPILE_FLAG  DFAIL
#endif

#ifndef COMPILE_FLAG
#define COMPILE_FLAG  DTERS      
#endif


#ifdef XCOMPILE
#define	NO_ERR_SUITE
#endif



static int output_flag = COMPILE_FLAG;


static int block_number;	/* This identifies the current block */

static int condition_number;	/* This is a number used to identify the 
				  exact points of failure */
static int global_flag = PASSED;	/* Pass/Fail flag for the entire program */


static char * getresdir();


static char testname[30];
static char logxname[30];

static void blenter(){
	 DbgPrint("\tEnter Block #%d \n",block_number);  
	 /* fflush(temp) */ 
	 fflush(stderr); 
	 local_flag = PASSED;
	 condition_number = 0;
}



blexit(){
	char * INTERNAL = "*** Internal error : exiting block %d \n\n";

	DbgPrint("\tExit Block #%d ",block_number++); 
	switch(local_flag) {
	case PASSED: {  DbgPrint("passed\n\n"); 
	 		/* fflush(temp) */ 
		        return PASSED;
		     }
	case FAILED: {  DbgPrint("FAIL\n\n");
	 		/* fflush(temp) */
		        return global_flag = FAILED;
		     }
	default:     {  DbgPrint( INTERNAL, block_number);
	 		/* fflush(temp) */
			return global_flag = ERROR;
		     }
	}
}


static void separate()
{

/*
 * This section opens all the report files in the Results directory
 * Also resets block_number and global_flag
 */

	int i = 0;
	int flag;
	char c, name[20];   

	block_number = 0 ;
	global_flag = PASSED ;

	c = progname[0];
	flag = TRUE;

	while(flag)
		if((c != '\0') && (c != '.') && (c != '(')) {
			name[i] = c;
			i++;
			c = progname[i];
		}
		else flag = FALSE;
	name[i] = '\0';

	strcpy(testname, name);
	strcat(testname, ".c");
	strcpy(logxname, getresdir());

	strcat(logxname, name);
	strcat(logxname, ".log");
#if 0
	if ((temp = fopen(logxname, "w")) == NULL){
		DbgPrint("%s : separate: can`t open log file\n",
			testname);
		return; /* exit(-4); */
	}
#endif
	temp=stdout;
	DbgPrint("===%s\n",progname);
	/* fflush(temp) */
}



static void setup()
{
	separate();
}



static void debug()
{
	DbgPrint("Debug function:\n");
	DbgPrint("name %s \n",progname);
	DbgPrint("test %s \n",testname);
	DbgPrint("global_flag %d \n",global_flag);
	DbgPrint("local_flag %d \n",local_flag);
	DbgPrint("block_number %d \n",block_number);
	DbgPrint("condition_number %d \n",condition_number);
}



static void 
errmesg(char message[])          
{
	DbgPrint("*** Internal error %s \n",message);
	debug();
	DbgPrint("*** Internal error %s error\n",message);
	/* fflush(temp)  */
	return; /* exit(-1); */ 
}


static pend()
{

	switch(output_flag) {
		case DFAIL: 
		case DPASS:
		case DTERS:  
		case DVERB: 
		case DDEBUG:
			break;
		default: 
			output_flag = FATAL;
	}

	fclose(temp);
	return output_flag;
}



static void anyfail(){
	switch(global_flag){
		case PASSED: { DbgPrint("++++++++++++%s Passed\n",
					progname);
			       pend();
			       return; /* exit(PASSED); */
			     }
			
		case FAILED: { DbgPrint("------------%s ******FAILED******\n",
					progname);
			       pend();
			       return; /* exit(FAILED); */
			     }
		case ERROR:  { DbgPrint("***Internal Error");
			       DbgPrint("***Internal Error anyfail"); 
			       pend();
			       return; /* exit(ERROR); */
			     }
		default:     { DbgPrint("Fatal Error in %s",testname);
			       DbgPrint("Fatal Error in %s",testname);
			       pend();
			       return; /* exit(32767); */
			     }
		}
}



static void 
ipostcall(int got, int expected, char mesgstr[])
{
	DbgPrint("\t\tgot  %d expected  %d %s \n",got ,expected, mesgstr);
	/* fflush(temp) */
}

static void 
opostcall(int got, int expected, char mesgstr[])
{
	DbgPrint("\t\tgot  %o expected  %o %s \n",got ,expected, mesgstr);
	/* fflush(temp) */
}

static void 
fpostcall(float got, float expected, char mesgstr[])
{
	DbgPrint("\t\tgot  %f expected  %f %s \n",got ,expected, mesgstr);
	/* fflush(temp) */
}

static void 
spostcall(char got[], char expected[], char mesgstr[])
{
	DbgPrint("\t\tgot  :%s: expected  :%s: %s \n",
		got ,expected, mesgstr);
	/* fflush(temp) */
}

static void 
lpostcall(long got, long expected, char mesgstr[])
{
	DbgPrint("\t\tgot %d expected  %d %s\n",
		got,expected,mesgstr );
	/* fflush(temp) */
}

#ifndef NO_ERR_SUITE

#define DEBUG 1
#define CC_OUT_SZ 2046
#define EXPECT_SZ 254

static char got[CC_OUT_SZ];			/* CC stderr */
static char expect[EXPECT_SZ];			/* expected error match substring */

/* 
 * get_output() --- Get output from file and put in buf.
 *
 *	Returns: 	0 if ok, else 1.
 */
static int get_output(
	char * file,			/* file name */
	char *buf,			/* target buffer */
	int size			/* max size */
	)
{
	FILE * fp;
	size_t r; /*LX:10131999 /int/size_t for 64-bit friendliness */

	fp = fopen (file, "r");
	if (fp == NULL) {
		DbgPrint( "Can't open %s. errno=%d\n", file, errno);
		return 1;
	}
/*LX:10131999 added the (int) cast below. Not sure why this is so general in the 
first place. sizeof(*buf) seems to be always 1, but I leave it at this for now */
	r = fread (buf, (int) sizeof(*buf), size, fp);
	if (r < 0) {
		DbgPrint( "Can't read %s. errno=%d\n", file, errno);
		return 1;
	}
	/* DbgPrint("buf=\n%s\n", buf); */

	fclose (fp);
	return 0;
}

static int lc_get_output()
{
	if (get_output ("tmp.out", (char*) &got, CC_OUT_SZ)) {
		DbgPrint( "Could not obtain results of compile.\n");
		local_flag = FAILED;
	}
	else if (get_output ("exp.out", (char*) &expect, EXPECT_SZ)) {
		DbgPrint( 
		  "Could not obtain expectations of compile.\n");
		local_flag = FAILED;
	}
	return (local_flag == FAILED);
}

static void compile_it(char *what)
{
	int r=0;

	char command[1022];

	sprintf (command, "%s %s", "./doCC.sh", what);

        /* Compile test only. */

/************************** MICROSOFT CHANGES ******************************/
#ifdef PEREN_TEST
#ifdef _WINDOWS
        /* r = system (command); */
#endif
#endif
/************************** MICROSOFT CHANGES ******************************/

	r = (r & 0xff00) >> 8 ;

	switch (r) {
	case 0:		/* OK */
		break;
	case 1:
		DbgPrint( "Missing err_data file. UNTESTED.\n");
		local_flag = FAILED;
		break;
	case 2:
		DbgPrint( "Missing err_path file. UNTESTED.\n");
		local_flag = FAILED;
		break;
	case 3:
		DbgPrint( "Incomplete err_data file. UNTESTED.\n");
		local_flag = FAILED;
		break;
	case 4:
		DbgPrint( "Incomplete err_path file. UNTESTED.\n");
		local_flag = FAILED;
		break;
	case 5:
		DbgPrint( "Test case file nonexistent. UNTESTED.\n");
		local_flag = FAILED;
		break;
	case 6:
		DbgPrint( "Exit status of CC = 0. Expected non-zero.\n");
		local_flag = FAILED;
		break;
	case 7:
		if (lc_get_output())	/* Can't get CC output? */
			break;		/* Failure */

		DbgPrint( 
		  "Expected error message keywords: %s\nGot: %s\n", 
			expect, got); /* But not a failure. */
		break;
	case 8:
		DbgPrint( "No error or warning message.\n");
		local_flag = FAILED;
		break;

	case 9:
		if (lc_get_output())	/* Can't get CC output? */
			break;		/* Failure */

		DbgPrint( 
		  "Unexpected error (should be implemented).\nGot: %s\n", 
			got); /* But not a failure. */
		break;

	case 10:
		if (lc_get_output())	/* Can't get CC output? */
			break;		/* Failure */

		DbgPrint( 
	         "Unexpected non-zero status (should be implemented).\n");
		/* But not a failure. */
		break;

	default:
		DbgPrint( "Unexpected result. Exit status=%d\n", r);
		if (r < 0) DbgPrint( "/t errno=%d.", errno);
		local_flag = FAILED;
		break;
	}

	if (!DEBUG) {
		remove("tmp.out");
		remove("exp.out");
	}
}

#endif /* NO_ERR_SUITE */

/*
 * failure()
 *
 * As a convenience and shorthand for the test programmer, the function
 * failure(msg) will set local_flag to FAILED and display a diagnostic that
 * is intended to be the reason that the block failed. 
 *
 * As a convenience, if the message is not terminated by a newline '\n' the
 * routine will output one. To do this it first writes the string to a
 * buffer and then prints the buffer.
 */
static void failure(char * format)
{
	DbgPrint( "%s : %s", progname, format);
	if (format[strlen(format) - 1] != '\n')
		DbgPrint( "\n");
	local_flag = FAILED;
}

#if defined(__cplusplus)
static void failure(char * format, int i1, int i2)
{
	char buf[256];
	sprintf(buf, "%s : %s", progname, format);
	DbgPrint( buf, i1, i2);
	if (format[strlen(format) - 1] != '\n')
		DbgPrint( "\n");
	local_flag = FAILED;
}
#endif

#ifdef XCOMPILE
static char default_dir[] = "CROSS/Results/";
#else
static char default_dir[] = "D:\\";
#endif

static char *
getresdir()
{
	static char dirname[256];
	FILE * fp;

	fp = fopen("rslt_dir", "r");

	if (fp == NULL || fscanf(fp, "%s", dirname) == 0)
	    strcpy(dirname, default_dir);

	return dirname;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\sbuf6.c ===
/* @(#)File: sbuf6.C        Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)      >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Testing the default definitions of of the following virtual   >
    < functions of class streambuf: pbackfail, seekoff, seekpos,    >
    < setbuf, sync.                         >

>HOW:   < Constructs an empty buffer with streambuf().          > 
    < Check the default definitions of each function.       >
    
    < 0. pbackfail(c) returns EOF.                  >

    < 1. seekoff(off, dir, mode) returns EOF.           >

    < 2. seekpos(pos, mode) returns seekoff(streamoff(pos),     >
    <    ios::beg, mode).  Since seekoff returns EOF, seekpos   >
    <    should also return EOF.                    >

    < 3. setbuf(ptr, len) is used to set up a reserve area and  >
    <    always honors the request when there is no reserve area.   >
    <    the return value is then the address of the streambuf. >

    < 4. sync() returns 0 if the get area is empty and there are    >
    <    no unconsumed characters.  Otherwise it returns EOF.   >
    
>MODS:  < Version 1.0 created by HK.                    >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "sbuf6()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif
// global variable declarations

//char buf[10]="hi!";

#if defined(USING_OLD_IOS)
static streambuf sb;//(buf, 6);
#else
static char buf[10]="hi!";
static strstreambuf sb(buf, 6, buf);
#endif
/*--------------------------------------------------------------------*/
void sbuf6_main()                                 /***** BEGINNING OF MAIN. *****/
{
    setup();
#if defined(USING_OLD_IOS)

/*--------------------------------------------------------------------*/
    block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("The default definition of pbackfail(c) returns EOF");

    if (sb.pbackfail(0) != EOF)
        fail("unexpected return value");
    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("The default definition of seekoff(off, dir, mode) returns EOF");

    if (sb.seekoff(0, ios::beg, 0) != EOF)
        fail("unexpected return value");

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("The default definition of seekpos(pos, mode) returns EOF");

    if (sb.seekpos(0, 0) != EOF)
        fail("unexpected return value");

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("The buffer created by the constructor streambuf() has no");
    print("reserve area.  Use setbuf(char *, int) to set up a reserve");
    print("area.  The default definition of setbuf honors the request");
    print("when there is no previous reserve area.");

    char buf3[10];

    if (sb.setbuf(buf3, 10) != &sb)
        fail("unexpected setbuf failure");

    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("The default definition of sync() returns 0 when the get");
    print("area is empty and there are no unconsumed characters.");

    int s = sb.sync();

    if ((s != EOF) && (s != 0))
        fail("unexpected return value");

    /*
    if (sb.in_avail()+sb.out_waiting())
        {if (sb.sync() != EOF)
            fail("sync() doesn't return expected value EOF");
        }
    else
        {if (sb.sync() != 0)
            fail("sync() doesn't return expected value 0");
        }
    */

    blexit();
/*--------------------------------------------------------------------*/
#endif
    anyfail();      
}                                       /******** END OF MAIN. ********/



#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sources

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built

!ENDIF

TARGETTYPE=LIBRARY
TARGETPATH=..\..\lib

386_STDCALL=0
USER_C_FLAGS=-TP -DQA_DBG_OUTPUT_DEBUGWIN=1 -DXBOX -DPEREN_TEST
USE_NATIVE_EH=1
LINKER_FLAGS=/IGNORE:4006

SOURCES=\
	..\a15039.c \
	..\p15038.c \
	..\p15071.c \
	..\a15040.c \
	..\a15050.c \
	..\a15051.c \
	..\a15052.c \
	..\a15053.c \
	..\a15054.c \
	..\p15036.c \
	..\p15037.c \
	..\filbuf_1.c \
	..\filbuf_2.c \
	..\filbuf_3.c \
	..\format1.c \
	..\format2.c \
	..\format3.c \
	..\format4.c \
	..\format5.c \
	..\format6.c \
	..\format7.c \
	..\fstream1.c \
	..\fstream2.c \
	..\fstream3.c \
	..\ios2.c \
	..\ios3.c \
	..\ios4.c \
	..\ios5.c \
	..\ios6.c \
	..\iosenum1.c \
	..\iosenum3.c \
	..\iosenum4.c \
	..\iosenum5.c \
	..\istream1.c \
	..\istreama.c \
	..\istreamb.c \
	..\istreamc.c \
	..\istream2.c \
	..\istream3.c \
	..\istream4.c \
	..\istream5.c \
	..\istream6.c \
	..\istream7.c \
	..\istream8.c \
	..\istream9.c \
	..\manip1.c \
	..\manip3.c \
	..\manip5.c \
	..\ofstream.c \
	..\osfx.c \
	..\osfx2.c \
	..\ostream1.c \
	..\ostream2.c \
	..\ostream3.c \
	..\ostream4.c \
	..\ostream5.c \
	..\ostream6.c \
	..\ostream7.c \
	..\ostream8.c \
	..\sbuf1.c \
	..\sbuf2.c \
	..\sbuf3.c \
	..\sbuf4.c \
	..\sbuf5.c \
	..\sbuf6.c \
	..\ssbuf1.c \
	..\ssbuf2.c \
	..\ssbuf3.c \
	..\ssbuf4.c \
	..\ssbuf5.c \
	..\ssbuf6.c \
	..\stdiobuf.c \
	..\stream.c \
	..\strm_wa.c \
	..\syncstd1.c \
	..\syncstd2.c \
	..\perennial.cpp

INCLUDES=$(XDK_INC_PATH);$(INCLUDES)

MSC_WARNING_LEVEL=/W2

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\sbuf5.c ===
/* @(#)File: sbuf5.C        Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)      >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Testing the streambuf(char *, int) constructor        >

>HOW:   < streambuf(char * b, int len) constructs an empty buffer   >
    < and then sets up the reserve area to be the len bytes     >
    < starting at b.                        >
    
    < 0. Check the get area is empty using in_avail()       >
    < 1. Check the put area is empty using out_waiting()        >
    < 2. Get and put a string to check the buffer is functional >
    
>MODS:  < Version 1.0 created by HK.                    >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "sbuf5()";         

inline void print(char str[]) { DbgPrint( "%s\n", str); }
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
    }

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif
// global variable declarations

static char buf[10]="hi!";

#if defined(USING_OLD_IOS)
static streambuf sb(buf, 6);
#else
static strstreambuf sb(buf, 6, buf);
#endif 
/*--------------------------------------------------------------------*/
void sbuf5_main()                                  /***** BEGINNING OF MAIN. *****/
{
        setup();
/*--------------------------------------------------------------------*/
block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("The buffer created by the constructor streambuf(char *, int)");
    print("has an empty get area.");

    if (sb.in_avail() != 0)
        fail("get area is not empty");

        blexit();
/*--------------------------------------------------------------------*/
block1: blenter();                      
#if defined(USING_OLD_IOS)

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("The buffer created by the constructor streambuf(char *, int)");
    print("has an empty put area.");

    if (sb.out_waiting() != 0)
        fail("put area is not empty");
#endif 
        blexit();
/*--------------------------------------------------------------------*/
block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("The buffer created by the constructor streambuf(char *, int)");
    print("is functional. Try to put and get data.");

    static char in[5] = "test";

    if ((sb.sputn(in, 4) != 4) || (strncmp(buf, in, 4)))
        fail ("unexpected put error");

    static char out[5] = "";

    if ((sb.sgetn(out, 4) != 4) || (strncmp(out, in, 4)))
        fail ("unexpected get error");

        blexit();
/*--------------------------------------------------------------------*/
        anyfail();      
}                                       /******** END OF MAIN. ********/



#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ssbuf1.c ===
/* @(#)File: ssbuf1.C       Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SSBUF(3C++)      >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Testing the strstreambuf() constructor            >

>HOW:   < strstreambuf() constructs an empty buffer in dynamic mode.    >
    
    < 0. Check the get area is empty using in_avail()       >
    < 1. Check the put area is empty using out_waiting()        >
    < 2. Get and put a string to check the buffer is functional >
    
>MODS:  < Version 1.0 created by HK.                    >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ssbuf1()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif
// global variable declarations

static strstreambuf sb;
/*--------------------------------------------------------------------*/
void ssbuf1_main()                                 /***** BEGINNING OF MAIN. *****/
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SSBUF(3C++)");
    print("Check that a buffer created by constructor strstreambuf()");
    print("has an empty get area.");

    if (sb.in_avail() != 0)
        fail("get area is not empty");

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();                      
#if defined(USING_OLD_IOS)

    print("REF: AT&T C++ Library Manual, Appendix A, SSBUF(3C++)");
    print("Check that a buffer created by constructor strstreambuf()");
    print("has an empty put area.");

    if (sb.out_waiting() != 0)
        fail("put area is not empty");
#endif 
    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SSBUF(3C++)");
    print("Check that a buffer created by constructor strstreambuf()");
    print("is functional.");

    static char in[5] = "test";

    if (sb.sputn(in, 4) != 4)
        fail ("unexpected put error");

    static char out[5] = "";

    if ((sb.sgetn(out, 4) != 4) || (strncmp(out, in, 4)))
        fail ("unexpected get error");

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();      
}                                       /******** END OF MAIN. ********/



#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\scaffold.cxx ===
/* File: scaffold.C    Version: 2.9    Date: 11/12/92
 * CVS-C++, C++ Validation Suite
 * Section: scaffold
 * Copyright 1985-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        
>WHAT:  Included in this file are the support functions used in generating
        test programs for the PERENNIAL C++ Validation Suite:

                blenter()       enter a block in a test program
                blexit()        exit a block in a test program
                failure(reason) set failure condition for current block
                                   and display diagnostic message ``reason''
                failure(reason, int)    an alternate format
                failure(reason, int, int)       an alternate format
                setup()         begin a test program
                anyfail()       end a test program
                errmesg()       exit test program with diagnostic
                pend()          controls various output streams
                debug()         useful during developement
                ipost()         post an integer result in standard format
                fpost()         post a floating point result in standard format
                spost()         post a string result in standard format
                lpost()         post a long result in standard format

>NOTE:  None.

======================================================================
MSC CHANGES:
    28-Jun-93   bruceku added comments with MICROSOFT CHANGES around
                          modified lines

======================================================================*/

#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <stddef.h>

#if defined(_DEBUG)
#include <crtdbg.h>
#endif 

#include "tsthd.h"

/*************************** MICROSOFT CHANGES *****************************/
#include <eh.h>

#ifndef PEREN_TEST
#ifdef _WINDOWS
static char test[] = "CVSEH";
#endif
#endif
/*************************** MICROSOFT CHANGES *****************************/

#define  PASSED 0
#define  FAILED 1
#define  ERROR -1 
#define  FATAL -2
#define  TRUE   1
#define  FALSE  0

#define  DFAIL  0
#define  DPASS  1
#define  DTERS  2
#define  DVERB  3
#define  DDEBUG 4

#define PMODE 0644
#define  WRITEPLUS     "w+"
#define  ACVS_MAX_OPEN 5

#if TERS                         
#define COMPILE_FLAG  DTERS
#endif

#if DEBUG
#define COMPILE_FLAG  DDEBUG
#endif

#if VERB
#define COMPILE_FLAG  DVERB
#endif

#if PASS 
#define COMPILE_FLAG  DPASS
#endif

#if FAIL
#define COMPILE_FLAG  DFAIL
#endif

#ifndef COMPILE_FLAG
#define COMPILE_FLAG  DTERS      
#endif


#ifdef XCOMPILE
#define NO_ERR_SUITE
#endif

/*-------------------------------------*
 *                                     *
 * block tracking states               *
 *                                     *
 *-------------------------------------*/

#define START 0
#define OUTBLK 1
#define INBLK 2
#define END 3
static int state=START;


static int output_flag = COMPILE_FLAG;

static int locflg;             /* This flag is used in blocks to track failure. */


static int condition_number;   /* This is a number used to identify the 
                           exact points of failure */
static int gloflg;             /* Pass/Fail flag for the entire program */

static char * getresdir();

/*************************** MICROSOFT CHANGES *****************************/
#if defined(PEREN_TEST)
#else
#endif

#if defined(_DLL) && defined(_M_MPPC)
static "C" {
static void _TestExit(int);
}
#endif 

static void crt_test_terminate()
{
//  DbgPrint("hello\n");    //! remove after testing.
  CreateExitFile();
  abort();
}

/*************************** MICROSOFT CHANGES *****************************/
 
static char testname[30];
static char logxname[30];

static FILE *Filefp[ACVS_MAX_OPEN];  /* An array of pointers to temp streams.*/
static char FileName[ACVS_MAX_OPEN][L_tmpnam]; /* To hold the names of temp files.*/

static void errmesg(char *);

static void blenter(){
        if (state != OUTBLK)
                switch (state) {
                case INBLK:     errmesg("Two successive calls to blenter().");
                        break;
                case START:     errmesg("The test did not call setup().");
                        break;
                case END:       errmesg("blenter() is called after anyfail().");
                        break;
                default:errmesg("State machine in unknown state.");
                }
        state=INBLK;

        block_number++;
        fprintf(logfp,"\tEnter Block #%d \n",block_number);  
        fflush(logfp); 
        fflush(stderr); 
        locflg = PASSED;
        condition_number = 0;
}

blexit(){
        if (state != INBLK)
                switch (state) {
                case OUTBLK:    errmesg("Two successive calls to blexit().");
                        break;
                case START:     errmesg("The test did not call setup().");
                        break;
                case END:       errmesg("blexit() is called after anyfail().");
                        break;
                default:errmesg("State machine in unknown state.");
                }
        state=OUTBLK;

        fprintf(logfp,"\tExit Block #%d ",block_number); 
        switch(locflg) {
        case PASSED: {  fprintf(logfp,"passed\n\n"); 
                        fflush(logfp);
                        return PASSED;
                        }
        case FAILED: {  fprintf(logfp,"FAIL\n\n");
                        fflush(logfp);
                        return gloflg = FAILED;
                        }
        default: {      fprintf(logfp,"Unknown block result");
                        fflush(logfp);
                        return gloflg = ERROR;
                        }
        }
}


static void setup()
{

/*
 * This section opens all the report files in the Results directory
 * Also resets block_number and gloflg
 */

        int i = 0;
        int flag;
        char c, name[20];   

        if (state != START)
                errmesg("setup() was called more than once");
        state=OUTBLK;

        block_number = -1 ;

        gloflg = PASSED ;

        c = prgnam[0];
        flag = TRUE;

        while(flag)
                if((c != '\0') && (c != '.') && (c != '(')) {
                        name[i] = c;
                        i++;
                        c = prgnam[i];
                }
                else flag = FALSE;
        name[i] = '\0';

        strcpy(testname, name);
        strcat(testname, ".c");
        strcpy(logxname, getresdir());

        strcat(logxname, name);
        strcat(logxname, ".log");

/*************************** MICROSOFT CHANGES *****************************/
#if defined(_DEBUG)
		_CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
		_CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );
		_CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
		_CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );
		_CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
		_CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );
#endif 

#if defined(PEREN_TEST)
        if ((logfp = fopen(logxname, "w")) == NULL){
                fprintf(stderr,"%s : setup: can`t open log file\n",
                        testname);
                return; /* exit(-4); */
        }
        fprintf(logfp,"===%s\n",prgnam);
        fflush(logfp);
#else
        setvbuf( logfp, NULL, _IONBF, 0 );
#endif

#if defined(_DLL) && !defined(_M_MPPC)
        set_terminate (crt_test_terminate);
#endif        
/*************************** MICROSOFT CHANGES *****************************/

}

static void debug()
{
        fprintf(logfp,"Debug function:\n");
        fprintf(logfp,"name %s \n",prgnam);
        fprintf(logfp,"test %s \n",testname);
        fprintf(logfp,"block_number %d \n",block_number);
        fprintf(logfp,"gloflg %d (test result)\n",gloflg);
        fprintf(logfp,"locflg %d (block result)\n",locflg);
        fprintf(logfp,"state %d (block tracking state machine)\n",state);
        fprintf(logfp,"condition_number %d \n",condition_number);
        fprintf(stderr,"Debug function:\n");
        fprintf(stderr,"name %s \n",prgnam);
        fprintf(stderr,"test %s \n",testname);
        fprintf(stderr,"block_number %d \n",block_number);
        fprintf(stderr,"gloflg %d (test result)\n",gloflg);
        fprintf(stderr,"locflg %d (block result)\n",locflg);
        fprintf(stderr,"state %d (block tracking state machine)\n",state);
        fprintf(stderr,"condition_number %d \n",condition_number);
}

static void 
/*************************** MICROSOFT CHANGES *****************************/
errmesg(char *message)                          /* was char message[] */
/*************************** MICROSOFT CHANGES *****************************/
{
        fprintf(logfp,"------------%s *** Internal error: %s\n",
                prgnam, message);
        fprintf(stderr,"------------%s *** Internal error: %s\n",
                prgnam, message);
#ifdef DEBUG
        debug();
#endif
        fflush(logfp) ;
        fflush(stderr) ;
        return; /* exit(ERROR); */ 
}


static pend()
{

        switch(output_flag) {
                case DFAIL: 
                case DPASS:
                case DTERS:  
                case DVERB: 
                case DDEBUG:
                        break;
                default: 
                        output_flag = FATAL;
        }

        fclose(logfp);
        return output_flag;
}

static void anyfail(){
        if (state != OUTBLK)
                switch (state) {
                case START:     errmesg("setup() was never called.");
                        break;
                case INBLK:     errmesg("anyfail() was called before blexit().");
                        break;
                case END:       errmesg("Two successive calls to anyfail().");
                        break;
                default:errmesg("State machine in unknown state.");
                }
        state=END;
        if (block_number < 0)
                errmesg("blenter() was never called.");

        switch(gloflg){
                case PASSED: { fprintf(logfp,"++++++++++++%s Passed\n",
                                        prgnam);
                               pend();
                               return; /* exit(PASSED); */
                             }
                        
                case FAILED: { fprintf(logfp,"------------%s ******FAILED******\n",
                                        prgnam);
                               pend();
                               return; /* exit(FAILED); */
                             }
                case ERROR:  { fprintf(logfp,"***Internal Error");
                               fprintf(stderr,"***Internal Error"); 
                               pend();
                               return; /* exit(ERROR); */
                             }
                default:     { fprintf(stderr,"Fatal Error in %s",testname);
                               fprintf(logfp,"Fatal Error in %s",testname);
                               pend();
                               return; /* exit(32767); */
                             }
                }
}

static void 
anyfail(int expected_blocks)
{
        char msg[80];   /* buffer used to build messages for errmesg() */

        if (expected_blocks != (block_number+1)){
                sprintf(msg, "Expected %d blocks, found %d\n", 
                        expected_blocks, block_number+1);
                errmesg(msg);
                }
        anyfail();
}

static void 
ipost(int got, int expected, char mesgstr[])
{
        fprintf(logfp,"\t\tgot  %d expected  %d %s \n",got ,expected, mesgstr);
        fflush(logfp);
}

static void 
opost(int got, int expected, char mesgstr[])
{
        fprintf(logfp,"\t\tgot  %o expected  %o %s \n",got ,expected, mesgstr);
        fflush(logfp);
}

static void 
fpost(float got, float expected, char mesgstr[])
{
        fprintf(logfp,"\t\tgot  %f expected  %f %s \n",got ,expected, mesgstr);
        fflush(logfp);
}

static void 
spost(char got[], char expected[], char mesgstr[])
{
        fprintf(logfp,"\t\tgot  :%s: expected  :%s: %s \n",
                got ,expected, mesgstr);
        fflush(logfp);
}

static void 
lpost(long got, long expected, char mesgstr[])
{
        fprintf(logfp,"\t\tgot %d expected  %d %s\n",
                got,expected,mesgstr );
        fflush(logfp);
}

/* #ifndef NO_ERR_SUITE */
#if 0

#define DEBUG 1
#define CC_OUT_SZ 2046
#define EXPECT_SZ 254

static char got[CC_OUT_SZ];                    /* CC stderr */
static char expect[EXPECT_SZ];                 /* expected error match substring */

/* 
 * get_output() --- Get output from file and put in buf.
 *
 *      Returns:        0 if ok, else 1.
 */
static int get_output(
        char * file,                    /* file name */
        char *buf,                      /* target buffer */
        int size                        /* max size */
        )
{
        FILE * fp;
        int r;

        fp = fopen (file, "r");
        if (fp == NULL) {
                fprintf(logfp, "Can't open %s. errno=%d\n", file, errno);
                return 1;
        }

        r = fread (buf, sizeof(*buf), size, fp);
        if (r < 0) {
                fprintf(logfp, "Can't read %s. errno=%d\n", file, errno);
                return 1;
        }
        /* DbgPrint("buf=\n%s\n", buf); */

        fclose (fp);
        return 0;
}

static int lc_get_output()
{
        if (get_output ("tmp.out", (char*) &got, CC_OUT_SZ)) {
                fprintf(logfp, "Could not obtain results of compile.\n");
                locflg = FAILED;
        }
        else if (get_output ("exp.out", (char*) &expect, EXPECT_SZ)) {
                fprintf(logfp, 
                  "Could not obtain expectations of compile.\n");
                locflg = FAILED;
        }
        return (locflg == FAILED);
}

static void compile_it(char *what)
{
        int r;

        char command[1022];

        sprintf (command, "%s %s", "./doCC.sh", what);

        /* Compile test only. */

        /* r = system (command); */

        r = (r & 0xff00) >> 8 ;

        switch (r) {
        case 0:         /* OK */
                break;
        case 1:
                fprintf(logfp, "Missing err_data file. UNTESTED.\n");
                locflg = FAILED;
                break;
        case 2:
                fprintf(logfp, "Missing err_path file. UNTESTED.\n");
                locflg = FAILED;
                break;
        case 3:
                fprintf(logfp, "Incomplete err_data file. UNTESTED.\n");
                locflg = FAILED;
                break;
        case 4:
                fprintf(logfp, "Incomplete err_path file. UNTESTED.\n");
                locflg = FAILED;
                break;
        case 5:
                fprintf(logfp, "Test case file nonexistent. UNTESTED.\n");
                locflg = FAILED;
                break;
        case 6:
                fprintf(logfp, "Exit status of CC = 0. Expected non-zero.\n");
                locflg = FAILED;
                break;
        case 7:
                if (lc_get_output())    /* Can't get CC output? */
                        break;          /* Failure */

                fprintf(logfp, 
                  "Expected error message keywords: %s\nGot: %s\n", 
                        expect, got); /* But not a failure. */
                break;
        case 8:
                fprintf(logfp, "No error or warning message.\n");
                locflg = FAILED;
                break;

        case 9:
                if (lc_get_output())    /* Can't get CC output? */
                        break;          /* Failure */

                fprintf(logfp, 
                  "Unexpected error (should be implemented).\nGot: %s\n", 
                        got); /* But not a failure. */
                break;

        case 10:
                if (lc_get_output())    /* Can't get CC output? */
                        break;          /* Failure */

                fprintf(logfp, 
                 "Unexpected non-zero status (should be implemented).\n");
                /* But not a failure. */
                break;

        default:
                fprintf(logfp, "Unexpected result. Exit status=%d\n", r);
                if (r < 0) fprintf(logfp, "/t errno=%d.", errno);
                locflg = FAILED;
                break;
        }

        if (!DEBUG) {
                remove("tmp.out");
                remove("exp.out");
        }
}

#endif /* NO_ERR_SUITE */

/*
 * failure()
 *
 * As a convenience and shorthand for the test programmer, the function
 * failure(str) will set locflg to FAILED and display a diagnostic that
 * is intended to be the reason that the block failed. 
 *
 * As a convenience, if the message is not terminated by a newline '\n' the
 * routine will output one. To do this it first writes the string to a
 * buffer and then prints the buffer.
 */
static void failure(char * format)
{
        fprintf(logfp, "%s : %s", prgnam, format);
        if (format[strlen(format) - 1] != '\n')
                fprintf(logfp, "\n");
        locflg = FAILED;
}

static void failure(char * format, int i1)
{
        char buf[256];
        sprintf(buf, "%s : %s", prgnam, format);
        fprintf(logfp, buf, i1);
        if (format[strlen(format) - 1] != '\n')
                fprintf(logfp, "\n");
        locflg = FAILED;
}

static void failure(char * format, int i1, int i2)
{
        char buf[256];
        sprintf(buf, "%s : %s", prgnam, format);
        fprintf(logfp, buf, i1, i2);
        if (format[strlen(format) - 1] != '\n')
                fprintf(logfp, "\n");
        locflg = FAILED;
}


#ifdef XCOMPILE
static char default_dir[] = "CROSS/Results/";
#else
static char default_dir[] = "D:\\";
#endif

static char *
getresdir()
{
        static char dirname[256];
        FILE * fp;

        fp = fopen("rslt_dir", "r");

        if (fp == NULL || fscanf(fp, "%s", dirname) == 0)
            strcpy(dirname, default_dir);

        return dirname;
}

/*
 * b4abort()
 *
 * This function is provided for use right before the point of a type A
 * test where a call to abort() is expected. 
 *
 * The driver passes a type A test if the test exits with a call to abort()
 * and if the last line in the log file has the string ABORT_EXPECTED_NOW.
 * This function writes ABORT_EXPECTED_NOW to the log file and flushes the
 * log file and stderr pointers.
 */
static void b4abort(void)
{
        fprintf(logfp, "%s : ABORT_EXPECTED_NOW\n", prgnam);
        fflush(logfp); 
        fflush(stderr); 
}

/* added by HK to accommodate ACVS tests */

/*----------------------------------------------------------------*\
 * FUNCTION: opnfil()                                             *
 * ARGUMENTS:   n - An integer holding the index to the desired   *
 *                  file name and file pointer to close and       * 
 *                  and remove.                                   * 
 *                  n must be less than ACVS_MAX_OPEN.            *
 * DESCRIPTION: A support utility that is used to create a file   *
 *              with a call to the function tmpnam() to get a     *
 *              valid file name.  The file name and file pointer  *
 *              are stored in the global variables FileName[n]    *
 *              and Filefp[n].                                    *
 *              A total of ACVS_MAX_OPEN can be open at the same  *
 *              time.                                             *
 *              The support function "clsrmfil()" must be used to *
 *              close and remove the temporary file.              *
 * RETURNS: A valid FILE * that can be used to read or write the  *
 *          stream.                                               *
 *          NULL, if the file could not be opened, or an existing *
 *          file was open.                                        *
\*----------------------------------------------------------------*/
static FILE * opnfil( int n )
{

   if( n >= ACVS_MAX_OPEN) 
      return(NULL);
   else if(Filefp[n] != NULL)
      return(NULL);

   if((tmpnam(FileName[n])) != FileName[n])
                return(NULL);

   if((Filefp[n] = fopen(FileName[n], WRITEPLUS)) == NULL)
      (void)fprintf(logfp,"%s: Could not open %s\n", prgnam, FileName[n]);
       
   return(Filefp[n]); 
}

/*----------------------------------------------------------------*\
 * FUNCTION: clsrmfil()                                           *
 * ARGUMENTS:   n - An integer holding the index to the desired   *
 *                  file name and file pointer to close and       *
 *                  and remove.                                   *
 *                  n must be less than ACVS_MAX_OPEN.            *
 * DESCRIPTION: A support function that is used to close and      *
 *              remove a file.                                    *
 * RETURNS:  0 - Success                                          *
 *           nonzero - Failure                                    *
\*----------------------------------------------------------------*/
static int clsrmfil( int n )
{
   static int ReturnVal = 1;

   if ( n < ACVS_MAX_OPEN ) {
      if(Filefp[n] != NULL) {
         if((ReturnVal = fclose(Filefp[n])) == 0) {
            Filefp[n] = NULL;
            ReturnVal = remove(FileName[n]); 
         }
      }
   }

   return(ReturnVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ssbuf2.c ===
/* @(#)File: ssbuf2.C       Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SSBUF(3C++)      >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Testing the strstreambuf(int) constructor         >

>HOW:   < strstreambuf(int) constructs an empty buffer in dynamic mode. >
    < the initial allocation of space will be at least n bytes. >
    
    < 0. Check the get area is empty using in_avail()       >
    < 1. Check the put area is empty using out_waiting()        >
    < 2. Put and get a string to check the buffer is functional >
    <    Put a string larger than the initial allocation space so   >
    <    as to check that the automatic dynamic allocation works.   >
    
>MODS:  < Version 1.0 created by HK.                    >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ssbuf2()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif 

// global variable declarations

static strstreambuf sb(3);
/*--------------------------------------------------------------------*/
void ssbuf2_main()                                  /***** BEGINNING OF MAIN. *****/
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SSBUF(3C++)");
    print("Check that a buffer created by constructor strstreambuf(int)");
    print("has an empty get area.");

    if (sb.in_avail() != 0)
        fail("get area is not empty");

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SSBUF(3C++)");
    print("Check that a buffer created by constructor strstreambuf(int)");
    print("has an empty put area.");

#if defined(USING_OLD_IOS)

    if (sb.out_waiting() != 0)
        fail("put area is not empty");
#endif 
    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SSBUF(3C++)");
    print("Check that a buffer created by constructor strstreambuf(int)");
    print("is functional.");

    static char in[5] = "test";

    if (sb.sputn(in, 4) != 4)
        fail ("unexpected put error");

    static char out[5] = "";

    if ((sb.sgetn(out, 4) != 4) || (strncmp(out, in, 4)))
        fail ("unexpected get error");

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();      
}                                       /******** END OF MAIN. ********/



#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\sbuf4.c ===
/* @(#)File: sbuf4.C        Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)      >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Testing the streambuf() constructor               >

>HOW:   < streambuf() constructs an empty buffer corresponding to an    >
    < empty sequence.                       >
    
    < 0. Check the get area is empty using in_avail()       >
    < 1. Check the put area is empty using out_waiting()        >
    < 2. Get and put a string to check the buffer is functional >
    
>MODS:  < Version 1.0 created by HK.                    >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "sbuf4()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <sstream>
#endif
// global variable declarations

#if defined(USING_OLD_IOS)
static streambuf sb;
#else
static stringbuf sb;
#endif 
/*--------------------------------------------------------------------*/
void sbuf4_main()                                 /***** BEGINNING OF MAIN. *****/
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("Check that a buffer created by constructor streambuf()");
    print("has an empty get area.");

    if (sb.in_avail() != 0)
        fail("get area is not empty");

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();                      
#if defined(USING_OLD_IOS)

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("Check that a buffer created by constructor streambuf()");
    print("has an empty put area.");

    if (sb.out_waiting() != 0)
        fail("put area is not empty");
#endif 
    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SBUF.PROT(3C++)");
    print("Check that a buffer created by constructor streambuf()");
    print("is functional.");

    /*
    if (sb.sputc('!') == EOF)
        fail ("unexpected put error");
    if (sb.sgetc() != '!')
        fail ("unexpected get error");
    */

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();      
}                                       /******** END OF MAIN. ********/



#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ssbuf3.c ===
/* @(#)File: ssbuf3.C       Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SSBUF(3C++)      >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Testing the strstreambuf(void* (*a)(long), void (*f)(void*))  >
    < constructor.                          >

>HOW:   < strstreambuf (void* (*a)(long), void (*f)(void*)) constructs  >
    < an empty buffer in dynamic mode.  a is used as the allocator  >
    < function in dynamic mode.  f is used to free areas areas  >
    < returned by a.  If a is null, operator new is used.  If f is  >
    < null the operator delete is used.             >

    < Define an allocation function and free function which modify  >
    < the value of a global flag.  Use the constructor to create    >
    < a buffer that uses this functions for memory management.  >

    < 0. Check the get area is empty using in_avail()       >
    < 1. Check the put area is empty using out_waiting()        >
    < 2. Put and get a string to check the buffer is functional >

>MODS:  < Version 1.0 created by HK.                    >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ssbuf3()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif 
// global variable declarations

int INDICATOR = - 1;

#if defined(USING_OLD_IOS)

void * make_space(long i)
{   
    INDICATOR += 3;
    return (new char[i]);
}

#else

void * make_space(size_t i)
{   
    INDICATOR += 3;
    return (new char[i]);
}

#endif 

void free_space(void * ptr)
{   
    INDICATOR -= 2;
    delete ptr;
}

static strstreambuf sb(make_space, free_space);

/*--------------------------------------------------------------------*/
void ssbuf3_main()                                  /***** BEGINNING OF MAIN. *****/
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SSBUF(3C++)");
    print("Check that a buffer created by constructor strstreambuf(a,f)");
    print("where a is an allocation function, and f is a free function,");
    print("has an empty get area.");

    if (sb.in_avail() != 0)
        fail("get area is not empty");

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SSBUF(3C++)");
    print("Check that a buffer created by constructor strstreambuf(a,f)");
    print("where a is an allocation function, and f is a free function,");
    print("has an empty put area.");

#if defined(USING_OLD_IOS)
    if (sb.out_waiting() != 0)
        fail("put area is not empty");
#endif 
    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();                      

    print("REF: AT&T C++ Library Manual, Appendix A, SSBUF(3C++)");
    print("Check that a buffer created by constructor strstreambuf(a,f)");
    print("where a is an allocation function, and f is a free function,");
    print("is functional.");

    static char in[5] = "test";

    if (sb.sputn(in, 4) != 4)
        fail ("unexpected put error");

    static char out[5] = "";

    if ((sb.sgetn(out, 4) != 4) || (strncmp(out, in, 4)))
        fail ("unexpected get error");

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();      
}                                       /******** END OF MAIN. ********/



#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ssbuf6.c ===
/* @(#)File: ssbuf6.C       Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SSBUF(3C++)      >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < The member function str() of class strstreambuf       >

    < This function returns a pointer to the first char of the  >
    < current buffer.                       >

>HOW:   < Create a strstreambuf in static mode.  The buffer is a char   >
    < array passed to the constructor at the time of creation.  >

    < 0. Call str() and check it returns a pointer to the buffer.   >

>MODS:  < Version 1.0 by HK.                        >

>BUGS:  < None known.                           >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ssbuf6()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <strstrea.h>
#else
#include <iostream>
#include <strstream>
#endif
#define NULL 0

// global variable declarations

static char buf[15] = "Hi there!";
static strstreambuf ssb(buf, 8, NULL);

/*--------------------------------------------------------------------*/
void ssbuf6_main()                                 /***** BEGINNING OF MAIN. *****/
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("Check that str() returns a pointer to the first character of");
    print("the array the strstreambuf currently uses.");

    if (ssb.str() != buf)
        fail ("unexpected return value");

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\stdiobuf.c ===
/* @(#)File: stdiobuf.C    Version: 1.0    Date: 01/05/91             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular stdiostream and
    < stdiobuf classes, STDIOBUF(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the seek/tell operations of the stdiostream class.
    < 
    < These tests use the seekg positioning member to adjust
    < the get pointer of the streambuf. 
    <
    < 0. Positioning at the beginning of the buffer after reading
    <    a few bytes.
    < 
    < 1. Positioning at the end of the buffer before any reads.
    <
    < 2. Positioning at the end of the buffer after reading a few 
    <    characters.
    <
    < 3. Positioning at an offset from the beginning.
    <

>HOW:   < The program uses a stdiobuf as its stream buffer. It creates
    < and opens a Unix file and operates on the file. Then removes it.
    <
    < 0. Put something into the buffer. Read a few bytes remembering
    <    the first one read. Seek to the beginning, reread and check
    <    the first byte.
    <
    < 1. Jump to the end of the buffer and try to read. Should return
    <    EOF. 
    < 
    < 2. Same as 2 but read a few characters first.
    < 
    < 3. Read three characters and save the third. Then read several
    <    more. Then reposition to 2 off the beginning and try to read
    <    the saved character.

>MODS:  < 07/02/90, DRE: Change definition of failure() to a prototype.
    <    Include "testhead.h" rather than "testhead.h"
    < Vers 1.0, date: 3/4/90 Created: DRE

>BUGS:  < This test is dependent on the ANSI C stdio libraries
    < because it uses the tmpfile() library call.
    <
    < Block 3, the seek to a saved position, is failed by the 2.0
    < stream library, and some cfront 2.1.
    <
    
======================================================================*/
#define USING_OLD_IOS
#pragma warning(disable:4995)
#if defined(USING_OLD_IOS)
#include <iostream.h>
#include <stdiostr.h>
#include <fstream.h>
#else
#include <iostream>
#include <fstream>
#endif

#include <stdio.h>
#include "testhead.h"


static char progname[] = "stdiobuf()";

const int COUNT = 3;

static const char * file_data[COUNT] = {
    "abc 987",
    "line 2",
    "zyxw"
};

/* Put known contents in the data file, then seek back to beginning */
void writefile(FILE * tmpf);

static char * ptr;
static char c;

/*--------------------------------------------------------------------*/
void stdiobuf_main()                  
{
    setup();
#if defined(USING_OLD_IOS)

/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("STDIOBUF(3C++) Manual Page: seekg().\n");
    DbgPrint("Seeking to the start of the buffer after extracting.\n");

    {
        FILE * fp = tmpfile();
        if (fp == NULL)
            failure("Could not open temp file.");
        else
        {
        // Put known contents in file
            writefile(fp);
            stdiobuf sb(fp);
            istream is(&sb);
            char remembered_char;
            if (!is.good())
                failure("Couldn't open data buffer.");
            else
            {
                is >> remembered_char;
                if (remembered_char != file_data[0][0])
                    failure("Didn't extract correct character.");
                else
                {
            // Extract a few extra characters
                    is >> c;
                    is >> c;
                    is >> c;
                    if (!is)
                        failure("Errors during extraction.");
                    else
                    {
                        is.seekg(0,ios::beg);
                        if (is.get() != remembered_char)
                            failure("After seek got wrong character.");
                    }
                }
            }
            fclose(fp);
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("STDIOBUF(3C++) Manual Page: seekg().\n");
    DbgPrint("Seek to the end of the buffer and try to read.\n");

    {
        FILE * fp = tmpfile();
        if (fp == NULL)
            failure("Could not open temp file.");
        else
        {
        // Put known contents in file
            writefile(fp);
            stdiobuf sb(fp);
            istream is(&sb);
            if (!is.good())
                failure("Couldn't open data buffer.");
            else
            {
                is.seekg(0,ios::end);
                if ((c = is.get()) != EOF)
                {
                    failure("After seeking to end didn't read EOF.");
                    DbgPrint( "Got character %d(%c).\n", c, c);
                }
            }
            fclose(fp);
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("STDIOBUF(3C++) Manual Page: seekg().\n");
    DbgPrint("Read a few, then seek to the end of the buffer\n");
    DbgPrint("and try to read.\n");

    {
        FILE * fp = tmpfile();
        if (fp == NULL)
            failure("Can not open temp file.");
        else
        {
            stdiobuf sb(fp);
            istream is(&sb);
            if (!is.good())
                failure("Couldn't open data buffer.");
            else
            {
                is >> c;
                is >> c;
                is.seekg(0,ios::end);
                if ((c = is.get()) != EOF)
                {
                    failure("After seeking to end didn't read EOF.");
                    DbgPrint( "Got character %d(%c).\n", c, c);
                }
            }
            fclose(fp);
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("STDIOBUF(3C++) Manual Page: seekg().\n");
    DbgPrint("Jump to an offset from the beginning.\n");

    {
        FILE * fp = tmpfile();
        if (fp == NULL)
            failure("Can not open temp file.");
        else
        {
            writefile(fp);
            stdiobuf sb(fp);
            istream is(&sb);
            if (!is.good())
                failure("Couldn't open data buffer.");
            else
            {
                char savechar;
                is >> c;
                is >> c;
                is >> savechar;
                if (savechar != file_data[0][2])
                {
                    failure("Got wrong data.");
                    DbgPrint( "Wanted %c(%d), got %c(%d)\n",
                            savechar,savechar, 
                            file_data[0][2], file_data[0][2]);
                }
                else
                {
                    is >> c;
                    is >> c;
                    is >> c;
                    is.seekg(2,ios::beg);
                    is >> c;
                    if (c != savechar)
                        failure("After seek to beginning+2 read wrong char.");
                }
            }
            fclose(fp);
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
#endif
    anyfail();  
}                   


/**********************************************************************/
/*                                                                    */
/* writefile                                                          */
/*                                                                    */
/* This routine writes the known data into the data file.             */
/* It seeks back to the beginning of the file after writing.          */
/*                                                                    */
/* Return:                                                            */
/*                                                                    */
/*    1   success                                                     */
/*    0   failure for some reason                                     */
/*                                                                    */
/**********************************************************************/

void writefile(FILE * tmpf)
{
    rewind(tmpf);
    const char ** pp = file_data;
    while (pp < file_data + COUNT)
        fprintf(tmpf, "%s\n", *pp++);
    fflush(tmpf);
    rewind(tmpf);
}

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ssbuf4.c ===
/* @(#)File: ssbuf4.C       Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SSBUF(3C++)      >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Constructor strstreambuf(char *ptr, int n, char * pstart) >
    < This constructor has various modes of behavior depending  >
    < on the sign of n, and the values of ptr and pstart.       >

>HOW:   < For each mode of the constructor, create an object and verify >
    < the object has the expected get and put areas.        >

    < In all cases, the get area starts at ptr.  Its length depends >
    < on n and pstart.  To test the content and length of the get   >
    < area, we call sgetn() to request a larger number of char's    >
    < than we know are available.  sgetn() returns the number of    >
    < char's actually fetched and stores this characters in an  >
    < array.                            >

    < The put area is tested using out_waiting() and sputc().   >

    < In the following cases, pstart is always NULL.  Consequently  >
    < the initial get area is the entire array.  Test the effect    >
    < of n.                             >

    < 0. if n is positive, the get area consists of the n bytes     >
    < following ptr.                        >

    < 1. If n is zero, the get area terminates at the end of the    >
    < string that starts at ptr.                    >

    < 2. If n is negative, the get area is assumed to continue  >
    < indefinitely.  We verify it extends beyond the end-of-string. >

    < 3. If pstart is null, all stores are treated as errors.   >

    < In the following cases, pstart is non-NULL.  Consequently >
    < the initial get area is the area between ptr and pstart.  >
    < Check the effect of n.                    >

    < 4. Make n positive and larger than pstart-ptr.  Check that    >
    < only the char's up to pstart can be fetched.          >

    < 5. Make n positive and smaller than pstart-ptr.  Check that   >
    < only the char's up to ptr+n can be fetched.           >

>MODS:  < Version 1.0 by HK.                        >

>BUGS:  < AT&T library BUG:                         >
    <   In block 4, the get area extends beyond pstart instead  >
    <   of only up to pstart as specified by the manual in  >
    <   section SSBUF(3C++), page 2.                >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ssbuf4()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#define NULL 0

// global variable declarations

static char msg[] = "Hi there!";
static size_t msglen = strlen(msg); //LX:10131999 /int/size_t for 64-bit friendliness 
static char buf[15],
tmp[15];

/*--------------------------------------------------------------------*/
void ssbuf4_main()                                 /***** BEGINNING OF MAIN. *****/
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf (char* ptr, int n, char* pstart) constructor:");
    print("if n is positive, the get area consists of the n bytes");
    print("following ptr.");

    strcpy(buf, msg);
    {strstreambuf ssb(buf, (streamsize) msglen -5 , NULL); /* LX:10131999 */
        if ((size_t)ssb.sgetn(tmp, (streamsize) msglen) != msglen -5) /* LX:10131999 */
            fail ("unexpected get area size");
        else if (strncmp(msg, tmp, msglen -5))
            fail ("unexpected get area content");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf (char* ptr, int n, char* pstart) constructor:");
    print("If n is zero, the get area terminates at the end of the");
    print("string that starts at ptr.");

    strcpy(buf, msg);
    {strstreambuf ssb(buf, 0 , NULL);
        if ((size_t) ssb.sgetn(tmp, (streamsize) msglen+5) != msglen) /*LX:10131999 */
            fail ("unexpected get area size");
        else if (strcmp(msg, tmp))
            fail ("unexpected get area content");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf (char* ptr, int n, char* pstart) constructor:");
    print("If n is negative, the get area is assumed to continue");
    print("indefinitely.  We verify it extends beyond the end-of-string.");

    strcpy(buf, msg);
    strcpy(buf+10,"test");
    {strstreambuf ssb(buf, -1 , NULL);
        if (ssb.sgetn(tmp, 15) != 15)
            fail ("unexpected get area size");
        else if (strcmp(tmp+10, "test"))
            fail ("unexpected get area content");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf (char* ptr, int n, char* pstart) constructor:");
    print("If pstart is null, all stores are treated as errors.");

    strcpy(buf, msg);
    {strstreambuf ssb(buf, (streamsize) msglen , NULL); /*LX:10131999 */
        if (ssb.sputc('$') != EOF)
            fail ("unexpected success of sputc()");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();                      
// the ctor behaves differently with the final draft standard.
    //
#if defined(USING_OLD_IOS)  

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf (char* ptr, int n, char* pstart) constructor:");
    print("Make n positive and larger than pstart-ptr.  Check that");
    print("only the char's up to pstart can be fetched.");

    strcpy(buf, msg);
    {strstreambuf ssb(buf, msglen, buf+5);
        int i = ssb.sgetn(tmp, msglen);
        if (i != 5)
        {fail ("unexpected get area size");
            DbgPrint( "\tfetched %d char's instead of 5\n", i);
        }
        else if (strncmp(msg, tmp, 5))
            fail ("unexpected get area content");
    }
#endif 
    blexit();
/*--------------------------------------------------------------------*/
    block5: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf (char* ptr, int n, char* pstart) constructor:");
    print("Make n positive and smaller than pstart-ptr.  Check that");
    print("only the char's up to ptr+n can be fetched.");

    strcpy(buf, msg);
    {strstreambuf ssb(buf, 5, buf+msglen);
        if (ssb.sgetn(tmp, (streamsize) msglen) != 5) /*LX:10131999*/
            fail ("unexpected get area size");
        else if (strncmp(msg, tmp, 5))
            fail ("unexpected get area content");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\stream.c ===
/* @(#)File: stream.C    Version: 1.0    Date: 09/27/90               */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream and ostream
    < classes. IOS.INTRO(3C++) manual page dated 14 June 1989

>WHAT:  < Testing the types of the standard streams, cin, cout
    < cerr and clog are of ?stream_withassign types.
    < 
    < 0. cin is an istream_withassign
    <
    < 1. cout is an ostream_withassign
    <
    < 2. cerr is an ostream_withassign
    <
    < 3. clog is an ostream_withassign

>HOW:   < 0-3. Assign the standard streams to other variables
    <      of the same type.

>MODS:  < 07/02/90, DRE: Changed definition of failure() to a prototype.
    <    Included "testhead.h" instead of "testhead.h"
    < Vers 1.0, date: 3/6/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    <
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#endif

#include "testhead.h"


static char progname[] = "stream()";   

/*--------------------------------------------------------------------*/
void stream_main()                  
{
    setup();
#if defined(USING_OLD_IOS)

/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS.INTRO(3C++) manual page dated 14 June 1989.\n");
    DbgPrint("cin is of type istream_withassign.\n");

    {
        // This is a compile test only
        istream_withassign i;
        i = cin;
        // If it compiles it passes
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS.INTRO(3C++) manual page dated 14 June 1989.\n");
    DbgPrint("cout is of type ostream_withassign.\n");

    {
        // This is a compile test only
        ostream_withassign o;
        o = cout;
        // If it compiles it passes
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS.INTRO(3C++) manual page dated 14 June 1989.\n");
    DbgPrint("cerr is of type ostream_withassign.\n");

    {
        // This is a compile test only
        ostream_withassign o2;
        o2 = cerr;
        // If it compiles it passes
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS.INTRO(3C++) manual page dated 14 June 1989.\n");
    DbgPrint("clog is of type ostream_withassign.\n");

    {
        // This is a compile test only
        ostream_withassign o3;
        o3 = clog;
        // If it compiles it passes
    }

    blexit();
/*--------------------------------------------------------------------*/
#endif
    anyfail();  
}                   

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\strm_wa.c ===
/* @(#)File: strm_wa.C    Version: 1.0    Date: 09/27/90              */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular istream class.

>WHAT:  < Testing the *stream_withassign class.
    <
    < 0. Assign one istream to another and check that it works.
    <
    < 0. Assign one ostream to another and check that it works.
    <
    < 0. Assign one iostream to another and check that it works.
    <

>HOW:   < The program uses a strstreambuf as its stream buffer.
    <
    < 0. Write a string with leading whitespace to a buffer.
    <    Create an istream on the strbuf. Create another istream.
    <    Perform an assignment, extract and check the data.
    <
    < 1. Construct an ostream_withassign on a strstreambuf.
    <    Assign the ostream to another. Through the second ostream
    <    write into the buffer. Then check that the data can
    <    be read.
    <
    < 2. Combine blocks 0 and 1, do both the reading and writing
    <    through the iostream.

>MODS:  < 07/02/90, DRE: Changed definition of failure() to a prototype.
    <    Included "testhead.h" instead of "testhead.h"
    < Vers 1.0, date: 3/6/90 Created: DRE

>BUGS:  < No bugs or system dependencies known.
    
======================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif

#include "testhead.h"


static char progname[] = "strm_wa()";

/*--------------------------------------------------------------------*/
void strm_wa_main()                  
{
    setup();
#if defined(USING_OLD_IOS)

/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("ISTREAM(3C++) Manual Page: istream_withassign.\n");

    {
        char * ptr = "abc";
        char buf[128];
        strstreambuf sb;
        sb.sputn(ptr,strlen(ptr));
        istream is(&sb);
        istream_withassign is2;
        is2 = is;
        if (!is2)
            failure("Assignment failed.");
        else
        {
            is2.width(128);
            is2 >> buf;
            if (strcmp(buf,ptr))
                failure("Got wrong string.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("OSTREAM(3C++) Manual Page: ostream_withassign.\n");

    {
        char * ptr = "def";
        char buf[128];
        strstreambuf sb;
        ostream os(&sb);
        ostream_withassign os2;
        os2 = os;
        if (!(os2 << ptr << '\0'))
            failure("Could not insert into assigned ostream.");
        else if (sb.sgetn(buf,strlen(ptr)+1) != strlen(ptr)+1)
            failure("Could not read string out of buffer");
        else if (strcmp(ptr,buf))
            failure("Read wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS.INTRO(3C++) Manual Page: iostream_withassign.\n");
    DbgPrint("Read test.\n");

    {
        char * ptr = "ghi";
        char buf[128];
        strstreambuf sb;
        sb.sputn(ptr,strlen(ptr));
        iostream ios(&sb);
        iostream_withassign ios2;
        ios2 = ios;
        if (!ios2)
            failure("Assignment failed.");
        else
        {
            ios2.width(128);
            ios2 >> buf;
            if (strcmp(buf,ptr))
                failure("Got wrong string.");
        }
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS.INTRO(3C++) Manual Page: iostream_withassign.\n");
    DbgPrint("Write test.\n");

    {
        char * ptr = "jkl";
        char buf[128];
        strstreambuf sb;
        iostream ios(&sb);
        iostream_withassign ios2;
        ios2 = ios;
        if (!(ios2 << ptr << '\0'))
            failure("Could not insert into assigned ostream.");
        else if (sb.sgetn(buf,strlen(ptr)+1) != strlen(ptr)+1)
            failure("Could not read string out of buffer");
        else if (strcmp(ptr,buf))
            failure("Read wrong string.");
    }

    blexit();
/*--------------------------------------------------------------------*/
#endif 
    anyfail();  
}                   


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\ssbuf5.c ===
/* @(#)File: ssbuf5.C       Version: 1.0        Date:09/27/90   */
/* CVS-CC, C++ Validation Suite                     */
/* Copyright 1989, Perennial, All Rights Reserved           */
/*========================================================================
        =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Manual, Appendix A, SSBUF(3C++)      >
    < in AT&T C++ Language System 2.0, May 89.  Select Code 307-145 >

>WHAT:  < Constructor strstreambuf(unsigned char *ptr, int n, unsigned  >
    < char * pstart)                        >

    < This constructor has various modes of behavior depending  >
    < on the sign of n, and the values of ptr and pstart.       >
    < This file is identical to ssbuf4.C except for the fact that   >
    < the constructor uses buffers of type unsigned char instead    >
    < of char.                          >

>HOW:   < For each mode of the constructor, create an object and verify >
    < the object has the expected get and put areas.        >

    < In all cases, the get area starts at ptr.  Its length depends >
    < on n and pstart.  To test the content and length of the get   >
    < area, we call sgetn() to request a larger number of char's    >
    < than we know are available.  sgetn() returns the number of    >
    < char's actually fetched and stores this characters in an  >
    < array.                            >

    < The put area is tested using out_waiting() and sputc().   >

    < In the following cases, pstart is always NULL.  Consequently  >
    < the initial get area is the entire array.  Test the effect    >
    < of n.                             >

    < 0. if n is positive, the get area consists of the n bytes     >
    < following ptr.                        >

    < 1. If n is zero, the get area terminates at the end of the    >
    < string that starts at ptr.                    >

    < 2. If n is negative, the get area is assumed to continue  >
    < indefinitely.  We verify it extends beyond the end-of-string. >

    < 3. If pstart is null, all stores are treated as errors.   >

    < In the following cases, pstart is non-NULL.  Consequently >
    < the initial get area is the area between ptr and pstart.  >
    < Check the effect of n.                    >

    < 4. Make n positive and larger than pstart-ptr.  Check that    >
    < only the char's up to pstart can be fetched.          >

    < 5. Make n positive and smaller than pstart-ptr.  Check that   >
    < only the char's up to ptr+n can be fetched.           >

>MODS:  < Version 1.0 by HK.                        >

>BUGS:  < AT&T library BUG:                         >
    <   In block 4, the get area extends beyond pstart instead  >
    <   of only up to pstart as specified by the manual in  >
    <   section SSBUF(3C++), page 2.                >
========================================================================*/
#include "testhead.h"     

static char progname[] = "ssbuf5()";         

inline void print(char str[]) { DbgPrint( "%s\n", str);}
static void fail (char str[]) {
    local_flag =FAILED;
    DbgPrint( "\tFAILURE: %s\n", str);
}

/*--------------------------------------------------------------------*/
#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#include <strstream>
#endif
#define NULL 0

// global variable declarations

static char msg[] = "Hi there!";
static size_t msglen = strlen(msg); /*LX:10131999*/
static char buf[15],
tmp[15];
unsigned char * BUF = (unsigned char *) buf;

/*--------------------------------------------------------------------*/
void ssbuf5_main()                                 /***** BEGINNING OF MAIN. *****/
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf(unsigned char* ptr,int n, unsigned char* pstart):");
    print("if n is positive, the get area consists of the n bytes");
    print("following ptr.");

    strcpy(buf, msg);
    {strstreambuf ssb(BUF, (streamsize) msglen -5 , NULL); /*LX:10131999 */
        if ((size_t)ssb.sgetn(tmp, (streamsize)  msglen) != msglen -5) /*LX:10131999*/
            fail ("unexpected get area size");
        else if (strncmp(msg, tmp, msglen -5))
            fail ("unexpected get area content");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf(unsigned char* ptr,int n, unsigned char* pstart):");
    print("If n is zero, the get area terminates at the end of the");
    print("string that starts at ptr.");

    strcpy(buf, msg);
    {strstreambuf ssb(BUF, 0 , NULL);
        if ((size_t)ssb.sgetn(tmp, (streamsize)  msglen+5) != msglen) /*LX:10131999*/
            fail ("unexpected get area size");
        else if (strcmp(msg, tmp))
            fail ("unexpected get area content");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block2: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf(unsigned char* ptr,int n, unsigned char* pstart):");
    print("If n is negative, the get area is assumed to continue");
    print("indefinitely.  We verify it extends beyond the end-of-string.");

    strcpy(buf, msg);
    strcpy(buf+10,"test");
    {strstreambuf ssb(BUF, -1 , NULL);
        if (ssb.sgetn(tmp, 15) != 15)
            fail ("unexpected get area size");
        else if (strcmp(tmp+10, "test"))
            fail ("unexpected get area content");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block3: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf(unsigned char* ptr,int n, unsigned char* pstart):");
    print("If pstart is null, all stores are treated as errors.");

    strcpy(buf, msg);
    {strstreambuf ssb(BUF, (streamsize) msglen , NULL); /*LX:10131999 */
        if (ssb.sputc('$') != EOF)
            fail ("unexpected success of sputc()");
    }

    blexit();
/*--------------------------------------------------------------------*/
    block4: blenter();                      
#if defined(USING_OLD_IOS)

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf(unsigned char* ptr,int n, unsigned char* pstart):");
    print("Make n positive and larger than pstart-ptr.  Check that");
    print("only the char's up to pstart can be fetched.");

    strcpy(buf, msg);
    {strstreambuf ssb(BUF, (streamsize) msglen, BUF+5); /*LX:10131999 */
        size_t i = ssb.sgetn(tmp, (streamsize) msglen); /*LX:10131999 */
        if (i != 5)
        {fail ("unexpected get area size");
            DbgPrint( "\tfetched %d char's instead of 5\n", i);
        }
        else if (strncmp(msg, tmp, 5))
            fail ("unexpected get area content");
    }
#endif 
    blexit();
/*--------------------------------------------------------------------*/
    block5: blenter();                      

    print("AT&T Library Manual, Appendix A, SSBUF(3C++)");
    print("strstreambuf(unsigned char* ptr,int n, unsigned char* pstart):");
    print("Make n positive and smaller than pstart-ptr.  Check that");
    print("only the char's up to ptr+n can be fetched.");

    strcpy(buf, msg);
    {strstreambuf ssb(BUF, 5, BUF+(streamsize) msglen); /*LX:10131999 */
        if (ssb.sgetn(tmp, (streamsize) msglen) != 5)
            fail ("unexpected get area size");
        else if (strncmp(msg, tmp, 5))
            fail ("unexpected get area content");
    }

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();      
}                                       /******** END OF MAIN. ********/


#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\syncstd1.c ===
/* @(#)File: syncstd1.C    Version: 1.0    Date: 10/19/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ios class,
    < IOS(3C++) page dated June 14, 1989.

>WHAT:  < Testing the sync_with_stdio member for mixing stream and stdio I/O.
    < 
    < 0. Input from stdin and cin can be mixed.
    <
    < 1. Output through stdout and cout can be mixed.
    <

>HOW:   < 0. Give a temp file known contents. Read the file in
    <    pieces and verify that the data come in correctly.
    <
    < 1. Write to a temp file through both packages. Read back the
    <    contents and check that they are corret.

>MODS:  < 07/02/90, DRE: Changed definition of failure() to a prototype.
    <    Included "testhead.h" instead of "testhead.h"
    < Vers 1.0, date: 5/04/90: Created: dre

>BUGS:  < ``cin >> (char*)'' reads characters until it hits a whitespace
    < and leaves the whitespace in the istream. Such an extraction
    < (under cfront 2.0 and its libraries)
    < following by a stdio fgets loses the whitespace. The whitespace
    < must be read with a stream character input such as  cin >> c.
    < This is tested in another file to see if it is symptomatic of 
    < a general problem involving putting back characters when streams
    < are synchronized with stdio.
*/
/*====================================================================*/
/*                              syncstd1.C                            */
/*====================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#endif
#include <stdio.h>
#include "remove.h"

#include "testhead.h"


static char progname[] = "syncstd1()";

static char namebuf[L_tmpnam];
static const char * fname = tmpnam(namebuf);

const int maxlen = 128;
const int maxstrings = 8;

static const char Rbuf[] = "abc\ndef\n12345\ncab\nqwerty \t\towef\n e 230f hello\n";
static const char * Rdata = Rbuf;
static char Wbuf[maxlen];
static char * Wdata = Wbuf;

static FILE * fpw;
static FILE * fpr;

/*--------------------------------------------------------------------*/
void syncstd1_main()                  
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS(3C++) Manual Page, class ios.\n");
    DbgPrint("Testing sync_with_stdio member, mixed input.\n");

    ios::sync_with_stdio();

    // Put known contents in file.
    fpw = fopen(fname, "w");
    fputs(Rbuf, fpw);
    fclose(fpw);

    // Read back the data with mixed library calls
    freopen(fname, "r", stdin);
    rewind(stdin);
    char * writep = Wbuf;
    cin.flags(cin.flags() & ~ios::skipws);
    while (1)
    {
        // Do some mixed character I/O.
        int c;
        if ((c = getchar()) == EOF)
            break;
        *writep++ = c;
        if (!(cin >> *writep++))
            break;
        // Do some string I/O
        if (!(cin >> writep))
            break;
        writep += strlen(writep); // advance beyond what we just read
        if (*writep)
            DbgPrint( "Bad synchronization.\n");
        // Need to get the whitespace character
        // *** This should not be necessary but it is.
        if (!(cin >> *writep++))
            break;
        if (fgets(writep, maxlen, stdin) == NULL)
            break;
        writep += strlen(writep); // advance beyond what we just read
        if (*writep)
            DbgPrint( "Bad synchronization.\n");
        // And some more character I/O
        if ((c = getchar()) == EOF)
            break;
        *writep++ = c;
        if (!(cin >> *writep++))
            break;
    }
    if (strcmp(Rbuf,Wbuf))
    {
        failure("Data compares wrong.");
        DbgPrint( "String R(%d) '%s'\n\n", strlen(Rbuf),Rbuf);
        DbgPrint( "String W(%d) '%s'\n\n", strlen(Wbuf),Wbuf);
    }

    fclose(stdin);
    remove(fname);

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS(3C++) Manual Page, class ios.\n");
    DbgPrint("Testing sync_with_stdio member, mixed output.\n");

    // Do mixed writes to file, then read it back and check it.
    freopen(fname, "w", stdout);
    ios::sync_with_stdio();
    const char * readp = Rbuf;
    size_t i; /*LX:10131999*/
    while (1)
    {
        // Do some mixed character I/O.
        if (!*readp) break;
        putchar(*readp++);
        if (!*readp) break;
        cout << *readp++;

        // Do some multicharacter I/P
        i = strlen(readp);
        if (i>3)
            i=3;
        if (i)
            cout.write(readp,(streamsize) i); /*LX:1013199*/
        else
            break;
        readp += i;

        i = strlen(readp);
        if (i>3)
            i=3;
        if (i)
            fwrite(readp, sizeof(*readp),i,stdout);
        else
            break;
        readp += i;
    }

    // Read the data back
    fpr = fopen(fname, "r");
    fread(Wbuf,sizeof(*Wbuf),sizeof(Wbuf),fpr);
    fclose(fpr);

    if (strcmp(Rbuf,Wbuf))
    {
        failure("Data compares wrong.");
        DbgPrint( "String R(%d) '%s'\n\n", strlen(Rbuf),Rbuf);
        DbgPrint( "String W(%d) '%s'\n\n", strlen(Wbuf),Wbuf);
    }

    fclose(stdout);
    remove(fname);

    blexit();
/*--------------------------------------------------------------------*/
    anyfail();  
}                   

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\syncstd2.c ===
/* @(#)File: syncstd2.C    Version: 1.0    Date: 10/19/90             */
/* CVS-CC, C++ Validation Suite                                       */
/* Copyright 1989, Perennial, All Rights Reserved                     */
/*======================================================================
    =================== TESTPLAN SEGMENT ===================
>KEYS:  < AT&T C++ Library Reference, Feb 90, Appendix A-4, Stream
    < I/O Library Manual pages, In particular ios class,
    < IOS(3C++) page dated June 14, 1989.

>WHAT:  < Testing the sync_with_stdio member for mixing stream and stdio I/O.
    < Testing ungetting characters.
    < 
    < 0. Unget a character through stdio and see if stream I/O
    <    reads it.
    <
    < 1. Unget a character through stream I/O and see if stdio 
    <    reads it.
    <

>HOW:   < 0-1. Do the manipulations in a temporary disk file.
    <

>MODS:  < 07/02/90, DRE: Changed definition of failure() to a prototype.
    <    Included "testhead.h" instead of "testhead.h"
    < Vers 1.0, date: 5/12/90: Created: dre

>BUGS:  < Under cfront 2.0 and its stream libraries, when we putback
    < a character, the stdio library fails to read the character.
    < This appears to be a library bug.
    <
*/
/*====================================================================*/
/*                              syncstd2.C                            */
/*====================================================================*/

#if defined(USING_OLD_IOS)
#include <iostream.h>
#else
#include <iostream>
#endif

#include <stdio.h>
#include "remove.h"

#include "testhead.h"


static char progname[] = "syncstd2()";

static char namebuf[L_tmpnam];
static const char * fname = tmpnam(namebuf);

static const char Rbuf[] = "abc";
static const char * Rdata = Rbuf;

static FILE * fpw;

/*--------------------------------------------------------------------*/
void syncstd2_main()                  
{
    setup();
/*--------------------------------------------------------------------*/
    block0: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS(3C++) Manual Page, class ios.\n");
    DbgPrint("Testing sync_with_stdio member, ungetting.\n");
    DbgPrint("Ungetting through stream I/O.\n");

    ios::sync_with_stdio();

    // Put known contents in file.
    fpw = fopen(fname, "w");
    fputs(Rbuf, fpw);
    fclose(fpw);

    // Read back the data with mixed library calls
    freopen(fname, "r", stdin);
    rewind(stdin);

    char c, cc;

    cin >> c;
    cin.putback(c);
    if ((cc = getchar()) != c)
    {
        failure("Stdio didn't get the char the stream put back.");
        DbgPrint( "c='%c', cc='%c'\n",c,cc);
    }

    fclose(stdin);

    blexit();
/*--------------------------------------------------------------------*/
    block1: blenter();          

    DbgPrint("REF: AT&T Library Reference February 1990\n");
    DbgPrint("Appendix A-4: Testing I/O Streams.\n");
    DbgPrint("IOS(3C++) Manual Page, class ios.\n");
    DbgPrint("Testing sync_with_stdio member, ungetting.\n");
    DbgPrint("Ungetting through stdio.\n");

    // Read back the data with mixed library calls
    freopen(fname, "r", stdin);
    rewind(stdin);

    c = getchar();
    cc = c + 1;
    ungetc(c,stdin);
    cin >> cc;
    if (cc != c)
        failure("Stream I/O didn't get the char that stdio put back.");

    fclose(stdin);

    blexit();
/*--------------------------------------------------------------------*/
    remove(fname);
    anyfail();  
}                   

#include "peren_another.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\testhead.h ===
#ifndef __TESTHEAD_H__
#define __TESTHEAD_H__
/* @(#)File: testhead.h    Version: 1.3.1 C++    Date: 1/20/91 */
/* COPYRIGHT 1984-91, PERENNIAL, All Rights Reserved           */
                        /* testhead.h */
/*===========================================================================
|       This is the include file for all tests developed for the PERENNIAL
| C++ Validation Suite, CVS-CC.  It should be included in any test that 
| uses the support functions in "libd" or "libd.o".
===========================================================================*/

/******************************************************************************
MS changes:
22-Mar-1991 mattheww            comment out overloaded failure() declaration
23-Jul-92   bos                 added changes for Windows testing; see sections
                                  separated by MICROSOFT CHANGES
******************************************************************************/

#include <io.h>
#include <stdio.h>
/************************** MICROSOFT CHANGES ******************************/
/*
** This was moved to be above the section below due to a conflict with the
** macro redefining exit() in wintest.h.
*/

#include <stdlib.h>
/************************** MICROSOFT CHANGES ******************************/
#ifdef _M_IA64
#pragma warning( disable : 4244)
#endif

/************************** MICROSOFT CHANGES ******************************/
#ifndef PEREN_TEST
#ifdef _WINDOWS
#include <wintest.h>
static char test[];
#undef ERROR
#endif
#endif
/************************** MICROSOFT CHANGES ******************************/

#define  PASSED 0
#define  FAILED 1
#define  ERROR -1 
#define  FATAL -2

#define  DFAIL  0
#define  DPASS  1
#define  DTERS  2
#define  DVERB  3
#define  DDEBUG 4
#define PMODE 0644

#include <string.h>
#include <errno.h>
#include <stddef.h>



static int  local_flag;
static FILE *temp;

static void setup();
static void blenter();
static void anyfail();
static int  blexit();

static void failure(char * format);
#if defined(__cplusplus)
static void failure(char * format, int i1, int i2);
#endif
static void fpostcall(float got,float expected,char mesgstr[]);
static void ipostcall(int got,int expected,char mesgstr[]);
static void lpostcall(long got, long expected, char mesgstr[]);
static void spostcall(char got[], char expected[], char mesgstr[]);

#define REL_2_0 0200
#define REL_2_1 0201

#define block0 goto Block0;\
Block0

#define block1 goto Block1;\
Block1

#define block2 goto Block2;\
Block2

#define block3 goto Block3;\
Block3

#define block4 goto Block4;\
Block4

#define block5 goto Block5;\
Block5

#define block6 goto Block6;\
Block6

#define block7 goto Block7;\
Block7

#define block8 goto Block8;\
Block8

#define block9 goto Block9;\
Block9

#define block10 goto Block10;\
Block10

#define block11 goto Block11;\
Block11

#define block12 goto Block12;\
Block12

#define block13 goto Block13;\
Block13

#define block14 goto Block14;\
Block14

#define block15 goto Block15;\
Block15

#define block16 goto Block16;\
Block16

#define block17 goto Block17;\
Block17

#define block18 goto Block18;\
Block18

#define block19 goto Block19;\
Block19

#define block20 goto Block20;\
Block20

#define block21 goto Block21;\
Block21

#define block22 goto Block22;\
Block22

#define block23 goto Block23;\
Block23

#define block24 goto Block24;\
Block24

#ifdef __cplusplus
#if !defined(QA_DISABLE_USING_NAMESPACE)
namespace std {}
using namespace std;
#endif
#endif
#ifdef _XBOX
extern "C" int DbgPrint(const char *, ...);
#endif

#endif // #define __TESTHEAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\tsteh.h ===
/* File: tsteh.h    Version: 2.12    Date: 09/07/92
 * CVS-C++, C++ Validation Suite
 * Section: include
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================
        =================== TESTPLAN SEGMENT ===================

>KEYS:	X3J16/91-0059, May 1991: ANSI C++ Working Paper,
	15 Exception Handling.
        15.6 Special Functions.
        15.6.1 The terminate() Function.
        15.6.2 The unexpected() Function.

>REL:   EH Phase I and later.

>WHAT:  Provide a standard trapping mechanism for wayward
	exceptions.  The inclusion of this file is not
	necessary for normal functioning of the testcases, 
	but may assist debugging.
	
	No assertions here.  
	This is an include file.

>HOW:   Write messages to the report file if exceptions
	are detected herein.
	
	Include this file from most EH testcases,
	and call eh_traps().
	
>NOTE:	None
======================================================================*/

typedef void (*PFV)();
PFV set_terminate(PFV);
PFV set_unexpected(PFV);

static void eh_unexpected()
{
	failure("tsteh.h: eh_unexpected(): Missing exception-specification ?");
	blexit();
	anyfail(block_number+1);
}

static void eh_terminate()
{
	failure("tsteh.h: eh_terminate(): EH termination trap");
	blexit();
	anyfail(block_number+1);
}

static void eh_traps()
{
	(void) set_terminate (&eh_terminate);
	(void) set_unexpected (&eh_unexpected);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\perennial\tsthd.h ===
#ifndef __TSTHD_H__
#define __TSTHD_H__
/* File: tsthd.h    Version: 2.10    Date: 11/16/92
 * CVS-C++, C++ Validation Suite
 * Section: scaffold
 * Copyright 1991-92, PERENNIAL, All Rights Reserved
 */
/*======================================================================

>WHAT:  This is the include file for all tests developed for the PERENNIAL
        C++ Validation Suite, CVS-C++.  It should be #include'd in any 
        test that uses the support functions of scaffold.C.

>NOTE:  None
======================================================================*/
#include <stdio.h>

/************************** MICROSOFT CHANGES ******************************/

#ifdef _M_IA64
#pragma warning( disable : 4244)
#endif

/* Bounds Checking Macro */
/* A = Answer            */
/* B = Upper Bound Limit */
/* C = Lower Bound Limit */
#define INBOUND(A,B,C) ((A) <= (B) && (A) >= (C))

#define  PASSED 0
#define  FAILED 1
#define  ERROR -1 
#define  FATAL -2
#define  SUCCESS 0

#define  DFAIL  0
#define  DPASS  1
#define  DTERS  2
#define  DVERB  3
#define  DDEBUG 4
#define PMODE 0644

#define  ACVS_OPEN_MAX  5
#define  MIN_EXP_LENGTH 2
#define LEN_ERR   1
#define SGN_ERR   2
#define MAN_ERR   3
#define NO_E_ERR  4
#define MAT_E_ERR 5
#define LEN_E_ERR 6
#define EXP_ERR   7
#define LEN_T_ERR 8
#define TXT_ERR   9

static int block_number;
/*
static int blknum;
static int connum;
*/


static FILE *logfp;

static void setup(void);
static void blenter(void);
static void anyfail(void);
static void anyfail(int);
static int  blexit(void);

static void failure(char * format);
static void failure(char * format, int i1);
static void failure(char * format, int i1, int i2);
static void fpost(float got,float expected,char mesgstr[]);
static void ipost(int got,int expected,char mesgstr[]);
static void lpost(long got, long expected, char mesgstr[]);
static void spost(char got[], char expected[], char mesgstr[]);
static void b4abort(void);

static FILE *opnfil( int );
static int  clsrmfil( int );

#define REL_2_0 0200
#define REL_2_1 0201

/*
static void errmesg(char *);
static void debug( void );
static void opost(int , int , char *);
*/

#if defined(_DLL) && defined(_M_MPPC)
static "C" {
static void _TestExit(int);
}
static void crt_test_terminate();

#define CreateExitFile() _TestExit(gloflg == PASSED ? 3 : 1)
#else
#define CreateExitFile()
#endif
#ifdef _XBOX
extern "C" int DbgPrint(const char *, ...);
#endif

#endif // #define __TSTHD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\clib.h ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-1998 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as	agreed in writing with
 *  Dinkumware, Ltd.
 */

/*
 * CLIB - portable replacements for various C library functions
 */
#ifndef CLIB_H
#define CLIB_H

/* assumes you have #include'd either  "defs.h"  or  "hodefs.h" */

/*
 * IS_DIGIT
 */
int is_digit FN_DEF1(c,
	int c)
	{
	return '0' <= c && c <= '9';
	}

/*
 * MEM_CMP
 */
int mem_cmp FN_DEF3(ps1, ps2, n,
	const void *ps1,
	const void *ps2,
	int n)
	{
	const char *s1 = (const char *)ps1;
	const char *s2 = (const char *)ps2;
	for (;n > 0; --n)
		{
		if (*s1 != *s2)
			return (UCHAR)*s1 - (UCHAR)*s2;
		++s1, ++s2;
		}
	return 0;
	}

/*
 * STR_CMP
 */
int str_cmp FN_DEF2(s1, s2,
	const char *s1,
	const char *s2)
	{
	for (; *s1 == *s2; ++s1, ++s2)
		if (*s1 == '\0')
			return 0;
	return (UCHAR)*s1 - (UCHAR)*s2;
	}

/*
 * ST_NCMP
 *  Note: spelled  st_ncmp  to avoid 6-letter collision with st_ncpy
 */
int st_ncmp FN_DEF3(s1, s2, n,
	const char *s1,
	const char *s2,
	int n)
	{
	for (; n > 0 && *s1 == *s2; ++s1, ++s2, --n)
		if (*s1 == '\0')
			return 0;
	if (n == 0)
		return 0;
	else
		return (UCHAR)*s1 - (UCHAR)*s2;
	}

/*
 * STR_CPYE - copy string s2 to s1 (not an exact replacement for strcpy)
 */
char *str_cpye FN_DEF2(s1, s2,
	char *s1,
	const char *s2)
	{
	while ((*s1 = *s2++) != '\0')
		++s1;
	return s1;
	}

/*
 * STR_CAT - copy string s2 to end of s1
 */
char *str_cat FN_DEF2(s1, s2,
	char *s1,
	const char *s2)
	{
	char *s0 = s1;

	while (*s1 != '\0')
		++s1;
	while ((*s1 = *s2++) != '\0')
		++s1;
	return s0;
	}

/*
 * ST_NCPY - copy at most n chars of string s2 to s1
 */
char *st_ncpy FN_DEF3(s1, s2, n,
	char *s1,
	const char *s2,
	int n)
	{
	char *s0 = s1;
	while (n > 0 && (*s1 = *s2++) != '\0')
		--n, ++s1;
	while (n-- > 0)
		*s1++ = '\0';
	return s0;
	}

/*
 * STR_LEN - return the length of a string
 */
int str_len FN_DEF1(s,
	const char *s)
	{
	const char *t;

	for (t = s; *t != '\0'; ++t)
		;
	return t - s;
	}

/*
 * STR_STR - find occurrence of s2 in s1
 */
const char *str_str FN_DEF2(s1, s2,
	const char *s1,
	const char *s2)
	{
	register const char *ps1, *ps2;

	if (*s2 == '\0')
		return s1;
	for ( ; *s1 != '\0'; ++s1)
		{
		if (*s1 == *s2)
			{
			for (ps1 = s1, ps2 = s2; *ps1 && *ps2 && *ps1 == *ps2; ++ps1, ++ps2)
				;
			if (*ps2 == '\0')
				return s1;
			}
		}
	return 0;
	}
/*
 * STR_CSPN
 */
int str_cspn FN_DEF2(s1, s2,
	char *s1,
	char *s2)
	{
	register int i;
	register char *p;

	for (i = 0;  s1[i] != '\0';  ++i)
		{
		for (p = s2;  *p != '\0';  ++p)
			{
			if (*p == s1[i])
				return (i);
			}
		}
	return (i);
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\compil.h ===
/* Suite++: The Plum Hall Validation Suite for C++
 * LVS++:   The Plum Hall Validation Suite for the C++ Library
 * AND      The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1994, Plum Hall Inc
 * DATE: 1994-07-20
 * As per your license agreement, your distribution is not
 * to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

/* CONFIGURATION -- ADAPT THE FOLLOWING PAGE OF DEFINITIONS TO LOCAL VALUES APPROPRIATE TO COMPILER  */

#ifndef COMPIL_H
#define COMPIL_H

#define ANSI 1	/* conforms to ANSI X3J11 standard */

#ifndef LIB_TEST
#include <limits.h>
#include <float.h>
#include <stddef.h>
#ifndef STANDALONE
#include <errno.h>
#include <stdlib.h>
#endif  /* !STANDALONE */
#define LIB_TEST 0
#endif	/* !LIB_TEST */

#define UCHAR	unsigned char		/* For pre-ANSI compiler, these */
#define USHORT	unsigned short		/* can be simulated or faked */
#define ULONG	unsigned long		/* as needed */

#ifndef Dgeneric_ptr
#define Dgeneric_ptr
typedef void *generic_ptr;
#endif	/* Dgeneric_ptr */

#define V7	 0
/* The following named-constants can be configured independently */
#define UNIQ_MEMB_NAMES 	1	/* Does each struct-or-union have unique member name table */
#define VOID_OK 			1	/* Does compiler recognize "void" */
#define LONG_IDENTIFIERS 	1	/* Is name significance at least 31 */
#define STRUCT_COND_OK 		1	/* Can conditional (?:) operator take struct-or-union operands */
#define TAG_AND_MEMB_SPACES 1	/* Are name spaces of tags and members separate */
#define ALL_STRING_FNS 		1	/* Are all string fns (see d11.c pg 1) provided */
#define ALL_CTYPE_FNS 		1	/* Are all ctype fns (esp. isgraph, tolower, toupper) provided */
#define HAS_PROTOTYPES		1	/* Does compiler support "prototype" declarations -- int f(int); */
#define NEW_STYLE_FN_DEF 	1	/* Does compiler support "prototype" fn definitions -- int f(int i) { ... } */
#define MACRO_NOV_86 		1	/* Full Nov 86 draft -- rescan cat'ed names, full re-scan */
#define LIB_NOV_86			1	/* Full Nov 86 library */
#define WIDE_CHARS			1	/* has L'x', L"x", and wc*mb* functions */
#define PP_CAT_AND_STR		1	/* has preprocessor catenate and stringize */
#define TRIGRAPHS			1	/* supports trigraphs */
#define ANSI8612			1	/* embodies Dec 86 decisions (see Suite User Manual) */
#define ANSI8703			1	/* embodies Mar 87 decisions (see Suite User Manual) */
#define ANSI8706			1	/* embodies Jun 87 decisions (see Suite User Manual) */
#define ANSI8709			1	/* embodies Sep 87 decisions (see decision.88 */
#define ANSI8712			1	/* embodies Dec 87 decisions (see decision.88 */
#define ANSI8804			1	/* embodies Apr 88 decisions (see decision.88 */
#define ANSI8809			1	/* embodies Sep 88 decisions (see decision.88 */
#endif	/* COMPIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\defs.h ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as	agreed in writing with
 *  Dinkumware, Ltd.
 */

/* defs.h -- define support for tests
 */
#ifndef DEFS_H
 #define DEFS_H
#include <float.h>
#include <stdio.h>
#ifdef _XBOX
extern "C" int DbgPrint(const char *, ...);
#endif
#include "flags.h"

	// macros and types used throughout tests
typedef char Char;	// should also permit [un]signed char too
typedef unsigned char Mychar;	// signed char or unsigned char
typedef int Ty;	// should be an integer type

#if IS_EMBEDDED
 #define CPXfloat	float_complex
 #define CPXdouble	double_complex
#else /* IS_EMBEDDED */
 #define CPXfloat	complex<float>
 #define CPXdouble	complex<double>
 #define CPXldouble	complex<long double>

struct Myfloat
	{	// stressful float for template class complex
	Myfloat(double x = 0)
		: val(x)
		{}	// construct from x

	operator double() const
		{	// return stored value
		return (val); }

private:
	double val;	// the stored value
	};
#endif /* IS_EMBEDDED */

static const long double e      = 2.7182818284590452353602874713526625L;
static const long double ln2    = 0.69314718055994530941723212145817657L;
static const long double piby4  = 0.78539816339744830961566084581987572L;
static const long double rthalf = 0.70710678118654752440084436210484904L;
static const long double cos1   = rthalf * (e + 1 / e) / 2;
static const long double sin1   = rthalf * (e - 1 / e) / 2;

#define CLINK	/* nonstandard C linkage, otherwise empty */

#ifdef _LONGLONG	/* common extension */
 #define Longlong	_LONGLONG
 #ifdef _ULONGLONG
  #define ULonglong	_ULONGLONG
 #else
  #define ULonglong	unsigned _LONGLONG
 #endif
#endif

	// macros used by bitset
#define NITSY	1	/* NITSY == 0 for maximum stress, otherwise 1 */
#define NTINY	6	/* NTINY < # of bits in char */
#define NBIG	131	/* NBIG > # of bits in unsigned long */

	// macros used by iostreams classes
#if IS_EMBEDDED
 #define Al		STD char_allocator
 #define Bi		STD ios
 #define Bfs	STD filebuf
 #define Bs		STD streambuf
 #define Bss	STD stringbuf
 #define Cstr	STD string
 #define Ifs	STD ifstream
 #define Is		STD istream
 #define Isit	STD istreambuf_iterator<char, It>
 #define Iss	STD istringstream
 #define It		STD char_traits
 #define Ofs	STD ofstream
 #define Os		STD ostream
 #define Osit	STD ostreambuf_iterator<char, It>
 #define Oss	STD ostringstream
 #define Sb		STD stringbuf
 #define Ustr	STD string
#else /* IS_EMBEDDED */
 #define Al 	STD allocator<Char>
 #define Bi		STD basic_ios<Char, It >
 #define Bfs	STD basic_filebuf<Char, It >
 #define Bs		STD basic_streambuf<Char, It >
 #define Bss	STD basic_stringbuf<Char, It >
 #define Cstr	STD basic_string<Char, It, Al >
 #define Ifs	STD basic_ifstream<Char, It >
 #define Is		STD basic_istream<Char, It >
 #define Isit	STD istreambuf_iterator<Char, It >
 #define Iss	STD basic_istringstream<Char, It >
 #define It		STD char_traits<Char>
 #define Ofs	STD basic_ofstream<Char, It >
 #define Os		STD basic_ostream<Char, It >
 #define Osit	STD ostreambuf_iterator<Char, It >
 #define Oss	STD basic_ostringstream<Char, It >
 #define Sb		STD basic_stringbuf<Char, It, Al >
 #define Ustr	STD basic_string<Char, It, Al >
#endif /* IS_EMBEDDED */

#if IS_EMBEDDED
 #define CHAR_TRAITS			char_traits
 #define STR_ALLOCATOR(T)		char_allocator
#else /* IS_EMBEDDED */
 #define CHAR_TRAITS			char_traits<char>
 #define STR_ALLOCATOR(T)		ALLOCATOR(T)
#endif /* IS_EMBEDDED */

 #define ALLOCATOR(T)			STD allocator<T>	/* CHANGED [MAR96] */
 #define ADDRESS(T, al, x)		al.address(x)
 #define ALLOCATE(T, al, n)		al.allocate(n, (void *)0)
 #define CONSTRUCT(T, al, p, v)	al.construct(p, v)
 #define DEALLOCATE(T, al, p)	al.deallocate(p)
 #define DESTROY(T, al, p)		al.destroy(p)
 #define MAX_SIZE(T, al)		al.max_size()

 #define PTR_TYPE(T, A)			A
 #define SIZ_TYPE(T, A)			A

#if !DISALLOW_TOLERANT_TEMPLATES
 #define ADDFAC(loc, pfac)		locale(loc, pfac)
 #define HAS(loc, fac)	has_facet<fac>(loc)
 #define USE(loc, fac)	use_facet<fac>(loc)
#else
// tailor as needed for actual locale implementation
 #define ADDFAC(loc, pfac)	_Addfac(loc, pfac)
 #define HAS(loc, fac)	has_facet(loc, (fac *)0)
 #define USE(loc, fac)	use_facet(loc, (fac *)0)
#endif

#if DISALLOW_NAMESPACES
 #define STD	/* should be :: */
 #define CSTD	/* should be :: */
#else
 #define STD	/* should be std:: */
 #define CSTD	/* should be std:: or at least :: */
namespace std {}
using namespace std;	// temporary, until more detailed tests
#endif

#if DISALLOW_BOOLEANS
// tailor as needed for any names not defined in library
// #define true 1
// #define false 0
// #define bool int
 #define Bool	_Bool
#else
 #define Bool	bool
#endif

#if DISALLOW_BOOLEANS || DISALLOW_PARTIAL_SPECIALIZATION
// tailor as needed for actual vector<bool> implementation
// (assumed to look like vector<Bool, Bool_allocator>)
#define Bool_allocator	_Bool_allocator
#endif

#if DISALLOW_ACTUAL_DESTRUCTOR_NAME
 #define DESTRUCTOR(actual, alias)	~alias()
#else
 #define DESTRUCTOR(actual, alias)	~actual()
#endif

#ifdef THROW
// THROW and THROW0 are predefined in flags.h
#elif DISALLOW_EXCEPTIONS
 #define THROW(x)
 #define THROW0()
#else
 #define THROW(x)	throw (x)
 #define THROW0()	throw ()
#endif

	// MACROS USED IN TEST CODE
#define errmes(mesg)	fail_report_chk(__LINE__, mesg)
#define chk(x)			beq_chk(__LINE__, x, #x)
#define ileq(x, y)		ile_chk(__LINE__, x, y)
#define ieq(x, y)		ieq_chk(__LINE__, x, y)
#define leq(x, y)		leq_chk(__LINE__, x, y)
#define ueq(x, y)		ueq_chk(__LINE__, x, y)
#define feq(x, y)		feq_chk(__LINE__, x, y)
#define deq(x, y)		deq_chk(__LINE__, x, y)
#define ldeq(x, y)		eeq_chk(__LINE__, x, y)
#define steq(x, y)		seq_chk(__LINE__, x, y)
#define aeq(x, y)		aeq_chk(__LINE__, x, y)

#define FLT1_CHK(x, y)	((x) < 0 ? -(x) <= (y) : (x) <= (y))
#define FLT_CHK(x, y, eps)	((x) == 0 ? FLT1_CHK(y, eps) \
	: (y) == 0 ? FLT1_CHK(x, eps) \
	: FLT1_CHK(((x) - (y)) / (x), eps))

#define TOUCH(x)	_touch((void *)&(x))

	// STATIC STORAGE
const float feps_chk = FLT_EPSILON * 2;
const double deps_chk = DBL_EPSILON * 4;
const long double eeps_chk = LDBL_EPSILON * 6;

static char buf_chk[64] = "";
static const char *fname_chk = "";
static const char *iname_chk = "";

static bool reached_chk = false;

static int fail_chk = 0;
static int succ_chk = 0;
static int total_cfail_chk = 0;
static int total_csucc_chk = 0;
static int total_fail_chk = 0;
static int total_cskip_chk = 0;
static int total_succ_chk = 0;

	// FUNCTIONS
inline void _touch(void *)
	{}	// to quiet warnings about unused declarations

static void enter_chk(const char *fname)
	{	// enter test arena
	fname_chk = fname; }

static bool leave_chk(const char *tname)
	{	// leave test arena
	if (0 < total_fail_chk)
		DbgPrint("***** %d erroneous items in %s *****\n",
			total_fail_chk, tname);
	if (0 < total_succ_chk)
		DbgPrint("***** %d successful items in %s *****\n",
			total_succ_chk, tname);
	if (0 < total_cskip_chk)
		DbgPrint("***** %d skipped test cases in %s *****\n",
			total_cskip_chk, tname);
	DbgPrint("***** %d erroneous test cases in %s *****\n",
			total_cfail_chk, tname);
	DbgPrint("***** %d successful test cases in %s *****\n",
		total_csucc_chk, tname);
	return (total_fail_chk != 0); }

static void begin_chk(const char *iname)
	{	// enter a test
	iname_chk = iname;
	fail_chk = 0;
	succ_chk = 0; }

static void end_chk(const char *iname)
	{	// end a test
	if (fail_chk == 0)
		++total_csucc_chk;
	else
		++total_cfail_chk;
	total_fail_chk += fail_chk;
	total_succ_chk += succ_chk;
	DbgPrint("#%s: %s\n", 0 < fail_chk ? "FAILED" : "PASSED",
		iname); }

static void skip_chk(const char *sname)
	{	// skip a test
	++total_cskip_chk;
	DbgPrint("#SKIPPED: %s\n", sname); }

static void first_chk()
	{	// first-time check
	if (!reached_chk)
		{	// print entry message
		DbgPrint("***** Reached first test *****\n");
		reached_chk = true; }}

static bool succ_report_chk()
	{	// record success
	first_chk();
	++succ_chk;
	return (true); }

static bool fail_report_chk(int line, const char *mesg)
	{	// record failure
	first_chk();
	++fail_chk;
	DbgPrint("error in %s at line %d%s%s\n", fname_chk,
		line, mesg[0] == '\0' ? "" : ": ", mesg);
	return (false); }

static bool beq_chk(int line, bool x, const char *mesg)
	{	// boolean check
	if (x)
		return (succ_report_chk());
	else
		return (fail_report_chk(line, mesg)); }

static bool ile_chk(int line, int x, int y)
	{	// int x <= y check
	if (x <= y)
		return (succ_report_chk());
	else
		{	// print error message
		sprintf(buf_chk, "%d > %d", x, y);
		return (fail_report_chk(line, buf_chk)); }}

static bool ieq_chk(int line, int x, int y)
	{	// int x == y check
	if (x == y)
		return (succ_report_chk());
	else
		{	// print error message
		sprintf(buf_chk, "%d != %d", x, y);
		return (fail_report_chk(line, buf_chk)); }}

static bool leq_chk(int line, long x, long y)
	{	// long x == y check
	if (x == y)
		return (succ_report_chk());
	else
		{	// print error message
		sprintf(buf_chk, "%ld != %ld", x, y);
		return (fail_report_chk(line, buf_chk)); }}

static bool ueq_chk(int line, unsigned long x, unsigned long y)
	{	// unsigned long x == y check
	if (x == y)
		return (succ_report_chk());
	else
		{	// print error message
		sprintf(buf_chk, "%ld != %ld", x, y);
		return (fail_report_chk(line, buf_chk)); }}

static bool feq_chk(int line, float x, float y)
	{	// float x == y check
	if (FLT_CHK(x, y, feps_chk))
		return (succ_report_chk());
	else
		{	// print error message
		sprintf(buf_chk, "%.6g != %.6g", x, y);
		return (fail_report_chk(line, buf_chk)); }}

static bool deq_chk(int line, double x, double y)
	{	// double x == y check
	if (FLT_CHK(x, y, deps_chk))
		return (succ_report_chk());
	else
		{	// print error message
		sprintf(buf_chk, "%.10g != %.10g", x, y);
		return (fail_report_chk(line, buf_chk)); }}

static bool eeq_chk(int line, long double x, long double y)
	{	// long double x == y check
	if (FLT_CHK(x, y, eeps_chk))
		return (succ_report_chk());
	else
		{	// print error message
		sprintf(buf_chk, "%.10Lg != %.10Lg", x, y);
		return (fail_report_chk(line, buf_chk)); }}

static bool seq_chk(int line, const char *x, const char *y)
	{	// string x == y check
	int i;
	for (i = 0; x[i] != '\0' && x[i] == y[i]; ++i)
		;
	if (x[i] == y[i])
		return (succ_report_chk());
	else
		{	// print error message
		sprintf(buf_chk, "\"%s\" != \"%s\"", x, y);
		return (fail_report_chk(line, buf_chk)); }}

static bool aeq_chk(int line, const void *x, const void *y)
	{	// address x == y check
	if (x == y)
		return (succ_report_chk());
	else
		{	// print error message
		sprintf(buf_chk, "%p != %p", x, y);
		return (fail_report_chk(line, buf_chk)); }}

inline int ceil_log2(int n)
	{	// compute log2(n) rounded up
	if (n < 2)
		return (0);
	else
		return (1 + ceil_log2((n + 1) / 2)); }

#endif  /* of DEFS_H */

/*
991124 pjp: revised for 3.0
000328 pjp: changed ERROR to error for grep
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\logdbg.h ===
//
// QA added file to redirect CRT dbg output to stdout.
//
#if !defined(__LOGDBG_H__)
#define __LOGDBG_H__

#if defined(_DEBUG) && !defined(QA_NO_DBGCRT_HOOK)
#include <crtdbg.h>
#include <stdlib.h>
#include <stdio.h>

static int oldRetVal = 0;
static int reportHookCalled = 0; /* 1 if report hook called */
static int dbgCrtCont = 0;       /* 0 == exit, 1 = continue program. */

static void logDbgCrtExit(void)
{
  exit(99);
}

static int logDbgCrtReport(int nRptType, char *szMsg, int* retval)
{
  oldRetVal = 0;
  reportHookCalled = 1;
  if (dbgCrtCont)
    return 1;
  printf("\nDebug CRT Report: %s", szMsg);
  printf("%s: ----- FAILED -----\n", __FILE__);
  logDbgCrtExit();
  return 0;    /* never gets called, but compiler complains if not here.*/
}

#define InitDbgLog()  _CrtSetReportHook((_CRT_REPORT_HOOK)logDbgCrtReport)

#else

#define InitDbgLog()

#endif

#endif // __LOGDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\flags.h ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-1998 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as	agreed in writing with
 *  Dinkumware, Ltd.
 */

/* flags.h  */

#ifndef FLAGS_H
#define FLAGS_H

#define BIG_OBJECT	((size_t)(-1) / 2)	/* or smaller, as needed */

#if _MSC_VER < 1200
 #define PAIR_DEFINITION	typedef pair<Char, int> Pair
#endif

#define THROW(x)	/* VC++ ignores exception specifications */
#define THROW0()

#define DISALLOW_ACTUAL_DESTRUCTOR_NAME	0
#define DISALLOW_ARRAY_NEW_DELETE	0
#define DISALLOW_MEMBER_TEMPLATES	0
#define DISALLOW_PARTIAL_SPECIALIZATION	1
#define DISALLOW_PLACEMENT_DELETE	0
#define DISALLOW_TOLERANT_TEMPLATES	0
#define DISALLOW_TYPENAME	0
#define DISALLOW_USER_NAME_PROTECTION	1

/* #define DISALLOW_ACTUAL_DESTRUCTOR_NAME */
/* #define DISALLOW_ARRAY_NEW_DELETE */
/* #define DISALLOW_BINARY_AND_UNARY_AMPERSAND */
/* #define DISALLOW_BOOLEANS */
/* #define DISALLOW_CONDITIONS */
/* #define DISALLOW_DIGRAPHS */
/* #define DISALLOW_EMPTY_BRACKETS_IN_DELETE */
/* #define DISALLOW_EXCEPTIONS */
/* #define DISALLOW_IMPLICIT_INSTANTIATION */
/* #define DISALLOW_MEMBER_TEMPLATES */
/* #define DISALLOW_MUTABLE */
/* #define DISALLOW_NAMESPACES */
/* #define DISALLOW_NEW_CASTS */
/* #define DISALLOW_OVERLOADED_POSTFIX_INCREMENT */
/* #define DISALLOW_PARTIAL_SPECIALIZATION */
/* #define DISALLOW_PLACEMENT_DELETE */
/* #define DISALLOW_QUALIFIED_CLASS_NAMES */
/* #define DISALLOW_REDUNDANT_PARENS_IN_DECLARATOR */
/* #define DISALLOW_RETURN_TEMPORARY_WITH_DESTRUCTOR */
/* #define DISALLOW_RTTI */
/* #define DISALLOW_TEMPLATES */
/* #define DISALLOW_TOLERANT_POINTER_OPERATOR */
/* #define DISALLOW_TOLERANT_TEMPLATES */
/* #define DISALLOW_TYPENAME */
/* #define DISALLOW_USER_NAME_PROTECTION */
/* #define SKIP_PENDING_CASES */

		/* SKIP INDIVIDUAL TESTS */
#define SKIP_18614T11  /* unexpected() called by exception-specification failure */

#define SKIP_265T41a  /* abs(long), div(long, long) clashes w/valarray */
#define SKIP_2782T21  /* <cwchar> synopsis */

 #if (defined(_DLL) && !defined(_STATIC_CPPLIB)) || defined(_DEBUG)
  /*
   * These tests expect replacement new/delete to be called for internal
   * Library operations, which doesn't happen in the DLL or Debug CRTs
   */
  #define SKIP_XD313T65  /* streambuf::overflow calls operator new[] */
  #define SKIP_XD313T73  /* streambuf::overflow calls operator delete */
 #endif

#endif  /* of FLAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\memcheck.h ===
#if !defined(__MEM_CHECK_H__)
#define __MEM_CHECK_H__

#if defined(_DEBUG)
#include <crtdbg.h>

#if !defined(QA_DBG_OUTPUT_DEBUGWIN)

#define  QA_SEND_TO_STDOUT() \
    _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE ); \
    _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT ); \
    _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE ); \
    _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT ); \
    _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE ); \
    _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT )
#else
#define  QA_SEND_TO_STDOUT()
#endif

#define  SET_CRT_DEBUG_FIELD(a) \
            _CrtSetDbgFlag((a) | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG))
#define  CLEAR_CRT_DEBUG_FIELD(a) \
            _CrtSetDbgFlag(~(a) & _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG))

#define QA_DISPLAY_MEM_LEAKS_STDOUT() \
	QA_SEND_TO_STDOUT(); \
    SET_CRT_DEBUG_FIELD(_CRTDBG_LEAK_CHECK_DF)

class CMemCheck
{
public:
  CMemCheck(int line)
  : m_line(line)
  {
    //!: how much of this is necessary?
	QA_DISPLAY_MEM_LEAKS_STDOUT();
    _CrtMemCheckpoint(&m_memState);
  }
  ~CMemCheck()
  {
    _CrtMemState  cur;
    _CrtMemState  result;
    _CrtMemCheckpoint(&cur);

    if (_CrtMemDifference(&result, &m_memState, &cur ))
    {
      complain(m_line);
      _CrtMemDumpAllObjectsSince(&m_memState);
    }
  }

private:
  int       m_line;
  _CrtMemState  m_memState;
};

#define MEM_CHECK_OBJECT CMemCheck      memCheck(__LINE__)
#define MEM_CHECK_OBJECT_GLOBAL CMemCheck g_memCheck(__LINE__)

#else

#define MEM_CHECK_OBJECT
#define MEM_CHECK_OBJECT_GLOBAL

#define  SET_CRT_DEBUG_FIELD(a)
#define  CLEAR_CRT_DEBUG_FIELD(a)

#define  QA_SEND_TO_STDOUT()

#define QA_DISPLAY_MEM_LEAKS_STDOUT()

#endif

#endif // __MEM_CHECK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\slconfrm.cpp ===
#include <stdio.h>

int t170_main(int argc, char *argv[]);
int t180_main(int argc, char *argv[]);
int t182_main(int argc, char *argv[]);
int t183_main(int argc, char *argv[]);
int t190_main(int argc, char *argv[]);
int t212_main(int argc, char *argv[]);
int t217_main(int argc, char *argv[]);
int t230_main(int argc, char *argv[]);
int t238_main(int argc, char *argv[]);
int t251_main(int argc, char *argv[]);
int t252_main(int argc, char *argv[]);
int t258_main(int argc, char *argv[]);
int t260_main(int argc, char *argv[]);
int t262_main(int argc, char *argv[]);
int t270_main(int argc, char *argv[]);
int t273_main(int argc, char *argv[]);
int t27e_main(int argc, char *argv[]);
int t27f_main(int argc, char *argv[]);
int t27j_main(int argc, char *argv[]);
int txd0_main(int argc, char *argv[]);
int txd2_main(int argc, char *argv[]);


extern "C" void __cdecl SlConfrmStartTest( void )
{
    t170_main( 0, NULL );
    t180_main( 0, NULL );
    t182_main( 0, NULL );
    t183_main( 0, NULL );
    t190_main( 0, NULL );
    t212_main( 0, NULL );
    t217_main( 0, NULL );
    t230_main( 0, NULL );
    t238_main( 0, NULL );
    t251_main( 0, NULL );
    t252_main( 0, NULL );
    t258_main( 0, NULL );
    t260_main( 0, NULL );
    t262_main( 0, NULL );
    t270_main( 0, NULL );
    t273_main( 0, NULL );
    t27e_main( 0, NULL );
    t27f_main( 0, NULL );
    t27j_main( 0, NULL );
    txd0_main( 0, NULL );
    txd2_main( 0, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\sdutil.h ===
/* Suite++: The Plum Hall Validation Suite for C++
 * LVS++:   The Plum Hall Validation Suite for the C++ Library
 * AND      The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1994, Plum Hall Inc
 * DATE: 1994-07-20
 * As per your license agreement, your distribution is not
 * to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef SDUTIL_H
#define SDUTIL_H

#ifndef FREESTANDING
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#endif /* FREESTANDING */

#include "defs.h"

extern char last_char_printed;

#ifndef FREESTANDING

/* If your environment is FREESTANDING, you need to ...
 *  For the C suite, modify  pr_ok  and  setzero ; you don't need
 *      the  ph_alloc  and  ph_free  functions.
 *  For the C++ suite, modify all of the remaining functions.
 */

/*
 * PH_ALLOC - allocate dynamic memory
 */
void *ph_alloc FN_DEF1(n,
	int n)
	{
	return malloc(n != 0 ? n : 1);
	}

/*
 * PH_FREE - free dynamic memory
 */
void ph_free FN_DEF1(p,
	void *p)
	{
	free((char *)p);
	}

/*
 * PR_OK - printf a text line in ok situation (no error, just text)
 */
void pr_ok FN_DEF1(s,
	const char *s)
	{
	char c;
#ifndef _XBOX
	fputs(s, stdout);
#else
	DbgPrint(s);
#endif
	while (*s != '\0')
		c = *s++;
	last_char_printed = c;
	fflush(stdout);
	}

/*
 * SETZERO - appear, to a compiler, as though Zero is unpredictably set
 */
extern int Zero;

void setzero()
	{
	FILE *fp;
	int save;

	save = errno;
	if ((fp = fopen("nonexistent", "r")) != 0)
		{
		fscanf(fp, "ignore format", &Zero);
		fclose(fp);
		}
	errno = save;
	}

#endif /* FREESTANDING */

#endif /* SDUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\machin.h ===
/* Suite++: The Plum Hall Validation Suite for C++
 * LVS++:   The Plum Hall Validation Suite for the C++ Library
 * AND      The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1994, Plum Hall Inc
 * DATE: 1994-07-20
 * As per your license agreement, your distribution is not
 * to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef MACHIN_H
#define MACHIN_H

#include <limits.h>
#define SIGNED_CHAR		(CHAR_MIN < 0)		/* Does char sign-extend ... */
#define UNSIGNED_CHAR	(CHAR_MIN == 0)		/* ... or not? */

#define MAX_UCHAR		UCHAR_MAX		/* biggest unsigned character */
#define MAX_USHORT		USHRT_MAX		/* biggest unsigned short */
#define MAX_UINT		UINT_MAX		/* biggest unsigned int */
#define MAX_INT			INT_MAX			/* biggest int */
#define MAX_ULONG		ULONG_MAX		/* biggest unsigned long */
#define MAX_LONG		LONG_MAX		/* biggest long int */

#include <float.h>
#define FDIGITS_MAX 	(FLT_DIG - 1)	/* number of significant digits for single precision comparison. */
#define DIGITS_MAX 		(DBL_DIG - 1)	/* number of significant digits for double precision comparison. */
#define LDIGITS_MAX 	(LDBL_DIG - 1)	/* number of significant digits for long double precision comparison. */
#endif	/* MACHIN_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sources

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built

!ENDIF

TARGETTYPE=LIBRARY
TARGETPATH=..\..\lib

386_STDCALL=0
USER_C_FLAGS=-TP -DQA_DBG_OUTPUT_DEBUGWIN=1 -DXBOX
USE_NATIVE_EH=1
LINKER_FLAGS=/IGNORE:4006

SOURCES=\
	..\t170.cpp \
	..\t180.cpp \
	..\t182.cpp \
	..\t183.cpp \
	..\t190.cpp \
	..\t212.cpp \
	..\t217.cpp \
	..\t230.cpp \
	..\t238.cpp \
	..\t251.cpp \
	..\t252.cpp \
	..\t258.cpp \
	..\t260.cpp \
	..\t262.cpp \
	..\t270.cpp \
	..\t273.cpp \
	..\t27e.cpp \
	..\t27f.cpp \
	..\t27j.cpp \
	..\txd0.cpp \
	..\txd2.cpp \
	..\slconfrm.cpp

INCLUDES=$(XDK_INC_PATH);$(INCLUDES)

MSC_WARNING_LEVEL=/W2

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\iter.h ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as	agreed in writing with
 *  Dinkumware, Ltd.
 */

#ifndef ITER_H
#define ITER_H
#include <iterator>
		// CONSTANTS
const int bad_copy = 0x01;
const int bad_compare = 0x02;
const int bad_indirect = 0x04;
const int bad_preinc = 0x08;
const int bad_postinc = 0x10;
const int bad_assign = 0x40;
const int bad_destroy = 0x80;
const int bad_predec = 0x100;
const int bad_postdec = 0x200;
const int bad_incn = 0x400;
		// TEMPLATE CLASS strict_random_access_iterator
template<class Iter, class T>
	class strict_random_access_iterator
		: public iterator<random_access_iterator_tag, T, int,
			T *, T&> {
public:
	strict_random_access_iterator()
		: iter(Iter()), perr(&recno), pcnt(&recno),
			maxrec(0), recno(0)
		{}
	strict_random_access_iterator(Iter it, int& err,
		int& cnt, int off = 0)
		: iter(it), perr(&err), pcnt(&cnt), recno(cnt - off),
			maxrec(cnt)
		{*perr = 0; }
	bool operator==(
		const strict_random_access_iterator<Iter, T> &x) const
		{return (iter == x.iter); }
	bool operator!=(
		const strict_random_access_iterator<Iter, T> &x) const
		{return (!(*this == x)); }
	T& operator*() const
		{if (recno <= 0 || maxrec < recno)
			*perr |= bad_indirect;
		return (*iter); }
#if _HAS_TOLERANT_POINTER_OPERATOR
	T *operator->() const
		{return (&**this); }
#endif
	strict_random_access_iterator<Iter, T>& operator++()
		{if (recno <= 0)
			*perr |= bad_preinc;
		else
			--recno;
		if (recno < *pcnt)
			*pcnt = recno;
		++iter;
		return (*this); }
	strict_random_access_iterator<Iter, T> operator++(int)
		{strict_random_access_iterator<Iter, T> tmp(*this);
		if (recno <= 0)
			*perr |= bad_postinc;
		else
			--recno;
		if (recno < *pcnt)
			*pcnt = recno;
		++iter;
		return (tmp); }
	strict_random_access_iterator<Iter, T>& operator--()
		{if (maxrec <= recno)
			*perr |= bad_predec;
		else
			++recno;
		--iter;
		return (*this); }
	strict_random_access_iterator<Iter, T> operator--(int)
		{strict_random_access_iterator<Iter, T> tmp(*this);
		if (recno == 0)
			*perr |= bad_postdec;
		else
			++recno;
		--iter;
		return (tmp); }
	strict_random_access_iterator<Iter, T>& operator+=(int n)
		{if (0 < n && recno < n || n < 0 && n < recno - maxrec)
			*perr |= bad_incn;
		else
			recno -= n;
		if (recno < *pcnt)
			*pcnt = recno;
		iter += n;
		return (*this); }
	strict_random_access_iterator<Iter, T>& operator-=(int n)
		{return (*this += -n); }
	int operator-(
		const strict_random_access_iterator<Iter, T> &x) const
		{return (iter - x.iter); }
	T& operator[](int n) const
		{strict_random_access_iterator<Iter, T> tmp = *this;
		tmp += n;
		return (*tmp); }
	bool operator<(
		const strict_random_access_iterator<Iter, T> &x) const
		{return (iter < x.iter); }
	bool operator>(
		const strict_random_access_iterator<Iter, T> &x) const
		{return (iter > x.iter); }
	bool operator<=(
		const strict_random_access_iterator<Iter, T> &x) const
		{return (iter <= x.iter); }
	bool operator>=(
		const strict_random_access_iterator<Iter, T> &x) const
		{return (iter >= x.iter); }
private:
	int *perr, *pcnt, recno, maxrec;
	Iter iter;
	};
template<class Iter, class T>
	strict_random_access_iterator<Iter, T>
		operator+(const strict_random_access_iterator<Iter, T> x,
			int n)
	{strict_random_access_iterator<Iter, T> tmp = x;
	return (tmp += n); }
template<class Iter, class T>
	strict_random_access_iterator<Iter, T>
		operator+(int n,
			const strict_random_access_iterator<Iter, T> x)
	{strict_random_access_iterator<Iter, T> tmp = x;
	return (tmp += n); }
template<class Iter, class T>
	strict_random_access_iterator<Iter, T>
		operator-(const strict_random_access_iterator<Iter, T> x,
			int n)
	{strict_random_access_iterator<Iter, T> tmp = x;
	return (tmp -= n); }
template<class Iter, class T>
	strict_random_access_iterator<Iter, T>
		operator-(int n,
			const strict_random_access_iterator<Iter, T> x)
	{strict_random_access_iterator<Iter, T> tmp = x;
	return (tmp -= n); }
		// TEMPLATE CLASS strict_bidirectional_iterator
template<class Iter, class T>
	class strict_bidirectional_iterator
		: public iterator<bidirectional_iterator_tag, T, int,
			T *, T&> {
public:
	strict_bidirectional_iterator()
		: iter(Iter()), perr(&recno), pcnt(&recno),
			maxrec(0), recno(0)
		{}
	strict_bidirectional_iterator(Iter it, int& err,
		int& cnt, int off = 0)
		: iter(it), perr(&err), pcnt(&cnt),
			recno(cnt - off), maxrec(cnt)
		{*perr = 0; }
	bool operator==(
		const strict_bidirectional_iterator<Iter, T> &X) const
		{return (iter == X.iter); }
	bool operator!=(
		const strict_bidirectional_iterator<Iter, T> &X) const
		{return (!(*this == X)); }
	T& operator*() const
		{if (recno <= 0 || maxrec < recno)
			*perr |= bad_indirect;
		return (*iter); }
#if _HAS_TOLERANT_POINTER_OPERATOR
	T *operator->() const
		{return (&**this); }
#endif
	strict_bidirectional_iterator<Iter, T>& operator++()
		{if (recno <= 0)
			*perr |= bad_preinc;
		else
			--recno;
		if (recno < *pcnt)
			*pcnt = recno;
		++iter;
		return (*this); }
	strict_bidirectional_iterator<Iter, T> operator++(int)
		{strict_bidirectional_iterator<Iter, T> tmp(*this);
		if (recno <= 0)
			*perr |= bad_postinc;
		else
			--recno;
		if (recno < *pcnt)
			*pcnt = recno;
		++iter;
		return (tmp); }
	strict_bidirectional_iterator<Iter, T>& operator--()
		{if (maxrec <= recno)
			*perr |= bad_predec;
		else
			++recno;
		--iter;
		return (*this); }
	strict_bidirectional_iterator<Iter, T> operator--(int)
		{strict_bidirectional_iterator<Iter, T> tmp(*this);
		if (recno == 0)
			*perr |= bad_postdec;
		else
			++recno;
		--iter;
		return (tmp); }
private:
	int *perr, *pcnt, recno, maxrec;
	Iter iter;
	};
		// TEMPLATE CLASS strict_forward_iterator
template<class Iter, class T>
	class strict_forward_iterator
		: public iterator<forward_iterator_tag, T, int,
			T *, T&> {
public:
	strict_forward_iterator()
		: iter(Iter()), perr(&recno), pcnt(&recno), recno(0)
		{}
	strict_forward_iterator(Iter it, int& err,
		int& cnt, int off = 0)
		: iter(it), perr(&err), pcnt(&cnt), recno(cnt - off)
		{*perr = 0; }
	bool operator==(
		const strict_forward_iterator<Iter, T> &X) const
		{return (iter == X.iter); }
	bool operator!=(
		const strict_forward_iterator<Iter, T> &X) const
		{return (!(*this == X)); }
	T& operator*() const
		{if (recno <= 0)
			*perr |= bad_indirect;
		return (*iter); }
#if _HAS_TOLERANT_POINTER_OPERATOR
	T *operator->() const
		{return (&**this); }
#endif
	strict_forward_iterator<Iter, T>& operator++()
		{if (recno <= 0)
			*perr |= bad_preinc;
		else
			--recno;
		if (recno < *pcnt)
			*pcnt = recno;
		++iter;
		return (*this); }
	strict_forward_iterator<Iter, T> operator++(int)
		{strict_forward_iterator<Iter, T> tmp(*this);
		if (recno <= 0)
			*perr |= bad_postinc;
		else
			--recno;
		if (recno < *pcnt)
			*pcnt = recno;
		++iter;
		return (tmp); }
private:
	int *perr, *pcnt, recno;
	Iter iter;
	};
		// TEMPLATE CLASS strict_input_iterator
template<class Iter, class T>
	class strict_input_iterator
		: public iterator<input_iterator_tag, T, int,
			T *, T&> {
public:
	strict_input_iterator(Iter it, int& err,
		int& cnt, int off = 0)
		: iter(it), perr(&err), pcnt(&cnt), recno(cnt - off)
		{*perr = 0; }
	bool operator==(
		const strict_input_iterator<Iter, T> &X) const
		{return (iter == X.iter); }
	bool operator!=(
		const strict_input_iterator<Iter, T> &X) const
		{return (!(*this == X)); }
	T operator*() const
		{if (recno <= 0)
			*perr |= bad_indirect;
		return (*iter); }
#if _HAS_TOLERANT_POINTER_OPERATOR
	T *operator->() const
		{return (&**this); }
#endif
	strict_input_iterator<Iter, T>& operator++()
		{if (*pcnt != recno)
			*perr |= bad_preinc;
		else if (0 < *pcnt)
			recno = --*pcnt;
		++iter;
		return (*this); }
	strict_input_iterator<Iter, T> operator++(int)
		{strict_input_iterator<Iter, T> tmp(*this);
		if (*pcnt != recno)
			*perr |= bad_postinc;
		else if (0 < *pcnt)
			recno = --*pcnt;
		++iter;
		return (tmp); }
private:
	int *perr, *pcnt, recno;
	Iter iter;
	};
		// TEMPLATE CLASS strict_output_iterator
template<class Iter, class T>
	class strict_output_iterator
		: public iterator<output_iterator_tag, void, void,
			void, void> {
public:
	enum State {ready = 0, postinc = 1, indirp = 2,
		indir = 4, assigned = 8, dead = 16};
	strict_output_iterator(Iter it, int& err,
		int& cnt, int off = 0)
		: iter(it), piter(&iter), perr(&err), pcnt(&cnt),
			recno(cnt - off), state(ready)
		{*perr = 0; }
	strict_output_iterator(
		const strict_output_iterator<Iter, T>& X)
		: piter(X.piter), perr(X.perr), pcnt(X.pcnt),
			recno(X.recno), state(X.state)
		{if (state != ready && state != postinc)
			*perr |= bad_copy; }
	void operator=(
		const strict_output_iterator<Iter, T> &X)
		{piter = X.piter, perr = X.perr, pcnt = X.pcnt,
			recno = X.recno, state = X.state;
		if (state != ready)
			*perr |= bad_copy; }
//	~strict_output_iterator()
//		{if (state != ready)
//			*perr |= bad_destroy; }
	strict_output_iterator<Iter, T>& operator=(const T& V)
		{if (state == indirp)
			state = dead, *pcnt = recno;
		else if (state == indir)
			state = assigned;
		else
			*perr |= bad_assign, state = ready;
		**piter = V;
		++*piter;
		return (*this); }
	strict_output_iterator<Iter, T>& operator*()
		{if (state == postinc)
			state = indirp;
		else if (state == ready)
			state = indir;
		else
			*perr |= bad_indirect, state = indir;
		return (*this); }
	strict_output_iterator<Iter, T>& operator++()
		{if (state != assigned)
			*perr |= bad_preinc;
		state = ready;
		if (*pcnt == 0 || *pcnt != recno)
			*perr |= bad_preinc;
		if (0 < *pcnt)
			recno = --*pcnt;
		return (*this); }
	strict_output_iterator<Iter, T> operator++(int)
		{strict_output_iterator<Iter, T> tmp(*this);
		tmp.state = postinc;
		if (state != ready || *pcnt == 0 || *pcnt != recno)
			*perr |= bad_postinc;
		if (0 < *pcnt)
			recno = *pcnt - 1;
		tmp.recno = recno, *pcnt = 0;
		return (tmp); }
private:
	Iter iter;	// full constructor only
	int *perr, *pcnt, recno;
	Iter *piter;
	State state;
	};
#endif  /* of ITER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t180.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"

#if IS_EMBEDDED
#define ONLY
#define CASE_181T21		Table 25: <cstddef> synopsis
#endif /* IS_EMBEDDED */

/* _181T21 Table 25: <cstddef> synopsis */
#if !defined(SKIP_181T21)&&(!defined(ONLY)||defined(CASE_181T21))
#include <cstddef>
#endif /* CASE_181T21 */

/* _1821T22 numeric_limits::is_specialized true for all specializations */
#if !defined(SKIP_1821T22)&&(!defined(ONLY)||defined(CASE_1821T22))
#include <limits>
#endif /* CASE_1821T22 */

/* _1821T31 non-scalar types shall not have specializations */
#if !defined(SKIP_1821T31)&&(!defined(ONLY)||defined(CASE_1821T31))
#include <complex>
#include <limits>
#endif /* CASE_1821T31 */

/* _1821T41 <limits> summary */
#if !defined(SKIP_1821T41)&&(!defined(ONLY)||defined(CASE_1821T41))
#include <limits>
#endif /* CASE_1821T41 */

/* _18211T01 numeric_limits definition */
#if !defined(SKIP_18211T01)&&(!defined(ONLY)||defined(CASE_18211T01))
#include <limits>
#endif /* CASE_18211T01 */

/* _18211T11 numeric_limits::is_specialized distinguishes specializations */
#if !defined(SKIP_18211T11)&&(!defined(ONLY)||defined(CASE_18211T11))
#include <limits>
class wrapper_18211T11 {
public:
    wrapper_18211T11(int v)
        : val(v) {};
    bool operator==(int v)
        {return (val == v); }
private:
    int val; };
#endif /* CASE_18211T11 */

/* _18211T21 radix, epsilon, and round_error meaningful for floating */
#if !defined(SKIP_18211T21)&&(!defined(ONLY)||defined(CASE_18211T21))
#include <cfloat>
#include <limits>
#endif /* CASE_18211T21 */

/* _18211T41 numeric_limits template shall have all members, with 0 values */
#if !defined(SKIP_18211T41)&&(!defined(ONLY)||defined(CASE_18211T41))
#include <climits>
#include <limits>
class wrapper_18211T41 {
public:
    wrapper_18211T41(int v)
        : val(v) {};
    bool operator==(int v)
        {return (val == v); }
private:
    int val; };
#endif /* CASE_18211T41 */

/* _18212T11 numeric_limits::min() */
#if !defined(SKIP_18212T11)&&(!defined(ONLY)||defined(CASE_18212T11))
#include <climits>
#include <cwchar>
#include <limits>
#endif /* CASE_18212T11 */

/* _18212T21 numeric_limits::denorm_min() */
#if !defined(SKIP_18212T21)&&(!defined(ONLY)||defined(CASE_18212T21))
#include <cfloat>
#include <limits>
#endif /* CASE_18212T21 */

/* _18212T31 numeric_limits::denorm_min() meaningful for is_bounded */
#if !defined(SKIP_18212T31)&&(!defined(ONLY)||defined(CASE_18212T31))
#include <limits>
#endif /* CASE_18212T31 */

/* _18212T41 numeric_limits::max() */
#if !defined(SKIP_18212T41)&&(!defined(ONLY)||defined(CASE_18212T41))
#include <cfloat>
#include <climits>
#include <cwchar>
#include <limits>
#endif /* CASE_18212T41 */

/* _18212T51 numeric_limits::max() meaningful for is_bounded */
#if !defined(SKIP_18212T51)&&(!defined(ONLY)||defined(CASE_18212T51))
#include <limits>
#endif /* CASE_18212T51 */

/* _18212T71 numeric_limits::digits for integer */
#if !defined(SKIP_18212T71)&&(!defined(ONLY)||defined(CASE_18212T71))
#include <climits>
#include <cwchar>
#include <limits>
#endif /* CASE_18212T71 */

/* _18212T81 numeric_limits::digits for floating */
#if !defined(SKIP_18212T81)&&(!defined(ONLY)||defined(CASE_18212T81))
#include <cfloat>
#include <limits>
#endif /* CASE_18212T81 */

/* _18212T91 numeric_limits::digits10 */
#if !defined(SKIP_18212T91)&&(!defined(ONLY)||defined(CASE_18212T91))
#include <cfloat>
#include <limits>
#endif /* CASE_18212T91 */

/* _18212T_101 numeric_limits::digits10 meaningful for is_bounded */
#if !defined(SKIP_18212T_101)&&(!defined(ONLY)||defined(CASE_18212T_101))
#include <limits>
#endif /* CASE_18212T_101 */

/* _18212T_111 numeric_limits::is_signed */
#if !defined(SKIP_18212T_111)&&(!defined(ONLY)||defined(CASE_18212T_111))
#include <climits>
#include <cwchar>
#include <limits>
#endif /* CASE_18212T_111 */

/* _18212T_131 numeric_limits::is_integer */
#if !defined(SKIP_18212T_131)&&(!defined(ONLY)||defined(CASE_18212T_131))
#include <limits>
#endif /* CASE_18212T_131 */

/* _18212T_141 numeric_limits::is_integer meaningful for all specializations */
#if !defined(SKIP_18212T_141)&&(!defined(ONLY)||defined(CASE_18212T_141))
#include <limits>
#endif /* CASE_18212T_141 */

/* _18212T_151 numeric_limits::is_exact */
#if !defined(SKIP_18212T_151)&&(!defined(ONLY)||defined(CASE_18212T_151))
#include <limits>
#endif /* CASE_18212T_151 */

/* _18212T_161 numeric_limits::is_exact meaningful for all specializations */
#if !defined(SKIP_18212T_161)&&(!defined(ONLY)||defined(CASE_18212T_161))
#include <limits>
#endif /* CASE_18212T_161 */

/* _18212T_171 numeric_limits::radix for floating_point types */
#if !defined(SKIP_18212T_171)&&(!defined(ONLY)||defined(CASE_18212T_171))
#include <cfloat>
#include <limits>
#endif /* CASE_18212T_171 */

/* _18212T_181 numeric_limits::radix for integer */
#if !defined(SKIP_18212T_181)&&(!defined(ONLY)||defined(CASE_18212T_181))
#include <limits>
#endif /* CASE_18212T_181 */

/* _18212T_201 numeric_limits::epsilon() */
#if !defined(SKIP_18212T_201)&&(!defined(ONLY)||defined(CASE_18212T_201))
#include <cfloat>
#include <limits>
#endif /* CASE_18212T_201 */

/* _18212T_211 numeric_limits::epsilon() meaningful only for floating */
#if !defined(SKIP_18212T_211)&&(!defined(ONLY)||defined(CASE_18212T_211))
#include <limits>
#endif /* CASE_18212T_211 */

int t180_main(int, char *[])
{
enter_chk("t180.cpp");
/* _181T21 Table 25: <cstddef> synopsis */
#if !defined(SKIP_181T21)&&(!defined(ONLY)||defined(CASE_181T21))
	begin_chk("_181T21");
	{
	struct x {char ch1, ch2; };
	ptrdiff_t pdiff; TOUCH(pdiff);
	size_t st = offsetof(x, ch2); TOUCH(st);
	void *pv = NULL; TOUCH(pv);
	chk(1);


	}
	end_chk("_181T21");
#else
	skip_chk("_181T21");
#endif /* CASE_181T21 */

/* _1821T22 numeric_limits::is_specialized true for all specializations */
#if !defined(SKIP_1821T22)&&(!defined(ONLY)||defined(CASE_1821T22))
	begin_chk("_1821T22");
	{
	chk(STD numeric_limits<bool>::is_specialized);
	chk(STD numeric_limits<char>::is_specialized);
	chk(STD numeric_limits<signed char>::is_specialized);
	chk(STD numeric_limits<unsigned char>::is_specialized);
	chk(STD numeric_limits<wchar_t>::is_specialized);
	chk(STD numeric_limits<short>::is_specialized);
	chk(STD numeric_limits<unsigned short>::is_specialized);
	chk(STD numeric_limits<int>::is_specialized);
	chk(STD numeric_limits<unsigned int>::is_specialized);
	chk(STD numeric_limits<long>::is_specialized);
	chk(STD numeric_limits<unsigned long>::is_specialized);
	chk(STD numeric_limits<float>::is_specialized);
	chk(STD numeric_limits<double>::is_specialized);
	chk(STD numeric_limits<long double>::is_specialized);


	}
	end_chk("_1821T22");
#else
	skip_chk("_1821T22");
#endif /* CASE_1821T22 */

/* _1821T31 non-scalar types shall not have specializations */
#if !defined(SKIP_1821T31)&&(!defined(ONLY)||defined(CASE_1821T31))
	begin_chk("_1821T31");
	{
	chk(!STD numeric_limits<STD complex<float> >::is_specialized);
	chk(!STD numeric_limits<STD complex<double> >::is_specialized);
	chk(!STD numeric_limits<STD complex<long double> >::is_specialized);




	}
	end_chk("_1821T31");
#else
	skip_chk("_1821T31");
#endif /* CASE_1821T31 */

/* _1821T41 <limits> summary */
#if !defined(SKIP_1821T41)&&(!defined(ONLY)||defined(CASE_1821T41))
	begin_chk("_1821T41");
	{
	STD float_round_style *p0; TOUCH(p0);
	STD float_denorm_style *p01; TOUCH(p01);	// ADDED [NOV97]
	STD numeric_limits<bool> *p1; TOUCH(p1);
	STD numeric_limits<char> *p2; TOUCH(p2);
	STD numeric_limits<signed char> *p3; TOUCH(p3);
	STD numeric_limits<unsigned char> *p4; TOUCH(p4);
	STD numeric_limits<wchar_t> *p5; TOUCH(p5);
	STD numeric_limits<short> *p6; TOUCH(p6);
	STD numeric_limits<unsigned short> *p7; TOUCH(p7);
	STD numeric_limits<int> *p8; TOUCH(p8);
	STD numeric_limits<unsigned int> *p9; TOUCH(p9);
	STD numeric_limits<long> *p10; TOUCH(p10);
	STD numeric_limits<unsigned long> *p11; TOUCH(p11);
	STD numeric_limits<float> *p12; TOUCH(p12);
	STD numeric_limits<double> *p13; TOUCH(p13);
	STD numeric_limits<long double> *p14; TOUCH(p14);
	chk(1);


	}
	end_chk("_1821T41");
#else
	skip_chk("_1821T41");
#endif /* CASE_1821T41 */

/* _18211T01 numeric_limits definition */
#if !defined(SKIP_18211T01)&&(!defined(ONLY)||defined(CASE_18211T01))
	begin_chk("_18211T01");
	{
	STD numeric_limits<void *> *px; TOUCH(px);
	chk(1);


	}
	end_chk("_18211T01");
#else
	skip_chk("_18211T01");
#endif /* CASE_18211T01 */

/* _18211T11 numeric_limits::is_specialized distinguishes specializations */
#if !defined(SKIP_18211T11)&&(!defined(ONLY)||defined(CASE_18211T11))
	begin_chk("_18211T11");
	{
	STD numeric_limits<wrapper_18211T11> x; TOUCH(x);
	chk(STD numeric_limits<int>::is_specialized && !x.is_specialized);



	}
	end_chk("_18211T11");
#else
	skip_chk("_18211T11");
#endif /* CASE_18211T11 */

/* _18211T21 radix, epsilon, and round_error meaningful for floating */
#if !defined(SKIP_18211T21)&&(!defined(ONLY)||defined(CASE_18211T21))
	begin_chk("_18211T21");
	{
	ieq(STD numeric_limits<float>::radix, FLT_RADIX);
	ieq(STD numeric_limits<double>::radix, FLT_RADIX);
	ieq(STD numeric_limits<long double>::radix, FLT_RADIX);
	chk(STD numeric_limits<float>::epsilon() == FLT_EPSILON);
	chk(STD numeric_limits<double>::epsilon() == DBL_EPSILON);
	chk(STD numeric_limits<long double>::epsilon() == LDBL_EPSILON);
	chk(0 < STD numeric_limits<float>::round_error());
	chk(0 < STD numeric_limits<double>::round_error());
	chk(0 < STD numeric_limits<long double>::round_error());





	}
	end_chk("_18211T21");
#else
	skip_chk("_18211T21");
#endif /* CASE_18211T21 */

/* _18211T41 numeric_limits template shall have all members, with 0 values */
#if !defined(SKIP_18211T41)&&(!defined(ONLY)||defined(CASE_18211T41))
	begin_chk("_18211T41");
	{
	typedef STD numeric_limits<wrapper_18211T41> myty;
	myty x; TOUCH(x);
	chk(!x.is_specialized);
	chk(x.min() == 0);
	chk(x.max() == 0);
	ieq(x.digits, 0);
	ieq(x.digits10, 0);
	chk(!x.is_signed);
	chk(!x.is_integer);
	chk(!x.is_exact);
	ieq(x.radix, 0);
	chk(x.epsilon() == 0);
	chk(x.round_error() == 0);
	ieq(x.min_exponent, 0);
	ieq(x.min_exponent10, 0);
	ieq(x.max_exponent, 0);
	ieq(x.max_exponent10, 0);
	chk(!x.has_infinity);
	chk(!x.has_quiet_NaN);
	chk(!x.has_signaling_NaN);
	chk(x.has_denorm == STD denorm_absent);	// CHANGED [NOV97]
	chk(!x.has_denorm_loss);
	chk(x.infinity() == 0);
	chk(x.quiet_NaN() == 0);
	chk(x.signaling_NaN() == 0);
	chk(x.denorm_min() == 0);
	chk(!x.is_iec559);
	chk(!x.is_bounded);
	chk(!x.is_modulo);
	chk(!x.traps);
	chk(!x.tinyness_before);
	chk(x.round_style == STD round_toward_zero);
	switch (1) {case myty::is_specialized: break; }	// added [JUL96]
	switch (1) {case myty::digits: break; }	// added [JUL96]
	switch (1) {case myty::digits10: break; }	// added [JUL96]
	switch (1) {case myty::is_signed: break; }	// added [JUL96]
	switch (1) {case myty::is_integer: break; }	// added [JUL96]
	switch (1) {case myty::is_exact: break; }	// added [JUL96]
	switch (1) {case myty::radix: break; }	// added [JUL96]
	switch (1) {case myty::min_exponent: break; }	// added [JUL96]
	switch (1) {case myty::min_exponent10: break; }	// added [JUL96]
	switch (1) {case myty::max_exponent: break; }	// added [JUL96]
	switch (1) {case myty::max_exponent10: break; }	// added [JUL96]
	switch (1) {case myty::has_infinity: break; }	// added [JUL96]
	switch (1) {case myty::has_quiet_NaN: break; }	// added [JUL96]
	switch (1) {case myty::has_signaling_NaN: break; }	// added [JUL96]
	switch (1) {case myty::has_denorm: break; }	// added [JUL96]
	switch (1) {case myty::has_denorm_loss: break; }	// added [JUL96]
	switch (1) {case myty::is_iec559: break; }	// added [JUL96]
	switch (1) {case myty::is_bounded: break; }	// added [JUL96]
	switch (1) {case myty::is_modulo: break; }	// added [JUL96]
	switch (1) {case myty::traps: break; }	// added [JUL96]
	switch (1) {case myty::tinyness_before: break; }	// added [JUL96]
	switch (1) {case myty::round_style: break; }	// added [JUL96]


	}
	end_chk("_18211T41");
#else
	skip_chk("_18211T41");
#endif /* CASE_18211T41 */

/* _18212T11 numeric_limits::min() */
#if !defined(SKIP_18212T11)&&(!defined(ONLY)||defined(CASE_18212T11))
	begin_chk("_18212T11");
	{
	chk(STD numeric_limits<Bool>::min() == false);
	chk(STD numeric_limits<char>::min() == CHAR_MIN);
	chk(STD numeric_limits<signed char>::min() == SCHAR_MIN);
	chk(STD numeric_limits<unsigned char>::min() == 0);
	chk(STD numeric_limits<wchar_t>::min() == WCHAR_MIN);
	chk(STD numeric_limits<short>::min() == SHRT_MIN);
	chk(STD numeric_limits<unsigned short>::min() == 0);
	chk(STD numeric_limits<int>::min() == INT_MIN);
	chk(STD numeric_limits<unsigned int>::min() == 0);
	chk(STD numeric_limits<long>::min() == LONG_MIN);
	chk(STD numeric_limits<unsigned long>::min() == 0);



	}
	end_chk("_18212T11");
#else
	skip_chk("_18212T11");
#endif /* CASE_18212T11 */

/* _18212T21 numeric_limits::denorm_min() */
#if !defined(SKIP_18212T21)&&(!defined(ONLY)||defined(CASE_18212T21))
	begin_chk("_18212T21");
	{
	chk(STD numeric_limits<float>::min() == FLT_MIN);
	chk(STD numeric_limits<double>::min() == DBL_MIN);
	chk(STD numeric_limits<long double>::min() == LDBL_MIN);


	}
	end_chk("_18212T21");
#else
	skip_chk("_18212T21");
#endif /* CASE_18212T21 */

/* _18212T31 numeric_limits::denorm_min() meaningful for is_bounded */
#if !defined(SKIP_18212T31)&&(!defined(ONLY)||defined(CASE_18212T31))
	begin_chk("_18212T31");
	{
	chk((STD numeric_limits<signed char>::is_bounded
	    || !STD numeric_limits<signed char>::is_signed)
	        && STD numeric_limits<signed char>::min() < 0);
	chk((STD numeric_limits<short>::is_bounded
	    || !STD numeric_limits<short>::is_signed)
	        && STD numeric_limits<short>::min() < 0);
	chk((STD numeric_limits<int>::is_bounded
	    || !STD numeric_limits<int>::is_signed)
	        && STD numeric_limits<int>::min() < 0);
	chk((STD numeric_limits<long>::is_bounded
	    || !STD numeric_limits<long>::is_signed)
	        && STD numeric_limits<long>::min() < 0);
	chk((STD numeric_limits<float>::is_bounded
	    || !STD numeric_limits<float>::is_signed)
	        && STD numeric_limits<float>::min() != 0);
	chk((STD numeric_limits<double>::is_bounded
	    || !STD numeric_limits<double>::is_signed)
	        && STD numeric_limits<double>::min() != 0);
	chk((STD numeric_limits<long double>::is_bounded
	    || !STD numeric_limits<long double>::is_signed)
	        && STD numeric_limits<long double>::min() != 0);


	}
	end_chk("_18212T31");
#else
	skip_chk("_18212T31");
#endif /* CASE_18212T31 */

/* _18212T41 numeric_limits::max() */
#if !defined(SKIP_18212T41)&&(!defined(ONLY)||defined(CASE_18212T41))
	begin_chk("_18212T41");
	{
	chk(STD numeric_limits<Bool>::max() == true);
	chk(STD numeric_limits<char>::max() == CHAR_MAX);
	chk(STD numeric_limits<signed char>::max() == SCHAR_MAX);
	chk(STD numeric_limits<unsigned char>::max() == UCHAR_MAX);
	chk(STD numeric_limits<wchar_t>::max() == WCHAR_MAX);
	chk(STD numeric_limits<short>::max() == SHRT_MAX);
	chk(STD numeric_limits<unsigned short>::max() == USHRT_MAX);
	chk(STD numeric_limits<int>::max() == INT_MAX);
	chk(STD numeric_limits<unsigned int>::max() == UINT_MAX);
	chk(STD numeric_limits<long>::max() == LONG_MAX);
	chk(STD numeric_limits<unsigned long>::max() == ULONG_MAX);
	chk(STD numeric_limits<float>::max() == FLT_MAX);
	chk(STD numeric_limits<double>::max() == DBL_MAX);
	chk(STD numeric_limits<long double>::max() == LDBL_MAX);


	}
	end_chk("_18212T41");
#else
	skip_chk("_18212T41");
#endif /* CASE_18212T41 */

/* _18212T51 numeric_limits::max() meaningful for is_bounded */
#if !defined(SKIP_18212T51)&&(!defined(ONLY)||defined(CASE_18212T51))
	begin_chk("_18212T51");
	{
	chk(STD numeric_limits<bool>::is_bounded
	    && STD numeric_limits<bool>::max() != false);
	chk(STD numeric_limits<char>::is_bounded
	    && 0 < STD numeric_limits<char>::max());
	chk(STD numeric_limits<signed char>::is_bounded
	    && 0 < STD numeric_limits<signed char>::max());
	chk(STD numeric_limits<unsigned char>::is_bounded
	    && 0 < STD numeric_limits<unsigned char>::max());
	chk(STD numeric_limits<wchar_t>::is_bounded
	    && 0 < STD numeric_limits<wchar_t>::max());
	chk(STD numeric_limits<short>::is_bounded
	    && 0 < STD numeric_limits<short>::max());
	chk(STD numeric_limits<unsigned short>::is_bounded
	    && 0 < STD numeric_limits<unsigned short>::max());
	chk(STD numeric_limits<int>::is_bounded
	    && 0 < STD numeric_limits<int>::max());
	chk(STD numeric_limits<unsigned int>::is_bounded
	    && 0 < STD numeric_limits<unsigned int>::max());
	chk(STD numeric_limits<long>::is_bounded
	    && 0 < STD numeric_limits<long>::max());
	chk(STD numeric_limits<unsigned long>::is_bounded
	    && 0 < STD numeric_limits<unsigned long>::max());
	chk(STD numeric_limits<float>::is_bounded
	    && 0 < STD numeric_limits<float>::max());
	chk(STD numeric_limits<double>::is_bounded
	    && 0 < STD numeric_limits<double>::max());
	chk(STD numeric_limits<long double>::is_bounded
	    && 0 < STD numeric_limits<long double>::max());


	}
	end_chk("_18212T51");
#else
	skip_chk("_18212T51");
#endif /* CASE_18212T51 */

/* _18212T71 numeric_limits::digits for integer */
#if !defined(SKIP_18212T71)&&(!defined(ONLY)||defined(CASE_18212T71))
	begin_chk("_18212T71");
	{
	ieq(STD numeric_limits<Bool>::digits, 1);
	ieq(STD numeric_limits<char>::digits, CHAR_BIT - (CHAR_MIN < 0 ? 1 :
	0));
	ieq(STD numeric_limits<signed char>::digits, CHAR_BIT - 1);
	ieq(STD numeric_limits<unsigned char>::digits, CHAR_BIT);
	ieq(STD numeric_limits<wchar_t>::digits,
	    CHAR_BIT * sizeof (wchar_t) - (WCHAR_MIN < 0 ? 1 : 0));
	ieq(STD numeric_limits<short>::digits, CHAR_BIT * sizeof (short) -
	1);
	ieq(STD numeric_limits<unsigned short>::digits,
	    STD numeric_limits<short>::digits + 1);
	ieq(STD numeric_limits<int>::digits, CHAR_BIT * sizeof (int) - 1);
	ieq(STD numeric_limits<unsigned int>::digits,
	    STD numeric_limits<int>::digits + 1);
	ieq(STD numeric_limits<long>::digits, CHAR_BIT * sizeof (long) - 1);
	ieq(STD numeric_limits<unsigned long>::digits,
	    STD numeric_limits<long>::digits + 1);


	}
	end_chk("_18212T71");
#else
	skip_chk("_18212T71");
#endif /* CASE_18212T71 */

/* _18212T81 numeric_limits::digits for floating */
#if !defined(SKIP_18212T81)&&(!defined(ONLY)||defined(CASE_18212T81))
	begin_chk("_18212T81");
	{
	ieq(STD numeric_limits<float>::digits, FLT_MANT_DIG);
	ieq(STD numeric_limits<double>::digits, DBL_MANT_DIG);
	ieq(STD numeric_limits<long double>::digits, LDBL_MANT_DIG);


	}
	end_chk("_18212T81");
#else
	skip_chk("_18212T81");
#endif /* CASE_18212T81 */

/* _18212T91 numeric_limits::digits10 */
#if !defined(SKIP_18212T91)&&(!defined(ONLY)||defined(CASE_18212T91))
	begin_chk("_18212T91");
	{
	const float LOG2 = (float)0.30103;
	ieq((int)(LOG2 * (int)STD numeric_limits<bool>::digits),
	    STD numeric_limits<bool>::digits10);
	ieq((int)(LOG2 * (int)STD numeric_limits<char>::digits),
	    STD numeric_limits<char>::digits10);
	ieq((int)(LOG2 * (int)STD numeric_limits<signed char>::digits),
	    STD numeric_limits<signed char>::digits10);
	ieq((int)(LOG2 * (int)STD numeric_limits<unsigned char>::digits),
	    STD numeric_limits<unsigned char>::digits10);
	ieq((int)(LOG2 * (int)STD numeric_limits<wchar_t>::digits),
	    STD numeric_limits<wchar_t>::digits10);
	ieq((int)(LOG2 * (int)STD numeric_limits<short>::digits),
	    STD numeric_limits<short>::digits10);
	ieq((int)(LOG2 * (int)STD numeric_limits<unsigned short>::digits),
	    STD numeric_limits<unsigned short>::digits10);
	ieq((int)(LOG2 * (int)STD numeric_limits<int>::digits),
	    STD numeric_limits<int>::digits10);
	ieq((int)(LOG2 * (int)STD numeric_limits<unsigned int>::digits),
	    STD numeric_limits<unsigned int>::digits10);
	ieq((int)(LOG2 * (int)STD numeric_limits<long>::digits),
	    STD numeric_limits<long>::digits10);
	ieq((int)(LOG2 * (int)STD numeric_limits<unsigned long>::digits),
	    STD numeric_limits<unsigned long>::digits10);
	ieq(STD numeric_limits<float>::digits10, FLT_DIG);
	ieq(STD numeric_limits<double>::digits10, DBL_DIG);
	ieq(STD numeric_limits<long double>::digits10, LDBL_DIG);


	}
	end_chk("_18212T91");
#else
	skip_chk("_18212T91");
#endif /* CASE_18212T91 */

/* _18212T_101 numeric_limits::digits10 meaningful for is_bounded */
#if !defined(SKIP_18212T_101)&&(!defined(ONLY)||defined(CASE_18212T_101))
	begin_chk("_18212T_101");
	{
	chk(STD numeric_limits<char>::is_bounded
	    && 0 < STD numeric_limits<char>::digits10);
	chk(STD numeric_limits<signed char>::is_bounded
	    && 0 < STD numeric_limits<signed char>::digits10);
	chk(STD numeric_limits<unsigned char>::is_bounded
	    && 0 < STD numeric_limits<unsigned char>::digits10);
	chk(STD numeric_limits<wchar_t>::is_bounded
	    && 0 < STD numeric_limits<wchar_t>::digits10);
	chk(STD numeric_limits<short>::is_bounded
	    && 0 < STD numeric_limits<short>::digits10);
	chk(STD numeric_limits<unsigned short>::is_bounded
	    && 0 < STD numeric_limits<unsigned short>::digits10);
	chk(STD numeric_limits<int>::is_bounded
	    && 0 < STD numeric_limits<int>::digits10);
	chk(STD numeric_limits<unsigned int>::is_bounded
	    && 0 < STD numeric_limits<unsigned int>::digits10);
	chk(STD numeric_limits<long>::is_bounded
	    && 0 < STD numeric_limits<long>::digits10);
	chk(STD numeric_limits<unsigned long>::is_bounded
	    && 0 < STD numeric_limits<unsigned long>::digits10);
	chk(STD numeric_limits<float>::is_bounded
	    && 0 < STD numeric_limits<float>::digits10);
	chk(STD numeric_limits<double>::is_bounded
	    && 0 < STD numeric_limits<double>::digits10);
	chk(STD numeric_limits<long double>::is_bounded
	    && 0 < STD numeric_limits<long double>::digits10);


	}
	end_chk("_18212T_101");
#else
	skip_chk("_18212T_101");
#endif /* CASE_18212T_101 */

/* _18212T_111 numeric_limits::is_signed */
#if !defined(SKIP_18212T_111)&&(!defined(ONLY)||defined(CASE_18212T_111))
	begin_chk("_18212T_111");
	{
	chk(!STD numeric_limits<Bool>::is_signed);
	chk(STD numeric_limits<char>::is_signed && CHAR_MIN < 0
	    || !STD numeric_limits<char>::is_signed && CHAR_MIN == 0);
	chk(STD numeric_limits<signed char>::is_signed);
	chk(!STD numeric_limits<unsigned char>::is_signed);
	chk(STD numeric_limits<wchar_t>::is_signed && WCHAR_MIN < 0
	    || !STD numeric_limits<wchar_t>::is_signed && WCHAR_MIN == 0);
	chk(STD numeric_limits<short>::is_signed);
	chk(!STD numeric_limits<unsigned short>::is_signed);
	chk(STD numeric_limits<int>::is_signed);
	chk(!STD numeric_limits<unsigned int>::is_signed);
	chk(STD numeric_limits<long>::is_signed);
	chk(!STD numeric_limits<unsigned long>::is_signed);
	chk(STD numeric_limits<float>::is_signed);
	chk(STD numeric_limits<double>::is_signed);
	chk(STD numeric_limits<long double>::is_signed);


	}
	end_chk("_18212T_111");
#else
	skip_chk("_18212T_111");
#endif /* CASE_18212T_111 */

/* _18212T_131 numeric_limits::is_integer */
#if !defined(SKIP_18212T_131)&&(!defined(ONLY)||defined(CASE_18212T_131))
	begin_chk("_18212T_131");
	{
	chk(STD numeric_limits<bool>::is_integer);
	chk(STD numeric_limits<char>::is_integer);
	chk(STD numeric_limits<signed char>::is_integer);
	chk(STD numeric_limits<unsigned char>::is_integer);
	chk(STD numeric_limits<wchar_t>::is_integer);
	chk(STD numeric_limits<short>::is_integer);
	chk(STD numeric_limits<unsigned short>::is_integer);
	chk(STD numeric_limits<int>::is_integer);
	chk(STD numeric_limits<unsigned int>::is_integer);
	chk(STD numeric_limits<long>::is_integer);
	chk(STD numeric_limits<unsigned long>::is_integer);


	}
	end_chk("_18212T_131");
#else
	skip_chk("_18212T_131");
#endif /* CASE_18212T_131 */

/* _18212T_141 numeric_limits::is_integer meaningful for all specializations */
#if !defined(SKIP_18212T_141)&&(!defined(ONLY)||defined(CASE_18212T_141))
	begin_chk("_18212T_141");
	{
	chk(!STD numeric_limits<float>::is_integer);
	chk(!STD numeric_limits<double>::is_integer);
	chk(!STD numeric_limits<long double>::is_integer);


	}
	end_chk("_18212T_141");
#else
	skip_chk("_18212T_141");
#endif /* CASE_18212T_141 */

/* _18212T_151 numeric_limits::is_exact */
#if !defined(SKIP_18212T_151)&&(!defined(ONLY)||defined(CASE_18212T_151))
	begin_chk("_18212T_151");
	{
	chk(STD numeric_limits<bool>::is_exact);
	chk(STD numeric_limits<char>::is_exact);
	chk(STD numeric_limits<signed char>::is_exact);
	chk(STD numeric_limits<unsigned char>::is_exact);
	chk(STD numeric_limits<wchar_t>::is_exact);
	chk(STD numeric_limits<short>::is_exact);
	chk(STD numeric_limits<unsigned short>::is_exact);
	chk(STD numeric_limits<int>::is_exact);
	chk(STD numeric_limits<unsigned int>::is_exact);
	chk(STD numeric_limits<long>::is_exact);
	chk(STD numeric_limits<unsigned long>::is_exact);


	}
	end_chk("_18212T_151");
#else
	skip_chk("_18212T_151");
#endif /* CASE_18212T_151 */

/* _18212T_161 numeric_limits::is_exact meaningful for all specializations */
#if !defined(SKIP_18212T_161)&&(!defined(ONLY)||defined(CASE_18212T_161))
	begin_chk("_18212T_161");
	{
	chk(!STD numeric_limits<float>::is_exact);
	chk(!STD numeric_limits<double>::is_exact);
	chk(!STD numeric_limits<long double>::is_exact);

	//

	}
	end_chk("_18212T_161");
#else
	skip_chk("_18212T_161");
#endif /* CASE_18212T_161 */

/* _18212T_171 numeric_limits::radix for floating_point types */
#if !defined(SKIP_18212T_171)&&(!defined(ONLY)||defined(CASE_18212T_171))
	begin_chk("_18212T_171");
	{
	ieq(STD numeric_limits<float>::radix, FLT_RADIX);
	ieq(STD numeric_limits<double>::radix, FLT_RADIX);
	ieq(STD numeric_limits<long double>::radix, FLT_RADIX);


	}
	end_chk("_18212T_171");
#else
	skip_chk("_18212T_171");
#endif /* CASE_18212T_171 */

/* _18212T_181 numeric_limits::radix for integer */
#if !defined(SKIP_18212T_181)&&(!defined(ONLY)||defined(CASE_18212T_181))
	begin_chk("_18212T_181");
	{
	ieq(STD numeric_limits<bool>::radix, 2);
	ieq(STD numeric_limits<char>::radix, 2);
	ieq(STD numeric_limits<signed char>::radix, 2);
	ieq(STD numeric_limits<unsigned char>::radix, 2);
	ieq(STD numeric_limits<wchar_t>::radix, 2);
	ieq(STD numeric_limits<short>::radix, 2);
	ieq(STD numeric_limits<unsigned short>::radix, 2);
	ieq(STD numeric_limits<int>::radix, 2);
	ieq(STD numeric_limits<unsigned int>::radix, 2);
	ieq(STD numeric_limits<long>::radix, 2);
	ieq(STD numeric_limits<unsigned long>::radix, 2);


	}
	end_chk("_18212T_181");
#else
	skip_chk("_18212T_181");
#endif /* CASE_18212T_181 */

/* _18212T_201 numeric_limits::epsilon() */
#if !defined(SKIP_18212T_201)&&(!defined(ONLY)||defined(CASE_18212T_201))
	begin_chk("_18212T_201");
	{
	chk(STD numeric_limits<float>::epsilon() == FLT_EPSILON);
	chk(STD numeric_limits<double>::epsilon() == DBL_EPSILON);
	chk(STD numeric_limits<long double>::epsilon() == LDBL_EPSILON);


	}
	end_chk("_18212T_201");
#else
	skip_chk("_18212T_201");
#endif /* CASE_18212T_201 */

/* _18212T_211 numeric_limits::epsilon() meaningful only for floating */
#if !defined(SKIP_18212T_211)&&(!defined(ONLY)||defined(CASE_18212T_211))
	begin_chk("_18212T_211");
	{
	chk(STD numeric_limits<bool>::epsilon() == 0);
	chk(STD numeric_limits<char>::epsilon() == 0);
	chk(STD numeric_limits<signed char>::epsilon() == 0);
	chk(STD numeric_limits<unsigned char>::epsilon() == 0);
	chk(STD numeric_limits<wchar_t>::epsilon() == 0);
	chk(STD numeric_limits<short>::epsilon() == 0);
	chk(STD numeric_limits<unsigned short>::epsilon() == 0);
	chk(STD numeric_limits<int>::epsilon() == 0);
	chk(STD numeric_limits<unsigned int>::epsilon() == 0);
	chk(STD numeric_limits<long>::epsilon() == 0);
	chk(STD numeric_limits<unsigned long>::epsilon() == 0);
	}
	end_chk("_18212T_211");
#else
	skip_chk("_18212T_211");
#endif /* CASE_18212T_211 */

return leave_chk("t180");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t182.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _1822T21 Table 26: <climits> synopsis */
#if !defined(SKIP_1822T21)&&(!defined(ONLY)||defined(CASE_1822T21))
#include <climits>
#endif /* CASE_1822T21 */

/* _1822T41 Table 27: <cfloat> synopsis */
#if !defined(SKIP_1822T41)&&(!defined(ONLY)||defined(CASE_1822T41))
#include <cfloat>
#endif /* CASE_1822T41 */

/* _183T21 Table 28: <cstdlib> synopsis */
#if !defined(SKIP_183T21)&&(!defined(ONLY)||defined(CASE_183T21))
#include <cstdlib>
#endif /* CASE_183T21 */

/* _183T48 exit(EXIT_FAILURE) reports unsuccessful termination */
#if !defined(SKIP_183T48)&&(!defined(ONLY)||defined(CASE_183T48))
#include <cstdlib>
#endif /* CASE_183T48 */

/* _184T31 <new> synopsis */
#if !defined(SKIP_184T31)&&(!defined(ONLY)||defined(CASE_184T31))
#include <cstdlib>
#if DISALLOW_USER_NAME_PROTECTION
 #include <new>
#else
	#define xalloc	"xalloc"	/* looking for trouble */
 #include <new>
	#undef xalloc
#endif
static void newh_184T31()
	{}
#endif /* CASE_184T31 */

/* _18411T11 new(size_t) effects */
#if !defined(SKIP_18411T11)&&(!defined(ONLY)||defined(CASE_18411T11))
#include <new>
#endif /* CASE_18411T11 */

/* _18411T44 new(size_t) returns pointer on success */
#if !defined(SKIP_18411T44)&&(!defined(ONLY)||defined(CASE_18411T44))
#include <new>
#endif /* CASE_18411T44 */

/* _18411T51 new(size_t, const nothrow&) returns null, doesn't throw */
#if !defined(SKIP_18411T51)&&(!defined(ONLY)||defined(CASE_18411T51))
#include <new>
#endif /* CASE_18411T51 */

/* _18411T91 delete(void *) effects */
#if !defined(SKIP_18411T91)&&(!defined(ONLY)||defined(CASE_18411T91))
#include <new>
#endif /* CASE_18411T91 */

/* _18411T_121 delete(void *) does nothing with null argument */
#if !defined(SKIP_18411T_121)&&(!defined(ONLY)||defined(CASE_18411T_121))
#include <new>
#endif /* CASE_18411T_121 */

/* _18411T_131 delete(void *) reclaims storage from earlier new call */
#if !defined(SKIP_18411T_131)&&(!defined(ONLY)||defined(CASE_18411T_131))
#include <new>
#endif /* CASE_18411T_131 */

/* _18412T11 new[](size_t) called by array new expression */
#if !defined(SKIP_18412T11)&&(!defined(ONLY)||defined(CASE_18412T11))
#include <new>
#endif /* CASE_18412T11 */

/* _18412T61 new[](size_t, const nothrow&) effects */
#if !defined(SKIP_18412T61)&&(!defined(ONLY)||defined(CASE_18412T61))
#include <new>
#endif /* CASE_18412T61 */

/* _18412T_111 delete[](void *) effects */
#if !defined(SKIP_18412T_111)&&(!defined(ONLY)||defined(CASE_18412T_111))
#include <new>
#endif /* CASE_18412T_111 */

/* _18412T_141 delete[](void *) does nothing with null argument */
#if !defined(SKIP_18412T_141)&&(!defined(ONLY)||defined(CASE_18412T_141))
#include <new>
#endif /* CASE_18412T_141 */

/* _18412T_152 delete[](void *) reclaims storage from new[] */
#if !defined(SKIP_18412T_152)&&(!defined(ONLY)||defined(CASE_18412T_152))
#include <new>
#endif /* CASE_18412T_152 */

/* _18413T13 new(size_t, void *) returns */
#if !defined(SKIP_18413T13)&&(!defined(ONLY)||defined(CASE_18413T13))
#include <new>
#endif /* CASE_18413T13 */

/* _18413T51 new[](size_t, void *) returns */
#if !defined(SKIP_18413T51)&&(!defined(ONLY)||defined(CASE_18413T51))
#include <new>
#endif /* CASE_18413T51 */

/* _18413T81 delete(void *, void *) effects */
#if !defined(SKIP_18413T81)&&(!defined(ONLY)||defined(CASE_18413T81))
#include <new>
#endif /* CASE_18413T81 */

/* _18413T_111 delete[](void *, void *) effects */
#if !defined(SKIP_18413T_111)&&(!defined(ONLY)||defined(CASE_18413T_111))
#include <new>
#endif /* CASE_18413T_111 */

int t182_main(int, char *[])
{
enter_chk("t182.cpp");
/* _1822T21 Table 26: <climits> synopsis */
#if !defined(SKIP_1822T21)&&(!defined(ONLY)||defined(CASE_1822T21))
	begin_chk("_1822T21");
	{
	static int char_bit = CHAR_BIT;
	static char char_max = CHAR_MAX;
	static char char_min = CHAR_MIN;
	static int int_max = INT_MAX;
	static int int_min = INT_MIN;
	static long long_max = LONG_MAX;
	static long long_min = LONG_MIN;
	static int mb_len_max = MB_LEN_MAX;
	static signed char schar_max = SCHAR_MAX;
	static signed char schar_min = SCHAR_MIN;
	static short shrt_max = SHRT_MAX;
	static short shrt_min = SHRT_MIN;
	static unsigned char uchar_max = UCHAR_MAX;
	static unsigned int uint_max = UINT_MAX;
	static unsigned long ulong_max = ULONG_MAX;
	static unsigned short ushrt_max = USHRT_MAX;
	ieq(char_bit, CHAR_BIT);
	chk(char_max == CHAR_MAX);
	chk(char_min == CHAR_MIN);
	ieq(int_max, INT_MAX);
	ieq(int_min, INT_MIN);
	leq(long_max, LONG_MAX);
	leq(long_min, LONG_MIN);
	ieq(mb_len_max, MB_LEN_MAX);
	ieq(schar_max, SCHAR_MAX);
	ieq(schar_min, SCHAR_MIN);
	ieq(shrt_max, SHRT_MAX);
	ieq(shrt_min, SHRT_MIN);
	chk(uchar_max == UCHAR_MAX);
	chk(uint_max == UINT_MAX);
	chk(ulong_max == ULONG_MAX);
	chk(ushrt_max == USHRT_MAX);


	}
	end_chk("_1822T21");
#else
	skip_chk("_1822T21");
#endif /* CASE_1822T21 */

/* _1822T41 Table 27: <cfloat> synopsis */
#if !defined(SKIP_1822T41)&&(!defined(ONLY)||defined(CASE_1822T41))
	begin_chk("_1822T41");
	{
	int flt_radix = FLT_RADIX;
	ieq(flt_radix, FLT_RADIX);
	//	double properties
	int dbl_dig = DBL_DIG;
	double dbl_epsilon = DBL_EPSILON;
	int dbl_mant_dig = DBL_MANT_DIG;
	double dbl_max = DBL_MAX;
	int dbl_max_10_exp = DBL_MAX_10_EXP;
	int dbl_max_exp = DBL_MAX_EXP;
	double dbl_min = DBL_MIN;
	int dbl_min_10_exp = DBL_MIN_10_EXP;
	int dbl_min_exp = DBL_MIN_EXP;
	ieq(dbl_dig, DBL_DIG);
	chk(dbl_epsilon == DBL_EPSILON);
	ieq(dbl_mant_dig, DBL_MANT_DIG);
	chk(dbl_max == DBL_MAX);
	ieq(dbl_max_10_exp, DBL_MAX_10_EXP);
	ieq(dbl_max_exp, DBL_MAX_EXP);
	chk(dbl_min == DBL_MIN);
	ieq(dbl_min_10_exp, DBL_MIN_10_EXP);
	ieq(dbl_min_exp, DBL_MIN_EXP);
	// float properties
	int flt_dig = FLT_DIG;
	float flt_epsilon = FLT_EPSILON;
	int flt_mant_dig = FLT_MANT_DIG;
	float flt_max = FLT_MAX;
	int flt_max_10_exp = FLT_MAX_10_EXP;
	int flt_max_exp = FLT_MAX_EXP;
	float flt_min = FLT_MIN;
	int flt_min_10_exp = FLT_MIN_10_EXP;
	int flt_min_exp = FLT_MIN_EXP;
	ieq(flt_dig, FLT_DIG);
	chk(flt_epsilon == FLT_EPSILON);
	ieq(flt_mant_dig, FLT_MANT_DIG);
	chk(flt_max == FLT_MAX);
	ieq(flt_max_10_exp, FLT_MAX_10_EXP);
	ieq(flt_max_exp, FLT_MAX_EXP);
	chk(flt_min == FLT_MIN);
	ieq(flt_min_10_exp, FLT_MIN_10_EXP);
	ieq(flt_min_exp, FLT_MIN_EXP);
	// long double properties
	int ldbl_dig = LDBL_DIG;
	long double ldbl_epsilon = LDBL_EPSILON;
	int ldbl_mant_dig = LDBL_MANT_DIG;
	long double ldbl_max = LDBL_MAX;
	int ldbl_max_10_exp = LDBL_MAX_10_EXP;
	int ldbl_max_exp = LDBL_MAX_EXP;
	long double ldbl_min = LDBL_MIN;
	int ldbl_min_10_exp = LDBL_MIN_10_EXP;
	int ldbl_min_exp = LDBL_MIN_EXP;
	ieq(ldbl_dig, LDBL_DIG);
	chk(ldbl_epsilon == LDBL_EPSILON);
	ieq(ldbl_mant_dig, LDBL_MANT_DIG);
	chk(ldbl_max == LDBL_MAX);
	ieq(ldbl_max_10_exp, LDBL_MAX_10_EXP);
	ieq(ldbl_max_exp, LDBL_MAX_EXP);
	chk(ldbl_min == LDBL_MIN);
	ieq(ldbl_min_10_exp, LDBL_MIN_10_EXP);
	ieq(ldbl_min_exp, LDBL_MIN_EXP);


	}
	end_chk("_1822T41");
#else
	skip_chk("_1822T41");
#endif /* CASE_1822T41 */

/* _183T21 Table 28: <cstdlib> synopsis */
#if !defined(SKIP_183T21)&&(!defined(ONLY)||defined(CASE_183T21))
	begin_chk("_183T21");
	{
	int zero = 0;
	if (zero)
		{	// never called
		abort();
		atexit(&abort);
		exit(0); }
	int fail = EXIT_FAILURE;
	int suc = EXIT_SUCCESS;
	ieq(fail, EXIT_FAILURE);
	ieq(suc, EXIT_SUCCESS);


	}
	end_chk("_183T21");
#else
	skip_chk("_183T21");
#endif /* CASE_183T21 */

/* _183T48 exit(EXIT_FAILURE) reports unsuccessful termination */
#if !defined(SKIP_183T48)&&(!defined(ONLY)||defined(CASE_183T48))
	begin_chk("_183T48");
	{
	chk(EXIT_SUCCESS != EXIT_FAILURE);


	}
	end_chk("_183T48");
#else
	skip_chk("_183T48");
#endif /* CASE_183T48 */

/* _184T31 <new> synopsis */
#if !defined(SKIP_184T31)&&(!defined(ONLY)||defined(CASE_184T31))
	begin_chk("_184T31");
	{
	STD nothrow_t nt;
	void *pv = operator new(sizeof (float));
	operator delete(pv);
	pv = operator new(sizeof (float), nt);
	operator delete(pv);
	#if !DISALLOW_ARRAY_NEW_DELETE
		pv = operator new[](10 * sizeof (float));
		operator delete[](pv);
		pv = operator new[](10 * sizeof (float), nt);
		operator delete[](pv);
		float fl;
		pv = operator new(sizeof (float), &fl);
		pv = operator new[](sizeof (float), &fl);
	#endif
	#if !DISALLOW_PLACEMENT_DELETE
		operator delete(pv, pv);
		operator delete[](pv, pv);
		pv = operator new(sizeof (float), nt);	// added [NOV95]
		operator delete(pv, nt);
		pv = operator new[](10 * sizeof (float), nt);
		operator delete(pv, nt);
	#endif
	STD new_handler ph = STD set_new_handler(&newh_184T31);
	STD set_new_handler(ph);
	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	STD bad_alloc ex;
	#endif /* IS_EMBEDDED */
	chk(1);


	}
	end_chk("_184T31");
#else
	skip_chk("_184T31");
#endif /* CASE_184T31 */

/* _18411T11 new(size_t) effects */
#if !defined(SKIP_18411T11)&&(!defined(ONLY)||defined(CASE_18411T11))
	begin_chk("_18411T11");
	{
	void *pv = operator new(sizeof (long double));
	chk(pv != 0);
	if (pv != 0)
		{long double *pld = (long double *)pv;
		*pld = 21.5L;
		ldeq(*pld, 21.5L); }
	operator delete(pv);


	}
	end_chk("_18411T11");
#else
	skip_chk("_18411T11");
#endif /* CASE_18411T11 */

/* _18411T44 new(size_t) returns pointer on success */
#if !defined(SKIP_18411T44)&&(!defined(ONLY)||defined(CASE_18411T44))
	begin_chk("_18411T44");
	{
	int *p = (int *)operator new(sizeof (int));
	chk(p != 0);
	if (p != 0)
		{*p = -27;
		ieq(*p, -27); }
	operator delete(p);


	}
	end_chk("_18411T44");
#else
	skip_chk("_18411T44");
#endif /* CASE_18411T44 */

/* _18411T51 new(size_t, const nothrow&) returns null, doesn't throw */
#if !defined(SKIP_18411T51)&&(!defined(ONLY)||defined(CASE_18411T51))
	begin_chk("_18411T51");
	{
	STD nothrow_t nt;
	void *pv = operator new(sizeof (long double), nt);
	chk(pv != 0);
	if (pv != 0)
		{long double *pld = (long double *)pv;
		*pld = 21.5L;
		ldeq(*pld, 21.5L); }
	operator delete(pv);


	}
	end_chk("_18411T51");
#else
	skip_chk("_18411T51");
#endif /* CASE_18411T51 */

/* _18411T91 delete(void *) effects */
#if !defined(SKIP_18411T91)&&(!defined(ONLY)||defined(CASE_18411T91))
	begin_chk("_18411T91");
	{
	operator delete(0);
	chk(1);


	}
	end_chk("_18411T91");
#else
	skip_chk("_18411T91");
#endif /* CASE_18411T91 */

/* _18411T_121 delete(void *) does nothing with null argument */
#if !defined(SKIP_18411T_121)&&(!defined(ONLY)||defined(CASE_18411T_121))
	begin_chk("_18411T_121");
	{
	operator delete(0);
	chk(1);


	}
	end_chk("_18411T_121");
#else
	skip_chk("_18411T_121");
#endif /* CASE_18411T_121 */

/* _18411T_131 delete(void *) reclaims storage from earlier new call */
#if !defined(SKIP_18411T_131)&&(!defined(ONLY)||defined(CASE_18411T_131))
	begin_chk("_18411T_131");
	{
	int *p = (int *)operator new(sizeof (int));
	operator delete(p);
	chk(1);


	}
	end_chk("_18411T_131");
#else
	skip_chk("_18411T_131");
#endif /* CASE_18411T_131 */

/* _18412T11 new[](size_t) called by array new expression */
#if !defined(SKIP_18412T11)&&(!defined(ONLY)||defined(CASE_18412T11))
	begin_chk("_18412T11");
	{
	#if !DISALLOW_ARRAY_NEW_DELETE
		void *pv = operator new[](sizeof (long double));
		chk(pv != 0);
		if (pv != 0)
			{long double *pld = (long double *)pv;
			*pld = 21.5L;
			ldeq(*pld, 21.5L); }
		operator delete[](pv);
	#else
		chk(1);
	#endif


	}
	end_chk("_18412T11");
#else
	skip_chk("_18412T11");
#endif /* CASE_18412T11 */

/* _18412T61 new[](size_t, const nothrow&) effects */
#if !defined(SKIP_18412T61)&&(!defined(ONLY)||defined(CASE_18412T61))
	begin_chk("_18412T61");
	{
	STD nothrow_t nt; TOUCH(nt);
	#if !DISALLOW_ARRAY_NEW_DELETE
		void *pv = operator new[](sizeof (long double), nt);
		chk(pv != 0);
		if (pv != 0)
			{long double *pld = (long double *)pv;
			*pld = 21.5L;
			ldeq(*pld, 21.5L); }
		operator delete[](pv);
	#else
		chk(1);
	#endif


	}
	end_chk("_18412T61");
#else
	skip_chk("_18412T61");
#endif /* CASE_18412T61 */

/* _18412T_111 delete[](void *) effects */
#if !defined(SKIP_18412T_111)&&(!defined(ONLY)||defined(CASE_18412T_111))
	begin_chk("_18412T_111");
	{
	#if !DISALLOW_ARRAY_NEW_DELETE
		operator delete[](0);
	#endif
	chk(1);


	}
	end_chk("_18412T_111");
#else
	skip_chk("_18412T_111");
#endif /* CASE_18412T_111 */

/* _18412T_141 delete[](void *) does nothing with null argument */
#if !defined(SKIP_18412T_141)&&(!defined(ONLY)||defined(CASE_18412T_141))
	begin_chk("_18412T_141");
	{
	#if !DISALLOW_ARRAY_NEW_DELETE
		operator delete[](0);
	#endif
	chk(1);


	}
	end_chk("_18412T_141");
#else
	skip_chk("_18412T_141");
#endif /* CASE_18412T_141 */

/* _18412T_152 delete[](void *) reclaims storage from new[] */
#if !defined(SKIP_18412T_152)&&(!defined(ONLY)||defined(CASE_18412T_152))
	begin_chk("_18412T_152");
	{
	#if !DISALLOW_ARRAY_NEW_DELETE
		int *p = (int *)operator new[](sizeof (int));
		operator delete[](p);
	#endif
	chk(1);


	}
	end_chk("_18412T_152");
#else
	skip_chk("_18412T_152");
#endif /* CASE_18412T_152 */

/* _18413T13 new(size_t, void *) returns */
#if !defined(SKIP_18413T13)&&(!defined(ONLY)||defined(CASE_18413T13))
	begin_chk("_18413T13");
	{
	int i;
	chk(operator new(0, &i) == (void *)&i);
	chk(operator new(10000, &i) == (void *)&i);


	}
	end_chk("_18413T13");
#else
	skip_chk("_18413T13");
#endif /* CASE_18413T13 */

/* _18413T51 new[](size_t, void *) returns */
#if !defined(SKIP_18413T51)&&(!defined(ONLY)||defined(CASE_18413T51))
	begin_chk("_18413T51");
	{
	int i; TOUCH(i);
	#if !DISALLOW_ARRAY_NEW_DELETE
		chk(operator new[](0, &i) == (void *)&i);
		chk(operator new[](10000, &i) == (void *)&i);
	#else
		chk(1);
	#endif


	}
	end_chk("_18413T51");
#else
	skip_chk("_18413T51");
#endif /* CASE_18413T51 */

/* _18413T81 delete(void *, void *) effects */
#if !defined(SKIP_18413T81)&&(!defined(ONLY)||defined(CASE_18413T81))
	begin_chk("_18413T81");
	{
	#if !DISALLOW_PLACEMENT_DELETE
		int i;
		operator delete(&i, &i);
	#endif
	chk(1);


	}
	end_chk("_18413T81");
#else
	skip_chk("_18413T81");
#endif /* CASE_18413T81 */

/* _18413T_111 delete[](void *, void *) effects */
#if !defined(SKIP_18413T_111)&&(!defined(ONLY)||defined(CASE_18413T_111))
	begin_chk("_18413T_111");
	{
	#if !DISALLOW_PLACEMENT_DELETE
		int i;
		operator delete[](&i, &i);
	#endif
	chk(1);

	}
	end_chk("_18413T_111");
#else
	skip_chk("_18413T_111");
#endif /* CASE_18413T_111 */

return leave_chk("t182");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t190.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"

#if IS_EMBEDDED
#define ONLY
#define CASE_192T23		Table 30: <cassert> synopsis
#define CASE_193T21		Table 31: <cerrno> synopsis
#endif /* IS_EMBEDDED */

/* _191T41 <exception> synopsis */
#if !defined(SKIP_191T41)&&(!defined(ONLY)||defined(CASE_191T41))
#if DISALLOW_USER_NAME_PROTECTION
 #include <stdexcept>
#else
	#define xmsg	"xmsg"	/* looking for trouble */
 #include <stdexcept>
	#undef xmsg
#endif
#endif /* CASE_191T41 */

/* _1911T11 exception definition */
#if !defined(SKIP_1911T11)&&(!defined(ONLY)||defined(CASE_1911T11))
#include <exception>	/* now in exception [JUL95] */
#endif /* CASE_1911T11 */

/* _1911T31 exception::exception() effects */
#if !defined(SKIP_1911T31)&&(!defined(ONLY)||defined(CASE_1911T31))
#include <exception>	/* now in exception [JUL95] */
#endif /* CASE_1911T31 */

/* _1911T61 exception::exception(const exception&), operator= effects */
#if !defined(SKIP_1911T61)&&(!defined(ONLY)||defined(CASE_1911T61))
#include <exception>	/* now in exception [JUL95] */
#endif /* CASE_1911T61 */

/* _1911T91 exception::~exception() effects */
#if !defined(SKIP_1911T91)&&(!defined(ONLY)||defined(CASE_1911T91))
#include <exception>	/* now in exception [JUL95] */
#endif /* CASE_1911T91 */

/* _1911T_111 exception::what returns */
#if !defined(SKIP_1911T_111)&&(!defined(ONLY)||defined(CASE_1911T_111))
#include <cstring>
#include <exception>	/* now in exception [JUL95] */
#endif /* CASE_1911T_111 */

/* _1912T11 logic_error definition */
#if !defined(SKIP_1912T11)&&(!defined(ONLY)||defined(CASE_1912T11))
#include <stdexcept>
#endif /* CASE_1912T11 */

/* _1912T31 logic_error::logic_error(const string&) effects */
#if !defined(SKIP_1912T31)&&(!defined(ONLY)||defined(CASE_1912T31))
#include <stdexcept>
#include <string>
#endif /* CASE_1912T31 */

/* _1912T41 logic_error::logic_error(const string&) postcondition */
#if !defined(SKIP_1912T41)&&(!defined(ONLY)||defined(CASE_1912T41))
#include <stdexcept>
#include <string>
#endif /* CASE_1912T41 */

/* _1913T11 domain_error definition */
#if !defined(SKIP_1913T11)&&(!defined(ONLY)||defined(CASE_1913T11))
#include <stdexcept>
#endif /* CASE_1913T11 */

/* _1913T31 domain_error::domain_error(const string&) effects */
#if !defined(SKIP_1913T31)&&(!defined(ONLY)||defined(CASE_1913T31))
#include <stdexcept>
#include <string>
#endif /* CASE_1913T31 */

/* _1913T41 domain_error::domain_error(const string&) postcondition */
#if !defined(SKIP_1913T41)&&(!defined(ONLY)||defined(CASE_1913T41))
#include <stdexcept>
#include <string>
#endif /* CASE_1913T41 */

/* _1914T11 invalid_argument definition */
#if !defined(SKIP_1914T11)&&(!defined(ONLY)||defined(CASE_1914T11))
#include <stdexcept>
#endif /* CASE_1914T11 */

/* _1914T31 invalid_argument::invalid_argument(const string&) effects */
#if !defined(SKIP_1914T31)&&(!defined(ONLY)||defined(CASE_1914T31))
#include <stdexcept>
#include <string>
#endif /* CASE_1914T31 */

/* _1914T41 invalid_argument::invalid_argument(const string&) postcondition */
#if !defined(SKIP_1914T41)&&(!defined(ONLY)||defined(CASE_1914T41))
#include <stdexcept>
#include <string>
#endif /* CASE_1914T41 */

/* _1915T11 length_error definition */
#if !defined(SKIP_1915T11)&&(!defined(ONLY)||defined(CASE_1915T11))
#include <stdexcept>
#endif /* CASE_1915T11 */

/* _1915T31 length_error::length_error(const string&) effects */
#if !defined(SKIP_1915T31)&&(!defined(ONLY)||defined(CASE_1915T31))
#include <stdexcept>
#include <string>
#endif /* CASE_1915T31 */

/* _1915T41 length_error::length_error(const string&) postcondition */
#if !defined(SKIP_1915T41)&&(!defined(ONLY)||defined(CASE_1915T41))
#include <stdexcept>
#include <string>
#endif /* CASE_1915T41 */

/* _1916T11 out_of_range definition */
#if !defined(SKIP_1916T11)&&(!defined(ONLY)||defined(CASE_1916T11))
#include <stdexcept>
#endif /* CASE_1916T11 */

/* _1916T31 out_of_range::out_of_range(const string&) effects */
#if !defined(SKIP_1916T31)&&(!defined(ONLY)||defined(CASE_1916T31))
#include <stdexcept>
#include <string>
#endif /* CASE_1916T31 */

/* _1916T41 out_of_range::out_of_range(const string&) postcondition */
#if !defined(SKIP_1916T41)&&(!defined(ONLY)||defined(CASE_1916T41))
#include <stdexcept>
#include <string>
#endif /* CASE_1916T41 */

/* _1917T11 runtime_error definition */
#if !defined(SKIP_1917T11)&&(!defined(ONLY)||defined(CASE_1917T11))
#include <stdexcept>
#endif /* CASE_1917T11 */

/* _1917T31 runtime_error::runtime_error(const string&) effects */
#if !defined(SKIP_1917T31)&&(!defined(ONLY)||defined(CASE_1917T31))
#include <stdexcept>
#include <string>
#endif /* CASE_1917T31 */

/* _1917T41 runtime_error::runtime_error(const string&) postcondition */
#if !defined(SKIP_1917T41)&&(!defined(ONLY)||defined(CASE_1917T41))
#include <stdexcept>
#include <string>
#endif /* CASE_1917T41 */

/* _1918T11 range_error definition */
#if !defined(SKIP_1918T11)&&(!defined(ONLY)||defined(CASE_1918T11))
#include <stdexcept>
#endif /* CASE_1918T11 */

/* _1918T31 range_error::range_error(const string&) effects */
#if !defined(SKIP_1918T31)&&(!defined(ONLY)||defined(CASE_1918T31))
#include <stdexcept>
#include <string>
#endif /* CASE_1918T31 */

/* _1918T41 range_error::range_error(const string&) postcondition */
#if !defined(SKIP_1918T41)&&(!defined(ONLY)||defined(CASE_1918T41))
#include <stdexcept>
#include <string>
#endif /* CASE_1918T41 */

/* _1919T11 overflow_error definition */
#if !defined(SKIP_1919T11)&&(!defined(ONLY)||defined(CASE_1919T11))
#include <stdexcept>
#endif /* CASE_1919T11 */

/* _1919T11a underflow_error definition */
#if !defined(SKIP_1919T11a)&&(!defined(ONLY)||defined(CASE_1919T11a))
#include <stdexcept>
#endif /* CASE_1919T11a */

/* _1919T31 overflow_error::overflow_error(const string&) effects */
#if !defined(SKIP_1919T31)&&(!defined(ONLY)||defined(CASE_1919T31))
#include <stdexcept>
#include <string>
#endif /* CASE_1919T31 */

/* _1919T31a underflow_error::underflow_error(const string&) effects */
#if !defined(SKIP_1919T31a)&&(!defined(ONLY)||defined(CASE_1919T31a))
#include <stdexcept>
#include <string>
#endif /* CASE_1919T31a */

/* _1919T41 overflow_error::overflow_error(const string&) postcondition */
#if !defined(SKIP_1919T41)&&(!defined(ONLY)||defined(CASE_1919T41))
#include <stdexcept>
#include <string>
#endif /* CASE_1919T41 */

/* _1919T41a underflow_error::underflow_error(const string&) postcondition */
#if !defined(SKIP_1919T41a)&&(!defined(ONLY)||defined(CASE_1919T41a))
#include <stdexcept>
#include <string>
#endif /* CASE_1919T41a */

/* _192T23 Table 30: <cassert> synopsis */
#if !defined(SKIP_192T23)&&(!defined(ONLY)||defined(CASE_192T23))
#ifdef NDEBUG
 #include <cassert>
void f1_192T23()
	{assert(0); }
 #undef NDEBUG
 #include <cassert>
void f2_192T23()
	{assert(1); }
 #define NDEBUG
 #include <cassert>
#else
 #define NDEBUG
 #include <cassert>
void f1_192T23()
	{assert(0); }
 #undef NDEBUG
 #include <cassert>
void f2_192T23()
	{assert(1); }
#endif
#endif /* CASE_192T23 */

/* _193T21 Table 31: <cerrno> synopsis */
#if !defined(SKIP_193T21)&&(!defined(ONLY)||defined(CASE_193T21))
#include <cerrno>
#endif /* CASE_193T21 */

int t190_main(int, char *[])
{
enter_chk("t190.cpp");
/* _191T41 <exception> synopsis */
#if !defined(SKIP_191T41)&&(!defined(ONLY)||defined(CASE_191T41))
	begin_chk("_191T41");
	{
	STD exception *p1; TOUCH(p1);
	STD logic_error *p2; TOUCH(p2);
	STD domain_error *p3; TOUCH(p3);
	STD invalid_argument *p4; TOUCH(p4);
	STD length_error *p5; TOUCH(p5);
	STD out_of_range *p6; TOUCH(p6);
	STD runtime_error *p7; TOUCH(p7);
	STD range_error *p8; TOUCH(p8);
	STD overflow_error *p9; TOUCH(p9);
	STD underflow_error *p10; TOUCH(p10);	// [MAR96]
	chk(1);




	}
	end_chk("_191T41");
#else
	skip_chk("_191T41");
#endif /* CASE_191T41 */

/* _1911T11 exception definition */
#if !defined(SKIP_1911T11)&&(!defined(ONLY)||defined(CASE_1911T11))
	begin_chk("_1911T11");
	{
	STD exception *p1; TOUCH(p1);
	chk(1);


	}
	end_chk("_1911T11");
#else
	skip_chk("_1911T11");
#endif /* CASE_1911T11 */

/* _1911T31 exception::exception() effects */
#if !defined(SKIP_1911T31)&&(!defined(ONLY)||defined(CASE_1911T31))
	begin_chk("_1911T31");
	{
	STD exception x;
	chk(1);


	}
	end_chk("_1911T31");
#else
	skip_chk("_1911T31");
#endif /* CASE_1911T31 */

/* _1911T61 exception::exception(const exception&), operator= effects */
#if !defined(SKIP_1911T61)&&(!defined(ONLY)||defined(CASE_1911T61))
	begin_chk("_1911T61");
	{
	STD exception x;
	STD exception y(x);
	x = y;
	chk(1);


	}
	end_chk("_1911T61");
#else
	skip_chk("_1911T61");
#endif /* CASE_1911T61 */

/* _1911T91 exception::~exception() effects */
#if !defined(SKIP_1911T91)&&(!defined(ONLY)||defined(CASE_1911T91))
	begin_chk("_1911T91");
	{
	STD exception *px = new STD exception;
	px->~exception();
	chk(1);


	}
	end_chk("_1911T91");
#else
	skip_chk("_1911T91");
#endif /* CASE_1911T91 */

/* _1911T_111 exception::what returns */
#if !defined(SKIP_1911T_111)&&(!defined(ONLY)||defined(CASE_1911T_111))
	begin_chk("_1911T_111");
	{
	STD exception x;
	const char *s = x.what();
	chk(s != 0);


	}
	end_chk("_1911T_111");
#else
	skip_chk("_1911T_111");
#endif /* CASE_1911T_111 */

/* _1912T11 logic_error definition */
#if !defined(SKIP_1912T11)&&(!defined(ONLY)||defined(CASE_1912T11))
	begin_chk("_1912T11");
	{
	STD logic_error *p = 0;
	STD exception *q = p; TOUCH(q);
	chk(1);


	}
	end_chk("_1912T11");
#else
	skip_chk("_1912T11");
#endif /* CASE_1912T11 */

/* _1912T31 logic_error::logic_error(const string&) effects */
#if !defined(SKIP_1912T31)&&(!defined(ONLY)||defined(CASE_1912T31))
	begin_chk("_1912T31");
	{
	const STD string arg("argument");
	STD logic_error x(arg);
	chk(1);


	}
	end_chk("_1912T31");
#else
	skip_chk("_1912T31");
#endif /* CASE_1912T31 */

/* _1912T41 logic_error::logic_error(const string&) postcondition */
#if !defined(SKIP_1912T41)&&(!defined(ONLY)||defined(CASE_1912T41))
	begin_chk("_1912T41");
	{
	const STD string arg("argument");
	STD logic_error x(arg);
	steq(x.what(), arg.c_str());


	}
	end_chk("_1912T41");
#else
	skip_chk("_1912T41");
#endif /* CASE_1912T41 */

/* _1913T11 domain_error definition */
#if !defined(SKIP_1913T11)&&(!defined(ONLY)||defined(CASE_1913T11))
	begin_chk("_1913T11");
	{
	STD domain_error *p = 0;
	STD logic_error *q = p; TOUCH(q);
	chk(1);


	}
	end_chk("_1913T11");
#else
	skip_chk("_1913T11");
#endif /* CASE_1913T11 */

/* _1913T31 domain_error::domain_error(const string&) effects */
#if !defined(SKIP_1913T31)&&(!defined(ONLY)||defined(CASE_1913T31))
	begin_chk("_1913T31");
	{
	const STD string arg("argument");
	STD domain_error x(arg);
	chk(1);


	}
	end_chk("_1913T31");
#else
	skip_chk("_1913T31");
#endif /* CASE_1913T31 */

/* _1913T41 domain_error::domain_error(const string&) postcondition */
#if !defined(SKIP_1913T41)&&(!defined(ONLY)||defined(CASE_1913T41))
	begin_chk("_1913T41");
	{
	const STD string arg("argument");
	STD domain_error x(arg);
	steq(x.what(), arg.c_str());


	}
	end_chk("_1913T41");
#else
	skip_chk("_1913T41");
#endif /* CASE_1913T41 */

/* _1914T11 invalid_argument definition */
#if !defined(SKIP_1914T11)&&(!defined(ONLY)||defined(CASE_1914T11))
	begin_chk("_1914T11");
	{
	STD invalid_argument *p = 0;
	STD logic_error *q = p; TOUCH(q);
	chk(1);


	}
	end_chk("_1914T11");
#else
	skip_chk("_1914T11");
#endif /* CASE_1914T11 */

/* _1914T31 invalid_argument::invalid_argument(const string&) effects */
#if !defined(SKIP_1914T31)&&(!defined(ONLY)||defined(CASE_1914T31))
	begin_chk("_1914T31");
	{
	const STD string arg("argument");
	STD invalid_argument x(arg);
	chk(1);


	}
	end_chk("_1914T31");
#else
	skip_chk("_1914T31");
#endif /* CASE_1914T31 */

/* _1914T41 invalid_argument::invalid_argument(const string&) postcondition */
#if !defined(SKIP_1914T41)&&(!defined(ONLY)||defined(CASE_1914T41))
	begin_chk("_1914T41");
	{
	const STD string arg("argument");
	STD invalid_argument x(arg);
	steq(x.what(), arg.c_str());


	}
	end_chk("_1914T41");
#else
	skip_chk("_1914T41");
#endif /* CASE_1914T41 */

/* _1915T11 length_error definition */
#if !defined(SKIP_1915T11)&&(!defined(ONLY)||defined(CASE_1915T11))
	begin_chk("_1915T11");
	{
	STD length_error *p = 0;
	STD logic_error *q = p; TOUCH(q);
	chk(1);


	}
	end_chk("_1915T11");
#else
	skip_chk("_1915T11");
#endif /* CASE_1915T11 */

/* _1915T31 length_error::length_error(const string&) effects */
#if !defined(SKIP_1915T31)&&(!defined(ONLY)||defined(CASE_1915T31))
	begin_chk("_1915T31");
	{
	const STD string arg("argument");
	STD length_error x(arg);
	chk(1);


	}
	end_chk("_1915T31");
#else
	skip_chk("_1915T31");
#endif /* CASE_1915T31 */

/* _1915T41 length_error::length_error(const string&) postcondition */
#if !defined(SKIP_1915T41)&&(!defined(ONLY)||defined(CASE_1915T41))
	begin_chk("_1915T41");
	{
	const STD string arg("argument");
	STD length_error x(arg);
	steq(x.what(), arg.c_str());


	}
	end_chk("_1915T41");
#else
	skip_chk("_1915T41");
#endif /* CASE_1915T41 */

/* _1916T11 out_of_range definition */
#if !defined(SKIP_1916T11)&&(!defined(ONLY)||defined(CASE_1916T11))
	begin_chk("_1916T11");
	{
	STD out_of_range *p = 0;
	STD logic_error *q = p; TOUCH(q);
	chk(1);


	}
	end_chk("_1916T11");
#else
	skip_chk("_1916T11");
#endif /* CASE_1916T11 */

/* _1916T31 out_of_range::out_of_range(const string&) effects */
#if !defined(SKIP_1916T31)&&(!defined(ONLY)||defined(CASE_1916T31))
	begin_chk("_1916T31");
	{
	const STD string arg("argument");
	STD out_of_range x(arg);
	chk(1);


	}
	end_chk("_1916T31");
#else
	skip_chk("_1916T31");
#endif /* CASE_1916T31 */

/* _1916T41 out_of_range::out_of_range(const string&) postcondition */
#if !defined(SKIP_1916T41)&&(!defined(ONLY)||defined(CASE_1916T41))
	begin_chk("_1916T41");
	{
	const STD string arg("argument");
	STD out_of_range x(arg);
	steq(x.what(), arg.c_str());


	}
	end_chk("_1916T41");
#else
	skip_chk("_1916T41");
#endif /* CASE_1916T41 */

/* _1917T11 runtime_error definition */
#if !defined(SKIP_1917T11)&&(!defined(ONLY)||defined(CASE_1917T11))
	begin_chk("_1917T11");
	{
	STD runtime_error *p = 0;
	STD exception *q = p; TOUCH(q);
	chk(1);


	}
	end_chk("_1917T11");
#else
	skip_chk("_1917T11");
#endif /* CASE_1917T11 */

/* _1917T31 runtime_error::runtime_error(const string&) effects */
#if !defined(SKIP_1917T31)&&(!defined(ONLY)||defined(CASE_1917T31))
	begin_chk("_1917T31");
	{
	const STD string arg("argument");
	STD runtime_error x(arg);
	chk(1);


	}
	end_chk("_1917T31");
#else
	skip_chk("_1917T31");
#endif /* CASE_1917T31 */

/* _1917T41 runtime_error::runtime_error(const string&) postcondition */
#if !defined(SKIP_1917T41)&&(!defined(ONLY)||defined(CASE_1917T41))
	begin_chk("_1917T41");
	{
	const STD string arg("argument");
	STD runtime_error x(arg);
	steq(x.what(), arg.c_str());


	}
	end_chk("_1917T41");
#else
	skip_chk("_1917T41");
#endif /* CASE_1917T41 */

/* _1918T11 range_error definition */
#if !defined(SKIP_1918T11)&&(!defined(ONLY)||defined(CASE_1918T11))
	begin_chk("_1918T11");
	{
	STD range_error *p = 0;
	STD runtime_error *q = p; TOUCH(q);
	chk(1);


	}
	end_chk("_1918T11");
#else
	skip_chk("_1918T11");
#endif /* CASE_1918T11 */

/* _1918T31 range_error::range_error(const string&) effects */
#if !defined(SKIP_1918T31)&&(!defined(ONLY)||defined(CASE_1918T31))
	begin_chk("_1918T31");
	{
	const STD string arg("argument");
	STD range_error x(arg);
	chk(1);


	}
	end_chk("_1918T31");
#else
	skip_chk("_1918T31");
#endif /* CASE_1918T31 */

/* _1918T41 range_error::range_error(const string&) postcondition */
#if !defined(SKIP_1918T41)&&(!defined(ONLY)||defined(CASE_1918T41))
	begin_chk("_1918T41");
	{
	const STD string arg("argument");
	STD range_error x(arg);
	steq(x.what(), arg.c_str());


	}
	end_chk("_1918T41");
#else
	skip_chk("_1918T41");
#endif /* CASE_1918T41 */

/* _1919T11 overflow_error definition */
#if !defined(SKIP_1919T11)&&(!defined(ONLY)||defined(CASE_1919T11))
	begin_chk("_1919T11");
	{
	STD overflow_error *p = 0;
	STD runtime_error *q = p; TOUCH(q);
	chk(1);

	}
	end_chk("_1919T11");
#else
	skip_chk("_1919T11");
#endif /* CASE_1919T11 */

/* _1919T11a underflow_error definition */
#if !defined(SKIP_1919T11a)&&(!defined(ONLY)||defined(CASE_1919T11a))
	begin_chk("_1919T11a");
	{
	STD underflow_error *p = 0;	// [MAR96]
	STD runtime_error *q = p; TOUCH(q);
	chk(1);


	}
	end_chk("_1919T11a");
#else
	skip_chk("_1919T11a");
#endif /* CASE_1919T11a */

/* _1919T31 overflow_error::overflow_error(const string&) effects */
#if !defined(SKIP_1919T31)&&(!defined(ONLY)||defined(CASE_1919T31))
	begin_chk("_1919T31");
	{
	const STD string arg("argument");
	STD overflow_error x(arg);
	chk(1);

	}
	end_chk("_1919T31");
#else
	skip_chk("_1919T31");
#endif /* CASE_1919T31 */

/* _1919T31a underflow_error::underflow_error(const string&) effects */
#if !defined(SKIP_1919T31a)&&(!defined(ONLY)||defined(CASE_1919T31a))
	begin_chk("_1919T31a");
	{
	const STD string arg("argument");
	STD underflow_error x(arg);	// [MAR96]
	chk(1);


	}
	end_chk("_1919T31a");
#else
	skip_chk("_1919T31a");
#endif /* CASE_1919T31a */

/* _1919T41 overflow_error::overflow_error(const string&) postcondition */
#if !defined(SKIP_1919T41)&&(!defined(ONLY)||defined(CASE_1919T41))
	begin_chk("_1919T41");
	{
	const STD string arg("argument");
	STD overflow_error x(arg);
	steq(x.what(), arg.c_str());

	}
	end_chk("_1919T41");
#else
	skip_chk("_1919T41");
#endif /* CASE_1919T41 */

/* _1919T41a underflow_error::underflow_error(const string&) postcondition */
#if !defined(SKIP_1919T41a)&&(!defined(ONLY)||defined(CASE_1919T41a))
	begin_chk("_1919T41a");
	{
	const STD string arg("argument");
	STD underflow_error x(arg);	// [MAR96]
	steq(x.what(), arg.c_str());


	}
	end_chk("_1919T41a");
#else
	skip_chk("_1919T41a");
#endif /* CASE_1919T41a */

/* _192T23 Table 30: <cassert> synopsis */
#if !defined(SKIP_192T23)&&(!defined(ONLY)||defined(CASE_192T23))
	begin_chk("_192T23");
	{
	f1_192T23();	// suppressed failure
	f2_192T23();	// unsuppressed success
	chk(1);


	}
	end_chk("_192T23");
#else
	skip_chk("_192T23");
#endif /* CASE_192T23 */

/* _193T21 Table 31: <cerrno> synopsis */
#if !defined(SKIP_193T21)&&(!defined(ONLY)||defined(CASE_193T21))
	begin_chk("_193T21");
	{
	errno = EDOM;
	ieq(errno, EDOM);
	errno = ERANGE;
	ieq(errno, ERANGE);
	errno = 0;
	ieq(errno, 0);

	}
	end_chk("_193T21");
#else
	skip_chk("_193T21");
#endif /* CASE_193T21 */

return leave_chk("t190");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t170.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _17412T21 Table 21: C++ library headers */
#if !defined(SKIP_17412T21)&&(!defined(ONLY)||defined(CASE_17412T21))
#if !DISALLOW_USER_NAME_PROTECTION
	#define smanip	"smanip"	/* looking for trouble */
	#define T	"T"
	#define x	"x"
#endif
#if IS_EMBEDDED
#else /* IS_EMBEDDED */
#include <algorithm>
#include <bitset>
#include <deque>
#include <exception>
#include <functional>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <stdexcept>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>
#endif /* IS_EMBEDDED */
#include <complex>
#include <fstream>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <new>
#include <ostream>
#include <sstream>
#include <streambuf>
#include <string>
#if !DISALLOW_USER_NAME_PROTECTION
	#undef smanip
	#undef T
	#undef x
#endif
#endif /* CASE_17412T21 */

/* _17412T31 Table 22: C++ headers for C library */
#if !defined(SKIP_17412T31)&&(!defined(ONLY)||defined(CASE_17412T31))
#include <cassert>
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#if IS_EMBEDDED
#else /* IS_EMBEDDED */
#include <ciso646>
#include <cwchar>
#include <cwctype>
#endif /* IS_EMBEDDED */
#endif /* CASE_17412T31 */

/* _17412T41 contents of cname same as name.h */
#if !defined(SKIP_17412T41)&&(!defined(ONLY)||defined(CASE_17412T41))
#include <cstdio>
static int fun1_17412T41() {return (EOF); }
#include <stdio.h>
static int fun2_17412T41() {return (EOF); }
#endif /* CASE_17412T41 */

/* _17412T42 declarations are in namespace std */
#if !defined(SKIP_17412T42)&&(!defined(ONLY)||defined(CASE_17412T42))
#include <cstdio>
static int fun1_17412T42() {return (STD ferror(stdin)); }
#include <stdio.h>
static int fun2_17412T42() {return (ferror(stdin)); }
#endif /* CASE_17412T42 */

/* _17321T21 may include headers in any order */
#if !defined(SKIP_17321T21)&&(!defined(ONLY)||defined(CASE_17321T21))
#include <iostream>
#include <cstddef>
#include <istream>
#endif /* CASE_17321T21 */

/* _17321T22 may be included more than once (except <assert.h>) */
#if !defined(SKIP_17321T22)&&(!defined(ONLY)||defined(CASE_17321T22))
#include <cstddef>
#include <cstddef>
#include <iostream>
#include <iostream>
#undef NDEBUG
#include <cassert>
static int fun1_17321T22() {assert(1); return (1); }
#define NDEBUG
#include <cassert>
static int fun2_17321T22() {assert(0); return (1); }
#undef NDEBUG
#include <cassert>
static int fun3_17321T22() {assert(1); return (1); }
#endif /* CASE_17321T22 */

/* _17335T21 may install different handler functions during execution */
#if !defined(SKIP_17335T21)&&(!defined(ONLY)||defined(CASE_17335T21))
#include <cstdlib>
#include <new>
#if DISALLOW_EXCEPTIONS
#else /* DISALLOW_EXCEPTIONS */
#include <exception>
static void unexh_17335T21() {abort(); }
static void termh_17335T21() {abort(); }
#endif /* DISALLOW_EXCEPTIONS */
static void newh_17335T21() {abort(); }
#endif /* CASE_17335T21 */

/* _17341T12 second header may also define certain types and macros */
#if !defined(SKIP_17341T12)&&(!defined(ONLY)||defined(CASE_17341T12))
#include <cstddef>
static size_t s1_17341T12 = 0;
#include <stddef.h>
static size_t s2_17341T12 = 0;
#include <streambuf>
static int eof1 = EOF;
#include <stdio.h>
static int eof2 = EOF;
#endif /* CASE_17341T12 */

/* _17341T22 any C++ header may include any other */
#if !defined(SKIP_17341T22)&&(!defined(ONLY)||defined(CASE_17341T22))
#include <istream>
#endif /* CASE_17341T22 */

/* _17342T21 object-like macros are #if expressions */
#if !defined(SKIP_17342T21)&&(!defined(ONLY)||defined(CASE_17342T21))
#include <cfloat>
#if FLT_RADIX == 0
 #error FLT_RADIX not usable in #if
#endif
#include <climits>
#if CHAR_MAX == 0
 #error CHAR_MAX not usable in #if
#endif
#include <clocale>
#if LC_ALL == 0 && !defined(LC_ALL)
 #error LC_ALL not usable in #if
#endif
#include <csignal>
#if SIGILL == 0
 #error SIGILL not usable in #if
#endif
#include <cstdlib>
#if EXIT_FAILURE == 0
 #error EXIT_FAILURE not usable in #if
#endif
#include <streambuf>
#if EOF == 0
 #error EOF not usable in #if
#endif
#endif /* CASE_17342T21 */

/* _17347T21 distinct type names are different types */
#if !defined(SKIP_17347T21)&&(!defined(ONLY)||defined(CASE_17347T21))
#include <stdio.h>
#include <iostream>
int fun_17347T21(int x) {return (x); }
int fun_17347T21(FILE) {return (0); }
int fun_17347T21(STD ios) {return (0); }
int fun_17347T21(STD streampos) {return (0); }
#endif /* CASE_17347T21 */

int t170_main(int, char *[])
{
enter_chk("t170.cpp");
/* _17412T21 Table 21: C++ library headers */
#if !defined(SKIP_17412T21)&&(!defined(ONLY)||defined(CASE_17412T21))
	begin_chk("_17412T21");
	{
	chk(1);


	}
	end_chk("_17412T21");
#else
	skip_chk("_17412T21");
#endif /* CASE_17412T21 */

/* _17412T31 Table 22: C++ headers for C library */
#if !defined(SKIP_17412T31)&&(!defined(ONLY)||defined(CASE_17412T31))
	begin_chk("_17412T31");
	{
	chk(1);


	}
	end_chk("_17412T31");
#else
	skip_chk("_17412T31");
#endif /* CASE_17412T31 */

/* _17412T41 contents of cname same as name.h */
#if !defined(SKIP_17412T41)&&(!defined(ONLY)||defined(CASE_17412T41))
	begin_chk("_17412T41");
	{
	ieq(fun1_17412T41(), fun2_17412T41());


	}
	end_chk("_17412T41");
#else
	skip_chk("_17412T41");
#endif /* CASE_17412T41 */

/* _17412T42 declarations are in namespace std */
#if !defined(SKIP_17412T42)&&(!defined(ONLY)||defined(CASE_17412T42))
	begin_chk("_17412T42");
	{
	ieq(fun1_17412T42(), fun2_17412T42());




	}
	end_chk("_17412T42");
#else
	skip_chk("_17412T42");
#endif /* CASE_17412T42 */

/* _17321T21 may include headers in any order */
#if !defined(SKIP_17321T21)&&(!defined(ONLY)||defined(CASE_17321T21))
	begin_chk("_17321T21");
	{
	chk(1);


	}
	end_chk("_17321T21");
#else
	skip_chk("_17321T21");
#endif /* CASE_17321T21 */

/* _17321T22 may be included more than once (except <assert.h>) */
#if !defined(SKIP_17321T22)&&(!defined(ONLY)||defined(CASE_17321T22))
	begin_chk("_17321T22");
	{
	ieq(fun1_17321T22(), 1);
	ieq(fun2_17321T22(), 1);
	ieq(fun3_17321T22(), 1);




	}
	end_chk("_17321T22");
#else
	skip_chk("_17321T22");
#endif /* CASE_17321T22 */

/* _17335T21 may install different handler functions during execution */
#if !defined(SKIP_17335T21)&&(!defined(ONLY)||defined(CASE_17335T21))
	begin_chk("_17335T21");
	{
	STD new_handler newp = STD set_new_handler(&newh_17335T21);
	newp = STD set_new_handler(newp);
	chk(newp == &newh_17335T21);
	#if DISALLOW_EXCEPTIONS
	#else /* DISALLOW_EXCEPTIONS */
	STD unexpected_handler unexp = STD set_unexpected(&unexh_17335T21);
	STD terminate_handler termp = STD set_terminate(&termh_17335T21);
	unexp = STD set_unexpected(unexp);
	termp = STD set_terminate(termp);
	chk(unexp == &unexh_17335T21);
	chk(termp == &termh_17335T21);
	#endif /* DISALLOW_EXCEPTIONS */


	}
	end_chk("_17335T21");
#else
	skip_chk("_17335T21");
#endif /* CASE_17335T21 */

/* _17341T12 second header may also define certain types and macros */
#if !defined(SKIP_17341T12)&&(!defined(ONLY)||defined(CASE_17341T12))
	begin_chk("_17341T12");
	{
	TOUCH(s1_17341T12);
	TOUCH(s2_17341T12);
	ieq(eof1, EOF);
	ieq(eof1, eof2);


	}
	end_chk("_17341T12");
#else
	skip_chk("_17341T12");
#endif /* CASE_17341T12 */

/* _17341T22 any C++ header may include any other */
#if !defined(SKIP_17341T22)&&(!defined(ONLY)||defined(CASE_17341T22))
	begin_chk("_17341T22");
	{
	STD ios::fmtflags ff = STD ios::hex; TOUCH(ff);
	chk(1);




	}
	end_chk("_17341T22");
#else
	skip_chk("_17341T22");
#endif /* CASE_17341T22 */

/* _17342T21 object-like macros are #if expressions */
#if !defined(SKIP_17342T21)&&(!defined(ONLY)||defined(CASE_17342T21))
	begin_chk("_17342T21");
	{
	chk(1);


	}
	end_chk("_17342T21");
#else
	skip_chk("_17342T21");
#endif /* CASE_17342T21 */

/* _17347T21 distinct type names are different types */
#if !defined(SKIP_17347T21)&&(!defined(ONLY)||defined(CASE_17347T21))
	begin_chk("_17347T21");
	{
	ieq(fun_17347T21(3), 3);

	}
	end_chk("_17347T21");
#else
	skip_chk("_17347T21");
#endif /* CASE_17347T21 */

return leave_chk("t170");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t183.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"

#if IS_EMBEDDED
#define ONLY
#define CASE_18422T11   5 new_handler definition
#define CASE_18423T21   8 set_new_handler returns
#define CASE_186T21    24 <exception> synopsis
#define CASE_18611T11  25 bad_exception definition
#define CASE_18611T31  26 bad_exception::bad_exception() effects
#define CASE_18611T51  27 bad_exception::bad_exception(const bad_exception&), operator= effects
#define CASE_18611T81  28 bad_exception::what returns
#define CASE_18612T11  29 unexpected_handler definition
#define CASE_18612T31  30 unexpected handler default behavior
#define CASE_18613T11  31 set_unexpected effects
#define CASE_18613T31  32 set_unexpected returns
#define CASE_18614T11  33 unexpected() called by exception-specification failure
#define CASE_18614T21  34 unexpected() effects
#define CASE_18621T11  35 terminate_handler definition
#define CASE_18621T31  36 terminate handler default behavior
#define CASE_18622T11  37 set_terminate effects
#define CASE_18622T31  38 set_terminate returns
#define CASE_18623T11  39 terminate() called by exception handling
#define CASE_18623T21  40 terminate() effects
#define CASE_187T21    41 Table 28: <cstdarg> synopsis
#define CASE_187T31    42 Table 28 [sic]: <csetjmp> synopsis
#define CASE_187T41    43 Table 28 [sic]: <ctime> synopsis
#define CASE_187T51    44 Table 28 [sic]: <csignal> synopsis
#define CASE_187T61    45 Table 28 [sic]: <cstdlib> synopsis
#endif /* IS_EMBEDDED */
#if DISALLOW_EXCEPTIONS
#define SKIP_186T21    24 <exception> synopsis
#define SKIP_18611T11  25 bad_exception definition
#define SKIP_18611T31  26 bad_exception::bad_exception() effects
#define SKIP_18611T51  27 bad_exception::bad_exception(const bad_exception&), operator= effects
#define SKIP_18611T81  28 bad_exception::what returns
#define SKIP_18612T11  29 unexpected_handler definition
#define SKIP_18612T31  30 unexpected handler default behavior
#define SKIP_18613T11  31 set_unexpected effects
#define SKIP_18613T31  32 set_unexpected returns
#define SKIP_18614T11  33 unexpected() called by exception-specification failure
#define SKIP_18614T21  34 unexpected() effects
#define SKIP_18621T11  35 terminate_handler definition
#define SKIP_18621T31  36 terminate handler default behavior
#define SKIP_18622T11  37 set_terminate effects
#define SKIP_18622T31  38 set_terminate returns
#define SKIP_18623T11  39 terminate() called by exception handling
#define SKIP_18623T21  40 terminate() effects
#endif

/* _18421T11 bad_alloc definition */
#if !defined(SKIP_18421T11)&&(!defined(ONLY)||defined(CASE_18421T11))
#include <new>
#endif /* CASE_18421T11 */

/* _18421T31 bad_alloc::bad_alloc() effects */
#if !defined(SKIP_18421T31)&&(!defined(ONLY)||defined(CASE_18421T31))
#include <new>
#endif /* CASE_18421T31 */

/* _18421T51 bad_alloc::operator= effects */
#if !defined(SKIP_18421T51)&&(!defined(ONLY)||defined(CASE_18421T51))
#include <new>
#endif /* CASE_18421T51 */

/* _18421T81 bad_alloc::what() returns */
#if !defined(SKIP_18421T81)&&(!defined(ONLY)||defined(CASE_18421T81))
#include <cstring>
#include <new>
#endif /* CASE_18421T81 */

/* _18422T11 new_handler definition */
#if !defined(SKIP_18422T11)&&(!defined(ONLY)||defined(CASE_18422T11))
#include <new>
static void newh_18422T11()
	{}
#include <new>
#endif /* CASE_18422T11 */

/* _18422T31 new handler default behavior */
#if !defined(SKIP_18422T31)&&(!defined(ONLY)||defined(CASE_18422T31))
#include <new>
#endif /* CASE_18422T31 */

/* _18423T21 set_new_handler returns */
#if !defined(SKIP_18423T21)&&(!defined(ONLY)||defined(CASE_18423T21))
#include <new>
static void newh_18423T21()
	{}
#endif /* CASE_18423T21 */

/* _185T31 <stdexcept> synopsis */
#if !defined(SKIP_185T31)&&(!defined(ONLY)||defined(CASE_185T31))
#if DISALLOW_USER_NAME_PROTECTION
 #include <typeinfo>
#else
	#define Bad_cast	"Bad_cast"	/* looking for trouble */
	#define Bad_typeid	"Bad_typeid"
	#define typeinfo	"typeinfo"
 #include <typeinfo>
	#undef Bad_cast
	#undef Bad_typeid
	#undef typeinfo
#endif
#endif /* CASE_185T31 */

/* _1851T11 type_info definition */
#if !defined(SKIP_1851T11)&&(!defined(ONLY)||defined(CASE_1851T11))
#include <typeinfo>
#endif /* CASE_1851T11 */

/* _1851T31 type_info::operator== returns */
#if !defined(SKIP_1851T31)&&(!defined(ONLY)||defined(CASE_1851T31))
#include <typeinfo>
#endif /* CASE_1851T31 */

/* _1851T51 type_info::operator!= returns */
#if !defined(SKIP_1851T51)&&(!defined(ONLY)||defined(CASE_1851T51))
#include <typeinfo>
#endif /* CASE_1851T51 */

/* _1851T81 type_info::before returns */
#if !defined(SKIP_1851T81)&&(!defined(ONLY)||defined(CASE_1851T81))
#include <typeinfo>
#endif /* CASE_1851T81 */

/* _1851T_101 type_info::name returns */
#if !defined(SKIP_1851T_101)&&(!defined(ONLY)||defined(CASE_1851T_101))
#include <cstring>
#include <typeinfo>
#endif /* CASE_1851T_101 */

/* _1851T_131 type_info::type_info, operator= effects */
#if !defined(SKIP_1851T_131)&&(!defined(ONLY)||defined(CASE_1851T_131))
#include <typeinfo>
#endif /* CASE_1851T_131 */

/* _1852T11 bad_cast definition */
#if !defined(SKIP_1852T11)&&(!defined(ONLY)||defined(CASE_1852T11))
#include <typeinfo>
#endif /* CASE_1852T11 */

/* _1852T31 bad_cast::bad_cast() effects */
#if !defined(SKIP_1852T31)&&(!defined(ONLY)||defined(CASE_1852T31))
#include <cstring>
#include <typeinfo>
#endif /* CASE_1852T31 */

/* _1852T51 bad_cast::bad_cast(const bad_cast&), operator= effects */
#if !defined(SKIP_1852T51)&&(!defined(ONLY)||defined(CASE_1852T51))
#include <typeinfo>
#endif /* CASE_1852T51 */

/* _1852T81 bad_cast::what returns */
#if !defined(SKIP_1852T81)&&(!defined(ONLY)||defined(CASE_1852T81))
#include <cstring>
#include <typeinfo>
#endif /* CASE_1852T81 */

/* _1853T11 bad_typeid definition */
#if !defined(SKIP_1853T11)&&(!defined(ONLY)||defined(CASE_1853T11))
#include <typeinfo>
#endif /* CASE_1853T11 */

/* _1853T31 bad_typeid::bad_typeid() effects */
#if !defined(SKIP_1853T31)&&(!defined(ONLY)||defined(CASE_1853T31))
#include <typeinfo>
#endif /* CASE_1853T31 */

/* _1853T51 bad_typeid::bad_typeid(const bad_typeid&), operator= effects */
#if !defined(SKIP_1853T51)&&(!defined(ONLY)||defined(CASE_1853T51))
#include <typeinfo>
#endif /* CASE_1853T51 */

/* _1853T81 bad_typeid::what returns */
#if !defined(SKIP_1853T81)&&(!defined(ONLY)||defined(CASE_1853T81))
#include <cstring>
#include <typeinfo>
#endif /* CASE_1853T81 */

/* _186T21 <exception> synopsis */
#if !defined(SKIP_186T21)&&(!defined(ONLY)||defined(CASE_186T21))
#if DISALLOW_USER_NAME_PROTECTION
 #include <exception>
#else
	#define xmsg	"xmsg"	/* looking for trouble */
	#define xalloc	"xalloc"
 #include <exception>
	#undef xmsg
	#undef xalloc
#endif
#endif /* CASE_186T21 */

/* _18611T11 bad_exception definition */
#if !defined(SKIP_18611T11)&&(!defined(ONLY)||defined(CASE_18611T11))
#include <exception>
#endif /* CASE_18611T11 */

/* _18611T31 bad_exception::bad_exception() effects */
#if !defined(SKIP_18611T31)&&(!defined(ONLY)||defined(CASE_18611T31))
#include <exception>
#endif /* CASE_18611T31 */

/* _18611T51 bad_exception::bad_exception(const bad_exception&), operator= effects */
#if !defined(SKIP_18611T51)&&(!defined(ONLY)||defined(CASE_18611T51))
#include <exception>
#endif /* CASE_18611T51 */

/* _18611T81 bad_exception::what returns */
#if !defined(SKIP_18611T81)&&(!defined(ONLY)||defined(CASE_18611T81))
#include <cstring>
#include <exception>
#endif /* CASE_18611T81 */

/* _18612T11 unexpected_handler definition */
#if !defined(SKIP_18612T11)&&(!defined(ONLY)||defined(CASE_18612T11))
static void unh_18612T11()
	{}
#include <exception>
#endif /* CASE_18612T11 */

/* _18612T31 unexpected handler default behavior */
#if !defined(SKIP_18612T31)&&(!defined(ONLY)||defined(CASE_18612T31))
#include <csetjmp>
#include <exception>
static int cnt_18612T31;
static jmp_buf jbuf_18612T31;
static void terh_18612T31()
	{++cnt_18612T31;
	longjmp(jbuf_18612T31, 1); }
#endif /* CASE_18612T31 */

/* _18613T11 set_unexpected effects */
#if !defined(SKIP_18613T11)&&(!defined(ONLY)||defined(CASE_18613T11))
#include <csetjmp>
#include <exception>
static int cnt_18613T11;
static jmp_buf jbuf_18613T11;
static void unh_18613T11()
	{++cnt_18613T11;
	longjmp(jbuf_18613T11, 1); }
#endif /* CASE_18613T11 */

/* _18613T31 set_unexpected returns */
#if !defined(SKIP_18613T31)&&(!defined(ONLY)||defined(CASE_18613T31))
#include <exception>
static void unh_18613T31()
	{}
#endif /* CASE_18613T31 */

/* _18614T21 unexpected() effects */
#if !defined(SKIP_18614T21)&&(!defined(ONLY)||defined(CASE_18614T21))
#include <csetjmp>
#include <exception>
static int cnt_18614T21;
static jmp_buf jbuf_18614T21;
static void unh_18614T21()
	{++cnt_18614T21;
	longjmp(jbuf_18614T21, 1); }
#endif /* CASE_18614T21 */

/* _18621T11 terminate_handler definition */
#if !defined(SKIP_18621T11)&&(!defined(ONLY)||defined(CASE_18621T11))
static void terh_18621T11()
	{}
#include <exception>
#endif /* CASE_18621T11 */

/* _18622T11 set_terminate effects */
#if !defined(SKIP_18622T11)&&(!defined(ONLY)||defined(CASE_18622T11))
#include <csetjmp>
#include <exception>
static int cnt_18622T11;
static jmp_buf jbuf_18622T11;
static void terh_18622T11()
	{++cnt_18622T11;
	longjmp(jbuf_18622T11, 1); }
#endif /* CASE_18622T11 */

/* _18622T31 set_terminate returns */
#if !defined(SKIP_18622T31)&&(!defined(ONLY)||defined(CASE_18622T31))
#include <exception>
static void terh_18622T31()
	{}
#endif /* CASE_18622T31 */

/* _18623T21 terminate() effects */
#if !defined(SKIP_18623T21)&&(!defined(ONLY)||defined(CASE_18623T21))
#include <csetjmp>
#include <cstdio>
#include <exception>
static int cnt_18623T21;
static jmp_buf jbuf_18623T21;
static void terh_18623T21()
	{++cnt_18623T21;
	longjmp(jbuf_18623T21, 1); }
#endif /* CASE_18623T21 */

/* _187T21 Table 28: <cstdarg> synopsis */
#if !defined(SKIP_187T21)&&(!defined(ONLY)||defined(CASE_187T21))
#include <cstdarg>
int fun_187T21(int x, ...)
	{va_list ap;
	va_start(ap, x);
	int val = va_arg(ap, int);
	va_end(ap);
	return (val); }
#endif /* CASE_187T21 */

/* _187T31 Table 28 [sic]: <csetjmp> synopsis */
#if !defined(SKIP_187T31)&&(!defined(ONLY)||defined(CASE_187T31))
#include <csetjmp>
static jmp_buf jbuf_187T31;
static int cnt_187T31;
void fun_187T31()
	{++cnt_187T31;
	longjmp(jbuf_187T31, 1); }
#endif /* CASE_187T31 */

/* _187T41 Table 28 [sic]: <ctime> synopsis */
#if !defined(SKIP_187T41)&&(!defined(ONLY)||defined(CASE_187T41))
#include <ctime>
#endif /* CASE_187T41 */

/* _187T51 Table 28 [sic]: <csignal> synopsis */
#if !defined(SKIP_187T51)&&(!defined(ONLY)||defined(CASE_187T51))
#include <csignal>
static int cnt_187T51;
static const int sigs_187T51[] = {
	SIGABRT, SIGFPE, SIGILL, SIGINT, SIGSEGV, SIGTERM};

extern "C" {
static void (*CLINK ret1_187T51)(int) = {SIG_DFL};
static void (*CLINK ret2_187T51)(int) = {SIG_ERR};
static void (*CLINK ret3_187T51)(int) = {SIG_IGN};
void CLINK fpe_187T51(int sig)
	{++cnt_187T51;
	ieq(sig, SIGFPE); }
void (*CLINK ps_187T51)(int) = 0;
}
#endif /* CASE_187T51 */

/* _187T61 Table 28 [sic]: <cstdlib> synopsis */
#if !defined(SKIP_187T61)&&(!defined(ONLY)||defined(CASE_187T61))
#include <cstdlib>
#endif /* CASE_187T61 */

int t183_main(int, char *[])
{
enter_chk("t183.cpp");
/* _18421T11 bad_alloc definition */
#if !defined(SKIP_18421T11)&&(!defined(ONLY)||defined(CASE_18421T11))
	begin_chk("_18421T11");
	{
	STD bad_alloc *p; TOUCH(p);
	chk(1);


	}
	end_chk("_18421T11");
#else
	skip_chk("_18421T11");
#endif /* CASE_18421T11 */

/* _18421T31 bad_alloc::bad_alloc() effects */
#if !defined(SKIP_18421T31)&&(!defined(ONLY)||defined(CASE_18421T31))
	begin_chk("_18421T31");
	{
	STD bad_alloc x;
	STD exception *pr = &x; TOUCH(pr);
	chk(1);


	}
	end_chk("_18421T31");
#else
	skip_chk("_18421T31");
#endif /* CASE_18421T31 */

/* _18421T51 bad_alloc::operator= effects */
#if !defined(SKIP_18421T51)&&(!defined(ONLY)||defined(CASE_18421T51))
	begin_chk("_18421T51");
	{
	STD bad_alloc x;
	STD bad_alloc y(x);
	x = y;
	chk(1);


	}
	end_chk("_18421T51");
#else
	skip_chk("_18421T51");
#endif /* CASE_18421T51 */

/* _18421T81 bad_alloc::what() returns */
#if !defined(SKIP_18421T81)&&(!defined(ONLY)||defined(CASE_18421T81))
	begin_chk("_18421T81");
	{
	STD bad_alloc x;
	const char *s = x.what();
	chk(s != 0 && 0 < strlen(s));


	}
	end_chk("_18421T81");
#else
	skip_chk("_18421T81");
#endif /* CASE_18421T81 */

/* _18422T11 new_handler definition */
#if !defined(SKIP_18422T11)&&(!defined(ONLY)||defined(CASE_18422T11))
	begin_chk("_18422T11");
	{
	STD new_handler ph = &newh_18422T11; TOUCH(ph);
	chk(1);


	}
	end_chk("_18422T11");
#else
	skip_chk("_18422T11");
#endif /* CASE_18422T11 */

/* _18422T31 new handler default behavior */
#if !defined(SKIP_18422T31)&&(!defined(ONLY)||defined(CASE_18422T31))
	begin_chk("_18422T31");
	{
	#if DISALLOW_EXCEPTIONS
	chk(1);
	#else
	struct x {
		struct x *next;
		char a[BIG_OBJECT]; };
	struct x *head = 0, **qb;
	int cnt = 0;
	try {	// consume all of heap
		for (qb = &head; (*qb = (x *)operator new(sizeof (x))) != 0; )
			qb = &(*qb)->next, *qb = 0; }
	catch (STD bad_alloc) {
		cnt = 1; }
	catch (...) {
		chk("shouldn't get here" == 0); }
	ieq(cnt, 1);
	while (head != 0)
		{struct x *p = head->next;
		operator delete(head);
		head = p; }
	#endif


	}
	end_chk("_18422T31");
#else
	skip_chk("_18422T31");
#endif /* CASE_18422T31 */

/* _18423T21 set_new_handler returns */
#if !defined(SKIP_18423T21)&&(!defined(ONLY)||defined(CASE_18423T21))
	begin_chk("_18423T21");
	{
	STD new_handler ph = STD set_new_handler(&newh_18423T21);
	chk(STD set_new_handler(ph) == &newh_18423T21);


	}
	end_chk("_18423T21");
#else
	skip_chk("_18423T21");
#endif /* CASE_18423T21 */

/* _185T31 <stdexcept> synopsis */
#if !defined(SKIP_185T31)&&(!defined(ONLY)||defined(CASE_185T31))
	begin_chk("_185T31");
	{
	STD bad_cast *pbc = 0; TOUCH(pbc); 
	STD bad_typeid *pbt = 0; TOUCH(pbt);
	STD type_info *pti = 0; TOUCH(pti);
	chk(1);




	}
	end_chk("_185T31");
#else
	skip_chk("_185T31");
#endif /* CASE_185T31 */

/* _1851T11 type_info definition */
#if !defined(SKIP_1851T11)&&(!defined(ONLY)||defined(CASE_1851T11))
	begin_chk("_1851T11");
	{
	STD type_info *p = 0; TOUCH(p);
	bool x = typeid(char) == typeid(int); TOUCH(x);
	chk(1);


	}
	end_chk("_1851T11");
#else
	skip_chk("_1851T11");
#endif /* CASE_1851T11 */

/* _1851T31 type_info::operator== returns */
#if !defined(SKIP_1851T31)&&(!defined(ONLY)||defined(CASE_1851T31))
	begin_chk("_1851T31");
	{
	chk(typeid(char) == typeid(char));
	chk(!(typeid(char) == typeid(int)));


	}
	end_chk("_1851T31");
#else
	skip_chk("_1851T31");
#endif /* CASE_1851T31 */

/* _1851T51 type_info::operator!= returns */
#if !defined(SKIP_1851T51)&&(!defined(ONLY)||defined(CASE_1851T51))
	begin_chk("_1851T51");
	{
	chk(typeid(char) != typeid(int));
	chk(!(typeid(char) != typeid(char)));


	}
	end_chk("_1851T51");
#else
	skip_chk("_1851T51");
#endif /* CASE_1851T51 */

/* _1851T81 type_info::before returns */
#if !defined(SKIP_1851T81)&&(!defined(ONLY)||defined(CASE_1851T81))
	begin_chk("_1851T81");
	{
	chk(!typeid(int).before(typeid(int)));
	if (typeid(int).before(typeid(char)))
		chk(!typeid(char).before(typeid(int)));
	if (typeid(char).before(typeid(int)))
		chk(!typeid(int).before(typeid(char)));


	}
	end_chk("_1851T81");
#else
	skip_chk("_1851T81");
#endif /* CASE_1851T81 */

/* _1851T_101 type_info::name returns */
#if !defined(SKIP_1851T_101)&&(!defined(ONLY)||defined(CASE_1851T_101))
	begin_chk("_1851T_101");
	{
	const char *nm = typeid(int).name();
	chk(nm != 0 && 0 < STD strlen(nm));


	}
	end_chk("_1851T_101");
#else
	skip_chk("_1851T_101");
#endif /* CASE_1851T_101 */

/* _1851T_131 type_info::type_info, operator= effects */
#if !defined(SKIP_1851T_131)&&(!defined(ONLY)||defined(CASE_1851T_131))
	begin_chk("_1851T_131");
	{
	// UNTESTABLE
	chk(1);


	}
	end_chk("_1851T_131");
#else
	skip_chk("_1851T_131");
#endif /* CASE_1851T_131 */

/* _1852T11 bad_cast definition */
#if !defined(SKIP_1852T11)&&(!defined(ONLY)||defined(CASE_1852T11))
	begin_chk("_1852T11");
	{
	STD bad_cast *p; TOUCH(p);
	chk(1);


	}
	end_chk("_1852T11");
#else
	skip_chk("_1852T11");
#endif /* CASE_1852T11 */

/* _1852T31 bad_cast::bad_cast() effects */
#if !defined(SKIP_1852T31)&&(!defined(ONLY)||defined(CASE_1852T31))
	begin_chk("_1852T31");
	{
	STD bad_cast x;
	STD exception *pr = &x; TOUCH(pr);
	chk(1);


	}
	end_chk("_1852T31");
#else
	skip_chk("_1852T31");
#endif /* CASE_1852T31 */

/* _1852T51 bad_cast::bad_cast(const bad_cast&), operator= effects */
#if !defined(SKIP_1852T51)&&(!defined(ONLY)||defined(CASE_1852T51))
	begin_chk("_1852T51");
	{
	STD bad_cast x, y(x);
	x = y;
	chk(1);


	}
	end_chk("_1852T51");
#else
	skip_chk("_1852T51");
#endif /* CASE_1852T51 */

/* _1852T81 bad_cast::what returns */
#if !defined(SKIP_1852T81)&&(!defined(ONLY)||defined(CASE_1852T81))
	begin_chk("_1852T81");
	{
	STD bad_cast x;
	const char *s = x.what();
	chk(s != 0);


	}
	end_chk("_1852T81");
#else
	skip_chk("_1852T81");
#endif /* CASE_1852T81 */

/* _1853T11 bad_typeid definition */
#if !defined(SKIP_1853T11)&&(!defined(ONLY)||defined(CASE_1853T11))
	begin_chk("_1853T11");
	{
	STD bad_typeid *p; TOUCH(p);
	chk(1);


	}
	end_chk("_1853T11");
#else
	skip_chk("_1853T11");
#endif /* CASE_1853T11 */

/* _1853T31 bad_typeid::bad_typeid() effects */
#if !defined(SKIP_1853T31)&&(!defined(ONLY)||defined(CASE_1853T31))
	begin_chk("_1853T31");
	{
	STD bad_typeid x;
	STD exception *pr = &x; TOUCH(pr);
	chk(1);


	}
	end_chk("_1853T31");
#else
	skip_chk("_1853T31");
#endif /* CASE_1853T31 */

/* _1853T51 bad_typeid::bad_typeid(const bad_typeid&), operator= effects */
#if !defined(SKIP_1853T51)&&(!defined(ONLY)||defined(CASE_1853T51))
	begin_chk("_1853T51");
	{
	STD bad_typeid x, y(x);
	x = y;
	chk(1);


	}
	end_chk("_1853T51");
#else
	skip_chk("_1853T51");
#endif /* CASE_1853T51 */

/* _1853T81 bad_typeid::what returns */
#if !defined(SKIP_1853T81)&&(!defined(ONLY)||defined(CASE_1853T81))
	begin_chk("_1853T81");
	{
	STD bad_typeid x;
	const char *s = x.what();
	chk(s != 0);


	}
	end_chk("_1853T81");
#else
	skip_chk("_1853T81");
#endif /* CASE_1853T81 */

/* _186T21 <exception> synopsis */
#if !defined(SKIP_186T21)&&(!defined(ONLY)||defined(CASE_186T21))
	begin_chk("_186T21");
	{
	STD exception *pbc = 0; TOUCH(pbc);		// [JUL95]
	STD terminate_handler th; TOUCH(th);
	STD unexpected_handler uh; TOUCH(uh);
	STD terminate_handler (*pst)(STD terminate_handler) = &STD set_terminate; TOUCH(pst);
	STD unexpected_handler (*pun)(STD unexpected_handler) = &STD set_unexpected; TOUCH(pun);
	void (*pt)() = &STD terminate; TOUCH(pt);
	void (*pu)() = &STD unexpected; TOUCH(pu);
	chk(1);



	}
	end_chk("_186T21");
#else
	skip_chk("_186T21");
#endif /* CASE_186T21 */

/* _18611T11 bad_exception definition */
#if !defined(SKIP_18611T11)&&(!defined(ONLY)||defined(CASE_18611T11))
	begin_chk("_18611T11");
	{
	STD bad_exception *p; TOUCH(p);
	chk(1);


	}
	end_chk("_18611T11");
#else
	skip_chk("_18611T11");
#endif /* CASE_18611T11 */

/* _18611T31 bad_exception::bad_exception() effects */
#if !defined(SKIP_18611T31)&&(!defined(ONLY)||defined(CASE_18611T31))
	begin_chk("_18611T31");
	{
	STD bad_exception x;
	STD exception *pr = &x; TOUCH(pr);
	chk(1);


	}
	end_chk("_18611T31");
#else
	skip_chk("_18611T31");
#endif /* CASE_18611T31 */

/* _18611T51 bad_exception::bad_exception(const bad_exception&), operator= effects */
#if !defined(SKIP_18611T51)&&(!defined(ONLY)||defined(CASE_18611T51))
	begin_chk("_18611T51");
	{
	STD bad_exception x, y(x);
	x = y;
	chk(1);


	}
	end_chk("_18611T51");
#else
	skip_chk("_18611T51");
#endif /* CASE_18611T51 */

/* _18611T81 bad_exception::what returns */
#if !defined(SKIP_18611T81)&&(!defined(ONLY)||defined(CASE_18611T81))
	begin_chk("_18611T81");
	{
	STD bad_exception x;
	const char *s = x.what();
	chk(s != 0);


	}
	end_chk("_18611T81");
#else
	skip_chk("_18611T81");
#endif /* CASE_18611T81 */

/* _18612T11 unexpected_handler definition */
#if !defined(SKIP_18612T11)&&(!defined(ONLY)||defined(CASE_18612T11))
	begin_chk("_18612T11");
	{
	STD unexpected_handler uh = &unh_18612T11; TOUCH(uh);
	chk(1);


	}
	end_chk("_18612T11");
#else
	skip_chk("_18612T11");
#endif /* CASE_18612T11 */

/* _18612T31 unexpected handler default behavior */
#if !defined(SKIP_18612T31)&&(!defined(ONLY)||defined(CASE_18612T31))
	begin_chk("_18612T31");
	{
	STD terminate_handler th = STD set_terminate(&terh_18612T31); TOUCH(th);
	cnt_18612T31 = 0;
	if (setjmp(jbuf_18612T31) == 0)
		STD unexpected();
	ieq(cnt_18612T31, 1);
	STD set_terminate(th);


	}
	end_chk("_18612T31");
#else
	skip_chk("_18612T31");
#endif /* CASE_18612T31 */

/* _18613T11 set_unexpected effects */
#if !defined(SKIP_18613T11)&&(!defined(ONLY)||defined(CASE_18613T11))
	begin_chk("_18613T11");
	{
	STD unexpected_handler uh = STD set_unexpected(&unh_18613T11);
	cnt_18613T11 = 0;
	if (setjmp(jbuf_18613T11) == 0)
		STD unexpected();
	ieq(cnt_18613T11, 1);
	STD set_unexpected(uh);


	}
	end_chk("_18613T11");
#else
	skip_chk("_18613T11");
#endif /* CASE_18613T11 */

/* _18613T31 set_unexpected returns */
#if !defined(SKIP_18613T31)&&(!defined(ONLY)||defined(CASE_18613T31))
	begin_chk("_18613T31");
	{
	STD unexpected_handler uh = STD set_unexpected(&unh_18613T31);
	chk(STD set_unexpected(uh) == &unh_18613T31);


	}
	end_chk("_18613T31");
#else
	skip_chk("_18613T31");
#endif /* CASE_18613T31 */

/* _18614T21 unexpected() effects */
#if !defined(SKIP_18614T21)&&(!defined(ONLY)||defined(CASE_18614T21))
	begin_chk("_18614T21");
	{
	STD unexpected_handler uh = STD set_unexpected(&unh_18614T21);
	cnt_18614T21 = 0;
	if (setjmp(jbuf_18614T21) == 0)
		STD unexpected();
	ieq(cnt_18614T21, 1);
	STD set_unexpected(unh_18614T21);


	}
	end_chk("_18614T21");
#else
	skip_chk("_18614T21");
#endif /* CASE_18614T21 */

/* _18621T11 terminate_handler definition */
#if !defined(SKIP_18621T11)&&(!defined(ONLY)||defined(CASE_18621T11))
	begin_chk("_18621T11");
	{
	STD terminate_handler th = &terh_18621T11; TOUCH(th);
	chk(1);


	}
	end_chk("_18621T11");
#else
	skip_chk("_18621T11");
#endif /* CASE_18621T11 */

/* _18622T11 set_terminate effects */
#if !defined(SKIP_18622T11)&&(!defined(ONLY)||defined(CASE_18622T11))
	begin_chk("_18622T11");
	{
	STD terminate_handler th = STD set_terminate(&terh_18622T11);
	cnt_18622T11 = 0;
	if (setjmp(jbuf_18622T11) == 0)
		STD terminate();
	ieq(cnt_18622T11, 1);
	STD set_terminate(th);


	}
	end_chk("_18622T11");
#else
	skip_chk("_18622T11");
#endif /* CASE_18622T11 */

/* _18622T31 set_terminate returns */
#if !defined(SKIP_18622T31)&&(!defined(ONLY)||defined(CASE_18622T31))
	begin_chk("_18622T31");
	{
	STD terminate_handler th = STD set_terminate(&terh_18622T31);
	chk(STD set_terminate(th) == &terh_18622T31);


	}
	end_chk("_18622T31");
#else
	skip_chk("_18622T31");
#endif /* CASE_18622T31 */

/* _18623T21 terminate() effects */
#if !defined(SKIP_18623T21)&&(!defined(ONLY)||defined(CASE_18623T21))
	begin_chk("_18623T21");
	{
	STD terminate_handler th = STD set_terminate(&terh_18623T21);
	cnt_18623T21 = 0;
	if (setjmp(jbuf_18623T21) == 0)
		STD terminate();
	ieq(cnt_18623T21, 1);
	STD set_terminate(th);


	}
	end_chk("_18623T21");
#else
	skip_chk("_18623T21");
#endif /* CASE_18623T21 */

/* _187T21 Table 28: <cstdarg> synopsis */
#if !defined(SKIP_187T21)&&(!defined(ONLY)||defined(CASE_187T21))
	begin_chk("_187T21");
	{
	ieq(fun_187T21(1, 3), 3);




	}
	end_chk("_187T21");
#else
	skip_chk("_187T21");
#endif /* CASE_187T21 */

/* _187T31 Table 28 [sic]: <csetjmp> synopsis */
#if !defined(SKIP_187T31)&&(!defined(ONLY)||defined(CASE_187T31))
	begin_chk("_187T31");
	{
	cnt_187T31 = 0;
	if (setjmp(jbuf_187T31) == 0)
		{fun_187T31();
		chk("shouldn't get here" == 0); }
	ieq(cnt_187T31, 1);


	}
	end_chk("_187T31");
#else
	skip_chk("_187T31");
#endif /* CASE_187T31 */

/* _187T41 Table 28 [sic]: <ctime> synopsis */
#if !defined(SKIP_187T41)&&(!defined(ONLY)||defined(CASE_187T41))
	begin_chk("_187T41");
	{
	clock_t ticks = clock();
	chk(0 < CLOCKS_PER_SEC);
	chk(ticks <= clock());


	}
	end_chk("_187T41");
#else
	skip_chk("_187T41");
#endif /* CASE_187T41 */

/* _187T51 Table 28 [sic]: <csignal> synopsis */
#if !defined(SKIP_187T51)&&(!defined(ONLY)||defined(CASE_187T51))
	begin_chk("_187T51");
	{
	TOUCH(sigs_187T51);
	TOUCH(ret1_187T51);
	TOUCH(ret2_187T51);
	TOUCH(ret3_187T51);
	sig_atomic_t x = 3; TOUCH(x);
	ps_187T51 = signal(SIGFPE, &fpe_187T51);
	raise(SIGFPE);
	ieq(cnt_187T51, 1);
	signal(SIGFPE, ps_187T51);


	}
	end_chk("_187T51");
#else
	skip_chk("_187T51");
#endif /* CASE_187T51 */

/* _187T61 Table 28 [sic]: <cstdlib> synopsis */
#if !defined(SKIP_187T61)&&(!defined(ONLY)||defined(CASE_187T61))
	begin_chk("_187T61");
	{
	//getenv("TZ");
	//system(0);
	chk(1);

	}
	end_chk("_187T61");
#else
	skip_chk("_187T61");
#endif /* CASE_187T61 */

return leave_chk("t183");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t230.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"

#if IS_EMBEDDED
#define ONLY
//#define CASE_232T11	<bitset> synopsis
#define CASE_232T21	<deque> synopsis
#define CASE_232T31	<list> synopsis
#define CASE_232T41	<queue> synopsis
#define CASE_232T51	<stack> synopsis
#define CASE_232T61	<vector> synopsis
#else /* IS_EMBEDDED */
#endif /* IS_EMBEDDED */

/* _232T11 <bitset> synopsis */
#if !defined(SKIP_232T11)&&(!defined(ONLY)||defined(CASE_232T11))
#if DISALLOW_USER_NAME_PROTECTION
 #include <bitset>
#else
	#define toggle	"toggle"	/* looking for trouble */
	#define bits	"bits"
 #include <bitset>
	#undef bits
	#undef toggle
#endif
#include <sstream>
#endif /* CASE_232T11 */

/* _232T21 <deque> synopsis */
#if !defined(SKIP_232T21)&&(!defined(ONLY)||defined(CASE_232T21))
#include <deque>
#endif /* CASE_232T21 */

/* _232T31 <list> synopsis */
#if !defined(SKIP_232T31)&&(!defined(ONLY)||defined(CASE_232T31))
#include <list>
#endif /* CASE_232T31 */

/* _232T41 <queue> synopsis */
#if !defined(SKIP_232T41)&&(!defined(ONLY)||defined(CASE_232T41))
#include <functional>
#include <list>
#include <queue>
#include <vector>
#endif /* CASE_232T41 */

/* _232T51 <stack> synopsis */
#if !defined(SKIP_232T51)&&(!defined(ONLY)||defined(CASE_232T51))
#include <stack>
#include <vector>
#endif /* CASE_232T51 */

/* _232T61 <vector> synopsis */
#if !defined(SKIP_232T61)&&(!defined(ONLY)||defined(CASE_232T61))
#include <vector>
#endif /* CASE_232T61 */

int t230_main(int, char *[])
{
enter_chk("t230.cpp");
/* _232T11 <bitset> synopsis */
#if !defined(SKIP_232T11)&&(!defined(ONLY)||defined(CASE_232T11))
	begin_chk("_232T11");
	{
	typedef bitset<23> Cont;
	Cont v0, v1;
	v0 = v0 & v1;
	v0 = v0 | v1;
	v0 = v0 ^ v1;
	istringstream is;
	is >> v0;
	ostringstream os;
	os << v0; 
	chk(1);


	}
	end_chk("_232T11");
#else
	skip_chk("_232T11");
#endif /* CASE_232T11 */

/* _232T21 <deque> synopsis */
#if !defined(SKIP_232T21)&&(!defined(ONLY)||defined(CASE_232T21))
	begin_chk("_232T21");
	{
	typedef deque<Char, ALLOCATOR(Char)> Cont;
	Cont v0;
	chk(v0 == v0);
	chk(!(v0 < v0));


	}
	end_chk("_232T21");
#else
	skip_chk("_232T21");
#endif /* CASE_232T21 */

/* _232T31 <list> synopsis */
#if !defined(SKIP_232T31)&&(!defined(ONLY)||defined(CASE_232T31))
	begin_chk("_232T31");
	{
	typedef list<Char, ALLOCATOR(Char)> Cont;
	Cont v0;
	chk(v0 == v0);
	chk(!(v0 < v0));


	}
	end_chk("_232T31");
#else
	skip_chk("_232T31");
#endif /* CASE_232T31 */

/* _232T41 <queue> synopsis */
#if !defined(SKIP_232T41)&&(!defined(ONLY)||defined(CASE_232T41))
	begin_chk("_232T41");
	{
	typedef list<Char, ALLOCATOR(Char)> Cont1;
	typedef queue<Char, Cont1> Adap1;	// CHANGED [JUL96]
	Adap1 v0;
	chk(v0 == v0);
	chk(!(v0 < v0));
	typedef vector<Char, ALLOCATOR(Char)> Cont2;
	typedef priority_queue<Char, Cont2,
		less<Cont2::value_type> > Adap2;	// CHANGED [JUL96]
	Adap2 vp0;


	}
	end_chk("_232T41");
#else
	skip_chk("_232T41");
#endif /* CASE_232T41 */

/* _232T51 <stack> synopsis */
#if !defined(SKIP_232T51)&&(!defined(ONLY)||defined(CASE_232T51))
	begin_chk("_232T51");
	{
	typedef vector<Char, ALLOCATOR(Char)> Cont;
	typedef stack<Char, Cont> Adap;	// CHANGED [JUL96]
	Adap v0;
	chk(v0 == v0);
	chk(!(v0 < v0));


	}
	end_chk("_232T51");
#else
	skip_chk("_232T51");
#endif /* CASE_232T51 */

/* _232T61 <vector> synopsis */
#if !defined(SKIP_232T61)&&(!defined(ONLY)||defined(CASE_232T61))
	begin_chk("_232T61");
	{
	typedef vector<Char, ALLOCATOR(Char)> Cont;
	Cont v0;
	chk(v0 == v0);
	chk(!(v0 < v0));
	typedef vector<bool, ALLOCATOR(bool)> Bvec;
	Bvec v1;
	chk(v1 == v1);
	chk(!(v1 < v1));

	}
	end_chk("_232T61");
#else
	skip_chk("_232T61");
#endif /* CASE_232T61 */

return leave_chk("t230");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t217.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"

#if IS_EMBEDDED
#define ONLY
//#define CASE_2114T11	definition of char_traits<wchar_t>, wstring
//#define CASE_2115T21	char_traits<wchar_t>::assign effects
//#define CASE_2115T41	char_traits<wchar_t>::eq returns
//#define CASE_2115T81	char_traits<wchar_t>::lt returns
//#define CASE_2115T_181	char_traits<wchar_t>::compare returns
//#define CASE_2115T_201	char_traits<wchar_t>::length returns
//#define CASE_2115T_221	char_traits<wchar_t>::copy returns
#define CASE_212T12	<cctype> synopsis
//#define CASE_212T13	<cwctype> synopsis
#define CASE_212T14	<cstring> synopsis
//#define CASE_212T15	<cwchar> synopsis
#define CASE_212T16	<cstdlib> synopsis
#define CASE_212T51	strchr declarations
#define CASE_212T71	strpbrk declarations
#define CASE_212T91	strrchr declarations
#define CASE_212T_111	strstr declarations
#define CASE_212T_131	memchr declarations
//#define CASE_212T_151	wcschr declarations
//#define CASE_212T_171	wcspbrk declarations
//#define CASE_212T_191	wcsrchr declarations
//#define CASE_212T_211	wcsstr declarations
//#define CASE_212T_231	wmemchr declarations
#endif /* IS_EMBEDDED */

/* _2114T11 definition of char_traits<wchar_t>, wstring */
#if !defined(SKIP_2114T11)&&(!defined(ONLY)||defined(CASE_2114T11))
#include <sstream>
#include <string>
#endif /* CASE_2114T11 */

/* _2115T21 char_traits<wchar_t>::assign effects */
#if !defined(SKIP_2115T21)&&(!defined(ONLY)||defined(CASE_2115T21))
#include <string>
#endif /* CASE_2115T21 */

/* _2115T41 char_traits<wchar_t>::eq returns */
#if !defined(SKIP_2115T41)&&(!defined(ONLY)||defined(CASE_2115T41))
#include <string>
#endif /* CASE_2115T41 */

/* _2115T81 char_traits<wchar_t>::lt returns */
#if !defined(SKIP_2115T81)&&(!defined(ONLY)||defined(CASE_2115T81))
#include <string>
#endif /* CASE_2115T81 */

/* _2115T_181 char_traits<wchar_t>::compare returns */
#if !defined(SKIP_2115T_181)&&(!defined(ONLY)||defined(CASE_2115T_181))
#include <string>
#endif /* CASE_2115T_181 */

/* _2115T_201 char_traits<wchar_t>::length returns */
#if !defined(SKIP_2115T_201)&&(!defined(ONLY)||defined(CASE_2115T_201))
#include <string>
#endif /* CASE_2115T_201 */

/* _2115T_221 char_traits<wchar_t>::copy returns */
#if !defined(SKIP_2115T_221)&&(!defined(ONLY)||defined(CASE_2115T_221))
#include <string>
#endif /* CASE_2115T_221 */

/* _212T12 <cctype> synopsis */
#if !defined(SKIP_212T12)&&(!defined(ONLY)||defined(CASE_212T12))
#include <cctype>
#endif /* CASE_212T12 */

/* _212T13 <cwctype> synopsis */
#if !defined(SKIP_212T13)&&(!defined(ONLY)||defined(CASE_212T13))
#include <cwctype>
#endif /* CASE_212T13 */

/* _212T14 <cstring> synopsis */
#if !defined(SKIP_212T14)&&(!defined(ONLY)||defined(CASE_212T14))
#include <cstring>
#endif /* CASE_212T14 */

/* _212T15 <cwchar> synopsis */
#if !defined(SKIP_212T15)&&(!defined(ONLY)||defined(CASE_212T15))
#include <cwchar>
#endif /* CASE_212T15 */

/* _212T16 <cstdlib> synopsis */
#if !defined(SKIP_212T16)&&(!defined(ONLY)||defined(CASE_212T16))
#include <cstdlib>
#endif /* CASE_212T16 */

/* _212T51 strchr declarations */
#if !defined(SKIP_212T51)&&(!defined(ONLY)||defined(CASE_212T51))
#include <cstring>
#endif /* CASE_212T51 */

/* _212T71 strpbrk declarations */
#if !defined(SKIP_212T71)&&(!defined(ONLY)||defined(CASE_212T71))
#include <cstring>
#endif /* CASE_212T71 */

/* _212T91 strrchr declarations */
#if !defined(SKIP_212T91)&&(!defined(ONLY)||defined(CASE_212T91))
#include <cstring>
#endif /* CASE_212T91 */

/* _212T_111 strstr declarations */
#if !defined(SKIP_212T_111)&&(!defined(ONLY)||defined(CASE_212T_111))
#include <cstring>
#endif /* CASE_212T_111 */

/* _212T_131 memchr declarations */
#if !defined(SKIP_212T_131)&&(!defined(ONLY)||defined(CASE_212T_131))
#include <cstring>
#endif /* CASE_212T_131 */

/* _212T_151 wcschr declarations */
#if !defined(SKIP_212T_151)&&(!defined(ONLY)||defined(CASE_212T_151))
#include <cwchar>
#endif /* CASE_212T_151 */

/* _212T_171 wcspbrk declarations */
#if !defined(SKIP_212T_171)&&(!defined(ONLY)||defined(CASE_212T_171))
#include <cwchar>
#endif /* CASE_212T_171 */

/* _212T_191 wcsrchr declarations */
#if !defined(SKIP_212T_191)&&(!defined(ONLY)||defined(CASE_212T_191))
#include <cwchar>
#endif /* CASE_212T_191 */

/* _212T_211 wcsstr declarations */
#if !defined(SKIP_212T_211)&&(!defined(ONLY)||defined(CASE_212T_211))
#include <cwchar>
#endif /* CASE_212T_211 */

/* _212T_231 wmemchr declarations */
#if !defined(SKIP_212T_231)&&(!defined(ONLY)||defined(CASE_212T_231))
#include <cwchar>
#endif /* CASE_212T_231 */

int t217_main(int, char *[])
{
enter_chk("t217.cpp");
/* _2114T11 definition of char_traits<wchar_t>, wstring */
#if !defined(SKIP_2114T11)&&(!defined(ONLY)||defined(CASE_2114T11))
	begin_chk("_2114T11");
	{
	typedef STD char_traits<wchar_t> Strt;
	wchar_t c1;
	Strt::char_type *p0 = &c1; TOUCH(p0);
	typedef STD basic_string<wchar_t, Strt, ALLOCATOR(wchar_t)> Str;
	STD wstring *p1 = (Str *)0; TOUCH(p1);
	STD wstring s1, s2(20, L'a');
	const wchar_t abc[] = {L'a', L'b', L'c', 0};
	const wchar_t def[] = {L'd', L'e', L'f', 0};
	s1 = (abc + s1) + (s1 + def) + (L'g' + s1) + (s1 + L'h');
	bool t1 = s1 == s2 || s1 == abc || def == s1;
	t1 = s1 != s2 || s1 != abc || def != s1;
	t1 = s1 < s2 || s1 < abc || def < s1;
	t1 = s1 > s2 || s1 > abc || def > s1;
	t1 = s1 <= s2 || s1 <= abc || def <= s1;
	t1 = s1 >= s2 || s1 >= abc || def >= s1;
	const wchar_t s1s2[] = {L's', L'1', L' ', L's', L'2', L'\n', 0};
	const STD wstring input(s1s2);
	STD wistringstream ins(input);
	ins >> s1;
	STD getline(ins, s1, L'\n');
	STD wostringstream outs;
	outs << s1;
	chk(1);



	}
	end_chk("_2114T11");
#else
	skip_chk("_2114T11");
#endif /* CASE_2114T11 */

/* _2115T21 char_traits<wchar_t>::assign effects */
#if !defined(SKIP_2115T21)&&(!defined(ONLY)||defined(CASE_2115T21))
	begin_chk("_2115T21");
	{
	typedef STD char_traits<wchar_t> Strt;
	wchar_t x1 = 0, x2 = (wchar_t)(-3);
	Strt::assign(x1, x2);
	ieq(x1, (wchar_t)(-3));


	}
	end_chk("_2115T21");
#else
	skip_chk("_2115T21");
#endif /* CASE_2115T21 */

/* _2115T41 char_traits<wchar_t>::eq returns */
#if !defined(SKIP_2115T41)&&(!defined(ONLY)||defined(CASE_2115T41))
	begin_chk("_2115T41");
	{
	typedef STD char_traits<wchar_t> Strt;
	wchar_t x1 = 0, x2 = (wchar_t)(-3);
	chk(!Strt::eq(x1, x2));
	chk(Strt::eq(x1, x1));


	//###T_2115T61 string_char_traits<wchar_t>::ne returns	DROPPED [MAR96]
	//FILE-SCOPE:
	//#include <string>
	//BLOCK-SCOPE:
	//typedef STD string_char_traits<wchar_t> Strt;
	//wchar_t x1 = 0, x2 = -3;
	//chk(!Strt::ne(x1, x1));
	//chk(Strt::ne(x1, x2));


	}
	end_chk("_2115T41");
#else
	skip_chk("_2115T41");
#endif /* CASE_2115T41 */

/* _2115T81 char_traits<wchar_t>::lt returns */
#if !defined(SKIP_2115T81)&&(!defined(ONLY)||defined(CASE_2115T81))
	begin_chk("_2115T81");
	{
	typedef STD char_traits<wchar_t> Strt;
	wchar_t x1 = 0, x2 = 3;
	chk(Strt::lt(x1, x2));
	chk(!Strt::lt(x1, x1));


	//### _2115T_101 string_char_traits<wchar_t>::eos returns	DROPPED [MAR96]
	//FILE-SCOPE:
	//#include <string>
	//BLOCK-SCOPE:
	//typedef STD string_char_traits<wchar_t> Strt;
	//ieq(Strt::eos(), 0);


	}
	end_chk("_2115T81");
#else
	skip_chk("_2115T81");
#endif /* CASE_2115T81 */

/* _2115T_181 char_traits<wchar_t>::compare returns */
#if !defined(SKIP_2115T_181)&&(!defined(ONLY)||defined(CASE_2115T_181))
	begin_chk("_2115T_181");
	{
	typedef STD char_traits<wchar_t> Strt;
	const wchar_t str1[] = {'a', 'b', '1', 0};
	const wchar_t str2[] = {'a', 'b', '2', 0};
	ieq(Strt::compare(str1, str2, 3), -1);
	ieq(Strt::compare(str1, str2, 2), 0);
	ieq(Strt::compare(&str2[1], &str1[1], 3), 1);


	}
	end_chk("_2115T_181");
#else
	skip_chk("_2115T_181");
#endif /* CASE_2115T_181 */

/* _2115T_201 char_traits<wchar_t>::length returns */
#if !defined(SKIP_2115T_201)&&(!defined(ONLY)||defined(CASE_2115T_201))
	begin_chk("_2115T_201");
	{
	typedef STD char_traits<wchar_t> Strt;
	const wchar_t str1[] = {'a', 'b', '1', 0};
	ieq(Strt::length(str1), 3);
	ieq(Strt::length(&str1[3]), 0);


	}
	end_chk("_2115T_201");
#else
	skip_chk("_2115T_201");
#endif /* CASE_2115T_201 */

/* _2115T_221 char_traits<wchar_t>::copy returns */
#if !defined(SKIP_2115T_221)&&(!defined(ONLY)||defined(CASE_2115T_221))
	begin_chk("_2115T_221");
	{
	typedef STD char_traits<wchar_t> Strt;
	wchar_t str1[10] = {0};
	const wchar_t str2[] = {L'a', L'b', L'2', 0};
	chk(Strt::copy(str1, str2, 0) == str1);
	ieq(str1[0], 0);
	chk(Strt::copy(str1, str2, 2) == str1);
	const wchar_t str3[] = {L'a', L'b', 0};
	ieq(STD wmemcmp(str1, str3, 3), 0);
	chk(Strt::copy(&str1[2], str1, 4) == &str1[2]);
	const wchar_t str4[] = {L'a', L'b', L'a', L'b', L'a', L'b', 0};
	ieq(STD memcmp(str1, str4, 7), 0);


	}
	end_chk("_2115T_221");
#else
	skip_chk("_2115T_221");
#endif /* CASE_2115T_221 */

/* _212T12 <cctype> synopsis */
#if !defined(SKIP_212T12)&&(!defined(ONLY)||defined(CASE_212T12))
	begin_chk("_212T12");
	{
	int c; TOUCH(c);
	c = isalnum('x');
	c = isalpha('x');
	c = iscntrl('x');
	c = isdigit('x');
	c = isgraph('x');
	c = islower('x');
	c = isprint('x');
	c = ispunct('x');
	c = isspace('x');
	c = isupper('x');
	c = isxdigit('x');
	c = tolower('x');
	c = toupper('x');
	chk(1);




	}
	end_chk("_212T12");
#else
	skip_chk("_212T12");
#endif /* CASE_212T12 */

/* _212T13 <cwctype> synopsis */
#if !defined(SKIP_212T13)&&(!defined(ONLY)||defined(CASE_212T13))
	begin_chk("_212T13");
	{
	wint_t weof = WEOF; TOUCH(weof);
	wctrans_t wctr = wctrans("tolower");
	wctype_t wcty = wctype("alpha");
	int c = iswalnum(L'x');
	c = iswalpha(L'x');
	c = iswcntrl(L'x');
	c = iswdigit(L'x');
	c = iswgraph(L'x');
	c = iswlower(L'x');
	c = iswprint(L'x');
	c = iswpunct(L'x');
	c = iswspace(L'x');
	c = iswupper(L'x');
	c = iswxdigit(L'x');
	wint_t ch; TOUCH(ch);
	ch = towlower(L'x');
	ch = towupper(L'x');
	chk(1);



	}
	end_chk("_212T13");
#else
	skip_chk("_212T13");
#endif /* CASE_212T13 */

/* _212T14 <cstring> synopsis */
#if !defined(SKIP_212T14)&&(!defined(ONLY)||defined(CASE_212T14))
	begin_chk("_212T14");
	{
	void *pn = NULL; TOUCH(pn);
	size_t szt = sizeof (pn); TOUCH(szt);
	char a[10], *p; TOUCH(p);
	const char *pc; TOUCH(pc);
	const char *s1 = "abcd";
	const char *s2 = "efgh";
	int i; TOUCH(i);
	i = strcmp(s1, s2);
	i = strcoll(s1, s2);
	p = strcpy(a, s1);
	szt = strcspn(s1, s2);
	p = strerror(0);
	szt = strlen(s1);
	p = strncat(a, s2, 2);
	i = strncmp(s1, s2, 4);
	p = strncpy(a, s2, 3);
	szt = strspn(s1, s2);
	p = strtok(a, s2);
	szt = strxfrm(a, s1, 6);
	pc = strchr(s1, 'c');
	pc = strpbrk(s1, s2);
	pc = strrchr(s1, 'c');
	pc = strstr(s1, s2);


	}
	end_chk("_212T14");
#else
	skip_chk("_212T14");
#endif /* CASE_212T14 */

/* _212T15 <cwchar> synopsis */
#if !defined(SKIP_212T15)&&(!defined(ONLY)||defined(CASE_212T15))
	begin_chk("_212T15");
	{
	void *pn = NULL; TOUCH(pn);
	wchar_t wmin = WCHAR_MIN; TOUCH(wmin);
	wchar_t wmax = WCHAR_MAX; TOUCH(wmax);
	wint_t weof = WEOF; TOUCH(weof);
	mbstate_t mbst = {0}; TOUCH(mbst);
	typedef void (*Pf)(void);
	Pf ptrs[] = {(Pf)&fgetwc, (Pf)&fgetws, (Pf)&fputwc, (Pf)&fputws,
		(Pf)&fwide, (Pf)&fwprintf, (Pf)&fwscanf, (Pf)&getwc, (Pf)&getwchar,
		(Pf)&putwc, (Pf)&putwchar, (Pf)&swprintf, (Pf)&swscanf, (Pf)&ungetwc,
		(Pf)&vfwprintf, (Pf)&vswprintf, (Pf)&vwprintf, (Pf)&wprintf,
		(Pf)&wscanf, (Pf)&mbrlen, (Pf)&mbrtowc, (Pf)&mbsrtowcs, (Pf)&mbsinit,
		(Pf)&wcrtomb, (Pf)&wcsrtombs, (Pf)&wcstol, (Pf)&wcscat, (Pf)&wcscmp,
		(Pf)&wcscoll, (Pf)&wcscpy, (Pf)&wcscspn, (Pf)&wcslen, (Pf)&wcsncat,
		(Pf)&wcsncmp, (Pf)&wcsncpy, (Pf)&wcsspn, (Pf)&wcstok, (Pf)&wcsxfrm,
		(Pf)&wmemcmp, (Pf)&wmemcpy, (Pf)&wmemmove, (Pf)&wmemset, (Pf)&wcsftime,
		(Pf)&btowc, (Pf)&wcstod, (Pf)&wcstoul, (Pf)&wctob}; TOUCH(ptrs);
	const wchar_t *pc; TOUCH(pc);
	const wchar_t s1[] = {L'a', L'b', L'c', L'd', 0};
	const wchar_t s2[] = {L'e', L'f', L'g', L'h', 0};
	pc = wmemchr(s1, 4, L'c');
	pc = wcschr(s1, L'c');
	pc = wcspbrk(s1, s2);
	pc = wcsrchr(s1, L'c');
	pc = wcsstr(s1, s2);
	chk(1);


	}
	end_chk("_212T15");
#else
	skip_chk("_212T15");
#endif /* CASE_212T15 */

/* _212T16 <cstdlib> synopsis */
#if !defined(SKIP_212T16)&&(!defined(ONLY)||defined(CASE_212T16))
	begin_chk("_212T16");
	{
	size_t mbmax = MB_CUR_MAX; TOUCH(mbmax);
	typedef void (*Pf)(void);
	Pf ptrs[] = {(Pf)&atol, (Pf)&atof, (Pf)&atoi, (Pf)&mblen,
		(Pf)&mbstowcs, (Pf)&mbtowc, (Pf)&strtod, (Pf)&strtol, (Pf)&strtoul,
		(Pf)&wctomb, (Pf)&wcstombs}; TOUCH(ptrs);
	chk(1);


	}
	end_chk("_212T16");
#else
	skip_chk("_212T16");
#endif /* CASE_212T16 */

/* _212T51 strchr declarations */
#if !defined(SKIP_212T51)&&(!defined(ONLY)||defined(CASE_212T51))
	begin_chk("_212T51");
	{
	const char *pc = strchr((const char *)"abcd", 'b');
	chk(pc != 0);
	if (pc != 0)
		ieq(*pc, 'b');
	char *p = strchr((char *)"abcd", 'b');
	chk(p != 0);
	if (p != 0)
		ieq(*p, 'b');


	}
	end_chk("_212T51");
#else
	skip_chk("_212T51");
#endif /* CASE_212T51 */

/* _212T71 strpbrk declarations */
#if !defined(SKIP_212T71)&&(!defined(ONLY)||defined(CASE_212T71))
	begin_chk("_212T71");
	{
	const char *pc = strpbrk((const char *)"abcd", "b");
	chk(pc != 0);
	if (pc != 0)
		ieq(*pc, 'b');
	char *p = strpbrk((char *)"abcd", "b");
	chk(p != 0);
	if (p != 0)
		ieq(*p, 'b');


	}
	end_chk("_212T71");
#else
	skip_chk("_212T71");
#endif /* CASE_212T71 */

/* _212T91 strrchr declarations */
#if !defined(SKIP_212T91)&&(!defined(ONLY)||defined(CASE_212T91))
	begin_chk("_212T91");
	{
	const char *pc = strrchr((const char *)"abcd", 'b');
	chk(pc != 0);
	if (pc != 0)
		ieq(*pc, 'b');
	char *p = strrchr((char *)"abcd", 'b');
	chk(p != 0);
	if (p != 0)
		ieq(*p, 'b');


	}
	end_chk("_212T91");
#else
	skip_chk("_212T91");
#endif /* CASE_212T91 */

/* _212T_111 strstr declarations */
#if !defined(SKIP_212T_111)&&(!defined(ONLY)||defined(CASE_212T_111))
	begin_chk("_212T_111");
	{
	const char *pc = strstr((const char *)"abcd", "b");
	chk(pc != 0);
	if (pc != 0)
		ieq(*pc, 'b');
	char *p = strstr((char *)"abcd", "b");
	chk(p != 0);
	if (p != 0)
		ieq(*p, 'b');


	}
	end_chk("_212T_111");
#else
	skip_chk("_212T_111");
#endif /* CASE_212T_111 */

/* _212T_131 memchr declarations */
#if !defined(SKIP_212T_131)&&(!defined(ONLY)||defined(CASE_212T_131))
	begin_chk("_212T_131");
	{
	const void *pc = memchr((const char *)"abcd", 'b', 4);
	chk(pc != 0);
	if (pc != 0)
		ieq(*(const char *)pc, 'b');
	void *p = memchr((char *)"abcd", 'b', 4);
	chk(p != 0);
	if (p != 0)
		ieq(*(const char *)p, 'b');


	}
	end_chk("_212T_131");
#else
	skip_chk("_212T_131");
#endif /* CASE_212T_131 */

/* _212T_151 wcschr declarations */
#if !defined(SKIP_212T_151)&&(!defined(ONLY)||defined(CASE_212T_151))
	begin_chk("_212T_151");
	{
	const wchar_t s1[] = {L'a', L'b', L'c', L'd', 0};
	const wchar_t *pc = wcschr(s1, L'b');
	chk(pc != 0);
	if (pc != 0)
		ieq(*pc, L'b');
	wchar_t *p = wcschr((wchar_t *)s1, L'b');
	chk(p != 0);
	if (p != 0)
		ieq(*p, L'b');


	}
	end_chk("_212T_151");
#else
	skip_chk("_212T_151");
#endif /* CASE_212T_151 */

/* _212T_171 wcspbrk declarations */
#if !defined(SKIP_212T_171)&&(!defined(ONLY)||defined(CASE_212T_171))
	begin_chk("_212T_171");
	{
	const wchar_t s1[] = {L'a', L'b', L'c', L'd', 0};
	const wchar_t s2[] = {L'b', 0};
	const wchar_t *pc = wcspbrk(s1, s2);
	chk(pc != 0);
	if (pc != 0)
		ieq(*pc, L'b');
	wchar_t *p = wcspbrk((wchar_t *)s1, s2);
	chk(p != 0);
	if (p != 0)
		ieq(*p, L'b');


	}
	end_chk("_212T_171");
#else
	skip_chk("_212T_171");
#endif /* CASE_212T_171 */

/* _212T_191 wcsrchr declarations */
#if !defined(SKIP_212T_191)&&(!defined(ONLY)||defined(CASE_212T_191))
	begin_chk("_212T_191");
	{
	const wchar_t s1[] = {L'a', L'b', L'c', L'd', 0};
	const wchar_t *pc = wcsrchr(s1, L'b');
	chk(pc != 0);
	if (pc != 0)
		ieq(*pc, L'b');
	wchar_t *p = wcsrchr((wchar_t *)s1, L'b');
	chk(p != 0);
	if (p != 0)
		ieq(*p, L'b');


	}
	end_chk("_212T_191");
#else
	skip_chk("_212T_191");
#endif /* CASE_212T_191 */

/* _212T_211 wcsstr declarations */
#if !defined(SKIP_212T_211)&&(!defined(ONLY)||defined(CASE_212T_211))
	begin_chk("_212T_211");
	{
	const wchar_t s1[] = {L'a', L'b', L'c', L'd', 0};
	const wchar_t s2[] = {L'b', 0};
	const wchar_t *pc = wcsstr(s1, s2);
	chk(pc != 0);
	if (pc != 0)
		ieq(*pc, L'b');
	wchar_t *p = wcsstr((wchar_t *)s1, s2);
	chk(p != 0);
	if (p != 0)
		ieq(*p, L'b');


	}
	end_chk("_212T_211");
#else
	skip_chk("_212T_211");
#endif /* CASE_212T_211 */

/* _212T_231 wmemchr declarations */
#if !defined(SKIP_212T_231)&&(!defined(ONLY)||defined(CASE_212T_231))
	begin_chk("_212T_231");
	{
	const wchar_t s1[] = {L'a', L'b', L'c', L'd', 0};
	const wchar_t *pc = wmemchr(s1, L'b', 4);
	chk(pc != 0);
	if (pc != 0)
		ieq(*pc, L'b');
	wchar_t *p = wmemchr((wchar_t *)s1, L'b', 4);
	chk(p != 0);
	if (p != 0)
		ieq(*p, L'b');

	}
	end_chk("_212T_231");
#else
	skip_chk("_212T_231");
#endif /* CASE_212T_231 */

return leave_chk("t217");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t212.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"

#if IS_EMBEDDED
#define ONLY
#define CASE_21115T21	basic_string::begin() returns
#define CASE_21115T41	basic_string::end() returns
#define CASE_21115T61	basic_string::rbegin() returns
#define CASE_21115T81	basic_string::rend() returns
#define CASE_21116T21	basic_string::size() returns
#define CASE_21116T51	basic_string::length() returns
#define CASE_21116T71	basic_string::max_size() returns
//#define CASE_21116T91	basic_string::resize(size_type, charT) throws
#define CASE_21116T_111	basic_string::resize(size_type, charT) for n <= size()
#define CASE_21116T_121	basic_string::resize(size_type, charT) for n > size()
#define CASE_21116T_141	basic_string::resize(size_type) effects
#define CASE_21116T_171	basic_string::capacity() returns
#define CASE_21116T_201	basic_string::reserve effects
#define CASE_21116T_211	basic_string::reserve complexity
#define CASE_21116T_222	basic_string::reserve notes
#define CASE_21116T_241	basic_string::empty() returns
#define CASE_21117T21	basic_string::operator[]() returns
//#define CASE_21117T51	basic_string::at() throws
#define CASE_21117T61	basic_string::at() returns
#define CASE_211181T21	basic_string::operator+=(const basic_string&) returns
#define CASE_211181T41	basic_string::operator+=(const charT *) returns
//#define CASE_211181T51	basic_string::operator+=(const charT *) notes
#define CASE_211181T71	basic_string::operator+=(charT) returns
//#define CASE_211182T31	basic_string::append(const basic_string) throws
//#define CASE_211182T42	basic_string::append() effects, throws length_error
#define CASE_211182T51	basic_string::append(const basic_string&), effects replacement
#define CASE_211182T61	basic_string::append(const basic_string&) returns
#define CASE_211182T81	basic_string::append(const charT *, size_type) returns
#define CASE_211182T_101	basic_string::append(const charT *) returns
//#define CASE_211182T_111	basic_string::append(const CharT*) notes
#define CASE_211182T_131	basic_string::append(size_type, charT) returns
#define CASE_211182T_151	basic_string::append(InIt, InIt) returns
//#define CASE_211183T31	basic_string::assign(const basic_string) throws
#define CASE_211183T42	basic_string::assign(const basic_string&), effects
#define CASE_211183T51	basic_string::assign(const basic_string&) returns
#define CASE_211183T71	basic_string::assign(const charT *, size_type) returns
#define CASE_211183T91	basic_string::assign(const charT *) returns
//#define CASE_211183T_101	basic_string::assign(const CharT*) notes
#define CASE_211183T_121	basic_string::assign(size_type, charT) returns
#define CASE_211183T_141	basic_string::assign(InIt, InIt) returns
#endif /* IS_EMBEDDED */

/* _21115T21 basic_string::begin() returns */
#if !defined(SKIP_21115T21)&&(!defined(ONLY)||defined(CASE_21115T21))
#include <string>
#endif /* CASE_21115T21 */

/* _21115T41 basic_string::end() returns */
#if !defined(SKIP_21115T41)&&(!defined(ONLY)||defined(CASE_21115T41))
#include <string>
#endif /* CASE_21115T41 */

/* _21115T61 basic_string::rbegin() returns */
#if !defined(SKIP_21115T61)&&(!defined(ONLY)||defined(CASE_21115T61))
#include <string>
#endif /* CASE_21115T61 */

/* _21115T81 basic_string::rend() returns */
#if !defined(SKIP_21115T81)&&(!defined(ONLY)||defined(CASE_21115T81))
#include <string>
#endif /* CASE_21115T81 */

/* _21116T21 basic_string::size() returns */
#if !defined(SKIP_21116T21)&&(!defined(ONLY)||defined(CASE_21116T21))
#include <string>
#endif /* CASE_21116T21 */

/* _21116T51 basic_string::length() returns */
#if !defined(SKIP_21116T51)&&(!defined(ONLY)||defined(CASE_21116T51))
#include <string>
#endif /* CASE_21116T51 */

/* _21116T71 basic_string::max_size() returns */
#if !defined(SKIP_21116T71)&&(!defined(ONLY)||defined(CASE_21116T71))
#include <string>
#endif /* CASE_21116T71 */

/* _21116T91 basic_string::resize(size_type, charT) throws */
#if !defined(SKIP_21116T91)&&(!defined(ONLY)||defined(CASE_21116T91))
#include <string>
template<class T>
	class Myalloc_21116T91 : public allocator<T> {
public:
#if DISALLOW_TYPENAME
	typedef allocator<T>::pointer pointer;
	typedef allocator<T>::size_type size_type;
#else
	typedef typename allocator<T>::pointer pointer;
	typedef typename allocator<T>::size_type size_type;
#endif
	Myalloc_21116T91()
		{}
#if !DISALLOW_MEMBER_TEMPLATES_REBIND
//	Myalloc_21116T91(const Myalloc_21116T91<T>&)
//		{}
//	template<class U>
//		Myalloc_21116T91(const Myalloc_21116T91<U>&)
//		{}
	template<class U>
		Myalloc_21116T91<T>& operator=(const Myalloc_21116T91<U>&)
		{return (this); }
	template<class U>
		struct rebind {
			typedef Myalloc_21116T91<U> other;
		};
#endif
	size_t max_size() const
		{return (10); }
	};
#endif /* CASE_21116T91 */

/* _21116T_111 basic_string::resize(size_type, charT) for n <= size() */
#if !defined(SKIP_21116T_111)&&(!defined(ONLY)||defined(CASE_21116T_111))
#include <cstring>
#include <string>
#endif /* CASE_21116T_111 */

/* _21116T_121 basic_string::resize(size_type, charT) for n > size() */
#if !defined(SKIP_21116T_121)&&(!defined(ONLY)||defined(CASE_21116T_121))
#include <cstring>
#include <string>
#endif /* CASE_21116T_121 */

/* _21116T_141 basic_string::resize(size_type) effects */
#if !defined(SKIP_21116T_141)&&(!defined(ONLY)||defined(CASE_21116T_141))
#include <cstring>
#include <string>
#endif /* CASE_21116T_141 */

/* _21116T_171 basic_string::capacity() returns */
#if !defined(SKIP_21116T_171)&&(!defined(ONLY)||defined(CASE_21116T_171))
#include <string>
#endif /* CASE_21116T_171 */

/* _21116T_201 basic_string::reserve effects */
#if !defined(SKIP_21116T_201)&&(!defined(ONLY)||defined(CASE_21116T_201))
#include <string>
#endif /* CASE_21116T_201 */

/* _21116T_211 basic_string::reserve complexity */
#if !defined(SKIP_21116T_211)&&(!defined(ONLY)||defined(CASE_21116T_211))
#include <string>
#endif /* CASE_21116T_211 */

/* _21116T_222 basic_string::reserve notes */
#if !defined(SKIP_21116T_222)&&(!defined(ONLY)||defined(CASE_21116T_222))
#include <cstring>
#include <string>
#endif /* CASE_21116T_222 */

/* _21116T_241 basic_string::empty() returns */
#if !defined(SKIP_21116T_241)&&(!defined(ONLY)||defined(CASE_21116T_241))
#include <string>
#endif /* CASE_21116T_241 */

/* _21117T21 basic_string::operator[]() returns */
#if !defined(SKIP_21117T21)&&(!defined(ONLY)||defined(CASE_21117T21))
#include <string>
#endif /* CASE_21117T21 */

/* _21117T51 basic_string::at() throws */
#if !defined(SKIP_21117T51)&&(!defined(ONLY)||defined(CASE_21117T51))
#include <string>
#endif /* CASE_21117T51 */

/* _21117T61 basic_string::at() returns */
#if !defined(SKIP_21117T61)&&(!defined(ONLY)||defined(CASE_21117T61))
#include <string>
#endif /* CASE_21117T61 */

/* _211181T21 basic_string::operator+=(const basic_string&) returns */
#if !defined(SKIP_211181T21)&&(!defined(ONLY)||defined(CASE_211181T21))
#include <cstring>
#include <string>
#endif /* CASE_211181T21 */

/* _211181T41 basic_string::operator+=(const charT *) returns */
#if !defined(SKIP_211181T41)&&(!defined(ONLY)||defined(CASE_211181T41))
#include <cstring>
#include <string>
#endif /* CASE_211181T41 */

/* _211181T51 basic_string::operator+=(const charT *) notes */
#if !defined(SKIP_211181T51)&&(!defined(ONLY)||defined(CASE_211181T51))
#include <cctype>
#include <string>
int cnt_211181T51;
struct My_char_traits_211181T51 : public char_traits<Char> {
	static size_t length(const char_type *U)
		{cnt_211181T51 |= 1;
		return (strlen((const char *)U)); }
	};
#endif /* CASE_211181T51 */

/* _211181T71 basic_string::operator+=(charT) returns */
#if !defined(SKIP_211181T71)&&(!defined(ONLY)||defined(CASE_211181T71))
#include <cstring>
#include <string>
#endif /* CASE_211181T71 */

/* _211182T31 basic_string::append(const basic_string) throws */
#if !defined(SKIP_211182T31)&&(!defined(ONLY)||defined(CASE_211182T31))
#include <string>
#endif /* CASE_211182T31 */

/* _211182T42 basic_string::append() effects, throws length_error */
#if !defined(SKIP_211182T42)&&(!defined(ONLY)||defined(CASE_211182T42))
#include <string>
template<class T>
	class Myalloc_211182T42 : public allocator<T> {
public:
#if DISALLOW_TYPENAME
	typedef allocator<T>::pointer pointer;
	typedef allocator<T>::size_type size_type;
#else
	typedef typename allocator<T>::pointer pointer;
	typedef typename allocator<T>::size_type size_type;
#endif
	Myalloc_211182T42()
		{}
#if !DISALLOW_MEMBER_TEMPLATES_REBIND
//	Myalloc_211182T42(const Myalloc_211182T42<T>&)
//		{}
//	template<class U>
//		Myalloc_211182T42(const Myalloc_211182T42<U>&)
//		{}
	template<class U>
		Myalloc_211182T42<T>& operator=(const Myalloc_211182T42<U>&)
		{return (this); }
	template<class U>
		struct rebind {
			typedef Myalloc_211182T42<U> other;
		};
#endif
	size_t max_size() const
		{return (10); }
	};
#endif /* CASE_211182T42 */

/* _211182T51 basic_string::append(const basic_string&), effects replacement */
#if !defined(SKIP_211182T51)&&(!defined(ONLY)||defined(CASE_211182T51))
#include <cstring>
#include <string>
#endif /* CASE_211182T51 */

/* _211182T61 basic_string::append(const basic_string&) returns */
#if !defined(SKIP_211182T61)&&(!defined(ONLY)||defined(CASE_211182T61))
#include <string>
#endif /* CASE_211182T61 */

/* _211182T81 basic_string::append(const charT *, size_type) returns */
#if !defined(SKIP_211182T81)&&(!defined(ONLY)||defined(CASE_211182T81))
#include <cstring>
#include <string>
#endif /* CASE_211182T81 */

/* _211182T_101 basic_string::append(const charT *) returns */
#if !defined(SKIP_211182T_101)&&(!defined(ONLY)||defined(CASE_211182T_101))
#include <cstring>
#include <string>
#endif /* CASE_211182T_101 */

/* _211182T_111 basic_string::append(const CharT*) notes */
#if !defined(SKIP_211182T_111)&&(!defined(ONLY)||defined(CASE_211182T_111))
#include <cctype>
#include <string>
int cnt_211182T_111;
struct My_char_traits_211182T_111 : public char_traits<Char> {
	static size_t length(const char_type *U)
		{cnt_211182T_111 |= 1;
		return (strlen((const char *)U)); }
	};
#endif /* CASE_211182T_111 */

/* _211182T_131 basic_string::append(size_type, charT) returns */
#if !defined(SKIP_211182T_131)&&(!defined(ONLY)||defined(CASE_211182T_131))
#include <cstring>
#include <string>
#endif /* CASE_211182T_131 */

/* _211182T_151 basic_string::append(InIt, InIt) returns */
#if !defined(SKIP_211182T_151)&&(!defined(ONLY)||defined(CASE_211182T_151))
#if !IS_EMBEDDED && !DISALLOW_MEMBER_TEMPLATES
#include "iter.h"
#endif
#include <cstring>
#include <string>
#endif /* CASE_211182T_151 */

/* _211183T31 basic_string::assign(const basic_string) throws */
#if !defined(SKIP_211183T31)&&(!defined(ONLY)||defined(CASE_211183T31))
#include <string>
#endif /* CASE_211183T31 */

/* _211183T42 basic_string::assign(const basic_string&), effects */
#if !defined(SKIP_211183T42)&&(!defined(ONLY)||defined(CASE_211183T42))
#include <cstring>
#include <string>
#endif /* CASE_211183T42 */

/* _211183T51 basic_string::assign(const basic_string&) returns */
#if !defined(SKIP_211183T51)&&(!defined(ONLY)||defined(CASE_211183T51))
#include <string>
#endif /* CASE_211183T51 */

/* _211183T71 basic_string::assign(const charT *, size_type) returns */
#if !defined(SKIP_211183T71)&&(!defined(ONLY)||defined(CASE_211183T71))
#include <cstring>
#include <string>
#endif /* CASE_211183T71 */

/* _211183T91 basic_string::assign(const charT *) returns */
#if !defined(SKIP_211183T91)&&(!defined(ONLY)||defined(CASE_211183T91))
#include <cstring>
#include <string>
#endif /* CASE_211183T91 */

/* _211183T_101 basic_string::assign(const CharT*) notes */
#if !defined(SKIP_211183T_101)&&(!defined(ONLY)||defined(CASE_211183T_101))
#include <cctype>
#include <string>
int cnt_211183T_101;
struct My_char_traits_211183T_101 : public char_traits<Char> {
	static size_t length(const char_type *U)
		{cnt_211183T_101 |= 1;
		return (strlen((const char *)U)); }
	};
#endif /* CASE_211183T_101 */

/* _211183T_121 basic_string::assign(size_type, charT) returns */
#if !defined(SKIP_211183T_121)&&(!defined(ONLY)||defined(CASE_211183T_121))
#include <cstring>
#include <string>
#endif /* CASE_211183T_121 */

/* _211183T_141 basic_string::assign(InIt, InIt) returns */
#if !defined(SKIP_211183T_141)&&(!defined(ONLY)||defined(CASE_211183T_141))
#if !IS_EMBEDDED && !DISALLOW_MEMBER_TEMPLATES
#include "iter.h"
#endif
#include <cstring>
#include <string>
#endif /* CASE_211183T_141 */

int t212_main(int, char *[])
{
enter_chk("t212.cpp");
/* _21115T21 basic_string::begin() returns */
#if !defined(SKIP_21115T21)&&(!defined(ONLY)||defined(CASE_21115T21))
	begin_chk("_21115T21");
	{
	Ustr s1((const Char *)"abcd");
	Ustr::iterator p1 = s1.begin();
	ieq(*p1, (Char)'a');
	const Ustr s2((const Char *)"efgh");
	Ustr::const_iterator p2 = s2.begin();
	ieq(*p2, (Char)'e');
	Ustr s3 = s1;
	*p1 = (Char)'x';
	ieq(*s3.c_str(), (Char)'a');
	*s3.begin() = (Char)'y';
	ieq(*p1, (Char)'x');


	}
	end_chk("_21115T21");
#else
	skip_chk("_21115T21");
#endif /* CASE_21115T21 */

/* _21115T41 basic_string::end() returns */
#if !defined(SKIP_21115T41)&&(!defined(ONLY)||defined(CASE_21115T41))
	begin_chk("_21115T41");
	{
	Ustr s0;
	chk(s0.begin() == s0.end());
	Ustr s1((const Char *)"abcd");
	Ustr::iterator p1 = s1.end();
	ieq(*--p1, (Char)'d');
	const Ustr s2((const Char *)"efgh");
	Ustr::const_iterator p2 = s2.end();
	ieq(*--p2, (Char)'h');
	Ustr s3 = s1;
	*p1 = (Char)'x';
	ieq(*(s3.c_str() + 3), (Char)'d');
	*(s3.end() - 1) = (Char)'y';
	ieq(*p1, (Char)'x');


	}
	end_chk("_21115T41");
#else
	skip_chk("_21115T41");
#endif /* CASE_21115T41 */

/* _21115T61 basic_string::rbegin() returns */
#if !defined(SKIP_21115T61)&&(!defined(ONLY)||defined(CASE_21115T61))
	begin_chk("_21115T61");
	{
	Ustr s1((const Char *)"abcd");
	Ustr::reverse_iterator p1 = s1.rbegin();
	ieq(*p1, (Char)'d');
	const Ustr s2((const Char *)"efgh");
	Ustr::const_reverse_iterator p2 = s2.rbegin();
	ieq(*p2, (Char)'h');
	Ustr s3 = s1;
	*p1 = (Char)'x';
	ieq(*(s3.c_str() + 3), (Char)'d');
	*s3.rbegin() = (Char)'y';
	ieq(*p1, (Char)'x');


	}
	end_chk("_21115T61");
#else
	skip_chk("_21115T61");
#endif /* CASE_21115T61 */

/* _21115T81 basic_string::rend() returns */
#if !defined(SKIP_21115T81)&&(!defined(ONLY)||defined(CASE_21115T81))
	begin_chk("_21115T81");
	{
	Ustr s0;
	chk(s0.rbegin() == s0.rend());
	Ustr s1((const Char *)"abcd");
	Ustr::reverse_iterator p1 = s1.rend();
	ieq(*--p1, (Char)'a');
	const Ustr s2((const Char *)"efgh");
	Ustr::const_reverse_iterator p2 = s2.rend();
	ieq(*--p2, (Char)'e');
	Ustr s3 = s1;
	*p1 = (Char)'x';
	ieq(*s3.c_str(), (Char)'a');
	*(s3.rend() - 1) = (Char)'y';
	ieq(*p1, (Char)'x');


	}
	end_chk("_21115T81");
#else
	skip_chk("_21115T81");
#endif /* CASE_21115T81 */

/* _21116T21 basic_string::size() returns */
#if !defined(SKIP_21116T21)&&(!defined(ONLY)||defined(CASE_21116T21))
	begin_chk("_21116T21");
	{
	Ustr s1((const Char *)"abcd");
	ieq(s1.size(), 4);
	const Ustr s2;
	ieq(s2.size(), 0);




	}
	end_chk("_21116T21");
#else
	skip_chk("_21116T21");
#endif /* CASE_21116T21 */

/* _21116T51 basic_string::length() returns */
#if !defined(SKIP_21116T51)&&(!defined(ONLY)||defined(CASE_21116T51))
	begin_chk("_21116T51");
	{
	Ustr s1((const Char *)"abcd");
	ieq(s1.size(), s1.length());
	const Ustr s2;
	ieq(s2.size(), s2.length());


	}
	end_chk("_21116T51");
#else
	skip_chk("_21116T51");
#endif /* CASE_21116T51 */

/* _21116T71 basic_string::max_size() returns */
#if !defined(SKIP_21116T71)&&(!defined(ONLY)||defined(CASE_21116T71))
	begin_chk("_21116T71");
	{
	Ustr s1((const Char *)"abcd");
	Ustr::size_type ms = s1.max_size();
	chk(0 < ms);
	chk(ms < Ustr::npos);
	const Ustr s2;
	chk(s2.max_size() == ms);



	}
	end_chk("_21116T71");
#else
	skip_chk("_21116T71");
#endif /* CASE_21116T71 */

/* _21116T91 basic_string::resize(size_type, charT) throws */
#if !defined(SKIP_21116T91)&&(!defined(ONLY)||defined(CASE_21116T91))
	begin_chk("_21116T91");
	{
	#if DISALLOW_EXCEPTIONS
	chk(1);
	#else
	typedef STD basic_string<Char,
		STD char_traits<Char>,
		Myalloc_21116T91<Char> > Mystr;
	Mystr s0;
	int cnt = 0;
	try
		{s0.resize(s0.max_size(), 0);
		cnt += 5;
		s0.resize(s0.max_size() + 1, 0); }
	catch (STD length_error)
		{++cnt; }
	catch (...)
		{cnt += 10; }
	ieq(cnt, 6);
	#endif


	}
	end_chk("_21116T91");
#else
	skip_chk("_21116T91");
#endif /* CASE_21116T91 */

/* _21116T_111 basic_string::resize(size_type, charT) for n <= size() */
#if !defined(SKIP_21116T_111)&&(!defined(ONLY)||defined(CASE_21116T_111))
	begin_chk("_21116T_111");
	{
	Ustr s1((const Char *)"abcd");
	s1.resize(4, 0);
	ieq(s1.size(), 4);
	ieq(STD memcmp(s1.c_str(), "abcd", 5), 0);
	s1.resize(2, 0);
	ieq(s1.size(), 2);
	ieq(STD memcmp(s1.c_str(), "ab", 3), 0);
	s1.resize(0, 0);
	ieq(s1.size(), 0);
	ieq(STD memcmp(s1.c_str(), "", 1), 0);


	}
	end_chk("_21116T_111");
#else
	skip_chk("_21116T_111");
#endif /* CASE_21116T_111 */

/* _21116T_121 basic_string::resize(size_type, charT) for n > size() */
#if !defined(SKIP_21116T_121)&&(!defined(ONLY)||defined(CASE_21116T_121))
	begin_chk("_21116T_121");
	{
	Ustr s1((const Char *)"abcd");
	s1.resize(6, (Char)'x');
	ieq(s1.size(), 6);
	ieq(STD memcmp(s1.c_str(), "abcdxx", 7), 0);
	s1.resize(11, (Char)'y');
	ieq(s1.size(), 11);
	ieq(STD memcmp(s1.c_str(), "abcdxxyyyyy", 12), 0);




	}
	end_chk("_21116T_121");
#else
	skip_chk("_21116T_121");
#endif /* CASE_21116T_121 */

/* _21116T_141 basic_string::resize(size_type) effects */
#if !defined(SKIP_21116T_141)&&(!defined(ONLY)||defined(CASE_21116T_141))
	begin_chk("_21116T_141");
	{
	Ustr s1((const Char *)"abcd");
	s1.resize(7);
	ieq(s1.size(), 7);
	ieq(STD memcmp(s1.c_str(), "abcd\0\0\0", 8), 0);




	}
	end_chk("_21116T_141");
#else
	skip_chk("_21116T_141");
#endif /* CASE_21116T_141 */

/* _21116T_171 basic_string::capacity() returns */
#if !defined(SKIP_21116T_171)&&(!defined(ONLY)||defined(CASE_21116T_171))
	begin_chk("_21116T_171");
	{
	Ustr s1((const Char *)"abcd");
	chk(s1.size() <= s1.capacity());
	const Ustr s2;
	chk(s2.size() <= s2.capacity());


	}
	end_chk("_21116T_171");
#else
	skip_chk("_21116T_171");
#endif /* CASE_21116T_171 */

/* _21116T_201 basic_string::reserve effects */
#if !defined(SKIP_21116T_201)&&(!defined(ONLY)||defined(CASE_21116T_201))
	begin_chk("_21116T_201");
	{
	Ustr s1((const Char *)"abcd");
	s1.reserve();	// ADDED [MAR96]
	s1.reserve(50);
	chk(50 <= s1.capacity());

	Ustr s2;
	s2.reserve(80);
	chk(80 <= s2.capacity());


	}
	end_chk("_21116T_201");
#else
	skip_chk("_21116T_201");
#endif /* CASE_21116T_201 */

/* _21116T_211 basic_string::reserve complexity */
#if !defined(SKIP_21116T_211)&&(!defined(ONLY)||defined(CASE_21116T_211))
	begin_chk("_21116T_211");
	{
	Ustr s1((const Char *)"abcd");
	s1.reserve(50);
	ieq(s1.size(), 4);
	ieq(STD memcmp(s1.c_str(), "abcd", 5), 0);
	Ustr s2;
	s2.reserve(80);
	ieq(s2.size(), 0);
	ieq(STD memcmp(s2.c_str(), "", 1), 0);



	}
	end_chk("_21116T_211");
#else
	skip_chk("_21116T_211");
#endif /* CASE_21116T_211 */

/* _21116T_222 basic_string::reserve notes */
#if !defined(SKIP_21116T_222)&&(!defined(ONLY)||defined(CASE_21116T_222))
	begin_chk("_21116T_222");
	{
	const Char *s = (const Char *)"abcd";
	Ustr s1(s);
	s1.reserve(600);
	Ustr::iterator p = s1.begin();
	ieq(STD memcmp(&*p, "abcd", 5), 0);
	int i;
	for (i = 8; i < 600; i += 4)
		{s1 += s;
		ieq(s1.begin() == p ? i : 0, i); }
	Ustr s2;
	s2.reserve(600);
	const char *q = s2.c_str();
	for (i = 4; i < 600; i += 4)
		{s2 += s;
		ieq(s2.c_str() == q ? i : 0, i); }


	}
	end_chk("_21116T_222");
#else
	skip_chk("_21116T_222");
#endif /* CASE_21116T_222 */

/* _21116T_241 basic_string::empty() returns */
#if !defined(SKIP_21116T_241)&&(!defined(ONLY)||defined(CASE_21116T_241))
	begin_chk("_21116T_241");
	{
	Ustr s1((const Char *)"abcd");
	chk(!s1.empty());
	const Ustr s2;
	chk(s2.empty());


	}
	end_chk("_21116T_241");
#else
	skip_chk("_21116T_241");
#endif /* CASE_21116T_241 */

/* _21117T21 basic_string::operator[]() returns */
#if !defined(SKIP_21117T21)&&(!defined(ONLY)||defined(CASE_21117T21))
	begin_chk("_21117T21");
	{
	Ustr s1((const Char *)"abcd");
	ieq(s1[3], (Char)'d');
	ieq(s1[4], 0);
	s1[2] = (Char)'x';
	ieq(s1[2], (Char)'x');
	const Ustr s2;
	ieq(s2[0], 0);
	Ustr s3 = s1;
	s1[0] = (Char)'x';
	ieq(*s3.c_str(), (Char)'a');
	s3[0] = (Char)'y';
	ieq(s1[0], (Char)'x');


	}
	end_chk("_21117T21");
#else
	skip_chk("_21117T21");
#endif /* CASE_21117T21 */

/* _21117T51 basic_string::at() throws */
#if !defined(SKIP_21117T51)&&(!defined(ONLY)||defined(CASE_21117T51))
	begin_chk("_21117T51");
	{
	#if DISALLOW_EXCEPTIONS
	chk(1);
	#else
	Ustr s1((const Char *)"abcd");
	int cnt = 0;
	try
		{s1.at(4); }
	catch (STD out_of_range)
		{++cnt; }
	catch (...)
		{cnt += 10; }
	ieq(cnt, 1);
	cnt = 0;
	try
		{s1.at(23); }
	catch (STD out_of_range)
		{++cnt; }
	catch (...)
		{cnt += 10; }
	ieq(cnt, 1);
	#endif


	}
	end_chk("_21117T51");
#else
	skip_chk("_21117T51");
#endif /* CASE_21117T51 */

/* _21117T61 basic_string::at() returns */
#if !defined(SKIP_21117T61)&&(!defined(ONLY)||defined(CASE_21117T61))
	begin_chk("_21117T61");
	{
	Ustr s1((const Char *)"abcd");
	ieq(s1.at(3), (Char)'d');
	s1.at(2) = (Char)'x';
	ieq(s1.at(2), (Char)'x');
	const Ustr s2((const Char *)"efg");
	ieq(s2.at(1), (Char)'f');
	Ustr s3 = s1;
	s1.at(0) = (Char)'x';
	ieq(*s3.c_str(), (Char)'a');
	s3.at(0) = (Char)'y';
	ieq(s1.at(0), (Char)'x');


	}
	end_chk("_21117T61");
#else
	skip_chk("_21117T61");
#endif /* CASE_21117T61 */

/* _211181T21 basic_string::operator+=(const basic_string&) returns */
#if !defined(SKIP_211181T21)&&(!defined(ONLY)||defined(CASE_211181T21))
	begin_chk("_211181T21");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	const Ustr s2((const Char *)"efgh");
	s1 += s2;
	ieq(STD memcmp(s1.c_str(), "abcdefgh", 9), 0);
	s1 += s0;
	ieq(STD memcmp(s1.c_str(), "abcdefgh", 9), 0);
	s1 += s1;
	ieq(STD memcmp(s1.c_str(), "abcdefghabcdefgh", 17), 0);
	s0 += s0;
	ieq(STD memcmp(s0.c_str(), "", 1), 0);


	}
	end_chk("_211181T21");
#else
	skip_chk("_211181T21");
#endif /* CASE_211181T21 */

/* _211181T41 basic_string::operator+=(const charT *) returns */
#if !defined(SKIP_211181T41)&&(!defined(ONLY)||defined(CASE_211181T41))
	begin_chk("_211181T41");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	s1 += (const Char *)"efgh";
	ieq(STD memcmp(s1.c_str(), "abcdefgh", 9), 0);
	s1 += (const Char *)"";
	ieq(STD memcmp(s1.c_str(), "abcdefgh", 9), 0);
	s0 += (const Char *)"";
	ieq(STD memcmp(s0.c_str(), "", 1), 0);


	}
	end_chk("_211181T41");
#else
	skip_chk("_211181T41");
#endif /* CASE_211181T41 */

/* _211181T51 basic_string::operator+=(const charT *) notes */
#if !defined(SKIP_211181T51)&&(!defined(ONLY)||defined(CASE_211181T51))
	begin_chk("_211181T51");
	{
	typedef STD basic_string<Char,
		My_char_traits_211181T51,
		Al> Mystr;
	Mystr s0((const Char *)"abcd");
	cnt_211181T51 = 0;
	s0 += (const Char *)"efgh";
	ieq(cnt_211181T51, 1);


	}
	end_chk("_211181T51");
#else
	skip_chk("_211181T51");
#endif /* CASE_211181T51 */

/* _211181T71 basic_string::operator+=(charT) returns */
#if !defined(SKIP_211181T71)&&(!defined(ONLY)||defined(CASE_211181T71))
	begin_chk("_211181T71");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	s1 += (Char)'e';
	ieq(STD memcmp(s1.c_str(), "abcde", 6), 0);
	s0 += (Char)'x';
	ieq(STD memcmp(s0.c_str(), "x", 2), 0);


	}
	end_chk("_211181T71");
#else
	skip_chk("_211181T71");
#endif /* CASE_211181T71 */

/* _211182T31 basic_string::append(const basic_string) throws */
#if !defined(SKIP_211182T31)&&(!defined(ONLY)||defined(CASE_211182T31))
	begin_chk("_211182T31");
	{
	#if DISALLOW_EXCEPTIONS
	chk(1);
	#else
	const Ustr s0;
	Ustr s1((const Char *)"abcd");
	int cnt = 0;
	try
		{s1.append(s0, 1, 20); }
	catch (STD out_of_range)
		{++cnt; }
	catch (...)
		{cnt += 10; }
	ieq(cnt, 1);
	#endif


	}
	end_chk("_211182T31");
#else
	skip_chk("_211182T31");
#endif /* CASE_211182T31 */

/* _211182T42 basic_string::append() effects, throws length_error */
#if !defined(SKIP_211182T42)&&(!defined(ONLY)||defined(CASE_211182T42))
	begin_chk("_211182T42");
	{
	#if DISALLOW_EXCEPTIONS
	chk(1);
	#else
	typedef STD basic_string<Char,
		STD char_traits<Char>,
		Myalloc_211182T42<Char> > Mystr;
	Mystr s1 = (const Char *)"abcd";
	const Mystr s2(s1.max_size() - 4, (Char)'x');
	int cnt = 0;
	try
		{s1.append(s2);
		cnt += 5;
		s1 = (const Char *)"abcde";
		s1.append(s2); }
	catch (STD length_error)
		{++cnt; }
	catch (...)
		{cnt += 10; }
	ieq(cnt, 6);
	s1 = (const Char *)"abcdef";
	cnt = 0;
	try
		{s1.append(s2); }
	catch (STD length_error)
		{++cnt; }
	catch (...)
		{cnt += 10; }
	ieq(cnt, 1);
	#endif


	}
	end_chk("_211182T42");
#else
	skip_chk("_211182T42");
#endif /* CASE_211182T42 */

/* _211182T51 basic_string::append(const basic_string&), effects replacement */
#if !defined(SKIP_211182T51)&&(!defined(ONLY)||defined(CASE_211182T51))
	begin_chk("_211182T51");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	const Ustr s2((const Char *)"efgh");
	s1.append(s2, 1, 1);
	ieq(STD memcmp(s1.c_str(), "abcdf", 6), 0);
	s1.append(s2, 2, 20);
	ieq(STD memcmp(s1.c_str(), "abcdfgh", 8), 0);
	s1.append(s1);
	ieq(STD memcmp(s1.c_str(), "abcdfghabcdfgh", 15), 0);
	s1.append(s0);
	ieq(STD memcmp(s1.c_str(), "abcdfghabcdfgh", 15), 0);
	s0.append(s0);
	ieq(s0.size(), 0);
	ieq(STD memcmp(s0.c_str(), "", 1), 0);


	}
	end_chk("_211182T51");
#else
	skip_chk("_211182T51");
#endif /* CASE_211182T51 */

/* _211182T61 basic_string::append(const basic_string&) returns */
#if !defined(SKIP_211182T61)&&(!defined(ONLY)||defined(CASE_211182T61))
	begin_chk("_211182T61");
	{
	Ustr s1((const Char *)"abcd");
	const Ustr s2((const Char *)"efgh");
	chk(&s1.append(s2, 1, 1) == &s1);
	chk(&s1.append(s2, 2, 20) == &s1);
	chk(&s1.append(s1) == &s1);


	}
	end_chk("_211182T61");
#else
	skip_chk("_211182T61");
#endif /* CASE_211182T61 */

/* _211182T81 basic_string::append(const charT *, size_type) returns */
#if !defined(SKIP_211182T81)&&(!defined(ONLY)||defined(CASE_211182T81))
	begin_chk("_211182T81");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	const Char *s = (const Char *)"efgh";
	s1.append(s, 5);
	ieq(STD memcmp(s1.c_str(), "abcdefgh\0", 10), 0);
	s1.append(s, (Ustr::size_type)0);
	ieq(STD memcmp(s1.c_str(), "abcdefgh\0", 10), 0);
	s0.append(s, (Ustr::size_type)0);
	ieq(STD memcmp(s0.c_str(), "", 1), 0);
	s0.append(s, 1);
	ieq(STD memcmp(s0.c_str(), "e", 2), 0);
	s0.append(&*s0.begin(), 1);	// ADDED [JUL97]
	ieq(STD memcmp(s0.c_str(), "ee", 3), 0);


	}
	end_chk("_211182T81");
#else
	skip_chk("_211182T81");
#endif /* CASE_211182T81 */

/* _211182T_101 basic_string::append(const charT *) returns */
#if !defined(SKIP_211182T_101)&&(!defined(ONLY)||defined(CASE_211182T_101))
	begin_chk("_211182T_101");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	const Char *s = (const Char *)"efgh";
	const Char *sn = (const Char *)"";
	s1.append(s);
	ieq(STD memcmp(s1.c_str(), "abcdefgh", 9), 0);
	s1.append(sn);
	ieq(STD memcmp(s1.c_str(), "abcdefgh", 9), 0);
	s0.append(sn);
	ieq(STD memcmp(s0.c_str(), "", 1), 0);
	s0.append(s);
	ieq(STD memcmp(s0.c_str(), "efgh", 5), 0);


	}
	end_chk("_211182T_101");
#else
	skip_chk("_211182T_101");
#endif /* CASE_211182T_101 */

/* _211182T_111 basic_string::append(const CharT*) notes */
#if !defined(SKIP_211182T_111)&&(!defined(ONLY)||defined(CASE_211182T_111))
	begin_chk("_211182T_111");
	{
	typedef STD basic_string<Char,
		My_char_traits_211182T_111,
		Al> Mystr;
	Mystr s0((const Char *)"abcd");
	cnt_211182T_111 = 0;
	s0.append((const Char *)"efgh");
	ieq(cnt_211182T_111, 1);



	}
	end_chk("_211182T_111");
#else
	skip_chk("_211182T_111");
#endif /* CASE_211182T_111 */

/* _211182T_131 basic_string::append(size_type, charT) returns */
#if !defined(SKIP_211182T_131)&&(!defined(ONLY)||defined(CASE_211182T_131))
	begin_chk("_211182T_131");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	s1.append(2, (Char)'x');
	ieq(STD memcmp(s1.c_str(), "abcdxx", 7), 0);
	s1.append(0, (Char)'y');
	ieq(STD memcmp(s1.c_str(), "abcdxx", 7), 0);
	s0.append((Ustr::size_type)0, (Char)0);
	ieq(STD memcmp(s0.c_str(), "", 1), 0);
	s0.append(4, (Char)'z');
	ieq(STD memcmp(s0.c_str(), "zzzz", 5), 0);


	}
	end_chk("_211182T_131");
#else
	skip_chk("_211182T_131");
#endif /* CASE_211182T_131 */

/* _211182T_151 basic_string::append(InIt, InIt) returns */
#if !defined(SKIP_211182T_151)&&(!defined(ONLY)||defined(CASE_211182T_151))
	begin_chk("_211182T_151");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	const Char *s = (const Char *)"efgh";
	s1.append(s, s + 2);
	ieq(STD memcmp(s1.c_str(), "abcdef", 7), 0);
	s1.append(s, s);
	ieq(STD memcmp(s1.c_str(), "abcdef", 7), 0);
	s0.append(s, s);
	ieq(STD memcmp(s0.c_str(), "", 1), 0);
	s0.append(s, s + 5);
	ieq(STD memcmp(s0.c_str(), "efgh\0", 6), 0);

	#if !IS_EMBEDDED && !DISALLOW_MEMBER_TEMPLATES
	s0 = s;
	s1 = s;
	int err1 = 0, nrec1 = 4;
	strict_input_iterator<Ustr::const_iterator, Char> it1
		(s1.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<Ustr::const_iterator, Char> it2
		(s1.end(), err2, nrec2);
	s0.append(it1, it2);
	ieq(STD memcmp(s0.c_str(), "efghefgh", 9), 0);
	ieq(err1, 0);
	ieq(err2, 0);

	s0.append((short)3, (short)'x');	// ADDED [JUL97]
	ieq(STD memcmp(s0.c_str(), "efghefghxxx", 12), 0);
	#endif


	}
	end_chk("_211182T_151");
#else
	skip_chk("_211182T_151");
#endif /* CASE_211182T_151 */

/* _211183T31 basic_string::assign(const basic_string) throws */
#if !defined(SKIP_211183T31)&&(!defined(ONLY)||defined(CASE_211183T31))
	begin_chk("_211183T31");
	{
	#if DISALLOW_EXCEPTIONS
	chk(1);
	#else
	const Ustr s0;
	Ustr s1((const Char *)"abcd");
	int cnt = 0;
	try
		{s1.assign(s0, 1, 20); }
	catch (STD out_of_range)
		{++cnt; }
	catch (...)
		{cnt += 10; }
	ieq(cnt, 1);
	#endif


	}
	end_chk("_211183T31");
#else
	skip_chk("_211183T31");
#endif /* CASE_211183T31 */

/* _211183T42 basic_string::assign(const basic_string&), effects */
#if !defined(SKIP_211183T42)&&(!defined(ONLY)||defined(CASE_211183T42))
	begin_chk("_211183T42");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	const Ustr s2((const Char *)"efgh");
	s1.assign(s2, 1, 1);
	ieq(STD memcmp(s1.c_str(), "f", 2), 0);
	s1.assign(s2, 2, 20);
	ieq(STD memcmp(s1.c_str(), "gh", 3), 0);
	s1.assign(s2);
	ieq(STD memcmp(s1.c_str(), "efgh", 5), 0);
	s1.assign(s1);
	ieq(STD memcmp(s1.c_str(), "efgh", 5), 0);
	s1.assign(s0);
	ieq(STD memcmp(s1.c_str(), "", 1), 0);
	s0.assign(s0);
	ieq(STD memcmp(s0.c_str(), "", 1), 0);


	}
	end_chk("_211183T42");
#else
	skip_chk("_211183T42");
#endif /* CASE_211183T42 */

/* _211183T51 basic_string::assign(const basic_string&) returns */
#if !defined(SKIP_211183T51)&&(!defined(ONLY)||defined(CASE_211183T51))
	begin_chk("_211183T51");
	{
	Ustr s1((const Char *)"abcd");
	const Ustr s2((const Char *)"efgh");
	chk(&s1.assign(s2, 1, 1) == &s1);
	chk(&s1.assign(s2, 2, 20) == &s1);
	chk(&s1.assign(s1) == &s1);


	}
	end_chk("_211183T51");
#else
	skip_chk("_211183T51");
#endif /* CASE_211183T51 */

/* _211183T71 basic_string::assign(const charT *, size_type) returns */
#if !defined(SKIP_211183T71)&&(!defined(ONLY)||defined(CASE_211183T71))
	begin_chk("_211183T71");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	const Char *s = (const Char *)"efgh";
	s1.assign(s, 5);
	ieq(STD memcmp(s1.c_str(), "efgh\0", 6), 0);
	s1.assign(s, (Ustr::size_type)0);
	ieq(STD memcmp(s1.c_str(), "", 1), 0);
	s0.assign(s, (Ustr::size_type)0);
	ieq(STD memcmp(s0.c_str(), "", 1), 0);
	s0.assign(s, 1);
	ieq(STD memcmp(s0.c_str(), "e", 2), 0);

	s0.assign(&*s0.begin(), 1);	// ADDED [JUL97]
	ieq(STD memcmp(s0.c_str(), "e", 2), 0);


	}
	end_chk("_211183T71");
#else
	skip_chk("_211183T71");
#endif /* CASE_211183T71 */

/* _211183T91 basic_string::assign(const charT *) returns */
#if !defined(SKIP_211183T91)&&(!defined(ONLY)||defined(CASE_211183T91))
	begin_chk("_211183T91");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	const Char *s = (const Char *)"efgh";
	const Char *sn = (const Char *)"";
	s1.assign(s);
	ieq(STD memcmp(s1.c_str(), "efgh", 5), 0);
	s1.assign(sn);
	ieq(STD memcmp(s1.c_str(), "", 1), 0);
	s0.assign(sn);
	ieq(STD memcmp(s0.c_str(), "", 1), 0);
	s0.assign(s);
	ieq(STD memcmp(s0.c_str(), "efgh", 5), 0);


	}
	end_chk("_211183T91");
#else
	skip_chk("_211183T91");
#endif /* CASE_211183T91 */

/* _211183T_101 basic_string::assign(const CharT*) notes */
#if !defined(SKIP_211183T_101)&&(!defined(ONLY)||defined(CASE_211183T_101))
	begin_chk("_211183T_101");
	{
	typedef STD basic_string<Char,
		My_char_traits_211183T_101,
		Al> Mystr;
	Mystr s0((const Char *)"abcd");
	cnt_211183T_101 = 0;
	s0.assign((const Char *)"efgh");
	ieq(cnt_211183T_101, 1);



	}
	end_chk("_211183T_101");
#else
	skip_chk("_211183T_101");
#endif /* CASE_211183T_101 */

/* _211183T_121 basic_string::assign(size_type, charT) returns */
#if !defined(SKIP_211183T_121)&&(!defined(ONLY)||defined(CASE_211183T_121))
	begin_chk("_211183T_121");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	s1.assign(2, (Char)'x');
	ieq(STD memcmp(s1.c_str(), "xx", 3), 0);
	s1.assign(0, (Char)'y');
	ieq(STD memcmp(s1.c_str(), "", 1), 0);
	s0.assign((Ustr::size_type)0, (Char)0);
	ieq(STD memcmp(s0.c_str(), "", 1), 0);
	s0.assign(4, (Char)'z');
	ieq(STD memcmp(s0.c_str(), "zzzz", 5), 0);


	}
	end_chk("_211183T_121");
#else
	skip_chk("_211183T_121");
#endif /* CASE_211183T_121 */

/* _211183T_141 basic_string::assign(InIt, InIt) returns */
#if !defined(SKIP_211183T_141)&&(!defined(ONLY)||defined(CASE_211183T_141))
	begin_chk("_211183T_141");
	{
	Ustr s0;
	Ustr s1((const Char *)"abcd");
	const Char *s = (const Char *)"efgh";
	s1.assign(s, s + 2);
	ieq(STD memcmp(s1.c_str(), "ef", 3), 0);
	s1.assign(s, s);
	ieq(STD memcmp(s1.c_str(), "", 1), 0);
	s0.assign(s, s);
	ieq(STD memcmp(s0.c_str(), "", 1), 0);
	s0.assign(s, s + 5);
	ieq(STD memcmp(s0.c_str(), "efgh\0", 6), 0);

	#if !IS_EMBEDDED && !DISALLOW_MEMBER_TEMPLATES
	s1 = s;
	int err1 = 0, nrec1 = 4;
	strict_input_iterator<Ustr::const_iterator, Char> it1
		(s1.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<Ustr::const_iterator, Char> it2
		(s1.end(), err2, nrec2);
	s0.assign(it1, it2);
	ieq(STD memcmp(s0.c_str(), "efgh", 5), 0);
	ieq(err1, 0);
	ieq(err2, 0);

	s0.assign((short)3, (short)'x');	// ADDED [JUL97]
	ieq(STD memcmp(s0.c_str(), "xxx", 4), 0);
	#endif

	}
	end_chk("_211183T_141");
#else
	skip_chk("_211183T_141");
#endif /* CASE_211183T_141 */

return leave_chk("t212");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t258.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _25361T31a push_heap(first, last)   effects, complexity */
#if !defined(SKIP_25361T31a)&&(!defined(ONLY)||defined(CASE_25361T31a))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
#endif /* CASE_25361T31a */

/* _25361T31b push_heap(first, last, comp)   effects, complexity */
#if !defined(SKIP_25361T31b)&&(!defined(ONLY)||defined(CASE_25361T31b))
#include<algorithm>
#include <cctype>
#include <cstring>
#include <string>
#include "iter.h"
int npreds_25361T31b = 0;
int f_25361T31b(Char c1, Char c2)
	{++npreds_25361T31b;
	return (tolower(c1) < tolower(c2)); }
#endif /* CASE_25361T31b */

/* _25362T31a pop_heap(first, last)   effects, complexity */
#if !defined(SKIP_25362T31a)&&(!defined(ONLY)||defined(CASE_25362T31a))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
#endif /* CASE_25362T31a */

/* _25362T31b pop_heap(first, last, comp)   effects, complexity */
#if !defined(SKIP_25362T31b)&&(!defined(ONLY)||defined(CASE_25362T31b))
#include <algorithm>
#include <cctype>
#include <cstring>
#include <string>
#include "iter.h"
int npreds_25362T31b = 0;
int f_25362T31b(Char c1, Char c2)
	{++npreds_25362T31b;
	return (tolower(c1) < tolower(c2)); }
#endif /* CASE_25362T31b */

/* _25363T31a make_heap(first, last)   effects, complexity */
#if !defined(SKIP_25363T31a)&&(!defined(ONLY)||defined(CASE_25363T31a))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
#endif /* CASE_25363T31a */

/* _25363T31b make_heap(first, last, comp)   effects, complexity */
#if !defined(SKIP_25363T31b)&&(!defined(ONLY)||defined(CASE_25363T31b))
#include <algorithm>
#include <cctype>
#include <cstring>
#include <string>
#include "iter.h"
int npreds_25363T31b = 0;
int f_25363T31b(Char c1, Char c2)
	{++npreds_25363T31b;
	return (tolower(c1) < tolower(c2)); }
#endif /* CASE_25363T31b */

/* _25364T21a sort_heap(first, last)   effects, complexity */
#if !defined(SKIP_25364T21a)&&(!defined(ONLY)||defined(CASE_25364T21a))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
#endif /* CASE_25364T21a */

/* _25364T21b sort_heap(first, last, comp)   effects, complexity */
#if !defined(SKIP_25364T21b)&&(!defined(ONLY)||defined(CASE_25364T21b))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
int npreds_25364T21b = 0;
int f_25364T21b(Char c1, Char c2)
	{++npreds_25364T21b;
	return (tolower(c1) < tolower(c2)); }
#endif /* CASE_25364T21b */

/* _2537T21a min(a, b)   returns, notes */
#if !defined(SKIP_2537T21a)&&(!defined(ONLY)||defined(CASE_2537T21a))
#include <algorithm>
#endif /* CASE_2537T21a */

/* _2537T21b min(a, b, comp)  returns, notes */
#if !defined(SKIP_2537T21b)&&(!defined(ONLY)||defined(CASE_2537T21b))
#include <algorithm>
#include <cctype>
bool g_2537T21b(char c1, char c2)
	{return (tolower(c1) < tolower(c2)); }
bool h_2537T21b(double d1, double d2)
	{return (d1 > d2); }
bool i_2537T21b(long n1, long n2)
	{ return (n1 % 10 < n2 % 10); }
#endif /* CASE_2537T21b */

/* _2537T51a max(a, b)   returns, notes */
#if !defined(SKIP_2537T51a)&&(!defined(ONLY)||defined(CASE_2537T51a))
#include <algorithm>
#endif /* CASE_2537T51a */

/* _2537T51b max(a, b, comp)  returns, notes */
#if !defined(SKIP_2537T51b)&&(!defined(ONLY)||defined(CASE_2537T51b))
#include <algorithm>
#include <cctype>
bool g_2537T51b(char c1, char c2)
	{return (tolower(c1) < tolower(c2)); }
bool h_2537T51b(double d1, double d2)
	{return (d1 > d2); }
bool i_2537T51b(long n1, long n2)
	{return (n1 % 10 < n2 % 10); }
#endif /* CASE_2537T51b */

/* _2537T81a min_element(a, b)   returns */
#if !defined(SKIP_2537T81a)&&(!defined(ONLY)||defined(CASE_2537T81a))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
#endif /* CASE_2537T81a */

/* _2537T81b min_element(a, b, comp)  returns, complexity */
#if !defined(SKIP_2537T81b)&&(!defined(ONLY)||defined(CASE_2537T81b))
#include <algorithm>
#include <cctype>
#include <cstring>
#include <string>
#include "iter.h"
int npreds_2537T81b = 0;
int f_2537T81b(Char c1, Char c2)
	{++npreds_2537T81b;
	return (tolower(c1) < tolower(c2)); }
#endif /* CASE_2537T81b */

/* _2537T_111a max_element(a, b)   returns, complexity */
#if !defined(SKIP_2537T_111a)&&(!defined(ONLY)||defined(CASE_2537T_111a))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
#endif /* CASE_2537T_111a */

/* _2537T_111b max_element(a, b, comp)  returns, complexity */
#if !defined(SKIP_2537T_111b)&&(!defined(ONLY)||defined(CASE_2537T_111b))
#include <algorithm>
#include <cctype>
#include <cstring>
#include <string>
#include "iter.h"
int npreds_2537T_111b = 0;
int f_2537T_111b(Char c1, Char c2)
	{++npreds_2537T_111b;
	return (tolower(c1) < tolower(c2)); }
#endif /* CASE_2537T_111b */

/* _2538T21a lexicographical_compare(-)   returns, complexity */
#if !defined(SKIP_2538T21a)&&(!defined(ONLY)||defined(CASE_2538T21a))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
#endif /* CASE_2538T21a */

/* _2538T21b lexicographical_compare(-,comp)   returns, complexity */
#if !defined(SKIP_2538T21b)&&(!defined(ONLY)||defined(CASE_2538T21b))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
int npreds_2538T21b = 0;
int f_2538T21b(Char c1, Char c2)
	{++npreds_2538T21b;
	return (tolower(c1) < tolower(c2)); }
#endif /* CASE_2538T21b */

/* _2538T31a next_permutation(first, last)   effects, complexity */
#if !defined(SKIP_2538T31a)&&(!defined(ONLY)||defined(CASE_2538T31a))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
int cnt_2538T31a = 0;
struct Mychar_2538T31a {
	Mychar_2538T31a(char ch = 0)
		: c(ch) {}
	Mychar_2538T31a(const Mychar_2538T31a& x)
		{++cnt_2538T31a;
		c = x.c; }
	Mychar_2538T31a& operator=(const Mychar_2538T31a& x)
		{++cnt_2538T31a;
		c = x.c;
		return (*this); }
	Mychar_2538T31a& operator=(char ch)
		{c = ch;
		return (*this); }
	bool operator<(const Mychar_2538T31a& x)
		{return (c == x.c); }
	char c;
	};
#endif /* CASE_2538T31a */

/* _2538T31b next_permutation(first, last, comp)   effects, complexity */
#if !defined(SKIP_2538T31b)&&(!defined(ONLY)||defined(CASE_2538T31b))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
int f_2538T31b(Char c1, Char c2)
	{return (tolower(c1) < tolower(c2)); }
#endif /* CASE_2538T31b */

/* _2538T41a prev_permutation(first, last)   effects, complexity */
#if !defined(SKIP_2538T41a)&&(!defined(ONLY)||defined(CASE_2538T41a))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
int cnt_2538T41a = 0;
struct Mychar_2538T41a {
	Mychar_2538T41a(char ch = 0)
		: c(ch) {}
	Mychar_2538T41a(const Mychar_2538T41a& x)
		{++cnt_2538T41a;
		c = x.c; }
	Mychar_2538T41a& operator=(const Mychar_2538T41a& x)
		{++cnt_2538T41a;
		c = x.c;
		return (*this); }
	Mychar_2538T41a& operator=(char ch)
		{c = ch;
		return (*this); }
	bool operator<(const Mychar_2538T41a& x)
		{return (c == x.c); }
	char c;
	};
#endif /* CASE_2538T41a */

/* _2538T41b prev_permutation(first, last, comp)   effects, complexity */
#if !defined(SKIP_2538T41b)&&(!defined(ONLY)||defined(CASE_2538T41b))
#include <algorithm>
#include <cstring>
#include <string>
#include "iter.h"
int f_2538T41b(Char c1, Char c2)
	{return (tolower(c1) < tolower(c2)); }
#endif /* CASE_2538T41b */

/* _254T21 <cstdlib> synopsis */
#if !defined(SKIP_254T21)&&(!defined(ONLY)||defined(CASE_254T21))
#include <cstdlib>
int CLINK cmp_254T21(const void *p1, const void *p2)
	{return (*(unsigned char *)p1 - *(unsigned char *)p2); }
#endif /* CASE_254T21 */

int t258_main(int, char *[])
{
enter_chk("t258.cpp");
/* _25361T31a push_heap(first, last)   effects, complexity */
#if !defined(SKIP_25361T31a)&&(!defined(ONLY)||defined(CASE_25361T31a))
	begin_chk("_25361T31a");
	{
	// simple pointers
	Char buf[] = "yxcbaz";
	Char *p1 = buf;
	Char *p2 = buf+6;
	push_heap(p1, p1 + 1);
	steq(buf, "yxcbaz");
	push_heap(p1, p1 + 2);
	steq(buf, "yxcbaz");
	push_heap(p1, p1 + 5);
	steq(buf, "yxcbaz");
	push_heap(p1, p2);
	ieq(*p1, 'z');

	// strings
	Ustr s ("7653214");
	push_heap(s.begin(), s.end());
	ieq(s[0], '7');
	chk(s[7] != '4');

	// strict iterators over strings
	const Char *buf2 = (const Char *)"dbcax";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	push_heap(it1, it2);
	ieq(s4[0], 'x');
	ieq(err1, 0);
	ieq(err2, 0);

	}
	end_chk("_25361T31a");
#else
	skip_chk("_25361T31a");
#endif /* CASE_25361T31a */

/* _25361T31b push_heap(first, last, comp)   effects, complexity */
#if !defined(SKIP_25361T31b)&&(!defined(ONLY)||defined(CASE_25361T31b))
	begin_chk("_25361T31b");
	{
	// simple pointers
	Char buf[] = "yxCbaZ";
	Char *p1 = buf;
	Char *p2 = buf+6;
	push_heap(p1, p1 + 1, f_25361T31b);
	steq(buf, "yxCbaZ");
	push_heap(p1, p1 + 2, f_25361T31b);
	steq(buf, "yxCbaZ");
	push_heap(p1, p1 + 5, f_25361T31b);
	steq(buf, "yxCbaZ");
	npreds_25361T31b = 0;
	push_heap(p1, p2, f_25361T31b);
	int n = 6;
	ileq(npreds_25361T31b,  ceil_log2(n));
	ieq(*p1, 'Z');

	// strings
	Ustr s ("7653214");
	npreds_25361T31b = 0;
	push_heap(s.begin(), s.end(), f_25361T31b);
	n = 6;
	ileq(npreds_25361T31b, ceil_log2(n));
	ieq(s[0], '7');
	chk(s[7] != '4');

	// strict iterators over strings
	const Char *buf2 = (const Char *)"dBCax";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	push_heap(it1, it2, f_25361T31b);
	ieq(s4[0], 'x');
	ieq(err1, 0);
	ieq(err2, 0);


	}
	end_chk("_25361T31b");
#else
	skip_chk("_25361T31b");
#endif /* CASE_25361T31b */

/* _25362T31a pop_heap(first, last)   effects, complexity */
#if !defined(SKIP_25362T31a)&&(!defined(ONLY)||defined(CASE_25362T31a))
	begin_chk("_25362T31a");
	{
	// simple pointers
	Char buf[] = "zxycba";
	Char *p1 = buf;
	Char *p2 = buf+6;
	pop_heap(p1, p1 + 1);
	steq(buf, "zxycba");
	pop_heap(p1, p2);
	ieq(*p1, 'y');
	ieq(*(p2 - 1), 'z');

	// strings
	Ustr s ("7654321");
	pop_heap(s.begin(), s.end());
	ieq(s[0], '6');
	ieq(s[6], '7');

	// strict iterators over strings
	const Char *buf2 = (const Char *)"xcdba";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	pop_heap(it1, it2);
	ieq(s4[0], 'd');
	ieq(s4[4], 'x');
	ieq(err1, 0);
	ieq(err2, 0);

	}
	end_chk("_25362T31a");
#else
	skip_chk("_25362T31a");
#endif /* CASE_25362T31a */

/* _25362T31b pop_heap(first, last, comp)   effects, complexity */
#if !defined(SKIP_25362T31b)&&(!defined(ONLY)||defined(CASE_25362T31b))
	begin_chk("_25362T31b");
	{
	// simple pointers
	Char buf[] = "ZyxCba";
	Char *p1 = buf;
	Char *p2 = buf+6;
	npreds_25362T31b = 0;
	pop_heap(p1, p2, f_25362T31b);
	int n = 6;
	ileq(npreds_25362T31b, 2 * ceil_log2(n));
	ieq(buf[0], 'y');
	ieq(buf[5], 'Z');

	// strings
	npreds_25362T31b = 0;
	Ustr s ("ZyxCba");
	pop_heap(s.begin(), s.end(), f_25362T31b);
	ieq(buf[0], 'y');
	ieq(buf[5], 'Z');

	// strict iterators over strings
	const Char *buf2 = (const Char *)"xCdBa";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	pop_heap(it1, it2, f_25362T31b);
	ieq(s4[0], 'd');
	ieq(s4[4], 'x');
	ieq(err1, 0);
	ieq(err2, 0);


	}
	end_chk("_25362T31b");
#else
	skip_chk("_25362T31b");
#endif /* CASE_25362T31b */

/* _25363T31a make_heap(first, last)   effects, complexity */
#if !defined(SKIP_25363T31a)&&(!defined(ONLY)||defined(CASE_25363T31a))
	begin_chk("_25363T31a");
	{
	// simple pointers
	Char buf[] = "xazbcy";
	Char *p1 = buf;
	Char *p2 = buf+6;
	make_heap(p1, p1);
	steq(buf, "xazbcy");
	make_heap(p1, p1 + 1);
	steq(buf, "xazbcy");
	make_heap(p1, p1 + 2);
	steq(buf, "xazbcy");
	make_heap(p1, p2);
	ieq(*p1, 'z');

	// strings
	Ustr s("22101");
	make_heap(s.begin(), s.end());
	ieq(s[0], '2');
	pop_heap(s.begin(), s.end());
	ieq(s[0], '2');
	pop_heap(s.begin(), s.end() - 1);
	ieq(s[0], '1');

	// strict iterators over strings
	const Char *buf2 = (const Char *)"baxcd";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	make_heap(it1, it2);
	ieq(s4[0], 'x');
	ieq(err1, 0);
	ieq(err2, 0);

	}
	end_chk("_25363T31a");
#else
	skip_chk("_25363T31a");
#endif /* CASE_25363T31a */

/* _25363T31b make_heap(first, last, comp)   effects, complexity */
#if !defined(SKIP_25363T31b)&&(!defined(ONLY)||defined(CASE_25363T31b))
	begin_chk("_25363T31b");
	{
	// simple pointers
	Char buf[] = "xaZBcy";
	Char *p1 = buf;
	Char *p2 = buf+6;
	make_heap(p1, p1, f_25363T31b);
	steq(buf, "xaZBcy");
	make_heap(p1, p1 + 1, f_25363T31b);
	steq(buf, "xaZBcy");
	make_heap(p1, p1 + 2, f_25363T31b);
	steq(buf, "xaZBcy");
	npreds_25363T31b = 0;
	make_heap(p1, p2, f_25363T31b);
	int n = 6;
	ileq(npreds_25363T31b, 3 * n);
	ieq(*p1, 'Z');

	// strings
	npreds_25363T31b = 0;
	Ustr s ("22101");
	make_heap(s.begin(), s.end(), f_25363T31b);
	ieq(s[0], '2');
	pop_heap(s.begin(), s.end(), f_25363T31b);
	ieq(s[0], '2');
	pop_heap(s.begin(), s.end() - 1, f_25363T31b);
	ieq(s[0], '1');

	// strict iterators over strings
	const Char *buf2 = (const Char *)"bAXcd";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	make_heap(it1, it2, f_25363T31b);
	ieq(s4[0], 'X');
	ieq(err1, 0);
	ieq(err2, 0);



	}
	end_chk("_25363T31b");
#else
	skip_chk("_25363T31b");
#endif /* CASE_25363T31b */

/* _25364T21a sort_heap(first, last)   effects, complexity */
#if !defined(SKIP_25364T21a)&&(!defined(ONLY)||defined(CASE_25364T21a))
	begin_chk("_25364T21a");
	{
	// simple pointers
	Char buf[] = "zxycba";
	Char *p1 = buf;
	Char *p2 = buf+6;
	sort_heap(p1, p1);
	steq(buf, "zxycba");
	sort_heap(p1, p1 + 1);
	steq(buf, "zxycba");
	sort_heap(p1 + 3, p1 + 5);
	steq(buf, "zxybca");
	sort_heap(p1, p2);
	steq(buf, "abcxyz");

	// strings
	Ustr s ("765432210");
	sort_heap(s.begin(), s.end());
	steq(s.c_str(), "012234567");

	// strict iterators over strings
	const Char *buf2 = (const Char *)"xcdba";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	sort_heap(it1, it2);
	steq(s4.c_str(), "abcdx");
	ieq(err1, 0);
	ieq(err2, 0);

	}
	end_chk("_25364T21a");
#else
	skip_chk("_25364T21a");
#endif /* CASE_25364T21a */

/* _25364T21b sort_heap(first, last, comp)   effects, complexity */
#if !defined(SKIP_25364T21b)&&(!defined(ONLY)||defined(CASE_25364T21b))
	begin_chk("_25364T21b");
	{
	// simple pointers
	Char buf[] = "zXyCba";
	Char *p1 = buf;
	Char *p2 = buf+6;
	sort_heap(p1, p1, f_25364T21b);
	steq(buf, "zXyCba");
	sort_heap(p1, p1 + 1, f_25364T21b);
	steq(buf, "zXyCba");
	sort_heap(p1 + 3, p1 + 5, f_25364T21b);
	steq(buf, "zXybCa");
	npreds_25364T21b = 0;
	sort_heap(p1, p2, f_25364T21b);
	int n = 6;
	ileq(npreds_25364T21b, n * ceil_log2(n));
	steq(buf, "abCXyz");

	// strings
	Ustr s("765432210");
	sort_heap(s.begin(), s.end(), f_25364T21b);
	steq(s.c_str(), "012234567");

	// strict iterators over strings
	const Char *buf2 = (const Char *)"xCDba";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	sort_heap(it1, it2, f_25364T21b);
	steq(s4.c_str(), "abCDx");
	ieq(err1, 0);
	ieq(err2, 0);


	}
	end_chk("_25364T21b");
#else
	skip_chk("_25364T21b");
#endif /* CASE_25364T21b */

/* _2537T21a min(a, b)   returns, notes */
#if !defined(SKIP_2537T21a)&&(!defined(ONLY)||defined(CASE_2537T21a))
	begin_chk("_2537T21a");
	{
	ieq(min('a', 'b'), 'a');
	ieq(min('b', 'a'), 'a');
	deq(min(1.0, -2.0), -2.0);
	leq(min(2L, 3L), 2L);

	}
	end_chk("_2537T21a");
#else
	skip_chk("_2537T21a");
#endif /* CASE_2537T21a */

/* _2537T21b min(a, b, comp)  returns, notes */
#if !defined(SKIP_2537T21b)&&(!defined(ONLY)||defined(CASE_2537T21b))
	begin_chk("_2537T21b");
	{
	ieq(min('a', 'b', g_2537T21b), 'a');
	ieq(min('b', 'B', g_2537T21b), 'b');
	ieq(min('B', 'b', g_2537T21b), 'B');
	ieq(min('A', 'b', g_2537T21b), 'A');
	deq(min(1.0, -2.0, h_2537T21b), 1.0);
	leq(min(12L, 3L, i_2537T21b), 12L);


	}
	end_chk("_2537T21b");
#else
	skip_chk("_2537T21b");
#endif /* CASE_2537T21b */

/* _2537T51a max(a, b)   returns, notes */
#if !defined(SKIP_2537T51a)&&(!defined(ONLY)||defined(CASE_2537T51a))
	begin_chk("_2537T51a");
	{
	ieq(max('a', 'b'), 'b');
	ieq(max('b', 'a'), 'b');
	deq(max(1.0, -2.0), 1.0);
	leq(max(2L, 3L), 3L);

	}
	end_chk("_2537T51a");
#else
	skip_chk("_2537T51a");
#endif /* CASE_2537T51a */

/* _2537T51b max(a, b, comp)  returns, notes */
#if !defined(SKIP_2537T51b)&&(!defined(ONLY)||defined(CASE_2537T51b))
	begin_chk("_2537T51b");
	{
	ieq(max('a', 'b', g_2537T51b), 'b');
	ieq(max('B', 'b', g_2537T51b), 'B');
	ieq(max('b', 'B', g_2537T51b), 'b');
	ieq(max('A', 'b', g_2537T51b), 'b');
	deq(max(1.0, -2.0, h_2537T51b), -2.0);
	leq(max(12L, 3L, i_2537T51b), 3L);



	}
	end_chk("_2537T51b");
#else
	skip_chk("_2537T51b");
#endif /* CASE_2537T51b */

/* _2537T81a min_element(a, b)   returns */
#if !defined(SKIP_2537T81a)&&(!defined(ONLY)||defined(CASE_2537T81a))
	begin_chk("_2537T81a");
	{
	// simple pointers
	const Char buf[] = "zayxca";
	const Char *p1 = buf;
	const Char *p2 = buf+6;
	chk(min_element(p1, p1) == p1);
	chk(min_element(p1, p1 + 1) == p1);
	chk(min_element(p1, p1 + 2) == p1 + 1);
	chk(min_element(p1 + 1, p1 + 3) == p1 + 1);
	const Char *r = min_element(p1, p2);
	chk(r == p1 + 1);
	ieq(*r, 'a');

	// strings
	Ustr s ("azaxay");
	Ustr::const_iterator r2 = min_element(s.begin(), s.end());
	ieq(*r2, 'a');
	ieq(r2 - s.begin(), 0);

	// strict iterators over strings
	const Char *buf2 = (const Char *)"31011";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	strict_forward_iterator<Ustr::iterator, Char> it3
		(min_element(it1, it2));
	ieq(*it3, '0');
	ieq(err1, 0);
	ieq(err2, 0);

	}
	end_chk("_2537T81a");
#else
	skip_chk("_2537T81a");
#endif /* CASE_2537T81a */

/* _2537T81b min_element(a, b, comp)  returns, complexity */
#if !defined(SKIP_2537T81b)&&(!defined(ONLY)||defined(CASE_2537T81b))
	begin_chk("_2537T81b");
	{
	// simple pointers
	const Char buf[] = "zayXcA";
	const Char *p1 = buf;
	const Char *p2 = buf+6;
	chk(min_element(p1, p1, f_2537T81b) == p1);
	chk(min_element(p1, p1 + 1, f_2537T81b) == p1);
	chk(min_element(p1, p1 + 2, f_2537T81b) == p1 + 1);
	chk(min_element(p1 + 1, p1 + 3, f_2537T81b) == p1 + 1);
	npreds_2537T81b = 0;
	const Char *r = min_element(p1, p2, f_2537T81b);
	int n = 6;
	ileq(npreds_2537T81b, (n - 1 < 0 ? 0 : n - 1));
	chk(r == p1 + 1);
	ieq(*r, 'a');

	// strings
	Ustr s ("azAxay");
	npreds_2537T81b = 0;
	Ustr::const_iterator r2 = min_element(s.begin(), s.end(), f_2537T81b);
	n = 6;
	ileq(npreds_2537T81b, (n - 1 < 0 ? 0 : n - 1));
	ieq(*r2, 'a');
	ieq(r2 - s.begin(), 0);

	// strict iterators over strings
	const Char *buf2 = (const Char *)"31011";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	strict_forward_iterator<Ustr::iterator, Char> it3
		(min_element(it1, it2, f_2537T81b));
	ieq(*it3, '0');
	ieq(err1, 0);
	ieq(err2, 0);


	}
	end_chk("_2537T81b");
#else
	skip_chk("_2537T81b");
#endif /* CASE_2537T81b */

/* _2537T_111a max_element(a, b)   returns, complexity */
#if !defined(SKIP_2537T_111a)&&(!defined(ONLY)||defined(CASE_2537T_111a))
	begin_chk("_2537T_111a");
	{
	// simple pointers
	const Char buf[] = "zayxca";
	const Char *p1 = buf;
	const Char *p2 = buf+6;
	chk(max_element(p1, p1) == p1);
	chk(max_element(p1, p1 + 1) == p1);
	chk(max_element(p1, p1 + 2) == p1);
	chk(max_element(p1 + 1, p1 + 3) == p1 + 2);
	const Char *r = max_element(p1, p2);
	chk(r == p1);
	ieq(*r, 'z');

	// strings
	Ustr s ("axazay");
	Ustr::const_iterator r2 = max_element(s.begin(), s.end());
	ieq(*r2, 'z');
	ieq(r2 - s.begin(), 3);

	// strict iterators over strings
	const Char *buf2 = (const Char *)"31411";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	strict_forward_iterator<Ustr::iterator, Char> it3
		(max_element(it1, it2));
	ieq(*it3, '4');
	ieq(err1, 0);
	ieq(err2, 0);

	}
	end_chk("_2537T_111a");
#else
	skip_chk("_2537T_111a");
#endif /* CASE_2537T_111a */

/* _2537T_111b max_element(a, b, comp)  returns, complexity */
#if !defined(SKIP_2537T_111b)&&(!defined(ONLY)||defined(CASE_2537T_111b))
	begin_chk("_2537T_111b");
	{
	// simple pointers
	const Char buf[] = "ZayxCa";
	const Char *p1 = buf;
	const Char *p2 = buf+6;
	chk(max_element(p1, p1, f_2537T_111b) == p1);
	chk(max_element(p1, p1 + 1, f_2537T_111b) == p1);
	chk(max_element(p1, p1 + 2, f_2537T_111b) == p1);
	chk(max_element(p1 + 1, p1 + 3, f_2537T_111b) == p1 + 2);
	npreds_2537T_111b = 0;
	const Char *r = max_element(p1, p2, f_2537T_111b);
	int n = 6;
	ileq(npreds_2537T_111b, (n - 1 < 0 ? 0 : n - 1));
	chk(r == p1);
	ieq(*r, 'Z');

	// strings
	Ustr s ("AxaZzy");
	npreds_2537T_111b = 0;
	Ustr::const_iterator r2 = max_element(s.begin(), s.end(), f_2537T_111b);
	n = 6;
	ileq(npreds_2537T_111b, (n - 1 < 0 ? 0 : n - 1));
	ieq(*r2, 'Z');
	ieq(r2 - s.begin(), 3);

	// strict iterators over strings
	const Char *buf2 = (const Char *)"31411";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	strict_forward_iterator<Ustr::iterator, Char> it3
		(max_element(it1, it2, f_2537T_111b));
	ieq(*it3, '4');
	ieq(err1, 0);
	ieq(err2, 0);



	}
	end_chk("_2537T_111b");
#else
	skip_chk("_2537T_111b");
#endif /* CASE_2537T_111b */

/* _2538T21a lexicographical_compare(-)   returns, complexity */
#if !defined(SKIP_2538T21a)&&(!defined(ONLY)||defined(CASE_2538T21a))
	begin_chk("_2538T21a");
	{
	// simple pointers
	Char buf[] = "aby";
	Char bufb[] = "abz";
	chk(!lexicographical_compare(buf, buf, bufb, bufb));
	chk(!lexicographical_compare(buf, buf + 1, bufb, bufb));
	chk(lexicographical_compare(buf, buf, bufb, bufb + 1));
	chk(lexicographical_compare(buf, buf + 1, bufb, bufb + 2));
	chk(!lexicographical_compare(buf, buf + 2, bufb, bufb + 2));
	bool r = lexicographical_compare(buf, buf + 3, bufb, bufb + 3);
	ieq(r, true);

	// strings
	Ustr s ("zzaxz");
	Ustr sb ("zzaxzY");
	chk(lexicographical_compare(s.begin(), s.end(), sb.begin(), sb.end()));

	// strict iterators over strings
	const Char *buf2 = (const Char *)"01133";
	Ustr s4(buf2, buf2 + 5);
	const Char *buf3 = (const Char *)"0113";
	Ustr s5(buf3, buf3 + 4);
	int err1 = 0, nrec1 = 5;
	strict_input_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	int err3 = 0, nrec3 = 4;
	strict_input_iterator<Ustr::iterator, Char> it3
		(s5.begin(), err3, nrec3);
	int err4 = 0, nrec4 = 0;
	strict_input_iterator<Ustr::iterator, Char> it4
		(s5.end(), err4, nrec4);
	chk(!lexicographical_compare(it1, it2, it3, it4));
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);
	ieq(err4, 0);

	}
	end_chk("_2538T21a");
#else
	skip_chk("_2538T21a");
#endif /* CASE_2538T21a */

/* _2538T21b lexicographical_compare(-,comp)   returns, complexity */
#if !defined(SKIP_2538T21b)&&(!defined(ONLY)||defined(CASE_2538T21b))
	begin_chk("_2538T21b");
	{
	// simple pointers
	Char buf[] = "ABy";
	Char bufb[] = "abz";
	chk(!lexicographical_compare(buf, buf, bufb, bufb, f_2538T21b));
	chk(!lexicographical_compare(buf, buf + 1, bufb, bufb, f_2538T21b));
	chk(lexicographical_compare(buf, buf, bufb, bufb + 1, f_2538T21b));
	chk(lexicographical_compare(buf, buf + 1, bufb, bufb + 2, f_2538T21b));
	chk(!lexicographical_compare(buf, buf + 2, bufb, bufb + 2, f_2538T21b));
	npreds_2538T21b = 0;
	bool r = lexicographical_compare(buf, buf + 3, bufb, bufb + 3, f_2538T21b);
	int n = 3;
	int m = 3;
	ileq(npreds_2538T21b, 2 * (n < m ? n : m));
	ieq(r, true);

	// strings
	Ustr s ("zzaxz");
	Ustr sb ("zZAxzY");
	npreds_2538T21b = 0;
	chk(lexicographical_compare(s.begin(), s.end(), sb.begin(), sb.end(), f_2538T21b));
	n = 5;
	m = 6;
	ileq(npreds_2538T21b, 2 * (n < m ? n : m));

	// strict iterators over strings
	const Char *buf2 = (const Char *)"01133";
	Ustr s4(buf2, buf2 + 5);
	const Char *buf3 = (const Char *)"0113";
	Ustr s5(buf3, buf3 + 4);
	int err1 = 0, nrec1 = 5;
	strict_input_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	int err3 = 0, nrec3 = 4;
	strict_input_iterator<Ustr::iterator, Char> it3
		(s5.begin(), err3, nrec3);
	int err4 = 0, nrec4 = 0;
	strict_input_iterator<Ustr::iterator, Char> it4
		(s5.end(), err4, nrec4);
	chk(!lexicographical_compare(it1, it2, it3, it4, f_2538T21b));
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);
	ieq(err4, 0);


	}
	end_chk("_2538T21b");
#else
	skip_chk("_2538T21b");
#endif /* CASE_2538T21b */

/* _2538T31a next_permutation(first, last)   effects, complexity */
#if !defined(SKIP_2538T31a)&&(!defined(ONLY)||defined(CASE_2538T31a))
	begin_chk("_2538T31a");
	{
	// simple pointers
	Char buf[] = "akz";
	Char *p1 = buf;
	Char *p2 = buf + 2;
	chk(!next_permutation(buf, buf));
	steq(buf, "akz");
	chk(!next_permutation(buf, buf + 1));
	steq(buf, "akz");
	chk(next_permutation(buf, buf + 2));
	steq(buf, "kaz");
	chk(!next_permutation(buf, buf + 2));
	steq(buf, "akz");
	bool r = next_permutation(p1, p2);
	steq(buf, "kaz");
	ieq(r, true);

	// strings
	Ustr s("zyxba");
	bool r2 = next_permutation(s.begin(), s.end());
	steq(s.c_str(), "abxyz");
	ieq(r2, false);

	// strict iterators over strings
	const Char *buf2 = (const Char *)"aedcb";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_bidirectional_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_bidirectional_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	chk(next_permutation(it1, it2));
	ieq(err1, 0);
	ieq(err2, 0);

	// complexity
	Mychar_2538T31a a[10];
	int n = 10;
	for (int i = 0; i < n; i ++)
		a[i] = '0' + i;
	random_shuffle(a, a + 10);
	cnt_2538T31a = 0;
	next_permutation(a, a + 10);
	ileq(cnt_2538T31a, (3 * n) / 2);
	random_shuffle(a, a + 10);
	cnt_2538T31a = 0;
	next_permutation(a, a + 10);
	ileq(cnt_2538T31a, (3 * n) / 2);

	}
	end_chk("_2538T31a");
#else
	skip_chk("_2538T31a");
#endif /* CASE_2538T31a */

/* _2538T31b next_permutation(first, last, comp)   effects, complexity */
#if !defined(SKIP_2538T31b)&&(!defined(ONLY)||defined(CASE_2538T31b))
	begin_chk("_2538T31b");
	{
	// simple pointers
	Char buf[] = "aKz";
	Char *p1 = buf;
	Char *p2 = buf + 2;
	chk(!next_permutation(buf, buf, f_2538T31b));
	steq(buf, "aKz");
	chk(!next_permutation(buf, buf + 1, f_2538T31b));
	steq(buf, "aKz");
	chk(next_permutation(buf, buf + 2, f_2538T31b));
	steq(buf, "Kaz");
	chk(!next_permutation(buf, buf + 2, f_2538T31b));
	steq(buf, "aKz");
	bool r = next_permutation(p1, p2, f_2538T31b);
	steq(buf, "Kaz");
	ieq(r, true);

	// strings
	Ustr s("zyxba");
	bool r2 = next_permutation(s.begin(), s.end(), f_2538T31b);
	steq(s.c_str(), "abxyz");
	ieq(r2, false);

	// strict iterators over strings
	const Char *buf2 = (const Char *)"aedcb";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_bidirectional_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_bidirectional_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	chk(next_permutation(it1, it2, f_2538T31b));
	ieq(err1, 0);
	ieq(err2, 0);


	}
	end_chk("_2538T31b");
#else
	skip_chk("_2538T31b");
#endif /* CASE_2538T31b */

/* _2538T41a prev_permutation(first, last)   effects, complexity */
#if !defined(SKIP_2538T41a)&&(!defined(ONLY)||defined(CASE_2538T41a))
	begin_chk("_2538T41a");
	{
	// simple pointers
	Char buf[] = "akz";
	Char *p1 = buf;
	Char *p2 = buf + 2;
	chk(!prev_permutation(buf, buf));
	steq(buf, "akz");
	chk(!prev_permutation(buf, buf + 1));
	steq(buf, "akz");
	chk(!prev_permutation(buf, buf + 2));
	steq(buf, "kaz");
	chk(prev_permutation(buf, buf + 2));
	steq(buf, "akz");
	chk(!prev_permutation(buf, buf + 2));
	steq(buf, "kaz");
	bool r = prev_permutation(p1, p2);
	steq(buf, "akz");
	ieq(r, true);

	// strings
	Ustr s("abxyz");
	bool r2 = prev_permutation(s.begin(), s.end());
	steq(s.c_str(), "zyxba");
	ieq(r2, false);

	// strict iterators over strings
	const Char *buf2 = (const Char *)"aedcb";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_bidirectional_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_bidirectional_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	chk(prev_permutation(it1, it2));
	ieq(err1, 0);
	ieq(err2, 0);

	// complexity
	Mychar_2538T41a a[10];
	int n = 10;
	for (int i = 0; i < n; i ++)
		a[i] = '0' + i;
	random_shuffle(a, a + 10);
	cnt_2538T41a = 0;
	prev_permutation(a, a + 10);
	ileq(cnt_2538T41a, (3 * n) / 2);
	random_shuffle(a, a + 10);
	cnt_2538T41a = 0;
	prev_permutation(a, a + 10);
	ileq(cnt_2538T41a, (3 * n) / 2);

	}
	end_chk("_2538T41a");
#else
	skip_chk("_2538T41a");
#endif /* CASE_2538T41a */

/* _2538T41b prev_permutation(first, last, comp)   effects, complexity */
#if !defined(SKIP_2538T41b)&&(!defined(ONLY)||defined(CASE_2538T41b))
	begin_chk("_2538T41b");
	{
	// simple pointers
	Char buf[] = "aKz";
	Char *p1 = buf;
	Char *p2 = buf + 2;
	chk(!prev_permutation(buf, buf, f_2538T41b));
	steq(buf, "aKz");
	chk(!prev_permutation(buf, buf + 1, f_2538T41b));
	steq(buf, "aKz");
	chk(!prev_permutation(buf, buf + 2, f_2538T41b));
	steq(buf, "Kaz");
	chk(prev_permutation(buf, buf + 2, f_2538T41b));
	steq(buf, "aKz");
	chk(!prev_permutation(buf, buf + 2, f_2538T41b));
	steq(buf, "Kaz");
	bool r = prev_permutation(p1, p2, f_2538T41b);
	steq(buf, "aKz");
	ieq(r, true);

	// strings
	Ustr s("abxyz");
	bool r2 = prev_permutation(s.begin(), s.end(), f_2538T41b);
	steq(s.c_str(), "zyxba");
	ieq(r2, false);

	// strict iterators over strings
	const Char *buf2 = (const Char *)"aedcb";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_bidirectional_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 5;
	strict_bidirectional_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2, nrec2);
	chk(prev_permutation(it1, it2, f_2538T41b));
	ieq(err1, 0);
	ieq(err2, 0);


	}
	end_chk("_2538T41b");
#else
	skip_chk("_2538T41b");
#endif /* CASE_2538T41b */

/* _254T21 <cstdlib> synopsis */
#if !defined(SKIP_254T21)&&(!defined(ONLY)||defined(CASE_254T21))
	begin_chk("_254T21");
	{
	char abc[] = "fghijpqrstxyzuklabcdemnovw";
	qsort(abc, 26, 1, &cmp_254T21);
	chk((char *)bsearch("0", abc, 26, 1, &cmp_254T21) == 0);
	chk((char *)bsearch("c", abc, 26, 1, &cmp_254T21) == &abc[2]);



	}
	end_chk("_254T21");
#else
	skip_chk("_254T21");
#endif /* CASE_254T21 */

return leave_chk("t258");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t251.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _2511T21a for_each    effects, returns, complexity, notes */
#if !defined(SKIP_2511T21a)&&(!defined(ONLY)||defined(CASE_2511T21a))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
int sum_2511T21a = 0;
int f_2511T21a(Char c)
	{sum_2511T21a += c;
	return (0); }
typedef int (*f_type_2511T21a)(Char c);
f_type_2511T21a pf_2511T21a = 0;
#endif /* CASE_2511T21a */

/* _2512T21a find    returns, complexity */
#if !defined(SKIP_2512T21a)&&(!defined(ONLY)||defined(CASE_2512T21a))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
#endif /* CASE_2512T21a */

/* _2512T21b find_if    returns, complexity */
#if !defined(SKIP_2512T21b)&&(!defined(ONLY)||defined(CASE_2512T21b))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
#include <functional>
bool f_2512T21b(Char c)
	{return (c == 'b'); }
class equal_to_b_2512T21b 
	{
public:
	int operator() (Char c)
		{
		const STD equal_to<Char> x = equal_to<Char>();
		return x(c, 'b');
		}
	};
#endif /* CASE_2512T21b */

/* _2513T31a find_end(-) effects, returns */
#if !defined(SKIP_2513T31a)&&(!defined(ONLY)||defined(CASE_2513T31a))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
#endif /* CASE_2513T31a */

/* _2513T31b find_end(-, pred) effects, returns, complexity */
#if !defined(SKIP_2513T31b)&&(!defined(ONLY)||defined(CASE_2513T31b))
#include "iter.h"
#include <algorithm>
#include <cctype>
#include <cstring>
#include <string>
#include <functional>
int npreds_2513T31b;
bool f_2513T31b(Char c, Char c2)
	{++npreds_2513T31b;
	return (tolower(c) == tolower(c2)); }
#endif /* CASE_2513T31b */

/* _2514T31a find_first_of(-) effects, returns, complexity */
#if !defined(SKIP_2514T31a)&&(!defined(ONLY)||defined(CASE_2514T31a))
#include <algorithm>
#include <string>
#include <cstring>
#include "iter.h"
#endif /* CASE_2514T31a */

/* _2514T31b find_first_of(-, pred) effects, returns, complexity */
#if !defined(SKIP_2514T31b)&&(!defined(ONLY)||defined(CASE_2514T31b))
#include <algorithm>
#include <cctype>
#include <cstring>
#include <string>
#include <functional>
#include "iter.h"
int npreds_2514T31b;
bool f_2514T31b(Char c1, Char c2)
	{++npreds_2514T31b;
	return (tolower(c1) == tolower(c2)); }
#endif /* CASE_2514T31b */

/* _2515T31a adjacent_find(-) effects, returns, complexity */
#if !defined(SKIP_2515T31a)&&(!defined(ONLY)||defined(CASE_2515T31a))
#include <algorithm>
#include <string>
#include <cstring>
#include "iter.h"
#endif /* CASE_2515T31a */

/* _2515T31b adjacent_find(-, pred) effects, returns, complexity */
#if !defined(SKIP_2515T31b)&&(!defined(ONLY)||defined(CASE_2515T31b))
#include <algorithm>
#include <cctype>
#include <cstring>
#include <string>
#include <functional>
#include "iter.h"
int npreds_2515T31b = 0;
bool f_2515T31b(Char c1, Char c2)
	{++npreds_2515T31b;
	return (tolower(c1) == tolower(c2)); }
#endif /* CASE_2515T31b */

/* _2516T31a count effects, complexity */
#if !defined(SKIP_2516T31a)&&(!defined(ONLY)||defined(CASE_2516T31a))
#include <algorithm>
#include <string>
#include <cstring>
#include "iter.h"
#endif /* CASE_2516T31a */

/* _2516T31b count_if   effects, complexity */
#if !defined(SKIP_2516T31b)&&(!defined(ONLY)||defined(CASE_2516T31b))
#include <algorithm>
#include <cstring>
#include <string>
#include <functional>
#include "iter.h"
int npreds_2516T31b = 0;
bool f_2516T31b(Char c1)
	{++npreds_2516T31b;
	return (c1 == 'b'); }
class not_equal_to_b_2516T31b 
	{
public:
	int operator() (Char c)
		{
		const STD equal_to<Char> x = equal_to<Char>();
		return !x(c, 'b');
		}
	};
#endif /* CASE_2516T31b */

/* _2517T31a mismatch(-)  returns, complexity */
#if !defined(SKIP_2517T31a)&&(!defined(ONLY)||defined(CASE_2517T31a))
#include <algorithm>
#include <string>
#include <cstring>
#include "iter.h"
#endif /* CASE_2517T31a */

/* _2517T31b mismatch(-, pred) returns, complexity */
#if !defined(SKIP_2517T31b)&&(!defined(ONLY)||defined(CASE_2517T31b))
#include <algorithm>
#include <cstring>
#include <string>
#include <functional>
#include "iter.h"
int npreds_2517T31b = 0;
bool f_2517T31b(Char c1, Char c2)
	{++npreds_2517T31b;
	return (c1 == c2); }
const STD equal_to<Char> x_2517T31b = equal_to<Char>();
#endif /* CASE_2517T31b */

/* _2518T31a equal(-)  returns [not complexity] */
#if !defined(SKIP_2518T31a)&&(!defined(ONLY)||defined(CASE_2518T31a))
#include <algorithm>
#include <string>
#include <cstring>
#include "iter.h"
#endif /* CASE_2518T31a */

/* _2518T31b equal(-, pred) returns, complexity */
#if !defined(SKIP_2518T31b)&&(!defined(ONLY)||defined(CASE_2518T31b))
#include <algorithm>
#include <cstring>
#include <string>
#include <functional>
#include "iter.h"
int npreds_2518T31b = 0;
bool f_2518T31b(Char c1, Char c2)
	{++npreds_2518T31b;
	return (c1 == c2); }
#endif /* CASE_2518T31b */

/* _2519T31a search(-)        effects, returns, complexity */
#if !defined(SKIP_2519T31a)&&(!defined(ONLY)||defined(CASE_2519T31a))
#include <algorithm>
#include <string>
#include <cstring>
#include "iter.h"
#endif /* CASE_2519T31a */

/* _2519T31b search(-, pred)  effects, returns, complexity */
#if !defined(SKIP_2519T31b)&&(!defined(ONLY)||defined(CASE_2519T31b))
#include <algorithm>
#include <cstring>
#include <string>
#include <functional>
#include "iter.h"
int npreds_2519T31b;
bool f_2519T31b(Char c1, Char c2)
	{++npreds_2519T31b;
	return (c1 == c2); }
#endif /* CASE_2519T31b */

/* _2519T31c search_n(-)        effects, returns, complexity ADDED [MAR96] */
#if !defined(SKIP_2519T31c)&&(!defined(ONLY)||defined(CASE_2519T31c))
#include <algorithm>
#include <string>
#include <cstring>
#include "iter.h"
#endif /* CASE_2519T31c */

/* _2519T31d search_n(-, pred)  effects, returns, complexity ADDED [MAR96] */
#if !defined(SKIP_2519T31d)&&(!defined(ONLY)||defined(CASE_2519T31d))
#include <algorithm>
#include <cstring>
#include <string>
#include <functional>
#include "iter.h"
int npreds_2519T31d;
bool f_2519T31d(Char c1, Char c2)
	{++npreds_2519T31d;
	return (c1 == c2); }
#endif /* CASE_2519T31d */

int t251_main(int, char *[])
{
enter_chk("t251.cpp");
/* _2511T21a for_each    effects, returns, complexity, notes */
#if !defined(SKIP_2511T21a)&&(!defined(ONLY)||defined(CASE_2511T21a))
	begin_chk("_2511T21a");
	{
	// simple pointers
	Char buf[] = "\1\2";
	sum_2511T21a = 0;
	pf_2511T21a = for_each(buf, buf, f_2511T21a);
	chk(pf_2511T21a == f_2511T21a);
	ieq(sum_2511T21a, 0);
	sum_2511T21a = 0;
	pf_2511T21a = 0;
	Char *p1 = buf;
	Char *p2 = buf+3;
	pf_2511T21a = for_each(p1, p2, f_2511T21a);
	chk(pf_2511T21a == f_2511T21a);
	ieq(sum_2511T21a, 3);

	// strings
	sum_2511T21a = 0;
	pf_2511T21a = 0;
	Ustr s("\1\2");
	pf_2511T21a = for_each(s.begin(), s.end(), f_2511T21a);
	chk(pf_2511T21a == f_2511T21a);
	ieq(sum_2511T21a, 3);

	// strict iterators over strings
	sum_2511T21a = 0;
	pf_2511T21a = 0;
	const Char *buf2 = (const Char *)"abcd";
	Ustr s4 (buf2, buf2+4);
	int err1 = 0, nrec1 = 4;
	strict_input_iterator<Ustr::/*const_2511T21a*/iterator, /*const */Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<Ustr::/*const_2511T21a*/iterator, /*const */Char> it2
		(s4.end(), err2, nrec2);
	pf_2511T21a = for_each(it1, it2, f_2511T21a);
	ieq(err1, 0);
	ieq(err2, 0);


	}
	end_chk("_2511T21a");
#else
	skip_chk("_2511T21a");
#endif /* CASE_2511T21a */

/* _2512T21a find    returns, complexity */
#if !defined(SKIP_2512T21a)&&(!defined(ONLY)||defined(CASE_2512T21a))
	begin_chk("_2512T21a");
	{
	// simple pointers
	Char buf[] = "ab";
	Char *p1 = buf;
	Char *p2 = buf+3;
	Char *p3;
	p3 = find(p1, p1, 'b');
	aeq(p3, buf);
	p3 = find(p1, p2, 'b');
	aeq(p3, buf+1);
	ieq(*p3, 'b');

	// strings
	Ustr s("ab");
	ieq(*find(s.begin(), s.end(), 'b'), 'b');

	// iterators over strings
	const Char *buf2 = (const Char *)"abcd";
	Ustr s4(buf2, buf2+4);
	int err1 = 0, nrec1 = 4;
	strict_input_iterator<Ustr::/*const_2512T21a*/iterator, /*const */Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<Ustr::/*const_2512T21a*/iterator, /*const */Char> it2
		(s4.end(), err2, nrec2);
	ieq(*find(it1, it2, 'b'), 'b');
	ieq(err1, 0);
	ieq(err2, 0);

	}
	end_chk("_2512T21a");
#else
	skip_chk("_2512T21a");
#endif /* CASE_2512T21a */

/* _2512T21b find_if    returns, complexity */
#if !defined(SKIP_2512T21b)&&(!defined(ONLY)||defined(CASE_2512T21b))
	begin_chk("_2512T21b");
	{
	// simple pointers
	Char buf[] = "ab";
	Char *p1 = buf;
	Char *p2 = buf+3;
	Char *p3;
	p3 = find_if(p1, p1, f_2512T21b);
	aeq(p3, buf);
	p3 = find_if(p1, p2, f_2512T21b);
	aeq(p3, buf+1);
	ieq(*p3, 'b');

	// strings
	Ustr s ("ab");
	Ustr::iterator p4 = s.begin();
	Ustr::iterator p5 = find_if(s.begin(), s.end(), f_2512T21b);
	aeq(&*p5, &*p4+1);
	ieq(*p5, 'b');

	// strict iterators over strings
	const Char *buf2 = (const Char *)"abcd";
	Ustr s4(buf2, buf2+4);
	int err1 = 0, nrec1 = 4;
	strict_input_iterator<Ustr::/*const_2512T21b*/iterator, /*const */Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<Ustr::/*const_2512T21b*/iterator, /*const */Char> it2
		(s4.end(), err2, nrec2);
	equal_to_b_2512T21b pred;
	ieq(*find_if(it1, it2, pred), 'b');
	ieq(err1, 0);
	ieq(err2, 0);








	}
	end_chk("_2512T21b");
#else
	skip_chk("_2512T21b");
#endif /* CASE_2512T21b */

/* _2513T31a find_end(-) effects, returns */
#if !defined(SKIP_2513T31a)&&(!defined(ONLY)||defined(CASE_2513T31a))
	begin_chk("_2513T31a");
	{
	// simple pointers
	Char buf0[] = "abcbc";
	Char *p1 = buf0;
	Char *p2 = buf0 + 5;
	Char *p3;
	Char buf1[] = "bc";
	Char *p4 = buf1;
	Char *p5 = buf1 + 2;
	p3 = find_end(p1, p1, p4, p5);
	aeq(p3, p1);
	p3 = find_end(p1, p2, p4, p4);
	aeq(p3, p2);
	p3 = find_end(p1, p2, p4, p5);
	aeq(p3, buf0 + 3);	// [NOV95]
	ieq(*p3, 'b');

	// strings
	Ustr s("xab");
	Ustr t("ab");
	ieq(*find_end(s.begin(), s.end(), t.begin(), t.end()), 'a');	// [NOV95]

	// strict iterators over strings
	const Char *buf2 = (const Char *)"xabcd";
	Ustr s4(buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::/*const_2513T31a*/iterator, /*const */Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::/*const_2513T31a*/iterator, /*const */Char> it2
		(s4.end(), err2, nrec2);
	const Char *buf3 = (const Char *)"ab";
	Ustr s5 (buf3, buf3 + 2);
	int err3 = 0, nrec3 = 2;
	strict_forward_iterator<Ustr::/*const_2513T31a*/iterator, /*const */Char> it3
		(s5.begin(), err3, nrec3);
	int err4 = 0, nrec4 = 0;
	strict_forward_iterator<Ustr::/*const_2513T31a*/iterator, /*const */Char> it4
		(s5.end(), err4, nrec4);
	ieq(*find_end(it1, it2, it3, it4), 'a');	// [NOV95]
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);
	ieq(err4, 0);

	}
	end_chk("_2513T31a");
#else
	skip_chk("_2513T31a");
#endif /* CASE_2513T31a */

/* _2513T31b find_end(-, pred) effects, returns, complexity */
#if !defined(SKIP_2513T31b)&&(!defined(ONLY)||defined(CASE_2513T31b))
	begin_chk("_2513T31b");
	{
	// simple pointers
	Char buf0[] = "abcbC";
	Char *p1 = buf0;
	Char *p2 = buf0 + 5;
	Char *p3;
	Char buf1[] = "Bc";
	Char *p4 = buf1;
	Char *p5 = buf1 + 2;
	npreds_2513T31b = 0;
	p3 = find_end(p1, p1, p4, p5, f_2513T31b);
	aeq(p3, p1);
	p3 = find_end(p1, p2, p4, p4, f_2513T31b);
	aeq(p3, p2);
	p3 = find_end(p1, p2, p4, p5, f_2513T31b);
	aeq(p3, buf0 + 3);	// [NOV95]
	ieq(*p3, 'b');
	chk(npreds_2513T31b <= 9);

	// strings
	Ustr s("xab");
	Ustr t("AB");
	npreds_2513T31b = 0;
	ieq(*find_end(s.begin(), s.end(), t.begin(), t.end(), f_2513T31b), 'a');	// [NOV95]
	chk(npreds_2513T31b <= 6);

	// strict iterators over strings
	const STD equal_to<Char> x = equal_to<Char>();
	const Char *buf2 = (const Char *)"xabcd";
	Ustr s4 (buf2, buf2 + 5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *buf3 = (const Char *)"ab";
	Ustr s5 (buf3, buf3 + 2);
	int err3 = 0, nrec3 = 2;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s5.begin(), err3, nrec3);
	int err4 = 0, nrec4 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it4
		(s5.end(), err4, nrec4);
	ieq(*find_end(it1, it2, it3, it4, x), 'a');	// [NOV95]
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);
	ieq(err4, 0);



	}
	end_chk("_2513T31b");
#else
	skip_chk("_2513T31b");
#endif /* CASE_2513T31b */

/* _2514T31a find_first_of(-) effects, returns, complexity */
#if !defined(SKIP_2514T31a)&&(!defined(ONLY)||defined(CASE_2514T31a))
	begin_chk("_2514T31a");
	{
	// simple pointers
	Char buf[] = "ab";
	Char *p1 = buf;
	Char *p2 = buf+2;
	Char *p3;
	Char *p4 = (Char *)"b";
	Char *p5 = p4+1;
	p3 = find_first_of(p1, p1, p4, p5);
	aeq(p3, p1);
	p3 = find_first_of(p1, p2, p4, p4);
	aeq(p3, p2);
	p3 = find_first_of(p1, p2, p4, p5);
	aeq(p3, buf+1);
	ieq(*p3, 'b');

	// strings
	Ustr s("xab");
	Ustr t("ab");
	ieq(*find_first_of(s.begin(), s.end(), t.begin(), t.end()), 'a');

	// strict iterators over strings
	const Char *ptr = (const Char *)"xabcd";
	Ustr s4(ptr, ptr+5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *ptr2 = (const Char *)"ab";
	Ustr s5 (ptr2, ptr2+2);
	int err3 = 0, nrec3 = 2;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s5.begin(), err3, nrec3);
	int err4 = 0, nrec4 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it4
		(s5.end(), err4, nrec4);
	ieq(*find_first_of(it1, it2, it3, it4), 'a');
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);
	ieq(err4, 0);

	}
	end_chk("_2514T31a");
#else
	skip_chk("_2514T31a");
#endif /* CASE_2514T31a */

/* _2514T31b find_first_of(-, pred) effects, returns, complexity */
#if !defined(SKIP_2514T31b)&&(!defined(ONLY)||defined(CASE_2514T31b))
	begin_chk("_2514T31b");
	{
	// simple pointers
	Char buf[] = "ab";
	Char *p1 = buf;
	Char *p2 = buf+2;
	Char *p3;
	Char *p4 = (Char *)"B";
	Char *p5 = p4+1;
	npreds_2514T31b = 0;
	p3 = find_first_of(p1, p2, p4, p5, f_2514T31b);
	aeq(p3, buf+1);
	ieq(*p3, 'b');
	chk(npreds_2514T31b <= 2);

	// strings
	Ustr s("xabab");
	Ustr t("AB");
	npreds_2514T31b = 0;
	Ustr::iterator i =
		find_first_of(s.begin(), s.end(), t.begin(), t.end(), f_2514T31b);
	ieq(*(i+1), 'b');
	ieq(*i, 'a');
	ieq(*(i-1), 'x');
	chk(npreds_2514T31b <= 10);	// [NOV95]

	// strict iterators over strings
	const STD equal_to<Char> x = equal_to<Char>();
	const Char *buf2 = (const Char *)"xabcd";
	Ustr s4 (buf2, buf2+4);
	int err1 = 0, nrec1 = 4;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *buf3 = (const Char *)"ab";
	Ustr s5 (buf3, buf3+2);
	int err3 = 0, nrec3 = 4;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s5.begin(), err3, nrec3);
	int err4 = 0, nrec4 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it4
		(s5.end(), err4, nrec4);
	ieq(*find_first_of(it1, it2, it3, it4, x), 'a');
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);
	ieq(err4, 0);




	// We will validate adjacent_find using forward_iterator.



	}
	end_chk("_2514T31b");
#else
	skip_chk("_2514T31b");
#endif /* CASE_2514T31b */

/* _2515T31a adjacent_find(-) effects, returns, complexity */
#if !defined(SKIP_2515T31a)&&(!defined(ONLY)||defined(CASE_2515T31a))
	begin_chk("_2515T31a");
	{
	// simple pointers
	Char buf[] = "abb";
	Char *p1 = buf;
	Char *p2 = buf+3;
	Char *p3;
	p3 = adjacent_find(p1, p1);
	aeq(p3, p1);
	p3 = adjacent_find(p1, p1 + 1);
	aeq(p3, p1 + 1);
	p3 = adjacent_find(p1, p2);
	aeq(p3, buf+1);
	ieq(*p3, 'b');
	p3 = adjacent_find(p1, p2 - 1);  // no repeated instance
	aeq(p3, p2 - 1);
	ieq(*p3, 'b');

	// strings
	Ustr s("xbb");
	ieq(*adjacent_find(s.begin(), s.end()), 'b');

	// strict iterators over strings
	const Char *buf2 = (const Char *)"xbbcd";
	Ustr s4 (buf2, buf2+4);
	int err1 = 0, nrec1 = 4;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	strict_forward_iterator<Ustr::iterator, Char> it 
		(adjacent_find(it1, it2));
	ieq(*it, 'b');
	ieq(*++it, 'b');
	ieq(*++it, 'c');
	ieq(err1, 0);
	ieq(err2, 0);
		
	}
	end_chk("_2515T31a");
#else
	skip_chk("_2515T31a");
#endif /* CASE_2515T31a */

/* _2515T31b adjacent_find(-, pred) effects, returns, complexity */
#if !defined(SKIP_2515T31b)&&(!defined(ONLY)||defined(CASE_2515T31b))
	begin_chk("_2515T31b");
	{
	// simple pointers
	Char buf[] = "abb";
	Char *p1 = buf;
	Char *p2 = buf+3;
	Char *p3;
	p3 = adjacent_find(p1, p2, f_2515T31b);
	aeq(p3, buf+1);
	ieq(*p3, 'b');
	ieq(npreds_2515T31b, 2); // complexity

	// strings
	Ustr s("xbBab");
	npreds_2515T31b = 0;
	Ustr::iterator i =
		adjacent_find(s.begin(), s.end(), f_2515T31b);
	ieq(*i, 'b');
	ieq(*++i, 'B');
	ieq(npreds_2515T31b, 2); // complexity

	// strict iterators over strings
	const STD equal_to<Char> x = equal_to<Char>();
	const Char *buf2 = (const Char *)"xbbcd";
	Ustr s4 (buf2, buf2+4);
	int err1 = 0, nrec1 = 4;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	strict_forward_iterator<Ustr::iterator, Char> it 
		(adjacent_find(it1, it2, x));
	ieq(*it, 'b');
	ieq(*++it, 'b');
	ieq(*++it, 'c');
	ieq(err1, 0);
	ieq(err2, 0);


	}
	end_chk("_2515T31b");
#else
	skip_chk("_2515T31b");
#endif /* CASE_2515T31b */

/* _2516T31a count effects, complexity */
#if !defined(SKIP_2516T31a)&&(!defined(ONLY)||defined(CASE_2516T31a))
	begin_chk("_2516T31a");
	{
	// simple pointers
	Char buf[] = "ab";
	Char *p1 = buf;
	Char *p2 = buf+2;
	size_t sum = count(p1, p1, 'b');	// CHANGED [MAR96]
	ieq(sum, 0);
	sum = count(p1, p1 + 1, 'b');
	ieq(sum, 0);
	sum = count(p1, p2, 'b');
	ieq(sum, 1);

	// strings
	Ustr s ("xab");
	sum = count(s.begin(), s.end(), 'b');	// CHANGED [MAR96]
	ieq(sum, 1);

	// strict iterators over strings
	const Char *ptr = (const Char *)"xabcd";
	Ustr s4 (ptr, ptr+4);
	int err1 = 0, nrec1 = 4;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 2;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	sum = count(it1, it2, 'b');	// CHANGED [MAR96]
	ieq(sum, 1);
	ieq(err1, 0);
	ieq(err2, 0);

	}
	end_chk("_2516T31a");
#else
	skip_chk("_2516T31a");
#endif /* CASE_2516T31a */

/* _2516T31b count_if   effects, complexity */
#if !defined(SKIP_2516T31b)&&(!defined(ONLY)||defined(CASE_2516T31b))
	begin_chk("_2516T31b");
	{
	// simple pointers
	Char buf[] = "ab";
	Char *p1 = buf;
	Char *p2 = buf+2;
	size_t sum = count_if(p1, p2, f_2516T31b);	// CHANGED [MAR96]
	ieq(sum, 1);
	chk(npreds_2516T31b == 2);

	// strings
	npreds_2516T31b = 0;
	Ustr s ("xabab");
	sum = count_if(s.begin(), s.end(), f_2516T31b);
	ieq(sum, 2);
	chk(npreds_2516T31b == 5);

	// strict iterators over strings
	not_equal_to_b_2516T31b x = not_equal_to_b_2516T31b();
	const Char *buf2 = (const Char *)"xabcd";
	Ustr s4 (buf2, buf2+5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	sum = count_if(it1, it2, x);
	ieq(sum, 4);
	ieq(err1, 0);
	ieq(err2, 0);


	}
	end_chk("_2516T31b");
#else
	skip_chk("_2516T31b");
#endif /* CASE_2516T31b */

/* _2517T31a mismatch(-)  returns, complexity */
#if !defined(SKIP_2517T31a)&&(!defined(ONLY)||defined(CASE_2517T31a))
	begin_chk("_2517T31a");
	{
	// simple pointers
	Char buf[] = "abxd";
	Char *p1 = buf;
	Char *p2 = buf+4;
	Char bufb[4] = "abd";
	Char *p3 = bufb;
	pair<Char*,Char*> r (mismatch(p1, p2, p3));
	ieq(*r.first, 'x');
	ieq(*r.second, 'd');
	r = mismatch(p2, p2, p3);
	chk(r.first == p2);
	ieq(*r.second, 'a');

	// strings
	Ustr s ("xabcd");
	Ustr t ("xab");
	pair<Ustr::iterator, Ustr::iterator>
		r2(mismatch(s.begin(), s.end(), t.begin()));
	ieq(*r2.first, 'c');
	ieq(r2.second - t.begin(), 3);

	// strict iterators over strings
	const Char *ptr = (const Char *)"abcdy";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *ptrb = (const Char *)"abcdx";
	Ustr s4b (ptrb, ptrb+5);
	int err3 = 0, nrec3 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s4b.begin(), err3, nrec3);
	typedef strict_forward_iterator<Ustr::iterator, Char> FI;
	pair<FI, FI> r3 (mismatch(it1, it2, it3));
	ieq(*r3.first, 'y');
	ieq(*r3.second, 'x');
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);

	}
	end_chk("_2517T31a");
#else
	skip_chk("_2517T31a");
#endif /* CASE_2517T31a */

/* _2517T31b mismatch(-, pred) returns, complexity */
#if !defined(SKIP_2517T31b)&&(!defined(ONLY)||defined(CASE_2517T31b))
	begin_chk("_2517T31b");
	{
	// simple pointers
	Char buf[] = "abxd";
	Char *p1 = buf;
	Char *p2 = buf+4;
	Char bufb[4] = "abd";
	Char *p3 = bufb;
	pair<Char*,Char*> r (mismatch(p1, p2, p3, f_2517T31b));
	ieq(*r.first, 'x');
	ieq(*r.second, 'd');
	chk(npreds_2517T31b <= 4);

	// strings
	Ustr s ("xabcd");
	Ustr t ("xab");
	pair<Ustr::iterator, Ustr::iterator>
		r2(mismatch(s.begin(), s.end(), t.begin(), f_2517T31b));
	ieq(*r2.first, 'c');
	ieq(r2.second - t.begin(), 3);

	// strict iterators over strings
	const Char *ptr = (const Char *)"xabcd";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *ptrb = (const Char *)"abcd";
	Ustr s4b (ptrb, ptrb+4);
	int err3 = 0, nrec3 = 4;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s4b.begin(), err3, nrec3);
	typedef strict_forward_iterator<Ustr::iterator, Char> FI;
	pair<FI, FI> r3 (mismatch(it1, it2, it3, x_2517T31b));
	ieq(*r3.first, 'x');
	ieq(*r3.second, 'a');
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);


	}
	end_chk("_2517T31b");
#else
	skip_chk("_2517T31b");
#endif /* CASE_2517T31b */

/* _2518T31a equal(-)  returns [not complexity] */
#if !defined(SKIP_2518T31a)&&(!defined(ONLY)||defined(CASE_2518T31a))
	begin_chk("_2518T31a");
	{

	// simple pointers
	Char buf[] = "abdx";
	Char *p1 = buf;
	Char *p2 = buf+3;  // first 3 chars only
	Char bufb[4] = "abd";
	Char *p3 = bufb;
	bool ret (equal(p1, p2, p3));
	ieq(ret, 1);
	chk(equal(p1, p1, p3));
	chk(!equal(p1, p1 + 1, p3 + 1));

	// strings
	Ustr s ("xabcd");
	Ustr t ("xab");
	bool ret2 (equal(s.begin(), s.end(), t.begin()));
	ieq(ret2, 0);

	// strict iterators over strings
	const Char *ptr = (const Char *)"xabcd";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *ptrb = (const Char *)"xabcd";
	Ustr s4b (ptrb, ptrb+5);
	int err3 = 0, nrec3 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s4b.begin(), err3, nrec3);
	bool ret3 
		(equal(it1, it2, it3));
	ieq(ret3, 1);
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);

	}
	end_chk("_2518T31a");
#else
	skip_chk("_2518T31a");
#endif /* CASE_2518T31a */

/* _2518T31b equal(-, pred) returns, complexity */
#if !defined(SKIP_2518T31b)&&(!defined(ONLY)||defined(CASE_2518T31b))
	begin_chk("_2518T31b");
	{

	// simple pointers
	Char buf[] = "abdx";
	Char *p1 = buf;
	Char *p2 = buf+3;  // first 3 chars only
	Char bufb[4] = "abd";
	Char *p3 = bufb;
	bool ret = equal(p1, p2, p3, f_2518T31b);
	ieq(ret, 1);

	// strings
	Ustr s ("xabcd");
	Ustr t ("xab");
	bool ret2 = equal(s.begin(), s.end(), t.begin(), f_2518T31b);
	ieq(ret2, 0);

	// strict iterators over strings
	const STD equal_to<Char> x = equal_to<Char>();
	const Char *ptr = (const Char *)"xabcd";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *ptrb = (const Char *)"xabcd";
	Ustr s4b (ptrb, ptrb+5);
	int err3 = 0, nrec3 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s4b.begin(), err3, nrec3);
	bool ret3 =
		equal(it1, it2, it3, x);
	ieq(ret3, 1);
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);



	}
	end_chk("_2518T31b");
#else
	skip_chk("_2518T31b");
#endif /* CASE_2518T31b */

/* _2519T31a search(-)        effects, returns, complexity */
#if !defined(SKIP_2519T31a)&&(!defined(ONLY)||defined(CASE_2519T31a))
	begin_chk("_2519T31a");
	{

	// simple pointers
	Char buf[] = "ab";
	Char *p1 = buf;
	Char *p2 = buf+2;
	Char *p3;
	Char *p4 = (Char *)"b";
	Char *p5 = p4+1;
	p3 = search(p1, p2, p4, p5);
	aeq(p3, buf+1);
	ieq(*p3, 'b');
	chk(search(p1, p1, p4, p5) == p1);
	chk(search(p1, p2, p4, p4) == p1);

	// strings
	Ustr s ("xab");
	Ustr t ("ab");
	ieq(*search(s.begin(), s.end(), t.begin(), t.end()), 'a');

	// strict iterators over strings
	const Char *ptr = (const Char *)"xabcd";
	Ustr s4 (ptr, ptr+4);
	int err1 = 0, nrec1 = 4;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *ptr2 = (const Char *)"ab";
	Ustr s5 (ptr2, ptr2+2);
	int err3 = 0, nrec3 = 4;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s5.begin(), err3, nrec3);
	int err4 = 0, nrec4 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it4
		(s5.end(), err4, nrec4);
	ieq(*search(it1, it2, it3, it4), 'a');
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);
	ieq(err4, 0);

	}
	end_chk("_2519T31a");
#else
	skip_chk("_2519T31a");
#endif /* CASE_2519T31a */

/* _2519T31b search(-, pred)  effects, returns, complexity */
#if !defined(SKIP_2519T31b)&&(!defined(ONLY)||defined(CASE_2519T31b))
	begin_chk("_2519T31b");
	{
	// simple pointers
	Char buf[] = "abcxabcd";
	Char *p1 = buf;
	Char *p2 = buf+8;
	Char *p3;
	Char *p4 = (Char *)"abcd";
	Char *p5 = p4+4;
	npreds_2519T31b = 0;
	p3 = search(p1, p2, p4, p5, f_2519T31b);
	aeq(p3, buf+4);
	ieq(*p3, 'a');
	ieq(*++p3, 'b');
	ieq(*++p3, 'c');
	ieq(*++p3, 'd');
	chk(npreds_2519T31b <= 8 * 4);

	// strings
	npreds_2519T31b = 0;
	Ustr s("xababd");
	Ustr t("abd");
	Ustr::iterator i =
		search(s.begin(), s.end(), t.begin(), t.end());
	ieq(i - s.begin(), 3);
	ieq(*(i - 1), 'b');
	chk(npreds_2519T31b <= 5 * 3);

	// strict iterators over strings
	const STD equal_to<Char> x = equal_to<Char>();
	const Char *buf2 = (const Char *)"xabcd";
	Ustr s4 (buf2, buf2+5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *buf3 = (const Char *)"ab";
	Ustr s5 (buf3, buf3+2);
	int err3 = 0, nrec3 = 2;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s5.begin(), err3, nrec3);
	int err4 = 0, nrec4 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it4
		(s5.end(), err4, nrec4);
	ieq(*search(it1, it2, it3, it4, x), 'a');
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);
	ieq(err4, 0);

	}
	end_chk("_2519T31b");
#else
	skip_chk("_2519T31b");
#endif /* CASE_2519T31b */

/* _2519T31c search_n(-)        effects, returns, complexity ADDED [MAR96] */
#if !defined(SKIP_2519T31c)&&(!defined(ONLY)||defined(CASE_2519T31c))
	begin_chk("_2519T31c");
	{

	// simple pointers
	Char buf[] = "ab";
	Char *p1 = buf;
	Char *p2 = buf+2;
	Char *p3;
	p3 = search_n(p1, p2, 1, 'b');
	aeq(p3, buf+1);
	ieq(*p3, 'b');
	aeq(search_n(p1, p1, 1, 'b'), p1);
	aeq(search_n(p1, p2, 0, 'b'), p1);

	// strings
	Ustr s ("babb");
	aeq(&*search_n(s.begin(), s.end(), 2, 'b'), &*s.begin() + 2);

	// strict iterators over strings
	const Char *ptr = (const Char *)"ababba";
	Ustr s4 (ptr, ptr + 6);
	int err1 = 0, nrec1 = 6;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	ieq(*search_n(it1, it2, 2, 'b'), 'b');
	ieq(err1, 0);
	ieq(err2, 0);

	}
	end_chk("_2519T31c");
#else
	skip_chk("_2519T31c");
#endif /* CASE_2519T31c */

/* _2519T31d search_n(-, pred)  effects, returns, complexity ADDED [MAR96] */
#if !defined(SKIP_2519T31d)&&(!defined(ONLY)||defined(CASE_2519T31d))
	begin_chk("_2519T31d");
	{
	// simple pointers
	Char buf[] = "abcbbbcd";
	Char *p1 = buf;
	Char *p2 = buf+8;
	Char *p3;
	npreds_2519T31d = 0;
	p3 = search_n(p1, p2, 2, 'b', f_2519T31d);
	aeq(p3, buf + 3);
	ieq(*p3, 'b');
	chk(npreds_2519T31d <= 8 * 2);

	// strings
	npreds_2519T31d = 0;
	Ustr s("xbabb");
	Ustr::iterator i =
		search_n(s.begin(), s.end(), 2, 'b');
	ieq(i - s.begin(), 3);
	ieq(*(i - 1), 'a');
	chk(npreds_2519T31d <= 5 * 2);

	// strict iterators over strings
	const STD equal_to<Char> x = equal_to<Char>();
	const Char *buf2 = (const Char *)"xababba";
	Ustr s4 (buf2, buf2 + 7);
	int err1 = 0, nrec1 = 7;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	ieq(*search_n(it1, it2, 2, 'b', x), 'b');
	ieq(err1, 0);
	ieq(err2, 0);




	}
	end_chk("_2519T31d");
#else
	skip_chk("_2519T31d");
#endif /* CASE_2519T31d */

return leave_chk("t251");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t238.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _233T11 <map> synopsis */
#if !defined(SKIP_233T11)&&(!defined(ONLY)||defined(CASE_233T11))
#include <functional>
#include <map>
#include <utility>

#ifdef PAIR_DEFINITION
 PAIR_DEFINITION;
#else
 typedef pair<const Char, int> Pair;
#endif

#endif /* CASE_233T11 */

/* _233T21 <set> synopsis */
#if !defined(SKIP_233T21)&&(!defined(ONLY)||defined(CASE_233T21))
#include <functional>
#include <set>
#endif /* CASE_233T21 */

/* _2331T11 map definition */
#if !defined(SKIP_2331T11)&&(!defined(ONLY)||defined(CASE_2331T11))
#include "iter.h"
#include <map>
#include <new>
#include <utility>

#ifdef PAIR_DEFINITION
 PAIR_DEFINITION;
#else
 typedef pair<const Char, int> Pair;
#endif

typedef map<Char, int, less<Char>, ALLOCATOR(Pair)> Cont_2331T11;	// [NOV97]
Cont_2331T11::reference f1_2331T11()
	{static Pair uc((Char)'x', 5);
	return ((Cont_2331T11::reference)uc);
	}
Cont_2331T11::const_reference f2_2331T11()
	{static Pair uc((Char)'x', 5);
	return ((Cont_2331T11::const_reference)uc);
	}
#endif /* CASE_2331T11 */

/* _23315T21 map::operator[] returns */
#if !defined(SKIP_23315T21)&&(!defined(ONLY)||defined(CASE_23315T21))
#include "iter.h"
#include <map>
#include <new>
#include <utility>

#ifdef PAIR_DEFINITION
 PAIR_DEFINITION;
#else
 typedef pair<const Char, int> Pair;
#endif

typedef map<Char, int, less<Char>, ALLOCATOR(Pair)> Cont_23315T21;	// [NOV97]
#endif /* CASE_23315T21 */

int t238_main(int, char *[])
{
enter_chk("t238.cpp");
/* _233T11 <map> synopsis */
#if !defined(SKIP_233T11)&&(!defined(ONLY)||defined(CASE_233T11))
	begin_chk("_233T11");
	{
	typedef map<Char, int, less<Char>, ALLOCATOR(Pair)> Cont;	// [NOV97]
	Cont v0;
	chk(v0 == v0);
	chk(!(v0 < v0));
	typedef multimap<Char, int, less<Char>, ALLOCATOR(Pair)> Mcont;	// [NOV97]
	Mcont m0;
	chk(m0 == m0);
	chk(!(m0 < m0));


	}
	end_chk("_233T11");
#else
	skip_chk("_233T11");
#endif /* CASE_233T11 */

/* _233T21 <set> synopsis */
#if !defined(SKIP_233T21)&&(!defined(ONLY)||defined(CASE_233T21))
	begin_chk("_233T21");
	{
	typedef set<Char, less<Char>, ALLOCATOR(Char)> Cont;
	Cont v0;
	chk(v0 == v0);
	chk(!(v0 < v0));
	typedef multiset<Char, less<Char>, ALLOCATOR(Char)> Mcont;
	Mcont m0;
	chk(m0 == m0);
	chk(!(m0 < m0));








	}
	end_chk("_233T21");
#else
	skip_chk("_233T21");
#endif /* CASE_233T21 */

/* _2331T11 map definition */
#if !defined(SKIP_2331T11)&&(!defined(ONLY)||defined(CASE_2331T11))
	begin_chk("_2331T11");
	{
	typedef Cont_2331T11 Cont;
	const Pair s[] = {
		Pair('a', 'A'), Pair('b', 'B'), Pair('c', 'C'),
		Pair('d', 'D'), Pair('e', 'E')};
	const int NC = 5;
	const Cont a(s, s + 5);	// container specific
	// UNAUTHORIZED CHANGE FROM referent_type int *p0 = (Cont::mapped_type *)0;
	Cont::allocator_type::const_pointer *p00
		= (Cont::const_pointer *)0; TOUCH(p00);
	Cont::allocator_type::pointer *p01 = (Cont::pointer *)0; TOUCH(p01);

		// Table 50 -- for all containers
	ALLOCATOR(Pair) *pal
		= (Cont::allocator_type *)0; TOUCH(pal);	// ADDED [MAR96] CHANGED [NOV97]
	Pair *p1 = (Cont::value_type *)0; TOUCH(p1);
	size_t *p2 = (Cont::size_type *)0; TOUCH(p2);
	ptrdiff_t *p3 = (Cont::difference_type *)0; TOUCH(p3);
	Pair uc1 = f1_2331T11();
	Pair uc2 = f2_2331T11();
	Cont::iterator *p6 = (Cont::iterator *)0; TOUCH(p6);
	Cont::const_iterator *p7 = (Cont::const_iterator *)0; TOUCH(p7);
	ALLOCATOR(Pair) al;	// CHANGED [NOV97]
	Cont u0;
	ieq(u0.size(), 0);
	chk(u0.empty());
	ieq(a.size(), NC);
	chk(!a.empty());
	chk(u0 != a);
	Cont u1;
	Cont u3(a);
	chk(u3 == a);

	Cont::allocator_type al3 = u3.get_allocator();	// added [JUL95]
	chk(al3 == al);
	u3.clear();
	chk(u3.empty());
	u3 = a;
	chk(u3 == a);

	const Cont u4 = a;
	chk(u4 == a);
	Cont *p = new Cont(a);
	ieq(p->size(), NC);
	p->DESTRUCTOR(map, Cont);
	ieq(p->size(), 0);
	operator delete(p);
	Cont::size_type n = distance(u3.begin(), u3.end());	// CHANGED [MAR96]
	ieq(n, NC);
	Cont::const_iterator pa = a.begin();
	pa = a.end();
	u1.swap(u3);
	chk(a == u1);
	swap(u1, u3);	// [NOV95]
	chk(a != u1);
	swap(u1, u3);
	chk(a == u1);
	ieq(u3.size(), 0);
	chk(&(u3 = a) == &u3);
	chk(u3 == a);
	chk(0 < a.max_size());
	n = u0.max_size();
	chk(a.max_size() == n);
	chk(u0 < a && !(u0 < u0) && !(a < a));
	chk(a > u0 && !(u0 > u0) && !(a > a));
	chk(u0 <= a && u0 <= u0 && !(a <= u0));
	chk(a >= u0 && u0 >= u0 && !(u0 >= a));
		// Table 51 -- for reversible (bidirectional) containers
	//typedef POINTER_X(Cont::value_type, Cont::allocator_type)
	//	Ptrty;
	//typedef POINTER_X(const Cont::value_type, Cont::allocator_type)
	//	Cptrty;
	//STD reverse_bidirectional_iterator<Cont::const_iterator, Cont::value_type,
	//	Cont::const_reference, Cptrty, Cont::difference_type> *p8 =
	//		(Cont::const_reverse_iterator *)0;
	//STD reverse_bidirectional_iterator<Cont::iterator, Cont::value_type,
	//	Cont::reference, Ptrty, Cont::difference_type> *p9 =
	//		(Cont::reverse_iterator *)0;
	Cont::const_reverse_iterator *p8 = 0; TOUCH(p8);	// CHANGED [NOV96]
	Cont::reverse_iterator *p9 = 0; TOUCH(p9);
	n = distance(a.rbegin(), a.rend());	// CHANGED [MAR96]
	ieq(n, NC);
	chk(*u3.rbegin() == s[4]);
	chk(*(--u3.rend()) == s[0]);
		// Table 54 -- for associative containers
	Char *p10 = (Cont::key_type *)0; TOUCH(p10);
	less<Char> *p11 = (Cont::key_compare *)0; TOUCH(p11);
	Cont::value_compare *p12 = (Cont::value_compare *)0; TOUCH(p12);
	less<Char> flt;
	Cont a0(flt);
	ieq(a0.size(), 0);
	Cont a1(flt, al);
	ieq(a1.size(), 0);
	Cont a2(s, s + 1, flt);
	ieq(a2.size(), 1);
	Cont a3(s, s + 2, flt, al);
	ieq(a3.size(), 2);
	Cont::key_compare kc = a3.key_comp();
	chk(kc((Char)'a', (Char)'b'));
	chk(!kc((Char)'b', (Char)'a'));
	chk(!kc((Char)'a', (Char)'a'));
	Cont::value_compare vc = a3.value_comp();
	chk(vc(s[0], s[1]));
	chk(!vc(s[1], s[0]));
	chk(!vc(s[0], s[0]));
	chk(*(a3.insert(s[4])).first == s[4]);
	ieq(a3.size(), 3);
	chk(*--a3.end() == s[4]);
	chk((a3.insert(s[3])).second);
	ieq(a3.size(), 4);
	chk(*--a3.end() == s[4]);
	chk(*(a3.insert(s[1])).first == s[1]);
	ieq(a3.size(), 4);	// 5 for multi
	chk(*--a3.end() == s[4]);
	chk(!(a3.insert(s[1])).second);	// true for multi
	ieq(a3.count((Char)'b'), 1);	// 3 for multi
	ieq(a3.erase((Char)'b'), 1);	// 3 for multi
	chk(*a3.insert(a3.end(), s[3]) == s[3]);
	chk(*a3.insert(a3.begin(), s[3]) == s[3]);
	a0.insert(s, s);
	ieq(a0.size(), 0);
	a0.insert(s + 1, s + 3);
	ieq(a0.size(), 2);
	chk(*a0.begin() == s[1]);
	chk(*a0.erase(a0.begin()) == s[2]);	// [NOV95]
	chk(*a0.erase(a0.begin(), a0.begin()) == s[2]);
	chk(*a0.begin() == s[2]);
	a0 = a;
	a0.erase(a0.end(), a0.end());
	ieq(a0.size(), NC);
	a0.erase(a0.begin(), ++a0.begin());
	ieq(a0.size(), NC - 1);
	a0.erase(a0.begin(), a0.end());
	ieq(a0.size(), 0);
	chk(a.find((Char)'a') == a.begin());
	chk(a.find((Char)'x') == a.end());
	chk(a0.find((Char)'x') == a0.end());
	ieq(a.count((Char)'a'), 1);
	ieq(a.count((Char)'x'), 0);
	ieq(a0.count((Char)'x'), 0);
	chk(a.lower_bound((Char)'b') == ++a.begin());
	chk(a.lower_bound((Char)'e') == --a.end());
	chk(a0.lower_bound((Char)'e') == a0.end());
	chk(a.upper_bound((Char)'a') == ++a.begin());
	chk(a.upper_bound((Char)'e') == a.end());
	chk(a0.upper_bound((Char)'e') == a0.end());
	chk((a.equal_range((Char)'b')).first == ++a.begin());
	chk((a.equal_range((Char)'e')).second == a.end());
	chk((a0.equal_range((Char)'e')).first == a0.end());
	 #if !DISALLOW_MEMBER_TEMPLATES
	int err1 = 0, nrec1 = NC;
	strict_input_iterator<const Pair *, Pair> it1
		(s, err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<const Pair *, Pair> it2
		(s + NC, err2, nrec2);
	Cont s0(it1, it2);
	ieq(err1, 0);
	ieq(err2, 0);
	 #endif




	}
	end_chk("_2331T11");
#else
	skip_chk("_2331T11");
#endif /* CASE_2331T11 */

/* _23315T21 map::operator[] returns */
#if !defined(SKIP_23315T21)&&(!defined(ONLY)||defined(CASE_23315T21))
	begin_chk("_23315T21");
	{
	typedef Cont_23315T21 Cont;
	Cont s0;
	s0[(Char)'a'] = 32767;
	ieq(s0[(Char)'a'], 32767);
	ieq(s0.size(), 1);
	s0[(Char)'a'] = -3;
	ieq(s0[(Char)'a'], -3);
	ieq(s0.size(), 1);

	}
	end_chk("_23315T21");
#else
	skip_chk("_23315T21");
#endif /* CASE_23315T21 */

return leave_chk("t238");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t252.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _2521T21 copy effects, returns, complexity */
#if !defined(SKIP_2521T21)&&(!defined(ONLY)||defined(CASE_2521T21))
#include "iter.h"
#include <algorithm>
#include <string>
int assts_2521T21 = 0;
class Mychar_2521T21 {
public:
	Mychar_2521T21(Char c = 0)
		: val(c) {}
	Mychar_2521T21(const Mychar_2521T21& x)
		: val(x.val) {}
	Mychar_2521T21& operator=(const Mychar_2521T21& x)
		{val = x.val;
		++assts_2521T21;
		return (*this); }
	~Mychar_2521T21()
		{ }
private:
	Char val;
	};
#endif /* CASE_2521T21 */

/* _2521T71 copy_backward effects, returns, complexity */
#if !defined(SKIP_2521T71)&&(!defined(ONLY)||defined(CASE_2521T71))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
int assts_2521T71 = 0;
class Mychar_2521T71 {
public:
	Mychar_2521T71(Char c = 0)
		: val(c) {}
	Mychar_2521T71(const Mychar_2521T71& x)
		: val(x.val) {}
	Mychar_2521T71& operator=(const Mychar_2521T71& x)
		{val = x.val;
		++assts_2521T71;
		return (*this); }
	~Mychar_2521T71()
		{ }
private:
	Char val;
	};
#endif /* CASE_2521T71 */

/* _2522T21 swap effects */
#if !defined(SKIP_2522T21)&&(!defined(ONLY)||defined(CASE_2522T21))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
#endif /* CASE_2522T21 */

/* _2522T51 swap_ranges effects, returns, complexity */
#if !defined(SKIP_2522T51)&&(!defined(ONLY)||defined(CASE_2522T51))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
int cnt_2522T51;
struct Mychar_2522T51 {
	Mychar_2522T51()
		: c(0) {}
	Mychar_2522T51(const Mychar_2522T51& x)
		{++cnt_2522T51;
		c = x.c; }
	Mychar_2522T51& operator=(const Mychar_2522T51& x)
		{++cnt_2522T51;
		c = x.c;
		return (*this); }
	char c;
	};
#endif /* CASE_2522T51 */

/* _2522T71 iter_swap effects */
#if !defined(SKIP_2522T71)&&(!defined(ONLY)||defined(CASE_2522T71))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
#endif /* CASE_2522T71 */

/* _2523T21a transform(-, unary_op) effects, returns, complexity */
#if !defined(SKIP_2523T21a)&&(!defined(ONLY)||defined(CASE_2523T21a))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <functional>
#include <string>
int nops_2523T21a = 0;
int f_2523T21a(Char c1)
	{++nops_2523T21a;
	return (c1 + 1); }
#endif /* CASE_2523T21a */

/* _2523T21b transform(-, binaryop) effects, returns, complexity */
#if !defined(SKIP_2523T21b)&&(!defined(ONLY)||defined(CASE_2523T21b))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <functional>
#include <string>
int nops_2523T21b = 0;
int f_2523T21b(Char c1, Char c2)
	{++nops_2523T21b;
	return (c1 + (c2 - 'a')); }
#endif /* CASE_2523T21b */

/* _2524T21a replace effects, complexity */
#if !defined(SKIP_2524T21a)&&(!defined(ONLY)||defined(CASE_2524T21a))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <functional>
#include <string>
#endif /* CASE_2524T21a */

/* _2524T21b replace_if effects, complexity */
#if !defined(SKIP_2524T21b)&&(!defined(ONLY)||defined(CASE_2524T21b))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <functional>
#include <string>
int nops_2524T21b = 0;
bool f_2524T21b(Char c1)
	{++nops_2524T21b;
	return (c1 == 'a' || c1 == 'b' || c1 == 'c'); }
#endif /* CASE_2524T21b */

/* _2524T41a replace_copy effects, returns */
#if !defined(SKIP_2524T41a)&&(!defined(ONLY)||defined(CASE_2524T41a))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <functional>
#include <string>
#endif /* CASE_2524T41a */

/* _2524T41b replace_copy_if effects, complexity */
#if !defined(SKIP_2524T41b)&&(!defined(ONLY)||defined(CASE_2524T41b))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <functional>
#include <string>
int nops_2524T41b = 0;
bool f_2524T41b(Char c1)
	{++nops_2524T41b;
	return (c1 == 'a' || c1 == 'b' || c1 == 'c'); }
#endif /* CASE_2524T41b */

/* _2525T21a fill effects, complexity */
#if !defined(SKIP_2525T21a)&&(!defined(ONLY)||defined(CASE_2525T21a))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
int assts_2525T21a = 0;
class Mychar_2525T21a {
public:
	Mychar_2525T21a(Char c = 0)
		: val(c) {}
	Mychar_2525T21a(const Mychar_2525T21a& x)
		: val(x.val) {}
	Mychar_2525T21a& operator=(const Mychar_2525T21a& x)
		{val = x.val;
		++assts_2525T21a;
		return (*this); }
	~Mychar_2525T21a()
		{ }
private:
	Char val;
	};
#endif /* CASE_2525T21a */

/* _2525T21b fill_n effects, complexity */
#if !defined(SKIP_2525T21b)&&(!defined(ONLY)||defined(CASE_2525T21b))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
int assts_2525T21b = 0;
class Mychar_2525T21b {
public:
	Mychar_2525T21b(Char c = 0)
		: val(c) {}
	Mychar_2525T21b(const Mychar_2525T21b& x)
		: val(x.val) {}
	Mychar_2525T21b& operator=(const Mychar_2525T21b& x)
		{val = x.val;
		++assts_2525T21b;
		return (*this); }
	~Mychar_2525T21b()
		{ }
private:
	Char val;
	};
#endif /* CASE_2525T21b */

/* _2526T21a generate    effects, complexity */
#if !defined(SKIP_2526T21a)&&(!defined(ONLY)||defined(CASE_2526T21a))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
int assts_2526T21a = 0;
class Mychar_2526T21a {
public:
	Mychar_2526T21a(Char c = 0)
		: val(c) {}
	Mychar_2526T21a(const Mychar_2526T21a& x)
		: val(x.val) {}
	Mychar_2526T21a& operator=(const Mychar_2526T21a& x)
		{val = x.val;
		++assts_2526T21a;
		return (*this); }
	~Mychar_2526T21a()
		{ }
private:
	Char val;
	};
int calls_2526T21a = 0;
int f_2526T21a()
	{return ('a' + calls_2526T21a++); }
#endif /* CASE_2526T21a */

/* _2526T21b generate_n  effects, complexity */
#if !defined(SKIP_2526T21b)&&(!defined(ONLY)||defined(CASE_2526T21b))
#include "iter.h"
#include <algorithm>
#include <cstring>
#include <string>
int assts_2526T21b = 0;
class Mychar_2526T21b {
public:
	Mychar_2526T21b(Char c = 0)
		: val(c) {}
	Mychar_2526T21b(const Mychar_2526T21b& x)
		: val(x.val) {}
	Mychar_2526T21b& operator=(const Mychar_2526T21b& x)
		{val = x.val;
		++assts_2526T21b;
		return (*this); }
	~Mychar_2526T21b()
		{ }
private:
	Char val;
	};
int calls_2526T21b = 0;
int f_2526T21b()
	{return ('a' + calls_2526T21b++); }
#endif /* CASE_2526T21b */

int t252_main(int, char *[])
{
enter_chk("t252.cpp");
/* _2521T21 copy effects, returns, complexity */
#if !defined(SKIP_2521T21)&&(!defined(ONLY)||defined(CASE_2521T21))
	begin_chk("_2521T21");
	{
	// simple pointers
	Char buf[] = "abdx";
	Char bufb[5] = "yyy";
	copy(buf, buf, bufb);
	steq(bufb, "yyy");
	Char *ret = copy(buf, buf + 3, bufb);
	aeq(ret, bufb + 3);
	steq(bufb, "abd");

	// strings
	Ustr s ("xabcd");
	Ustr t ("yyyxx");
	Ustr::iterator ret2 (copy(s.begin(), s.end(), t.begin()));
	ieq(ret2 - t.begin(), 5);  // returns
	chk(t == "xabcd");         // effects
	steq(t.c_str(), "xabcd");

	// strict iterators over strings
	const Char *ptr = (const Char *)"xabcd";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 5;
	strict_input_iterator<Ustr::const_iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<Ustr::const_iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *ptrb = (const Char *)"xabcd";
	Ustr s4b (ptrb, ptrb+5);
	int err3 = 0, nrec3 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s4b.begin(), err3, nrec3);
	strict_forward_iterator<Ustr::iterator, Char> it4
		(copy(it1, it2, it3));
	chk(s4b == "xabcd");
	steq(s4b.c_str(), "xabcd");  // effects
	ieq(err1, 0); // no iterator violations
	ieq(err2, 0);
	ieq(err3, 0);

	// complexity
	Mychar_2521T21 a[10];
	assts_2521T21 = 0;
	copy(a, a + 5, a + 5);
	ieq(assts_2521T21, 5); // complexity, assignments


	}
	end_chk("_2521T21");
#else
	skip_chk("_2521T21");
#endif /* CASE_2521T21 */

/* _2521T71 copy_backward effects, returns, complexity */
#if !defined(SKIP_2521T71)&&(!defined(ONLY)||defined(CASE_2521T71))
	begin_chk("_2521T71");
	{
	// simple pointers
	Char buf[] = "abdyyy";
	copy_backward(buf, buf, buf + 4);
	steq(buf, "abdyyy");
	Char *ret = copy_backward(buf, buf + 3, buf + 4);
	aeq(ret, buf + 1);  // returns 
	steq(buf, "aabdyy");        // effects

	// strings
	Ustr s ("abcdx");
	Ustr::iterator ret2 (copy_backward(s.begin(), s.end()-1, s.end()));
	ieq(ret2 - s.begin(), 1);
	chk(s == "aabcd");

	// strict iterators over strings
	const Char *ptr = (const Char *)"abcxx";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 3;
	strict_bidirectional_iterator<Ustr::/*const_2521T71*/iterator, /*const */Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 3;
	strict_bidirectional_iterator<Ustr::/*const_2521T71*/iterator, /*const */Char> it2
		(s4.begin() + nrec2, err2, nrec2, nrec2);
	int err3 = 0, nrec3 = 3;
	strict_bidirectional_iterator<Ustr::iterator, Char> it3
		(s4.begin() + 5, err3, nrec3, nrec3);
	strict_bidirectional_iterator<Ustr::iterator, Char> it4
		(copy_backward(it1, it2, it3));
	chk(s4 == "ababc");
	steq(s4.c_str(), "ababc");
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);

	// complexity
	Mychar_2521T71 a[6];
	assts_2521T71 = 0;
	copy_backward(a, a + 5, a + 6);
	ieq(assts_2521T71, 5); // complexity, assignments


	}
	end_chk("_2521T71");
#else
	skip_chk("_2521T71");
#endif /* CASE_2521T71 */

/* _2522T21 swap effects */
#if !defined(SKIP_2522T21)&&(!defined(ONLY)||defined(CASE_2522T21))
	begin_chk("_2522T21");
	{
	// simple pointers
	Char buf[] = "abdx";
	Char *p1 = buf;
	Char *p2 = buf+3;
	swap(*p1, *p2);
	steq(buf, "xbda");
	swap(buf[3], buf[3]);  // same location
	steq(buf, "xbda");

	// strings
	Ustr s ("xabcd");
	swap(*s.begin(), *(s.end()-1));
	chk(s == "dabcx");

	// strict iterators over strings
	const Char *ptr = (const Char *)"xabcd";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 1;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin() + 1, err1, nrec1);
	int err2 = 0, nrec2 = 1;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.end() - 1, err2, nrec2);
	swap(*it1, *it2);
	chk(s4 == "xdbca");
	steq(s4.c_str(), "xdbca");
	ieq(err1, 0);
	ieq(err2, 0);


	}
	end_chk("_2522T21");
#else
	skip_chk("_2522T21");
#endif /* CASE_2522T21 */

/* _2522T51 swap_ranges effects, returns, complexity */
#if !defined(SKIP_2522T51)&&(!defined(ONLY)||defined(CASE_2522T51))
	begin_chk("_2522T51");
	{
	// simple pointers
	Char buf[] = "abdx";
	Char *p1 = buf;
	Char *p2 = buf+2;
	Char *p3 = buf+2;
	swap_ranges(p1, p1, p3);
	steq(buf, "abdx");
	Char *p4 = swap_ranges(p1, p2, p3);
	steq(buf, "dxab");
	aeq(p4, buf+4);  // check returns

	// strings
	Ustr s ("xabcd");
	swap_ranges(s.begin(), s.begin()+2, s.end()-2);
	chk(s == "cdbxa");

	// strict iterators over strings
	const Char *ptr = (const Char *)"xabcde";
	Ustr s4 (ptr, ptr+6);
	int err1 = 0, nrec1 = 3;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 3;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.begin() + nrec2, err2, nrec2, nrec2);
	int err3 = 0, nrec3 = 3;
	strict_random_access_iterator<Ustr::iterator, Char> it3
		(s4.begin() + 3, err3, nrec3);
	swap_ranges(it1, it2, it3);
	chk(s4 == "cdexab");
	steq(s4.c_str(), "cdexab");
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);

	// complexity
	Mychar_2522T51 a[10], b[10];
	cnt_2522T51 = 0;
	swap_ranges(&a[0], &a[10], &b[0]);
	ieq(cnt_2522T51, 30);


	}
	end_chk("_2522T51");
#else
	skip_chk("_2522T51");
#endif /* CASE_2522T51 */

/* _2522T71 iter_swap effects */
#if !defined(SKIP_2522T71)&&(!defined(ONLY)||defined(CASE_2522T71))
	begin_chk("_2522T71");
	{
	// simple pointers
	Char buf[] = "abdx";
	Char *p1 = buf;
	Char *p2 = buf+2;
	iter_swap(p1, p1);
	steq(buf, "abdx");
	iter_swap(p1, p2);
	steq(buf, "dbax");

	// strings
	Ustr s ("xabcd");
	iter_swap(s.begin()+1, s.begin()+3);
	chk(s == "xcbad");

	// strict iterators over strings
	const Char *ptr = (const Char *)"xabcde";
	Ustr s4 (ptr, ptr+6);
	int err1 = 0, nrec1 = 1;
	strict_random_access_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 1;
	strict_random_access_iterator<Ustr::iterator, Char> it2
		(s4.begin() + 3, err2, nrec2);
	iter_swap(it1, it2);
	chk(s4 == "cabxde");
	steq(s4.c_str(), "cabxde");
	ieq(err1, 0);
	ieq(err2, 0);



	}
	end_chk("_2522T71");
#else
	skip_chk("_2522T71");
#endif /* CASE_2522T71 */

/* _2523T21a transform(-, unary_op) effects, returns, complexity */
#if !defined(SKIP_2523T21a)&&(!defined(ONLY)||defined(CASE_2523T21a))
	begin_chk("_2523T21a");
	{
	// simple pointers
	Char buf[] = "abcd";
	Char bufc[] = "wxyz";
	Char *p5;
	transform(&buf[0], &buf[0], &bufc[0], f_2523T21a);
	steq(bufc, "wxyz");
	p5 = transform(&buf[0], &buf[4], &bufc[0], f_2523T21a);
	aeq(p5, &bufc[4]);
	steq(&bufc[0], "bcde");
	ieq(nops_2523T21a, 4);  // complexity

	// strings
	nops_2523T21a = 0;
	Ustr s ("axy");
	Ustr::iterator i =
		transform(s.begin(), s.end(), s.begin(), f_2523T21a);
	ieq(i - s.begin(), 3);
	ieq(*(i-1), 'z');
	steq(s.c_str(), "byz");
	chk(nops_2523T21a == 3);  // complexity

	// strict iterators over strings
	const Char *buf2 = (const Char *)"b";
	Ustr s4 (buf2, buf2+1);
	int err1 = 0, nrec1 = 1;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *buf3 = (const Char *)"xef";
	Ustr s5 (buf3, buf3+3);
	int err3 = 0, nrec3 = 1;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s5.begin(), err3, nrec3);
	transform(it1, it2, it3, f_2523T21a);
	steq(s5.c_str(), "cef");
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);

	}
	end_chk("_2523T21a");
#else
	skip_chk("_2523T21a");
#endif /* CASE_2523T21a */

/* _2523T21b transform(-, binaryop) effects, returns, complexity */
#if !defined(SKIP_2523T21b)&&(!defined(ONLY)||defined(CASE_2523T21b))
	begin_chk("_2523T21b");
	{
	// simple pointers
	Char buf[] = "abcd";
	Char bufb[] = "aabb";
	Char bufc[] = "wxyz";
	Char *p5;
	transform(&buf[0], &buf[0], &bufb[0], &bufc[0], f_2523T21b);
	steq(bufc, "wxyz");
	p5 = transform(&buf[0], &buf[4], &bufb[0], &bufc[0], f_2523T21b);
	aeq(p5, bufc+4);
	steq(bufc, "abde");
	ieq(nops_2523T21b, 4);  // complexity

	// strings
	nops_2523T21b = 0;
	Ustr s ("axy");
	Ustr t ("cba");
	Ustr::iterator i =
		transform(s.begin(), s.end(), t.begin(), t.begin(), f_2523T21b);
	ieq(i - t.begin(), 3);
	ieq(*(i-1), 'y');
	steq(t.c_str(), "cyy");
	chk(nops_2523T21b == 3);  // complexity

	// strict iterators over strings
	const STD plus<Char> x = plus<Char>();
	const Char *buf2 = (const Char *)"\1";
	Ustr s4 (buf2, buf2+1);
	int err1 = 0, nrec1 = 1;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	const Char *buf3 = (const Char *)"xef";
	Ustr s5 (buf3, buf3+3);
	int err3 = 0, nrec3 = 1;
	strict_forward_iterator<Ustr::iterator, Char> it3
		(s5.begin(), err3, nrec3);
	int err4 = 0, nrec4 = 1;
	strict_forward_iterator<Ustr::iterator, Char> it4
		(s4.begin(), err4, nrec4);
	transform(it1, it2, it3, it4, x);
	steq(s4.c_str(), "y");
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);
	ieq(err4, 0);


	}
	end_chk("_2523T21b");
#else
	skip_chk("_2523T21b");
#endif /* CASE_2523T21b */

/* _2524T21a replace effects, complexity */
#if !defined(SKIP_2524T21a)&&(!defined(ONLY)||defined(CASE_2524T21a))
	begin_chk("_2524T21a");
	{
	// simple pointers
	Char buf[] = "abcd";
	replace(&buf[0], &buf[0], 'c', 'x');
	steq(buf, "abcd");
	replace(&buf[0], &buf[4], 'c', 'x');
	steq(buf, "abxd");

	// strings
	Ustr s ("axy");
	replace(s.begin(), s.end(), 'y', 'k');
	steq(s.c_str(), "axk");

	// strict iterators over strings
	const Char *buf2 = (const Char *)"b";
	Ustr s4 (buf2, buf2+1);
	int err1 = 0, nrec1 = 1;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	replace(it1, it2, 'b', 'x');
	steq(s4.c_str(), "x");
	ieq(err1, 0);
	ieq(err2, 0);

	}
	end_chk("_2524T21a");
#else
	skip_chk("_2524T21a");
#endif /* CASE_2524T21a */

/* _2524T21b replace_if effects, complexity */
#if !defined(SKIP_2524T21b)&&(!defined(ONLY)||defined(CASE_2524T21b))
	begin_chk("_2524T21b");
	{
	// simple pointers
	Char buf[] = "abcd";
	replace_if(&buf[0], &buf[0], f_2524T21b, 'x');
	steq(buf, "abcd");
	replace_if(&buf[0], &buf[4], f_2524T21b, 'x');
	steq(buf, "xxxd"); // effects
	ieq(nops_2524T21b, 4);  // complexity

	// strings
	nops_2524T21b = 0;
	Ustr s ("axy");
	replace_if(s.begin(), s.end(), f_2524T21b, 'j');
	steq(s.c_str(), "jxy");
	chk(nops_2524T21b == 3);  // complexity

	// strict iterators over strings
	const STD plus<int> x = plus<int>();
	const Char *buf2 = (const Char *)"xyabc";
	Ustr s4 (buf2, buf2+5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	replace_if(it1, it2, f_2524T21b, 'e');
	steq(s4.c_str(), "xyeee");
	ieq(err1, 0);
	ieq(err2, 0);




	}
	end_chk("_2524T21b");
#else
	skip_chk("_2524T21b");
#endif /* CASE_2524T21b */

/* _2524T41a replace_copy effects, returns */
#if !defined(SKIP_2524T41a)&&(!defined(ONLY)||defined(CASE_2524T41a))
	begin_chk("_2524T41a");
	{
	// simple pointers
	Char buf[] = "abcd";
	Char bufb[] = "wxyz";
	replace_copy(&buf[0], &buf[0], &bufb[0], 'c', 'x');
	steq(bufb, "wxyz");
	replace_copy(&buf[0], &buf[4], &bufb[0], 'c', 'x');
	steq(bufb, "abxd");

	// strings
	Ustr s ("axy");
	Ustr t ("lmn");
	replace_copy(s.begin(), s.end(), t.begin(), 'y', 'k');
	steq(t.c_str(), "axk");

	// strict iterators over strings
	const Char *buf2 = (const Char *)"b";
	Ustr s4 (buf2, buf2+1);
	int err1 = 0, nrec1 = 1;
	strict_input_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	Char *ptrb = "z";
	Ustr s4b (ptrb, ptrb+1);
	int err3 = 0, nrec3 = 1;
	strict_output_iterator<Ustr::iterator, Char> it3
		(s4b.begin(), err3, nrec3);
	strict_output_iterator<Ustr::iterator, Char> it4
		(replace_copy(it1, it2, it3, 'b', 'x'));
	steq(s4b.c_str(), "x");
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);

	}
	end_chk("_2524T41a");
#else
	skip_chk("_2524T41a");
#endif /* CASE_2524T41a */

/* _2524T41b replace_copy_if effects, complexity */
#if !defined(SKIP_2524T41b)&&(!defined(ONLY)||defined(CASE_2524T41b))
	begin_chk("_2524T41b");
	{
	// simple pointers
	Char buf[] = "abcd";
	Char bufb[] = "wxyz";
	replace_copy_if(&buf[0], &buf[0], &bufb[0], f_2524T41b, 'x');
	steq(bufb, "wxyz");
	replace_copy_if(&buf[0], &buf[4], &bufb[0], f_2524T41b, 'x');
	steq(bufb, "xxxd"); // effects
	ieq(nops_2524T41b, 4);  // complexity

	// strings
	nops_2524T41b = 0;
	Ustr s ("axy");
	Ustr t ("lmn");
	replace_copy_if(s.begin(), s.end(), t.begin(), f_2524T41b, 'j');
	steq(t.c_str(), "jxy");
	chk(nops_2524T41b == 3);  // complexity

	// strict iterators over strings
	const STD plus<int> x = plus<int>();
	const Char *buf2 = (const Char *)"xyabc";
	Ustr s4 (buf2, buf2+5);
	int err1 = 0, nrec1 = 5;
	strict_input_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_input_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	Char *ptrb = "lmnop";
	Ustr s4b (ptrb, ptrb+5);
	int err3 = 0, nrec3 = 5;
	strict_output_iterator<Ustr::iterator, Char> it3
		(s4b.begin(), err3, nrec3);
	nops_2524T41b = 0;
	strict_output_iterator<Ustr::iterator, Char> it4
		(replace_copy_if(it1, it2, it3, f_2524T41b, 'e'));
	steq(s4b.c_str(), "xyeee");
	ieq(nops_2524T41b, 5);
	ieq(err1, 0);
	ieq(err2, 0);
	ieq(err3, 0);




	}
	end_chk("_2524T41b");
#else
	skip_chk("_2524T41b");
#endif /* CASE_2524T41b */

/* _2525T21a fill effects, complexity */
#if !defined(SKIP_2525T21a)&&(!defined(ONLY)||defined(CASE_2525T21a))
	begin_chk("_2525T21a");
	{

	// simple pointers
	Char buf[] = "abcdyy";
	fill(buf, buf, 'z');
	steq(buf, "abcdyy");
	fill(buf, buf + 3, 'z');
	steq(buf, "zzzdyy");        // effects

	// strings
	Ustr s ("abcdx");
	fill(s.begin(), s.end()-1, 'm');
	chk(s == "mmmmx");

	// strict iterators over strings
	const Char *ptr = (const Char *)"abcxx";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	fill(it1, it2, 'n');
	chk(s4 == "nnnnn");
	steq(s4.c_str(), "nnnnn");
	ieq(err1, 0);
	ieq(err2, 0);

	// complexity
	Mychar_2525T21a a[10];
	assts_2525T21a = 0;
	fill(a, a + 10, Mychar_2525T21a('x'));
	ieq(assts_2525T21a, 10); // complexity, assignments

	}
	end_chk("_2525T21a");
#else
	skip_chk("_2525T21a");
#endif /* CASE_2525T21a */

/* _2525T21b fill_n effects, complexity */
#if !defined(SKIP_2525T21b)&&(!defined(ONLY)||defined(CASE_2525T21b))
	begin_chk("_2525T21b");
	{

	// simple pointers
	Char buf[] = "abcdyy";
	fill_n(buf, 0, 'z');
	steq(buf, "abcdyy");
	fill_n(buf, 2, 'z');
	steq(buf, "zzcdyy");        // effects

	// strings
	Ustr s ("abcdx");
	fill_n(s.begin(), 4, 'm');
	chk(s == "mmmmx");

	// strict iterators over strings
	const Char *ptr = (const Char *)"abcxx";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 2;
	strict_output_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	fill_n(it1, 2, 'n');
	steq(s4.c_str(), "nncxx");
	ieq(err1, 0);

	// complexity
	Mychar_2525T21b a[10];
	assts_2525T21b = 0;
	fill_n(a, 10, Mychar_2525T21b('x'));
	ieq(assts_2525T21b, 10); // complexity, assignments


	}
	end_chk("_2525T21b");
#else
	skip_chk("_2525T21b");
#endif /* CASE_2525T21b */

/* _2526T21a generate    effects, complexity */
#if !defined(SKIP_2526T21a)&&(!defined(ONLY)||defined(CASE_2526T21a))
	begin_chk("_2526T21a");
	{
	// simple pointers
	Char buf[] = "uvwxyz";
	generate(buf, buf, f_2526T21a);
	steq(buf, "uvwxyz");        // effects
	generate(buf, buf + 3, f_2526T21a);
	steq(buf, "abcxyz");

	// strings
	Ustr s ("abcdx");
	calls_2526T21a = 3;
	generate(s.begin(), s.end()-1, f_2526T21a);
	chk(s == "defgx");
	ieq(calls_2526T21a, 7); // complexity

	// strict iterators over strings
	const Char *ptr = (const Char *)"abcxx";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 5;
	strict_forward_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	int err2 = 0, nrec2 = 0;
	strict_forward_iterator<Ustr::iterator, Char> it2
		(s4.end(), err2, nrec2);
	calls_2526T21a = 7;
	generate(it1, it2, f_2526T21a);
	chk(s4 == "hijkl");
	steq(s4.c_str(), "hijkl");
	ieq(calls_2526T21a, 12); // complexity
	ieq(err1, 0);
	ieq(err2, 0);

	// complexity
	Mychar_2526T21a a[10];
	assts_2526T21a = 0;
	calls_2526T21a = 0;
	generate(a, a + 10, f_2526T21a);
	ieq(assts_2526T21a, 10); // complexity, assignments
	ieq(calls_2526T21a, 10); // complexity, invocations

	}
	end_chk("_2526T21a");
#else
	skip_chk("_2526T21a");
#endif /* CASE_2526T21a */

/* _2526T21b generate_n  effects, complexity */
#if !defined(SKIP_2526T21b)&&(!defined(ONLY)||defined(CASE_2526T21b))
	begin_chk("_2526T21b");
	{
	// simple pointers
	Char buf[] = "uvwxyz";
	generate_n(buf, 0, f_2526T21b);
	steq(buf, "uvwxyz");        // effects
	generate_n(buf, 3, f_2526T21b);
	steq(buf, "abcxyz");

	// strings
	Ustr s ("abcdx");
	calls_2526T21b = 3;
	generate_n(s.begin(), 4, f_2526T21b);
	chk(s == "defgx");
	ieq(calls_2526T21b, 7); // complexity

	// strict iterators over strings
	const Char *ptr = (const Char *)"abcxx";
	Ustr s4 (ptr, ptr+5);
	int err1 = 0, nrec1 = 5;
	strict_output_iterator<Ustr::iterator, Char> it1
		(s4.begin(), err1, nrec1);
	calls_2526T21b = 7;
	generate_n(it1, 5, f_2526T21b);
	chk(s4 == "hijkl");
	steq(s4.c_str(), "hijkl");
	ieq(calls_2526T21b, 12); // complexity
	ieq(err1, 0);

	// complexity
	Mychar_2526T21b a[10];
	assts_2526T21b = 0;
	calls_2526T21b = 0;
	generate_n(a, 10, f_2526T21b);
	ieq(assts_2526T21b, 10); // complexity, assignments
	ieq(calls_2526T21b, 10); // complexity, invocations

	}
	end_chk("_2526T21b");
#else
	skip_chk("_2526T21b");
#endif /* CASE_2526T21b */

return leave_chk("t252");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t260.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _262T11  <complex> synopsis */
#if !defined(SKIP_262T11)&&(!defined(ONLY)||defined(CASE_262T11))
#if DISALLOW_USER_NAME_PROTECTION
 #include <complex>
#else
	#define re	"re"	/* looking for trouble */
	#define im	"im"
 #include <complex>
	#undef im
	#undef re
#endif
#endif /* CASE_262T11 */

/* _2621T11  complex definition */
#if !defined(SKIP_2621T11)&&(!defined(ONLY)||defined(CASE_2621T11))
#include <complex>
#endif /* CASE_2621T11 */

/* _2622T11  complex<float, double, long double> definitions */
#if !defined(SKIP_2622T11)&&(!defined(ONLY)||defined(CASE_2622T11))
#include <complex>
#endif /* CASE_2622T11 */

/* _2623T11 complex(T re = T(), T im = T())    effects, postcondition */
#if !defined(SKIP_2623T11)&&(!defined(ONLY)||defined(CASE_2623T11))
#include <complex>
#endif /* CASE_2623T11 */

/* _2624T11 operator+=   effects, returns */
#if !defined(SKIP_2624T11)&&(!defined(ONLY)||defined(CASE_2624T11))
#include <complex>
#endif /* CASE_2624T11 */

/* _2624T21 operator-=   effects, returns */
#if !defined(SKIP_2624T21)&&(!defined(ONLY)||defined(CASE_2624T21))
#include <complex>
#endif /* CASE_2624T21 */

/* _2624T31 operator*=   effects, returns */
#if !defined(SKIP_2624T31)&&(!defined(ONLY)||defined(CASE_2624T31))
#include <complex>
#endif /* CASE_2624T31 */

/* _2624T41 operator/=   effects, returns */
#if !defined(SKIP_2624T41)&&(!defined(ONLY)||defined(CASE_2624T41))
#include <complex>
#endif /* CASE_2624T41 */

/* _2625T11 unary  op+(complx)  effects, returns */
#if !defined(SKIP_2625T11)&&(!defined(ONLY)||defined(CASE_2625T11))
#include <complex>
#endif /* CASE_2625T11 */

/* _2625T21 op+(cmplx, cmplx)  effects, returns */
#if !defined(SKIP_2625T21)&&(!defined(ONLY)||defined(CASE_2625T21))
#include <complex>
#endif /* CASE_2625T21 */

/* _2625T22 op+(cmplx, T)  effects, returns */
#if !defined(SKIP_2625T22)&&(!defined(ONLY)||defined(CASE_2625T22))
#include <complex>
#endif /* CASE_2625T22 */

/* _2625T23 op+(T, cmplx)  effects, returns */
#if !defined(SKIP_2625T23)&&(!defined(ONLY)||defined(CASE_2625T23))
#include <complex>
#endif /* CASE_2625T23 */

/* _2625T31 unary op-(cmplx) */
#if !defined(SKIP_2625T31)&&(!defined(ONLY)||defined(CASE_2625T31))
#include <complex>
#endif /* CASE_2625T31 */

/* _2625T41 op-(cmplx, cmplx)  effects, returns */
#if !defined(SKIP_2625T41)&&(!defined(ONLY)||defined(CASE_2625T41))
#include <complex>
#endif /* CASE_2625T41 */

/* _2625T42 op-(cmplx, T)  effects, returns */
#if !defined(SKIP_2625T42)&&(!defined(ONLY)||defined(CASE_2625T42))
#include <complex>
#endif /* CASE_2625T42 */

/* _2625T43 op-(T, cmplx)  effects, returns */
#if !defined(SKIP_2625T43)&&(!defined(ONLY)||defined(CASE_2625T43))
#include <complex>
#endif /* CASE_2625T43 */

/* _2625T51 op*(cmplx, cmplx)  effects, returns */
#if !defined(SKIP_2625T51)&&(!defined(ONLY)||defined(CASE_2625T51))
#include <complex>
#endif /* CASE_2625T51 */

/* _2625T52 op*(cmplx, T)  effects, returns */
#if !defined(SKIP_2625T52)&&(!defined(ONLY)||defined(CASE_2625T52))
#include <complex>
#endif /* CASE_2625T52 */

/* _2625T53 op*(T, cmplx)  effects, returns */
#if !defined(SKIP_2625T53)&&(!defined(ONLY)||defined(CASE_2625T53))
#include <complex>
#endif /* CASE_2625T53 */

int t260_main(int, char *[])
{
enter_chk("t260.cpp");
/* _262T11  <complex> synopsis */
#if !defined(SKIP_262T11)&&(!defined(ONLY)||defined(CASE_262T11))
	begin_chk("_262T11");
	{
	CPXfloat *p0 = 0; TOUCH(p0);
	CPXdouble *p1 = 0; TOUCH(p1);
	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble *p2 = 0; TOUCH(p2);
	#endif /* IS_EMBEDDED */
	chk(1);





	}
	end_chk("_262T11");
#else
	skip_chk("_262T11");
#endif /* CASE_262T11 */

/* _2621T11  complex definition */
#if !defined(SKIP_2621T11)&&(!defined(ONLY)||defined(CASE_2621T11))
	begin_chk("_2621T11");
	{
	#if IS_EMBEDDED
	typedef float_complex Mycplx;
	float *p0 = (Mycplx::value_type *)0; TOUCH(p0);	// ADDED [MAR96]
	#else /* IS_EMBEDDED */
	typedef complex<Myfloat> Mycplx;
	Myfloat *p0 = (Mycplx::value_type *)0; TOUCH(p0);	// ADDED [MAR96]
	#endif /* IS_EMBEDDED */
	Mycplx c0(5, -3);

	chk(c0.real() == 5);
	chk(c0.imag() == -3);


	}
	end_chk("_2621T11");
#else
	skip_chk("_2621T11");
#endif /* CASE_2621T11 */

/* _2622T11  complex<float, double, long double> definitions */
#if !defined(SKIP_2622T11)&&(!defined(ONLY)||defined(CASE_2622T11))
	begin_chk("_2622T11");
	{
	typedef CPXfloat Mycplx0;
	float *p0 = (Mycplx0::value_type *)0; TOUCH(p0);	// ADDED [MAR96]
	Mycplx0 c0;
	chk(c0.real() == 0 && c0.imag() == 0);

	typedef CPXdouble Mycplx1;
	double *p1 = (Mycplx1::value_type *)0; TOUCH(p1);	// ADDED [MAR96]
	Mycplx1 c1(5);
	chk(c1.real() == 5 && c1.imag() == 0);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	typedef CPXldouble Mycplx2;
	long double *p2 = (Mycplx2::value_type *)0; TOUCH(p2);	// ADDED [MAR96]
	Mycplx2 c2(5, -3);
	chk(c2.real() == 5 && c2.imag() == -3);
	#endif /* IS_EMBEDDED */





	}
	end_chk("_2622T11");
#else
	skip_chk("_2622T11");
#endif /* CASE_2622T11 */

/* _2623T11 complex(T re = T(), T im = T())    effects, postcondition */
#if !defined(SKIP_2623T11)&&(!defined(ONLY)||defined(CASE_2623T11))
	begin_chk("_2623T11");
	{
	CPXfloat cf;
	feq(cf.real(), 0.F);
	feq(cf.imag(), 0.F);
	feq((cf = (float)3.0).real(), 3.F);	// ADDED [MAR96]
	CPXfloat cf2 (9.);
	feq(cf2.real(), 9.F);
	feq(cf2.imag(), 0.F);
	CPXfloat cf3 (8., 7.F);
	feq(cf3.real(), 8.F);
	feq(cf3.imag(), 7.F);

	CPXdouble cd;
	deq(cd.real(), 0.);
	deq(cd.imag(), 0.);
	deq((cd = (double)3.0).real(), 3);	// ADDED [MAR96]
	CPXdouble cd2 (9.);
	deq(cd2.real(), 9.);
	deq(cd2.imag(), 0.);
	CPXdouble cd3 (8., 7.);
	deq(cd3.real(), 8.);
	deq(cd3.imag(), 7.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld;
	ldeq(cld.real(), 0.);
	ldeq(cld.imag(), 0.);
	ldeq((cld = (long double)3.0).real(), 3);	// ADDED [MAR96]
	CPXldouble cld2 (9.);
	ldeq(cld2.real(), 9.);
	ldeq(cld2.imag(), 0.);
	CPXldouble cld3 (8., 7.);
	ldeq(cld3.real(), 8.);
	ldeq(cld3.imag(), 7.);

	complex<Myfloat> ci;
	chk(ci.real() == 0);
	chk(ci.imag() == 0);
	ci = (Myfloat)3.0;
	chk(ci.real() == 3);	// ADDED [MAR96]
	complex<Myfloat> ci2 (9);
	chk(ci2.real() == 9);
	chk(ci2.imag() == 0);
	complex<Myfloat> ci3 (8, 7);
	chk(ci3.real() == 8);
	chk(ci3.imag() == 7);
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2623T11");
#else
	skip_chk("_2623T11");
#endif /* CASE_2623T11 */

/* _2624T11 operator+=   effects, returns */
#if !defined(SKIP_2624T11)&&(!defined(ONLY)||defined(CASE_2624T11))
	begin_chk("_2624T11");
	{
	CPXfloat cf (9., 8.);
	CPXfloat cf2 (7., 5.);
	feq((cf += cf2).real(), 16.F);
	feq(cf.real(), 16.F);
	feq(cf.imag(), 13.F);
	feq((cf += (float)3.0).real(), 19.F);	// ADDED [MAR96]

	CPXdouble cd (9., 8.);
	CPXdouble cd2 (7., 5.);
	deq((cd += cd2).real(), 16);
	deq(cd.real(), 16.);
	deq(cd.imag(), 13.);
	deq((cd += (double)3.0).real(), 19);	// ADDED [MAR96]

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	CPXldouble cld2 (7., 5.);
	ldeq((cld += cld2).real(), 16);
	ldeq(cld.real(), 16.);
	ldeq(cld.imag(), 13.);
	ldeq((cld += (long double)3.0).real(), 19);	// ADDED [MAR96]

	complex<Myfloat> ci (9, 8);
	complex<Myfloat> ci2 (7, 5);
	chk((ci += ci2).real() == 16);
	chk(ci.real() == 16);
	chk(ci.imag() == 13);
	chk((ci += (Myfloat)3.0).real() == 19);	// ADDED [MAR96]
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2624T11");
#else
	skip_chk("_2624T11");
#endif /* CASE_2624T11 */

/* _2624T21 operator-=   effects, returns */
#if !defined(SKIP_2624T21)&&(!defined(ONLY)||defined(CASE_2624T21))
	begin_chk("_2624T21");
	{
	CPXfloat cf (9., 8.);
	CPXfloat cf2 (7., 5.);
	feq((cf -= cf2).real(), 2.F);
	feq(cf.real(), 2.F);
	feq(cf.imag(), 3.F);
	feq((cf -= (float)3.0).real(), -1.F);	// ADDED [MAR96]

	CPXdouble cd (9., 8.);
	CPXdouble cd2 (7., 5.);
	deq((cd -= cd2).real(), 2.);
	deq(cd.real(), 2.);
	deq(cd.imag(), 3.);
	deq((cd -= (double)3.0).real(), -1);	// ADDED [MAR96]

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	CPXldouble cld2 (7., 5.);
	ldeq((cld -= cld2).real(), 2.);
	ldeq(cld.real(), 2.);
	ldeq(cld.imag(), 3.);
	ldeq((cld -= (long double)3.0).real(), -1);	// ADDED [MAR96]

	complex<Myfloat> ci (9, 8);
	complex<Myfloat> ci2 (7, 5);
	chk((ci -= ci2).real() == 2);
	chk(ci.real() == 2);
	chk(ci.imag() == 3);
	chk((ci -= (float)3.0).real() == -1);	// ADDED [MAR96]
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2624T21");
#else
	skip_chk("_2624T21");
#endif /* CASE_2624T21 */

/* _2624T31 operator*=   effects, returns */
#if !defined(SKIP_2624T31)&&(!defined(ONLY)||defined(CASE_2624T31))
	begin_chk("_2624T31");
	{
	CPXfloat cf (9., 8.);
	CPXfloat cf2 (7., 5.);
	feq((cf *= cf2).real(), 23.F);
	feq(cf.real(), 23.F);
	feq(cf.imag(), 101.F);
	feq((cf *= (float)3.0).real(), 69.F);	// ADDED [MAR96]

	CPXdouble cd (9., 8.);
	CPXdouble cd2 (7., 5.);
	deq((cd *= cd2).real(), 23.);
	deq(cd.real(), 23.);
	deq(cd.imag(), 101.);
	deq((cd *= (double)3.0).real(), 69);	// ADDED [MAR96]

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	CPXldouble cld2 (7., 5.);
	ldeq((cld *= cld2).real(), 23.);
	ldeq(cld.real(), 23.);
	ldeq(cld.imag(), 101.);
	ldeq((cld *= (long double)3.0).real(), 69);	// ADDED [MAR96]

	complex<Myfloat> ci (9, 8);
	complex<Myfloat> ci2 (7, 5);
	chk((ci *= ci2).real() == 23);
	chk(ci.real() == 23);
	chk(ci.imag() == 101);
	chk((ci *= (Myfloat)3.0).real() == 69);	// ADDED [MAR96]
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2624T31");
#else
	skip_chk("_2624T31");
#endif /* CASE_2624T31 */

/* _2624T41 operator/=   effects, returns */
#if !defined(SKIP_2624T41)&&(!defined(ONLY)||defined(CASE_2624T41))
	begin_chk("_2624T41");
	{
	CPXfloat cf (23., 101.);
	CPXfloat cf2 (9., 8.);
	feq((cf /= cf2).real(), 7.F);
	feq(cf.real(), 7.F);
	feq(cf.imag(), 5.F);
	feq((cf /= (float)7.0).real(), 1.F);	// ADDED [MAR96]

	CPXdouble cd (23., 101.);
	CPXdouble cd2 (9., 8.);
	deq((cd /= cd2).real(), 7.);
	deq(cd.real(), 7.);
	deq(cd.imag(), 5.);
	deq((cd /= (double)7.0).real(), 1);	// ADDED [MAR96]

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (23., 101.);
	CPXldouble cld2 (9., 8.);
	ldeq((cld /= cld2).real(), 7.);
	ldeq(cld.real(), 7.);
	ldeq(cld.imag(), 5.);
	ldeq((cld /= (long double)7.0).real(), 1);	// ADDED [MAR96]

	complex<Myfloat> ci (23, 101);
	complex<Myfloat> ci2 (9, 8);
	deq((ci /= ci2).real(), 7.);
	deq(ci.real(), 7.);
	deq(ci.imag(), 5.);
	deq((ci /= (Myfloat)7.0).real(), 1.);	// ADDED [MAR96]
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2624T41");
#else
	skip_chk("_2624T41");
#endif /* CASE_2624T41 */

/* _2625T11 unary  op+(complx)  effects, returns */
#if !defined(SKIP_2625T11)&&(!defined(ONLY)||defined(CASE_2625T11))
	begin_chk("_2625T11");
	{
	CPXfloat cf (9., 8.);
	feq((+cf).real(), 9.F);
	feq((+cf).imag(), 8.F);

	CPXdouble cd (9., 8.);
	deq((+cd).real(), 9.);
	deq((+cd).imag(), 8.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	ldeq((+cld).real(), 9.);
	ldeq((+cld).imag(), 8.);

	complex<Myfloat> ci (9, 8);
	chk((+ci).real() == 9);
	chk((+ci).imag() == 8);
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2625T11");
#else
	skip_chk("_2625T11");
#endif /* CASE_2625T11 */

/* _2625T21 op+(cmplx, cmplx)  effects, returns */
#if !defined(SKIP_2625T21)&&(!defined(ONLY)||defined(CASE_2625T21))
	begin_chk("_2625T21");
	{
	CPXfloat cf (9., 8.);
	CPXfloat cf2 (7., 5.);
	feq((cf + cf2).real(), 16.F);
	feq((cf + cf2).imag(), 13.F);

	CPXdouble cd (9., 8.);
	CPXdouble cd2 (7., 5.);
	deq((cd + cd2).real(), 16.);
	deq((cd + cd2).imag(), 13.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	CPXldouble cld2 (7., 5.);
	ldeq((cld + cld2).real(), 16.);
	ldeq((cld + cld2).imag(), 13.);

	complex<Myfloat> ci (9, 8);
	complex<Myfloat> ci2 (7, 5);
	chk((ci + ci2).real() == 16);
	chk((ci + ci2).imag() == 13);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2625T21");
#else
	skip_chk("_2625T21");
#endif /* CASE_2625T21 */

/* _2625T22 op+(cmplx, T)  effects, returns */
#if !defined(SKIP_2625T22)&&(!defined(ONLY)||defined(CASE_2625T22))
	begin_chk("_2625T22");
	{
	CPXfloat cf (9., 8.);
	float f2 = 7.;
	feq((cf + f2).real(), 16.F);
	feq((cf + f2).imag(), 8.F);

	CPXdouble cd (9., 8.);
	double d2 = 7.;
	deq((cd + d2).real(), 16.);
	deq((cd + d2).imag(), 8.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	long double ld2 = 7.;
	ldeq((cld + ld2).real(), 16.);
	ldeq((cld + ld2).imag(), 8.);

	complex<Myfloat> ci (9, 8);
	Myfloat i2 = 7;
	chk((ci + i2).real() == 16);
	chk((ci + i2).imag() == 8);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2625T22");
#else
	skip_chk("_2625T22");
#endif /* CASE_2625T22 */

/* _2625T23 op+(T, cmplx)  effects, returns */
#if !defined(SKIP_2625T23)&&(!defined(ONLY)||defined(CASE_2625T23))
	begin_chk("_2625T23");
	{
	CPXfloat cf (9., 8.);
	float f2 = 7.;
	feq((f2 + cf).real(), 16.F);
	feq((f2 + cf).imag(), 8.F);

	CPXdouble cd (9., 8.);
	double d2 = 7.;
	deq((d2 + cd).real(), 16.);
	deq((d2 + cd).imag(), 8.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	long double ld2 = 7.;
	ldeq((ld2 + cld).real(), 16.);
	ldeq((ld2 + cld).imag(), 8.);

	complex<Myfloat> ci (9, 8);
	Myfloat i2 = 7;
	chk((i2 + ci).real() == 16);
	chk((i2 + ci).imag() == 8);
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2625T23");
#else
	skip_chk("_2625T23");
#endif /* CASE_2625T23 */

/* _2625T31 unary op-(cmplx) */
#if !defined(SKIP_2625T31)&&(!defined(ONLY)||defined(CASE_2625T31))
	begin_chk("_2625T31");
	{
	CPXfloat cf (9., 8.);
	feq((-cf).real(), -9.F);
	feq((-cf).imag(), -8.F);

	CPXdouble cd (9., 8.);
	deq((-cd).real(), -9.);
	deq((-cd).imag(), -8.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	ldeq((-cld).real(), -9.);
	ldeq((-cld).imag(), -8.);

	complex<Myfloat> ci (9, 8);
	chk((-ci).real() == -9);
	chk((-ci).imag() == -8);
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2625T31");
#else
	skip_chk("_2625T31");
#endif /* CASE_2625T31 */

/* _2625T41 op-(cmplx, cmplx)  effects, returns */
#if !defined(SKIP_2625T41)&&(!defined(ONLY)||defined(CASE_2625T41))
	begin_chk("_2625T41");
	{
	CPXfloat cf (9., 8.);
	CPXfloat cf2 (7., 5.);
	feq((cf - cf2).real(), 2.F);
	feq((cf - cf2).imag(), 3.F);

	CPXdouble cd (9., 8.);
	CPXdouble cd2 (7., 5.);
	deq((cd - cd2).real(), 2.);
	deq((cd - cd2).imag(), 3.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	CPXldouble cld2 (7., 5.);
	ldeq((cld - cld2).real(), 2.);
	ldeq((cld - cld2).imag(), 3.);

	complex<Myfloat> ci (9, 8);
	complex<Myfloat> ci2 (7, 5);
	chk((ci - ci2).real() == 2);
	chk((ci - ci2).imag() == 3);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2625T41");
#else
	skip_chk("_2625T41");
#endif /* CASE_2625T41 */

/* _2625T42 op-(cmplx, T)  effects, returns */
#if !defined(SKIP_2625T42)&&(!defined(ONLY)||defined(CASE_2625T42))
	begin_chk("_2625T42");
	{
	CPXfloat cf (9., 8.);
	float f2 = 7.;
	feq((cf - f2).real(), 2.F);
	feq((cf - f2).imag(), 8.F);

	CPXdouble cd (9., 8.);
	double d2 = 7.;
	deq((cd - d2).real(), 2.);
	deq((cd - d2).imag(), 8.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	long double ld2 = 7.;
	ldeq((cld - ld2).real(), 2.);
	ldeq((cld - ld2).imag(), 8.);

	complex<Myfloat> ci (9, 8);
	Myfloat i2 = 7;
	chk((ci - i2).real() == 2);
	chk((ci - i2).imag() == 8);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2625T42");
#else
	skip_chk("_2625T42");
#endif /* CASE_2625T42 */

/* _2625T43 op-(T, cmplx)  effects, returns */
#if !defined(SKIP_2625T43)&&(!defined(ONLY)||defined(CASE_2625T43))
	begin_chk("_2625T43");
	{
	CPXfloat cf (9., 8.);
	float f2 = 7.;
	feq((f2 - cf).real(), -2.F);
	feq((f2 - cf).imag(), -8.F);

	CPXdouble cd (9., 8.);
	double d2 = 7.;
	deq((d2 - cd).real(), -2.);
	deq((d2 - cd).imag(), -8.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	long double ld2 = 7.;
	ldeq((ld2 - cld).real(), -2.);
	ldeq((ld2 - cld).imag(), -8.);

	complex<Myfloat> ci (9, 8);
	Myfloat i2 = 7;
	chk((i2 - ci).real() == -2);
	chk((i2 - ci).imag() == -8);
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2625T43");
#else
	skip_chk("_2625T43");
#endif /* CASE_2625T43 */

/* _2625T51 op*(cmplx, cmplx)  effects, returns */
#if !defined(SKIP_2625T51)&&(!defined(ONLY)||defined(CASE_2625T51))
	begin_chk("_2625T51");
	{
	CPXfloat cf (9., 8.);
	CPXfloat cf2 (7., 5.);
	feq((cf * cf2).real(), 23.F);
	feq((cf * cf2).imag(), 101.F);

	CPXdouble cd (9., 8.);
	CPXdouble cd2 (7., 5.);
	deq((cd * cd2).real(), 23.);
	deq((cd * cd2).imag(), 101.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	CPXldouble cld2 (7., 5.);
	ldeq((cld * cld2).real(), 23.);
	ldeq((cld * cld2).imag(), 101.);

	complex<Myfloat> ci (9, 8);
	complex<Myfloat> ci2 (7, 5);
	chk((ci * ci2).real() == 23);
	chk((ci * ci2).imag() == 101);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2625T51");
#else
	skip_chk("_2625T51");
#endif /* CASE_2625T51 */

/* _2625T52 op*(cmplx, T)  effects, returns */
#if !defined(SKIP_2625T52)&&(!defined(ONLY)||defined(CASE_2625T52))
	begin_chk("_2625T52");
	{
	CPXfloat cf (9., 8.);
	float f2 = 7.;
	feq((cf * f2).real(), 63.F);
	feq((cf * f2).imag(), 56.F);

	CPXdouble cd (9., 8.);
	double d2 = 7.;
	deq((cd * d2).real(), 63.);
	deq((cd * d2).imag(), 56.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	long double ld2 = 7.;
	ldeq((cld * ld2).real(), 63.);
	ldeq((cld * ld2).imag(), 56.);

	complex<Myfloat> ci (9, 8);
	Myfloat i2 = 7;
	chk((ci * i2).real() == 63);
	chk((ci * i2).imag() == 56);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2625T52");
#else
	skip_chk("_2625T52");
#endif /* CASE_2625T52 */

/* _2625T53 op*(T, cmplx)  effects, returns */
#if !defined(SKIP_2625T53)&&(!defined(ONLY)||defined(CASE_2625T53))
	begin_chk("_2625T53");
	{
	CPXfloat cf (9., 8.);
	float f2 = 7.;
	feq((f2 * cf).real(), 63.F);
	feq((f2 * cf).imag(), 56.F);

	CPXdouble cd (9., 8.);
	double d2 = 7.;
	deq((d2 * cd).real(), 63.);
	deq((d2 * cd).imag(), 56.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (9., 8.);
	long double ld2 = 7.;
	ldeq((ld2 * cld).real(), 63.);
	ldeq((ld2 * cld).imag(), 56.);

	complex<Myfloat> ci (9, 8);
	Myfloat i2 = 7;
	chk((i2 * ci).real()== 63);
	chk((i2 * ci).imag() == 56);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2625T53");
#else
	skip_chk("_2625T53");
#endif /* CASE_2625T53 */

return leave_chk("t260");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t270.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"

#if IS_EMBEDDED
#define ONLY
#define CASE_272T01	<iosfwd> synopsis
#define CASE_273T11	<iostream> synopsis
#define CASE_273T32	<iostream> objects constructed by basic_ios::Init
#define CASE_2731T21	cin.tie() returns
#define CASE_2731T51	cerr.flags() has unitbuf set
#define CASE_2731T61	clog associated with stderr
//#define CASE_2732T11	wcin associated with stdin
//#define CASE_2732T21	wcin.tie() returns
//#define CASE_2732T31	wcout associated with stdout
//#define CASE_2732T41	wcerr associated with stderr
//#define CASE_2732T51	wcerr.flags() has unitbuf set
//#define CASE_2732T61	wclog associated with stderr
#define CASE_274T11	<ios> synopsis
#define CASE_2741T11	streamoff requirements
#define CASE_2741T31	streampos requirements
//#define CASE_2741T41	wstreampos requirements
#define CASE_2741T51	streamsize requirements
//#define CASE_2742T12	char_traits definition
//#define CASE_2742T21	char_traits instantiations
//#define CASE_27421T12	char_traits::state_type requirements
//#define CASE_27422T41	char_traits::eof returns
//#define CASE_27422T61	char_traits::not_eof returns
//#define CASE_27422T_121	char_traits::length returns
//#define CASE_27423T21	char_traits::eq returns	CHANGED [MAR96]
//#define CASE_27423T41	char_traits::eq_int_type returns
//#define CASE_27424T21	char_traits::to_char_type returns
//#define CASE_27424T41	char_traits::to_int_type returns
//#define CASE_27424T61	char_traits::copy returns
#endif /* IS_EMBEDDED */

/* _272T01 <iosfwd> synopsis */
#if !defined(SKIP_272T01)&&(!defined(ONLY)||defined(CASE_272T01))
#if DISALLOW_USER_NAME_PROTECTION
 #include <iosfwd>
#else
	#define charT	"charT"	/* looking for trouble */
	#define traits	"traits"
 #include <iosfwd>
	#undef traits
	#undef charT
#endif
#endif /* CASE_272T01 */

/* _273T11 <iostream> synopsis */
#if !defined(SKIP_273T11)&&(!defined(ONLY)||defined(CASE_273T11))
#if DISALLOW_USER_NAME_PROTECTION
 #include <iostream>
#else
	#define stdio		"stdio"	/* looking for trouble */
	#define ispecial	"ispecial"
	#define delbuf		"delbuf"
 #include <iostream>
	#undef stdio
	#undef ispecial
	#undef delbuf
#endif
#endif /* CASE_273T11 */

/* _273T32 <iostream> objects constructed by basic_ios::Init */
#if !defined(SKIP_273T32)&&(!defined(ONLY)||defined(CASE_273T32))
#include <iostream>
int cnt_273T32 = 0;
STD ios::Init x2;
struct x_273T32 {
	x_273T32()
		{if (STD cin.tie() == &STD cout)
			++cnt_273T32; }
	} staticx_273T32;
#endif /* CASE_273T32 */

/* _2731T21 cin.tie() returns */
#if !defined(SKIP_2731T21)&&(!defined(ONLY)||defined(CASE_2731T21))
#include <iostream>
#endif /* CASE_2731T21 */

/* _2731T51 cerr.flags() has unitbuf set */
#if !defined(SKIP_2731T51)&&(!defined(ONLY)||defined(CASE_2731T51))
#include <iostream>
#endif /* CASE_2731T51 */

/* _2731T61 clog associated with stderr */
#if !defined(SKIP_2731T61)&&(!defined(ONLY)||defined(CASE_2731T61))
#include <iostream>
#endif /* CASE_2731T61 */

/* _2732T11 wcin associated with stdin */
#if !defined(SKIP_2732T11)&&(!defined(ONLY)||defined(CASE_2732T11))
#include <iostream>
#endif /* CASE_2732T11 */

/* _2732T21 wcin.tie() returns */
#if !defined(SKIP_2732T21)&&(!defined(ONLY)||defined(CASE_2732T21))
#include <iostream>
#endif /* CASE_2732T21 */

/* _2732T31 wcout associated with stdout */
#if !defined(SKIP_2732T31)&&(!defined(ONLY)||defined(CASE_2732T31))
#include <iostream>
#endif /* CASE_2732T31 */

/* _2732T41 wcerr associated with stderr */
#if !defined(SKIP_2732T41)&&(!defined(ONLY)||defined(CASE_2732T41))
#include <iostream>
#endif /* CASE_2732T41 */

/* _2732T51 wcerr.flags() has unitbuf set */
#if !defined(SKIP_2732T51)&&(!defined(ONLY)||defined(CASE_2732T51))
#include <iostream>
#endif /* CASE_2732T51 */

/* _2732T61 wclog associated with stderr */
#if !defined(SKIP_2732T61)&&(!defined(ONLY)||defined(CASE_2732T61))
#include <iostream>
#endif /* CASE_2732T61 */

/* _274T11 <ios> synopsis */
#if !defined(SKIP_274T11)&&(!defined(ONLY)||defined(CASE_274T11))
#if DISALLOW_USER_NAME_PROTECTION
 #include <ios>
#else
	#define charT	"charT"
	#define POS_T	"POS_T"
	#define OFF_T	"OFF_T"
	#define traits	"traits"
 #include <ios>
	#undef traits
	#undef charT
	#undef POS_T
	#undef OFF_T
#endif
#include <iostream>
#endif /* CASE_274T11 */

/* _2741T11 streamoff requirements */
#if !defined(SKIP_2741T11)&&(!defined(ONLY)||defined(CASE_2741T11))
#include <climits>
#include <ios>
#endif /* CASE_2741T11 */

/* _2741T31 streampos requirements */
#if !defined(SKIP_2741T31)&&(!defined(ONLY)||defined(CASE_2741T31))
#include <climits>
#include <ios>
#endif /* CASE_2741T31 */

/* _2741T41 wstreampos requirements */
#if !defined(SKIP_2741T41)&&(!defined(ONLY)||defined(CASE_2741T41))
#include <climits>
#include <ios>
#endif /* CASE_2741T41 */

/* _2741T51 streamsize requirements */
#if !defined(SKIP_2741T51)&&(!defined(ONLY)||defined(CASE_2741T51))
#include <climits>
#include <ios>
#endif /* CASE_2741T51 */

/* _2742T12 char_traits definition */
#if !defined(SKIP_2742T12)&&(!defined(ONLY)||defined(CASE_2742T12))
#include <cstring>
#include <ios>
#include <locale>
class Mycty_2742T12 : public ctype<unsigned char> {
	};
#endif /* CASE_2742T12 */

/* _2742T21 char_traits instantiations */
#if !defined(SKIP_2742T21)&&(!defined(ONLY)||defined(CASE_2742T21))
#include <ios>
#endif /* CASE_2742T21 */

/* _27421T12 char_traits::state_type requirements */
#if !defined(SKIP_27421T12)&&(!defined(ONLY)||defined(CASE_27421T12))
#include <cstring>
#include <ios>
#include <string>
#endif /* CASE_27421T12 */

/* _27422T41 char_traits::eof returns */
#if !defined(SKIP_27422T41)&&(!defined(ONLY)||defined(CASE_27422T41))
#include <cstdio>
#include <cwchar>
#include <ios>
#include <string>
#endif /* CASE_27422T41 */

/* _27422T61 char_traits::not_eof returns */
#if !defined(SKIP_27422T61)&&(!defined(ONLY)||defined(CASE_27422T61))
#include <ios>
#include <string>
#endif /* CASE_27422T61 */

/* _27422T_121 char_traits::length returns */
#if !defined(SKIP_27422T_121)&&(!defined(ONLY)||defined(CASE_27422T_121))
#include <ios>
#include <string>
#endif /* CASE_27422T_121 */

/* _27423T21 char_traits::eq returns	CHANGED [MAR96] */
#if !defined(SKIP_27423T21)&&(!defined(ONLY)||defined(CASE_27423T21))
#include <ios>
#include <string>
#endif /* CASE_27423T21 */

/* _27423T41 char_traits::eq_int_type returns */
#if !defined(SKIP_27423T41)&&(!defined(ONLY)||defined(CASE_27423T41))
#include <ios>
#include <string>
#endif /* CASE_27423T41 */

/* _27424T21 char_traits::to_char_type returns */
#if !defined(SKIP_27424T21)&&(!defined(ONLY)||defined(CASE_27424T21))
#include <ios>
#include <string>
#endif /* CASE_27424T21 */

/* _27424T41 char_traits::to_int_type returns */
#if !defined(SKIP_27424T41)&&(!defined(ONLY)||defined(CASE_27424T41))
#include <ios>
#include <string>
#endif /* CASE_27424T41 */

/* _27424T61 char_traits::copy returns */
#if !defined(SKIP_27424T61)&&(!defined(ONLY)||defined(CASE_27424T61))
#include <cstring>
#include <cwchar>
#include <ios>
#include <string>
#endif /* CASE_27424T61 */

int t270_main(int, char *[])
{
enter_chk("t270.cpp");
/* _272T01 <iosfwd> synopsis */
#if !defined(SKIP_272T01)&&(!defined(ONLY)||defined(CASE_272T01))
	begin_chk("_272T01");
	{
	//STD streamoff *q0 = 0; TOUCH(q0);
	STD streampos *q1 = 0; TOUCH(q1);
	#if IS_EMBEDDED
	STD ios *p1 = 0; TOUCH(p1);

	STD streambuf *p3 = 0; TOUCH(p3);
	STD istream *p5 = 0; TOUCH(p5);
	STD ostream *p7 = 0; TOUCH(p7);

	STD stringbuf *p13 = 0; TOUCH(p13);
	STD istringstream *p15 = 0; TOUCH(p15);
	STD ostringstream *p17 = 0; TOUCH(p17);

	STD filebuf *p23 = 0; TOUCH(p23);
	STD ifstream *p25 = 0; TOUCH(p25);
	STD ofstream *p27 = 0; TOUCH(p27);
	#else /* IS_EMBEDDED */
	STD char_traits<char> *q2 = 0; TOUCH(q2);
	STD istreambuf_iterator<char, STD char_traits<char> > *q3; TOUCH(q3);
	STD ostreambuf_iterator<char, STD char_traits<char> > *q4; TOUCH(q4);

	STD wstreampos *wq1 = 0; TOUCH(wq1);
	STD char_traits<wchar_t> *wq2 = 0; TOUCH(wq2);

	STD basic_ios<char, STD char_traits<char> > *p0 = 0; TOUCH(p0);
	STD ios *p1 = p0; TOUCH(p1);

	STD basic_streambuf<char, STD char_traits<char> > *p2 = 0; TOUCH(p2);
	STD streambuf *p3 = p2; TOUCH(p3);
	STD basic_istream<char, STD char_traits<char> > *p4 = 0; TOUCH(p4);
	STD istream *p5 = p4; TOUCH(p5);
	STD basic_ostream<char, STD char_traits<char> > *p6 = 0; TOUCH(p6);
	STD ostream *p7 = p6; TOUCH(p7);
	STD basic_iostream<char, STD char_traits<char> > *p8 = 0; TOUCH(p8);
	STD iostream *p9 = p8; TOUCH(p9);

	STD basic_stringbuf<char, STD char_traits<char>,	// CHANGED [JUL96]
		STD allocator<char> > *p12 = 0; TOUCH(p12);
	STD stringbuf *p13 = p12; TOUCH(p13);
	STD basic_istringstream<char, STD char_traits<char>,
		STD allocator<char> > *p14 = 0; TOUCH(p14);
	STD istringstream *p15 = p14; TOUCH(p15);
	STD basic_ostringstream<char, STD char_traits<char>,
		STD allocator<char> > *p16 = 0; TOUCH(p16);
	STD ostringstream *p17 = p16; TOUCH(p17);
	STD basic_stringstream<char, STD char_traits<char>,
		STD allocator<char> > *p18 = 0; TOUCH(p18);
	STD stringstream *p19 = p18; TOUCH(p19);

	STD basic_filebuf<char, STD char_traits<char> > *p22 = 0; TOUCH(p22);
	STD filebuf *p23 = p22; TOUCH(p23);
	STD basic_ifstream<char, STD char_traits<char> > *p24 = 0; TOUCH(p24);
	STD ifstream *p25 = p24; TOUCH(p25);
	STD basic_ofstream<char, STD char_traits<char> > *p26 = 0; TOUCH(p26);
	STD ofstream *p27 = p26; TOUCH(p27);
	STD basic_fstream<char, STD char_traits<char> > *p28 = 0; TOUCH(p28);
	STD fstream *p29 = p28; TOUCH(p29);

	STD basic_ios<wchar_t, STD char_traits<wchar_t> > *wp0 = 0; TOUCH(wp0);
	STD wios *wp1 = wp0; TOUCH(wp1);

	STD basic_streambuf<wchar_t, STD char_traits<wchar_t> > *wp2 = 0; TOUCH(wp2);
	STD wstreambuf *wp3 = wp2; TOUCH(wp3);
	STD basic_istream<wchar_t, STD char_traits<wchar_t> > *wp4 = 0; TOUCH(wp4);
	STD wistream *wp5 = wp4; TOUCH(wp5);
	STD basic_ostream<wchar_t, STD char_traits<wchar_t> > *wp6 = 0; TOUCH(wp6);
	STD wostream *wp7 = wp6; TOUCH(wp7);
	STD basic_iostream<wchar_t, STD char_traits<wchar_t> > *wp8 = 0; TOUCH(wp8);
	STD wiostream *wp9 = wp8; TOUCH(wp9);

	STD basic_stringbuf<wchar_t, STD char_traits<wchar_t>,
		STD allocator<wchar_t> > *wp12 = 0; TOUCH(wp12);	// CHANGED [JUL96]
	STD wstringbuf *wp13 = wp12; TOUCH(wp13);
	STD basic_istringstream<wchar_t, STD char_traits<wchar_t>,
		STD allocator<wchar_t> > *wp14 = 0; TOUCH(wp14);
	STD wistringstream *wp15 = wp14; TOUCH(wp15);
	STD basic_ostringstream<wchar_t, STD char_traits<wchar_t>,
		STD allocator<wchar_t> > *wp16 = 0; TOUCH(wp16);
	STD wostringstream *wp17 = wp16; TOUCH(wp17);
	STD basic_stringstream<wchar_t, STD char_traits<wchar_t>,
		STD allocator<wchar_t> > *wp18 = 0; TOUCH(wp18);
	STD wstringstream *wp19 = wp18; TOUCH(wp19);

	STD basic_filebuf<wchar_t, STD char_traits<wchar_t> > *wp22 = 0; TOUCH(wp22);
	STD wfilebuf *wp23 = wp22; TOUCH(wp23);
	STD basic_ifstream<wchar_t, STD char_traits<wchar_t> > *wp24 = 0; TOUCH(wp24);
	STD wifstream *wp25 = wp24; TOUCH(wp25);
	STD basic_ofstream<wchar_t, STD char_traits<wchar_t> > *wp26 = 0; TOUCH(wp26);
	STD wofstream *wp27 = wp26; TOUCH(wp27);
	STD basic_fstream<wchar_t, STD char_traits<wchar_t> > *wp28 = 0; TOUCH(wp28);
	STD wfstream *wp29 = wp28; TOUCH(wp29);
	#endif /* IS_EMBEDDED */
	chk(1);




	}
	end_chk("_272T01");
#else
	skip_chk("_272T01");
#endif /* CASE_272T01 */

/* _273T11 <iostream> synopsis */
#if !defined(SKIP_273T11)&&(!defined(ONLY)||defined(CASE_273T11))
	begin_chk("_273T11");
	{
	STD istream *p1 = &STD cin; TOUCH(p1);
	STD ostream *p2 = &STD cout; TOUCH(p2);
	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	STD ostream *p3 = &STD cerr; TOUCH(p3);
	STD ostream *p4 = &STD clog; TOUCH(p4);
	STD wistream *p11 = &STD wcin; TOUCH(p11);
	STD wostream *p12 = &STD wcout; TOUCH(p12);
	STD wostream *p13 = &STD wcerr; TOUCH(p13);
	STD wostream *p14 = &STD wclog; TOUCH(p14);
	#endif /* IS_EMBEDDED */
	chk(1);


	}
	end_chk("_273T11");
#else
	skip_chk("_273T11");
#endif /* CASE_273T11 */

/* _273T32 <iostream> objects constructed by basic_ios::Init */
#if !defined(SKIP_273T32)&&(!defined(ONLY)||defined(CASE_273T32))
	begin_chk("_273T32");
	{
	ieq(cnt_273T32, 1);
	chk(STD cin != 0);	// CHANGED [JUL96]
	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	chk(STD wcin != 0);
	#endif /* IS_EMBEDDED */



	}
	end_chk("_273T32");
#else
	skip_chk("_273T32");
#endif /* CASE_273T32 */

/* _2731T21 cin.tie() returns */
#if !defined(SKIP_2731T21)&&(!defined(ONLY)||defined(CASE_2731T21))
	begin_chk("_2731T21");
	{
	chk(STD cin.tie() == &STD cout);


	}
	end_chk("_2731T21");
#else
	skip_chk("_2731T21");
#endif /* CASE_2731T21 */

/* _2731T51 cerr.flags() has unitbuf set */
#if !defined(SKIP_2731T51)&&(!defined(ONLY)||defined(CASE_2731T51))
	begin_chk("_2731T51");
	{
	#if IS_EMBEDDED
	chk(1);
	#else /* IS_EMBEDDED */
	chk((STD cerr.flags() & STD ios_base::unitbuf) != 0);
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2731T51");
#else
	skip_chk("_2731T51");
#endif /* CASE_2731T51 */

/* _2731T61 clog associated with stderr */
#if !defined(SKIP_2731T61)&&(!defined(ONLY)||defined(CASE_2731T61))
	begin_chk("_2731T61");
	{
	// UNTESTABLE
	chk(1);


	}
	end_chk("_2731T61");
#else
	skip_chk("_2731T61");
#endif /* CASE_2731T61 */

/* _2732T11 wcin associated with stdin */
#if !defined(SKIP_2732T11)&&(!defined(ONLY)||defined(CASE_2732T11))
	begin_chk("_2732T11");
	{
	// UNTESTABLE
	chk(1);



	}
	end_chk("_2732T11");
#else
	skip_chk("_2732T11");
#endif /* CASE_2732T11 */

/* _2732T21 wcin.tie() returns */
#if !defined(SKIP_2732T21)&&(!defined(ONLY)||defined(CASE_2732T21))
	begin_chk("_2732T21");
	{
	chk(STD wcin.tie() == &STD wcout);


	}
	end_chk("_2732T21");
#else
	skip_chk("_2732T21");
#endif /* CASE_2732T21 */

/* _2732T31 wcout associated with stdout */
#if !defined(SKIP_2732T31)&&(!defined(ONLY)||defined(CASE_2732T31))
	begin_chk("_2732T31");
	{
	// UNTESTABLE
	chk(1);


	}
	end_chk("_2732T31");
#else
	skip_chk("_2732T31");
#endif /* CASE_2732T31 */

/* _2732T41 wcerr associated with stderr */
#if !defined(SKIP_2732T41)&&(!defined(ONLY)||defined(CASE_2732T41))
	begin_chk("_2732T41");
	{
	// UNTESTABLE
	chk(1);


	}
	end_chk("_2732T41");
#else
	skip_chk("_2732T41");
#endif /* CASE_2732T41 */

/* _2732T51 wcerr.flags() has unitbuf set */
#if !defined(SKIP_2732T51)&&(!defined(ONLY)||defined(CASE_2732T51))
	begin_chk("_2732T51");
	{
	chk((STD wcerr.flags() & STD ios_base::unitbuf) != 0);


	}
	end_chk("_2732T51");
#else
	skip_chk("_2732T51");
#endif /* CASE_2732T51 */

/* _2732T61 wclog associated with stderr */
#if !defined(SKIP_2732T61)&&(!defined(ONLY)||defined(CASE_2732T61))
	begin_chk("_2732T61");
	{
	// UNTESTABLE
	chk(1);







	}
	end_chk("_2732T61");
#else
	skip_chk("_2732T61");
#endif /* CASE_2732T61 */

/* _274T11 <ios> synopsis */
#if !defined(SKIP_274T11)&&(!defined(ONLY)||defined(CASE_274T11))
	begin_chk("_274T11");
	{
	STD streamoff so; TOUCH(so);	// restored
	//STD wstreamoff *pwso = &so; // deleted [JUL95]
	STD streampos sp;
	STD streamsize ss; TOUCH(ss);
	#if IS_EMBEDDED
	STD ios *p5 = 0; TOUCH(p5);
	#else /* IS_EMBEDDED */
	STD wstreampos *pwsp = &sp; TOUCH(pwsp);
	STD char_traits<char> *p1 = 0; TOUCH(p1);
	STD char_traits<wchar_t> *p2 = 0; TOUCH(p2);
	STD ios_base *p3
		= (STD basic_ios<char, STD char_traits<char> > *)&STD cin; TOUCH(p3);
	STD basic_ios<char, STD char_traits<char> > *p4 = 0; TOUCH(p4);
	STD ios *p5 = p4; TOUCH(p5);
	STD basic_ios<wchar_t, STD char_traits<wchar_t> > *p6 = 0; TOUCH(p6);
	STD wios *p7 = p6; TOUCH(p7);
	#endif /* IS_EMBEDDED */
	typedef STD ios_base& (*Pf)(STD ios_base&);
	Pf parr[] = {
		&STD boolalpha, &STD noboolalpha, &STD showbase, &STD noshowbase,
		&STD showpoint, &STD noshowpoint, &STD showpos, &STD noshowpos,
		&STD skipws, &STD noskipws, &STD uppercase, &STD nouppercase,
		&STD internal, &STD left, &STD right, &STD dec, &STD hex, &STD oct,
		&STD fixed, &STD scientific}; TOUCH(parr);
	chk(1);


	}
	end_chk("_274T11");
#else
	skip_chk("_274T11");
#endif /* CASE_274T11 */

/* _2741T11 streamoff requirements */
#if !defined(SKIP_2741T11)&&(!defined(ONLY)||defined(CASE_2741T11))
	begin_chk("_2741T11");
	{
	STD streamoff so = LONG_MAX;
	chk(so == LONG_MAX);



	// _2741T21 streamsize requirements // deleted [JUL95]
	//FILE-SCOPE:
	//#include <climits>
	//#include <ios>
	//BLOCK-SCOPE:
	//STD wstreamoff wso = LONG_MAX;
	//chk(wso == LONG_MAX);


	}
	end_chk("_2741T11");
#else
	skip_chk("_2741T11");
#endif /* CASE_2741T11 */

/* _2741T31 streampos requirements */
#if !defined(SKIP_2741T31)&&(!defined(ONLY)||defined(CASE_2741T31))
	begin_chk("_2741T31");
	{
	STD streamoff badoff = -1;
	STD streamoff s0 = 0;
	const STD streampos sp0 = s0;
	chk((streamoff)sp0 == s0);
	const STD streampos sp5((streamoff)5);
	chk((streamoff)sp5 == (streamoff)5);
	const STD streampos spx(badoff);
	chk((streamoff)spx == badoff);
	chk(sp5 - sp0 == 5);
	chk(sp0 - sp5 == -5);
	STD streampos sp;
	chk((streamoff)sp == 0);
	sp += LONG_MAX;
	chk((streamoff)sp == LONG_MAX);
	sp -= 30;
	chk((streamoff)sp == LONG_MAX - 30);
	sp = sp5 + (streamoff)10;
	chk((streamoff)sp == 15);
	sp = sp5 - (streamoff)10;
	chk((streamoff)sp == -5);
	chk(sp0 == sp0);
	chk(sp0 != sp5);
	chk(spx == spx);
	chk(spx != sp5);
	sp = sp0 - (streamoff)1;
	chk(sp0 != spx);



	}
	end_chk("_2741T31");
#else
	skip_chk("_2741T31");
#endif /* CASE_2741T31 */

/* _2741T41 wstreampos requirements */
#if !defined(SKIP_2741T41)&&(!defined(ONLY)||defined(CASE_2741T41))
	begin_chk("_2741T41");
	{
	STD streamoff badoff = -1;	// wstreamoff-->streamoff [JUL95]
	STD streamoff s0 = 0;
	const STD wstreampos sp0 = s0;
	chk((streamoff)sp0 == s0);
	const STD wstreampos sp5((streamoff)5);
	chk((streamoff)sp5 == (streamoff)5);
	const STD wstreampos spx(badoff);
	chk((streamoff)spx == badoff);
	chk(sp5 - sp0 == 5);
	chk(sp0 - sp5 == -5);
	STD wstreampos sp;
	chk((streamoff)sp == 0);
	sp += LONG_MAX;
	chk((streamoff)sp == LONG_MAX);
	sp -= 30;
	chk((streamoff)sp == LONG_MAX - 30);
	sp = sp5 + (streamoff)10;
	chk((streamoff)sp == 15);
	sp = sp5 - (streamoff)10;
	chk((streamoff)sp == -5);
	chk(sp0 == sp0);
	chk(sp0 != sp5);
	chk(spx == spx);
	chk(spx != sp5);
	sp = sp0 - (streamoff)1;
	chk(sp0 != spx);


	}
	end_chk("_2741T41");
#else
	skip_chk("_2741T41");
#endif /* CASE_2741T41 */

/* _2741T51 streamsize requirements */
#if !defined(SKIP_2741T51)&&(!defined(ONLY)||defined(CASE_2741T51))
	begin_chk("_2741T51");
	{
	STD streamsize ss = INT_MAX;
	ieq(ss, INT_MAX);







	}
	end_chk("_2741T51");
#else
	skip_chk("_2741T51");
#endif /* CASE_2741T51 */

/* _2742T12 char_traits definition */
#if !defined(SKIP_2742T12)&&(!defined(ONLY)||defined(CASE_2742T12))
	begin_chk("_2742T12");
	{
	typedef STD char_traits<unsigned char> Iost;
	Mycty_2742T12 ufac;
	unsigned char uc;
	Iost::int_type ui = 0;
	Iost::char_type *p1 = &uc; TOUCH(p1);
	Iost::pos_type pos = 0; TOUCH(pos);
	Iost::off_type off = 0; TOUCH(off);
	Iost::state_type state; TOUCH(state);
	streampos fpos;
	//Iost::state_type st = Iost::get_state(pos);	DROPPED [JUL96]
	//pos = Iost::get_pos(fpos, state);

	//uc = Iost::eos();	DROPPED [MAR96]
	//ieq(uc, Iost::eos());	DROPPED [MAR96]

	ui = Iost::eof();
	chk(ui == Iost::eof());
	ui = Iost::not_eof('x');
	chk(ui != Iost::eof());

	//uc = Iost::newline();	DROPPED [MAR96]
	//ieq(uc, Iost::newline());

	ieq(Iost::length((const unsigned char *)"abcd"), 4);

	chk(Iost::eq('x', 'x'));	// CHANGED [MAR96]
	chk(!Iost::eq('x', 'y'));
	chk(Iost::eq_int_type(Iost::to_int_type('x'), Iost::to_int_type('x')));

	//chk(Iost::is_eof(Iost::eof()));	DROPPED [MAR96]

	ieq(Iost::to_char_type(Iost::to_int_type('x')), (unsigned char)'x');

	//chk(Iost::is_whitespace((unsigned char)' ', ufac));	DROPPED [MAR96]

	char a[] = "xxxxx";
	Iost::copy((unsigned char *)a, (const unsigned char *)"abcd", 4);
	ieq(STD memcmp(a, "abcdx", 6), 0);




	}
	end_chk("_2742T12");
#else
	skip_chk("_2742T12");
#endif /* CASE_2742T12 */

/* _2742T21 char_traits instantiations */
#if !defined(SKIP_2742T21)&&(!defined(ONLY)||defined(CASE_2742T21))
	begin_chk("_2742T21");
	{
	STD char_traits<char> it1; TOUCH(it1);
	STD char_traits<wchar_t> it2; TOUCH(it2);
	chk(1);



	}
	end_chk("_2742T21");
#else
	skip_chk("_2742T21");
#endif /* CASE_2742T21 */

/* _27421T12 char_traits::state_type requirements */
#if !defined(SKIP_27421T12)&&(!defined(ONLY)||defined(CASE_27421T12))
	begin_chk("_27421T12");
	{
	static STD char_traits<unsigned char>::state_type st1, st2;
	ieq(STD memcmp(&st1, &st2, sizeof (st1)), 0);


	//### _27422T22 ios_traits::eos returns	DROPPED [MAR96]
	//FILE-SCOPE:
	//#include <ios>
	//BLOCK-SCOPE:
	//ieq(STD ios_traits<char>::eos(), '\0');
	//ieq(STD ios_traits<wchar_t>::eos(), L'\0');


	}
	end_chk("_27421T12");
#else
	skip_chk("_27421T12");
#endif /* CASE_27421T12 */

/* _27422T41 char_traits::eof returns */
#if !defined(SKIP_27422T41)&&(!defined(ONLY)||defined(CASE_27422T41))
	begin_chk("_27422T41");
	{
	ieq(STD char_traits<char>::eof(), EOF);
	ieq(STD char_traits<wchar_t>::eof(), WEOF);




	}
	end_chk("_27422T41");
#else
	skip_chk("_27422T41");
#endif /* CASE_27422T41 */

/* _27422T61 char_traits::not_eof returns */
#if !defined(SKIP_27422T61)&&(!defined(ONLY)||defined(CASE_27422T61))
	begin_chk("_27422T61");
	{
	chk(STD char_traits<char>::not_eof('x') == 'x');
	chk(STD char_traits<char>::not_eof(STD char_traits<char>::eof())
		!= STD char_traits<char>::eof());
	chk(STD char_traits<wchar_t>::not_eof(L'x') == L'x');
	chk(STD char_traits<wchar_t>::not_eof(STD char_traits<wchar_t>::eof())
		!= STD char_traits<wchar_t>::eof());




	//### _27422T_101 ios_traits::newline returns	DROPPED [MAR96]
	//FILE-SCOPE:
	//#include <ios>
	//BLOCK-SCOPE:
	//ieq(STD ios_traits<char>::newline(), '\n');
	//ieq(STD ios_traits<wchar_t>::newline(), L'\n');



	}
	end_chk("_27422T61");
#else
	skip_chk("_27422T61");
#endif /* CASE_27422T61 */

/* _27422T_121 char_traits::length returns */
#if !defined(SKIP_27422T_121)&&(!defined(ONLY)||defined(CASE_27422T_121))
	begin_chk("_27422T_121");
	{
	ieq(STD char_traits<char>::length("abcd"), 4);
	ieq(STD char_traits<char>::length(""), 0);
	wchar_t abcd[] = {L'a', L'b', L'c', L'd', 0};
	ieq(STD char_traits<wchar_t>::length(abcd), 4);
	ieq(STD char_traits<wchar_t>::length(abcd + 4), 0);


	}
	end_chk("_27422T_121");
#else
	skip_chk("_27422T_121");
#endif /* CASE_27422T_121 */

/* _27423T21 char_traits::eq returns	CHANGED [MAR96] */
#if !defined(SKIP_27423T21)&&(!defined(ONLY)||defined(CASE_27423T21))
	begin_chk("_27423T21");
	{
	chk(STD char_traits<char>::eq('a', 'a'));
	chk(!STD char_traits<char>::eq('a', 'b'));
	chk(STD char_traits<wchar_t>::eq(L'a', L'a'));
	chk(!STD char_traits<wchar_t>::eq(L'a', L'b'));


	}
	end_chk("_27423T21");
#else
	skip_chk("_27423T21");
#endif /* CASE_27423T21 */

/* _27423T41 char_traits::eq_int_type returns */
#if !defined(SKIP_27423T41)&&(!defined(ONLY)||defined(CASE_27423T41))
	begin_chk("_27423T41");
	{
	chk(STD char_traits<char>::eq_int_type((int)'a', (int)'a'));
	chk(!STD char_traits<char>::eq_int_type((int)'a', (int)'b'));
	chk(STD char_traits<wchar_t>::eq_int_type((wint_t)L'a', (wint_t)L'a'));
	chk(!STD char_traits<wchar_t>::eq_int_type((wint_t)L'a', (wint_t)L'b'));


	//### _27423T61 ios_traits::is_eof returns	DROPPED [MAR96]
	//FILE-SCOPE:
	//#include <ios>
	//BLOCK-SCOPE:
	//chk(STD ios_traits<char>::is_eof(STD ios_traits<char>::eof()));
	//chk(!STD ios_traits<char>::is_eof(STD ios_traits<char>::eos()));
	//chk(!STD ios_traits<char>::is_eof('a'));
	//chk(STD ios_traits<wchar_t>::is_eof(STD ios_traits<wchar_t>::eof()));
	//chk(!STD ios_traits<wchar_t>::is_eof(STD ios_traits<wchar_t>::eos()));
	//chk(!STD ios_traits<wchar_t>::is_eof(L'a'));





	//### _27423T82 ios_traits::is_whitespace returns	DROPPED [MAR96]
	//FILE-SCOPE:
	//#include <ios>
	//#include <locale>
	//class Myctyc_27423T41 : public ctype<char> {
	//	};
	//class Myctyw_27423T41 : public ctype<wchar_t> {
	//	};
	//BLOCK-SCOPE:
	//Myctyc_27423T41 cfac;
	//Myctyw_27423T41 wfac;
	//chk(STD ios_traits<char>::is_whitespace(' ', cfac));
	//chk(!STD ios_traits<char>::is_whitespace('x', cfac));
	//chk(STD ios_traits<wchar_t>::is_whitespace(L' ', wfac));
	//chk(!STD ios_traits<wchar_t>::is_whitespace(L'x', wfac));





	}
	end_chk("_27423T41");
#else
	skip_chk("_27423T41");
#endif /* CASE_27423T41 */

/* _27424T21 char_traits::to_char_type returns */
#if !defined(SKIP_27424T21)&&(!defined(ONLY)||defined(CASE_27424T21))
	begin_chk("_27424T21");
	{
	ieq(STD char_traits<char>::to_char_type((int)'x'), 'x');
	ieq(STD char_traits<wchar_t>::to_char_type((wint_t)L'x'), L'x');



	}
	end_chk("_27424T21");
#else
	skip_chk("_27424T21");
#endif /* CASE_27424T21 */

/* _27424T41 char_traits::to_int_type returns */
#if !defined(SKIP_27424T41)&&(!defined(ONLY)||defined(CASE_27424T41))
	begin_chk("_27424T41");
	{
	ieq(STD char_traits<char>::to_int_type('x'), (int)'x');
	ieq(STD char_traits<wchar_t>::to_int_type(L'x'), (wint_t)L'x');



	}
	end_chk("_27424T41");
#else
	skip_chk("_27424T41");
#endif /* CASE_27424T41 */

/* _27424T61 char_traits::copy returns */
#if !defined(SKIP_27424T61)&&(!defined(ONLY)||defined(CASE_27424T61))
	begin_chk("_27424T61");
	{
	char a[] = "xxxxx";
	char *pa = STD char_traits<char>::copy(a, "", 0);
	chk(pa == a);
	ieq(STD memcmp(a, "xxxxx", 6), 0);
	pa = STD char_traits<char>::copy(a, "abcd", 4);
	chk(pa == a);
	ieq(STD memcmp(a, "abcdx", 6), 0);
	wchar_t wa[6];
	const wchar_t xxxxx[] = {L'x', L'x', L'x', L'x', L'x', 0};
	const wchar_t abcd[] = {L'a', L'b', L'c', L'd', 0};
	wmemcpy(wa, xxxxx, 6);
	wchar_t *pwa = STD char_traits<wchar_t>::copy(wa, abcd, 0);
	chk(pwa == wa);
	ieq(STD wmemcmp(wa, xxxxx, 6), 0);
	pwa = STD char_traits<wchar_t>::copy(wa, abcd, 4);
	chk(pwa == wa);
	ieq(STD wmemcmp(wa, abcd, 4), 0);
	ieq(STD wmemcmp(wa + 4, xxxxx + 4, 2), 0);



	//### _27424T81 char_traits::get_state returns	DROPPED [JUL96]
	//FILE-SCOPE:
	//#include <ios>
	//BLOCK-SCOPE:
	//STD char_traits<char>::pos_type pos = 0;
	//STD char_traits<char>::state_type st =
	//	STD char_traits<char>::get_state(pos);
	//STD char_traits<wchar_t>::pos_type wpos = 0;
	//STD char_traits<wchar_t>::state_type wst =
	//	STD char_traits<wchar_t>::get_state(wpos);
	//chk(1);



	//### _27424T_101 char_traits::get_pos returns	DROPPED [JUL96]
	//FILE-SCOPE:
	//#include <ios>
	//BLOCK-SCOPE:
	//STD streampos fpos;
	//STD char_traits<char>::state_type state;
	//STD char_traits<char>::pos_type pt =
	//	STD char_traits<char>::get_pos(fpos, state);
	//STD char_traits<wchar_t>::state_type wstate;
	//STD char_traits<wchar_t>::pos_type wpt =
	//	STD char_traits<wchar_t>::get_pos(fpos, wstate);
	//chk(1);

	}
	end_chk("_27424T61");
#else
	skip_chk("_27424T61");
#endif /* CASE_27424T61 */

return leave_chk("t270");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t273.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"

#if IS_EMBEDDED
#define ONLY
#define CASE_27451T21	boolalpha effects
#define CASE_27451T31	boolalpha returns
#define CASE_27451T41	noboolalpha effects
#define CASE_27451T51	noboolalpha returns
#define CASE_27451T71	showbase effects
#define CASE_27451T71a	unitbuf effects ADDED [MAR96]
#define CASE_27451T81	showbase returns
#define CASE_27451T81a	unitbuf returns	ADDED [MAR96]
#define CASE_27451T_111	noshowbase effects
#define CASE_27451T_111a	nounitbuf effects	ADDED [MAR96]
#define CASE_27451T_121	noshowbase returns
#define CASE_27451T_121a	nounitbuf returns	ADDED [MAR96]
#define CASE_27451T_141	showpoint effects
#define CASE_27451T_151	showpoint returns
#define CASE_27451T_171	noshowpoint effects
#define CASE_27451T_181	noshowpoint returns
#define CASE_27451T_191	showpos effects
#define CASE_27451T_201	showpos returns
#define CASE_27451T_221	noshowpos effects
#define CASE_27451T_231	noshowpos returns
#define CASE_27451T_251	skipws effects
#define CASE_27451T_261	skipws returns
#define CASE_27451T_281	noskipws effects
#define CASE_27451T_291	noskipws returns
#define CASE_27451T_301	uppercase effects
#define CASE_27451T_311	uppercase returns
#define CASE_27451T_331	nouppercase effects
#define CASE_27451T_341	nouppercase returns
#define CASE_27452T21	internal effects
#define CASE_27452T31	internal returns
#define CASE_27452T41	left effects
#define CASE_27452T51	left returns
#define CASE_27452T61	right effects
#define CASE_27452T71	right returns
#define CASE_27453T21	dec effects
#define CASE_27453T31	dec returns
#define CASE_27453T51	hex effects
#define CASE_27453T61	hex returns
#define CASE_27453T81	oct effects
#define CASE_27453T91	oct returns
#define CASE_27454T21	fixed effects
#define CASE_27454T31	fixed returns
#define CASE_27454T51	scientific effects
#define CASE_27454T61	scientific returns
#define CASE_275T11	<streambuf> synopsis
#define CASE_2752T11	basic_streambuf definition
//#define CASE_2752T21	streambuf definition
//#define CASE_2752T31	wstreambuf definition
#endif /* IS_EMBEDDED */

/* _27451T21 boolalpha effects */
#if !defined(SKIP_27451T21)&&(!defined(ONLY)||defined(CASE_27451T21))
#include <ios>
#endif /* CASE_27451T21 */

/* _27451T31 boolalpha returns */
#if !defined(SKIP_27451T31)&&(!defined(ONLY)||defined(CASE_27451T31))
#include <ios>
#endif /* CASE_27451T31 */

/* _27451T41 noboolalpha effects */
#if !defined(SKIP_27451T41)&&(!defined(ONLY)||defined(CASE_27451T41))
#include <ios>
#endif /* CASE_27451T41 */

/* _27451T51 noboolalpha returns */
#if !defined(SKIP_27451T51)&&(!defined(ONLY)||defined(CASE_27451T51))
#include <ios>
#endif /* CASE_27451T51 */

/* _27451T71 showbase effects */
#if !defined(SKIP_27451T71)&&(!defined(ONLY)||defined(CASE_27451T71))
#include <ios>
#endif /* CASE_27451T71 */

/* _27451T71a unitbuf effects ADDED [MAR96] */
#if !defined(SKIP_27451T71a)&&(!defined(ONLY)||defined(CASE_27451T71a))
#include <ios>
#endif /* CASE_27451T71a */

/* _27451T81 showbase returns */
#if !defined(SKIP_27451T81)&&(!defined(ONLY)||defined(CASE_27451T81))
#include <ios>
#endif /* CASE_27451T81 */

/* _27451T81a unitbuf returns	ADDED [MAR96] */
#if !defined(SKIP_27451T81a)&&(!defined(ONLY)||defined(CASE_27451T81a))
#include <ios>
#endif /* CASE_27451T81a */

/* _27451T_111 noshowbase effects */
#if !defined(SKIP_27451T_111)&&(!defined(ONLY)||defined(CASE_27451T_111))
#include <ios>
#endif /* CASE_27451T_111 */

/* _27451T_111a nounitbuf effects	ADDED [MAR96] */
#if !defined(SKIP_27451T_111a)&&(!defined(ONLY)||defined(CASE_27451T_111a))
#include <ios>
#endif /* CASE_27451T_111a */

/* _27451T_121 noshowbase returns */
#if !defined(SKIP_27451T_121)&&(!defined(ONLY)||defined(CASE_27451T_121))
#include <ios>
#endif /* CASE_27451T_121 */

/* _27451T_121a nounitbuf returns	ADDED [MAR96] */
#if !defined(SKIP_27451T_121a)&&(!defined(ONLY)||defined(CASE_27451T_121a))
#include <ios>
#endif /* CASE_27451T_121a */

/* _27451T_141 showpoint effects */
#if !defined(SKIP_27451T_141)&&(!defined(ONLY)||defined(CASE_27451T_141))
#include <ios>
#endif /* CASE_27451T_141 */

/* _27451T_151 showpoint returns */
#if !defined(SKIP_27451T_151)&&(!defined(ONLY)||defined(CASE_27451T_151))
#include <ios>
#endif /* CASE_27451T_151 */

/* _27451T_171 noshowpoint effects */
#if !defined(SKIP_27451T_171)&&(!defined(ONLY)||defined(CASE_27451T_171))
#include <ios>
#endif /* CASE_27451T_171 */

/* _27451T_181 noshowpoint returns */
#if !defined(SKIP_27451T_181)&&(!defined(ONLY)||defined(CASE_27451T_181))
#include <ios>
#endif /* CASE_27451T_181 */

/* _27451T_191 showpos effects */
#if !defined(SKIP_27451T_191)&&(!defined(ONLY)||defined(CASE_27451T_191))
#include <ios>
#endif /* CASE_27451T_191 */

/* _27451T_201 showpos returns */
#if !defined(SKIP_27451T_201)&&(!defined(ONLY)||defined(CASE_27451T_201))
#include <ios>
#endif /* CASE_27451T_201 */

/* _27451T_221 noshowpos effects */
#if !defined(SKIP_27451T_221)&&(!defined(ONLY)||defined(CASE_27451T_221))
#include <ios>
#endif /* CASE_27451T_221 */

/* _27451T_231 noshowpos returns */
#if !defined(SKIP_27451T_231)&&(!defined(ONLY)||defined(CASE_27451T_231))
#include <ios>
#endif /* CASE_27451T_231 */

/* _27451T_251 skipws effects */
#if !defined(SKIP_27451T_251)&&(!defined(ONLY)||defined(CASE_27451T_251))
#include <ios>
#endif /* CASE_27451T_251 */

/* _27451T_261 skipws returns */
#if !defined(SKIP_27451T_261)&&(!defined(ONLY)||defined(CASE_27451T_261))
#include <ios>
#endif /* CASE_27451T_261 */

/* _27451T_281 noskipws effects */
#if !defined(SKIP_27451T_281)&&(!defined(ONLY)||defined(CASE_27451T_281))
#include <ios>
#endif /* CASE_27451T_281 */

/* _27451T_291 noskipws returns */
#if !defined(SKIP_27451T_291)&&(!defined(ONLY)||defined(CASE_27451T_291))
#include <ios>
#endif /* CASE_27451T_291 */

/* _27451T_301 uppercase effects */
#if !defined(SKIP_27451T_301)&&(!defined(ONLY)||defined(CASE_27451T_301))
#include <ios>
#endif /* CASE_27451T_301 */

/* _27451T_311 uppercase returns */
#if !defined(SKIP_27451T_311)&&(!defined(ONLY)||defined(CASE_27451T_311))
#include <ios>
#endif /* CASE_27451T_311 */

/* _27451T_331 nouppercase effects */
#if !defined(SKIP_27451T_331)&&(!defined(ONLY)||defined(CASE_27451T_331))
#include <ios>
#endif /* CASE_27451T_331 */

/* _27451T_341 nouppercase returns */
#if !defined(SKIP_27451T_341)&&(!defined(ONLY)||defined(CASE_27451T_341))
#include <ios>
#endif /* CASE_27451T_341 */

/* _27452T21 internal effects */
#if !defined(SKIP_27452T21)&&(!defined(ONLY)||defined(CASE_27452T21))
#include <ios>
#endif /* CASE_27452T21 */

/* _27452T31 internal returns */
#if !defined(SKIP_27452T31)&&(!defined(ONLY)||defined(CASE_27452T31))
#include <ios>
#endif /* CASE_27452T31 */

/* _27452T41 left effects */
#if !defined(SKIP_27452T41)&&(!defined(ONLY)||defined(CASE_27452T41))
#include <ios>
#endif /* CASE_27452T41 */

/* _27452T51 left returns */
#if !defined(SKIP_27452T51)&&(!defined(ONLY)||defined(CASE_27452T51))
#include <ios>
#endif /* CASE_27452T51 */

/* _27452T61 right effects */
#if !defined(SKIP_27452T61)&&(!defined(ONLY)||defined(CASE_27452T61))
#include <ios>
#endif /* CASE_27452T61 */

/* _27452T71 right returns */
#if !defined(SKIP_27452T71)&&(!defined(ONLY)||defined(CASE_27452T71))
#include <ios>
#endif /* CASE_27452T71 */

/* _27453T21 dec effects */
#if !defined(SKIP_27453T21)&&(!defined(ONLY)||defined(CASE_27453T21))
#include <ios>
#endif /* CASE_27453T21 */

/* _27453T31 dec returns */
#if !defined(SKIP_27453T31)&&(!defined(ONLY)||defined(CASE_27453T31))
#include <ios>
#endif /* CASE_27453T31 */

/* _27453T51 hex effects */
#if !defined(SKIP_27453T51)&&(!defined(ONLY)||defined(CASE_27453T51))
#include <ios>
#endif /* CASE_27453T51 */

/* _27453T61 hex returns */
#if !defined(SKIP_27453T61)&&(!defined(ONLY)||defined(CASE_27453T61))
#include <ios>
#endif /* CASE_27453T61 */

/* _27453T81 oct effects */
#if !defined(SKIP_27453T81)&&(!defined(ONLY)||defined(CASE_27453T81))
#include <ios>
#endif /* CASE_27453T81 */

/* _27453T91 oct returns */
#if !defined(SKIP_27453T91)&&(!defined(ONLY)||defined(CASE_27453T91))
#include <ios>
#endif /* CASE_27453T91 */

/* _27454T21 fixed effects */
#if !defined(SKIP_27454T21)&&(!defined(ONLY)||defined(CASE_27454T21))
#include <ios>
#endif /* CASE_27454T21 */

/* _27454T31 fixed returns */
#if !defined(SKIP_27454T31)&&(!defined(ONLY)||defined(CASE_27454T31))
#include <ios>
#endif /* CASE_27454T31 */

/* _27454T51 scientific effects */
#if !defined(SKIP_27454T51)&&(!defined(ONLY)||defined(CASE_27454T51))
#include <ios>
#endif /* CASE_27454T51 */

/* _27454T61 scientific returns */
#if !defined(SKIP_27454T61)&&(!defined(ONLY)||defined(CASE_27454T61))
#include <ios>
#endif /* CASE_27454T61 */

/* _275T11 <streambuf> synopsis */
#if !defined(SKIP_275T11)&&(!defined(ONLY)||defined(CASE_275T11))
#include <streambuf>
#endif /* CASE_275T11 */

/* _2752T11 basic_streambuf definition */
#if !defined(SKIP_2752T11)&&(!defined(ONLY)||defined(CASE_2752T11))
#include <cstring>
#include <sstream>
#include <streambuf>
#endif /* CASE_2752T11 */

/* _2752T21 streambuf definition */
#if !defined(SKIP_2752T21)&&(!defined(ONLY)||defined(CASE_2752T21))
#include <streambuf>
#endif /* CASE_2752T21 */

/* _2752T31 wstreambuf definition */
#if !defined(SKIP_2752T31)&&(!defined(ONLY)||defined(CASE_2752T31))
#include <streambuf>
#endif /* CASE_2752T31 */

int t273_main(int, char *[])
{
enter_chk("t273.cpp");
/* _27451T21 boolalpha effects */
#if !defined(SKIP_27451T21)&&(!defined(ONLY)||defined(CASE_27451T21))
	begin_chk("_27451T21");
	{
	Bi x(0);
	x.flags(Bi::scientific);
	boolalpha(x);
	chk(x.flags() == (Bi::boolalpha | Bi::scientific));


	}
	end_chk("_27451T21");
#else
	skip_chk("_27451T21");
#endif /* CASE_27451T21 */

/* _27451T31 boolalpha returns */
#if !defined(SKIP_27451T31)&&(!defined(ONLY)||defined(CASE_27451T31))
	begin_chk("_27451T31");
	{
	Bi x(0);
	chk(&boolalpha(x) == &x);


	}
	end_chk("_27451T31");
#else
	skip_chk("_27451T31");
#endif /* CASE_27451T31 */

/* _27451T41 noboolalpha effects */
#if !defined(SKIP_27451T41)&&(!defined(ONLY)||defined(CASE_27451T41))
	begin_chk("_27451T41");
	{
	Bi x(0);
	x.flags(Bi::boolalpha | Bi::scientific);
	noboolalpha(x);
	chk(x.flags() == Bi::scientific);


	}
	end_chk("_27451T41");
#else
	skip_chk("_27451T41");
#endif /* CASE_27451T41 */

/* _27451T51 noboolalpha returns */
#if !defined(SKIP_27451T51)&&(!defined(ONLY)||defined(CASE_27451T51))
	begin_chk("_27451T51");
	{
	Bi x(0);
	chk(&noboolalpha(x) == &x);


	}
	end_chk("_27451T51");
#else
	skip_chk("_27451T51");
#endif /* CASE_27451T51 */

/* _27451T71 showbase effects */
#if !defined(SKIP_27451T71)&&(!defined(ONLY)||defined(CASE_27451T71))
	begin_chk("_27451T71");
	{
	Bi x(0);
	x.flags(Bi::scientific);
	showbase(x);
	chk(x.flags() == (Bi::showbase | Bi::scientific));

	}
	end_chk("_27451T71");
#else
	skip_chk("_27451T71");
#endif /* CASE_27451T71 */

/* _27451T71a unitbuf effects ADDED [MAR96] */
#if !defined(SKIP_27451T71a)&&(!defined(ONLY)||defined(CASE_27451T71a))
	begin_chk("_27451T71a");
	{
	Bi x(0);
	x.flags(Bi::scientific);
	unitbuf(x);
	chk(x.flags() == (Bi::unitbuf | Bi::scientific));


	}
	end_chk("_27451T71a");
#else
	skip_chk("_27451T71a");
#endif /* CASE_27451T71a */

/* _27451T81 showbase returns */
#if !defined(SKIP_27451T81)&&(!defined(ONLY)||defined(CASE_27451T81))
	begin_chk("_27451T81");
	{
	Bi x(0);
	chk(&showbase(x) == &x);

	}
	end_chk("_27451T81");
#else
	skip_chk("_27451T81");
#endif /* CASE_27451T81 */

/* _27451T81a unitbuf returns	ADDED [MAR96] */
#if !defined(SKIP_27451T81a)&&(!defined(ONLY)||defined(CASE_27451T81a))
	begin_chk("_27451T81a");
	{
	Bi x(0);
	chk(&unitbuf(x) == &x);


	}
	end_chk("_27451T81a");
#else
	skip_chk("_27451T81a");
#endif /* CASE_27451T81a */

/* _27451T_111 noshowbase effects */
#if !defined(SKIP_27451T_111)&&(!defined(ONLY)||defined(CASE_27451T_111))
	begin_chk("_27451T_111");
	{
	Bi x(0);
	x.flags(Bi::showbase | Bi::scientific);
	noshowbase(x);
	chk(x.flags() == Bi::scientific);

	}
	end_chk("_27451T_111");
#else
	skip_chk("_27451T_111");
#endif /* CASE_27451T_111 */

/* _27451T_111a nounitbuf effects	ADDED [MAR96] */
#if !defined(SKIP_27451T_111a)&&(!defined(ONLY)||defined(CASE_27451T_111a))
	begin_chk("_27451T_111a");
	{
	Bi x(0);
	x.flags(Bi::unitbuf | Bi::scientific);
	nounitbuf(x);
	chk(x.flags() == Bi::scientific);


	}
	end_chk("_27451T_111a");
#else
	skip_chk("_27451T_111a");
#endif /* CASE_27451T_111a */

/* _27451T_121 noshowbase returns */
#if !defined(SKIP_27451T_121)&&(!defined(ONLY)||defined(CASE_27451T_121))
	begin_chk("_27451T_121");
	{
	Bi x(0);
	chk(&noshowbase(x) == &x);

	}
	end_chk("_27451T_121");
#else
	skip_chk("_27451T_121");
#endif /* CASE_27451T_121 */

/* _27451T_121a nounitbuf returns	ADDED [MAR96] */
#if !defined(SKIP_27451T_121a)&&(!defined(ONLY)||defined(CASE_27451T_121a))
	begin_chk("_27451T_121a");
	{
	Bi x(0);
	chk(&nounitbuf(x) == &x);


	}
	end_chk("_27451T_121a");
#else
	skip_chk("_27451T_121a");
#endif /* CASE_27451T_121a */

/* _27451T_141 showpoint effects */
#if !defined(SKIP_27451T_141)&&(!defined(ONLY)||defined(CASE_27451T_141))
	begin_chk("_27451T_141");
	{
	Bi x(0);
	x.flags(Bi::scientific);
	showpoint(x);
	chk(x.flags() == (Bi::showpoint | Bi::scientific));


	}
	end_chk("_27451T_141");
#else
	skip_chk("_27451T_141");
#endif /* CASE_27451T_141 */

/* _27451T_151 showpoint returns */
#if !defined(SKIP_27451T_151)&&(!defined(ONLY)||defined(CASE_27451T_151))
	begin_chk("_27451T_151");
	{
	Bi x(0);
	chk(&showpoint(x) == &x);


	}
	end_chk("_27451T_151");
#else
	skip_chk("_27451T_151");
#endif /* CASE_27451T_151 */

/* _27451T_171 noshowpoint effects */
#if !defined(SKIP_27451T_171)&&(!defined(ONLY)||defined(CASE_27451T_171))
	begin_chk("_27451T_171");
	{
	Bi x(0);
	x.flags(Bi::showpoint | Bi::scientific);
	noshowpoint(x);
	chk(x.flags() == Bi::scientific);


	}
	end_chk("_27451T_171");
#else
	skip_chk("_27451T_171");
#endif /* CASE_27451T_171 */

/* _27451T_181 noshowpoint returns */
#if !defined(SKIP_27451T_181)&&(!defined(ONLY)||defined(CASE_27451T_181))
	begin_chk("_27451T_181");
	{
	Bi x(0);
	chk(&noshowpoint(x) == &x);


	}
	end_chk("_27451T_181");
#else
	skip_chk("_27451T_181");
#endif /* CASE_27451T_181 */

/* _27451T_191 showpos effects */
#if !defined(SKIP_27451T_191)&&(!defined(ONLY)||defined(CASE_27451T_191))
	begin_chk("_27451T_191");
	{
	Bi x(0);
	x.flags(Bi::scientific);
	showpos(x);
	chk(x.flags() == (Bi::showpos | Bi::scientific));


	}
	end_chk("_27451T_191");
#else
	skip_chk("_27451T_191");
#endif /* CASE_27451T_191 */

/* _27451T_201 showpos returns */
#if !defined(SKIP_27451T_201)&&(!defined(ONLY)||defined(CASE_27451T_201))
	begin_chk("_27451T_201");
	{
	Bi x(0);
	chk(&showpos(x) == &x);


	}
	end_chk("_27451T_201");
#else
	skip_chk("_27451T_201");
#endif /* CASE_27451T_201 */

/* _27451T_221 noshowpos effects */
#if !defined(SKIP_27451T_221)&&(!defined(ONLY)||defined(CASE_27451T_221))
	begin_chk("_27451T_221");
	{
	Bi x(0);
	x.flags(Bi::showpos | Bi::scientific);
	noshowpos(x);
	chk(x.flags() == Bi::scientific);


	}
	end_chk("_27451T_221");
#else
	skip_chk("_27451T_221");
#endif /* CASE_27451T_221 */

/* _27451T_231 noshowpos returns */
#if !defined(SKIP_27451T_231)&&(!defined(ONLY)||defined(CASE_27451T_231))
	begin_chk("_27451T_231");
	{
	Bi x(0);
	chk(&noshowpos(x) == &x);


	}
	end_chk("_27451T_231");
#else
	skip_chk("_27451T_231");
#endif /* CASE_27451T_231 */

/* _27451T_251 skipws effects */
#if !defined(SKIP_27451T_251)&&(!defined(ONLY)||defined(CASE_27451T_251))
	begin_chk("_27451T_251");
	{
	Bi x(0);
	x.flags(Bi::scientific);
	skipws(x);
	chk(x.flags() == (Bi::skipws | Bi::scientific));


	}
	end_chk("_27451T_251");
#else
	skip_chk("_27451T_251");
#endif /* CASE_27451T_251 */

/* _27451T_261 skipws returns */
#if !defined(SKIP_27451T_261)&&(!defined(ONLY)||defined(CASE_27451T_261))
	begin_chk("_27451T_261");
	{
	Bi x(0);
	chk(&skipws(x) == &x);


	}
	end_chk("_27451T_261");
#else
	skip_chk("_27451T_261");
#endif /* CASE_27451T_261 */

/* _27451T_281 noskipws effects */
#if !defined(SKIP_27451T_281)&&(!defined(ONLY)||defined(CASE_27451T_281))
	begin_chk("_27451T_281");
	{
	Bi x(0);
	x.flags(Bi::skipws | Bi::scientific);
	noskipws(x);
	chk(x.flags() == Bi::scientific);


	}
	end_chk("_27451T_281");
#else
	skip_chk("_27451T_281");
#endif /* CASE_27451T_281 */

/* _27451T_291 noskipws returns */
#if !defined(SKIP_27451T_291)&&(!defined(ONLY)||defined(CASE_27451T_291))
	begin_chk("_27451T_291");
	{
	Bi x(0);
	chk(&noskipws(x) == &x);


	}
	end_chk("_27451T_291");
#else
	skip_chk("_27451T_291");
#endif /* CASE_27451T_291 */

/* _27451T_301 uppercase effects */
#if !defined(SKIP_27451T_301)&&(!defined(ONLY)||defined(CASE_27451T_301))
	begin_chk("_27451T_301");
	{
	Bi x(0);
	x.flags(Bi::scientific);
	uppercase(x);
	chk(x.flags() == (Bi::uppercase | Bi::scientific));


	}
	end_chk("_27451T_301");
#else
	skip_chk("_27451T_301");
#endif /* CASE_27451T_301 */

/* _27451T_311 uppercase returns */
#if !defined(SKIP_27451T_311)&&(!defined(ONLY)||defined(CASE_27451T_311))
	begin_chk("_27451T_311");
	{
	Bi x(0);
	chk(&uppercase(x) == &x);


	}
	end_chk("_27451T_311");
#else
	skip_chk("_27451T_311");
#endif /* CASE_27451T_311 */

/* _27451T_331 nouppercase effects */
#if !defined(SKIP_27451T_331)&&(!defined(ONLY)||defined(CASE_27451T_331))
	begin_chk("_27451T_331");
	{
	Bi x(0);
	x.flags(Bi::uppercase | Bi::scientific);
	nouppercase(x);
	chk(x.flags() == Bi::scientific);


	}
	end_chk("_27451T_331");
#else
	skip_chk("_27451T_331");
#endif /* CASE_27451T_331 */

/* _27451T_341 nouppercase returns */
#if !defined(SKIP_27451T_341)&&(!defined(ONLY)||defined(CASE_27451T_341))
	begin_chk("_27451T_341");
	{
	Bi x(0);
	chk(&nouppercase(x) == &x);


	}
	end_chk("_27451T_341");
#else
	skip_chk("_27451T_341");
#endif /* CASE_27451T_341 */

/* _27452T21 internal effects */
#if !defined(SKIP_27452T21)&&(!defined(ONLY)||defined(CASE_27452T21))
	begin_chk("_27452T21");
	{
	Bi x(0);
	x.flags(Bi::adjustfield | Bi::skipws);
	internal(x);
	chk(x.flags() == (Bi::internal | Bi::skipws));


	}
	end_chk("_27452T21");
#else
	skip_chk("_27452T21");
#endif /* CASE_27452T21 */

/* _27452T31 internal returns */
#if !defined(SKIP_27452T31)&&(!defined(ONLY)||defined(CASE_27452T31))
	begin_chk("_27452T31");
	{
	Bi x(0);
	chk(&internal(x) == &x);


	}
	end_chk("_27452T31");
#else
	skip_chk("_27452T31");
#endif /* CASE_27452T31 */

/* _27452T41 left effects */
#if !defined(SKIP_27452T41)&&(!defined(ONLY)||defined(CASE_27452T41))
	begin_chk("_27452T41");
	{
	Bi x(0);
	x.flags(Bi::adjustfield | Bi::skipws);
	left(x);
	chk(x.flags() == (Bi::left | Bi::skipws));


	}
	end_chk("_27452T41");
#else
	skip_chk("_27452T41");
#endif /* CASE_27452T41 */

/* _27452T51 left returns */
#if !defined(SKIP_27452T51)&&(!defined(ONLY)||defined(CASE_27452T51))
	begin_chk("_27452T51");
	{
	Bi x(0);
	chk(&left(x) == &x);


	}
	end_chk("_27452T51");
#else
	skip_chk("_27452T51");
#endif /* CASE_27452T51 */

/* _27452T61 right effects */
#if !defined(SKIP_27452T61)&&(!defined(ONLY)||defined(CASE_27452T61))
	begin_chk("_27452T61");
	{
	Bi x(0);
	x.flags(Bi::adjustfield | Bi::skipws);
	right(x);
	chk(x.flags() == (Bi::right | Bi::skipws));


	}
	end_chk("_27452T61");
#else
	skip_chk("_27452T61");
#endif /* CASE_27452T61 */

/* _27452T71 right returns */
#if !defined(SKIP_27452T71)&&(!defined(ONLY)||defined(CASE_27452T71))
	begin_chk("_27452T71");
	{
	Bi x(0);
	chk(&right(x) == &x);


	}
	end_chk("_27452T71");
#else
	skip_chk("_27452T71");
#endif /* CASE_27452T71 */

/* _27453T21 dec effects */
#if !defined(SKIP_27453T21)&&(!defined(ONLY)||defined(CASE_27453T21))
	begin_chk("_27453T21");
	{
	Bi x(0);
	x.flags(Bi::basefield | Bi::skipws);
	dec(x);
	chk(x.flags() == (Bi::dec | Bi::skipws));


	}
	end_chk("_27453T21");
#else
	skip_chk("_27453T21");
#endif /* CASE_27453T21 */

/* _27453T31 dec returns */
#if !defined(SKIP_27453T31)&&(!defined(ONLY)||defined(CASE_27453T31))
	begin_chk("_27453T31");
	{
	Bi x(0);
	chk(&dec(x) == &x);


	}
	end_chk("_27453T31");
#else
	skip_chk("_27453T31");
#endif /* CASE_27453T31 */

/* _27453T51 hex effects */
#if !defined(SKIP_27453T51)&&(!defined(ONLY)||defined(CASE_27453T51))
	begin_chk("_27453T51");
	{
	Bi x(0);
	x.flags(Bi::basefield | Bi::skipws);
	hex(x);
	chk(x.flags() == (Bi::hex | Bi::skipws));


	}
	end_chk("_27453T51");
#else
	skip_chk("_27453T51");
#endif /* CASE_27453T51 */

/* _27453T61 hex returns */
#if !defined(SKIP_27453T61)&&(!defined(ONLY)||defined(CASE_27453T61))
	begin_chk("_27453T61");
	{
	Bi x(0);
	chk(&hex(x) == &x);


	}
	end_chk("_27453T61");
#else
	skip_chk("_27453T61");
#endif /* CASE_27453T61 */

/* _27453T81 oct effects */
#if !defined(SKIP_27453T81)&&(!defined(ONLY)||defined(CASE_27453T81))
	begin_chk("_27453T81");
	{
	Bi x(0);
	x.flags(Bi::basefield | Bi::skipws);
	oct(x);
	chk(x.flags() == (Bi::oct | Bi::skipws));


	}
	end_chk("_27453T81");
#else
	skip_chk("_27453T81");
#endif /* CASE_27453T81 */

/* _27453T91 oct returns */
#if !defined(SKIP_27453T91)&&(!defined(ONLY)||defined(CASE_27453T91))
	begin_chk("_27453T91");
	{
	Bi x(0);
	chk(&oct(x) == &x);


	}
	end_chk("_27453T91");
#else
	skip_chk("_27453T91");
#endif /* CASE_27453T91 */

/* _27454T21 fixed effects */
#if !defined(SKIP_27454T21)&&(!defined(ONLY)||defined(CASE_27454T21))
	begin_chk("_27454T21");
	{
	Bi x(0);
	x.flags(Bi::floatfield | Bi::skipws);
	fixed(x);
	chk(x.flags() == (Bi::fixed | Bi::skipws));


	}
	end_chk("_27454T21");
#else
	skip_chk("_27454T21");
#endif /* CASE_27454T21 */

/* _27454T31 fixed returns */
#if !defined(SKIP_27454T31)&&(!defined(ONLY)||defined(CASE_27454T31))
	begin_chk("_27454T31");
	{
	Bi x(0);
	chk(&fixed(x) == &x);


	}
	end_chk("_27454T31");
#else
	skip_chk("_27454T31");
#endif /* CASE_27454T31 */

/* _27454T51 scientific effects */
#if !defined(SKIP_27454T51)&&(!defined(ONLY)||defined(CASE_27454T51))
	begin_chk("_27454T51");
	{
	Bi x(0);
	x.flags(Bi::floatfield | Bi::skipws);
	scientific(x);
	chk(x.flags() == (Bi::scientific | Bi::skipws));


	}
	end_chk("_27454T51");
#else
	skip_chk("_27454T51");
#endif /* CASE_27454T51 */

/* _27454T61 scientific returns */
#if !defined(SKIP_27454T61)&&(!defined(ONLY)||defined(CASE_27454T61))
	begin_chk("_27454T61");
	{
	Bi x(0);
	chk(&scientific(x) == &x);


	}
	end_chk("_27454T61");
#else
	skip_chk("_27454T61");
#endif /* CASE_27454T61 */

/* _275T11 <streambuf> synopsis */
#if !defined(SKIP_275T11)&&(!defined(ONLY)||defined(CASE_275T11))
	begin_chk("_275T11");
	{
	streambuf *p2 = 0; TOUCH(p2);
	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	basic_streambuf<Char, char_traits<Char> > *p1 = 0; TOUCH(p1);
	wstreambuf *p3 = 0; TOUCH(p3);
	#endif /* IS_EMBEDDED */
	chk(1);










	}
	end_chk("_275T11");
#else
	skip_chk("_275T11");
#endif /* CASE_275T11 */

/* _2752T11 basic_streambuf definition */
#if !defined(SKIP_2752T11)&&(!defined(ONLY)||defined(CASE_2752T11))
	begin_chk("_2752T11");
	{
	Bss sbuf;
	Bs *p = &sbuf;

	Bs::char_type *pct = (char *)0; TOUCH(pct);
	Bs::traits_type *ptt = (It *)0; TOUCH(ptt);	// ADDED [MAR96]
	Bs::int_type *pit = (It::int_type *)0; TOUCH(pit);
	Bs::pos_type *pst = (It::pos_type *)0; TOUCH(pst);
	Bs::off_type *pot = (It::off_type *)0; TOUCH(pot);

	chk(p->sputc((Char)'T') == (Char)'T');
	ieq(p->sputn((const Char *)"his is a test", 13), 13);
	Bs::pos_type pos = p->pubseekoff(0, ios_base::beg);
	chk(pos == p->pubseekpos(pos, ios_base::in));
	p->pubsync();
	p->in_avail();
	chk(p->sbumpc() == (Char)'T');
	chk(p->sgetc() == (Char)'h');
	chk(p->snextc() == (Char)'i');
	chk(p->sputbackc((Char)'h') == (Char)'h');
	chk(p->sungetc() == (Char)'T');
	char arr[14];
	ieq(p->sgetn(arr, 14), 14);
	ieq(STD memcmp(arr, "This is a test", 14), 0);
	locale Myloc("");
	p->pubimbue(Myloc);
	chk(p->getloc() == Myloc);
	p->pubsetbuf(0, 0);


	}
	end_chk("_2752T11");
#else
	skip_chk("_2752T11");
#endif /* CASE_2752T11 */

/* _2752T21 streambuf definition */
#if !defined(SKIP_2752T21)&&(!defined(ONLY)||defined(CASE_2752T21))
	begin_chk("_2752T21");
	{
	basic_streambuf<Char, char_traits<Char> > *p
		= (streambuf *)0; TOUCH(p);
	chk(1);


	}
	end_chk("_2752T21");
#else
	skip_chk("_2752T21");
#endif /* CASE_2752T21 */

/* _2752T31 wstreambuf definition */
#if !defined(SKIP_2752T31)&&(!defined(ONLY)||defined(CASE_2752T31))
	begin_chk("_2752T31");
	{
	basic_streambuf<wchar_t, char_traits<wchar_t> > *p
		= (wstreambuf *)0; TOUCH(p);
	chk(1);
	}
	end_chk("_2752T31");
#else
	skip_chk("_2752T31");
#endif /* CASE_2752T31 */

return leave_chk("t273");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t262.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"

#if IS_EMBEDDED
#define ONLY
#define CASE_2627T71     cos  (const complex<T>& x)
#define CASE_2627T81     cosh (const complex<T>& x)
#define CASE_2627T91     exp  (const complex<T>& x)
#define CASE_2627T_101   log  (const complex<T>& x)
#define CASE_2627T_111   log10(const complex<T>& x)
#define CASE_2627T_121   pow(const complex<T>& x, const complex<T>& y)
#define CASE_2627T_131   pow  (const complex<T>& x, T y)
#define CASE_2627T_141   pow  (T x, const complex<T>& y)
#define CASE_2627T_151   pow  (const complex<T>& x, int y)
#define CASE_2627T_161   sin  (const complex<T>& x)
#define CASE_2627T_171   sinh (const complex<T>& x)
#define CASE_2627T_181   sqrt (const complex<T>& x)
#define CASE_2627T_191   tan  (const complex<T>& x)
#define CASE_2627T_201   tanh (const complex<T>& x)
//#define CASE_263T11  <valarray> synopsis
//#define CASE_2631T11  class valarray definition
#endif /* IS_EMBEDDED */

/* _2627T71     cos  (const complex<T>& x) */
#if !defined(SKIP_2627T71)&&(!defined(ONLY)||defined(CASE_2627T71))
#include <complex>
#endif /* CASE_2627T71 */

/* _2627T81     cosh (const complex<T>& x) */
#if !defined(SKIP_2627T81)&&(!defined(ONLY)||defined(CASE_2627T81))
#include <complex>
#endif /* CASE_2627T81 */

/* _2627T91     exp  (const complex<T>& x) */
#if !defined(SKIP_2627T91)&&(!defined(ONLY)||defined(CASE_2627T91))
#include <complex>
#endif /* CASE_2627T91 */

/* _2627T_101   log  (const complex<T>& x) */
#if !defined(SKIP_2627T_101)&&(!defined(ONLY)||defined(CASE_2627T_101))
#include <complex>
#endif /* CASE_2627T_101 */

/* _2627T_111   log10(const complex<T>& x) */
#if !defined(SKIP_2627T_111)&&(!defined(ONLY)||defined(CASE_2627T_111))
#include <complex>
#endif /* CASE_2627T_111 */

/* _2627T_121   pow(const complex<T>& x, const complex<T>& y) */
#if !defined(SKIP_2627T_121)&&(!defined(ONLY)||defined(CASE_2627T_121))
#include <complex>
#endif /* CASE_2627T_121 */

/* _2627T_131   pow  (const complex<T>& x, T y) */
#if !defined(SKIP_2627T_131)&&(!defined(ONLY)||defined(CASE_2627T_131))
#include <complex>
#endif /* CASE_2627T_131 */

/* _2627T_141   pow  (T x, const complex<T>& y) */
#if !defined(SKIP_2627T_141)&&(!defined(ONLY)||defined(CASE_2627T_141))
#include <complex>
#endif /* CASE_2627T_141 */

/* _2627T_151   pow  (const complex<T>& x, int y) */
#if !defined(SKIP_2627T_151)&&(!defined(ONLY)||defined(CASE_2627T_151))
#include <complex>
#endif /* CASE_2627T_151 */

/* _2627T_161   sin  (const complex<T>& x) */
#if !defined(SKIP_2627T_161)&&(!defined(ONLY)||defined(CASE_2627T_161))
#include <complex>
#endif /* CASE_2627T_161 */

/* _2627T_171   sinh (const complex<T>& x) */
#if !defined(SKIP_2627T_171)&&(!defined(ONLY)||defined(CASE_2627T_171))
#include <complex>
#endif /* CASE_2627T_171 */

/* _2627T_181   sqrt (const complex<T>& x) */
#if !defined(SKIP_2627T_181)&&(!defined(ONLY)||defined(CASE_2627T_181))
#include <complex>
#endif /* CASE_2627T_181 */

/* _2627T_191   tan (const complex<T>& x) */
#if !defined(SKIP_2627T_191)&&(!defined(ONLY)||defined(CASE_2627T_191))
#include <complex>
#endif /* CASE_2627T_191 */

/* _2627T_201   tanh (const complex<T>& x) */
#if !defined(SKIP_2627T_201)&&(!defined(ONLY)||defined(CASE_2627T_201))
#include <complex>
#endif /* CASE_2627T_201 */

/* _263T11  <valarray> synopsis */
#if !defined(SKIP_263T11)&&(!defined(ONLY)||defined(CASE_263T11))
#include <valarray>
#endif /* CASE_263T11 */

/* _2631T11  class valarray definition */
#if !defined(SKIP_2631T11)&&(!defined(ONLY)||defined(CASE_2631T11))
#include <valarray>
#endif /* CASE_2631T11 */

int t262_main(int, char *[])
{
enter_chk("t262.cpp");
/* _2627T71     cos  (const complex<T>& x) */
#if !defined(SKIP_2627T71)&&(!defined(ONLY)||defined(CASE_2627T71))
	begin_chk("_2627T71");
	{
	CPXfloat cf (1., 0.);
	feq(cos(cf).real(), 0.5403023058681398F);
	feq(cos(cf).imag(), 0.F);

	CPXdouble cd (1., 1.);
	deq(cos(cd).real(), 8.3373002513114904887E-01);
	deq(cos(cd).imag(), -9.8889770576286509626E-01);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (piby4, -1.);
	ldeq(cos(cld).real(), cos1);
	ldeq(cos(cld).imag(), sin1);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T71");
#else
	skip_chk("_2627T71");
#endif /* CASE_2627T71 */

/* _2627T81     cosh (const complex<T>& x) */
#if !defined(SKIP_2627T81)&&(!defined(ONLY)||defined(CASE_2627T81))
	begin_chk("_2627T81");
	{
	CPXfloat cf (1., 0.);
	feq(cosh(cf).real(), 1.543080634815244F);
	feq(cosh(cf).imag(), 0.F);

	CPXdouble cd (1., 1.);
	deq(cosh(cd).real(), 8.3373002513114904887E-01);
	deq(cosh(cd).imag(), 9.8889770576286509626E-01);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (-1, piby4);
	ldeq(cosh(cld).real(), cos1);
	ldeq(cosh(cld).imag(), -sin1);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T81");
#else
	skip_chk("_2627T81");
#endif /* CASE_2627T81 */

/* _2627T91     exp  (const complex<T>& x) */
#if !defined(SKIP_2627T91)&&(!defined(ONLY)||defined(CASE_2627T91))
	begin_chk("_2627T91");
	{
	CPXfloat cf (1., 0.);
	feq(exp(cf).real(), (float)e);
	feq(exp(cf).imag(), 0.F);

	CPXdouble cd (1., 1.);
	deq(exp(cd).real(), 1.4686939399158851571E+00);
	deq(exp(cd).imag(), 2.2873552871788423911E+00);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (1., -piby4);
	ldeq(exp(cld).real(), e * rthalf);
	ldeq(exp(cld).imag(), -e * rthalf);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T91");
#else
	skip_chk("_2627T91");
#endif /* CASE_2627T91 */

/* _2627T_101   log  (const complex<T>& x) */
#if !defined(SKIP_2627T_101)&&(!defined(ONLY)||defined(CASE_2627T_101))
	begin_chk("_2627T_101");
	{
	CPXfloat cf (2., 0.);
	feq(log(cf).real(), 6.9314718055994530940E-01F);
	feq(log(cf).imag(), 0.F);

	CPXdouble cd (1., 1.);
	deq(log(cd).real(), 3.4657359027997265470E-01);
	deq(log(cd).imag(), 7.8539816339744830964E-01);

	#if IS_EMBEDDED
	TOUCH(ln2);
	#else /* IS_EMBEDDED */
	CPXldouble cld (1., -1.);
	ldeq(log(cld).real(), ln2 / 2);
	ldeq(log(cld).imag(), -piby4);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T_101");
#else
	skip_chk("_2627T_101");
#endif /* CASE_2627T_101 */

/* _2627T_111   log10(const complex<T>& x) */
#if !defined(SKIP_2627T_111)&&(!defined(ONLY)||defined(CASE_2627T_111))
	begin_chk("_2627T_111");
	{
	CPXfloat cf (1., 0.);
	feq(log10(cf).real(), 0.F);
	feq(log10(cf).imag(), 0.F);

	CPXdouble cd (10., 0.);
	deq(log10(cd).real(), 1.);
	deq(log10(cd).imag(), 0.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (100., 0.);
	ldeq(log10(cld).real(), 2.);
	ldeq(log10(cld).imag(), 0.);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T_111");
#else
	skip_chk("_2627T_111");
#endif /* CASE_2627T_111 */

/* _2627T_121   pow(const complex<T>& x, const complex<T>& y) */
#if !defined(SKIP_2627T_121)&&(!defined(ONLY)||defined(CASE_2627T_121))
	begin_chk("_2627T_121");
	{
	CPXfloat cf (1., 0.);
	CPXfloat cf2 (1., 0.);
	feq(pow(cf, cf2).real(), 1.F);
	feq(pow(cf, cf2).imag(), 0.F);

	CPXdouble cd (1., 1.);
	CPXdouble cd2 (1., 1.);
	deq(pow(cd, cd2).real(), 2.7395725383012107108E-01);
	deq(pow(cd, cd2).imag(), 5.8370075875861462750E-01);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (0., 1.);
	CPXldouble cld2 (1., 0.);
	ldeq(pow(cld, cld2).real(), 0.);
	ldeq(pow(cld, cld2).imag(), 1.);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T_121");
#else
	skip_chk("_2627T_121");
#endif /* CASE_2627T_121 */

/* _2627T_131   pow  (const complex<T>& x, T y) */
#if !defined(SKIP_2627T_131)&&(!defined(ONLY)||defined(CASE_2627T_131))
	begin_chk("_2627T_131");
	{
	CPXfloat cf (1., 0.);
	float f2 = 0.;
	feq(pow(cf, f2).real(), 1.F);
	feq(pow(cf, f2).imag(), 0.F);

	CPXdouble cd (1., 1.);
	double d2 = 1.;
	deq(pow(cd, d2).real(), 1);
	deq(pow(cd, d2).imag(), 1);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (2., 2.);
	long double ld2 = 5.;
	ldeq(pow(cld, ld2).real(), -128.);
	ldeq(pow(cld, ld2).imag(), -128.);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T_131");
#else
	skip_chk("_2627T_131");
#endif /* CASE_2627T_131 */

/* _2627T_141   pow  (T x, const complex<T>& y) */
#if !defined(SKIP_2627T_141)&&(!defined(ONLY)||defined(CASE_2627T_141))
	begin_chk("_2627T_141");
	{
	float f = 1.;
	CPXfloat cf2 (0., 1.);
	feq(pow(f, cf2).real(), 1.F);
	feq(pow(f, cf2).imag(), 0.F);

	double d = 0.;
	CPXdouble cd2 (1., 0.);
	deq(pow(d, cd2).real(), 0);
	deq(pow(d, cd2).imag(), 0);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	long double ld = e;
	CPXldouble cld2 (1., -piby4);
	ldeq(pow(ld, cld2).real(), e * rthalf);
	ldeq(pow(ld, cld2).imag(), -e * rthalf);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T_141");
#else
	skip_chk("_2627T_141");
#endif /* CASE_2627T_141 */

/* _2627T_151   pow  (const complex<T>& x, int y) */
#if !defined(SKIP_2627T_151)&&(!defined(ONLY)||defined(CASE_2627T_151))
	begin_chk("_2627T_151");
	{
	CPXfloat cf (0., 1.);
	int i2a = 1;
	feq(pow(cf, i2a).real(), 0.F);
	feq(pow(cf, i2a).imag(), 1.F);

	CPXdouble cd (1., 0.);
	int i2b = 0;
	deq(pow(cd, i2b).real(), 1.);
	deq(pow(cd, i2b).imag(), 0.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (2., 2.);
	int i2c = 5;
	ldeq(pow(cld, i2c).real(), -128.);
	ldeq(pow(cld, i2c).imag(), -128.);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T_151");
#else
	skip_chk("_2627T_151");
#endif /* CASE_2627T_151 */

/* _2627T_161   sin  (const complex<T>& x) */
#if !defined(SKIP_2627T_161)&&(!defined(ONLY)||defined(CASE_2627T_161))
	begin_chk("_2627T_161");
	{
	CPXfloat cf (1., 0.);
	feq(sin(cf).real(), 8.4147098480789650665E-01F);
	feq(sin(cf).imag(), 0.F);

	CPXdouble cd (1., 1.);
	deq(sin(cd).real(), 1.2984575814159772947E+00);
	deq(sin(cd).imag(), 6.3496391478473610820E-01);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (piby4, -1.);
	ldeq(sin(cld).real(), cos1);
	ldeq(sin(cld).imag(), -sin1);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T_161");
#else
	skip_chk("_2627T_161");
#endif /* CASE_2627T_161 */

/* _2627T_171   sinh (const complex<T>& x) */
#if !defined(SKIP_2627T_171)&&(!defined(ONLY)||defined(CASE_2627T_171))
	begin_chk("_2627T_171");
	{
	CPXfloat cf (1., 0.);
	feq(sinh(cf).real(), 1.1752011936438014568E+00F);
	feq(sinh(cf).imag(), 0.F);

	CPXdouble cd (1., 1.);
	deq(sinh(cd).real(), 6.3496391478473610820E-01);
	deq(sinh(cd).imag(), 1.2984575814159772947E+00);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (-1., piby4);
	ldeq(sinh(cld).real(), -sin1);
	ldeq(sinh(cld).imag(), cos1);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T_171");
#else
	skip_chk("_2627T_171");
#endif /* CASE_2627T_171 */

/* _2627T_181   sqrt (const complex<T>& x) */
#if !defined(SKIP_2627T_181)&&(!defined(ONLY)||defined(CASE_2627T_181))
	begin_chk("_2627T_181");
	{
	CPXfloat cf (1., 0.);
	feq(sqrt(cf).real(), 1.F);
	feq(sqrt(cf).imag(), 0.F);

	CPXdouble cd (1., 1.);
	deq(sqrt(cd).real(), 1.0986841134678099660E+00);
	deq(sqrt(cd).imag(), 4.5508986056222734126E-01);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (0., -1.);
	ldeq(sqrt(cld).real(), rthalf);
	ldeq(sqrt(cld).imag(), -rthalf);
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2627T_181");
#else
	skip_chk("_2627T_181");
#endif /* CASE_2627T_181 */

/* _2627T_191   tan (const complex<T>& x) */
#if !defined(SKIP_2627T_191)&&(!defined(ONLY)||defined(CASE_2627T_191))
	begin_chk("_2627T_191");
	{
	CPXfloat cf ((float)piby4, 0.);
	feq(tan(cf).real(), 1.F);
	feq(tan(cf).imag(), 0.F);

	CPXdouble cd (piby4, 0.);
	deq(tan(cd).real(), 1.);
	deq(tan(cd).imag(), 0.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (piby4, 0.);
	ldeq(tan(cld).real(), 1.);
	ldeq(tan(cld).imag(), 0.);
	#endif /* IS_EMBEDDED */

	}
	end_chk("_2627T_191");
#else
	skip_chk("_2627T_191");
#endif /* CASE_2627T_191 */

/* _2627T_201   tanh (const complex<T>& x) */
#if !defined(SKIP_2627T_201)&&(!defined(ONLY)||defined(CASE_2627T_201))
	begin_chk("_2627T_201");
	{
	CPXfloat cf (0., 0.);
	feq(tanh(cf).real(), 0.F);
	feq(tanh(cf).imag(), 0.F);

	CPXdouble cd (0., 0.);
	deq(tanh(cd).real(), 0.);
	deq(tanh(cd).imag(), 0.);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	CPXldouble cld (0., 0.);
	ldeq(tanh(cld).real(), 0.);
	ldeq(tanh(cld).imag(), 0.);
	#endif /* IS_EMBEDDED */






	}
	end_chk("_2627T_201");
#else
	skip_chk("_2627T_201");
#endif /* CASE_2627T_201 */

/* _263T11  <valarray> synopsis */
#if !defined(SKIP_263T11)&&(!defined(ONLY)||defined(CASE_263T11))
	begin_chk("_263T11");
	{
	slice *p0 = 0; TOUCH(p0);
	gslice *p1 = 0; TOUCH(p1);
	valarray<Ty> *p2 = 0; TOUCH(p2);
	Ty *pv2 = (valarray<Ty>::value_type *)0; TOUCH(pv2);	// ADDED [MAR96]

	gslice_array<Ty> *p3 = 0; TOUCH(p3);
	Ty *pv3 = (gslice_array<Ty>::value_type *)0; TOUCH(pv3);	// ADDED [MAR96]

	indirect_array<Ty> *p4 = 0; TOUCH(p4);
	Ty *pv4 = (indirect_array<Ty>::value_type *)0; TOUCH(pv4);	// ADDED [MAR96]

	mask_array<Ty> *p5 = 0; TOUCH(p5);
	Ty *pv5 = (mask_array<Ty>::value_type *)0; TOUCH(pv5);	// ADDED [MAR96]

	slice_array<Ty> *p6 = 0; TOUCH(p6);
	Ty *pv6 = (slice_array<Ty>::value_type *)0; TOUCH(pv6);	// ADDED [MAR96]
	chk(1);




	}
	end_chk("_263T11");
#else
	skip_chk("_263T11");
#endif /* CASE_263T11 */

/* _2631T11  class valarray definition */
#if !defined(SKIP_2631T11)&&(!defined(ONLY)||defined(CASE_2631T11))
	begin_chk("_2631T11");
	{
	valarray<Ty> x, y(4, 10);
	ieq(y[9], 4);
	x = -y;
	ieq(x[9], -4);
	x /= y;
	ieq(x.sum(), -10);



	}
	end_chk("_2631T11");
#else
	skip_chk("_2631T11");
#endif /* CASE_2631T11 */

return leave_chk("t262");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t27e.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _2763T41 resetiosflags returns */
#if !defined(SKIP_2763T41)&&(!defined(ONLY)||defined(CASE_2763T41))
#include <iomanip>
#include <istream>
#include <ostream>
#endif /* CASE_2763T41 */

/* _2763T61 setiosflags returns */
#if !defined(SKIP_2763T61)&&(!defined(ONLY)||defined(CASE_2763T61))
#include <iomanip>
#include <istream>
#include <ostream>
#endif /* CASE_2763T61 */

/* _2763T81 setbase returns */
#if !defined(SKIP_2763T81)&&(!defined(ONLY)||defined(CASE_2763T81))
#include <iomanip>
#include <istream>
#include <ostream>
#endif /* CASE_2763T81 */

/* _2763T_101 setfill returns */
#if !defined(SKIP_2763T_101)&&(!defined(ONLY)||defined(CASE_2763T_101))
#include <climits>
#include <iomanip>
#include <sstream>
#if IS_EMBEDDED
#else /* IS_EMBEDDED */
#include <cwchar>
#endif /* IS_EMBEDDED */
#endif /* CASE_2763T_101 */

/* _2763T_121 setprecision returns */
#if !defined(SKIP_2763T_121)&&(!defined(ONLY)||defined(CASE_2763T_121))
#include <iomanip>
#include <istream>
#include <ostream>
#endif /* CASE_2763T_121 */

/* _2763T_141 setw returns */
#if !defined(SKIP_2763T_141)&&(!defined(ONLY)||defined(CASE_2763T_141))
#include <iomanip>
#include <istream>
#include <ostream>
#endif /* CASE_2763T_141 */

int t27e_main(int, char *[])
{
enter_chk("t27e.cpp");
/* _2763T41 resetiosflags returns */
#if !defined(SKIP_2763T41)&&(!defined(ONLY)||defined(CASE_2763T41))
	begin_chk("_2763T41");
	{
	STD ios_base::fmtflags allf =
		STD ios_base::skipws | STD ios_base::unitbuf
		| STD ios_base::uppercase | STD ios_base::showbase
		| STD ios_base::showpoint | STD ios_base::showpos
		| STD ios_base::adjustfield | STD ios_base::basefield
		| STD ios_base::floatfield;
	Is istr(0);
	istr.setf(allf);
	chk(&(istr >> resetiosflags(STD ios_base::uppercase)) == &istr);
	chk(istr.flags() == (allf & ~STD ios_base::uppercase));
	istr >> resetiosflags(STD ios_base::hex);
	chk(istr.flags() == (allf &
		~(STD ios_base::uppercase | STD ios_base::hex)));
	istr >> resetiosflags(allf);
	chk(istr.flags() == (STD ios_base::fmtflags)0);
	Os ostr(0);
	ostr.setf(allf);
	chk(&(ostr << resetiosflags(STD ios_base::uppercase)) == &ostr);
	chk(ostr.flags() == (allf & ~STD ios_base::uppercase));
	ostr << resetiosflags(STD ios_base::hex);
	chk(ostr.flags() == (allf &
		~(STD ios_base::uppercase | STD ios_base::hex)));
	ostr << resetiosflags(allf);
	chk(ostr.flags() == (STD ios_base::fmtflags)0);


	}
	end_chk("_2763T41");
#else
	skip_chk("_2763T41");
#endif /* CASE_2763T41 */

/* _2763T61 setiosflags returns */
#if !defined(SKIP_2763T61)&&(!defined(ONLY)||defined(CASE_2763T61))
	begin_chk("_2763T61");
	{
	STD ios_base::fmtflags allf =
		STD ios_base::skipws | STD ios_base::unitbuf
		| STD ios_base::uppercase | STD ios_base::showbase
		| STD ios_base::showpoint | STD ios_base::showpos
		| STD ios_base::adjustfield | STD ios_base::basefield
		| STD ios_base::floatfield;
	Is istr(0);
	istr.unsetf(allf);
	chk(&(istr >> setiosflags(STD ios_base::uppercase)) == &istr);
	chk(istr.flags() == STD ios_base::uppercase);
	istr >> setiosflags(STD ios_base::hex);
	chk(istr.flags() == (STD ios_base::uppercase | STD ios_base::hex));
	istr >> setiosflags(allf);
	chk(istr.flags() == allf);
	Os ostr(0);
	ostr.unsetf(allf);
	chk(&(ostr << setiosflags(STD ios_base::uppercase)) == &ostr);
	chk(ostr.flags() == STD ios_base::uppercase);
	ostr << setiosflags(STD ios_base::hex);
	chk(ostr.flags() == (STD ios_base::uppercase | STD ios_base::hex));
	ostr << setiosflags(allf);
	chk(ostr.flags() == allf);


	}
	end_chk("_2763T61");
#else
	skip_chk("_2763T61");
#endif /* CASE_2763T61 */

/* _2763T81 setbase returns */
#if !defined(SKIP_2763T81)&&(!defined(ONLY)||defined(CASE_2763T81))
	begin_chk("_2763T81");
	{
	STD ios_base::fmtflags allf =
		STD ios_base::skipws | STD ios_base::unitbuf
		| STD ios_base::uppercase | STD ios_base::showbase
		| STD ios_base::showpoint | STD ios_base::showpos
		| STD ios_base::adjustfield | STD ios_base::basefield
		| STD ios_base::floatfield;
	Is istr(0);
	istr >> setbase(8);
	chk((istr.flags() & STD ios_base::basefield) == STD ios_base::oct);
	istr >> setbase(10);
	chk((istr.flags() & STD ios_base::basefield) == STD ios_base::dec);
	istr >> setbase(16);
	chk((istr.flags() & STD ios_base::basefield) == STD ios_base::hex);
	istr >> setbase(0);
	chk((istr.flags() & STD ios_base::basefield) == (STD ios_base::fmtflags)0);
	istr.setf(allf);
	istr >> setbase(23);
	chk(istr.flags() == (allf & ~STD ios_base::basefield));
	Os ostr(0);
	ostr << setbase(8);
	chk((ostr.flags() & STD ios_base::basefield) == STD ios_base::oct);
	ostr << setbase(10);
	chk((ostr.flags() & STD ios_base::basefield) == STD ios_base::dec);
	ostr << setbase(16);
	chk((ostr.flags() & STD ios_base::basefield) == STD ios_base::hex);
	ostr << setbase(0);
	chk((ostr.flags() & STD ios_base::basefield) == (STD ios_base::fmtflags)0);
	ostr.setf(allf);
	ostr << setbase(23);
	chk(ostr.flags() == (allf & ~STD ios_base::basefield));


	}
	end_chk("_2763T81");
#else
	skip_chk("_2763T81");
#endif /* CASE_2763T81 */

/* _2763T_101 setfill returns */
#if !defined(SKIP_2763T_101)&&(!defined(ONLY)||defined(CASE_2763T_101))
	begin_chk("_2763T_101");
	{
	//Is istr(0);	// disappeared
	//istr >> setfill((Char)'\0');	// changed [JUL95]
	//ieq(istr.fill(), (Char)'\0');
	//istr >> setfill((Char)'x');
	//ieq(istr.fill(), (Char)'x');
	//istr >> setfill((Char)CHAR_MAX);
	//ieq(istr.fill(), (Char)CHAR_MAX);
	//istr >> setfill((Char)CHAR_MIN);
	//ieq(istr.fill(), (Char)CHAR_MIN);

	Os ostr(0);
	ostr << setfill((Char)'\0');
	ieq(ostr.fill(), (Char)'\0');
	ostr << setfill((Char)'x');
	ieq(ostr.fill(), (Char)'x');
	ostr << setfill((Char)CHAR_MAX);
	ieq(ostr.fill(), (Char)CHAR_MAX);
	ostr << setfill((Char)CHAR_MIN);
	ieq(ostr.fill(), (Char)CHAR_MIN);

	#if IS_EMBEDDED
	#else /* IS_EMBEDDED */
	wostringstream wostr;
	wostr << setfill((wchar_t)L'\0');
	ieq(wostr.fill(), L'\0');
	wostr << setfill((wchar_t)L'x');
	ieq(wostr.fill(), L'x');
	wostr << setfill((wchar_t)WCHAR_MAX);
	ieq(wostr.fill(), WCHAR_MAX);
	wostr << setfill((wchar_t)WCHAR_MIN);
	ieq(wostr.fill(), WCHAR_MIN);
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2763T_101");
#else
	skip_chk("_2763T_101");
#endif /* CASE_2763T_101 */

/* _2763T_121 setprecision returns */
#if !defined(SKIP_2763T_121)&&(!defined(ONLY)||defined(CASE_2763T_121))
	begin_chk("_2763T_121");
	{
	Is istr(0);
	istr >> setprecision(0);
	ieq(istr.precision(), 0);
	istr >> setprecision('x');
	ieq(istr.precision(), 'x');
	istr >> setprecision(32767);
	ieq(istr.precision(), 32767);
	istr >> setprecision(-32767);
	ieq(istr.precision(), -32767);
	Os ostr(0);
	ostr << setprecision(0);
	ieq(ostr.precision(), 0);
	ostr << setprecision('x');
	ieq(ostr.precision(), 'x');
	ostr << setprecision(32767);
	ieq(ostr.precision(), 32767);
	ostr << setprecision(-32767);
	ieq(ostr.precision(), -32767);


	}
	end_chk("_2763T_121");
#else
	skip_chk("_2763T_121");
#endif /* CASE_2763T_121 */

/* _2763T_141 setw returns */
#if !defined(SKIP_2763T_141)&&(!defined(ONLY)||defined(CASE_2763T_141))
	begin_chk("_2763T_141");
	{
	Is istr(0);
	istr >> setw(0);
	ieq(istr.width(), 0);
	istr >> setw('x');
	ieq(istr.width(), 'x');
	istr >> setw(32767);
	ieq(istr.width(), 32767);
	istr >> setw(-32767);
	ieq(istr.width(), -32767);
	Os ostr(0);
	ostr << setw(0);
	ieq(ostr.width(), 0);
	ostr << setw('x');
	ieq(ostr.width(), 'x');
	ostr << setw(32767);
	ieq(ostr.width(), 32767);
	ostr << setw(-32767);
	ieq(ostr.width(), -32767);

	}
	end_chk("_2763T_141");
#else
	skip_chk("_2763T_141");
#endif /* CASE_2763T_141 */

return leave_chk("t27e");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t27f.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _277T11 <sstream> synopsis */
#if !defined(SKIP_277T11)&&(!defined(ONLY)||defined(CASE_277T11))
#include <sstream>
#endif /* CASE_277T11 */

/* _2771T11 basic_stringbuf definition */
#if !defined(SKIP_2771T11)&&(!defined(ONLY)||defined(CASE_2771T11))
#include <sstream>
#endif /* CASE_2771T11 */

/* _2771T31 basic_stringbuf::basic_stringbuf(openmode) effects */
#if !defined(SKIP_2771T31)&&(!defined(ONLY)||defined(CASE_2771T31))
#include <sstream>
#endif /* CASE_2771T31 */

/* _2771T51 basic_stringbuf::basic_stringbuf(string) effects */
#if !defined(SKIP_2771T51)&&(!defined(ONLY)||defined(CASE_2771T51))
#include <sstream>
#endif /* CASE_2771T51 */

/* _2771T61 basic_stringbuf::basic_stringbuf(string) postcondition, str() == str */
#if !defined(SKIP_2771T61)&&(!defined(ONLY)||defined(CASE_2771T61))
#include <sstream>
#endif /* CASE_2771T61 */

/* _2771T62 basic_stringbuf::basic_stringbuf(string) postcondition, pointers */
#if !defined(SKIP_2771T62)&&(!defined(ONLY)||defined(CASE_2771T62))
#include <sstream>
#endif /* CASE_2771T62 */

/* _27712T21 basic_stringbuf::str() returns */
#if !defined(SKIP_27712T21)&&(!defined(ONLY)||defined(CASE_27712T21))
#include <sstream>
#endif /* CASE_27712T21 */

/* _27712T41 basic_stringbuf::str(string) effects */
#if !defined(SKIP_27712T41)&&(!defined(ONLY)||defined(CASE_27712T41))
#include <sstream>
#endif /* CASE_27712T41 */

/* _27712T51 basic_stringbuf::str(string) postcondition */
#if !defined(SKIP_27712T51)&&(!defined(ONLY)||defined(CASE_27712T51))
#include <sstream>
#endif /* CASE_27712T51 */

/* _27713T21 basic_stringbuf::underflow returns, *gptr() */
#if !defined(SKIP_27713T21)&&(!defined(ONLY)||defined(CASE_27713T21))
#include <sstream>
class Mystringbuf_27713T21 : public Bss {
public:
	int_type Myunderflow()
		{return (underflow()); }
	};
#endif /* CASE_27713T21 */

/* _27713T22 basic_stringbuf::underflow returns, eof() */
#if !defined(SKIP_27713T22)&&(!defined(ONLY)||defined(CASE_27713T22))
#include <sstream>
class Mystringbuf_27713T22 : public Bss {
public:
	int_type Myunderflow()
		{return (underflow()); }
	};
#endif /* CASE_27713T22 */

/* _27713T41 basic_stringbuf::pbackfail effects, --gptr() */
#if !defined(SKIP_27713T41)&&(!defined(ONLY)||defined(CASE_27713T41))
#include <sstream>
class Mystringbuf_27713T41 : public Bss {
public:
	Mystringbuf_27713T41(STD ios_base::openmode mode)
		: Bss(mode) {}
	int_type Mypbackfail(int_type c)
		{return (pbackfail(c)); }
	};
#endif /* CASE_27713T41 */

/* _27713T42 basic_stringbuf::pbackfail effects, return c after --gptr() */
#if !defined(SKIP_27713T42)&&(!defined(ONLY)||defined(CASE_27713T42))
#include <sstream>
class Mystringbuf_27713T42 : public Bss {
public:
	Mystringbuf_27713T42(STD ios_base::openmode mode)
		: Bss(mode) {}
	int_type Mypbackfail(int_type c)
		{return (pbackfail(c)); }
	};
#endif /* CASE_27713T42 */

/* _27713T43 basic_stringbuf::pbackfail effects, *--gptr() = c */
#if !defined(SKIP_27713T43)&&(!defined(ONLY)||defined(CASE_27713T43))
#include <sstream>
class Mystringbuf_27713T43 : public Bss {
public:
	int_type Mypbackfail(int_type c)
		{return (pbackfail(c)); }
	};
#endif /* CASE_27713T43 */

/* _27713T44 basic_stringbuf::pbackfail effects, return c after *--gptr() = c */
#if !defined(SKIP_27713T44)&&(!defined(ONLY)||defined(CASE_27713T44))
#include <sstream>
class Mystringbuf_27713T44 : public Bss {
public:
	int_type Mypbackfail(int_type c)
		{return (pbackfail(c)); }
	};
#endif /* CASE_27713T44 */

/* _27713T45 basic_stringbuf::pbackfail effects, c == eof() */
#if !defined(SKIP_27713T45)&&(!defined(ONLY)||defined(CASE_27713T45))
#include <sstream>
class Mystringbuf_27713T45 : public Bss {
public:
	Mystringbuf_27713T45(STD ios_base::openmode mode)
		: Bss(mode) {}
	int_type Mypbackfail(int_type c)
		{return (pbackfail(c)); }
	};
#endif /* CASE_27713T45 */

/* _27713T46 basic_stringbuf::pbackfail effects, return not_eof(c) */
#if !defined(SKIP_27713T46)&&(!defined(ONLY)||defined(CASE_27713T46))
#include <sstream>
class Mystringbuf_27713T46 : public Bss {
public:
	Mystringbuf_27713T46(STD ios_base::openmode mode)
		: Bss(mode) {}
	int_type Mypbackfail(int_type c)
		{return (pbackfail(c)); }
	};
#endif /* CASE_27713T46 */

/* _27713T51 basic_stringbuf::pbackfail returns */
#if !defined(SKIP_27713T51)&&(!defined(ONLY)||defined(CASE_27713T51))
#include <sstream>
class Mystringbuf_27713T51 : public Bss {
public:
	Mystringbuf_27713T51(STD ios_base::openmode mode)
		: Bss(mode) {}
	int_type Mypbackfail(int_type c)
		{return (pbackfail(c)); }
	};
#endif /* CASE_27713T51 */

/* _27713T71 basic_stringbuf::overflow effects, c != eof() */
#if !defined(SKIP_27713T71)&&(!defined(ONLY)||defined(CASE_27713T71))
#include <sstream>
class Mystringbuf_27713T71 : public Bss {
public:
	Mystringbuf_27713T71(STD ios_base::openmode mode)
		: Bss(mode) {}
	int_type Myoverflow(int_type c)
		{return (overflow(c)); }
	};
#endif /* CASE_27713T71 */

/* _27713T72 basic_stringbuf::overflow effects, returns c after c != eof() */
#if !defined(SKIP_27713T72)&&(!defined(ONLY)||defined(CASE_27713T72))
#include <sstream>
class Mystringbuf_27713T72 : public Bss {
public:
	Mystringbuf_27713T72(STD ios_base::openmode mode)
		: Bss(mode) {}
	int_type Myoverflow(int_type c)
		{return (overflow(c)); }
	};
#endif /* CASE_27713T72 */

/* _27713T73 basic_stringbuf::overflow effects, c == eof() */
#if !defined(SKIP_27713T73)&&(!defined(ONLY)||defined(CASE_27713T73))
#include <sstream>
class Mystringbuf_27713T73 : public Bss {
public:
	Mystringbuf_27713T73(STD ios_base::openmode mode)
		: Bss(mode) {}
	int_type Myoverflow(int_type c)
		{return (overflow(c)); }
	};
#endif /* CASE_27713T73 */

/* _27713T74 basic_stringbuf::overflow effects, returns not_eof(c) */
#if !defined(SKIP_27713T74)&&(!defined(ONLY)||defined(CASE_27713T74))
#include <sstream>
class Mystringbuf_27713T74 : public Bss {
public:
	Mystringbuf_27713T74(STD ios_base::openmode mode)
		: Bss(mode) {}
	int_type Myoverflow(int_type c)
		{return (overflow(c)); }
	};
#endif /* CASE_27713T74 */

/* _27713T91 basic_stringbuf::overflow returns */
#if !defined(SKIP_27713T91)&&(!defined(ONLY)||defined(CASE_27713T91))
#include <sstream>
class Mystringbuf_27713T91 : public Bss {
public:
	Mystringbuf_27713T91(STD ios_base::openmode mode)
		: Bss(mode) {}
	int_type Myoverflow(int_type c)
		{return (overflow(c)); }
	};
#endif /* CASE_27713T91 */

int t27f_main(int, char *[])
{
enter_chk("t27f.cpp");
/* _277T11 <sstream> synopsis */
#if !defined(SKIP_277T11)&&(!defined(ONLY)||defined(CASE_277T11))
	begin_chk("_277T11");
	{
	#if IS_EMBEDDED
	stringbuf *p1 = 0; TOUCH(p1);
	istringstream *p3 = 0; TOUCH(p3);
	ostringstream *p5 = 0; TOUCH(p5);
	chk(1);
	#else /* IS_EMBEDDED */
	typedef STD char_traits<char> CIt;
	typedef ALLOCATOR(char) CAl;
	typedef STD char_traits<wchar_t> WIt;
	typedef ALLOCATOR(wchar_t) WAl;
	basic_stringbuf<char, CIt, CAl> *p1 = 0; TOUCH(p1);
	stringbuf *p2 = p1; TOUCH(p2);
	basic_istringstream<char, CIt, CAl> *p3 = 0; TOUCH(p3);
	istringstream *p4 = p3; TOUCH(p4);
	basic_ostringstream<char, CIt, CAl> *p5 = 0; TOUCH(p5);
	ostringstream *p6 = p5; TOUCH(p6);
	basic_stringbuf<wchar_t, WIt, WAl> *pw1 = 0; TOUCH(pw1);
	wstringbuf *pw2 = pw1; TOUCH(pw2);
	basic_istringstream<wchar_t, WIt, WAl> *pw3 = 0; TOUCH(pw3);
	wistringstream *pw4 = pw3; TOUCH(pw4);
	basic_ostringstream<wchar_t, WIt, WAl> *pw5 = 0; TOUCH(pw5);
	wostringstream *pw6 = pw5; TOUCH(pw6);

	stringstream *p7 = (basic_stringstream<char, CIt, CAl> *)0; TOUCH(p7);
	wstringstream *p8 = (basic_stringstream<wchar_t, WIt, WAl> *)0; TOUCH(p8);

	typedef STD basic_stringstream<Char, It, Al> Iostr;	// ADDED [MAR96]
	Iostr::traits_type *ptt = (It *)0; TOUCH(ptt);	// ADDED [JUL96]
	Iostr::char_type *p9 = (Char *)0; TOUCH(p9);
	Iostr::int_type *p10 = 0; TOUCH(p10);
	Iostr::pos_type *p11 = 0; TOUCH(p11);
	Iostr::off_type *p12 = 0; TOUCH(p12);

	Iostr iostr, iostr1(ios_base::in);
	int i = 37;
	iostr << i << endl;

	iostr.rdbuf()->pubseekoff(0, ios_base::beg);
	iostr1.str(iostr.str());
	i = 0;
	iostr >> i;
	ieq(i, 37);
	#endif /* IS_EMBEDDED */




	}
	end_chk("_277T11");
#else
	skip_chk("_277T11");
#endif /* CASE_277T11 */

/* _2771T11 basic_stringbuf definition */
#if !defined(SKIP_2771T11)&&(!defined(ONLY)||defined(CASE_2771T11))
	begin_chk("_2771T11");
	{
	Cstr input((const Char *)"abcdefg");
	Bss sbuf, sbuf1(STD ios_base::out), sbuf2(input),
		subf3(input, STD ios_base::in);
	Bs *p = &sbuf; TOUCH(p);
	Bss::traits_type *ptt = (It *)0; TOUCH(ptt);	// ADDED [JUL96]
	Bss::char_type *pct = (Char *)0; TOUCH(pct);
	Bss::int_type *pit = (It::int_type *)0; TOUCH(pit);
	Bss::pos_type *pst = (It::pos_type *)0; TOUCH(pst);
	Bss::off_type *pot = (It::off_type *)0; TOUCH(pot);
	sbuf1.str(input);
	chk(sbuf2.str() == input);


	}
	end_chk("_2771T11");
#else
	skip_chk("_2771T11");
#endif /* CASE_2771T11 */

/* _2771T31 basic_stringbuf::basic_stringbuf(openmode) effects */
#if !defined(SKIP_2771T31)&&(!defined(ONLY)||defined(CASE_2771T31))
	begin_chk("_2771T31");
	{
	Cstr input((const Char *)"abcdefg");
	Bss sbuf, sbuf1(STD ios_base::out), sbuf2(STD ios_base::in),
		sbuf3(STD ios_base::in | STD ios_base::out),
		sbuf4((STD ios_base::openmode)0);
	Char ch = (Char)'a';
	Bss::int_type eof = It::eof();
	chk(sbuf.sputc(ch) == ch);
	chk(sbuf.sgetc() == ch);
	chk(sbuf1.sputc(ch) == ch);
	chk(sbuf1.sgetc() == eof);
	chk(sbuf2.sputc(ch) == eof);
	sbuf2.str(input);
	chk(sbuf2.sgetc() == ch);
	chk(sbuf3.sputc(ch) == ch);
	chk(sbuf3.sgetc() == ch);
	chk(sbuf4.sputc(ch) == eof);
	sbuf4.str(input);
	chk(sbuf4.sgetc() == eof);



	}
	end_chk("_2771T31");
#else
	skip_chk("_2771T31");
#endif /* CASE_2771T31 */

/* _2771T51 basic_stringbuf::basic_stringbuf(string) effects */
#if !defined(SKIP_2771T51)&&(!defined(ONLY)||defined(CASE_2771T51))
	begin_chk("_2771T51");
	{
	Cstr input((const Char *)"abcdefg");
	Bss sbuf(input), sbuf1(input, STD ios_base::out),
		sbuf2(input, STD ios_base::in),
		sbuf3(input, STD ios_base::in | STD ios_base::out),
		sbuf4(input, (STD ios_base::openmode)0);
	Char ch = (Char)'a';
	Bss::int_type eof = It::eof();
	chk(sbuf.sputc(ch) == ch);
	chk(sbuf.sgetc() == ch);
	chk(sbuf1.sputc(ch) == ch);
	chk(sbuf1.sgetc() == eof);
	chk(sbuf2.sgetc() == ch);
	chk(sbuf3.sputc(ch) == ch);
	chk(sbuf3.sgetc() == ch);
	chk(sbuf4.sputc(ch) == eof);
	chk(sbuf4.sgetc() == eof);



	}
	end_chk("_2771T51");
#else
	skip_chk("_2771T51");
#endif /* CASE_2771T51 */

/* _2771T61 basic_stringbuf::basic_stringbuf(string) postcondition, str() == str */
#if !defined(SKIP_2771T61)&&(!defined(ONLY)||defined(CASE_2771T61))
	begin_chk("_2771T61");
	{
	Cstr input((const Char *)"abcdefg");
	Bss sbuf(input), sbuf1(input, STD ios_base::out),
		sbuf2(input, STD ios_base::in),
		sbuf3(input, STD ios_base::in | STD ios_base::out);
	chk(sbuf.str() == input);
	sbuf1.pubseekoff(0, STD ios_base::end, STD ios_base::out);
	chk(sbuf1.str() == input);
	chk(sbuf2.str() == input);
	chk(sbuf3.str() == input);



	}
	end_chk("_2771T61");
#else
	skip_chk("_2771T61");
#endif /* CASE_2771T61 */

/* _2771T62 basic_stringbuf::basic_stringbuf(string) postcondition, pointers */
#if !defined(SKIP_2771T62)&&(!defined(ONLY)||defined(CASE_2771T62))
	begin_chk("_2771T62");
	{
	Cstr input((const Char *)"abcdefg");
	Bss sbuf(input), sbuf1(input, STD ios_base::out),
		sbuf2(input, STD ios_base::in),
		sbuf3(input, STD ios_base::in | STD ios_base::out);
	chk(sbuf.str() == input);
	sbuf1.pubseekoff(0, STD ios_base::end, STD ios_base::out);
	chk(sbuf1.str() == input);
	chk(sbuf2.str() == input);
	chk(sbuf3.str() == input);


	}
	end_chk("_2771T62");
#else
	skip_chk("_2771T62");
#endif /* CASE_2771T62 */

/* _27712T21 basic_stringbuf::str() returns */
#if !defined(SKIP_27712T21)&&(!defined(ONLY)||defined(CASE_27712T21))
	begin_chk("_27712T21");
	{
	Cstr input((const Char *)"abc");
	Bss sbuf(input), sbuf1(input, STD ios_base::out),
		sbuf2(input, STD ios_base::in);
	chk(sbuf.sbumpc() == (Char)'a');
	chk(sbuf.sbumpc() == (Char)'b');
	chk(sbuf.sbumpc() == (Char)'c');
	chk(sbuf.sbumpc() == It::eof());
	chk(sbuf.sputc((Char)'x') == (Char)'x');
	sbuf.pubseekoff(-1, STD ios_base::end, STD ios_base::out);
	chk(sbuf.sputc((Char)'z') == (Char)'z');
	sbuf.pubseekoff(0, STD ios_base::beg, STD ios_base::in);
	chk(sbuf.sbumpc() == (Char)'x');
	chk(sbuf.sbumpc() == (Char)'b');
	chk(sbuf.sbumpc() == (Char)'z');
	chk(sbuf.sbumpc() == It::eof());


	}
	end_chk("_27712T21");
#else
	skip_chk("_27712T21");
#endif /* CASE_27712T21 */

/* _27712T41 basic_stringbuf::str(string) effects */
#if !defined(SKIP_27712T41)&&(!defined(ONLY)||defined(CASE_27712T41))
	begin_chk("_27712T41");
	{
	Cstr input((const Char *)"");
	Bss sbuf(input);
	chk(sbuf.sgetc() == It::eof());





	}
	end_chk("_27712T41");
#else
	skip_chk("_27712T41");
#endif /* CASE_27712T41 */

/* _27712T51 basic_stringbuf::str(string) postcondition */
#if !defined(SKIP_27712T51)&&(!defined(ONLY)||defined(CASE_27712T51))
	begin_chk("_27712T51");
	{
	Cstr input((const Char *)"abcdefg");
	Bss sbuf, sbuf1(STD ios_base::out), sbuf2(STD ios_base::in),
		sbuf3(STD ios_base::in | STD ios_base::out);
	sbuf.str(input);
	chk(sbuf.str() == input);
	sbuf1.str(input);
	sbuf1.pubseekoff(0, STD ios_base::end, STD ios_base::out);
	chk(sbuf1.str() == input);
	sbuf2.str(input);
	chk(sbuf2.str() == input);
	sbuf3.str(input);
	chk(sbuf3.str() == input);



	}
	end_chk("_27712T51");
#else
	skip_chk("_27712T51");
#endif /* CASE_27712T51 */

/* _27713T21 basic_stringbuf::underflow returns, *gptr() */
#if !defined(SKIP_27713T21)&&(!defined(ONLY)||defined(CASE_27713T21))
	begin_chk("_27713T21");
	{
	Cstr input((const Char *)"abcdefg");
	Mystringbuf_27713T21 sbuf;
	sbuf.str(input);
	chk(sbuf.Myunderflow() == It::to_int_type((Char)'a'));
	chk(sbuf.Myunderflow() == It::to_int_type((Char)'a'));


	}
	end_chk("_27713T21");
#else
	skip_chk("_27713T21");
#endif /* CASE_27713T21 */

/* _27713T22 basic_stringbuf::underflow returns, eof() */
#if !defined(SKIP_27713T22)&&(!defined(ONLY)||defined(CASE_27713T22))
	begin_chk("_27713T22");
	{
	Mystringbuf_27713T22 sbuf;
	chk(sbuf.Myunderflow() == It::eof());


	}
	end_chk("_27713T22");
#else
	skip_chk("_27713T22");
#endif /* CASE_27713T22 */

/* _27713T41 basic_stringbuf::pbackfail effects, --gptr() */
#if !defined(SKIP_27713T41)&&(!defined(ONLY)||defined(CASE_27713T41))
	begin_chk("_27713T41");
	{
	Cstr input((const Char *)"abcdefg");
	Mystringbuf_27713T41 sbuf(STD ios_base::in);
	sbuf.str(input);
	sbuf.sbumpc();
	sbuf.Mypbackfail(It::to_int_type((Char)'a'));
	chk(sbuf.sbumpc() == It::to_int_type((Char)'a'));
	chk(sbuf.sgetc() == It::to_int_type((Char)'b'));


	}
	end_chk("_27713T41");
#else
	skip_chk("_27713T41");
#endif /* CASE_27713T41 */

/* _27713T42 basic_stringbuf::pbackfail effects, return c after --gptr() */
#if !defined(SKIP_27713T42)&&(!defined(ONLY)||defined(CASE_27713T42))
	begin_chk("_27713T42");
	{
	Cstr input((const Char *)"abcdefg");
	Mystringbuf_27713T42 sbuf(STD ios_base::in);
	sbuf.str(input);
	sbuf.sbumpc();
	chk(sbuf.Mypbackfail(It::to_int_type((Char)'a'))
		== It::to_int_type((Char)'a'));


	}
	end_chk("_27713T42");
#else
	skip_chk("_27713T42");
#endif /* CASE_27713T42 */

/* _27713T43 basic_stringbuf::pbackfail effects, *--gptr() = c */
#if !defined(SKIP_27713T43)&&(!defined(ONLY)||defined(CASE_27713T43))
	begin_chk("_27713T43");
	{
	Cstr input((const Char *)"abcdefg");
	Mystringbuf_27713T43 sbuf;
	sbuf.str(input);
	sbuf.sbumpc();
	sbuf.Mypbackfail(It::to_int_type((Char)'x'));
	chk(sbuf.sbumpc() == It::to_int_type((Char)'x'));
	chk(sbuf.sgetc() == It::to_int_type((Char)'b'));



	}
	end_chk("_27713T43");
#else
	skip_chk("_27713T43");
#endif /* CASE_27713T43 */

/* _27713T44 basic_stringbuf::pbackfail effects, return c after *--gptr() = c */
#if !defined(SKIP_27713T44)&&(!defined(ONLY)||defined(CASE_27713T44))
	begin_chk("_27713T44");
	{
	Cstr input((const Char *)"abcdefg");
	Mystringbuf_27713T44 sbuf;
	sbuf.str(input);
	sbuf.sbumpc();
	chk(sbuf.Mypbackfail(It::to_int_type((Char)'x'))
		== It::to_int_type((Char)'x'));


	}
	end_chk("_27713T44");
#else
	skip_chk("_27713T44");
#endif /* CASE_27713T44 */

/* _27713T45 basic_stringbuf::pbackfail effects, c == eof() */
#if !defined(SKIP_27713T45)&&(!defined(ONLY)||defined(CASE_27713T45))
	begin_chk("_27713T45");
	{
	Cstr input((const Char *)"abcdefg");
	Mystringbuf_27713T45 sbuf(STD ios_base::in);
	sbuf.str(input);
	sbuf.sbumpc();
	sbuf.Mypbackfail(It::eof());
	chk(sbuf.sbumpc() == It::to_int_type((Char)'a'));
	chk(sbuf.sgetc() == It::to_int_type((Char)'b'));



	}
	end_chk("_27713T45");
#else
	skip_chk("_27713T45");
#endif /* CASE_27713T45 */

/* _27713T46 basic_stringbuf::pbackfail effects, return not_eof(c) */
#if !defined(SKIP_27713T46)&&(!defined(ONLY)||defined(CASE_27713T46))
	begin_chk("_27713T46");
	{
	Cstr input((const Char *)"abcdefg");
	Mystringbuf_27713T46 sbuf(STD ios_base::in);
	sbuf.str(input);
	sbuf.sbumpc();
	chk(sbuf.Mypbackfail(It::eof()) != It::eof());


	}
	end_chk("_27713T46");
#else
	skip_chk("_27713T46");
#endif /* CASE_27713T46 */

/* _27713T51 basic_stringbuf::pbackfail returns */
#if !defined(SKIP_27713T51)&&(!defined(ONLY)||defined(CASE_27713T51))
	begin_chk("_27713T51");
	{
	Cstr input((const Char *)"abcdefg");
	Mystringbuf_27713T51 sbuf(STD ios_base::in);
	sbuf.str(input);
	sbuf.sbumpc();
	chk(sbuf.Mypbackfail(It::to_int_type((Char)'x'))
		== It::eof());
	Mystringbuf_27713T51 sbufx(STD ios_base::in | STD ios_base::out);
	chk(sbufx.Mypbackfail(It::to_int_type((Char)'x'))
		== It::eof());


	}
	end_chk("_27713T51");
#else
	skip_chk("_27713T51");
#endif /* CASE_27713T51 */

/* _27713T71 basic_stringbuf::overflow effects, c != eof() */
#if !defined(SKIP_27713T71)&&(!defined(ONLY)||defined(CASE_27713T71))
	begin_chk("_27713T71");
	{
	Mystringbuf_27713T71 sbuf(STD ios_base::in | STD ios_base::out);
	sbuf.Myoverflow(It::to_int_type((Char)'x'));
	chk(sbuf.sgetc() == It::to_int_type((Char)'x'));


	}
	end_chk("_27713T71");
#else
	skip_chk("_27713T71");
#endif /* CASE_27713T71 */

/* _27713T72 basic_stringbuf::overflow effects, returns c after c != eof() */
#if !defined(SKIP_27713T72)&&(!defined(ONLY)||defined(CASE_27713T72))
	begin_chk("_27713T72");
	{
	Mystringbuf_27713T72 sbuf(STD ios_base::in | STD ios_base::out);
	chk(sbuf.Myoverflow(It::to_int_type((Char)'x'))
		== It::to_int_type((Char)'x'));


	}
	end_chk("_27713T72");
#else
	skip_chk("_27713T72");
#endif /* CASE_27713T72 */

/* _27713T73 basic_stringbuf::overflow effects, c == eof() */
#if !defined(SKIP_27713T73)&&(!defined(ONLY)||defined(CASE_27713T73))
	begin_chk("_27713T73");
	{
	Mystringbuf_27713T73 sbuf(STD ios_base::in | STD ios_base::out);
	sbuf.Myoverflow(It::eof());
	chk(sbuf.sgetc() == It::eof());


	}
	end_chk("_27713T73");
#else
	skip_chk("_27713T73");
#endif /* CASE_27713T73 */

/* _27713T74 basic_stringbuf::overflow effects, returns not_eof(c) */
#if !defined(SKIP_27713T74)&&(!defined(ONLY)||defined(CASE_27713T74))
	begin_chk("_27713T74");
	{
	Mystringbuf_27713T74 sbuf(STD ios_base::in | STD ios_base::out);
	chk(sbuf.Myoverflow(It::eof()) != It::eof());


	}
	end_chk("_27713T74");
#else
	skip_chk("_27713T74");
#endif /* CASE_27713T74 */

/* _27713T91 basic_stringbuf::overflow returns */
#if !defined(SKIP_27713T91)&&(!defined(ONLY)||defined(CASE_27713T91))
	begin_chk("_27713T91");
	{
	Mystringbuf_27713T91 sbuf(STD ios_base::in);
	chk(sbuf.Myoverflow(It::to_int_type((Char)'x')) == It::eof());

	}
	end_chk("_27713T91");
#else
	skip_chk("_27713T91");
#endif /* CASE_27713T91 */

return leave_chk("t27f");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\txd0.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _XD1T11 <*.h> headers are present */
#if !defined(SKIP_XD1T11)&&(!defined(ONLY)||defined(CASE_XD1T11))
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <limits.h>
#include <locale.h>
#include <math.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#if IS_EMBEDDED
#else /* IS_EMBEDDED */
#include <iso646.h>
#include <wchar.h>
#include <wctype.h>
#endif /* IS_EMBEDDED */
#endif /* CASE_XD1T11 */

/* _XD1T21 <*.h> headers include <c*>, plus using */
#if !defined(SKIP_XD1T21)&&(!defined(ONLY)||defined(CASE_XD1T21))
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <limits.h>
#include <locale.h>
#include <math.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#if IS_EMBEDDED
#else /* IS_EMBEDDED */
#include <iso646.h>
#include <wchar.h>
#include <wctype.h>
#endif /* IS_EMBEDDED */
#endif /* CASE_XD1T21 */

/* _XD2T11 ios_base defines io_state, open_mode, seek_dir */
#if !defined(SKIP_XD2T11)&&(!defined(ONLY)||defined(CASE_XD2T11))
#include <ios>
#endif /* CASE_XD2T11 */

/* _XD2T21 io_state is an integer type */
#if !defined(SKIP_XD2T21)&&(!defined(ONLY)||defined(CASE_XD2T21))
#include <ios>
#endif /* CASE_XD2T21 */

/* _XD2T31 open_mode is an integer type */
#if !defined(SKIP_XD2T31)&&(!defined(ONLY)||defined(CASE_XD2T31))
#include <ios>
#endif /* CASE_XD2T31 */

/* _XD2T41 seek_dir is an integer type */
#if !defined(SKIP_XD2T41)&&(!defined(ONLY)||defined(CASE_XD2T41))
#include <ios>
#endif /* CASE_XD2T41 */

/* _XD2T61 overloads on io_state, open_mode, seek_dir, declaration */
#if !defined(SKIP_XD2T61)&&(!defined(ONLY)||defined(CASE_XD2T61))
#include <fstream>
#include <ios>
#include <iostream>
#include <streambuf>
#if IS_EMBEDDED
typedef char_traits It_XD2T61;
typedef streambuf Bs_XD2T61;
#else /* IS_EMBEDDED */
typedef STD char_traits<char> It_XD2T61;
typedef STD basic_streambuf<char, It_XD2T61> Bs_XD2T61;
#endif /* IS_EMBEDDED */
class Mybuf_XD2T61 : public Bs_XD2T61 {
	};
#endif /* CASE_XD2T61 */

/* _XD31T11 strstreambuf definition */
#if !defined(SKIP_XD31T11)&&(!defined(ONLY)||defined(CASE_XD31T11))
#include <strstream>
#endif /* CASE_XD31T11 */

/* _XD311T21 strstreambuf::strstreambuf(streamsize) effects */
#if !defined(SKIP_XD311T21)&&(!defined(ONLY)||defined(CASE_XD311T21))
#include <strstream>
#endif /* CASE_XD311T21 */

/* _XD311T31 strstreambuf::strstreambuf(streamsize) postconditions */
#if !defined(SKIP_XD311T31)&&(!defined(ONLY)||defined(CASE_XD311T31))
#include <strstream>
#endif /* CASE_XD311T31 */

/* _XD311T51 strstreambuf::strstreambuf(palloc, pfree) effects */
#if !defined(SKIP_XD311T51)&&(!defined(ONLY)||defined(CASE_XD311T51))
#include <cstdlib>
#include <strstream>
static int cnt1_XD311T51;
static int cnt2_XD311T51;
void *salloc_XD311T51(size_t n)
	{++cnt1_XD311T51;
	return (STD malloc(n)); }
void sfree_XD311T51(void *p)
	{++cnt2_XD311T51;
	STD free(p); }
#endif /* CASE_XD311T51 */

/* _XD311T61 strstreambuf::strstreambuf(palloc, pfree) postconditions */
#if !defined(SKIP_XD311T61)&&(!defined(ONLY)||defined(CASE_XD311T61))
#include <cstdlib>
#include <strstream>
static int cnt1_XD311T61;
static int cnt2_XD311T61;
void *salloc_XD311T61(size_t n)
	{++cnt1_XD311T61;
	return (STD malloc(n)); }
void sfree_XD311T61(void *p)
	{++cnt2_XD311T61;
	STD free(p); }
#endif /* CASE_XD311T61 */

/* _XD311T81 strstreambuf::strstreambuf(char *) effects */
#if !defined(SKIP_XD311T81)&&(!defined(ONLY)||defined(CASE_XD311T81))
#include <strstream>
#endif /* CASE_XD311T81 */

/* _XD311T91 strstreambuf::strstreambuf(char *) postconditions */
#if !defined(SKIP_XD311T91)&&(!defined(ONLY)||defined(CASE_XD311T91))
#include <strstream>
#endif /* CASE_XD311T91 */

/* _XD311T_111 strstreambuf::strstreambuf(char *), pbeg_arg is null */
#if !defined(SKIP_XD311T_111)&&(!defined(ONLY)||defined(CASE_XD311T_111))
#include <cstring>
#include <strstream>
#endif /* CASE_XD311T_111 */

/* _XD311T_121 strstreambuf::strstreambuf(char *), pbeg_arg not null */
#if !defined(SKIP_XD311T_121)&&(!defined(ONLY)||defined(CASE_XD311T_121))
#include <cstdlib>
#include <strstream>
#endif /* CASE_XD311T_121 */

/* _XD311T_141 strstreambuf::strstreambuf(const char *), effects */
#if !defined(SKIP_XD311T_141)&&(!defined(ONLY)||defined(CASE_XD311T_141))
#include <cstring>
#include <strstream>
#endif /* CASE_XD311T_141 */

/* _XD311T_161 strstreambuf::~strstreambuf() frees object */
#if !defined(SKIP_XD311T_161)&&(!defined(ONLY)||defined(CASE_XD311T_161))
#include <cstdlib>
#include <strstream>
static int cnt1_XD311T_161;
static int cnt2_XD311T_161;
void *salloc_XD311T_161(size_t n)
	{++cnt1_XD311T_161;
	return (STD malloc(n)); }
void sfree_XD311T_161(void *p)
	{++cnt2_XD311T_161;
	STD free(p); }
#endif /* CASE_XD311T_161 */

int txd0_main(int, char *[])
{
enter_chk("txd0.cpp");
/* _XD1T11 <*.h> headers are present */
#if !defined(SKIP_XD1T11)&&(!defined(ONLY)||defined(CASE_XD1T11))
	begin_chk("_XD1T11");
	{
	int n = strlen("abc");
	chk(1);


	}
	end_chk("_XD1T11");
#else
	skip_chk("_XD1T11");
#endif /* CASE_XD1T11 */

/* _XD1T21 <*.h> headers include <c*>, plus using */
#if !defined(SKIP_XD1T21)&&(!defined(ONLY)||defined(CASE_XD1T21))
	begin_chk("_XD1T21");
	{
	int n = STD strlen("abc");
	chk(1);


	}
	end_chk("_XD1T21");
#else
	skip_chk("_XD1T21");
#endif /* CASE_XD1T21 */

/* _XD2T11 ios_base defines io_state, open_mode, seek_dir */
#if !defined(SKIP_XD2T11)&&(!defined(ONLY)||defined(CASE_XD2T11))
	begin_chk("_XD2T11");
	{
	ios_base::io_state s1 = ios_base::failbit; TOUCH(s1);
	ios_base::open_mode s2 = ios_base::trunc; TOUCH(s2);
	ios_base::seek_dir s3 = ios_base::cur; TOUCH(s3);
	chk(1);


	}
	end_chk("_XD2T11");
#else
	skip_chk("_XD2T11");
#endif /* CASE_XD2T11 */

/* _XD2T21 io_state is an integer type */
#if !defined(SKIP_XD2T21)&&(!defined(ONLY)||defined(CASE_XD2T21))
	begin_chk("_XD2T21");
	{
	ios_base::io_state s1 = 37;
	chk(s1 / 12 == 3);


	}
	end_chk("_XD2T21");
#else
	skip_chk("_XD2T21");
#endif /* CASE_XD2T21 */

/* _XD2T31 open_mode is an integer type */
#if !defined(SKIP_XD2T31)&&(!defined(ONLY)||defined(CASE_XD2T31))
	begin_chk("_XD2T31");
	{
	ios_base::open_mode s1 = 37;
	chk(s1 / 12 == 3);


	}
	end_chk("_XD2T31");
#else
	skip_chk("_XD2T31");
#endif /* CASE_XD2T31 */

/* _XD2T41 seek_dir is an integer type */
#if !defined(SKIP_XD2T41)&&(!defined(ONLY)||defined(CASE_XD2T41))
	begin_chk("_XD2T41");
	{
	ios_base::seek_dir s1 = 37;
	chk(s1 / 12 == 3);


	//### _XD2T51 basic_streambuf::stossc -- DELETED as optional
	//FILE-SCOPE:
	//#include <streambuf>
	//#if IS_EMBEDDED
	//typedef char_traits It_XD2T41;
	//typedef streambuf Bs_XD2T41;
	//#else /* IS_EMBEDDED */
	//typedef STD char_traits<char> It_XD2T41;
	//typedef STD basic_streambuf<char, It_XD2T41> Bs_XD2T41;
	//#endif /* IS_EMBEDDED */
	//char a_XD2T41[5];
	//class Mybuf_XD2T41 : public Bs_XD2T41 {
	//public:
	//	void pubsetg(char *beg, char *cur, char *end)
	//		{setg(beg, cur, end); }
	//	};
	//BLOCK-SCOPE:
	//Mybuf_XD2T41 buf;
	//a_XD2T41[0] = 'a';
	//a_XD2T41[1] = 'b';
	//buf.pubsetg(&a_XD2T41[0], &a_XD2T41[0], &a_XD2T41[5]);
	//buf.stossc();
	//ieq(buf.sgetc(), a_XD2T41[1]);
	//

	}
	end_chk("_XD2T41");
#else
	skip_chk("_XD2T41");
#endif /* CASE_XD2T41 */

/* _XD2T61 overloads on io_state, open_mode, seek_dir, declaration */
#if !defined(SKIP_XD2T61)&&(!defined(ONLY)||defined(CASE_XD2T61))
	begin_chk("_XD2T61");
	{
	typedef char Char;	// override flexible character type for strstream only
	Bi x(STD cin.rdbuf());
	x.clear((Bi::io_state)Bi::failbit);
	chk(x.rdstate() == Bi::failbit);
	x.setstate((Bi::io_state)Bi::badbit);
	chk(x.rdstate() == (Bi::badbit | Bi::failbit));
	x.clear();
	x.exceptions((Bi::io_state)Bi::badbit);
	chk(x.exceptions() == Bi::badbit);
	Mybuf_XD2T61 buf;
	Bs_XD2T61::pos_type pt = buf.pubseekoff((Bs_XD2T61::off_type)5,
		(STD ios_base::seek_dir)ios_base::cur,
		(STD ios_base::open_mode)ios_base::in);
	pt = buf.pubseekpos(pt, (ios_base::open_mode)ios_base::in);
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, (STD ios_base::open_mode)(STD ios_base::out
		| STD ios_base::trunc));
	fbuf.close();
	Ifs istr;
	istr.open(tn, (STD ios_base::open_mode)(STD ios_base::out));
	istr.close();
	Ofs ostr;
	ostr.open(tn, (STD ios_base::open_mode)(STD ios_base::out));
	ostr.close();
	STD remove(tn);
	chk(1);










	}
	end_chk("_XD2T61");
#else
	skip_chk("_XD2T61");
#endif /* CASE_XD2T61 */

/* _XD31T11 strstreambuf definition */
#if !defined(SKIP_XD31T11)&&(!defined(ONLY)||defined(CASE_XD31T11))
	begin_chk("_XD31T11");
	{
	strstreambuf sb0;

	#if IS_EMBEDDED
	chk(1);
	#else /* IS_EMBEDDED */
	typedef STD strstream Iostr;	// ADDED [MAR96]
	Iostr::char_type *p9 = (char *)0; TOUCH(p9);
	Iostr::int_type *p10 = 0; TOUCH(p10);
	Iostr::pos_type *p11 = 0; TOUCH(p11);
	Iostr::off_type *p12 = 0; TOUCH(p12);

	char abc[] = "abc";
	Iostr iostr, iostr1(abc, 4, ios_base::in);
	int i = 37;
	iostr << i << endl;
	ieq(iostr.pcount(), 3);

	char *s = iostr.str();
	ieq(*s, '3');
	iostr.freeze(0);

	iostr.rdbuf()->pubseekoff(0, ios_base::beg);
	i = 0;
	iostr >> i;
	ieq(i, 37);
	#endif /* IS_EMBEDDED */


	}
	end_chk("_XD31T11");
#else
	skip_chk("_XD31T11");
#endif /* CASE_XD31T11 */

/* _XD311T21 strstreambuf::strstreambuf(streamsize) effects */
#if !defined(SKIP_XD311T21)&&(!defined(ONLY)||defined(CASE_XD311T21))
	begin_chk("_XD311T21");
	{
	strstreambuf sb0, sb1(0), sb2(32767);
	ieq(sb0.pcount(), 0);


	}
	end_chk("_XD311T21");
#else
	skip_chk("_XD311T21");
#endif /* CASE_XD311T21 */

/* _XD311T31 strstreambuf::strstreambuf(streamsize) postconditions */
#if !defined(SKIP_XD311T31)&&(!defined(ONLY)||defined(CASE_XD311T31))
	begin_chk("_XD311T31");
	{
	strstreambuf sb0;
	ieq(sb0.sputn("abcde", 5), 5);
	ieq(sb0.pcount(), 5);


	}
	end_chk("_XD311T31");
#else
	skip_chk("_XD311T31");
#endif /* CASE_XD311T31 */

/* _XD311T51 strstreambuf::strstreambuf(palloc, pfree) effects */
#if !defined(SKIP_XD311T51)&&(!defined(ONLY)||defined(CASE_XD311T51))
	begin_chk("_XD311T51");
	{
	strstreambuf sb0(&salloc_XD311T51, &sfree_XD311T51);
	ieq(sb0.pcount(), 0);


	}
	end_chk("_XD311T51");
#else
	skip_chk("_XD311T51");
#endif /* CASE_XD311T51 */

/* _XD311T61 strstreambuf::strstreambuf(palloc, pfree) postconditions */
#if !defined(SKIP_XD311T61)&&(!defined(ONLY)||defined(CASE_XD311T61))
	begin_chk("_XD311T61");
	{
	cnt1_XD311T61 = 0, cnt2_XD311T61 = 0;
		{strstreambuf sb0(&salloc_XD311T61, &sfree_XD311T61);
		ieq(sb0.sputn("abcde", 5), 5);
		ieq(sb0.pcount(), 5); }
	chk(0 < cnt1_XD311T61);
	chk(0 < cnt2_XD311T61);


	}
	end_chk("_XD311T61");
#else
	skip_chk("_XD311T61");
#endif /* CASE_XD311T61 */

/* _XD311T81 strstreambuf::strstreambuf(char *) effects */
#if !defined(SKIP_XD311T81)&&(!defined(ONLY)||defined(CASE_XD311T81))
	begin_chk("_XD311T81");
	{
	char a[20] = "abcde";
	streamsize n = 5;
	strstreambuf sb0(a, n), sb1(a, n, a);
	signed char sa[20] = "abcde";
	strstreambuf ssb0(sa, n), ssb1(sa, n, sa);
	unsigned char ua[20] = "abcde";
	strstreambuf usb0(ua, n), usb1(ua, n, ua);
	chk(1);


	}
	end_chk("_XD311T81");
#else
	skip_chk("_XD311T81");
#endif /* CASE_XD311T81 */

/* _XD311T91 strstreambuf::strstreambuf(char *) postconditions */
#if !defined(SKIP_XD311T91)&&(!defined(ONLY)||defined(CASE_XD311T91))
	begin_chk("_XD311T91");
	{
	char a[20] = "abcde";
	strstreambuf sb0(a, 5);
	chk(sb0.sputn("xyz", 3) != 3);
	signed char sa[20] = "abcde";
	strstreambuf ssb0(sa, 5);
	chk(ssb0.sputn("xyz", 3) != 3);
	unsigned char ua[20] = "abcde"; TOUCH(ua);
	strstreambuf usb0(a, 5);
	chk(usb0.sputn("xyz", 3) != 3);


	}
	end_chk("_XD311T91");
#else
	skip_chk("_XD311T91");
#endif /* CASE_XD311T91 */

/* _XD311T_111 strstreambuf::strstreambuf(char *), pbeg_arg is null */
#if !defined(SKIP_XD311T_111)&&(!defined(ONLY)||defined(CASE_XD311T_111))
	begin_chk("_XD311T_111");
	{
	char a[20] = "abcde";
	char b[20];
	strstreambuf sb0(a, 5, 0);
	ieq(sb0.sgetn(b, 20), 5);
	ieq(STD memcmp(a, b, 5), 0);
	ieq(sb0.sputbackc('x'), 'x');
	ieq(sb0.sgetc(), 'x');
	signed char sa[20] = "fghij";
	strstreambuf ssb0(sa, 0, 0);
	ieq(ssb0.sgetn(b, 20), 5);
	ieq(STD memcmp(sa, b, 5), 0);
	unsigned char ua[20] = "klmno";
	strstreambuf usb0(ua, -1, 0);
	ieq(usb0.sgetn(b, 20), 20);
	ieq(STD memcmp(ua, b, 20), 0);



	}
	end_chk("_XD311T_111");
#else
	skip_chk("_XD311T_111");
#endif /* CASE_XD311T_111 */

/* _XD311T_121 strstreambuf::strstreambuf(char *), pbeg_arg not null */
#if !defined(SKIP_XD311T_121)&&(!defined(ONLY)||defined(CASE_XD311T_121))
	begin_chk("_XD311T_121");
	{
	char a[20] = "abcde";
	char b[20];
	strstreambuf sb0(a, 0, a);
	ieq(sb0.sputc('x'), 'x');
	ieq(sb0.sbumpc(), 'x');
	ieq(sb0.sgetn(b, 20), 4);
	ieq(STD memcmp(a + 1, b, 4), 0);
	signed char sa[20] = "fghij";
	strstreambuf ssb0(sa, 20, sa + 1);
	ieq(ssb0.sputc('x'), 'x');
	ieq(ssb0.sbumpc(), 'f');
	ieq(ssb0.sbumpc(), 'x');
	ieq(ssb0.sgetn(b, 20), 18);
	ieq(STD memcmp(sa + 2, b, 18), 0);
	unsigned char ua[20] = "klmno";
	strstreambuf usb0(ua, 20, ua + 2);
	ieq(usb0.sputc('x'), 'x');
	ieq(usb0.sbumpc(), 'k');
	ieq(usb0.sbumpc(), 'l');
	ieq(usb0.sbumpc(), 'x');
	ieq(usb0.sgetc(), 'n');


	}
	end_chk("_XD311T_121");
#else
	skip_chk("_XD311T_121");
#endif /* CASE_XD311T_121 */

/* _XD311T_141 strstreambuf::strstreambuf(const char *), effects */
#if !defined(SKIP_XD311T_141)&&(!defined(ONLY)||defined(CASE_XD311T_141))
	begin_chk("_XD311T_141");
	{
	const char a[20] = "abcde";
	char b[20];
	strstreambuf sb0(a, 5);
	ieq(sb0.sgetn(b, 20), 5);
	ieq(STD memcmp(a, b, 5), 0);
	ieq(sb0.sputbackc('y'), EOF);
	const signed char sa[20] = "fghij";
	strstreambuf ssb0(sa, 0);
	ieq(ssb0.sgetn(b, 20), 5);
	ieq(STD memcmp(sa, b, 5), 0);
	const unsigned char ua[20] = "klmno";
	strstreambuf usb0(&ua[0], -1);
	ieq(usb0.sgetn(&b[0], 20), 20);
	ieq(STD memcmp(&ua[0], &b[0], 20), 0);


	}
	end_chk("_XD311T_141");
#else
	skip_chk("_XD311T_141");
#endif /* CASE_XD311T_141 */

/* _XD311T_161 strstreambuf::~strstreambuf() frees object */
#if !defined(SKIP_XD311T_161)&&(!defined(ONLY)||defined(CASE_XD311T_161))
	begin_chk("_XD311T_161");
	{
	strstreambuf *p = new strstreambuf(&salloc_XD311T_161, &sfree_XD311T_161);
	cnt2_XD311T_161 = 0;
	delete p;
	ieq(cnt2_XD311T_161, 0);
	p = new strstreambuf(&salloc_XD311T_161, &sfree_XD311T_161);
	p->sputn("abcde", 5);
	cnt2_XD311T_161 = 0;
	delete p;
	chk(0 < cnt2_XD311T_161);
	p = new strstreambuf(&salloc_XD311T_161, &sfree_XD311T_161);
	p->sputn("abcde", 5);
	char *s = p->str();
	cnt2_XD311T_161 = 0;
	delete p;
	ieq(cnt2_XD311T_161, 0);
	delete s;

	}
	end_chk("_XD311T_161");
#else
	skip_chk("_XD311T_161");
#endif /* CASE_XD311T_161 */

return leave_chk("txd0");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\t27j.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"

#if IS_EMBEDDED
#define ONLY
#define CASE_2781T11	<fstream> synopsis
#define CASE_27811T11	basic_filebuf definition
#define CASE_27811T31	basic_filebuf restrictions, must open for reading to read
#define CASE_27811T32	basic_filebuf restrictions, must open for writing to write
#define CASE_27811T33	basic_filebuf restrictions, streams positioned jointly
//#define CASE_27811T42	basic_filebuf restrictions, codecvt converts input
//#define CASE_27811T43	basic_filebuf restrictions, codecvt converts output
#define CASE_27812T21	basic_filebuf::basic_filebuf effects
#define CASE_27812T31	basic_filebuf::basic_filebuf postcondition
#define CASE_27812T52	basic_filebuf::~basic_filebuf calls close
#define CASE_27813T21	basic_filebuf::is_open returns
#define CASE_27813T23	basic_filebuf::open effects, is_open() is true
#define CASE_27813T24	basic_filebuf::open effects, open modes
#define CASE_27813T31	basic_filebuf::open effects, positions at end
#define CASE_27813T41	basic_filebuf::open effects, positioning fails
#define CASE_27813T51	basic_filebuf::open returns
#define CASE_27813T71	basic_filebuf::close effects, is_open() == false
#define CASE_27813T72	basic_filebuf::close effects, calls fclose
#define CASE_27813T81	basic_filebuf::close returns
#define CASE_27813T91	basic_filebuf::close postcondition
#endif /* IS_EMBEDDED */

/* _2781T11 <fstream> synopsis */
#if !defined(SKIP_2781T11)&&(!defined(ONLY)||defined(CASE_2781T11))
#include <fstream>
#endif /* CASE_2781T11 */

/* _27811T11 basic_filebuf definition */
#if !defined(SKIP_27811T11)&&(!defined(ONLY)||defined(CASE_27811T11))
#include <fstream>
#endif /* CASE_27811T11 */

/* _27811T31 basic_filebuf restrictions, must open for reading to read */
#if !defined(SKIP_27811T31)&&(!defined(ONLY)||defined(CASE_27811T31))
#include <fstream>
#endif /* CASE_27811T31 */

/* _27811T32 basic_filebuf restrictions, must open for writing to write */
#if !defined(SKIP_27811T32)&&(!defined(ONLY)||defined(CASE_27811T32))
#include <fstream>
#endif /* CASE_27811T32 */

/* _27811T33 basic_filebuf restrictions, streams positioned jointly */
#if !defined(SKIP_27811T33)&&(!defined(ONLY)||defined(CASE_27811T33))
#include <fstream>
#endif /* CASE_27811T33 */

/* _27811T42 basic_filebuf restrictions, codecvt converts input */
#if !defined(SKIP_27811T42)&&(!defined(ONLY)||defined(CASE_27811T42))
#include <cctype>
#include <fstream>
#include <locale>
typedef codecvt<char, char, mbstate_t> Cvtcc_27811T42;
int cnt_27811T42;
class Mycvtcc_27811T42 : public Cvtcc_27811T42 {
protected:
	virtual result do_in(mbstate_t& st,	// ADDED [JUL96]
		const char *f1, const char *l1, const char *& m1,
		char *f2, char *l2, char *& m2) const
		{return (do_out(st, f1, l1, m1, f2, l2, m2)); }
	virtual result do_out(mbstate_t&,
		const char *f1, const char *l1, const char *& m1,
		char *f2, char *l2, char *& m2) const
		{m1 = f1, m2 = f2;
		cnt_27811T42 |= 1;
		if (m1 == l1 || m2 == l2)
			return (partial);
		*m2++ = *m1++;
		return (ok); }
	virtual bool do_always_noconv() const THROW0()
		{return (false); }
	};
#endif /* CASE_27811T42 */

/* _27811T43 basic_filebuf restrictions, codecvt converts output */
#if !defined(SKIP_27811T43)&&(!defined(ONLY)||defined(CASE_27811T43))
#include <cctype>
#include <fstream>
#include <locale>
typedef codecvt<char, char, mbstate_t> Cvtcc_27811T43;
int cnt_27811T43;
class Mycvtcc_27811T43 : public Cvtcc_27811T43 {
protected:
	virtual result do_in(mbstate_t& st,	// ADDED [JUL96]
		const char *f1, const char *l1, const char *& m1,
		char *f2, char *l2, char *& m2) const
		{return (do_out(st, f1, l1, m1, f2, l2, m2)); }
	virtual result do_out(mbstate_t&,
		const char *f1, const char *l1, const char *& m1,
		char *f2, char *l2, char *& m2) const
		{m1 = f1, m2 = f2;
		cnt_27811T43 |= 1;
		if (m1 == l1 || m2 == l2)
			return (partial);
		*m2++ = *m1++;
		return (ok); }
	virtual bool do_always_noconv() const THROW0()
		{return (false); }
	};
#endif /* CASE_27811T43 */

/* _27812T21 basic_filebuf::basic_filebuf effects */
#if !defined(SKIP_27812T21)&&(!defined(ONLY)||defined(CASE_27812T21))
#include <fstream>
#endif /* CASE_27812T21 */

/* _27812T31 basic_filebuf::basic_filebuf postcondition */
#if !defined(SKIP_27812T31)&&(!defined(ONLY)||defined(CASE_27812T31))
#include <fstream>
#endif /* CASE_27812T31 */

/* _27812T52 basic_filebuf::~basic_filebuf calls close */
#if !defined(SKIP_27812T52)&&(!defined(ONLY)||defined(CASE_27812T52))
#include <fstream>
#endif /* CASE_27812T52 */

/* _27813T21 basic_filebuf::is_open returns */
#if !defined(SKIP_27813T21)&&(!defined(ONLY)||defined(CASE_27813T21))
#include <fstream>
#endif /* CASE_27813T21 */

/* _27813T23 basic_filebuf::open effects, is_open() is true */
#if !defined(SKIP_27813T23)&&(!defined(ONLY)||defined(CASE_27813T23))
#include <fstream>
#endif /* CASE_27813T23 */

/* _27813T24 basic_filebuf::open effects, open modes */
#if !defined(SKIP_27813T24)&&(!defined(ONLY)||defined(CASE_27813T24))
#include <fstream>
#endif /* CASE_27813T24 */

/* _27813T31 basic_filebuf::open effects, positions at end */
#if !defined(SKIP_27813T31)&&(!defined(ONLY)||defined(CASE_27813T31))
#include <fstream>
#endif /* CASE_27813T31 */

/* _27813T41 basic_filebuf::open effects, positioning fails */
#if !defined(SKIP_27813T41)&&(!defined(ONLY)||defined(CASE_27813T41))
#include <fstream>
#endif /* CASE_27813T41 */

/* _27813T51 basic_filebuf::open returns */
#if !defined(SKIP_27813T51)&&(!defined(ONLY)||defined(CASE_27813T51))
#include <fstream>
#endif /* CASE_27813T51 */

/* _27813T71 basic_filebuf::close effects, is_open() == false */
#if !defined(SKIP_27813T71)&&(!defined(ONLY)||defined(CASE_27813T71))
#include <fstream>
#endif /* CASE_27813T71 */

/* _27813T72 basic_filebuf::close effects, calls fclose */
#if !defined(SKIP_27813T72)&&(!defined(ONLY)||defined(CASE_27813T72))
#include <cstdio>
#include <fstream>
#endif /* CASE_27813T72 */

/* _27813T81 basic_filebuf::close returns */
#if !defined(SKIP_27813T81)&&(!defined(ONLY)||defined(CASE_27813T81))
#include <fstream>
#endif /* CASE_27813T81 */

/* _27813T91 basic_filebuf::close postcondition */
#if !defined(SKIP_27813T91)&&(!defined(ONLY)||defined(CASE_27813T91))
#include <fstream>
#endif /* CASE_27813T91 */

int t27j_main(int, char *[])
{
enter_chk("t27j.cpp");
/* _2781T11 <fstream> synopsis */
#if !defined(SKIP_2781T11)&&(!defined(ONLY)||defined(CASE_2781T11))
	begin_chk("_2781T11");
	{
	#if IS_EMBEDDED
	filebuf *p1 = 0; TOUCH(p1);
	ifstream *p3 = 0; TOUCH(p3);
	ofstream *p5 = 0; TOUCH(p5);
	chk(1);
	#else /* IS_EMBEDDED */
	basic_filebuf<char, char_traits<char> > *p1 = 0; TOUCH(p1);
	filebuf *p2 = p1; TOUCH(p2);
	basic_ifstream<char, char_traits<char> > *p3 = 0; TOUCH(p3);
	ifstream *p4 = p3; TOUCH(p4);
	basic_ofstream<char, char_traits<char> > *p5 = 0; TOUCH(p5);
	ofstream *p6 = p5; TOUCH(p6);
	basic_filebuf<wchar_t, char_traits<wchar_t> > *pw1 = 0; TOUCH(pw1);
	wfilebuf *pw2 = pw1; TOUCH(pw2);
	basic_ifstream<wchar_t, char_traits<wchar_t> > *pw3 = 0; TOUCH(pw3);
	wifstream *pw4 = pw3; TOUCH(pw4);
	basic_ofstream<wchar_t, char_traits<wchar_t> > *pw5 = 0; TOUCH(pw5);
	wofstream *pw6 = pw5; TOUCH(pw6);

	fstream *p7 = (basic_fstream<char, char_traits<char> > *)0; TOUCH(p7);
	wfstream *p8 = (basic_fstream<wchar_t, char_traits<wchar_t> > *)0; TOUCH(p8);

	typedef STD basic_fstream<Char, It> Iostr;	// ADDED [MAR96]
	Iostr::traits_type *ptt = (It *)0; TOUCH(ptt);	// ADDED [JUL96]
	Iostr::char_type *p9 = (Char *)0; TOUCH(p9);
	Iostr::int_type *p10 = 0; TOUCH(p10);
	Iostr::pos_type *p11 = 0; TOUCH(p11);
	Iostr::off_type *p12 = 0; TOUCH(p12);

	const char *tn = "d:\\abc"; // STD tmpnam(0);
	int i = 37;
		{Iostr iostr1(tn, ios_base::out | ios_base::trunc);
		chk(iostr1.is_open());
		iostr1 << i << endl; }
	Iostr iostr;
	iostr.open(tn);
	chk(iostr.is_open());
	iostr.rdbuf()->pubseekoff(0, ios_base::cur);
	i = 0;
	iostr >> i;
	ieq(i, 37);

	iostr.close();
	STD remove(tn);
	#endif /* IS_EMBEDDED */


	}
	end_chk("_2781T11");
#else
	skip_chk("_2781T11");
#endif /* CASE_2781T11 */

/* _27811T11 basic_filebuf definition */
#if !defined(SKIP_27811T11)&&(!defined(ONLY)||defined(CASE_27811T11))
	begin_chk("_27811T11");
	{
	Bfs fbuf;
	Bs *p = &fbuf; TOUCH(p);
	Bfs::traits_type *ptt = (It *)0; TOUCH(ptt);	// ADDED [JUL96]
	Bfs::char_type *pct = (Char *)0; TOUCH(pct);
	Bfs::int_type *pit = (It::int_type *)0; TOUCH(pit);
	Bfs::pos_type *pst = (It::pos_type *)0; TOUCH(pst);
	Bfs::off_type *pot = (It::off_type *)0; TOUCH(pot);
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.is_open());
	fbuf.close();
	STD remove(tn);



	}
	end_chk("_27811T11");
#else
	skip_chk("_27811T11");
#endif /* CASE_27811T11 */

/* _27811T31 basic_filebuf restrictions, must open for reading to read */
#if !defined(SKIP_27811T31)&&(!defined(ONLY)||defined(CASE_27811T31))
	begin_chk("_27811T31");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.sputc(It::to_int_type((Char)'a')) == It::to_int_type((Char)'a'));
	chk(fbuf.sputc(It::to_int_type((Char)'b')) == It::to_int_type((Char)'b'));
	chk(fbuf.sputc(It::to_int_type((Char)'\n')) == It::to_int_type((Char)'\n'));
	fbuf.close();
	fbuf.open(tn, STD ios_base::out | STD ios_base::app);
	chk(fbuf.sgetc() == It::eof());
	fbuf.close();
	STD remove(tn);


	}
	end_chk("_27811T31");
#else
	skip_chk("_27811T31");
#endif /* CASE_27811T31 */

/* _27811T32 basic_filebuf restrictions, must open for writing to write */
#if !defined(SKIP_27811T32)&&(!defined(ONLY)||defined(CASE_27811T32))
	begin_chk("_27811T32");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.sputc(It::to_int_type((Char)'a')) == It::to_int_type((Char)'a'));
	chk(fbuf.sputc(It::to_int_type((Char)'b')) == It::to_int_type((Char)'b'));
	chk(fbuf.sputc(It::to_int_type((Char)'\n')) == It::to_int_type((Char)'\n'));
	fbuf.close();
	fbuf.open(tn, STD ios_base::in);
	chk(fbuf.sputc(It::to_int_type((Char)'a')) == It::eof());
	fbuf.close();
	STD remove(tn);


	}
	end_chk("_27811T32");
#else
	skip_chk("_27811T32");
#endif /* CASE_27811T32 */

/* _27811T33 basic_filebuf restrictions, streams positioned jointly */
#if !defined(SKIP_27811T33)&&(!defined(ONLY)||defined(CASE_27811T33))
	begin_chk("_27811T33");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, STD ios_base::binary | STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.sputc(It::to_int_type((Char)'a')) == It::to_int_type((Char)'a'));
	chk(fbuf.sputc(It::to_int_type((Char)'b')) == It::to_int_type((Char)'b'));
	chk(fbuf.sputc(It::to_int_type((Char)'\n')) == It::to_int_type((Char)'\n'));
	fbuf.close();
	fbuf.open(tn, STD ios_base::binary | STD ios_base::in | STD ios_base::out);
	fbuf.pubseekoff(1, STD ios_base::beg, STD ios_base::out);
	chk(fbuf.sgetc() == It::to_int_type((Char)'b'));
	fbuf.pubseekoff(0, STD ios_base::beg, STD ios_base::in);
	chk(fbuf.sputc(It::to_int_type((Char)'x')) == It::to_int_type((Char)'x'));
	fbuf.pubseekoff(0, STD ios_base::beg, STD ios_base::out);
	chk(fbuf.sgetc() == It::to_int_type((Char)'x'));
	fbuf.close();
	STD remove(tn);


	}
	end_chk("_27811T33");
#else
	skip_chk("_27811T33");
#endif /* CASE_27811T33 */

/* _27811T42 basic_filebuf restrictions, codecvt converts input */
#if !defined(SKIP_27811T42)&&(!defined(ONLY)||defined(CASE_27811T42))
	begin_chk("_27811T42");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.sputc(It::to_int_type((Char)'a')) == It::to_int_type((Char)'a'));
	chk(fbuf.sputc(It::to_int_type((Char)'b')) == It::to_int_type((Char)'b'));
	chk(fbuf.sputc(It::to_int_type((Char)'\n')) == It::to_int_type((Char)'\n'));
	fbuf.close();
	Bfs fbufx;
	fbufx.pubimbue(ADDFAC(STD locale::classic(), new Mycvtcc_27811T42));
	cnt_27811T42 = 0;
	fbufx.open(tn, STD ios_base::in);
	fbufx.sbumpc();
	ieq(cnt_27811T42, 1);
	fbuf.close();
	STD remove(tn);


	}
	end_chk("_27811T42");
#else
	skip_chk("_27811T42");
#endif /* CASE_27811T42 */

/* _27811T43 basic_filebuf restrictions, codecvt converts output */
#if !defined(SKIP_27811T43)&&(!defined(ONLY)||defined(CASE_27811T43))
	begin_chk("_27811T43");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.pubimbue(ADDFAC(STD locale::classic(), new Mycvtcc_27811T43));
	cnt_27811T43 = 0;
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.sputc(It::to_int_type((Char)'a')) == It::to_int_type((Char)'a'));
	chk(fbuf.sputc(It::to_int_type((Char)'b')) == It::to_int_type((Char)'b'));
	chk(fbuf.sputc(It::to_int_type((Char)'\n')) == It::to_int_type((Char)'\n'));
	fbuf.close();
	ieq(cnt_27811T43, 1);
	STD remove(tn);


	}
	end_chk("_27811T43");
#else
	skip_chk("_27811T43");
#endif /* CASE_27811T43 */

/* _27812T21 basic_filebuf::basic_filebuf effects */
#if !defined(SKIP_27812T21)&&(!defined(ONLY)||defined(CASE_27812T21))
	begin_chk("_27812T21");
	{
	Bfs fbuf;
	chk(fbuf.sgetc() == It::eof());
	chk(fbuf.getloc() == locale());


	}
	end_chk("_27812T21");
#else
	skip_chk("_27812T21");
#endif /* CASE_27812T21 */

/* _27812T31 basic_filebuf::basic_filebuf postcondition */
#if !defined(SKIP_27812T31)&&(!defined(ONLY)||defined(CASE_27812T31))
	begin_chk("_27812T31");
	{
	Bfs fbuf;
	chk(!fbuf.is_open());


	}
	end_chk("_27812T31");
#else
	skip_chk("_27812T31");
#endif /* CASE_27812T31 */

/* _27812T52 basic_filebuf::~basic_filebuf calls close */
#if !defined(SKIP_27812T52)&&(!defined(ONLY)||defined(CASE_27812T52))
	begin_chk("_27812T52");
	{
	Bfs *p = new Bfs;
	#if IS_EMBEDDED
	p->DESTRUCTOR(filebuf, Bfs);
	#else /* IS_EMBEDDED */
	p->DESTRUCTOR(basic_filebuf, Bfs);
	#endif /* IS_EMBEDDED */
	chk(1);



	}
	end_chk("_27812T52");
#else
	skip_chk("_27812T52");
#endif /* CASE_27812T52 */

/* _27813T21 basic_filebuf::is_open returns */
#if !defined(SKIP_27813T21)&&(!defined(ONLY)||defined(CASE_27813T21))
	begin_chk("_27813T21");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	chk(!fbuf.is_open());
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.is_open());
	fbuf.close();
	chk(!fbuf.is_open());
	STD remove(tn);



	}
	end_chk("_27813T21");
#else
	skip_chk("_27813T21");
#endif /* CASE_27813T21 */

/* _27813T23 basic_filebuf::open effects, is_open() is true */
#if !defined(SKIP_27813T23)&&(!defined(ONLY)||defined(CASE_27813T23))
	begin_chk("_27813T23");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.open(STD tmpnam(0), STD ios_base::out | STD ios_base::trunc) == 0);
	fbuf.close();
	STD remove(tn);





	}
	end_chk("_27813T23");
#else
	skip_chk("_27813T23");
#endif /* CASE_27813T23 */

/* _27813T24 basic_filebuf::open effects, open modes */
#if !defined(SKIP_27813T24)&&(!defined(ONLY)||defined(CASE_27813T24))
	begin_chk("_27813T24");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, STD ios_base::out);
	chk(fbuf.is_open());
	fbuf.close();
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.is_open());
	fbuf.sputc(It::to_int_type((Char)'a'));
	fbuf.sputc(It::to_int_type((Char)'b'));
	fbuf.sputc(It::to_int_type((Char)'\n'));
	fbuf.close();
	fbuf.open(tn, STD ios_base::in);
	chk(fbuf.is_open());
	fbuf.close();
	fbuf.open(tn, STD ios_base::out | STD ios_base::app);
	chk(fbuf.is_open());
	fbuf.close();
	fbuf.open(tn, STD ios_base::in | STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.is_open());
	fbuf.sputc(It::to_int_type((Char)'a'));
	fbuf.sputc(It::to_int_type((Char)'b'));
	fbuf.sputc(It::to_int_type((Char)'\n'));
	fbuf.close();
	fbuf.open(tn, STD ios_base::in | STD ios_base::out);
	chk(fbuf.is_open());
	fbuf.close();
	fbuf.open(tn, STD ios_base::in | STD ios_base::out | STD ios_base::app);
	chk(fbuf.is_open());
	fbuf.close();
	fbuf.open(tn, STD ios_base::out
		| STD ios_base::binary);
	chk(fbuf.is_open());
	fbuf.close();
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc
		| STD ios_base::binary);
	chk(fbuf.is_open());
	fbuf.sputc(It::to_int_type((Char)'a'));
	fbuf.sputc(It::to_int_type((Char)'b'));
	fbuf.sputc(It::to_int_type((Char)'\n'));
	fbuf.close();
	fbuf.open(tn, STD ios_base::in
		| STD ios_base::binary);
	chk(fbuf.is_open());
	fbuf.close();
	fbuf.open(tn, STD ios_base::out | STD ios_base::app
		| STD ios_base::binary);
	chk(fbuf.is_open());
	fbuf.close();
	fbuf.open(tn, STD ios_base::in | STD ios_base::out | STD ios_base::trunc
		| STD ios_base::binary);
	chk(fbuf.is_open());
	fbuf.sputc(It::to_int_type((Char)'a'));
	fbuf.sputc(It::to_int_type((Char)'b'));
	fbuf.sputc(It::to_int_type((Char)'\n'));
	fbuf.close();
	fbuf.open(tn, STD ios_base::in | STD ios_base::out
		| STD ios_base::binary);
	chk(fbuf.is_open());
	fbuf.close();
	fbuf.open(tn, STD ios_base::in | STD ios_base::out | STD ios_base::app
		| STD ios_base::binary);
	chk(fbuf.is_open());
	fbuf.close();
	STD remove(tn);


	}
	end_chk("_27813T24");
#else
	skip_chk("_27813T24");
#endif /* CASE_27813T24 */

/* _27813T31 basic_filebuf::open effects, positions at end */
#if !defined(SKIP_27813T31)&&(!defined(ONLY)||defined(CASE_27813T31))
	begin_chk("_27813T31");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	fbuf.sputc(It::to_int_type((Char)'a'));
	fbuf.sputc(It::to_int_type((Char)'b'));
	fbuf.sputc(It::to_int_type((Char)'\n'));
	fbuf.close();
	fbuf.open(tn, STD ios_base::in | STD ios_base::ate);
	chk(fbuf.is_open());
	chk(fbuf.sgetc() == It::eof());
	fbuf.pubseekoff(0, STD ios_base::beg);
	chk(fbuf.sgetc() == It::to_int_type((Char)'a'));
	fbuf.close();
	STD remove(tn);


	}
	end_chk("_27813T31");
#else
	skip_chk("_27813T31");
#endif /* CASE_27813T31 */

/* _27813T41 basic_filebuf::open effects, positioning fails */
#if !defined(SKIP_27813T41)&&(!defined(ONLY)||defined(CASE_27813T41))
	begin_chk("_27813T41");
	{
	// UNTESTABLE
	chk(1);


	}
	end_chk("_27813T41");
#else
	skip_chk("_27813T41");
#endif /* CASE_27813T41 */

/* _27813T51 basic_filebuf::open returns */
#if !defined(SKIP_27813T51)&&(!defined(ONLY)||defined(CASE_27813T51))
	begin_chk("_27813T51");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	chk(fbuf.open(tn, STD ios_base::out | STD ios_base::trunc) == &fbuf);
	chk(fbuf.open(STD tmpnam(0),
		STD ios_base::out | STD ios_base::trunc) == 0);
	fbuf.close();
	STD remove(tn);


	}
	end_chk("_27813T51");
#else
	skip_chk("_27813T51");
#endif /* CASE_27813T51 */

/* _27813T71 basic_filebuf::close effects, is_open() == false */
#if !defined(SKIP_27813T71)&&(!defined(ONLY)||defined(CASE_27813T71))
	begin_chk("_27813T71");
	{
	Bfs fbuf;
	chk(fbuf.close() == 0);


	}
	end_chk("_27813T71");
#else
	skip_chk("_27813T71");
#endif /* CASE_27813T71 */

/* _27813T72 basic_filebuf::close effects, calls fclose */
#if !defined(SKIP_27813T72)&&(!defined(ONLY)||defined(CASE_27813T72))
	begin_chk("_27813T72");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	chk(fbuf.open(tn, STD ios_base::out | STD ios_base::trunc) == &fbuf);
	fbuf.close();
	STD FILE *pf = STD fopen(tn, "w");
	chk(pf != 0);
	fclose(pf);
	STD remove(tn);


	}
	end_chk("_27813T72");
#else
	skip_chk("_27813T72");
#endif /* CASE_27813T72 */

/* _27813T81 basic_filebuf::close returns */
#if !defined(SKIP_27813T81)&&(!defined(ONLY)||defined(CASE_27813T81))
	begin_chk("_27813T81");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	chk(fbuf.close() == &fbuf);
	chk(fbuf.close() == 0);
	STD remove(tn);


	}
	end_chk("_27813T81");
#else
	skip_chk("_27813T81");
#endif /* CASE_27813T81 */

/* _27813T91 basic_filebuf::close postcondition */
#if !defined(SKIP_27813T91)&&(!defined(ONLY)||defined(CASE_27813T91))
	begin_chk("_27813T91");
	{
	Bfs fbuf;
	const char *tn = STD tmpnam(0);
	fbuf.open(tn, STD ios_base::out | STD ios_base::trunc);
	fbuf.close();
	chk(!fbuf.is_open());
	STD remove(tn);

	}
	end_chk("_27813T91");
#else
	skip_chk("_27813T91");
#endif /* CASE_27813T91 */

return leave_chk("t27j");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\txd2.cpp ===
/*  Dinkum(R) C++ Proofer(TM)
 *  Copyright (C) 1995-2001 by P.J. Plauger. All rights reserved.
 *  This program is the property of P.J. Plauger. Its contents are
 *  proprietary information. No part of it is to be disclosed to anyone
 *  except employees of Dinkumware, Ltd., or as agreed in writing with
 *  Dinkumware, Ltd.
 */
#include "defs.h"


/* _XD32T11 istrstream definition */
#if !defined(SKIP_XD32T11)&&(!defined(ONLY)||defined(CASE_XD32T11))
#include <strstream>
#endif /* CASE_XD32T11 */

/* _XD321T21 istrstream::istrstream(const char *) */
#if !defined(SKIP_XD321T21)&&(!defined(ONLY)||defined(CASE_XD321T21))
#include <strstream>
#endif /* CASE_XD321T21 */

/* _XD321T41 istrstream::istrstream(const char *, streamsize) */
#if !defined(SKIP_XD321T41)&&(!defined(ONLY)||defined(CASE_XD321T41))
#include <strstream>
#endif /* CASE_XD321T41 */

/* _XD322T21 istrstream::rdbuf */
#if !defined(SKIP_XD322T21)&&(!defined(ONLY)||defined(CASE_XD322T21))
#include <strstream>
#endif /* CASE_XD322T21 */

/* _XD322T41 istrstream::str */
#if !defined(SKIP_XD322T41)&&(!defined(ONLY)||defined(CASE_XD322T41))
#include <strstream>
#endif /* CASE_XD322T41 */

/* _XD33T11 ostrstream definition */
#if !defined(SKIP_XD33T11)&&(!defined(ONLY)||defined(CASE_XD33T11))
#include <strstream>
#endif /* CASE_XD33T11 */

/* _XD331T21 ostrstream::ostrstream() */
#if !defined(SKIP_XD331T21)&&(!defined(ONLY)||defined(CASE_XD331T21))
#include <strstream>
#endif /* CASE_XD331T21 */

/* _XD331T43 ostrstream::ostrstream(char *, int, openmode), mode & app == 0 */
#if !defined(SKIP_XD331T43)&&(!defined(ONLY)||defined(CASE_XD331T43))
#include <strstream>
#endif /* CASE_XD331T43 */

/* _XD331T45 ostrstream::ostrstream(char *, int, openmode), mode & app != 0 */
#if !defined(SKIP_XD331T45)&&(!defined(ONLY)||defined(CASE_XD331T45))
#include <strstream>
#endif /* CASE_XD331T45 */

/* _XD332T21 ostrstream::rdbuf */
#if !defined(SKIP_XD332T21)&&(!defined(ONLY)||defined(CASE_XD332T21))
#include <strstream>
#endif /* CASE_XD332T21 */

/* _XD332T41 ostrstream::freeze */
#if !defined(SKIP_XD332T41)&&(!defined(ONLY)||defined(CASE_XD332T41))
#include <strstream>
#endif /* CASE_XD332T41 */

/* _XD332T61 ostrstream::str */
#if !defined(SKIP_XD332T61)&&(!defined(ONLY)||defined(CASE_XD332T61))
#include <strstream>
#endif /* CASE_XD332T61 */

/* _XD332T81 ostrstream::pcount */
#if !defined(SKIP_XD332T81)&&(!defined(ONLY)||defined(CASE_XD332T81))
#include <strstream>
#endif /* CASE_XD332T81 */

int txd2_main(int, char *[])
{
enter_chk("txd2.cpp");
/* _XD32T11 istrstream definition */
#if !defined(SKIP_XD32T11)&&(!defined(ONLY)||defined(CASE_XD32T11))
	begin_chk("_XD32T11");
	{
	istrstream is("abc");
	chk(1);


	}
	end_chk("_XD32T11");
#else
	skip_chk("_XD32T11");
#endif /* CASE_XD32T11 */

/* _XD321T21 istrstream::istrstream(const char *) */
#if !defined(SKIP_XD321T21)&&(!defined(ONLY)||defined(CASE_XD321T21))
	begin_chk("_XD321T21");
	{
	const char *s1 = "abc";
	char *s2 = "def";
	istrstream is1(s1);
	ieq(is1.get(), 'a');
	ieq(is1.rdbuf()->sputc('x'), EOF);
	ieq(is1.rdbuf()->pubseekoff(0, ios::end, ios::in) - streampos(0), 3);
	istrstream is2(s2);
	ieq(is2.get(), 'd');
	ieq(is2.rdbuf()->sputc('x'), EOF);
	ieq(is2.rdbuf()->pubseekoff(0, ios::end, ios::in) - streampos(0), 3);


	}
	end_chk("_XD321T21");
#else
	skip_chk("_XD321T21");
#endif /* CASE_XD321T21 */

/* _XD321T41 istrstream::istrstream(const char *, streamsize) */
#if !defined(SKIP_XD321T41)&&(!defined(ONLY)||defined(CASE_XD321T41))
	begin_chk("_XD321T41");
	{
	const char *s1 = "abc";
	istrstream is1(s1, 2);
	ieq(is1.get(), 'a');
	ieq(is1.rdbuf()->sputc('x'), EOF);
	ieq(is1.rdbuf()->pubseekoff(0, ios::end, ios::in) - streampos(0), 2);


	}
	end_chk("_XD321T41");
#else
	skip_chk("_XD321T41");
#endif /* CASE_XD321T41 */

/* _XD322T21 istrstream::rdbuf */
#if !defined(SKIP_XD322T21)&&(!defined(ONLY)||defined(CASE_XD322T21))
	begin_chk("_XD322T21");
	{
	istrstream is1("abc");
	strstreambuf *p = is1.rdbuf();
	const char *s = p->str();
	steq(s, "abc");
	p->freeze(false);


	}
	end_chk("_XD322T21");
#else
	skip_chk("_XD322T21");
#endif /* CASE_XD322T21 */

/* _XD322T41 istrstream::str */
#if !defined(SKIP_XD322T41)&&(!defined(ONLY)||defined(CASE_XD322T41))
	begin_chk("_XD322T41");
	{
	const char *s1 = "abc";
	istrstream is1(s1);
	char *s = is1.str();
	steq(s, s1);








	}
	end_chk("_XD322T41");
#else
	skip_chk("_XD322T41");
#endif /* CASE_XD322T41 */

/* _XD33T11 ostrstream definition */
#if !defined(SKIP_XD33T11)&&(!defined(ONLY)||defined(CASE_XD33T11))
	begin_chk("_XD33T11");
	{
	ostrstream os;
	chk(1);


	}
	end_chk("_XD33T11");
#else
	skip_chk("_XD33T11");
#endif /* CASE_XD33T11 */

/* _XD331T21 ostrstream::ostrstream() */
#if !defined(SKIP_XD331T21)&&(!defined(ONLY)||defined(CASE_XD331T21))
	begin_chk("_XD331T21");
	{
	ostrstream os;
	os.put('x');
	char *s = os.str();
	ieq(*s, 'x');
	os.freeze(false);


	}
	end_chk("_XD331T21");
#else
	skip_chk("_XD331T21");
#endif /* CASE_XD331T21 */

/* _XD331T43 ostrstream::ostrstream(char *, int, openmode), mode & app == 0 */
#if !defined(SKIP_XD331T43)&&(!defined(ONLY)||defined(CASE_XD331T43))
	begin_chk("_XD331T43");
	{
	char buf[] = "abcde";
	ostrstream os(buf, 5);
	ieq(os.rdbuf()->sgetc(), 'a');
	os.put('x');
	ieq(os.rdbuf()->sgetc(), 'x');


	}
	end_chk("_XD331T43");
#else
	skip_chk("_XD331T43");
#endif /* CASE_XD331T43 */

/* _XD331T45 ostrstream::ostrstream(char *, int, openmode), mode & app != 0 */
#if !defined(SKIP_XD331T45)&&(!defined(ONLY)||defined(CASE_XD331T45))
	begin_chk("_XD331T45");
	{
	char buf[10] = "abcde";
	ostrstream os(buf, 10, ios::app);
	ieq(os.rdbuf()->sgetc(), 'a');
	os.put('x');
	ieq(os.rdbuf()->sgetc(), 'a');
	char *s = os.str();
	steq(s, "abcdex");
	os.freeze(false);


	}
	end_chk("_XD331T45");
#else
	skip_chk("_XD331T45");
#endif /* CASE_XD331T45 */

/* _XD332T21 ostrstream::rdbuf */
#if !defined(SKIP_XD332T21)&&(!defined(ONLY)||defined(CASE_XD332T21))
	begin_chk("_XD332T21");
	{
	char buf[] = "abcde";
	ostrstream os(buf, 6);
	strstreambuf *p = os.rdbuf();
	const char *s = p->str();
	steq(s, "abcde");
	p->freeze(false);


	}
	end_chk("_XD332T21");
#else
	skip_chk("_XD332T21");
#endif /* CASE_XD332T21 */

/* _XD332T41 ostrstream::freeze */
#if !defined(SKIP_XD332T41)&&(!defined(ONLY)||defined(CASE_XD332T41))
	begin_chk("_XD332T41");
	{
	ostrstream os;
	os.freeze();
	strstreambuf*p = os.rdbuf();
	ieq(p->sputc('x'), EOF);
	os.freeze(false);
	ieq(p->sputc('x'), 'x');
	os.freeze(true);
	ieq(p->sputc('x'), EOF);
	os.freeze(false);


	}
	end_chk("_XD332T41");
#else
	skip_chk("_XD332T41");
#endif /* CASE_XD332T41 */

/* _XD332T61 ostrstream::str */
#if !defined(SKIP_XD332T61)&&(!defined(ONLY)||defined(CASE_XD332T61))
	begin_chk("_XD332T61");
	{
	ostrstream os;
	os.write("abcde", 6);
	char *s = os.str();
	steq(s, "abcde");
	os.freeze(false);


	}
	end_chk("_XD332T61");
#else
	skip_chk("_XD332T61");
#endif /* CASE_XD332T61 */

/* _XD332T81 ostrstream::pcount */
#if !defined(SKIP_XD332T81)&&(!defined(ONLY)||defined(CASE_XD332T81))
	begin_chk("_XD332T81");
	{
	ostrstream os;
	os.write("abcde", 6);
	ieq(os.pcount(), 6);
	}
	end_chk("_XD332T81");
#else
	skip_chk("_XD332T81");
#endif /* CASE_XD332T81 */

return leave_chk("txd2");
}
/* V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\sources.inc ===
!ifndef WINX_INC_PATH
WINX_INC_PATH = $(BASEDIR)\public\wsdk\inc
!endif

!ifndef WINX_LIB_PATH
WINX_LIB_PATH = $(BASEDIR)\public\wsdk\lib
!endif

!ifndef WINX_DX8_INC_PATH
WINX_DX8_INC_PATH = $(BASEDIR)\public\wsdk\inc
!endif

!ifndef WINX_DX8_LIB_PATH
WINX_DX8_LIB_PATH = $(BASEDIR)\public\wsdk\lib
!endif

TEST_ROOT_PATH = $(BASEDIR)\private\test\directx\d3d
GENTEST_PATH = $(TEST_ROOT_PATH)\frame\gentest

BINPLACE_PLACEFILE=$(TEST_ROOT_PATH)\placebin.txt

BINPLACE_NO_VERSION_RESOURCE=1

!ifdef WINXTARGET

#USE_VC7_WINDOWS=1
USE_PDB=1

_NT386TREE=$(_NT386TREE)\winx

NO_NTDLL=1

COMPILER_WARNINGS=-FI$(BASEDIR)\public\sdk\inc\warning.h
!ifdef USE_LINT
LINT_FORCEDINCS=$(LINT_FORCEDINCS) -header($(BASEDIR)\public\sdk\inc\warning.h)
!endif

!if "$(TARGETTYPE)" == "PROGRAM"
UMENTRY=winmain
!elseif "$(TARGETTYPE)" == "DYNLINK"
DLLENTRY=_DllMainCRTStartup
!endif
UMTYPE=windows

SDK_INC_PATH = $(WINX_INC_PATH)
SDK_LIB_PATH = $(WINX_LIB_PATH)
CRT_INC_PATH = $(WINX_INC_PATH)
CRT_LIB_PATH = $(WINX_LIB_PATH)

TEST_LIB_PATH = $(BASEDIR)\private\test\lib_winx\i386
TEST_LIB_DEST = $(BASEDIR)\private\test\lib_winx
TEST_RES_PATH = ..\..\winx\obj\i386

INCLUDES=\
    $(WINX_DX8_INC_PATH); \
    $(WINX_INC_PATH); \
    $(INCLUDES); \
    ..\..; \
    $(GENTEST_PATH); \
    $(BASEDIR)\private\test\directx\d3d\inc;

TARGETLIBS=\
    $(WINX_LIB_PATH)\kernel32.lib \
    $(WINX_LIB_PATH)\user32.lib \
    $(WINX_LIB_PATH)\gdi32.lib \
    $(WINX_LIB_PATH)\winspool.lib \
    $(WINX_LIB_PATH)\comdlg32.lib \
    $(WINX_LIB_PATH)\advapi32.lib \
    $(WINX_LIB_PATH)\shell32.lib \
    $(WINX_LIB_PATH)\ole32.lib \
    $(WINX_LIB_PATH)\oleaut32.lib \
    $(WINX_LIB_PATH)\kernel32.lib \
    $(WINX_LIB_PATH)\odbc32.lib \
    $(WINX_LIB_PATH)\odbccp32.lib \
    $(WINX_LIB_PATH)\uuid.lib \
    $(WINX_LIB_PATH)\winmm.lib \
    $(WINX_LIB_PATH)\wsock32.lib \
    $(WINX_LIB_PATH)\ws2_32.lib \
    $(WINX_DX8_LIB_PATH)\dxguid.lib \
    $(WINX_DX8_LIB_PATH)\d3d8.lib \
!if $(FREEBUILD)
    $(WINX_DX8_LIB_PATH)\d3dx8.lib \
!else
    $(WINX_DX8_LIB_PATH)\d3dx8d.lib \
!endif
    $(WINX_DX8_LIB_PATH)\dinput8.lib

#C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE

!else

TEST_LIB_PATH = $(BASEDIR)\private\test\lib\i386
TEST_LIB_DEST = $(BASEDIR)\private\test\lib
TEST_RES_PATH = ..\..\xbox\obj\i386

!if "$(TARGETTYPE)" == "PROGRAM"
UMTYPE=xboxapp
UMENTRY=wWinMainCRTStartup
!elseif "$(TARGETTYPE)" == "DYNLINK"
UMTYPE=xboxdll
DLLENTRY=_DllMainCRTStartup
TARGETPATHLIB=$(TEST_LIB_DEST)
!endif

XEINCLUDES=$(_NTTREE)\xboxtest

INCLUDES=\
    $(INCLUDES); \
    ..\..; \
    $(GENTEST_PATH); \
    $(BASEDIR)\private\test\inc; \
    $(BASEDIR)\private\test\directx\d3d\inc;

TARGETLIBS=\
    $(BASEDIR)\private\test\lib\*\xtestlib.lib \
    $(BASEDIR)\private\test\lib\*\xnetrefi$(D).lib \
    $(LIBRARY_PATH)\xnet$(D).lib \
    $(LIBRARY_PATH)\d3d8$(D).lib \
    $(LIBRARY_PATH)\d3dx8$(D).lib \
    $(LIBRARY_PATH)\xgraphics$(D).lib \
    $(TEST_LIB_PATH)\xmem.lib \
    $(TEST_LIB_PATH)\xlog.lib \
 
C_DEFINES=$(C_DEFINES) -DUNDER_XBOX

!if defined(LOGTOWEB)
C_DEFINES=$(C_DEFINES) -DLOGTOWEB
!endif

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\cubelock.cpp ===
#include "d3dapi.hpp"

LINKME(11);
typedef struct {
	int texnum1;
	int layer1;
	int face1;
	bool doraw1;
	int texnum2;
	int layer2;
	int face2;
	bool doraw2;
} CUBELOCKTESTSTRUCT;

namespace d3dapi {
class CTEX {
public:
	CTEX():m_t(0), m_pLast(0) {}

	bool Init(int width, int levels, D3DFORMAT format)
	{
		m_w = width; m_l = levels; m_f = format;
		DWORD hr;
		hr = g_pd3dd8->CreateCubeTexture(m_w,m_l,0,m_f,D3DPOOL_DEFAULT, &m_t);
		if(hr != D3D_OK) {
			xLog(hlog, XLL_FAIL, "CTEX: create cube texture, w%d l%d f%d", m_w, m_l, m_f);
			return false;
		}
		m_pLast = new DWORD[m_l * 6];
		if(!m_pLast) { 
			xLog(hlog, XLL_FAIL, "CTEX: couldn't create dword array, size %d", m_l * 6); 
			return false; 
		}
		m_bpp = D3D::BitsPerPixelOfD3DFORMAT(format);

		return true;
	}

	~CTEX() {
		Release();
	}
	bool Release() {
		DWORD hr;
		if(m_t) {
			hr = m_t->Release();
			xLog(hlog, (hr == 0) ? XLL_PASS : XLL_FAIL, "CTEX: release cube texture: %d", hr);
			m_t = 0;
		}
		if(m_pLast) {
			delete[] m_pLast;
			m_pLast = 0;
		}
		return true;
	}


	void Set(int side, int layer, bool raw, D3DLOCKED_RECT* pr) {  
		int r;
		DWORD col;
		int x, y;
		int w = max(m_w >> layer, 1);
		int h = max(m_w >> layer, 1);

		if(layer < 0 || layer >= m_l) _asm {int 3};
		if(!m_t || !m_pLast) _asm {int 3};
		m_pLast[layer * 6 + side] = rnd();
		r = m_pLast[layer * 6 + side];							//store the random number so we can check the location later
		col = (r + (r << 14) + (r << 27)) >> (32 - m_bpp);
		x = (r + (r << 14) + (r << 27)) & (w - 1);
		y = (r + (r << 14) + (r << 27)) / (w);
		SetPoint((x + 0) & (w - 1), (y + 0) & (h - 1), layer, col, raw, pr);  //draw 5 points to a random location
		SetPoint((x + 1) & (w - 1), (y + 0) & (h - 1), layer, col, raw, pr);  
		SetPoint((x + 0) & (w - 1), (y + 1) & (h - 1), layer, col, raw, pr);
		SetPoint((x - 1) & (w - 1), (y + 0) & (h - 1), layer, col, raw, pr);
		SetPoint((x + 0) & (w - 1), (y - 1) & (h - 1), layer, col, raw, pr);
		SetPoint(w - 1, h - 1, layer, col, raw, pr);						  //draw to first pixel & last pixel
		SetPoint(0, 0, layer, col, raw, pr);
	}

	bool Check(int side, int layer, bool raw, D3DLOCKED_RECT* pr) 
	{
		int r;
		DWORD col;
		int x, y;
		int w = max(m_w >> layer, 1);
		int h = max(m_w >> layer, 1);

		if(layer < 0 || layer >= m_l) _asm {int 3};
		if(!m_t || !m_pLast) _asm {int 3};

		r = m_pLast[layer * 6 + side];	//get the random number from last time
		col = (r + (r << 14) + (r << 27)) >> (32 - m_bpp);
		x = (r + (r << 14) + (r << 27)) & (w - 1);
		y = (r + (r << 14) + (r << 27)) / (w);
		if(!GetPoint((x + 0) & (w - 1), (y + 0) & (h - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 1) & (w - 1), (y + 0) & (h - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 0) & (w - 1), (y + 1) & (h - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x - 1) & (w - 1), (y + 0) & (h - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 0) & (w - 1), (y - 1) & (h - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint(w - 1, h - 1, layer, raw, pr, col)) goto bad;
		if(!GetPoint(0, 0, layer, raw, pr, col)) goto bad;
		return true;
	bad:
		return false;
	}


public: //private:
	int m_w;
	int m_l;
	int m_bpp;
	D3DFORMAT m_f;
	DWORD* m_pLast;
	D3DCubeTexture* m_t;

	void SetPoint(int x, int y, int layer, DWORD col, bool raw, D3DLOCKED_RECT* pr) 
	{
		int i;
		if(raw) {
			SWIZZLER s(max(m_w >> layer, 1), max(m_w >> layer, 1), 0);
			i = s.Convert(x,y,0);
		} else {
			i = (y * (m_w >> layer)) + x;
		}
		switch (m_bpp) {
		case 4:
			i >>= 1; 
			//fall through...
		case 8:
			((BYTE*)pr->pBits)[i] = (BYTE) col;
			break;
		case 16:
			((WORD*)pr->pBits)[i] = (WORD) col;
			break;
		case 32:
			((DWORD*)pr->pBits)[i] = (DWORD) col;
			break;
		default:
			_asm {int 3};
		}
	}	
	bool GetPoint(int x, int y, int layer, bool raw, D3DLOCKED_RECT* pr, DWORD col) 
	{
		int i;
//		DWORD col;
		if(raw) {
			SWIZZLER s(max(m_w >> layer, 1), max(m_w >> layer, 1), 0);
			i = s.Convert(x,y,0);
		} else {
			i = (y * (m_w >> layer)) + x;
		}
		switch (m_bpp) {
		case 4:
			i >>= 1; 
			//fall through...
		case 8:
			if((BYTE)col == (((BYTE*)pr->pBits)[i]))
				return true;
			else
				return false;
		case 16:
			if((WORD)col == (((WORD*)pr->pBits)[i]))
				return true;
			else
				return false;
		case 32:
			if((DWORD)col == (((DWORD*)pr->pBits)[i]))
				return true;
			else
				return false;
		default:
			_asm {int 3};
		}
		return false;
	}	

};
};

#pragma data_seg(".d3dapi$test052") //
BEGINTEST(testCubeLock)
{
	DWORD hr;
	bool br;
	CTEX t[2];
	D3DLOCKED_RECT r;
	int i, j;
	int face;
	//D3DCUBEMAP_FACE_POSITIVE_X;

	STARTLEAKCHECK();
	xStartVariation(hlog, "Cubelock, init");
	{
		br = t[0].Init(256, 9, D3DFMT_R8G8B8A8);
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;

		br = t[1].Init(512, 2, D3DFMT_R8G8B8A8);
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "cube:0L0 & 0L1 swizzled, ch sw");
	{
		for(face = D3DCUBEMAP_FACE_POSITIVE_X; face <= D3DCUBEMAP_FACE_NEGATIVE_Z; face++) {
			hr = t[0].m_t->LockRect((D3DCUBEMAP_FACES)face, 0, &r, NULL, 0); //Exception is happening in this call, on D3DCUBEMAP_FACE_NEGATIVE_Z
			CHECKRESULT(hr == D3D_OK && "LockRect (and unswizzle)");
			t[0].Set(face, 0, false, &r);

			hr = t[0].m_t->UnlockRect((D3DCUBEMAP_FACES)face, 0);
			CHECKRESULT(hr == D3D_OK && "UnlockRect (and reswizzle)");       

			hr = t[0].m_t->LockRect((D3DCUBEMAP_FACES)face, 0, &r, NULL, 0);
			CHECKRESULT(hr == D3D_OK && "LockRect again (and unswizzle)");
			br = t[0].Check(face, 0, false, &r);
			CHECKRESULT(true == br && "check for set pixels");         

			hr = t[0].m_t->UnlockRect((D3DCUBEMAP_FACES)face, 0);
			CHECKRESULT(hr == D3D_OK && "Unlock again and reswizzle");
		}
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "swizzle all sides");
	{
		for(face = D3DCUBEMAP_FACE_POSITIVE_X; face <= D3DCUBEMAP_FACE_NEGATIVE_Z; face++) {
			hr = t[0].m_t->LockRect((D3DCUBEMAP_FACES)face, 0, &r, NULL, 0); //Exception is happening in this call, on D3DCUBEMAP_FACE_NEGATIVE_Z
			CHECKRESULT(hr == D3D_OK && "LockRect (and unswizzle)");
			t[0].Set(face, 0, false, &r);
		}
		for(face = D3DCUBEMAP_FACE_POSITIVE_X; face <= D3DCUBEMAP_FACE_NEGATIVE_Z; face++) {
			hr = t[0].m_t->UnlockRect((D3DCUBEMAP_FACES)face, 0);
			CHECKRESULT(hr == D3D_OK && "UnlockRect (and reswizzle)");       
		}
		for(face = D3DCUBEMAP_FACE_NEGATIVE_Z; face >= D3DCUBEMAP_FACE_POSITIVE_X; face--) {
			hr = t[0].m_t->LockRect((D3DCUBEMAP_FACES)face, 0, &r, NULL, D3DLOCK_RAWDATA);
			CHECKRESULT(hr == D3D_OK && "LockRect again (no unswizzle)");
			br = t[0].Check(face, 0, true, &r);
			CHECKRESULT(true == br && "check for set pixels");         
		}
		for(face = D3DCUBEMAP_FACE_NEGATIVE_Z; face >= D3DCUBEMAP_FACE_POSITIVE_X; face--) {
			hr = t[0].m_t->UnlockRect((D3DCUBEMAP_FACES)face, 0);
			CHECKRESULT(hr == D3D_OK && "unlock again");
		}
	}
	xEndVariation(hlog);
	for(j = 0; j < 2; j++) {
		xStartVariation(hlog, "multi-layer locks");
		{
			CUBELOCKTESTSTRUCT tests [] = {
				{0, 0, D3DCUBEMAP_FACE_NEGATIVE_Z, false, 0, 1, D3DCUBEMAP_FACE_POSITIVE_X, true},
				{0, 0, D3DCUBEMAP_FACE_POSITIVE_X, false, 1, 0, D3DCUBEMAP_FACE_POSITIVE_X, false},
				{0, 0, D3DCUBEMAP_FACE_NEGATIVE_Z, false, 1, 1, D3DCUBEMAP_FACE_NEGATIVE_Z, false},
				{0, 0, D3DCUBEMAP_FACE_NEGATIVE_Z, true,  0, 1, D3DCUBEMAP_FACE_POSITIVE_X, true},
				{0, 0, D3DCUBEMAP_FACE_POSITIVE_X, true,  1, 0, D3DCUBEMAP_FACE_POSITIVE_X, false},
				{0, 0, D3DCUBEMAP_FACE_NEGATIVE_Z, false, 1, 0, D3DCUBEMAP_FACE_NEGATIVE_Z, true},
				{0, 0, D3DCUBEMAP_FACE_NEGATIVE_Z, false, 0, 1, D3DCUBEMAP_FACE_NEGATIVE_Z, true},
				{0, 0, D3DCUBEMAP_FACE_POSITIVE_X, false, 0, 1, D3DCUBEMAP_FACE_POSITIVE_X, true},
				{0, 0, D3DCUBEMAP_FACE_POSITIVE_Y, false, 0, 1, D3DCUBEMAP_FACE_POSITIVE_Y, true},
			};

			for(i = 0; i < COUNTOF(tests); i++) {
				xLog(hlog, XLL_INFO, "cubenum%d, layer%d, Face%d, as%d,  cubenum%d, layer%d, Face%d, as%d", 
					tests[i].texnum1, tests[i].layer1, tests[i].face1, tests[i].doraw1,
					tests[i].texnum2, tests[i].layer2, tests[i].face2, tests[i].doraw2);
				hr = t[tests[i].texnum1].m_t->LockRect((D3DCUBEMAP_FACES)tests[i].face1, tests[i].layer1, &r, NULL, tests[i].doraw1?D3DLOCK_RAWDATA:0); 
				CHECKRESULT(hr == D3D_OK && "Lock1");
				t[tests[i].texnum1].Set(tests[i].face1, tests[i].layer1, tests[i].doraw1, &r);
				hr = t[tests[i].texnum2].m_t->LockRect((D3DCUBEMAP_FACES)tests[i].face2, tests[i].layer2, &r, NULL, tests[i].doraw2?D3DLOCK_RAWDATA:0); 
				CHECKRESULT(hr == D3D_OK && "Lock2");
				t[tests[i].texnum2].Set(tests[i].face2, tests[i].layer2, tests[i].doraw2, &r);

				hr = t[tests[i].texnum1].m_t->UnlockRect((D3DCUBEMAP_FACES)tests[i].face1, tests[i].layer1);
				CHECKRESULT(hr == D3D_OK && "Unlock1");       
				hr = t[tests[i].texnum2].m_t->UnlockRect((D3DCUBEMAP_FACES)tests[i].face2, tests[i].layer2);
				CHECKRESULT(hr == D3D_OK && "Unlock2");       

				hr = t[tests[i].texnum1].m_t->LockRect((D3DCUBEMAP_FACES)tests[i].face1, tests[i].layer1, &r, NULL, tests[i].doraw1?D3DLOCK_RAWDATA:0); 
				CHECKRESULT(hr == D3D_OK && "Lock1 again");
				br = t[tests[i].texnum1].Check(tests[i].face1, tests[i].layer1, tests[i].doraw1, &r);
				CHECKRESULT(true == br && "check for set pixels");         
				hr = t[tests[i].texnum1].m_t->UnlockRect((D3DCUBEMAP_FACES)tests[i].face1, tests[i].layer1);
				CHECKRESULT(hr == D3D_OK && "Unlock1");       

				hr = t[tests[i].texnum2].m_t->LockRect((D3DCUBEMAP_FACES)tests[i].face2, tests[i].layer2, &r, NULL, tests[i].doraw2?D3DLOCK_RAWDATA:0); 
				CHECKRESULT(hr == D3D_OK && "Lock2 again");
				br = t[tests[i].texnum2].Check(tests[i].face2, tests[i].layer2, tests[i].doraw2, &r);
				CHECKRESULT(true == br && "check for set pixels");         
				hr = t[tests[i].texnum2].m_t->UnlockRect((D3DCUBEMAP_FACES)tests[i].face2, tests[i].layer2);
				CHECKRESULT(hr == D3D_OK && "Unlock2");       
			}
		}
		xEndVariation(hlog);
		if(j == 0) {
			xStartVariation(hlog, "cube:makebig");
			{
				t[0].Release();
				t[1].Release();
				CHECKLEAKS();

				br = t[0].Init(2048, 2, D3DFMT_A8);
				CHECKRESULT(br == true);
				if(WASBADRESULT()) goto cleanup;
				br = t[1].Init(2, 2, D3DFMT_A8);
				CHECKRESULT(br == true);
				if(WASBADRESULT()) goto cleanup;
			}
			xEndVariation(hlog);
		}
	}
	goto aftercleanup;
cleanup:
	xEndVariation(hlog);

aftercleanup:;
	xStartVariation(hlog, "leak check");
	t[0].Release();
	t[1].Release();
	CHECKLEAKS();
	xEndVariation(hlog);

}
ENDTEST()

BEGINTEST(testCubeUpdateTexture)
{
	DWORD hr;
	bool br;
	CTEX t[2];
	D3DLOCKED_RECT r;
	int i, j, j2, s;

	struct {
		int w1;
		int l1;
		int w2;
		int l2;
		D3DFORMAT format;
	} tests[] = {
		{1024,  2,  512,  1, D3DFMT_A8          },
		{ 512, 10,    1,  1, D3DFMT_A8          },
		{   2,  2,    1,  1, D3DFMT_A8          },
		{ 512,  9,  256,  8, D3DFMT_A8          },
		{1024,  9,  512,  8, D3DFMT_DXT1        },
		{ 512, 10,    1,  1, D3DFMT_R5G6B5      },
		{   2,  2,    1,  1, D3DFMT_R5G6B5      },
		{ 256,  9,  256,  9, D3DFMT_R5G6B5      },
		{ 512, 10,   64,  1, D3DFMT_R8G8B8A8    },
		{   4,  2,    2,  1, D3DFMT_R8G8B8A8    },
		{ 256,  9,  256,  9, D3DFMT_R8G8B8A8    },
	};

	STARTLEAKCHECK();
	for(i = 0; i < COUNTOF(tests); i++) {
		xStartVariation(hlog, "lock, new texture");
		{
			t[0].Release();
			t[1].Release();

			xLog(hlog, XLL_INFO, "cube 1 size: %d, num layers: %d,  cube 2 size: %d, num layers: %d, fmt: %d", tests[i].w1, tests[i].l1, tests[i].w2, tests[i].l2, tests[i].format);

			br = t[0].Init(tests[i].w1, tests[i].l1, tests[i].format);
			CHECKRESULT(br == true);
			if(WASBADRESULT()) goto cleanup;

			br = t[1].Init(tests[i].w2, tests[i].l2, tests[i].format);
			CHECKRESULT(br == true);
			if(WASBADRESULT()) goto cleanup;

			for(j2 = 0; j2 < tests[i].l2; j2++) {
				for(s = 0; s < 6; s++) {
					hr = t[1].m_t->LockRect((D3DCUBEMAP_FACES)s, j2, &r, NULL, D3DLOCK_RAWDATA);
					CHECKRESULT(hr == D3D_OK && "Lock");
					t[1].Set(s, j2, true, &r);
					hr = t[1].m_t->UnlockRect((D3DCUBEMAP_FACES)s, j2);
					CHECKRESULT(hr == D3D_OK && "Unlock");
				}
			}
			for(j = 0; j < tests[i].l1; j++) {
				for(s = 0; s < 6; s++) {
					hr = t[0].m_t->LockRect((D3DCUBEMAP_FACES)s, j, &r, NULL, D3DLOCK_RAWDATA);
					CHECKRESULT(hr == D3D_OK && "Lock");
					t[0].Set(s, j, true, &r);
					hr = t[0].m_t->UnlockRect((D3DCUBEMAP_FACES)s, j);
					CHECKRESULT(hr == D3D_OK && "Unlock");

					j2 = j - Log2(tests[i].w1) + Log2(tests[i].w2);
					if(j2 >= 0 && j2 < tests[i].l2) {
						t[1].m_pLast[j2 * 6 + s] = t[0].m_pLast[j * 6 + s];
					}
				}
			}
			hr = g_pd3dd8->UpdateTexture(t[0].m_t, t[1].m_t);
			CHECKRESULT(hr == D3D_OK && "Update");

			for(j2 = 0; j2 < tests[i].l2; j2++) {
				for(s = 0; s < 6; s++) {
					hr = t[1].m_t->LockRect((D3DCUBEMAP_FACES)s, j2, &r, NULL, D3DLOCK_RAWDATA);
					CHECKRESULT(hr == D3D_OK && "Lock");
					br = t[1].Check(s, j2, true, &r);
					CHECKRESULT(br == true && "CHECK!");
					hr = t[1].m_t->UnlockRect((D3DCUBEMAP_FACES)s, j2);
					CHECKRESULT(hr == D3D_OK && "Unlock");
				}
			}
		}
		xEndVariation(hlog);
	}
	goto aftercleanup;
cleanup:
	xEndVariation(hlog);
aftercleanup: 
	xStartVariation(hlog, "leak check");
	t[0].Release();
	t[1].Release();
	CHECKLEAKS();
	xEndVariation(hlog);

}
ENDTEST()

BEGINTEST(testCubeLockTextureFlags)
{
	DWORD hr;
	bool br;
	CTEX t[1];
	D3DLOCKED_RECT r, oldr;

	__int64 StartTime, EndTime;

	STARTLEAKCHECK();
	xStartVariation(hlog, "init");
	{
/*
		br = t[0].Init(512, 1, D3DFMT_R8G8B8A8);	
/*/
		br = t[0].Init(512, 1, D3DFMT_R5G6B5);	
/**/
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;

	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'0");
	{
		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, 0, true, &r);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);

		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, 0);
		CHECKRESULT(oldr.pBits != r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, 0, false, &r);
		CHECKRESULT(br == true);
		t[0].Set(0, 0, false, &r);
		hr = t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);

		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, 0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'R/O");
	{
		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, 0, true, &r);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);

		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_READONLY);
		CHECKRESULT(oldr.pBits != r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, 0, false, &r);
		CHECKRESULT(br == true);
//		t[0].Set(0, 0, false, &r);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to unlock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, 0, true, &r);
//		CHECKRESULT(br == true);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Dis");
	{
		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
//		t[0].Set(0, 0, true, &r);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_DISCARD);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits != r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, 0, false, &r);
//		CHECKRESULT(br == true);
		t[0].Set(0, 0, false, &r);
		hr = t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);

		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, 0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Raw");
	{
		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, 0, true, &r);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, 0, true, &r);
		CHECKRESULT(br == true);
		t[0].Set(0, 0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, 0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Raw/RO");
	{
		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, 0, true, &r);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA | D3DLOCK_READONLY);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, 0, true, &r);
		CHECKRESULT(br == true);
//		t[0].Set(0, 0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

//		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
//		CHECKRESULT(oldr.pBits == r.pBits);
//		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, 0, true, &r);
//		CHECKRESULT(br == true);
//		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Raw/Dis");
	{
		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
//		t[0].Set(0, 0, true, &r);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA | D3DLOCK_READONLY);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, 0, true, &r);
//		CHECKRESULT(br == true);
		t[0].Set(0, 0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[0].m_t->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, 0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
	}
	xEndVariation(hlog);

cleanup:
	xStartVariation(hlog, "Cleanup");
	{
		t[0].Release();
		CHECKLEAKS();
	}
	xEndVariation(hlog);
}
ENDTEST()

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\crttests\test\conformance\slconfrm\util.c ===
/* Suite++:    The Plum Hall Validation Suite for C++
 * LibSuite++: The Plum Hall Validation Suite for Standard C++ Library
 * AND         The Plum Hall Validation Suite for C
 * Unpublished copyright (c) 1994, Plum Hall Inc
 * DATE: 1994-07-20
 * As per your license agreement, your distribution is not
 * to be moved or copied outside the Designated Site
 * without specific permission from Plum Hall Inc.
 */

#ifndef UTIL_INCLUDED /* util.c can be #include'd via defs.h */
#define UTIL_INCLUDED

#ifndef DEFS_H
#include "defs.h"
#endif

#ifndef FREESTANDING
#include <stdio.h>
#endif

#define BUFSIZE 256

void setzero(void);
void setremark(void);
void trace(const char *msg, int line);

long Buffer_zone = 0;
long Nerrs = 0;
long Nerr_items = 0;
long Nerrs_this_case = 0;
long Nskips = 0;
long Nremarks = 0;
long Nsuccess = 0;
long Nsuccess_items = 0;
int Debug = FALSE;
int Tall_skinny = TRUE;
int Count_cases = FALSE;
int Score_items = FALSE;
char *Filename = 0;
char last_char_printed = 0;
static char details[BUFSIZE] = {0};
static int trace_msg_len = 0;
static char trace_routine[20] = "";
static char trace_filename[BUFSIZE] = "";
static int remarks = FALSE;
static int first = 1;

#include "clib.h"

/*
 * STR_REV - reverse a string
 */
char *str_rev(
        char *s)
        {
        char c;
        char *p, *q;

        for (p = s, q = s + str_len(s) - 1; p < q; ++p, --q)
                {
                c = *p;
                *p = *q;
                *q = c;
                }
        return s;
        }

/*
 * IABS - absolute value of an integer
 */
int iabs(
        int i)
        {
        return (i >= 0) ? i : -i;
        }

/*
 * DABS - absolute value of a double
 */
double dabs(
        double d)
        {
        return (d >= 0.0) ? d : -d;
        }

/*
 * DPOWU - returns a double d raised to the power of unsigned u
 */
double dpowu(
        double d,
        unsigned u)
        {
        double p = 1.0;

        while (u-- > 0)
                p *= d;
        return p;
        }

/*
 * ULTOSTR - convert unsigned long u to a string in base b, return the
 * address of the null terminator
 */
char *ultostr(
        char *s,
        ULONG u,
        unsigned b)
        {
        char *p = s;

        do
                {
                if ((*p = (char)(u % b)) < 10)
                        *p += '0';
                else
                        *p += 'A' - 10;
                ++p;
                }
        while ((u /= b) != 0);
        *p = '\0';
        str_rev(s);
        return p;
        }

/*
 * LTOSTR - convert long i to a string in base b
 */
char *ltostr(
        char *s,
        long i,
        unsigned b)
        {
        if (i < 0)
                {
                *s++ = '-';
                i = -i;
                }
        return ultostr(s, i, b);
        }

#define utostr(s, u, b) ultostr((s), (ULONG)(u), (b))

#define itostr(s, i, b) ltostr((s), (long)(i), (b))

#define ULONG_DIG 64

/*
 * PR_UL - print unsigned long u as a string in base b
 */
void pr_ul(
        ULONG lu,
        unsigned b)
        {
        char buf[ULONG_DIG + 1];

        ultostr(buf, lu, b);
        pr_ok(buf);
        }

/*
 * PR_L - print long li as a string in base b
 */
void pr_l(
        long li,
        unsigned b)
        {
        char buf[ULONG_DIG + 2];

        ltostr(buf, li, b);
        pr_ok(buf);
        }

#define pr_i(i, b) pr_l((long)(i), (b))

/*
 * ENTRY_FN - in Debug mode, record entry to a function
 */
void entry_fn(
        const char *s)
        {
        if (Debug)
                {
                if (last_char_printed != '\n')
                        pr_ok("\n");
                pr_ok("ENTERING: ");
                pr_ok(s);
                pr_ok("\n");
                }
        }

/*
 * ERRMSG - print and tabulate each message
 */
static void errmsg(
        char *msg,
        int line)
        {
        if (first)
                {
                setzero();
                setremark();
                first = 0;
                pr_ok("***** Reached first test *****\n");
                }
        if (trace_msg_len != 0 )
                {
                if (last_char_printed != '\n')
                        pr_ok("\n");
                trace_msg_len = 0;
                str_cpye(trace_routine, "");
                }
        if (line > 0 || remarks)
                {
                pr_ok(line > 0 ? "ERROR" : "REMARK");
                pr_ok(" in ");
                pr_ok(Filename);
                pr_ok(" at line ");
                pr_i(iabs(line), 10);
                pr_ok(msg);
                pr_ok("\n");
                }
        if (line > 0)
                ++Nerr_items;
        else
                ++Nremarks;
        }

/*
 * IEQUALS - 'int' equality check.  If val1 != val2, then report an error.
 */
int iequals(
        int line,
        int val1,
        int val2)
        {
        char *p;

        if (val1 != val2)
                {
                p = str_cpye(details, ": (");
                p = itostr(p, val1, 10);
                p = str_cpye(p, ") != (");
                p = itostr(p, val2, 10);
                p = str_cpye(p, ")");
                errmsg(details, line);
                return 0;
                }
        else
                trace("iequals", line);
        return 1;
        }

/*
 * INOTEQUALS - 'int' non-equality check.  If val1 == val2, then
 * report an error.
 */
int inotequals(
        int line,
        int val1,
        int val2)
        {
        char *p;

        if (val1 == val2)
                {
                p = str_cpye(details, ": (");
                p = itostr(p, val1, 10);
                p = str_cpye(p, ") == (");
                p = itostr(p, val2, 10);
                p = str_cpye(p, ")");
                errmsg(details, line);
                return 0;
                }
        else
                trace("inotequals", line);
        return 1;
        }

/*
 * ILEQUAL - 'int' less-or-equal check.  If val1 > val2, then
 * report an error.
 */
int ilequal(
        int line,
        int val1,
        int val2)
        {
        char *p;

        if (val1 > val2)
                {
                p = str_cpye(details, ": (");
                p = itostr(p, val1, 10);
                p = str_cpye(p, ") > (");
                p = itostr(p, val2, 10);
                p = str_cpye(p, ")");
                errmsg(details, line);
                return 0;
                }
        else
                trace("ilequal", line);
        return 1;
        }

/*
 * LEQUALS - 'long' equality check.  If val1 != val2, then
 * report an error.
 */
int lequals(
        int line,
        long val1,
        long val2)
        {
        char *p;

        if (val1 != val2)
                {
                p = str_cpye(details, ": (");
                p = ltostr(p, val1, 10);
                p = str_cpye(p, ") != (");
                p = ltostr(p, val2, 10);
                p = str_cpye(p, ")");
                errmsg(details, line);
                return 0;
                }
        else
                trace("lequals", line);
        return 1;
        }

/*
 * ULEQUALS - 'unsigned long' equality check.  If val1 != val2, then
 * report an error.
 */
int ulequals(
        int line,
        ULONG val1,
        ULONG val2)
        {
        char *p;

        if (val1 != val2)
                {
                p = str_cpye(details, ": (");
                p = ultostr(p, val1, 10);
                p = str_cpye(p, ") != (");
                p = ultostr(p, val2, 10);
                p = str_cpye(p, ")");
                errmsg(details, line);
                return 0;
                }
        else
                trace("ulequals", line);
        return 1;
        }

/*
 * STEQUALS - string equality.
 */
int stequals(
        int line,
        const char *val1,
        const char *val2)
        {
        char *p;

        if (str_cmp(val1, val2))
                {
                p = str_cpye(details, ": \"");
                p = str_cpye(p, val1);
                p = str_cpye(p, "\" != \"");
                p = str_cpye(p, val2);
                p = str_cpye(p, "\"");
                errmsg(details, line);
                return 0;
                }
        else
                trace("stequals", line);
        return 1;
        }

/*
 * COMPLAIN - unconditional failure.
 */
int complain(
        int line)
        {
        errmsg("", line);
        return 0;
        }

/*
 * ARBHEX - convert an arbitrary byte-sequence into hex codes
 */
#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif
#define NIBBLES_PER_BYTE ((CHAR_BIT + 3) / 4)

char *arbhex(
        char *str,
        const char *p,
        int n)
        {
        int i, nib, hex_dig;
        static char codes[] = "0123456789ABCDEF";

        for (i = 0; i < n; ++i, ++p)
                for (nib = NIBBLES_PER_BYTE - 1; nib >= 0; --nib)
                        {
                        hex_dig = (*p & (unsigned)(0xF << (nib * 4))) >> (nib * 4);
                        *str++ = codes[hex_dig];
                        }
        *str = '\0';
        return str;
        }

/*
 * AEQUALS - 'address' equality check.  If val1 != val2, then
 * report an error.
 */
int aequals(
        int line,
        const volatile void *val1,
        const volatile void *val2)
        {
#ifdef FREESTANDING
        char *p;
#endif

        if (val1 != val2)
                {
#ifdef FREESTANDING
                p = str_cpye(details, ": (");
                p = arbhex(p, (const char *)&val1, (int)sizeof(val1));
                p = str_cpye(p, ") != (");
                p = arbhex(p, (const char *)&val2, (int)sizeof(val2));
                p = str_cpye(p, ")");
#else
                sprintf(details, ": (%p) != (%p)",  val1, val2);
#endif
                errmsg(details, line);
                return 0;
                }
        else
                trace("aequals", line);
        return 1;
        }

/*
 * FAEQUALS - function address equality check.  If val1 != val2, then
 * report an error. The address of a function is not necessarily the same
 * size/type as the address of data.
 */
int faequals(
        int line,
        int (*val1)(),
        int (*val2)())
        {
        char *p;

        if (val1 != val2)
                {
                p = str_cpye(details, ": (");
                p = arbhex(p, (char *)&val1, (int)sizeof(val1));
                p = str_cpye(p, ") != (");
                p = arbhex(p, (char *)&val2, (int)sizeof(val2));
                p = str_cpye(p, ")");
                errmsg(details, line);
                return 0;
                }
        else
                trace("faequals", line);
        return 1;
        }

/*
 * DEQUALS - 'double' equality check.  If val1 != val2, then
 * report an error. This is computed using an equality approximation
 * that verifies that the two numbers are equal to R digits whenever
 *
 *    |x - y|    1    1-R
 *    ------- <= - 10
 *      |x|      2
 *
 * DIGITS_MAX  is defined in defs.h
 */
double Delta = 0.0;

int dequals(
        int line,
        double val1,
        double val2)
        {
#ifdef FREESTANDING
        char *p;
#endif
        double *pd;

        if (line < 0)   /* no "remarks" for floating point */
                return 0;
        if (Delta == 0.0)
                Delta = 0.5 / dpowu(10.0, DIGITS_MAX - 1);
        if (val1 == val2)
                {
                trace("dequals", line);
                return 1;
                }
        pd = &val1;
        if (val1 == 0.0)
                pd = &val2;

        /* special cases to handle zero against very small numbers */
        if (dabs(val1) == 0.0 && dabs(val2) < Delta)
                ;
        else if (dabs(val2) == 0.0 && dabs(val1) < Delta)
                ;
        else if ((dabs(val1 - val2) / dabs(*pd)) > Delta)
                {
#ifdef FREESTANDING
                p = str_cpye(details, ": (");
                p = arbhex(p, (const char *)&val1, (int)sizeof(val1));
                p = str_cpye(p, ") != (");
                p = arbhex(p, (const char *)&val2, (int)sizeof(val2));
                p = str_cpye(p, ")");
#else
                sprintf(details, ": (%.*G) != (%.*G)",
                        DIGITS_MAX + 2, val1, DIGITS_MAX + 2, val2);
#endif
                errmsg(details, line);
                return 0;
                }
        trace("dequals", line);
        return 1;
        }

#if ANSI
/*
 * LDEQUALS - Long double equality ... more of the same.
 */
#define ldabs(ld) ((ld) < 0.0 ? -(ld) : (ld))

long double LDelta = 0.0;

int ldequals(
        int line,
        long double val1,
        long double val2)
        {
#ifdef FREESTANDING
        char *p;
#endif
        long double *pd;

        if (line < 0)   /* no "remarks" for floating point */
                return 0;
        if (LDelta == 0.0)
                {
                LDelta = 0.5L / dpowu(10.0, LDIGITS_MAX - 1);
                }
        if (val1 == val2)
                {
                trace("ldequals", line);
                return 1;
                }
        pd = &val1;
        if (val1 == 0.0)
                pd = &val2;

        /* special cases to handle zero against very small numbers */
        if (ldabs(val1) == 0.0 && ldabs(val2) < LDelta)
                ;
        else if (ldabs(val2) == 0.0 && ldabs(val1) < LDelta)
                ;
        else if ((ldabs(val1 - val2) / ldabs(*pd)) > LDelta)
                {
#ifdef FREESTANDING
                p = str_cpye(details, ": (");
                p = arbhex(p, (char *)&val1, (int)sizeof(val1));
                p = str_cpye(p, ") != (");
                p = arbhex(p, (char *)&val2, (int)sizeof(val2));
                p = str_cpye(p, ")");
#else
                sprintf(details, ": (%.*LE) != (%.*LE)",
                        LDIGITS_MAX + 2, val1, LDIGITS_MAX + 2, val2);
#endif
                errmsg(details, line);
                return 0;
                }
        trace("ldequals", line);
        return 1;
        }
#endif

/*
 * FEQUALS - same as DEQUALS, but to FDIGITS_MAX instead of DIGITS_MAX.
 */
double FDelta = 0.0;

int fequals(
        int line,
        double in1,
        double in2)
        {
#ifdef FREESTANDING
        char *p;
#endif
        float *pf;
        float val1 = (float)in1;
        float val2 = (float)in2;

        if (line < 0)   /* no "remarks" for floating point */
                return 0;
        if (FDelta == 0.0)
                FDelta = 0.5 / dpowu(10.0, FDIGITS_MAX - 1);
        if (val1 == val2)
                {
                trace("fequals", line);
                return 1;
                }
        pf = &val1;
        if (val1 == 0.0)
                pf = &val2;

        /* special cases to handle zero against very small numbers */
        if (dabs(val1) == 0.0 && dabs(val2) < FDelta)
                ;
        else if (dabs(val2) == 0.0 && dabs(val1) < FDelta)
                ;
        else if ((dabs(val1 - val2) / dabs(*pf)) > FDelta)
                {
#ifdef FREESTANDING
                p = str_cpye(details, ": (");
                p = arbhex(p, (char *)&val1, (int)sizeof(val1));
                p = str_cpye(p, ") != (");
                p = arbhex(p, (char *)&val2, (int)sizeof(val2));
                p = str_cpye(p, ")");
#else
                sprintf(details, ": (%.*G) != (%.*G)",
                        FDIGITS_MAX+2, val1, FDIGITS_MAX+2, val2);
#endif
                errmsg(details, line);
                return 0;
                }
        trace("fequals", line);
        return 1;
        }

/*
 * CHECKTHAT - simple condition check.  If val1 == 0, then
 * report an error.
 */
int checkthat(
        int line,
        int cond)
        {
        if (!cond)
                {
                errmsg("", line);
                return 0;
                }
        else
                trace("checkthat", line);
        return 1;
        }

/*
 * VALUE - the value routines are used to defeat value propagation in
 * optimizing compilers.  We want to make sure that we are testing what we
 * think we are testing, not what the compiler transformed it to.
 * 1988: Some compilers "open-code" all small functions.  Now we have to hide
 * the constants still further.
 */
extern int Zero = 0;    /* See  setzero()  below */

int ivalue(
        int i)
        {
        return i + Zero;
        }

long lvalue(
        long i)
        {
        return i + Zero;
        }

double dvalue(
        double i)
        {
        return i + Zero;
        }

float fvalue(
        double i)
        {
        return (float)i + Zero;
        }

void * avalue(
        void * i)
        {
        if (i == 0)
                return 0;
        else
                return (char *)i + Zero;
        }

/*
 * SCHECK - check both values and side effects.
 */
int Side = 0;

int scheck(
        int line,
        int val1,
        int se,
        int val2)
        {
        int status = 1;

        if (Side != se)
                {
                errmsg(": incorrect side effect", line);
                status = 0;
                }
        else
                trace("scheck", line);
        Side = 0;
        return status == 1 && iequals(line, val1, val2);
        }

/*
 * DO_NOTHING - this is also intended to defeat optimizers by passing
 * the addresses of variables for which we want to stop any value propagation.
 */
int do_nothing(
        const volatile void *p, ...)
        {
        if (p != 0)
                *(char *)p = *((char *)p + Zero);
        return 0;
        }

/*
 * REPORT - summary report at end of testing.
 */
int report(
        const char *program)
        {
        if (trace_msg_len != 0 || last_char_printed != '\n')
                pr_ok("\n");

        if (Score_items || !Count_cases)
                {
                Nsuccess = Nsuccess_items;
                Nerrs = Nerr_items;
                }
        else
                {
                pr_ok("***** ");
                pr_l(Nsuccess_items, 10);
                pr_ok(" individual successful item");
                pr_ok(Nsuccess_items != 1 ? "s" : "");
                pr_ok(" in ");
                pr_ok(program);
                pr_ok(" *****\n");
                }

        pr_ok("***** ");
        pr_l(Nsuccess, 10);
        pr_ok(" successful test case");
        pr_ok(Nsuccess != 1 ? "s" : "");
        pr_ok(" in ");
        pr_ok(program);
        pr_ok(" *****\n");

        pr_ok("***** ");
        pr_l(Nerrs, 10);
        pr_ok(" error");
        pr_ok(Nerrs != 1 ? "s" : "");
        pr_ok(" detected in ");
        pr_ok(program);
        pr_ok(" *****\n");

        pr_ok("***** ");
        pr_l(Nskips, 10);
        pr_ok(" skipped section");
        pr_ok(Nskips != 1 ? "s" : "");
        pr_ok(" in ");
        pr_ok(program);
        pr_ok(" *****\n");

        if (remarks && Nremarks != 0)
                {
                pr_ok("***** ");
                pr_l(Nremarks, 10);
                pr_ok(" remark");
                pr_ok(Nremarks != 1 ? "s" : "");
                pr_ok(" detected in ");
                pr_ok(program);
                pr_ok(" *****\n");
                }

        if (Buffer_zone != 0)
                {
                pr_ok("WARNING: Data over-write (wild store) occurred\n");
                }

//!: (don't want skip tests to register as errors)        Nerrs += Nskips;
        return Nerrs > MAX_INT ? MAX_INT : (int)Nerrs;
        }

/*
 * DBPRINT - print the message if the Debug flag is on.
 */
void dbprint(
        const char *s)
        {
        if (Debug)
                {
                pr_ok("***DEBUG***");
                pr_ok(s);
                }
        }

/*
 * TRACE - print a line-number trace for debugging
 * Also count successful tests.
 */
void trace(
        const char *routine,
        int line)
        {
        char buf[10];

        if (first)
                {
                setzero();
                setremark();
                first = 0;
                pr_ok("***** Reached first test *****\n");
                }
        if (Debug && line > 0)
                {
                if (str_cmp(trace_routine, routine) != 0 ||
                        str_cmp(trace_filename, Filename) != 0 ||
                        last_char_printed == '\n' ||
                        Tall_skinny ||
                        trace_msg_len > 60)
                        {
                        if (last_char_printed != '\n')
                                pr_ok("\n");
                        pr_ok("TRACE: ");
                        pr_ok(routine);
                        pr_ok(" at ");
                        pr_ok(Filename);
                        pr_ok(" ");
                        str_cpye(trace_routine, routine);
                        str_cpye(trace_filename, Filename);
                        trace_msg_len = 11 + str_len(routine) + str_len(Filename);
                        }
                str_cpye(itostr(buf, iabs(line), 10), " ");
                pr_ok(buf);
                trace_msg_len += str_len(buf);
                }
        if (line > 0)
                ++Nsuccess_items; /* don't count remarks in score */
        }

/*
 * PR_SKIP - printf a text line in SKIP situation
 */
void pr_skip(
        const char *s)
        {
        ++Nskips;
        if (last_char_printed != '\n')
                pr_ok("\n");
        pr_ok("#SKIPPED: ");
        pr_ok(s);
        pr_ok("\n");
        }

/*
 * BEGIN_CASE - start a new test case
 */
void begin_case(
        const char *s)
        {
        Nerrs_this_case = Nerr_items;
        ignore(&s);
        }
/*
 * END_CASE - complete a test case
 */
void end_case(
        const char *s)
        {
        int i;
        static char buf[2] = {0};
        Count_cases = TRUE;
        if (last_char_printed != '\n')
                pr_ok("\n");
        if (Nerrs_this_case == Nerr_items)
                {
                ++Nsuccess;
                pr_ok("#PASSED:  ");  /* no new errors */
                for (i = 0; s[i] != ' ' && s[i] != '\0'; ++i)
                        buf[0] = s[i], pr_ok(buf);
                }
        else
                {
                static char m[] = "FAIL";
                ++Nerrs;
                pr_ok("#FAILED:  ");  /* new errors */
                for (i = 0; s[i] != ' ' && s[i] != '\0'; ++i)
                        buf[0] = s[i], pr_ok(buf);
                ++i;
                pr_ok(" ");
                if (s[i+2]!=m[0]||s[i+3]!=m[1]||s[i+4]!=m[2]||s[i+5]!=m[3])
                        pr_ok(s+i);
                }
        pr_ok("\n");
        }

/*
 * PR_ERR - printf a text line in error situation
 */
void pr_err(
        const char *s)
        {
        ++Nerr_items;
        pr_ok(s);
        }
/*
 * SETREMARK - determine whether "remark" messages should be printed
 */
void setremark()
        {
#ifdef SUITE_REMARK
        remarks = TRUE;
#else
        remarks = FALSE;
#endif
        }

/*
 * ignore - appear to use a value, but don't
 * (Purpose: shut up noisy "value not used" messages)
 */
void ignore(
        const volatile void *addr)
        {
        if (Zero)
                pr_ok((char *)addr);
        }

/* new utility functions for widechar library tests */

/*
 * WCS_CMP
 */
int wcs_cmp(
        const wchar_t *s1,
        const wchar_t *s2)
        {
        for (; *s1 == *s2; ++s1, ++s2)
                if (*s1 == 0)
                        return 0;
        if (*s1 < *s2)
                return -1;
        else 
                return 1;
        }

/*
 * WCS_MBSE - copy widechar string s2 to (narrow) string s1
 *    (not an exact replacement for wcstombs)
 */
char *wcs_mbse(
        char *s1,
        const wchar_t *s2)
        {
        do      {
                if ((char)*s2 == *s2)
                        *s1++ = (char)*s2++;
                else
                        *s1++ = '?', ++s2;
                } while ((*s1) != '\0');
        return s1;
        }

/*
 * WCS_CPYE - copy widechar string s2 to s1
 *    (not an exact replacement for wcscpy)
 */
wchar_t *wcs_cpye(
        wchar_t *s1,
        const wchar_t *s2)
        {
        while ((*s1 = *s2++) != 0)
                ++s1;
        return s1;
        }

/*
 * WCSEQUALS - widechar string equality.
 */
int wcsequals(
        int line,
        const wchar_t *val1,
        const wchar_t *val2)
        {
        char *p;

        if (wcs_cmp(val1, val2))
                {
                p = str_cpye(details, ": \"");
                p = wcs_mbse(p, val1);
                p = str_cpye(p, "\" != \"");
                p = wcs_mbse(p, val2);
                p = str_cpye(p, "\"");
                errmsg(details, line);
                return 0;
                }
        else
                trace("wcsequals", line);
        return 1;
        }

/*
 * PR_CHKN - print a NOTE with value of n
 */
int pr_chkn(int n)
        {
        pr_ok("NOTE: The actual value was: ");
        pr_l((long)n, 10);
        pr_ok("\n");
        return 0;   /* presumably called only in ERROR situations */
        }

#include "sdutil.h"

#endif /* UTIL_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\cursor.cpp ===
#include "d3dapi.hpp"

LINKME(2) 

//doesn't matter if this goes before or after other d3d device tests...

/*
    HRESULT WINAPI SetCursorProperties(UINT XHotSpot, UINT YHotSpot, IDirect3DSurface8 *pCursorBitmap);
    void    WINAPI SetCursorPosition(UINT XScreenSpace, UINT YScreenSpace, DWORD Flags);
    BOOL    WINAPI ShowCursor(BOOL bShow);
*/

#pragma data_seg(".d3dapi$test061") 

BEGINTEST(testDeviceCursor)
{

}
ENDTEST()

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\cubetexture.cpp ===
#include "d3dapi.hpp"
#include "swizzler.h"

LINKME(1)

static D3DFORMAT TextureTypes[] = {
//    D3DFMT_R8G8B8,
    D3DFMT_A8R8G8B8,
    D3DFMT_X8R8G8B8,
    D3DFMT_R5G6B5,
    D3DFMT_X1R5G5B5,
    D3DFMT_A1R5G5B5,
    D3DFMT_A4R4G4B4,
 //   D3DFMT_R3G3B2,
    D3DFMT_A8,
//    D3DFMT_A8R3G3B2,
//    D3DFMT_X4R4G4B4,

//    D3DFMT_A8P8,
    D3DFMT_P8,

    D3DFMT_L8,
    D3DFMT_A8L8,
//    D3DFMT_A4L4,

//    D3DFMT_UYVY,
//    D3DFMT_YUY2,
    D3DFMT_DXT1,
    D3DFMT_DXT2,
///    D3DFMT_DXT3,
///    D3DFMT_DXT4,
    D3DFMT_DXT5
};

static DWORD Usages[] = {
	0, D3DUSAGE_DEPTHSTENCIL, D3DUSAGE_RENDERTARGET, D3DUSAGE_DEPTHSTENCIL | D3DUSAGE_RENDERTARGET
};

static struct {UINT x; UINT y; UINT z;} Sizes[] = {
	{ 4,  4, 4},
	{ 8,  8, 8},
	{16, 16, 16},
	{32, 32, 32},
	{64, 64, 64},
	{ 4, 64, 32}
};

static DWORD Levels[] = {
	0, 1, 2
};

static struct cubestuffstruct {
	D3DFORMAT f;
	UINT bitdepth;
	UINT width;
//	UINT height;
	UINT count;
	UINT expected;
} CubeStuff[] = {
	{  D3DFMT_A8R8G8B8, 32,   64,  0,  7},
	{  D3DFMT_A8R8G8B8, 32,   64,  5,  5},
	{  D3DFMT_A8R8G8B8, 32,  128,  0,  8},
	{  D3DFMT_A8R8G8B8, 32,  128,  8,  8},
	{  D3DFMT_A8R8G8B8, 32,  512, 10, 10},
	{  D3DFMT_A8R8G8B8, 32,    4,  0,  3},
	{  D3DFMT_A8R8G8B8, 32,    2,  0,  2},
	{  D3DFMT_A8R8G8B8, 32,    1,  0,  1},

//	{      D3DFMT_DXT1,  4,   64,  0,  5},
//	{      D3DFMT_DXT1,  4,   64,  5,  5},
//	{      D3DFMT_DXT1,  4,  128,  0,  8},
//	{      D3DFMT_DXT1,  4,  128,  6,  6},
//	{      D3DFMT_DXT1,  4, 1024,  9,  9},
//	{      D3DFMT_DXT1,  4,    4,  0,  1},

	{    D3DFMT_R5G6B5, 16,   64,  5,  5},
	{        D3DFMT_A8,  8,   64,  0,  7},

//	{D3DFMT_LIN_R5G6B5, 16,   64,  0,  1},
//	{D3DFMT_LIN_R5G6B5, 16, 1024,  0,  1},
//	{D3DFMT_LIN_R5G6B5, 16,  128,  0,  1},
//	{D3DFMT_LIN_R5G6B5, 16,  512,  1,  1},
//	{D3DFMT_LIN_R5G6B5, 16, 2048,  0,  1}
};


#pragma data_seg(".d3dapi$test110") 


BEGINTEST(testCreateCubeTexture)
{
	IDirect3DCubeTexture8* t;
	DWORD hr;
	int a, b, c, d;

	xStartVariation(hlog, "Cube: Formats Loop");
	STARTLEAKCHECK();

	for(a = 0; a < COUNTOF(TextureTypes); a++) {
		hr = g_pd3dd8->CreateCubeTexture(64, 0, 0, TextureTypes[a], D3DPOOL_DEFAULT, &t);
		CHECKRESULT(hr == D3D_OK);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "len: %d, Lev: %d, Usage: %d, Format: %d",
				64, 0, 0, TextureTypes[a]);
			break;
		}
		hr = t->Release();
		CHECKRESULT(hr == 0);
	}

	CHECKLEAKS();
	xEndVariation(hlog);
	xStartVariation(hlog, "Cube: Size & Levels Loop");
	STARTLEAKCHECK();

	for(b = 0; b < COUNTOF(Sizes) - 1; b++) {
	for(c = 0; c < COUNTOF(Levels); c++) {
	for(d = 0; d < COUNTOF(Usages); d++) {
		hr = g_pd3dd8->CreateCubeTexture(Sizes[b].x, 
			Levels[c], Usages[d], D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t);
		CHECKRESULT(hr == D3D_OK);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "Len: %d, Lev: %d, Usage: %d, Format: %d",
				Sizes[b].x, Levels[c], Usages[d], D3DFMT_A8R8G8B8);
			break;
		}
		hr = t->Release();
		CHECKRESULT(hr == 0);
	}
	}
	}

	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()


BEGINTEST(testCubeTextureGetDevice)
{
	DWORD hr;
	IDirect3DCubeTexture8* t;
	IDirect3DDevice8* d;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();
	hr = g_pd3dd8->CreateCubeTexture(64, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t);
	CHECKRESULT(hr == D3D_OK);
	hr = t->GetDevice(&d);
	CHECKRESULT(hr == D3D_OK);
	CHECKRESULT(d == g_pd3dd8);
	d->Release();
	CHECKRESULT(t->Release() == 0);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testCubeTextureGetType)
{
	DWORD hr;
	IDirect3DCubeTexture8* t;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();
	hr = g_pd3dd8->CreateCubeTexture(64, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t);
	CHECKRESULT(hr == D3D_OK);
	CHECKRESULT(t->GetType() == D3DRTYPE_CUBETEXTURE);
	CHECKRESULT(t->Release() == 0);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testCubeTextureIsBusy)
{
	//#pragma TODO("test IsBusy")
}
ENDTEST()

BEGINTEST(testCubeTextureGetLevelCount)
{
	DWORD hr;
	IDirect3DCubeTexture8* t;
	int i;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(CubeStuff); i++) {
		hr = g_pd3dd8->CreateCubeTexture(CubeStuff[i].width, CubeStuff[i].count, 0, CubeStuff[i].f, D3DPOOL_DEFAULT, &t);
		CHECKRESULT(hr == D3D_OK);
		CHECKRESULT(t->GetLevelCount() == CubeStuff[i].expected);
		CHECKRESULT(t->Release() == 0);
	}
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()


BEGINTEST(testCubeTextureGetLevelDesc)
{
	DWORD hr;
	IDirect3DCubeTexture8* t;
	D3DSURFACE_DESC d;
	int i;
	unsigned int j;
	UINT w;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(CubeStuff); i++) {
		hr = g_pd3dd8->CreateCubeTexture(CubeStuff[i].width, CubeStuff[i].count, 0, CubeStuff[i].f, D3DPOOL_DEFAULT, &t);
		w = CubeStuff[i].width; 
		CHECKRESULT(hr == D3D_OK);
		if(WASGOODRESULT()) {
			for(j = 0; j < t->GetLevelCount(); j++) {
				t->GetLevelDesc(j, &d);
				CHECKRESULT(d.Width == w);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "d.Width is %d, should be %d", d.Width, w);
				CHECKRESULT(d.Height == w);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "d.Height is %d, should be %d", d.Height, w);
				CHECKRESULT(d.Size == w * w * CubeStuff[i].bitdepth/8);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "d.Size is %d, should be %d", d.Size, w*w*CubeStuff[i].bitdepth /8);
				CHECKRESULT(d.Format == CubeStuff[i].f);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "d.Format is %d, should be %d", d.Format, CubeStuff[i].f);
				w = (w >> 1) ? (w >> 1) : 1;
			}
			CHECKRESULT(t->Release() == 0);
		}
	}
	CHECKRESULT(d.Type == D3DRTYPE_CUBETEXTURE);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testCubeTextureGetSurfaceLevel)
{
	DWORD hr;
	IDirect3DCubeTexture8* t;
	IDirect3DSurface8* s;
	D3DSURFACE_DESC d;
	int i;
	unsigned int j;
	int f;
	UINT w;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(CubeStuff); i++) {
		hr = g_pd3dd8->CreateCubeTexture(CubeStuff[i].width, CubeStuff[i].count, 0, CubeStuff[i].f, D3DPOOL_DEFAULT, &t);
		CHECKRESULT(hr == D3D_OK);
		if(WASGOODRESULT()) {
			for(f = D3DCUBEMAP_FACE_POSITIVE_X; f <= D3DCUBEMAP_FACE_NEGATIVE_Z; f++) {
				w = CubeStuff[i].width; 
				for(j = 0; j < t->GetLevelCount(); j++) {
					t->GetCubeMapSurface((D3DCUBEMAP_FACES)f, j, &s);
					s->GetDesc(&d);
					CHECKRESULT(d.Width == w);
					if(WASBADRESULT()) {
						xLog(hlog, XLL_INFO, "d.Width is %d, should be %d", d.Width, w);
					}
					CHECKRESULT(d.Size == w * w * CubeStuff[i].bitdepth/8);
					if(WASBADRESULT()) {
						xLog(hlog, XLL_INFO, "d.Size is %d, should be %d. w=%d, bpp=%d", d.Size, w*w*CubeStuff[i].bitdepth/8, w, CubeStuff[i].bitdepth/8);
					}
					CHECKRESULT(d.Format == CubeStuff[i].f);
					w = (w >> 1) ? (w >> 1) : 1;
					hr = s->Release();
					CHECKRESULT(hr == 0);
				}
			}
			CHECKRESULT(t->Release() == 0);
		}
	}
	CHECKRESULT(d.Type == D3DRTYPE_SURFACE);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

#if 0
	BEGINTEST(testCubeTextureLockAndUnlockRect)
	{
		/*
		This test does the following:
			create huge CubeTexture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
			locks the top layer as RAW_DATA
			sets a few random pixels
			unlocks top layer
			locks top layer (unswizzled)
			checks if the pixels tweaked earlier are still set
			locks layer 3 (512x512), (RAW)
			sets a lot more pixels on top layer
			sets some pixels on layer 3
			unlock layer 3, lock layer 3 as unswizzled
			set more pixels on layer 3
			unlocks top layer
			locks top layer (RAW)
			lock bottom layer (RAW)
			create another CubeTexture (256x512, 1 mip layer, 32bits/pixel == 128k)
			lock second CubeTexture (unswizzled)
			write pixels to second CubeTexture
			set a pixel on bottom layer of first CubeTexture
			unlock bottom layer of first CubeTexture (RAW)
			unlock layer 3 of first CubeTexture(RAW)
			unlock second CubeTexture (unswizzled)
			checks for corruption of pixels set on RAW top layer
			unlock top layer
			lock top layer
			unlock top layer
			delete first CubeTexture
			lock second CubeTexture (RAW)
			check for corrupted pixels of second CubeTexture
			unlock second CubeTexture (RAW)
			delete second CubeTexture

		tests:
			huge CubeTextures, 
			multiple simultaneous unswizzling of CubeTexture levels
			swizzling
			unswizzling
			multiple simultaneous unswizzled CubeTextures
			1x1 mip layers
			non-square CubeTextures
			8bbp and 32bbp lock/unlock
		*/
		
		SWIZZLER2<DWORD> narf (4096, 4096, 0);


		DWORD hr;
		IDirect3DCubeTexture8* t[3];
		RECT r;
		D3DLOCKED_RECT l;
		D3DLOCKED_RECT l2;
		D3DLOCKED_RECT l3;
		D3DLOCKED_RECT l4;
		int i, j;
		int u, v;
		int p;
		bool isbad = false;

		SWIZZLER a (4096, 4096, 0);
		SWIZCOORD coords[32];

		xStartVariation(hlog, " ");
		STARTLEAKCHECK();

	//		create huge CubeTexture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateCubeTexture(4096, 13, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[0]);
		CHECKRESULT(hr == D3D_OK /*Create huge CubeTexture*/);

		r.top = 0;
		r.left = 0;
		r.right = 4095;
		r.bottom = 4095;

	//		locks the top layer as RAW_DATA
		hr = t[0]->LockRect(0, &l, &r, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock top layer RAW*/);
		CHECKRESULT(l.Pitch == 4096 /*lock top layer RAW*/);
		coords[0].Init(   2,    0,    0, &a);
		coords[1].Init(   3,    0,    0, &a);
		coords[2].Init(4095, 4094,    0, &a);
		coords[3].Init(2047, 2047,    0, &a);

	//		sets a few random pixels
		((BYTE*)l.pBits)[coords[0].c] = 0;
		((BYTE*)l.pBits)[coords[1].c] = 255;
		((BYTE*)l.pBits)[coords[2].c] = 31;
		((BYTE*)l.pBits)[coords[3].c] = 41;

	//		unlocks top layer
		hr = t[0]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*unlock top layer RAW*/);
		
	//		locks top layer (unswizzled)
		hr = t[0]->LockRect(0, &l, &r, 0); 
		CHECKRESULT(hr == D3D_OK /*lock top layer unswizzled*/);
		CHECKRESULT(l.Pitch == 4096 /*lock top layer unswizzled*/);

	//		checks if the pixels tweaked earlier are still set
		if(((BYTE*)l.pBits)[coords[0].i] != 0) isbad = true;
		if(((BYTE*)l.pBits)[coords[1].i] != 255) isbad = true;
		if(((BYTE*)l.pBits)[coords[2].i] != 31) isbad = true;
		if(((BYTE*)l.pBits)[coords[3].i] != 41) isbad = true;
		CHECKRESULT(isbad == false /*swizzle didn't work right*/);
		isbad = false;

	//		locks layer 3 (512x512), (RAW)
		hr = t[0]->LockRect(3, &l2, NULL, D3DLOCK_RAWDATA); //this should be a 512x512 CubeTexture (swizzled)
		CHECKRESULT(hr == D3D_OK /*second mipmap lock*/);

	//		sets a lot more pixels on top layer
		for(j = 0; j < 4096; j += 273) {
			for(i = 0; i < 4096; i += 259) {
				((BYTE*)l.pBits)[i + j * l.Pitch] = i + j;
			}
		}

	//		sets some pixels on layer 3
		for(i = 0; i < l2.Pitch; i++) {
			for(j = 0; j < l2.Pitch; j++) {
				((BYTE*)l2.pBits)[i + j * l2.Pitch] = 1;
			}
		}

	//		unlocks top layer
		hr = t[0]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*swizzled CubeTexture unlock*/);

	//		locks top layer (RAW)
		hr = t[0]->LockRect(0, &l, &r, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock top layer RAW*/);
		CHECKRESULT(l.Pitch == 4096 /*lock top layer RAW*/);

	//		lock bottom layer (RAW)
		hr = t[0]->LockRect(12, &l3, NULL, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock bottom layer RAW*/);
		CHECKRESULT(l.Pitch == 1 /*lock bottom layer RAW*/);

	//		create another CubeTexture (256x512, 1 mip layer, 32bits/pixel == 128k)
		hr = g_pd3dd8->CreateCubeTexture(2048, 256, 1, 0, D3DFMT_R8G8B8A8, D3DPOOL_DEFAULT, &t[1]);
		CHECKRESULT(hr == D3D_OK /*create second CubeTexture while first is unlocked*/);
		SWIZZLER b (2048, 256, 0);

	//		lock second CubeTexture (unswizzled)
		hr = t[1]->LockRect(0, &l4, NULL, 0); 
		CHECKRESULT(hr == D3D_OK);
		CHECKRESULT(l.Pitch == 2048 * sizeof(DWORD));

	//		write pixels to second CubeTexture
		coords[10].Init(   0,    0, 0, &b);
		coords[11].Init(   1,    0, 0, &b);
		coords[12].Init(   2,    0, 0, &b);
		coords[13].Init( 767,  255, 0, &b);
		coords[14].Init(2047,  255, 0, &b);
		coords[15].Init(2046,  254, 0, &b);
		((DWORD*)l4.pBits)[coords[10].i] = 0x12345678;
		((DWORD*)l4.pBits)[coords[11].i] = 0x11111111;
		((DWORD*)l4.pBits)[coords[12].i] = 0x33445566;
		((DWORD*)l4.pBits)[coords[13].i] = 0x91807f6e;
		((DWORD*)l4.pBits)[coords[14].i] = 0xfffefdfc;
		((DWORD*)l4.pBits)[coords[15].i] = 0x01020304;

	//		set a pixel on bottom layer of first CubeTexture
		*((BYTE*)l3.pBits) = 255;

	//		unlock bottom layer of first CubeTexture(RAW)
		hr = t[0]->UnlockRect(12);
		CHECKRESULT(hr == D3D_OK /*bottom-layer mipmap unlock*/);

	//		unlock layer 3 of first CubeTexture(RAW)
		hr = t[0]->UnlockRect(3);
		CHECKRESULT(hr == D3D_OK /*layer 3 mipmap unlock*/);

	//		unlock second CubeTexture (unswizzled)
		hr = t[1]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*second CubeTexture unlock*/);

	//		checks for corruption of pixels set on RAW top layer
		SWIZNUM big_u_259 = a.Convert(259, UCOORD);
		SWIZNUM big_v_273 = a.Convert(273, VCOORD);
		a.Set(0,UCOORD);
		for(j = 0; j < 2096; j += 273) {
			a.Set(0,VCOORD);
			for(i = 0; i < 4096; i += 259) {
				if(((BYTE*)l.pBits)[a.Get2()] != i + j) {isbad = true; break;}
				a.Add(big_u_259, UCOORD);
			}
			a.Add(big_v_273, VCOORD);
		}
		CHECKRESULT(isbad == false /*unswizzle of top layer didn't work right*/ );
		isbad = false;

	//		unlock top layer
		hr = t[0]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*unlock top layer*/);

	//		locks top layer (unswizzled)
		hr = t[0]->LockRect(0, &l, &r, 0); 
		CHECKRESULT(hr == D3D_OK /*second unswizzling of top layer*/);
		CHECKRESULT(l.Pitch == 4096 /*lock top layer of first CubeTexture*/);

	//		unlock top layer
		hr = t[0]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*second reswizzling of top layer*/);

	//		delete first CubeTexture
		hr = t[0]->Release();
		CHECKRESULT(hr == 0 /*release first CubeTexture*/);

	//		lock second CubeTexture (RAW)
		hr = t[1]->LockRect(0, &l4, NULL, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock second CubeTexture, RAW*/);
		CHECKRESULT(l.Pitch == 2048 * sizeof(DWORD) /*second CubeTexture RAW*/);

	//		check for corrupted pixels of second CubeTexture
		if(((DWORD*)l4.pBits)[coords[10].c] != 0x12345678) isbad = true;
		if(((DWORD*)l4.pBits)[coords[11].c] != 0x11111111) isbad = true;
		if(((DWORD*)l4.pBits)[coords[12].c] != 0x33445566) isbad = true;
		if(((DWORD*)l4.pBits)[coords[13].c] != 0x91807f6e) isbad = true;
		if(((DWORD*)l4.pBits)[coords[14].c] != 0xfffefdfc) isbad = true;
		if(((DWORD*)l4.pBits)[coords[15].c] != 0x01020304) isbad = true;
		CHECKRESULT(isbad == false /*corrupted pixels of second CubeTexture*/);

		//		unlock second CubeTexture (RAW)
		hr = t[1]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*second CubeTexture unlock*/);

	//		delete second CubeTexture
		hr = t[1]->Release();
		CHECKRESULT(hr == 0);

	//check for leaks
		CHECKLEAKS();
		xEndVariation(hlog);
	}
	ENDTEST()



	BEGINTEST(testCubeTextureUpdateCubeTexture)
	{
		/*
		This test does the following:
			create huge CubeTexture map (4096x4096x8bit), full mips (22.3 mb)
			write random pixels to first CubeTexture (multiple layers)
			create second huge CubeTexture map (4096x4096x8bit), full mips
			use UpdateCubeTexture to copy first CubeTexture to second
			delete first CubeTexture
			check random pixels in second CubeTexture (unswizzled)
			create 256x256 CubeTexture map, full mips
			copy lower mip layers from CubeTexture2 to CubeTexture3
			check CubeTexture3
			change pixels in CubeTexture2
			copy lower mip layers from CubeTexture2 to CubeTexture3
			check CubeTexture3
			delete CubeTexture2, CubeTexture3

		this checks:
			big CubeTexture
			full mip copy
			8-bit
			partial mip copy
			square CubeTexture
			multiple copy from same source
		*/
		DWORD hr;

		IDirect3DCubeTexture8* t[3];
		RECT r;
		D3DLOCKED_RECT l;

		SWIZZLER a (4096, 4096, 0);
		struct COORD {
			DWORD u;
			DWORD v;
			int layer;
		} coords [] = {
			{0, 0, 0},
			{4095, 4095, 0},
			{2048, 2047, 0},
			{1022, 34, 2},
			{100, 4, 4},
			{32, 32, 5},
			{0, 15, 8},
			{6, 2, 9},
			{2, 3, 10},
			{0, 1, 11},
			{1, 0, 11},
			{0, 0, 12},
		};
		int i;
		bool isbad = false;

		xStartVariation(hlog, "CubeTexture UpdateCubeTexture");
		STARTLEAKCHECK();

	//		create huge CubeTexture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateCubeTexture(4096, 4096, 13, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[0]);
		CHECKRESULT(hr == D3D_OK /*Create huge CubeTexture*/);

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[0]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = (BYTE)i;

		//		unlock layer
			hr = t[0]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);

		}

	//		create second huge CubeTexture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateCubeTexture(4096, 4096, 13, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[1]);
		CHECKRESULT(hr == D3D_OK /*Create second huge CubeTexture*/);

	//		use UpdateCubeTexture to copy first CubeTexture to second
		hr = g_pd3dd8->UpdateCubeTexture(t[0], t[1]);
		CHECKRESULT(hr == D3D_OK /*Update on huge CubeTexture*/);

	//		delete first CubeTexture
		hr = t[0]->Release();
		CHECKRESULT(hr == 0 /*release first huge CubeTexture*/);

	//		check bytes in second CubeTexture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != (BYTE)i) isbad = true;

		//		unlock layer
			hr = t[1]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateCubeTexture*/);
		isbad = false;

	//		create smaller CubeTexture (256x256, full mips, 8bits/pixel), 
		hr = g_pd3dd8->CreateCubeTexture(256, 256, 0, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[2]);
		CHECKRESULT(hr == D3D_OK /*Create 256x256 CubeTexture*/);

	//		use UpdateCubeTexture to copy second CubeTexture to third
		hr = g_pd3dd8->UpdateCubeTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small*/);
		
	//		check bytes in third CubeTexture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 4) {
				hr = t[1]->LockRect(coords[i].layer -4, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != i) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer -4);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateCubeTexture to smaller CubeTexture*/);
		isbad = false;

		coords[ 0].u = 255; coords[ 0].v = 255; coords[ 0].layer = 4;
		coords[ 0].u = 254; coords[ 0].v = 255; coords[ 0].layer = 4;
		coords[ 0].u = 185; coords[ 0].v =  25; coords[ 0].layer = 4;
		coords[ 0].u = 120; coords[ 0].v =   0; coords[ 0].layer = 5;
		coords[ 0].u =   0; coords[ 0].v =   0; coords[ 0].layer = 5;
		coords[ 0].u =  63; coords[ 0].v =  63; coords[ 0].layer = 6;
		coords[ 0].u =   7; coords[ 0].v =   0; coords[ 0].layer = 9;
		coords[ 0].u =   0; coords[ 0].v =   3; coords[ 0].layer =10;
		coords[ 0].u =   1; coords[ 0].v =   1; coords[ 0].layer =11;
		coords[ 0].u = 125; coords[ 0].v = 128; coords[ 0].layer = 4;
		coords[ 0].u =   0; coords[ 0].v =   0; coords[ 0].layer =12;
		coords[ 0].u =  30; coords[ 0].v =  31; coords[ 0].layer = 7;

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = -i;

		//		unlock layer
			hr = t[1]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}

		//		use UpdateCubeTexture to copy second CubeTexture to third
		hr = g_pd3dd8->UpdateCubeTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small again*/);

	//		check bytes in third CubeTexture again
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 4) {
				hr = t[1]->LockRect(coords[i].layer -4, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != -i) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer -4);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateCubeTexture to smaller CubeTexture*/);
		isbad = false;


		//		delete third CubeTexture
		hr = t[2]->Release();
		CHECKRESULT(hr == 0 /*release smaller CubeTexture*/);

	//		delete second CubeTexture
		hr = t[1]->Release();
		CHECKRESULT(hr == 0 /*release second big CubeTexture*/);

		CHECKLEAKS();
		xEndVariation(hlog);
	}
	ENDTEST()

	BEGINTEST(testCubeTextureUpdateCubeTextureNonSquare)
	{
		/*
		This test does the following:
			create huge CubeTexture map (4096x1024x16bit), full mips 
			write random pixels to first CubeTexture (multiple layers)
			create second huge CubeTexture map (4096x1024x16it), full mips
			use UpdateCubeTexture to copy first CubeTexture to second
			delete first CubeTexture
			check random pixels in second CubeTexture (unswizzled)
			create 256x64x16bit CubeTexture map, full mips
			copy lower mip layers from CubeTexture2 to CubeTexture3
			check CubeTexture3
			change pixels in CubeTexture2
			copy lower mip layers from CubeTexture2 to CubeTexture3
			check CubeTexture3
			delete CubeTexture2, CubeTexture3

		this checks:
			big CubeTexture
			full mip copy
			16-bit
			partial mip copy
			square CubeTexture
			multiple copy from same source
		*/
		DWORD hr;

		IDirect3DCubeTexture8* t[3];
		RECT r;
		D3DLOCKED_RECT l;

		SWIZZLER a (4096, 1024, 0);
		struct COORD {
			DWORD u;
			DWORD v;
			int layer;
		} coords [] = {
			{0, 0, 0},
			{4095, 1023, 0},
			{2048, 512, 0},
			{1022, 34, 2},
			{100, 4, 4},
			{32, 15, 5},
			{0,  3, 8},
			{6, 1, 9},
			{2, 0, 10},
			{0, 0, 11},
			{1, 0, 11},
			{0, 0, 12},
		};
		int i;
		bool isbad = false;

		xStartVariation(hlog, "CubeTexture UpdateCubeTexture");
		STARTLEAKCHECK();

	//		create huge CubeTexture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateCubeTexture(4096, 1024, 13, 0, D3DFMT_R5G6B5, D3DPOOL_DEFAULT, &t[0]);
		CHECKRESULT(hr == D3D_OK /*Create huge CubeTexture*/);

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[0]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((WORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = (WORD)i;

		//		unlock layer
			hr = t[0]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);

		}

	//		create second huge CubeTexture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateCubeTexture(4096, 1024, 13, 0, D3DFMT_R5G6B5, D3DPOOL_DEFAULT, &t[1]);
		CHECKRESULT(hr == D3D_OK /*Create second huge CubeTexture*/);

	//		use UpdateCubeTexture to copy first CubeTexture to second
		hr = g_pd3dd8->UpdateCubeTexture(t[0], t[1]);
		CHECKRESULT(hr == D3D_OK /*Update on huge CubeTexture*/);

	//		delete first CubeTexture
		hr = t[0]->Release();
		CHECKRESULT(hr == 0 /*release first huge CubeTexture*/);

	//		check bytes in second CubeTexture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//compare byte
			if(((WORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != (WORD)i) isbad = true;

		//		unlock layer
			hr = t[1]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateCubeTexture*/);
		isbad = false;

	//		create smaller CubeTexture (256x256, full mips, 8bits/pixel), 
		hr = g_pd3dd8->CreateCubeTexture(256, 64, 0, 0, D3DFMT_R5G6B5, D3DPOOL_DEFAULT, &t[2]);
		CHECKRESULT(hr == D3D_OK /*Create 256x256 CubeTexture*/);

	//		use UpdateCubeTexture to copy second CubeTexture to third
		hr = g_pd3dd8->UpdateCubeTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small*/);
		
	//		check bytes in third CubeTexture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 4) {
				hr = t[1]->LockRect(coords[i].layer -4, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((WORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != i) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer -4);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateCubeTexture to smaller CubeTexture*/);
		isbad = false;

		coords[ 0].u = 255; coords[ 0].v =  63; coords[ 0].layer = 4;
		coords[ 0].u = 254; coords[ 0].v =  63; coords[ 0].layer = 4;
		coords[ 0].u = 185; coords[ 0].v =  25; coords[ 0].layer = 4;
		coords[ 0].u = 120; coords[ 0].v =   0; coords[ 0].layer = 5;
		coords[ 0].u =   0; coords[ 0].v =   0; coords[ 0].layer = 5;
		coords[ 0].u =  63; coords[ 0].v =  15; coords[ 0].layer = 6;
		coords[ 0].u =   7; coords[ 0].v =   0; coords[ 0].layer = 9;
		coords[ 0].u =   0; coords[ 0].v =   3; coords[ 0].layer =10;
		coords[ 0].u =   1; coords[ 0].v =   1; coords[ 0].layer =11;
		coords[ 0].u = 125; coords[ 0].v =  32; coords[ 0].layer = 4;
		coords[ 0].u =   0; coords[ 0].v =   0; coords[ 0].layer =12;
		coords[ 0].u =  30; coords[ 0].v =   5; coords[ 0].layer = 7;

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((WORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = (WORD)(-i);

		//		unlock layer
			hr = t[1]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}

		//		use UpdateCubeTexture to copy second CubeTexture to third
		hr = g_pd3dd8->UpdateCubeTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small again*/);

	//		check bytes in third CubeTexture again
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 4) {
				hr = t[1]->LockRect(coords[i].layer -4, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((WORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != (WORD)(-i)) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer -4);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateCubeTexture to smaller CubeTexture*/);
		isbad = false;


		//		delete third CubeTexture
		hr = t[2]->Release();
		CHECKRESULT(hr == 0 /*release smaller CubeTexture*/);

	//		delete second CubeTexture
		hr = t[1]->Release();
		CHECKRESULT(hr == 0 /*release second big CubeTexture*/);

		CHECKLEAKS();
		xEndVariation(hlog);
	}
	ENDTEST()

	BEGINTEST(testCubeTextureUpdateCubeTextureNonSquare2)
	{
		/*
		This test does the following:
			create huge CubeTexture map (16x2048x32bit), 6 mip layers 
			write random pixels to first CubeTexture (multiple layers)
			create second huge CubeTexture map (2048x16x32it), 6 mip layers
			use UpdateCubeTexture to copy first CubeTexture to second
			delete first CubeTexture
			check random pixels in second CubeTexture (unswizzled)
			create 1x64 CubeTexture map, 1 layer
			copy lowest mip layers from CubeTexture2 to CubeTexture3
			check CubeTexture3
			change pixels in CubeTexture2
			copy lowest mip layer from CubeTexture2 to CubeTexture3
			check CubeTexture3
			delete CubeTexture2, CubeTexture3

		this checks:
			big CubeTexture
			32-bit
			1-layer mip copy
			non-square CubeTexture
			multiple copy from same source
		*/
		
		DWORD hr;

		IDirect3DCubeTexture8* t[3];
		RECT r;
		D3DLOCKED_RECT l;

		SWIZZLER a (16, 2048, 0);
		struct COORD {
			DWORD u;
			DWORD v;
			int layer;
		} coords [] = {
			{0, 0, 0},
			{15, 2047, 0},
			{7, 1821, 0},
			{5, 1000, 1},
			{1, 34, 2},
			{0, 4, 4},
			{0, 17, 5},
		};
		int i;
		bool isbad = false;

		xStartVariation(hlog, "CubeTexture UpdateCubeTexture");
		STARTLEAKCHECK();

	//		create huge CubeTexture (16x1024, 6 mip layers, 32bits/pixel), 
		hr = g_pd3dd8->CreateCubeTexture(16, 2048, 6, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t[0]);
		CHECKRESULT(hr == D3D_OK /*Create huge CubeTexture*/);

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[0]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((DWORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = (DWORD)i;

		//		unlock layer
			hr = t[0]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);

		}

	//		create second huge CubeTexture (4096x4096, 6 mip layers, 32bits/pixel), 
		hr = g_pd3dd8->CreateCubeTexture(16, 2048, 6, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t[1]);
		CHECKRESULT(hr == D3D_OK /*Create second huge CubeTexture*/);

	//		use UpdateCubeTexture to copy first CubeTexture to second
		hr = g_pd3dd8->UpdateCubeTexture(t[0], t[1]);
		CHECKRESULT(hr == D3D_OK /*Update on huge CubeTexture*/);

	//		delete first CubeTexture
		hr = t[0]->Release();
		CHECKRESULT(hr == 0 /*release first huge CubeTexture*/);

	//		check bytes in second CubeTexture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//compare byte
			if(((DWORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != (DWORD)i) isbad = true;

		//		unlock layer
			hr = t[1]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateCubeTexture*/);
		isbad = false;

	//		create smaller CubeTexture (256x256, 1 layer, 32bits/pixel), 
		hr = g_pd3dd8->CreateCubeTexture(1, 64, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t[2]);
		CHECKRESULT(hr == D3D_OK /*Create 256x256 CubeTexture*/);

	//		use UpdateCubeTexture to copy second CubeTexture to third
		hr = g_pd3dd8->UpdateCubeTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small*/);
		
	//		check bytes in third CubeTexture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 4) {
				hr = t[1]->LockRect(coords[i].layer -4, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != i) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer -4);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateCubeTexture to smaller CubeTexture*/);
		isbad = false;

		coords[ 0].u = 0; coords[ 0].v =  63; coords[ 0].layer = 6;
		coords[ 1].u = 0; coords[ 1].v =  21; coords[ 1].layer = 6;
		coords[ 2].u = 0; coords[ 2].v =   0; coords[ 2].layer = 6;
		coords[ 3].u = 0; coords[ 3].v =  13; coords[ 3].layer = 6;
		coords[ 4].u = 0; coords[ 4].v =  11; coords[ 4].layer = 6;
		coords[ 5].u = 0; coords[ 5].v =  62; coords[ 5].layer = 6;
		coords[ 6].u = 0; coords[ 6].v =  14; coords[ 6].layer = 6;

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((DWORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = (DWORD)(2*i);

		//		unlock layer
			hr = t[1]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}

		//		use UpdateCubeTexture to copy second CubeTexture to third
		hr = g_pd3dd8->UpdateCubeTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small again*/);

	//		check bytes in third CubeTexture again
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 4) {
				hr = t[1]->LockRect(coords[i].layer -6, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != DWORD(2*i)) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer -6);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateCubeTexture to smaller CubeTexture*/);
		isbad = false;


		//		delete third CubeTexture
		hr = t[2]->Release();
		CHECKRESULT(hr == 0 /*release smaller CubeTexture*/);

	//		delete second CubeTexture
		hr = t[1]->Release();
		CHECKRESULT(hr == 0 /*release second big CubeTexture*/);

		CHECKLEAKS();
		xEndVariation(hlog);
	}
	ENDTEST()

#endif //0

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\d3dapi.hpp ===
#ifndef __d3dapi_h_
#define __d3dapi_h_

#pragma warning(disable: 4509;disable:4731)

#include <xtl.h>

#include "d3dapimmstats.h"

#include <stdio.h>

#include <tchar.h>
#include <d3dx8.h>
#include <xlog.h>
#include <xtestlib.h>
#include "swizzler.h"

#include <time.h>

#define LINKME(n) namespace d3dapi { int dummy##n() { return n; } }
#define C_(n) d3dapi::dummy##n()
#define D_(n) namespace d3dapi { int dummy##n(); }



//****************************************************************************
// A few remainder macros shamelessly stolen from dsound.
//****************************************************************************
#define QUOTE0(a)               #a
#define QUOTE1(a)               QUOTE0(a)

//
// #pragma Reminders
//

#define MESSAGE(a)              message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)                 MESSAGE("TODO: " a)
#define BUGBUG(a)               MESSAGE("BUGBUG: " a)
#define HACKHACK(a)             MESSAGE("HACKHACK: " a)

#ifndef min
  #define min(a, b) (((a) < (b)) ? (a) : (b))
  #define max(a, b) (((a) > (b)) ? (a) : (b))
  #define min3(a, b, c) min(a, min(b, c))
  #define max3(a, b, c) max(a, max(b, c))
#endif //def min

#define ASSERT(x) {if(!(x)) { xLog(d3dapi::hlog,XLL_INFO, "ASSERT: " #x); }}

//***************************************************************************

#define BEGINTEST(func)                                 \
    namespace d3dapi {                                  \
     DWORD func();                                      \
     TESTFUNC p##func = func;                           \
     DWORD func() {                                     \
      char funcname[] = #func;                          \
      xSetFunctionName(hlog, funcname);                 \
      OutputDebugString(L"D3dapi: Entering " L###func L"\n");   \
      DWORD status = XLL_PASS;                          \
      MM_STATISTICS         mmStats, mmStats2;          \
      PS_STATISTICS         psStats, psStats2;          \
      ZeroMemory(&mmStats, sizeof(mmStats));            \
      mmStats.Length = sizeof(mmStats);                 \
      ZeroMemory(&psStats, sizeof(psStats));            \
      psStats.Length = sizeof(psStats);                 \
      ZeroMemory(&mmStats2, sizeof(mmStats2));          \
      mmStats2.Length = sizeof(mmStats2);               \
      ZeroMemory(&psStats2, sizeof(psStats2));          \
      psStats2.Length = sizeof(psStats2);               \

//    __try {
    
#define ENDTEST()                                       \
      return status;                                    \
    }}  
/*
#define ENDTEST()                                       \
      } _except(D3DAPIExceptionHandler(GetExceptionInformation())) {    \
       xLog(hlog, XLL_EXCEPTION, "Exception in %s", funcname);  \
       xEndVariation(hlog);                             \
       status = XLL_FAIL;                               \
        _asm {int 3}                                        \
      }                                                 \
      return status;                                    \
    }}  
*/

#define STARTLEAKCHECK()                                \
    MmQueryStatistics(&mmStats);                        \
    PsQueryStatistics(&psStats);                        

#define CHECKLEAKS()                                    \
    MmQueryStatistics(&mmStats2);                       \
    PsQueryStatistics(&psStats2);                       \
    d3dapi::CompareStats(&mmStats,  &mmStats2, &psStats, &psStats2);            


//#define RESETRESULT()                                 \
//  status = XLL_PASS;

#define WASBADRESULT()                                  \
    (status != XLL_PASS)

#define WASGOODRESULT()                                 \
    (status == XLL_PASS)

#define CHECKRESULT(x)                                  \
    if(!(x)) status = XLL_FAIL; else status = XLL_PASS;\
    xLog(hlog, status, __FILE__ "(" QUOTE1(__LINE__) "): " #x)
                
#define CHECKRESULTNOLOG(x)                             \
    (status = ((x) ? XLL_PASS : XLL_FAIL))

#define BLOCKRESULT(x)                                  \
    if(!(x)) status = XLL_BLOCK; else status = XLL_PASS;\
    xLog(hlog, status, __FILE__ "(" QUOTE1(__LINE__) "): " #x)

#define GETRESULT()                                     \
    (status)

#define COUNTOF(x) (sizeof(x) / sizeof(x[0]))
#define LASTOF(x) (COUNTOF(x) - 1)
#define countof(a) COUNTOF(a)
#define MIN(a,b) min(a,b)
#define MAX(a,b) max(a,b)
#define ROUNDUP(a,b) (((a) + ((b)-1)) & ~((b)-1)) //if b == power of 2
#define ROUNDDOWN(a,b) ((a) & !((b)-1))           //if b == power of 2

typedef DWORD (*TESTFUNC)();

void CallAllDummyFunctions();

namespace d3dapi {
    extern HANDLE hlog;

    extern HINSTANCE                g_hInstance;
    extern LPDIRECT3D8              g_pd3d8;
    extern LPDIRECT3DDEVICE8        g_pd3dd8;
//  extern LPDIRECT3DSWAPCHAIN8     g_pd3dsw8;
    extern LPDIRECT3DTEXTURE8       g_pd3dt8;
    extern LPDIRECT3DCUBETEXTURE8   g_pd3dtc8;
    extern LPDIRECT3DVOLUMETEXTURE8 g_pd3dtv8;
    extern LPDIRECT3DVERTEXBUFFER8  g_pd3dr8;
    extern LPDIRECT3DINDEXBUFFER8   g_pd3di8;
    extern LPDIRECT3DTEXTURE8       g_pd3dtSurf8;
    extern LPDIRECT3DSURFACE8       g_pd3ds8;
    extern LPDIRECT3DCUBETEXTURE8   g_pd3dtcSurf8;
    extern LPDIRECT3DSURFACE8       g_pd3dsc8;
    extern LPDIRECT3DVOLUMETEXTURE8 g_pd3dtvVol8;
    extern LPDIRECT3DVOLUME8        g_pd3dv8;

    ULONG rnd();
    VOID srnd(UINT seed);
    DWORD CompareStats(MM_STATISTICS*, MM_STATISTICS*, PS_STATISTICS*, PS_STATISTICS*);
    void RegisterDeinitFunc(TESTFUNC deinitproc);
    void RegisterDoAgain(TESTFUNC* newfunc);

    int D3DAPIExceptionHandler(EXCEPTION_POINTERS* p);

    class SWIZCOORD {
    public:
        DWORD u;
        DWORD v;
        DWORD s;
        SWIZNUM c;
        DWORD i;
        void Init(DWORD newu, DWORD newv, DWORD news, SWIZZLER* ps) {
            u = newu; v = newv; s = news; 
            c = ps->Convert(u, UCOORD) | ps->Convert(v, VCOORD) | ps->Convert(s, SCOORD);
            i = u + v * ps->m_size[UCOORD] + s * ps->m_size[UCOORD] * ps->m_size[VCOORD];
        }
    };

    inline DWORD Log2(DWORD Value)
    {
        ASSERT((Value & (Value - 1)) == 0);

        __asm {
            mov eax,[Value]   
            bsf ecx,eax 
            mov [Value],ecx
        }
        return Value;
    }
}

namespace D3D {
    DWORD BitsPerPixelOfD3DFORMAT(DWORD Format);
}

#pragma warning(disable:4035)
__inline __int64 GetTsc(){_asm {push ebx} _asm {cpuid} _asm{rdtsc} _asm {pop ebx}}
__inline __int64 GetSecCount(){ return GetTsc() / 733000000; }
__inline __int64 GetMsCount(){ return GetTsc() / 733000; }
__inline __int64 GetUsCount(){ return GetTsc() / 733; }
#pragma warning(default:4035)


#endif //def __d3dapi_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\d3dapimmstats.h ===
#ifndef _d3dapiMMstats_h_
#define _d3dapiMMstats_h_

/*
You'd think that we'd be able to have headers arranged in such a way that we 
could just #include "mm.h" and "ps.h", or "nt.h" or something similar, along 
with "xtl.h", in order to get at some of the more useful kernel features and 
everything would be happy & compile correctly. You'd think, anyway...
*/

typedef struct _MM_STATISTICS {
    ULONG Length;
    ULONG TotalPhysicalPages;
    ULONG AvailablePages;
    ULONG VirtualMemoryBytesCommitted;
    ULONG VirtualMemoryBytesReserved;
    ULONG CachePagesCommitted;
    ULONG PoolPagesCommitted;
    ULONG StackPagesCommitted;
    ULONG ImagePagesCommitted;
} MM_STATISTICS, *PMM_STATISTICS;

#define NTKERNELAPI DECLSPEC_IMPORT         // wdm
typedef LONG NTSTATUS;

EXTERN_C
NTKERNELAPI
NTSTATUS
MmQueryStatistics(
    IN OUT PMM_STATISTICS MemoryStatistics
    );

typedef struct _PS_STATISTICS {
    ULONG Length;
    ULONG ThreadCount;
    ULONG HandleCount;
} PS_STATISTICS, *PPS_STATISTICS;

EXTERN_C
NTKERNELAPI
NTSTATUS
PsQueryStatistics(
    IN OUT PPS_STATISTICS ProcessStatistics
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\d3dapi.cpp ===
#include "d3dapi.hpp"

/*
In order to not have to maintain a huge 30-page list of all test functions,
BEGINTEST(blah) creates a function named blah, and a function pointer pblah,
that points to blah. 
Data segments (like #pragma data_seg(".d3dapi$test070")) are used to 
collect these function pointers in memory. 
#pragma comment(linker, "/merge:.d3dapi=.data") sorts all of the data_seg sections 
alphabetically. I got this idea from MitchD, who used a similar method to collect 
usb class drivers.

ExecuteTests starts with pInit, and calls every function pointer until a NULL 
pointer is reached, or it gets to Deinit.

Note that no static variables can be used in the test functions without using 
a different data segment for them, since they will be placed in memory in the same 
data_seg as the function pointers. Global variables declared outside of the data_segs 
are recommended instead...

/***************************************************************************************
/***************************************************************************************
/***************************************************************************************
/***************************************************************************************

In order to remove tests for a particular function, just comment the appropriate C_(x) 
from linkme.cpp. 
from linkme.cppremove the appropriate number
from linkme.cpp that matches x in LINKME(x) at the top of that test file. Note that
direct3d8init must be included for any testing, and direct3ddevice8init must be included 
for most everything. 

Linkme.cpp is used to ensure that all files are linked. A really cool, but really
annoying feature of the ms linker is the ability to remove unreferenced modules from the 
final link of .exe files (hence, also, .xbe's). Since there are no direct references to any
functions in the test modules for d3dapi, the linker removes them from any .exe file that 
uses d3dapi.lib. (note that this doesn't happen if d3dapi is built as a .dll).
The macro LINKME(x) creates a function that is called by LinkMe. (x) should be a unique
number or name, and needs to be matched with _C(x) and _D(x) macros in linkme.cpp.

RegisterDeinitFunc can be used to ensure that a deinitialization function is called
when the "end of the line" is reached (end of the line == a NULL function pointer, or pDeinit). 
RegisterDoAgain is used to run more tests when the end of the line is reached. This way,
if you want to try several dozen tests with 2 or 3 variations of the IDirect3dDevice, 
the function that creates the device can register itself (by passing NULL) by calling 
RegisterDoAgain. It can deinitialize the device, and recreate it, and the tests after that
will then be repeated with the new device setup.

DeinitFunc and DoAgain are implimented as a stack, and share the same stack. When the 
"end of the line" is reached, the next item on the stack is called and removed from the stack. 
When the stack is gone, d3dapi testing stops.


A list of the data_segs used:
.d3dapi$test0		Init


.d3dapi$test005 	pre-IDirect3D8 tests
.d3dapi$test010 	IDirect3D8 init
.d3dapi$test020 	IDirect3D8 tests

.d3dapi$test025 	IDirect3DDevice8 Init

.d3dapi$test030		D3DVertexBuffer tests

  51, 52, 53: lock tests
.d3dapi$test060 	IDirect3DDevice8 tests

.d3dapi$test061 	Cursor

.d3dapi$test070 	Resource

.d3dapi$test080 	Base Texture?

.d3dapi$test100 	Texture
.d3dapi$test110 	CubeTexture
.d3dapi$test120 	VolumeTexture

.d3dapi$test220		Volume8

.d3dapi$testzzz 	Deinit
*/

namespace d3dapi {
	HANDLE hlog;

/*
we were having problems with the multi-threaded version of rand(), so I
am just using the non-multithreaded code... D3d doesn't run multi-threaded
anyway, and this code doesn't share any variables with other rand() implimentations, 
so this shouldn't matter.
*/
	static ULONG holdrand = 1;
	void srnd(UINT seed)
	{
		holdrand = seed;
	}
	ULONG rnd() 
	{
		return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
	}



	#pragma data_seg(".d3dapi$test0") //before A

	BEGINTEST(Init)
	{ 
	}
	ENDTEST()
	#pragma data_seg()
	
	#pragma data_seg(".d3dapi$testzzz") //last supported char
	BEGINTEST(Deinit)
	{ 
	}
	ENDTEST()
	
	TESTFUNC NullPointerAfterDeinit = 0; //in case I remove hard-coding of Deinit being the last function
	#pragma data_seg()
	
	
	
	#pragma comment(linker, "/merge:.d3dapi=.rdata")
	
	typedef struct _FUNCLIST {
		struct _FUNCLIST * next;
		BOOL doagain;
		union {
			TESTFUNC func;
			TESTFUNC*pfunc;
		};	
	} FUNCLIST;

	FUNCLIST* gpdeinit = NULL;
	TESTFUNC* gCurFunc = 0;
	
	void RegisterDeinitFunc(TESTFUNC proc)
	{
		FUNCLIST* p = gpdeinit;
		gpdeinit = new FUNCLIST;
		gpdeinit->func = proc;
		gpdeinit->next = p;
		gpdeinit->doagain = FALSE;
	}
	
	void RegisterDoAgain(TESTFUNC* newfunc)
	{
		FUNCLIST* p = gpdeinit;
		gpdeinit = new FUNCLIST;
		gpdeinit->pfunc = (newfunc ? newfunc : gCurFunc);
		gpdeinit->next = p;
		gpdeinit->doagain = TRUE;
	}
	
	
	HINSTANCE				 g_hInstance;
	LPDIRECT3D8 			 g_pd3d8 = NULL;
	LPDIRECT3DDEVICE8		 g_pd3dd8 = NULL;
	//LPDIRECT3DSWAPCHAIN8	   g_pd3dsw8 = NULL;
	LPDIRECT3DTEXTURE8		 g_pd3dt8 = NULL;
	LPDIRECT3DCUBETEXTURE8	 g_pd3dtc8 = NULL;
	LPDIRECT3DVOLUMETEXTURE8 g_pd3dtv8 = NULL;
	LPDIRECT3DVERTEXBUFFER8  g_pd3dr8 = NULL;
	LPDIRECT3DINDEXBUFFER8	 g_pd3di8 = NULL;
	LPDIRECT3DTEXTURE8		 g_pd3dtSurf8 = NULL;
	LPDIRECT3DSURFACE8		 g_pd3ds8 = NULL;
	LPDIRECT3DCUBETEXTURE8	 g_pd3dtcSurf8 = NULL;
	LPDIRECT3DSURFACE8		 g_pd3dsc8 = NULL;
	LPDIRECT3DVOLUMETEXTURE8 g_pd3dtvVol8 = NULL;
	LPDIRECT3DVOLUME8		 g_pd3dv8 = NULL;

	//******************************************************************************
	void ExecuteTests() 
	{
		DWORD status;

		CallAllDummyFunctions();

		gCurFunc = &d3dapi::pInit;			//start with Initialization
		RegisterDoAgain(0); 		//pInit is the first pointer in the "array" to test

		FUNCLIST * f;
		TESTFUNC * p;
		TESTFUNC t;

		while(gpdeinit) {
			if(gpdeinit->doagain == TRUE) {
				p = gpdeinit->pfunc;
				f = gpdeinit;
				gpdeinit = gpdeinit->next;
				delete f;
				for( ; p < &d3dapi::pDeinit && *p; p++) {
					gCurFunc = p;
					status = p[0]();
					if(status == XLL_BLOCK) {		//blocked = terminate this block of tests
						break;
					}
				}
			} else {
				t = gpdeinit->func;
				f = gpdeinit;
				gpdeinit = gpdeinit->next;
				delete f;
				status = t();
			}
		}
	}


	extern "C" void DebugPrint(char*,...);

	int int3(EXCEPTION_POINTERS* p)
	{
		DebugPrint("d3dapi: Unhandled exception 0x%x at %p\n  type \"!cxr 0x%p; !kb\" to get stack trace\n\n",
			p->ExceptionRecord->ExceptionCode,
			p->ExceptionRecord->ExceptionAddress,
			p->ContextRecord);

		_asm{int 3}; 
		return EXCEPTION_EXECUTE_HANDLER;
	}

	int D3DAPIExceptionHandler(EXCEPTION_POINTERS* p)
	{
		DebugPrint("d3dapi: exception 0x%x at %p.  type \"!cxr 0x%p; !kb\" to get stack trace\n\n",
			p->ExceptionRecord->ExceptionCode,
			p->ExceptionRecord->ExceptionAddress,
			p->ContextRecord);

		_asm{int 3}; 
		return EXCEPTION_EXECUTE_HANDLER;
	}


	/*++

	StartTest
  
	Routine Description:

		This is your test entry point. It returns only when all tests have
		completed. If you create threads, you must wait until all threads have
		completed. You also have to create your own heap using HeapAlloc, do not
		use GlobalAlloc or LocalAlloc.

		Please see "x-box test harness.doc" for more information

	Arguments:

		LogHandle - Handle used to call logging APIs. Please see "logging.doc"
			for more information regarding logging APIs

	Return Value:

		None

	--*/

	//#pragma comment(compiler, "-GX")

	VOID WINAPI D3DAPIStartTest(HANDLE Log)
	{
		hlog = Log;
		MM_STATISTICS		  mmStats = {sizeof(MM_STATISTICS), 0, 0, 0, 0, 0}, mmStats2 = {sizeof(MM_STATISTICS), 0, 0, 0, 0, 0};
		PS_STATISTICS		  psStats = {sizeof(PS_STATISTICS), 0, 0}, psStats2 = {sizeof(PS_STATISTICS), 0, 0};

		OutputDebugString( TEXT("d3dapi: StartTest is called\n") );

		xSetComponent( hlog, "Direct3D(S)", "Core (s-d3d)" );
		
		DWORD randomseed;
		randomseed = time(NULL);

		xLog(hlog, XLL_INFO, "random seed: %u", randomseed);
		srnd(randomseed);

		int i;
        for(i = 0; i < 2; i++) {
//		_try {
			MmQueryStatistics(&mmStats);
			PsQueryStatistics(&psStats);
			ExecuteTests();
			MmQueryStatistics(&mmStats2);
			PsQueryStatistics(&psStats2);
			xStartVariation(hlog, "D3dapi Overall Leak Test");
			CompareStats(&mmStats, &mmStats2, &psStats, &psStats2);
			xEndVariation(hlog);
		}

//		} _except(int3(GetExceptionInformation())) {
//			_asm int 3;
//		}

		return;

	}

	/*++

	EndTest

	Routine Description:

		This is your test clean up routine. It will be called only ONCE after
		all threads have done. This will allow you to do last chance clean up.
		Do not put any per-thread clean up code here. It will be called only
		once after you have finished your StartTest.

	Arguments:

		None

	Return Value:

		None

	--*/
	VOID WINAPI D3DAPIEndTest(VOID)
	{
		OutputDebugString( TEXT("d3dapi: EndTest is called\n") );
	}

	/*++

	Routine Description:

		main entry point
		
	Arguments:

		HINSTANCE	hInstance
		DWORD		fdwReason
		LPVOID		lpReserved

	Return Value:

		BOOL

	--*/

	/*
	BOOL
	WINAPI
	DllMain(
		HINSTANCE	hInstance,
		DWORD		fdwReason,
		LPVOID		lpReserved
		)
	{
		UNREFERENCED_PARAMETER( hInstance );
		UNREFERENCED_PARAMETER( lpReserved );

		if ( fdwReason == DLL_PROCESS_ATTACH ) {

		} else if ( fdwReason == DLL_PROCESS_DETACH ) {

		}

		return TRUE;
	}

    int __cdecl main( )
	{
		HANDLE h;
		h = xCreateLog(L"t:\\media\\d3dapi.log",
			NULL,
			-1,
			XLL_LOGALL,
			XLO_DEBUG|XLO_CONFIG|XLO_STATE|XLO_REFRESH
		);
		D3DAPIStartTest(h);
		D3DAPIEndTest();
		return 0;
	}
	*/

	#define CScheck(letter, sign, field)						\
	/*if(letter##1->field sign letter##2->field) {	*/			\
		xLog(hlog, (letter##1->field sign letter##2->field) ? XLL_FAIL : XLL_PASS, #field " before: %u, after: %u", \
			letter##1->field, letter##2->field);				\
		d = XLL_FAIL;											\
	/*}*/

	DWORD CompareStats(MM_STATISTICS* m1, MM_STATISTICS* m2, PS_STATISTICS* p1, PS_STATISTICS* p2)
	{
		DWORD d = XLL_PASS;

		xLog(hlog, XLL_INFO, "Available Pages: before, %u, after: %u", m1->AvailablePages, m2->AvailablePages);
		xLog(hlog, XLL_INFO, "CachePagesCommitted: before, %u, after: %u", m1->CachePagesCommitted, m2->CachePagesCommitted);

		CScheck(m, <, ImagePagesCommitted);
		CScheck(m, <, PoolPagesCommitted);
		CScheck(m, <, StackPagesCommitted);
		CScheck(m, <, VirtualMemoryBytesCommitted);
		CScheck(m, <, VirtualMemoryBytesReserved);
		CScheck(p, <, HandleCount);

		return d;
	/*
		if(m1->AvailablePages > m2->AvailablePages) {
			xLog(hlog, XLL_FAIL, "Available Pages before: %u, after: %u", m1->AvailablePages, m2->AvailablePages);
			d = XLL_FAIL;
		}
	*/
	}

} //namespace

extern "C" void D3DAPISTART(HANDLE h) {
	d3dapi::D3DAPIStartTest(h);
	d3dapi::D3DAPIEndTest();
}

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( D3DAPI )
#pragma data_seg()

BEGIN_EXPORT_TABLE( D3DAPI )
	EXPORT_TABLE_ENTRY( "StartTest", d3dapi::D3DAPIStartTest )
	EXPORT_TABLE_ENTRY( "EndTest", d3dapi::D3DAPIEndTest )
END_EXPORT_TABLE( D3DAPI )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\direct3d8api.cpp ===
#include "d3dapi.hpp"
#include <stdio.h>

LINKME(4)

INT gNumModes = 0;

D3DDISPLAYMODE gDisplayModes[100];

D3DFORMAT format[] = {
//	D3DFMT_R8G8B8,
	D3DFMT_A8R8G8B8,
	D3DFMT_X8R8G8B8,
	D3DFMT_R5G6B5,
	D3DFMT_X1R5G5B5,
//	D3DFMT_A1R5G5B5,
//	D3DFMT_A4R4G4B4,
//	D3DFMT_R3G3B2,
//	D3DFMT_A8,
//	D3DFMT_A8R3G3B2,
//	D3DFMT_X4R4G4B4,

//	D3DFMT_A8P8,
//	D3DFMT_P8,

//	D3DFMT_L8,
//	D3DFMT_A8L8,
//	D3DFMT_A4L4,

/*	D3DFMT_V8U8,
	D3DFMT_L6V5U5,
	D3DFMT_X8L8V8U8,
	D3DFMT_Q8W8V8U8,
	D3DFMT_V16U16,
	*/
//	D3DFMT_W11V11U10,

/*
	D3DFMT_UYVY,
	D3DFMT_YUY2,
	D3DFMT_DXT1,
	D3DFMT_DXT2,
	D3DFMT_DXT3,
	D3DFMT_DXT4,
	D3DFMT_DXT5,
*/
//	D3DFMT_D16_LOCKABLE,
//	D3DFMT_D32,
//	D3DFMT_D15S1,
//	D3DFMT_D24S8,
//	D3DFMT_D16,
 //   D3DFMT_D24S8,
//	D3DFMT_D24X4S4,

//	D3DFMT_VERTEXDATA,
//	D3DFMT_INDEX16,
//  D3DFMT_INDEX32
};

#pragma data_seg(".d3dapi$test005")

BEGINTEST(testDirect3DCreate8Release)
{
	IDirect3D8 * pid;
	xStartVariation(hlog, "Direct3DCreate8(D3D_SDK_VERSION)");
	STARTLEAKCHECK();
	pid = Direct3DCreate8(D3D_SDK_VERSION);
	BLOCKRESULT(pid != NULL);
	DWORD d;

	if(WASBADRESULT()) {
		xLog(hlog, XLL_INFO, "Error %d", GetLastError());
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "D3dRelease(no device)");
	__try {
		d = pid->Release();
		CHECKRESULT(d == 0 || d == 1);
	} __except(1) {
		xLog(hlog, XLL_EXCEPTION, "Exception raised in IDirect3d8::Release()");
	}

	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

#pragma data_seg(".d3dapi$test020")

BEGINTEST(testDirect3DGetAdapterCount)
{
	DWORD d;
	xStartVariation(hlog, "IDirect3d8::GetAdapterCount");
	STARTLEAKCHECK();
	d = g_pd3d8->GetAdapterCount();
	CHECKRESULT(d == 1);
	if(WASBADRESULT()) {
		xLog(hlog, XLL_INFO, "returned %d, Error %d", d,GetLastError());
	}
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testDirect3DGetAdapterIdentifier)
{
	D3DADAPTER_IDENTIFIER8 dai8;
	DWORD d;

	xStartVariation(hlog, "GetAdapterIdentifier(flags=0)");
	STARTLEAKCHECK();
	d = g_pd3d8->GetAdapterIdentifier(0, 0, &dai8);
	CHECKRESULT(d == D3D_OK);
	xEndVariation(hlog);

	xStartVariation(hlog, "GetAdapterIdentifier(flags=D3DENUM_NO_WHQL_LEVEL)");
	d = g_pd3d8->GetAdapterIdentifier(0, D3DENUM_NO_WHQL_LEVEL, &dai8);
	CHECKRESULT(d == D3D_OK);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testDirect3DGetAdapterModeCount)
{
	UINT d;

	xStartVariation(hlog, "IDirect3d8::GetAdapterModeCount(0)");
	STARTLEAKCHECK();
	d = g_pd3d8->GetAdapterModeCount(0);
	BLOCKRESULT(d != 0);
	xLog(hlog, XLL_INFO, "returned %d", d);
	CHECKLEAKS();
	xEndVariation(hlog);
	gNumModes = d;
}
ENDTEST()

BEGINTEST(testGetAdapterDisplayMode)
{
	D3DDISPLAYMODE m;
	DWORD d;

	xStartVariation(hlog, "IDirect3d8::GetAdapterDisplayMode");
	STARTLEAKCHECK();
	d = g_pd3d8->GetAdapterDisplayMode(0, &m);
	CHECKRESULT(d == D3D_OK);
	if(WASBADRESULT()) {
		xLog(hlog, XLL_INFO, "returned %d", d);
	}
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testDirect3DCheckDeviceType)
{
	DWORD d;
	D3DFORMAT types[] = {
//		D3DFMT_R8G8B8,
		D3DFMT_X8R8G8B8,
		D3DFMT_X8R8G8B8,
		D3DFMT_R5G6B5,
		D3DFMT_X1R5G5B5,
//		D3DFMT_A1R5G5B5,
//		D3DFMT_X4R4G4B4,
//		D3DFMT_R3G3B2,
//		D3DFMT_P8
//		D3DFMT_R3G3B2,
//		D3DFMT_X4R4G4B4
	};
	D3DFORMAT backtypes[] = {
//		D3DFMT_R8G8B8,
		D3DFMT_A8R8G8B8,
		D3DFMT_X8R8G8B8,
		D3DFMT_R5G6B5,
		D3DFMT_X1R5G5B5,
//		D3DFMT_A1R5G5B5,
//		D3DFMT_A4R4G4B4,
//		D3DFMT_R3G3B2,
//		D3DFMT_P8
//		D3DFMT_A8R3G3B2,
//		D3DFMT_X4R4G4B4
	};
	int i;

	xStartVariation(hlog, "D3DCheckDeviceType(0,1,x,x,0)");
	STARTLEAKCHECK();
	for (i = 0; i < sizeof(backtypes) / sizeof(backtypes[0]); i++)
	{
		d = g_pd3d8->CheckDeviceType(0, D3DDEVTYPE_HAL, types[i], backtypes[i], FALSE);
		CHECKRESULTNOLOG((d == D3D_OK) || (d == D3DERR_INVALIDDEVICE));
		xLog(hlog, GETRESULT(), "CheckDeviceType(0, 1, %d, %d, 0)", types[i],backtypes[i]);
	}
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()


BEGINTEST(testDirect3DCheckDeviceFormat)
{
	DWORD d;
	

	DWORD usage[] = {
		0, 
		D3DUSAGE_DEPTHSTENCIL,
		D3DUSAGE_RENDERTARGET,
		D3DUSAGE_DEPTHSTENCIL | D3DUSAGE_RENDERTARGET
	};

	D3DRESOURCETYPE resourcetype[] = {
		D3DRTYPE_SURFACE,
		D3DRTYPE_VOLUME,
		D3DRTYPE_TEXTURE,
		D3DRTYPE_VOLUMETEXTURE,
		D3DRTYPE_CUBETEXTURE,
		D3DRTYPE_VERTEXBUFFER,
		D3DRTYPE_INDEXBUFFER
	};
	int indeces[5];

	xStartVariation(hlog, "CheckDeviceFormat(rnd)");
	STARTLEAKCHECK();
	for(int i = 0; i < 50; i++) {
		d = g_pd3d8->CheckDeviceFormat(0, D3DDEVTYPE_HAL,
			format[indeces[0] = rnd() % COUNTOF(format)],
			usage[indeces[1] = rnd() % COUNTOF(usage)],
			resourcetype[indeces[2] = rnd() % COUNTOF(resourcetype)],
			format[indeces[3] = rnd() % COUNTOF(format)]);
		CHECKRESULT((d == D3D_OK) || (d == D3DERR_NOTAVAILABLE));
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, 
				"CheckDeviceFormat(0, D3DDEVTYPE_HAL, %d, %d, %d, %d)",
				indeces[0], indeces[1], indeces[2], indeces[3]);
		}
	}
	CHECKLEAKS();
	xEndVariation(hlog);
/*
	for(int formatindex = 0; formatindex < sizeof(format)/sizeof(format[0]);formatindex++) {
		for(int usageindex = 0; usageindex < sizeof(usage)/sizeof(usage[0]);usageindex++) {
			for(int rindex = 0; rindex < sizeof(resourcetype)/sizeof(resourcetype[0]);rindex++) {
				g_pd3d8->CheckDeviceFormat(0, D3DDEVTYPE_HAL, 
					format[formatindex],usage[usageindex],
					resourcetype[rindex],
			}
		}

	}
*/
}
ENDTEST()


BEGINTEST(testDirect3DCheckDeviceMultiSampleType)
{
	DWORD d;
	int type;
	xStartVariation(hlog, "CheckDeviceMultiSampleType");
	STARTLEAKCHECK();
	for (int i = 0; i < COUNTOF(format); i++) {
//        switch(i & 3) {
  //      case 0:
			type = 0;
//            break;
//        case 1:
//            type = 2;
//            break;
//        case 2:
//            type = 16;
//            break;
//        case 3:
//            type = rnd() % 13 + 3;
//            break;
//        }
		d = g_pd3d8->CheckDeviceMultiSampleType(0,D3DDEVTYPE_HAL,format[i],0,(D3DMULTISAMPLE_TYPE)type);
		CHECKRESULT((d == D3D_OK) || (d == D3DERR_NOTAVAILABLE));
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, 
				"CheckDeviceMultiSampleType(0, D3DDEVTYPE_HAL, %d, 0, %d)",
				i, type);
		}
	}
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testDirect3DCheckDepthStencilMatch)
{
	DWORD d;
	D3DFORMAT types[] = {
//		D3DFMT_R8G8B8,
		D3DFMT_A8R8G8B8,
		D3DFMT_X8R8G8B8,
		D3DFMT_R5G6B5,
		D3DFMT_X1R5G5B5,
//		D3DFMT_A1R5G5B5,
//		D3DFMT_X4R4G4B4,
//		D3DFMT_R3G3B2,
//		D3DFMT_P8
//		D3DFMT_R3G3B2,
//		D3DFMT_X4R4G4B4
	};
	D3DFORMAT backtypes[] = {
//		D3DFMT_R8G8B8,
		D3DFMT_A8R8G8B8,
		D3DFMT_X8R8G8B8,
		D3DFMT_R5G6B5,
		D3DFMT_X1R5G5B5,
//		D3DFMT_A1R5G5B5,
//		D3DFMT_A4R4G4B4,
//		D3DFMT_R3G3B2,
//		D3DFMT_P8
//		D3DFMT_A8R3G3B2,
//		D3DFMT_X4R4G4B4
	};

	D3DFORMAT depths[] = {
		D3DFMT_D16_LOCKABLE,
//		D3DFMT_D32,
//		D3DFMT_D15S1,
//		D3DFMT_D24S8,
//		D3DFMT_D16,
        D3DFMT_D24S8
//		D3DFMT_D24X4S4
	};

	xStartVariation(hlog, "CheckDeviceMultiSampleType");
	STARTLEAKCHECK();
	for(int i = 0; i < COUNTOF(types); i++) {
		for (int j = 0; j < 1; j++) {
			d = g_pd3d8->CheckDepthStencilMatch(0, D3DDEVTYPE_HAL,
				types[i], backtypes[i], 
				depths[(i + j) % COUNTOF(depths)]);
			CHECKRESULT((d == D3D_OK) || (d == D3DERR_NOTAVAILABLE));
			if(WASBADRESULT()) {
				xLog(hlog, XLL_INFO, 
					"CheckDepthStencilMatch(0, D3DDEVTYPE_HAL, %d, %d, %d)",
					types[i], backtypes[i], depths[(i + j) % COUNTOF(depths)]);
			}
		}
	}
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testDirect3DGetDeviceCaps)
{
	D3DCAPS8 c;
	DWORD d;

	xStartVariation(hlog, "IDirect3d8::GetDeviceCaps");
	STARTLEAKCHECK();
	d = g_pd3d8->GetDeviceCaps(0, D3DDEVTYPE_HAL, &c);
	CHECKRESULT(d == D3D_OK);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()


BEGINTEST(testDirect3DEnumAdapterModes)
{
	D3DDISPLAYMODE m;
	DWORD d;
	INT mode;

	xStartVariation(hlog, "EnumAdapterModes");
	STARTLEAKCHECK();

	for(mode = 0; mode < gNumModes; mode++) {
		d = g_pd3d8->EnumAdapterModes(0, mode, &m);
		CHECKRESULT(d == D3D_OK);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "EnumAdapterModes(0, %d, %p) returned %d", mode, &m, d);
		} else {
			gDisplayModes[mode] = m;
		}
	}

	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()


void DrawStuff() 
{
	//draw various numbers of triangles here.
}


BEGINTEST(testDirect3DCreateDevice)
{
	int RefreshRates[] = {
		60, 
		D3DPRESENT_RATE_DEFAULT, 
		D3DPRESENT_RATE_UNLIMITED
	};

	int BackBufferCounts[] = {
		0, 
		1, 
		2, 
//		3
	};

	struct MULTISAMPLES {
		D3DSWAPEFFECT se;
		D3DMULTISAMPLE_TYPE mst;
	} MultiSamples[] = {
		{D3DSWAPEFFECT_DISCARD, D3DMULTISAMPLE_NONE},
		{D3DSWAPEFFECT_FLIP, D3DMULTISAMPLE_NONE},
	};
	UINT Intervals[] = {
		D3DPRESENT_INTERVAL_IMMEDIATE,
//		D3DPRESENT_INTERVAL_TWO,
		D3DPRESENT_INTERVAL_ONE,
	};

	DWORD Flags[] = {
		D3DCREATE_HARDWARE_VERTEXPROCESSING,
		D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE,
	};
	
	DWORD PpFlags[] = {
		0, 
		D3DPRESENTFLAG_LOCKABLE_BACKBUFFER
	};

	struct STENCILS {
		BOOL u;
		D3DFORMAT s;
	} Stencils[] = {
		{FALSE, D3DFMT_D16_LOCKABLE},
//		{TRUE, D3DFMT_D15S1},
//		{TRUE, D3DFMT_D16_LOCKABLE},
//		{TRUE, D3DFMT_D24S8},
//		{TRUE, D3DFMT_D32},
//		{TRUE, D3DFMT_D16},
//		{TRUE, D3DFMT_D24X4S4},
        {TRUE, D3DFMT_D24S8}
	};

	DWORD dr;
	DWORD flags;
	D3DPRESENT_PARAMETERS pp;

	#define SETCDPARAMS(a,b,c,d,e,f,g,h)						 \
		xLog(hlog, XLL_INFO, "wid%d hgt%d fmt%d "\
			"BkBufCt%d MultiSamType%d MSs%d "\
			"Stencils?%d StFmt%d ppflags%08x "    \
			"RefRate%d PresInt%08x Flags%08x",\
			pp.BackBufferWidth = gDisplayModes[a].Width,			 \
			pp.BackBufferHeight = gDisplayModes[a].Height,		 \
			pp.BackBufferFormat = gDisplayModes[a].Format,		 \
			pp.BackBufferCount = BackBufferCounts[c],			 \
			pp.MultiSampleType = MultiSamples[d].mst,			 \
			pp.SwapEffect = MultiSamples[d].se,					 \
			pp.EnableAutoDepthStencil = Stencils[h].u,			 \
			pp.AutoDepthStencilFormat =							 \
                (gDisplayModes[a].Format == D3DFMT_LIN_A8R8G8B8 ? \
				  (Stencils[h].s == D3DFMT_LIN_D16 ?             \
				    D3DFMT_LIN_D24S8 : Stencils[h].s)            \
				: Stencils[h].s),                                \
			pp.Flags = PpFlags[g],								 \
			pp.FullScreen_RefreshRateInHz = RefreshRates[b],	 \
			pp.FullScreen_PresentationInterval = Intervals[e],	 \
			flags = Flags[f]									 \
		);														 \
		pp.hDeviceWindow = NULL;								 \
		pp.Windowed = FALSE;								

/*
	#define CDDOIT																	\
		__try {																		\
			dr = g_pd3d8->CreateDevice(0, D3DDEVTYPE_HAL, 0, flags, &pp, &g_pd3dd8);\
			CHECKRESULT(dr == D3D_OK);												\
			if(dr == D3D_OK) {														\
				dr = g_pd3dd8->AddRef();											\
				CHECKRESULT(dr == 2);												\
				dr = g_pd3dd8->Release();											\
				CHECKRESULT(dr == 1);												\
				if(WASBADRESULT()) {												\
					xLog(hlog, XLL_INFO, "Release returned %d", dr);				\
				} else {															\
					dr = g_pd3dd8->Release();										\
					CHECKRESULT(dr == 0);											\
					if(WASBADRESULT()) xLog(hlog, XLL_INFO, "Release returned %d", dr);\
				}																	\
			}																		\
			else {																	\
				xLog(hlog, XLL_INFO, "CreateDevice returned %d", dr);				\
			}																		\
		} __except(1) {																\
			xLog(hlog, XLL_EXCEPTION, "Exception.");								\
		}
*/
	#define CDDOIT																	   \
			dr = g_pd3d8->CreateDevice(0, D3DDEVTYPE_HAL, 0, flags, &pp, &g_pd3dd8);   \
			CHECKRESULT(dr == D3D_OK);												   \
			if(dr == D3D_OK) {														   \
				dr = g_pd3dd8->AddRef();											   \
				CHECKRESULT(dr == 2);												   \
				dr = g_pd3dd8->Release();											   \
				CHECKRESULT(dr == 1);												   \
				if(WASBADRESULT()) {												   \
					xLog(hlog, XLL_INFO, "Release returned %d", dr);				   \
				} else {																\
                    DrawStuff();                                                        \
					dr = g_pd3dd8->Release();										   \
					CHECKRESULT(dr == 0);											   \
					if(WASBADRESULT()) xLog(hlog, XLL_INFO, "Release returned %d", dr);\
				}																	   \
			}																		   \
			else {																	   \
				xLog(hlog, XLL_INFO, "CreateDevice returned %d", dr);				   \
			}																		   \


	int a,b,c,d,e,f,g,h,i,j;

	xStartVariation(hlog, "CreateRelease for leak checking");
	SETCDPARAMS(0,0,0,0,0,0,0,0);
	CDDOIT;
	xEndVariation(hlog);

	xStartVariation(hlog, "Display Modes loop");
	STARTLEAKCHECK();
	for (i = 0; i < gNumModes; i++) {
		for(j = 0; j < COUNTOF(RefreshRates); j++) {
			SETCDPARAMS(i,j,0,0,0,0,0,0);
			CDDOIT;
		}
	}
	xEndVariation(hlog);
//    RESETRESULT();

	xStartVariation(hlog, "BackBuffer count loop");
	for (i = 0; i < COUNTOF(BackBufferCounts); i++) {
		SETCDPARAMS(0,0,i,0,0,0,0,0);
		CDDOIT;
	}
	xEndVariation(hlog);
//    RESETRESULT();

	xStartVariation(hlog, "Multisamples count loop");
	for (i = 0; i < COUNTOF(MultiSamples); i++) {
		SETCDPARAMS(0,0,0,i,0,0,0,0);
		CDDOIT;
	}
	xEndVariation(hlog);
//    RESETRESULT();

	xStartVariation(hlog, "Intervals loop");
	for (i = 0; i < COUNTOF(Intervals); i++) {
		SETCDPARAMS(0,0,0,0,i,0,0,0);
		CDDOIT;
	}
	xEndVariation(hlog);
//    RESETRESULT();
	
	xStartVariation(hlog, "Flags loop");
	for (i = 0; i < COUNTOF(Flags); i++) {
		for (j = 0; j < COUNTOF(PpFlags); j++) {
			SETCDPARAMS(0,0,0,0,0,i,j,0);
			CDDOIT;
		}
	}
	xEndVariation(hlog);
//    RESETRESULT();

	xStartVariation(hlog, "Stencils loop");
	for (i = 0; i < COUNTOF(Stencils); i++) {
		SETCDPARAMS(0,0,0,0,0,0,0,i);
		CDDOIT;
	}
	xEndVariation(hlog);
//    RESETRESULT();

	xStartVariation(hlog, "Extrema loop");
	for (a = 0; a < gNumModes;     a += 1)     { //2
    for (b = 0; b < COUNTOF(RefreshRates);     b += 1/*COUNTOF(RefreshRates)*/)     { //2 =4
	for (c = 0; c < COUNTOF(BackBufferCounts); c += 1/*LASTOF(BackBufferCounts)*/) { //2 =8
	for (d = 0; d < COUNTOF(MultiSamples);     d += 1/*3*/)                        { //3 =24
	for (e = 0; e < COUNTOF(Intervals);        e += 1/*COUNTOF(Intervals)*/)        { //2 =48
	for (i = 0; i < COUNTOF(Flags) * COUNTOF(PpFlags); i += 1/*3*/);               { //3 =144
	f = (i % COUNTOF(Flags));
	g = (i / COUNTOF(Flags));
	for (h = 0; h < COUNTOF(Stencils);         h += 1/*2*/)                        { //4 =576
		SETCDPARAMS(a,b,c,d,e,f,g,h);
		CDDOIT;
	}
	}
	}
	}
	}
	}
	}
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()


#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\direct3d8apiinit.cpp ===
#include "d3dapi.hpp"

LINKME(5)

BEGINTEST(testDirect3D8_Release)
{
	xStartVariation(hlog, "Direct3d8Release");
//	__try {
		DWORD d = g_pd3d8->Release();
		CHECKRESULT(d == 0 || d == 1);
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "returned: %d", d);
//	} __except(1) {
//		xLog(hlog, XLL_EXCEPTION, "Exception in IDirect3d8::Release()");
//	}

	g_pd3d8 = NULL;
	xEndVariation(hlog);
}
ENDTEST()

#pragma data_seg(".d3dapi$test010")
BEGINTEST(testDirect3DCreate8)
{
	IDirect3D8 * pid;
	xStartVariation(hlog, "Direct3DCreate8(D3D_SDK_VERSION)");
	pid = Direct3DCreate8(D3D_SDK_VERSION);
	BLOCKRESULT(pid != NULL);

	if(WASBADRESULT()) {
		xLog(hlog, XLL_INFO, "Error %d", GetLastError());
	} else {
		g_pd3d8 = pid;
		RegisterDeinitFunc(ptestDirect3D8_Release);
	}
	xEndVariation(hlog);
}
ENDTEST()
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\direct3ddevice8.cpp ===
#include "d3dapi.hpp"

LINKME(6)

/*
    HRESULT WINAPI Reset(D3DPRESENT_PARAMETERS *pPresentationParameters);
    HRESULT WINAPI Present(CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, CONST RGNDATA *pDirtyRegion);
    HRESULT WINAPI GetBackBuffer(UINT BackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface8 **ppBackBuffer);
    HRESULT WINAPI GetRasterStatus(D3DRASTER_STATUS *pRasterStatus);

	HRESULT WINAPI CreateVertexBuffer(UINT Length, DWORD Usage, DWORD unused, D3DPOOL Pool, IDirect3DVertexBuffer8 **ppVertexBuffer);

    HRESULT WINAPI CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DIndexBuffer8 **ppIndexBuffer);
    HRESULT WINAPI CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, IDirect3DSurface8 **ppSurface);
    HRESULT WINAPI CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, IDirect3DSurface8 **ppSurface);
    HRESULT WINAPI CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, IDirect3DSurface8 **ppSurface);
    HRESULT WINAPI CopyRects(IDirect3DSurface8 *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, IDirect3DSurface8 *pDestinationSurface, CONST POINT *pDestPointsArray);
    HRESULT WINAPI GetFrontBuffer(IDirect3DSurface8 *pDestSurface);
    HRESULT WINAPI SetRenderTarget(IDirect3DSurface8 *pRenderTarget, IDirect3DSurface8 *pNewZStencil);
    HRESULT WINAPI GetRenderTarget(IDirect3DSurface8 **ppRenderTarget);
    HRESULT WINAPI GetDepthStencilSurface(IDirect3DSurface8 **ppZStencilSurface);
    HRESULT WINAPI BeginScene();
    HRESULT WINAPI EndScene();
    HRESULT WINAPI Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil);
    HRESULT WINAPI SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
    HRESULT WINAPI GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix);
    HRESULT WINAPI MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
    HRESULT WINAPI SetViewport(CONST D3DVIEWPORT8 *pViewport);
    HRESULT WINAPI GetViewport(D3DVIEWPORT8 *pViewport);
    HRESULT WINAPI SetMaterial(CONST D3DMATERIAL8 *pMaterial);
    HRESULT WINAPI GetMaterial(D3DMATERIAL8 *pMaterial);
    HRESULT WINAPI SetLight(DWORD Index, CONST D3DLIGHT8 *pLight);
    HRESULT WINAPI GetLight(DWORD Index, D3DLIGHT8 *pLight);
    HRESULT WINAPI LightEnable(DWORD Index, BOOL Enable);
    HRESULT WINAPI GetLightEnable(DWORD Index, BOOL *pEnable);
    HRESULT WINAPI SetClipPlane(DWORD Index, CONST float *pPlane);
    HRESULT WINAPI GetClipPlane(DWORD Index, float *pPlane);
    HRESULT WINAPI SetRenderState(D3DRENDERSTATETYPE State, DWORD Value);
    HRESULT WINAPI GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue);
    HRESULT WINAPI SetClipStatus(CONST D3DCLIPSTATUS8 *pClipStatus);
    HRESULT WINAPI GetClipStatus(D3DCLIPSTATUS8 *pClipStatus);
    HRESULT WINAPI ValidateDevice(DWORD *pNumPasses);
    HRESULT WINAPI GetInfo(DWORD DevInfoID, void *pDevInfoStruct, DWORD DevInfoStructSize);
    HRESULT WINAPI SetPaletteEntries(UINT PaletteNumber, CONST PALETTEENTRY *pEntries);
    HRESULT WINAPI GetPaletteEntries(UINT PaletteNumber, PALETTEENTRY *pEntries);
    HRESULT WINAPI DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount);
    HRESULT WINAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, UINT minIndex, UINT NumIndices, UINT startIndex, UINT primCount);
    HRESULT WINAPI DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    HRESULT WINAPI DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    HRESULT WINAPI ProcessVertices(UINT SrcStartIndex, UINT DestIndex, UINT VertexCount, IDirect3DVertexBuffer8 *pDestBuffer, DWORD Flags);
    HRESULT WINAPI CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage);
    HRESULT WINAPI SetVertexShader(DWORD Handle);
    HRESULT WINAPI GetVertexShader(DWORD *pHandle);
    HRESULT WINAPI DeleteVertexShader(DWORD Handle);
    HRESULT WINAPI SetVertexShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount);
    HRESULT WINAPI GetVertexShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount);
    HRESULT WINAPI GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData);
    HRESULT WINAPI GetVertexShaderFunction(DWORD Handle,void *pData, DWORD *pSizeOfData);
    HRESULT WINAPI SetStreamSource(UINT StreamNumber, IDirect3DVertexBuffer8 *pStreamData, UINT Stride);
    HRESULT WINAPI GetStreamSource(UINT StreamNumber, IDirect3DVertexBuffer8 **ppStreamData, UINT *pStride);
    HRESULT WINAPI SetIndices(IDirect3DIndexBuffer8* pIndexData, UINT BaseVertexIndex);
    HRESULT WINAPI GetIndices(IDirect3DIndexBuffer8** ppIndexData, UINT *pBaseVertexIndex);
    HRESULT WINAPI CreatePixelShader(CONST DWORD *pFunction, DWORD *pHandle);
    HRESULT WINAPI SetPixelShader(DWORD Handle);
    HRESULT WINAPI GetPixelShader(DWORD *pHandle);
    HRESULT WINAPI DeletePixelShader(DWORD Handle);
    HRESULT WINAPI SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount);
    HRESULT WINAPI GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount);
    HRESULT WINAPI GetPixelShaderFunction(DWORD Handle, void *pData, DWORD *pSizeOfData);
    HRESULT WINAPI DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo);
    HRESULT WINAPI DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo);
    HRESULT WINAPI DeletePatch(UINT Handle);

********************************Unimportant routines*******************************
  
	HRESULT WINAPI SetCursorProperties(UINT XHotSpot, UINT YHotSpot, IDirect3DSurface8 *pCursorBitmap);
    void    WINAPI SetCursorPosition(UINT XScreenSpace, UINT YScreenSpace, DWORD Flags);
    BOOL    WINAPI ShowCursor(BOOL bShow);
#if 0 // NUGOOP
    HRESULT WINAPI CreateAdditionalSwapChain(D3DPRESENT_PARAMETERS *pPresentationParameters, IDirect3DSwapChain8 **pSwapChain);
#endif 0 // NUGOOP


*/


//goes after Direct3d8 & testDirect3dDevice8
#pragma data_seg(".d3dapi$test060") 

BEGINTEST(testDeviceGetDirect3D)
{
	DWORD d;
	IDirect3D8* r;
	xStartVariation(hlog, "DeviceGetDirect3D");
	STARTLEAKCHECK();
	d = g_pd3dd8->GetDirect3D(&r);
	CHECKRESULT((d == D3D_OK) && (r == g_pd3d8));
//	if(!((DWORD(r)) & 0xfffffff0)) xLog(hlog, XLL_INFO, "r == %p", r);
	if(WASBADRESULT()) xLog(hlog, XLL_INFO, "result: %d, real d3d8: %p, received d3d8: %p", d, g_pd3d8, r);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testDeviceGetDeviceCaps)
{
	DWORD d;
	D3DCAPS8 p;


	xStartVariation(hlog, "GetDeviceCaps(f's)");
	STARTLEAKCHECK();
	p.Caps = 0xffffffff;
	d = g_pd3dd8->GetDeviceCaps(&p);
	CHECKRESULT((d == D3D_OK) && (p.Caps != 0xffffffff));
	if(WASBADRESULT()) xLog(hlog, XLL_INFO, "result: %d", d);

	xEndVariation(hlog);
	xStartVariation(hlog, "GetDeviceCaps(0's)");
	
	p.Caps = 0;
	d = g_pd3dd8->GetDeviceCaps(&p);
	CHECKRESULT((d == D3D_OK) && (p.Caps != 0));
	if(WASBADRESULT()) xLog(hlog, XLL_INFO, "result: %d", d);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()


BEGINTEST(testDeviceGetDisplayMode)
{
	DWORD d;
	D3DDISPLAYMODE m = {0,0,0,(D3DFORMAT)0};

	xStartVariation(hlog, "GetDisplayMode");
	STARTLEAKCHECK();
	d = g_pd3dd8->GetDisplayMode(&m);
	CHECKRESULT((d == D3D_OK) && (m.Width != 0) && (m.Height != 0) && (m.RefreshRate != 0) && (m.Format != (D3DFORMAT)0));
	if(WASBADRESULT()) xLog(hlog, XLL_INFO, "ret %d, wid %d, hei %d, rr %d, for %d", d, m.Width, m.Height, m.RefreshRate, m.Format);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

/*
BEGINTEST(testGetCreationParameters)
{
	DWORD d;
	D3DDEVICE_CREATION_PARAMETERS p = {777, (D3DDEVTYPE)777, (HWND)777, 777};
	xStartVariation(hlog, "GetCreationParameters");
	STARTLEAKCHECK();
	d = g_pd3dd8->GetCreationParameters(&p);
	CHECKRESULT((d == D3D_OK) && (p.AdapterOrdinal != 777) && (p.DeviceType != 777) && (p.BehaviorFlags != 777));
	if(WASBADRESULT()) xLog(hlog, XLL_INFO, "ret %d adapO %d DevType %d Hwnd %d BehF %d", 
		d, p.AdapterOrdinal, p.DeviceType, p.hFocusWindow, p.BehaviorFlags);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()
*/

BEGINTEST(testGammaRamp)
{
	D3DGAMMARAMP o, n, c1, c2;
	int i;
    DWORD numbad = 0;

	for(i = 0; i < 256; i++) {
		n.red[i] = 0 + i;
		n.green[i] = 0 - i;
		n.blue[i] = 5358 * i;
	}
	
	xStartVariation(hlog, "GammaRamps");
	STARTLEAKCHECK();
	g_pd3dd8->GetGammaRamp(&o);
	g_pd3dd8->SetGammaRamp(D3DSGR_NO_CALIBRATION, &n);
	g_pd3dd8->GetGammaRamp(&c1);
	g_pd3dd8->SetGammaRamp(D3DSGR_NO_CALIBRATION, &o);
	g_pd3dd8->GetGammaRamp(&c2);

	for(i = 0; i < 256; i++) {
		if((n.red[i] != c1.red[i]) || (n.green[i] != c1.green[i]) || (n.blue[i] != c1.blue[i])) 
            numbad |= 1;
		if((o.red[i] != c2.red[i]) || (o.green[i] != c2.green[i]) || (o.blue[i] != c2.blue[i])) 
            numbad |= 2;
	}
    CHECKRESULT(numbad == 0);
    if(WASBADRESULT()) xLog(hlog, XLL_INFO, "numbad = %d", numbad);
	CHECKLEAKS();
	xEndVariation(hlog);
}	
ENDTEST()

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\lock.cpp ===
#include "d3dapi.hpp"

LINKME(10);

namespace d3dapi {
class TEX {
public:
	D3DTexture* m_t;

	TEX(): m_pLast(0), m_t(0) {}

	bool Init(int width, int height, int levels, D3DFORMAT format)
	{
		m_w = width; m_h = height; m_l = levels; m_f = format;
		DWORD hr;
		hr = g_pd3dd8->CreateTexture(m_w,m_h,m_l,0,m_f,D3DPOOL_DEFAULT, &m_t);
		if(hr != D3D_OK) {
			xLog(hlog, XLL_FAIL, "TEX: create texture, w%d h%d l%d f%d", m_w, m_h, m_l, m_f);
			return false;
		}
		m_pLast = new DWORD[m_l];
		if(!m_pLast) { 
			xLog(hlog, XLL_FAIL, "TEX: couldn't create dword array, size %d", m_l); 
			return false; 
		}
		m_bpp = D3D::BitsPerPixelOfD3DFORMAT(format);

		return true;
	}

	~TEX() {
		Release();
	}
	bool Release() {
		DWORD hr;
		if(m_t) {
			hr = m_t->Release();
			xLog(hlog, (hr == 0) ? XLL_PASS : XLL_FAIL, "TEX: release texture: %d", hr);
			m_t = 0;
		}
		if(m_pLast) {
			delete[] m_pLast;
			m_pLast = 0;
		}
		return true;
	}


	void Set(int layer, bool raw, D3DLOCKED_RECT* pr) {  
		int r;
		DWORD col;
		int x, y;
		int w = max(m_w >> layer, 1);
		int h = max(m_h >> layer, 1);

		if(layer < 0 || layer >= m_l) _asm {int 3};
		if(!m_t || !m_pLast) _asm {int 3};
		m_pLast[layer] = rnd();
		r = m_pLast[layer];										//store the random number so we can check the location later
		col = (r + (r << 14) + (r << 27)) >> (32 - m_bpp);
		x = (r + (r << 14) + (r << 27)) & (w - 1);
		y = (r + (r << 14) + (r << 27)) / (w);
		SetPoint((x + 0) & (w - 1), (y + 0) & (h - 1), layer, col, raw, pr);  //draw 5 points to a random location
		SetPoint((x + 1) & (w - 1), (y + 0) & (h - 1), layer, col, raw, pr);  
		SetPoint((x + 0) & (w - 1), (y + 1) & (h - 1), layer, col, raw, pr);
		SetPoint((x - 1) & (w - 1), (y + 0) & (h - 1), layer, col, raw, pr);
		SetPoint((x + 0) & (w - 1), (y - 1) & (h - 1), layer, col, raw, pr);
		SetPoint(w - 1, h - 1, layer, col, raw, pr);						  //draw to first pixel & last pixel
		SetPoint(0, 0, layer, col, raw, pr);
	}

	bool Check(int layer, bool raw, D3DLOCKED_RECT* pr) 
	{
		int r;
		DWORD col;
		int x, y;
		int w = max(m_w >> layer, 1);
		int h = max(m_h >> layer, 1);

		if(layer < 0 || layer >= m_l) _asm {int 3};
		if(!m_t || !m_pLast) _asm {int 3};

		r = m_pLast[layer];	//get the random number from last time
		col = (r + (r << 14) + (r << 27)) >> (32 - m_bpp);
		x = (r + (r << 14) + (r << 27)) & (w - 1);
		y = (r + (r << 14) + (r << 27)) / (w);
		if(!GetPoint((x + 0) & (w - 1), (y + 0) & (h - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 1) & (w - 1), (y + 0) & (h - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 0) & (w - 1), (y + 1) & (h - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x - 1) & (w - 1), (y + 0) & (h - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 0) & (w - 1), (y - 1) & (h - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint(w - 1, h - 1, layer, raw, pr, col)) goto bad;
		if(!GetPoint(0, 0, layer, raw, pr, col)) goto bad;
		return true;
	bad:
		return false;
	}


public: //private:
	int m_w;
	int m_h;
	int m_l;
	int m_bpp;
	D3DFORMAT m_f;
	DWORD* m_pLast;

	void SetPoint(int x, int y, int layer, DWORD col, bool raw, D3DLOCKED_RECT* pr) 
	{
		int i;
		if(raw) {
			SWIZZLER s(max(m_w >> layer, 1), max(m_h >> layer, 1), 0);
			i = s.Convert(x,y,0);
		} else {
			i = (y * (m_w >> layer)) + x;
		}
		switch (m_bpp) {
		case 4:
			i >>= 1; 
			//fall through...
		case 8:
			((BYTE*)pr->pBits)[i] = (BYTE) col;
			break;
		case 16:
			((WORD*)pr->pBits)[i] = (WORD) col;
			break;
		case 32:
			((DWORD*)pr->pBits)[i] = (DWORD) col;
			break;
		default:
			_asm {int 3};
		}
	}	
	bool GetPoint(int x, int y, int layer, bool raw, D3DLOCKED_RECT* pr, DWORD col) 
	{
		int i;
//		DWORD col;
		if(raw) {
			SWIZZLER s(max(m_w >> layer, 1), max(m_h >> layer, 1), 0);
			i = s.Convert(x,y,0);
		} else {
			i = (y * (m_w >> layer)) + x;
		}
		switch (m_bpp) {
		case 4:
			i >>= 1; 
			//fall through...
		case 8:
			if((BYTE)col == (((BYTE*)pr->pBits)[i]))
				return true;
			else
				return false;
		case 16:
			if((WORD)col == (((WORD*)pr->pBits)[i]))
				return true;
			else
				return false;
		case 32:
			if((DWORD)col == (((DWORD*)pr->pBits)[i]))
				return true;
			else
				return false;
		default:
			_asm {int 3};
		}
		return false;
	}	

};
};

#pragma data_seg(".d3dapi$test051") //after device creation, before other tests

BEGINTEST(testLock)
{
	DWORD hr;
	bool br;
	TEX t[2];
	D3DLOCKED_RECT r;

	STARTLEAKCHECK();
	xStartVariation(hlog, "lock, init");
	{
		br = t[0].Init(256, 256, 9, D3DFMT_R8G8B8A8);
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;

		br = t[1].Init(512, 256, 2, D3DFMT_R8G8B8A8);
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "lock 0L0 raw, check swizzled");
	{
		int layer = 0;

		hr = t[0].m_t->LockRect(layer, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(layer, true, &r);
		hr = t[0].m_t->UnlockRect(layer);
		CHECKRESULT(hr == D3D_OK);

		hr = t[0].m_t->LockRect(layer, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(layer, false, &r);
		CHECKRESULT(true == br);
		hr = t[0].m_t->UnlockRect(layer);
		CHECKRESULT(hr == D3D_OK);
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "lock 0L1 swizzled, check raw");
	{
		int layer = 1;

		hr = t[0].m_t->LockRect(layer, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(layer, false, &r);
		hr = t[0].m_t->UnlockRect(layer);
		CHECKRESULT(hr == D3D_OK);

		hr = t[0].m_t->LockRect(layer, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(layer, true, &r);
		CHECKRESULT(true == br);
		hr = t[0].m_t->UnlockRect(layer);
		CHECKRESULT(hr == D3D_OK);
	}
	xEndVariation(hlog);
/*
	lock order        1
	0 lock type       2 
	1 lock type       4
	unlock order      8
	2nd lock order   10
	0 lock type      20
	1 lock type      40
	..
	2nd texture      80

*/
/*
	xStartVariation(hlog, "LockLockUnlockUnlock");
	for (i = 0; i < 256; i++) {
		int Lock1Type1 = (i & 0x02) ? D3DLOCK_RAWDATA : 0;
		int Lock1Type2 = (i & 0x04) ? D3DLOCK_RAWDATA : 0;
		int Lock2Type1 = (i & 0x20) ? D3DLOCK_RAWDATA : 0;
		int Lock2Type2 = (i & 0x40) ? D3DLOCK_RAWDATA : 0;
		int TexNum = (i & 0x80) ? 1 : 0;
		int LayerNum = (i & 0x80) ? 0 : 1;
		
		xLog(hlog, XLL_INFO, "Lock1 order:%d, Lock0Type:%d, Lock1Type:%d, UnlockOrder:%d", i&1,(i&2)>>1,(i&4)>>2,(i&8)>>3);
		xLog(hlog, XLL_INFO, "Lock2 order:%d, Lock0Type:%d, Lock1Type:%d, Layer/Tex", (i&16)>>4,(i&32)>>5,(i&64)>>6,(i&128)>>7);

/////Lock and set
		if(i & 1) goto lluui1_2;
lluui1_1:
		hr = t[0].m_t->LockRect(0, &r, NULL, Lock1Type1);
		CHECKRESULT(hr == D3D_OK && "Lock Tex1");
		t[0].Set(0, Lock1Type1 ? true : false, &r);
		if(i & 1) goto lluui1_3;

lluui1_2:
		hr = t[TexNum].m_t->LockRect(LayerNum, &r, NULL, Lock1Type2);
		CHECKRESULT(hr == D3D_OK && "Lock Tex2");
		t[TexNum].Set(LayerNum, Lock1Type2 ? true : false, &r);
		if(i & 1) goto lluui1_1;
lluui1_3:

//////unlock

		if(i & 8) goto lluui8_2;
lluui8_1:
		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK && "Unlock Tex1");
		if(i & 8) goto lluui8_3;
lluui8_2:
		hr = t[TexNum].m_t->UnlockRect(LayerNum);
		CHECKRESULT(hr == D3D_OK && "Unlock Tex2");
		if(i & 8) goto lluui8_1;
lluui8_3:


/////Lock and check
		if(i & 16) goto lluui16_2;
lluui16_1:
		hr = t[0].m_t->LockRect(0, &r, NULL, Lock2Type1);
		CHECKRESULT(hr == D3D_OK && "Lock tex1");
		br = t[0].Check(0, Lock2Type1 ? true : false, &r);
		CHECKRESULT((br == true) && "Check Tex1");
		if(i & 16) goto lluui16_3;
lluui16_2:
		hr = t[TexNum].m_t->LockRect(LayerNum, &r, NULL, Lock2Type2);
		CHECKRESULT(hr == D3D_OK && "Lock tex2");
		br = t[TexNum].Check(LayerNum, Lock2Type2 ? true : false, &r);
		CHECKRESULT((br == true) && "Check Tex2");
		if(i & 16) goto lluui16_1;
lluui16_3:

		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK && "unlock tex1");
		hr = t[TexNum].m_t->UnlockRect(LayerNum);
		CHECKRESULT(hr == D3D_OK && "unlock tex2");
	}
	xEndVariation(hlog);
*/
	xStartVariation(hlog, "0L0 & 0L1 swizzled, ch raw");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, false, &r);

		hr = t[0].m_t->LockRect(1, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(1, false, &r);

		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(1);
		CHECKRESULT(hr == D3D_OK);


		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(true == br);

		hr = t[0].m_t->LockRect(1, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(1, true, &r);
		CHECKRESULT(true == br);

		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(1);
		CHECKRESULT(hr == D3D_OK);
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "0L0 & 0L1 swizzled, ch sw");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, false, &r);

		hr = t[0].m_t->LockRect(1, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(1, false, &r);

		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(1);
		CHECKRESULT(hr == D3D_OK);


		hr = t[0].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, false, &r);
		CHECKRESULT(true == br);

		hr = t[0].m_t->LockRect(1, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(1, false, &r);
		CHECKRESULT(true == br);

		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(1);
		CHECKRESULT(hr == D3D_OK);
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "0L0, 1L0 sw, ch sw");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, false, &r);

		hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[1].Set(0, false, &r);

		hr = t[1].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);


		hr = t[0].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, false, &r);
		CHECKRESULT(true == br);

		hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[1].Check(0, false, &r);
		CHECKRESULT(true == br);

		hr = t[1].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "0L0, 0L1, 0L9, 1L0");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, false, &r);
		hr = t[0].m_t->LockRect(1, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(1, false, &r);
		hr = t[0].m_t->LockRect(8, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(8, false, &r);
		hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[1].Set(0, false, &r);
		hr = t[0].m_t->UnlockRect(1);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(8);
		CHECKRESULT(hr == D3D_OK);
		hr = t[1].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);

		hr = t[0].m_t->LockRect(8, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(8, false, &r);
		CHECKRESULT(true == br);
		
		hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[1].Check(0, false, &r);
		CHECKRESULT(true == br);
		
		hr = t[0].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, false, &r);
		CHECKRESULT(true == br);

		hr = t[0].m_t->LockRect(1, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(1, false, &r);
		CHECKRESULT(true == br);

		hr = t[1].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(1);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(8);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "Switch to big textures");
	{
		t[0].Release();
		br = t[0].Init(4096, 4096, 2, D3DFMT_A8);
		CHECKRESULT(br == true && "Init(4096 4096 2 D3DFMT_A8)");
		if(WASBADRESULT()) 
			goto cleanup;

		t[1].Release();
		br = t[1].Init(256, 256, 1, D3DFMT_LIN_R8G8B8A8);
		CHECKRESULT(br == true && "Init(256,256,1,D3DFMT_LIN_R8G8B8A8)");
		if(WASBADRESULT()) 
			goto cleanup;
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "big1: 0L0 & 0L1 raw, ch raw");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, true, &r);

		hr = t[0].m_t->LockRect(1, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(1, true, &r);

		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(1);
		CHECKRESULT(hr == D3D_OK);


		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(true == br); 

		hr = t[0].m_t->LockRect(1, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(1, true, &r);
		CHECKRESULT(true == br);

		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(1);
		CHECKRESULT(hr == D3D_OK);
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "big: 0L0 & 0L1 swizzled, ch sw");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, false, &r);

		hr = t[0].m_t->LockRect(1, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(1, false, &r);

		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);       
		hr = t[0].m_t->UnlockRect(1); 
		CHECKRESULT(hr == D3D_OK);       


		hr = t[0].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, false, &r);
		CHECKRESULT(true == br);

		hr = t[0].m_t->LockRect(1, &r, NULL, 0);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(1, false, &r);
		CHECKRESULT(true == br);

		hr = t[0].m_t->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);
		hr = t[0].m_t->UnlockRect(1);
		CHECKRESULT(hr == D3D_OK);
	}

cleanup:
	CHECKLEAKS();
	xEndVariation(hlog);

}
ENDTEST()

BEGINTEST(testLockTextureFlags)
{
	DWORD hr;
	bool br;
	TEX t[2];
	D3DLOCKED_RECT r, oldr;

	__int64 StartTime, EndTime;

	STARTLEAKCHECK();
	xStartVariation(hlog, "init");
	{
/*
		br = t[0].Init(1024, 1024, 1, D3DFMT_R8G8B8A8);	
/*/
		br = t[0].Init(1024, 1024, 1, D3DFMT_R5G6B5);	
/**/
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;

/*
		br = t[1].Init(1024, 1024, 1, D3DFMT_LIN_R8G8B8A8);	
/*/
		br = t[1].Init(1024, 1024, 1, D3DFMT_LIN_R5G6B5);	
/**/
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'0");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, true, &r);
		t[0].m_t->UnlockRect(0);

		hr = t[0].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(oldr.pBits != r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, false, &r);
		CHECKRESULT(br == true);
		t[0].Set(0, false, &r);
		hr = t[0].m_t->UnlockRect(0);

		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockRect(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'R/O");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, true, &r);
		t[0].m_t->UnlockRect(0);

		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_READONLY);
		CHECKRESULT(oldr.pBits != r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, false, &r);
		CHECKRESULT(br == true);
//		t[0].Set(0, false, &r);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockRect(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to unlock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, true, &r);
//		CHECKRESULT(br == true);
		t[0].m_t->UnlockRect(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Dis");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
//		t[0].Set(0, true, &r);
		t[0].m_t->UnlockRect(0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_DISCARD);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits != r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, false, &r);
//		CHECKRESULT(br == true);
		t[0].Set(0, false, &r);
		hr = t[0].m_t->UnlockRect(0);

		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockRect(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Raw");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, true, &r);
		t[0].m_t->UnlockRect(0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[0].Set(0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockRect(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockRect(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Raw/RO");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, true, &r);
		t[0].m_t->UnlockRect(0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA | D3DLOCK_READONLY);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
//		t[0].Set(0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockRect(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

//		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
//		CHECKRESULT(oldr.pBits == r.pBits);
//		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, true, &r);
//		CHECKRESULT(br == true);
//		t[0].m_t->UnlockRect(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Raw/Dis");
	{
		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
//		t[0].Set(0, true, &r);
		t[0].m_t->UnlockRect(0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA | D3DLOCK_READONLY);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, true, &r);
//		CHECKRESULT(br == true);
		t[0].Set(0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockRect(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[0].m_t->LockRect(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockRect(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "lin'0");
	{
		hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[1].Set(0, true, &r);
		t[1].m_t->UnlockRect(0);

		StartTime = GetUsCount(); {
			hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[1].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[1].Set(0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[1].m_t->UnlockRect(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[1].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[1].m_t->UnlockRect(0);
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "lin'Discard");
	{
		hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
//		t[1].Set(0, true, &r);
		t[1].m_t->UnlockRect(0);

		StartTime = GetUsCount(); {
			hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[1].Check(0, true, &r);
//		CHECKRESULT(br == true);
		t[1].Set(0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[1].m_t->UnlockRect(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[1].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[1].m_t->UnlockRect(0);
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "lin'RO");
	{
		hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[1].Set(0, true, &r);
		t[1].m_t->UnlockRect(0);

		StartTime = GetUsCount(); {
			hr = t[1].m_t->LockRect(0, &r, NULL, D3DLOCK_READONLY);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[1].Check(0, true, &r);
		CHECKRESULT(br == true);
//		t[1].Set(0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[1].m_t->UnlockRect(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[1].m_t->LockRect(0, &r, NULL, 0);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[1].Check(0, true, &r);
//		CHECKRESULT(br == true);
		t[1].m_t->UnlockRect(0);
	}
	xEndVariation(hlog);

cleanup:
	xStartVariation(hlog, "Cleanup");
	{
		t[0].Release();
		t[1].Release();
		CHECKLEAKS();
	}
	xEndVariation(hlog);
}
ENDTEST()



BEGINTEST(testUpdateTexture)
{
	DWORD hr;
	bool br;
	TEX t[2];
	D3DLOCKED_RECT r;
	int i, j, j2;

	struct {
		int w1;
		int h1;
		int l1;
		int w2;
		int h2;
		int l2;
		D3DFORMAT format;
	} tests[] = {
		{2048, 2048,  2, 1024, 1024,  1,D3DFMT_A8          },
		{ 512,  512, 10,    1,    1,  1,D3DFMT_A8          },
		{   2,    2,  2,    1,    1,  1,D3DFMT_A8          },
		{ 256,  512, 10,  256,  512, 10,D3DFMT_A8          },
		{1024,  512,  7,  512,  256,  6,D3DFMT_A8          },
		{   1,  512,  1,    1,  512,  1,D3DFMT_LIN_A8      },
		{ 512,  512, 10,    1,    1,  1,D3DFMT_R5G6B5      },
		{   2,    2,  2,    1,    1,  1,D3DFMT_R5G6B5      },
		{ 256,  512, 10,  256,  512, 10,D3DFMT_R5G6B5      },
		{ 256,  512,  1,  256,  512,  1,D3DFMT_LIN_R5G6B5  },
		{ 512,  512, 10,    1,    1,  1,D3DFMT_R8G8B8A8    },
		{   2,    2,  2,    1,    1,  1,D3DFMT_R8G8B8A8    },
		{ 256,  512, 10,  256,  512, 10,D3DFMT_R8G8B8A8    },
		{   1,  512,  1,    1,  512,  1,D3DFMT_LIN_R8G8B8A8},
		{1024,  512,  7,  512,  256,  6,D3DFMT_DXT1        },
	};

	STARTLEAKCHECK();
	for(i = 0; i < COUNTOF(tests); i++) {
		xStartVariation(hlog, "lock, new texture");
		{
			t[0].Release();
			t[1].Release();

			br = t[0].Init(tests[i].w1, tests[i].h1, tests[i].l1, tests[i].format);
			CHECKRESULT(br == true);
			if(WASBADRESULT()) goto cleanup;

			br = t[1].Init(tests[i].w2, tests[i].h2, tests[i].l2, tests[i].format);
			CHECKRESULT(br == true);
			if(WASBADRESULT()) goto cleanup;

			for(j2 = 0; j2 < tests[i].l2; j2++) {
				hr = t[1].m_t->LockRect(j2, &r, NULL, D3DLOCK_RAWDATA);
				CHECKRESULT(hr == D3D_OK && "Lock");
				t[1].Set(j2, true, &r);
				hr = t[1].m_t->UnlockRect(j2);
				CHECKRESULT(hr == D3D_OK && "Unlock");
			}
			for(j = 0; j < tests[i].l1; j++) {
				hr = t[0].m_t->LockRect(j, &r, NULL, D3DLOCK_RAWDATA);
				CHECKRESULT(hr == D3D_OK && "Lock");
				t[0].Set(j, true, &r);
				hr = t[0].m_t->UnlockRect(j);
				CHECKRESULT(hr == D3D_OK && "Unlock");
				j2 = (j + tests[i].l2 - tests[i].l1);
				if(j2 >= 0 && j2 < tests[i].l2) {
					t[1].m_pLast[j2] = t[0].m_pLast[j];
				}
			}
			hr = g_pd3dd8->UpdateTexture(t[0].m_t, t[1].m_t);
			CHECKRESULT(hr == D3D_OK && "Update");

			for(j2 = 0; j2 < tests[i].l2; j2++) {
				hr = t[1].m_t->LockRect(j2, &r, NULL, D3DLOCK_RAWDATA);
				CHECKRESULT(hr == D3D_OK && "Lock");
				br = t[1].Check(j2, true, &r);
				CHECKRESULT(br == true && "CHECK!");
				hr = t[1].m_t->UnlockRect(j2);
				CHECKRESULT(hr == D3D_OK && "Unlock");
			}
		}
		xEndVariation(hlog);
	}	
	goto aftercleanup;

cleanup:
	xEndVariation(hlog);
aftercleanup:;
	xStartVariation(hlog, "leak check");
	t[0].Release();
	t[1].Release();
	CHECKLEAKS();
	xEndVariation(hlog);

}
ENDTEST()

BEGINTEST(testUmaTexture)
{
	DWORD hr;
	bool br;
	TEX t[6];
	D3DLOCKED_RECT r;

	STARTLEAKCHECK();
	xStartVariation(hlog, "lock, init");
	{
		br = t[0].Init(1, 1, 1, D3DFMT_A8);					//1 byte 
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;				
		br = t[1].Init(512, 16, 1, D3DFMT_R5G6B5);			//8k (a boundry condition)
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;
		br = t[2].Init(4096, 4096, 1, D3DFMT_A8);			//16mb, exactly
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;
		br = t[3].Init(4082, 2, 1, D3DFMT_LIN_A8);		    //next step below 8k
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;
		br = t[4].Init(256, 256, 9, D3DFMT_R8G8B8A8);		//abt 300k
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;
		br = t[5].Init(2048, 2048, 9, D3DFMT_R8G8B8A8);		//22mb
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;

	}
	xEndVariation(hlog);
	xStartVariation(hlog, "");
	{
		int location, locktype, layer, i;

		for(i = 0; i <= LASTOF(t); i++) {
		for(layer = 0; layer <= (i / 4); layer++) {
		for(locktype = 0; locktype <= 1; locktype++) {
		for(location = D3DMEM_AGP; location <= D3DMEM_VIDEO; location++) {
			xLog(hlog, XLL_INFO, "Width: %d, Height: %d, Layer: %d, locktype: %d, loc: %d", t[i].m_w, t[i].m_h, layer, locktype, location);
			t[i].m_t->MoveResourceMemory((D3DMEMORY)location);

			hr = t[i].m_t->LockRect(layer, &r, NULL, locktype ? D3DLOCK_RAWDATA : 0);
			CHECKRESULT(hr == D3D_OK && "Lock");
			t[i].Set(layer, locktype ? true : false, &r);
			hr = t[i].m_t->UnlockRect(layer);
			CHECKRESULT(hr == D3D_OK && "Unlock");

			t[i].m_t->MoveResourceMemory((D3DMEMORY)(location ^ D3DMEM_AGP ^ D3DMEM_VIDEO));

			hr = t[i].m_t->LockRect(layer, &r, NULL, locktype ? D3DLOCK_RAWDATA : 0);
			CHECKRESULT(hr == D3D_OK && "Lock");
			br = t[i].Check(layer, locktype ? true : false, &r);
			CHECKRESULT(true == br && "Check");
			hr = t[i].m_t->UnlockRect(layer);
			CHECKRESULT(hr == D3D_OK && "Unlock");
		}
		}
		}
		}
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "deinit");
	{
cleanup:
		t[0].Release();
		t[1].Release();
		t[2].Release();
		t[3].Release();
		t[4].Release();
		t[5].Release();
		CHECKLEAKS();
	}
}
ENDTEST()
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\linkme.cpp ===
#include "d3dapi.hpp"

D_( 0); 
D_( 1); 
D_( 2); 
D_( 3); 
D_( 4); 
D_( 5); 
D_( 6); 
D_( 7); 
D_( 8); 
D_( 9); 
D_(10); 
D_(11); 
D_(12); 
D_(13);
D_(14);
D_(15);
D_(16);
D_(17);
D_(18);
D_(19);

void CallAllDummyFunctions ()
{
	C_( 0); //IDirect3DTexture8
	C_( 1); //IDirect3DCubeTexture8
//	C_( 2); //cursor
	C_( 3); //IDirect3DVolume8
  C_( 4); //IDirect3D8 (including CreateDevice tests)
	C_( 5); //init for Idirect3D8
	C_( 6); //IDirect3DDevice8
	C_( 7); //init for IDirect3DDevice8
	C_( 8); //IDirect3DResource8
	C_( 9); //IDirect3DVolumeTexture8
//  C_(10); //lock
//  C_(11); //cubelock
//  C_(12); //volumelock
    C_(13); //vertexbuffer
//  C_(14); //uma //broken for the time being
//	C_(15); //swiz (temporary)
 // C_(16); //leak
 // C_(17); //logicop
 // C_(18); //push-size
  C_(19); //math speed & accuracy tests
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\direct3ddevice8init.cpp ===
#include "d3dapi.hpp"
#pragma warning(disable:4035)
__inline DWORD OneIfZero(DWORD num) {
	_asm {
		mov eax, [num]
		cmp eax, 1
		adc eax, 0
	}
}
#pragma warning(default:4035)

LINKME(7)

BEGINTEST(testDirect3dDevice8Release)
{
	DWORD dr;
	xStartVariation(hlog, "Create Device");

	if(g_pd3dd8 == NULL) {
		_asm {int 3}
	}
	dr = g_pd3dd8->Release();
	CHECKRESULT(dr == 0);
	if(WASBADRESULT()) {
		xLog(hlog, XLL_INFO, "release returned %d, should be 0", dr);
	}
	xEndVariation(hlog);
}
ENDTEST()

int gDeviceTypeIndex = 0;

#pragma data_seg(".d3dapi$test025") //goes after Direct3d8

BEGINTEST(testDirect3dCreateDevice1)
{
	D3DDISPLAYMODE DisplayModes[] = 
	{
	    { 640,  480, 60, 0,D3DFMT_LIN_R5G6B5 },
	    { 640,  480, 60, 0,D3DFMT_LIN_A8R8G8B8 },
	};
	
	int RefreshRates[] = {
		60, 
		D3DPRESENT_RATE_DEFAULT, 
		D3DPRESENT_RATE_UNLIMITED
	};

	int BackBufferCounts[] = {
		0, 
		1, 
		2, 
//		3
	};

	struct MULTISAMPLES {
		D3DSWAPEFFECT se;
		D3DMULTISAMPLE_TYPE mst;
	} MultiSamples[] = {
		{D3DSWAPEFFECT_DISCARD, D3DMULTISAMPLE_NONE},
		{D3DSWAPEFFECT_FLIP, D3DMULTISAMPLE_NONE},
//		{D3DSWAPEFFECT_COPY, D3DMULTISAMPLE_NONE},
//		{D3DSWAPEFFECT_COPY_VSYNC, D3DMULTISAMPLE_NONE}
	};
	UINT Intervals[] = {
		D3DPRESENT_INTERVAL_IMMEDIATE,
		D3DPRESENT_INTERVAL_DEFAULT,
		D3DPRESENT_INTERVAL_ONE,
	};

	DWORD Flags[] = {
		D3DCREATE_HARDWARE_VERTEXPROCESSING,
		D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE,
//        D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_FPU_PRESERVE,
//        D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE | D3DCREATE_FPU_PRESERVE,
	};
	
	DWORD PpFlags[] = {
		0, 
		D3DPRESENTFLAG_LOCKABLE_BACKBUFFER
	};

	struct STENCILS {
		BOOL u;
		D3DFORMAT s;
	} Stencils[] = {
		{FALSE, D3DFMT_D16_LOCKABLE},
//		{TRUE, D3DFMT_D15S1},
		{TRUE, D3DFMT_D16_LOCKABLE},
//		{TRUE, D3DFMT_D24S8},
//		{TRUE, D3DFMT_D32},
//		{TRUE, D3DFMT_D16},
//		{TRUE, D3DFMT_D24X4S4},
        {TRUE, D3DFMT_D24S8}
	};

	DWORD dr;
	DWORD flags;
	D3DPRESENT_PARAMETERS pp;

	#define SETCDPARAMS(a,b,c,d,e,f,g,h)						\
		xLog(hlog, XLL_INFO, "Params: width%d height%d format%d"\
			"backbuffercount%d multisampletype%d multisamples%d"\
			"enable stencils%d stencil format%d ppflags%08x rr%d"\
			"presentation interval%08x Flags%08x",				\
			pp.BackBufferWidth = DisplayModes[a].Width,			\
			pp.BackBufferHeight = DisplayModes[a].Height,		\
			pp.BackBufferFormat = DisplayModes[a].Format,		\
			pp.BackBufferCount = BackBufferCounts[c],			\
			pp.MultiSampleType = MultiSamples[d].mst,			\
			pp.SwapEffect = MultiSamples[d].se,					\
			pp.EnableAutoDepthStencil = Stencils[h].u,			\
			pp.AutoDepthStencilFormat = Stencils[h].s,			\
			pp.Flags = PpFlags[g],								\
			pp.FullScreen_RefreshRateInHz = RefreshRates[b],	\
			pp.FullScreen_PresentationInterval = Intervals[e],	\
			flags = Flags[f]									\
		);														\
		pp.hDeviceWindow = NULL;								\
		pp.Windowed = FALSE;								

//	int a,b,c,d,e,f,g,h,i,j;

	xStartVariation(hlog, "Create Device");
	switch (gDeviceTypeIndex) {
	case 0:
		SETCDPARAMS(0,0,0,0,LASTOF(Intervals),0,0,0);    //Minimum requrements
		break;
	case 1:
        SETCDPARAMS(LASTOF(DisplayModes),1,2,1,0,1,1,2); //maximum requirements
		break;
	}

	gDeviceTypeIndex++;
	if(gDeviceTypeIndex > 1) {
		gDeviceTypeIndex = 0;
	} else {
		RegisterDoAgain(0);
	}

//	__try {
		dr = g_pd3d8->CreateDevice(0, D3DDEVTYPE_HAL, 0, flags, &pp, &g_pd3dd8);
//	} __except(1) {
//		xLog(hlog, XLL_EXCEPTION, "Exception.");
//		dr = D3DERR_DRIVERINTERNALERROR;
//	}

	BLOCKRESULT(dr == D3D_OK);
	if(WASGOODRESULT()) {
		RegisterDeinitFunc(ptestDirect3dDevice8Release);
	} else {
		xLog(hlog, XLL_INFO, "CreateDevice returned %d", dr);
	}

	xEndVariation(hlog);
}
ENDTEST()

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\math.cpp ===
#include "d3dapi.hpp"
#include "xgmath.h"

//please pardon the macros. It saves a lot of copy/paste errors, and makes it really easy to change the testing algorithm.
//before preprocessing, this file is 28k. Afterwards, (not including the headers), it is 257k. 

//needed for the defines... Def(Float, variable)
typedef float XGFloat, D3DXFloat;

//repeat count, for speed tests
#define COUNT (1000)

//accuracty (like epsilon, but scaled instead of linear)
#define ACCURACY (((.99)))

LINKME(19);

#define EPSILON 0.0001f
static inline bool WithinEpsilon(float a, float b)
{
    float f = a - b;
    return -EPSILON <= f && f <= EPSILON;
}

//used in prepending the appropriate prefixes on function and type names
#define xg_(x) XG##x
#define dx_(x) D3DX##x

//used in creating variable names
#define _dx(x) x##_D3DX
#define _xg(x) x##_XG

//_P is postfixed to a variable, to imply that it is a pointer
#define _P(x) x##_P
//_Size1 is postfixed to a variable name, being a pointer to the size, or the size.
#define _S1(x) x##_Size1

//used to declare PLANE, VECTOR2, VECTOR3, for use when the address is to be passed as a parameter to the function being tested.
#define Dec(type, x)  xg_(type)   _xg(x); dx_(type)   _dx(x); int _S1(x) = sizeof(_dx(x))/sizeof(float); xg_(type)*    _xg(x)##_P = &_xg(x); dx_(type)*   _dx(x)##_P = &(_dx(x)); 

//used to declare a pointer to a type that will be used as a return type (like to Vec2Add)
#define DecP(type, x) xg_(type)*  _xg(x); dx_(type)*  _dx(x); int x##_Size = sizeof(*_dx(x))/sizeof(float); int* _S1(x)=&x##_Size; xg_(type)**  _xg(x)##_P = &(_xg(x)); dx_(type)**  _dx(x)##_P = &(_dx(x)); 

//this was used to declare XGMATRIXA, but since that has been replaced, it is just shorter than typing Dec(MATRIX, )
#define DecMat(x)    xg_(MATRIX) _xg(x); dx_(MATRIX) _dx(x); int _S1(x) = 16;                           xg_(MATRIX)* _xg(x)##_P = &_xg(x); dx_(MATRIX)* _dx(x)##_P = &(_dx(x)); 

//declares a float that will be passed as a paramter (instead of by address)
#define DecFlt(x)    float        _xg(x); float       _dx(x); int x##_Size = 1; int* _S1(x) = &x##_Size; float* _xg(x)##_P1 = &_xg(x); float* _dx(x)##_P1 = &(_dx(x)); float** _xg(x)##_P = (&_xg(x)##_P1); float** _dx(x)##_P = (&_dx(x)##_P1);

//declare a type, like BOOL, that doesn't have the XG/D3DX prefix, but will be used as a return type
#define DecTyp(type, x) type        _xg(x); type       _dx(x); int x##_Size = 1; int* _S1(x) = &x##_Size; type* _xg(x)##_P1 = &_xg(x); type* _dx(x)##_P1 = &(_dx(x)); type** _xg(x)##_P = (&_xg(x)##_P1); type** _dx(x)##_P = (&_dx(x)##_P1);

//for parameters, pFloatify expands to be the address of (x) that can be used to fill the variable x with random data
#define pFloatify(x) ((float*)(*(_P(x))))

//used by Pre, below.
//used to pass various parameters to a function, with the appropriate postfix to each variable
#define xgPre1(p1)                   _xg(p1)
#define xgPre2(p1,p2)                _xg(p1), _xg(p2)
#define xgPre3(p1,p2,p3)             _xg(p1), _xg(p2), _xg(p3)
#define xgPre4(p1,p2,p3,p4)          _xg(p1), _xg(p2), _xg(p3), _xg(p4)
#define xgPre5(p1,p2,p3,p4,p5)       _xg(p1), _xg(p2), _xg(p3), _xg(p4), _xg(p5)
#define xgPre6(p1,p2,p3,p4,p5,p6)    _xg(p1), _xg(p2), _xg(p3), _xg(p4), _xg(p5), _xg(p6)
#define xgPre7(p1,p2,p3,p4,p5,p6,p7) _xg(p1), _xg(p2), _xg(p3), _xg(p4), _xg(p5), _xg(p6), _xg(p7)
#define dxPre1(p1)                   _dx(p1)
#define dxPre2(p1,p2)                _dx(p1), _dx(p2)
#define dxPre3(p1,p2,p3)             _dx(p1), _dx(p2), _dx(p3)
#define dxPre4(p1,p2,p3,p4)          _dx(p1), _dx(p2), _dx(p3), _dx(p4)
#define dxPre5(p1,p2,p3,p4,p5)       _dx(p1), _dx(p2), _dx(p3), _dx(p4), _dx(p5)
#define dxPre6(p1,p2,p3,p4,p5,p6)    _dx(p1), _dx(p2), _dx(p3), _dx(p4), _dx(p5), _dx(p6)
#define dxPre7(p1,p2,p3,p4,p5,p6,p7) _dx(p1), _dx(p2), _dx(p3), _dx(p4), _dx(p5), _dx(p6), _dx(p7)

//used to check a list of parameters
#define CheckPre1(p1)                   CheckRes &= Check(p1)
#define CheckPre2(p1,p2)                CheckRes &= Check(p1) & Check(p2)
#define CheckPre3(p1,p2,p3)             CheckRes &= Check(p1) & Check(p2) & Check(p3)
#define CheckPre4(p1,p2,p3,p4)          CheckRes &= Check(p1) & Check(p2) & Check(p3) & Check(p4)
#define CheckPre5(p1,p2,p3,p4,p5)       CheckRes &= Check(p1) & Check(p2) & Check(p3) & Check(p4) & Check(p5)
#define CheckPre6(p1,p2,p3,p4,p5,p6)    CheckRes &= Check(p1) & Check(p2) & Check(p3) & Check(p4) & Check(p5) & Check(p6)
#define CheckPre7(p1,p2,p3,p4,p5,p6,p7) CheckRes &= Check(p1) & Check(p2) & Check(p3) & Check(p4) & Check(p5) & Check(p6) & Check(p7)

//used to fill various parameters
#define FillPre1(p1)                   FillBoth(p1);
#define FillPre2(p1,p2)                FillBoth(p1); FillBoth(p2);
#define FillPre3(p1,p2,p3)             FillBoth(p1); FillBoth(p2); FillBoth(p3);
#define FillPre4(p1,p2,p3,p4)          FillBoth(p1); FillBoth(p2); FillBoth(p3); FillBoth(p4);
#define FillPre5(p1,p2,p3,p4,p5)       FillBoth(p1); FillBoth(p2); FillBoth(p3); FillBoth(p4); FillBoth(p5);
#define FillPre6(p1,p2,p3,p4,p5,p6)    FillBoth(p1); FillBoth(p2); FillBoth(p3); FillBoth(p4); FillBoth(p5); FillBoth(p6);
#define FillPre7(p1,p2,p3,p4,p5,p6,p7) FillBoth(p1); FillBoth(p2); FillBoth(p3); FillBoth(p4); FillBoth(p5); FillBoth(p6); FillBoth(p7);

//prepares the parameter list _p_ for use with the macro with prefix pre (see list above). cnt specifies the number of parameters in teh list.
#define Pre(pre, cnt, _p_) pre##Pre##cnt##_p_

//suffex the paramters in (list _p_ with cnt elements) with the postfix (pre), and call func with those parameters
#define Call(func, pre, cnt, _p_) pre##_(func) (Pre(pre,cnt,_p_)) 

//compares the dx and xg versions of all elements in _p_ 
#define CheckAll(cnt,_p_) Pre(Check,cnt,_p_)

//fills all elements of the xg and dx versions of all elements in _p_ with random single-precision float values
#define FillAll(cnt,_p_) Pre(Fill,cnt,_p_)

/*
#define Callboth1(func,p1)          do { Call1(xg, func, p1)         ; Call1(dx, func, p1)          } while(0)
#define Callboth2(func,p1,p2)       do { Call2(xg, func, p1,p2)      ; Call2(dx, func, p1,p2)       } while(0)
#define Callboth3(func,p1,p2,p3)    do { Call3(xg, func, p1,p2,p3)   ; Call3(dx, func, p1,p2,p3)    } while(0)
#define Callboth4(func,p1,p2,p3,p4) do { Call4(xg, func, p1,p2,p3,p4); Call4(dx, func, p1,p2,p3,p4) } while(0)
*/

float randf() {
	//generate a totally random float. This can include infinity, but no other non-numbers.

	DWORD mantissa;
	DWORD expo = (rand() & 0x11f) + 0x6d; //exponent and sign
	//the 0x3f is added to keep the exponent in the range of (about) -32 to 32, in order to prevent overflows
/*
	if((expo & 255) == 255) //infinity or qnan
	{
		mantissa = 0;
	} else {
*/
	mantissa = (rand() + (rand() << 15)) & ((1 << 23) - 1);

	DWORD ret = mantissa | (expo << 23);
	return *(float*)&ret;	
}

bool CmpFloats(float*a, float*b, int count) {
	volatile int i; //force the optimizer to keep i in memory so we can actually read it in the debugger if we break
	if(a == NULL || b == NULL) {
		if (a == b) return true;
		else return false;
	}
	for(i = 0; i < count; i++) {
		if(*(DWORD*)(&a[i]) == *(DWORD*)(&b[i])) continue; //catch infinity
		if(((*(DWORD*)(&a[i]) & 0x7f800000) == 0x7f800000) && ((*(DWORD*)(&b[i]) & 0x7f800000) == 0x7f800000)) continue;
		if(WithinEpsilon(a[i],b[i])) continue;
		if(fabs(a[i]*ACCURACY)<fabs(b[i]) && fabs(b[i]*ACCURACY)<fabs(a[i])) continue;
//		_asm {int 3};
		return false;
	}
	return true;
}

//the number of floats in x
#define FloatCount(x) (*(_S1(x)))

//fill the dx and xg versions of x with floating-point values. 
//with matracies, vectors, etc, it fills all elements of those variables.
#define FillBoth(x)	do { for (int i = 0; i < FloatCount(x); i++) { ((pFloatify(_dx(x)))[i]) = ((pFloatify(_xg(x)))[i]) = randf(); }; } while (0)

//sticks a dword in the specified range into x, where x is a variable the size of a dword
#define FillDword(x, _min, _max) (((int*)(pFloatify(_dx(x))))[0]) = (((int*)(pFloatify(_xg(x))))[0]) = RandMM(_min, _max)
#define FillViewPort(x) do { FillVP((D3DVIEWPORT8*)_xg(x), (D3DVIEWPORT8*)_dx(x)); } while(0)

//return a random int between mi and ma
int RandMM(int mi, int ma) {
	int r = rand() + (rand() << 15);
	return (r % (ma + 1 - mi)) + mi;
}
void FillVP(D3DVIEWPORT8*pvp1,D3DVIEWPORT8*pvp2){
	pvp2->X =     pvp1->X = RandMM(0,630);
	pvp2->Width = pvp1->Width = RandMM(1,640-pvp1->X);
	pvp2->Y =     pvp1->Y = RandMM(0, 470);
	pvp2->Height =pvp1->Height = RandMM(1,480-pvp1->Y);
	float f1 = (float)fabs(randf());
	float f2 = (float)fabs(randf());
	pvp2->MinZ =  pvp1->MinZ = min(f1,f2);
	pvp2->MaxZ =  pvp1->MaxZ = max(f1,f2);
}


//compares the xg and dx versions of x
#define Check(x) CmpFloats(pFloatify(_dx(x)), pFloatify(_xg(x)), FloatCount(x))

//declare and initialize variables used in speed tests
#define InitSpd __int64 _dx(Start), _xg(Start), _dx(End)=0, _xg(End)=0; bool CheckRes = true; bool SpdRes = true; int Counter;

//wrap code (x) in speed-checking code. pre is either xg or dx.
#define SpdCheck(pre, code) do { _##pre(Start) = GetTsc(); code; _##pre(End) += GetTsc() - _##pre(Start); } while(0)

//only used if the return type is void
#define Test(func,cnt,_p_) do {													\
							xLog(hlog,XLL_INFO,#func);							\
							for(Counter = 0; Counter < COUNT; Counter++) {		\
								FillAll(cnt,_p_);								\
								Call(func,dx,cnt,_p_);							\
								Call(func,xg,cnt,_p_);							\
								CheckAll(cnt,_p_);								\
							}													\
							for(Counter = 0; Counter < COUNT; Counter++) {		\
								SpdCheck(dx, Call(func,dx,cnt,_p_););			\
								SpdCheck(xg, Call(func,xg,cnt,_p_););			\
							};													\
							CHECKRESULT((_xg(End) * .97 <= _dx(End)) && "speed test");	\
                            if(1/*WASBADRESULT()*/) xLog(hlog,XLL_INFO,"xg uS: %I64d. dx us: %I64d", _xg(End), _dx(End)); \
							CHECKRESULT(CheckRes && "Float Comparison");		\
						} while (0)

//grabs the return type. Ret must be declared as the type of the return-type of the function tested
#define TestRet(func,cnt,_p_) do {												\
							xLog(hlog,XLL_INFO,#func);							\
							for(Counter = 0; Counter < COUNT; Counter++) {		\
								FillAll(cnt,_p_);								\
								_dx(Ret) = Call(func,dx,cnt,_p_);				\
								_xg(Ret) = Call(func,xg,cnt,_p_);				\
								CheckAll(cnt,_p_);								\
								Check(Ret);										\
							}													\
							for(Counter = 0; Counter < COUNT; Counter++) {		\
								SpdCheck(dx, Call(func,dx,cnt,_p_););			\
								SpdCheck(xg, Call(func,xg,cnt,_p_););			\
							};													\
							CHECKRESULT((_xg(End) * .97 <= _dx(End)) && "spd");	\
                            if(1/*WASBADRESULT()*/) xLog(hlog,XLL_INFO,"xg uS: %I64d. dx us: %I64d", _xg(End), _dx(End)); \
							CHECKRESULT(CheckRes && "Float Comparison");		\
						} while (0)


//fpu accuracy == saved in the first test, restored in the end.
//0 = single. 1 == double. 3 == extended-double
int gFpuAccuracy; 

int GetFpuAccuracy()
{
	int i=0;
	_asm fstcw [i];
	return (i >> 8) & 3;
}

void SetFpuAccuracy(int a)
{
	int i=0;
	_asm fstcw [i];
	i &= ~0x300;
	i |= ((a & 3) << 8);
	_asm fldcw [i];
}

#pragma data_seg(".d3dapi$test026") //run nearly first
extern "C" void DebugPrint(const char*,...);
BEGINTEST(testMathnew)
{
	int* blah = new int[63];
	DebugPrint("new int[64]: %p\n", blah);
	int* bla  = new int[63];
	DebugPrint("new int[64]: %p\n", bla);
	delete[] bla, blah;

}
ENDTEST();

BEGINTEST(testMathVec2Inl)
{

	gFpuAccuracy = GetFpuAccuracy();
	SetFpuAccuracy(3);

	xStartVariation(hlog, "Vector2 Inline tests");

	{   InitSpd;
		DecFlt(Ret); Dec(VECTOR2, v);
		TestRet(Vec2Length, 1, (&v));	
	}
	{   InitSpd;
		DecFlt(Ret); Dec(VECTOR2, v);
		TestRet(Vec2LengthSq, 1, (&v));	
	}
	{   InitSpd;
		DecFlt(Ret); Dec(VECTOR2, v1); Dec(VECTOR2, v2);
		TestRet(Vec2Dot, 2, (&v1, &v2));	
	}
	{   InitSpd;
		DecFlt(Ret); Dec(VECTOR2, v1); Dec(VECTOR2, v2);
		TestRet(Vec2CCW, 2, (&v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v1); Dec(VECTOR2, v2);
		TestRet(Vec2Add, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v1); Dec(VECTOR2, v2);
		TestRet(Vec2Subtract, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v1); Dec(VECTOR2, v2);
		TestRet(Vec2Minimize, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v1); Dec(VECTOR2, v2);
		TestRet(Vec2Maximize, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v); DecFlt(s);
		TestRet(Vec2Scale, 3, (&Out, &v, s));	
	}
	{   InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v1); Dec(VECTOR2, v2); DecFlt(s);
		TestRet(Vec2Lerp, 4, (&Out, &v1, &v2, s));	
	}

	xEndVariation(hlog);

} 
ENDTEST();

BEGINTEST(testMathVec2NonInl)
{

	xStartVariation(hlog, "Vector2 non-inline tests");

	{   InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v);
		TestRet(Vec2Normalize, 2, (&Out, &v));	
	}
	{	InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v1); Dec(VECTOR2, t1); Dec(VECTOR2, v2); Dec(VECTOR2, t2); DecFlt(s);
		TestRet(Vec2Hermite, 6, (&Out,&v1,&t1,&v2,&t2,s)); 
	}
	{	InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v0); Dec(VECTOR2, v1); Dec(VECTOR2, v2); Dec(VECTOR2, v3); DecFlt(s);
		TestRet(Vec2CatmullRom, 6, (&Out, &v0, &v1, &v2, &v3, s)); 
	}
	{	InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v1); Dec(VECTOR2, v2); Dec(VECTOR2, v3); DecFlt(f); DecFlt(g);
		TestRet(Vec2BaryCentric, 6, (&Out, &v1, &v2, &v3, f, g)); 
	}
	{	InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR2, v); DecMat(m);
		TestRet(Vec2Transform, 3, (&Out, &v, &m)); 
	}
	/*
	{	InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v); DecMat(m);
		TestRet(Vec2TransformCoord, 3, (&Out, &v, &m)); 
	}
	*/
	{	InitSpd;
		DecP(VECTOR2, Ret); Dec(VECTOR2, Out); Dec(VECTOR2, v); DecMat(m);
		TestRet(Vec2TransformNormal, 3, (&Out, &v, &m)); 
	}

	xEndVariation(hlog);
} 
ENDTEST();

BEGINTEST(testMathVec3Inl)
{
	xStartVariation(hlog, "Vector3 inline tests");

	{   InitSpd;
		DecFlt(Ret); Dec(VECTOR3, v);
		TestRet(Vec3Length, 1, (&v));	
	}
	{   InitSpd;
		DecFlt(Ret); Dec(VECTOR3, v);
		TestRet(Vec3LengthSq, 1, (&v));	
	}
	{   InitSpd;
		DecFlt(Ret); Dec(VECTOR3, v1); Dec(VECTOR3, v2);
		TestRet(Vec3Dot, 2, (&v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v1); Dec(VECTOR3, v2);
		TestRet(Vec3Add, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v1); Dec(VECTOR3, v2);
		TestRet(Vec3Cross, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v1); Dec(VECTOR3, v2);
		TestRet(Vec3Subtract, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v1); Dec(VECTOR3, v2);
		TestRet(Vec3Minimize, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v1); Dec(VECTOR3, v2);
		TestRet(Vec3Maximize, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v); DecFlt(s);
		TestRet(Vec3Scale, 3, (&Out, &v, s));	
	}
	{   InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v1); Dec(VECTOR3, v2); DecFlt(s);
		TestRet(Vec3Lerp, 4, (&Out, &v1, &v2, s));	
	}

	xEndVariation(hlog);
} 
ENDTEST();

BEGINTEST(testMathVec3NonInl)
{

	xStartVariation(hlog, "Vector3 non-inline tests");

	{	InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v);
		TestRet(Vec3Normalize, 2, (&Out, &v)); 
	}
	{	InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v1); Dec(VECTOR3, t1); Dec(VECTOR3, v2); Dec(VECTOR3, t2); DecFlt(s);
		TestRet(Vec3Hermite, 6, (&Out,&v1,&t1,&v2,&t2,s)); 
	}
	{	InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v0); Dec(VECTOR3, v1); Dec(VECTOR3, v2); Dec(VECTOR3, v3); DecFlt(s);
		TestRet(Vec3CatmullRom, 6, (&Out, &v0, &v1, &v2, &v3, s)); 
	}
	{	InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v1); Dec(VECTOR3, v2); Dec(VECTOR3, v3); DecFlt(f); DecFlt(g);
		TestRet(Vec3BaryCentric, 6, (&Out, &v1, &v2, &v3, f, g)); 
	}
	{	InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR3, v); DecMat(m);
		TestRet(Vec3Transform, 3, (&Out, &v, &m)); 
	}
	{	InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v); DecMat(m);
		TestRet(Vec3TransformCoord, 3, (&Out, &v, &m)); 
	}
	{	InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v); DecMat(m);
		TestRet(Vec3TransformNormal, 3, (&Out, &v, &m)); 
	}
	//viewport is a dword thing, not a float thing. FillPre6 must be redefined to fill it appropriately
	{	InitSpd;
		typedef D3DVIEWPORT8 XGVIEWPORT8, D3DXVIEWPORT8;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v); Dec(VIEWPORT8, vp); DecMat(proj); DecMat(view); DecMat(world);
		#undef FillPre6
		#define FillPre6(p1,p2,p3,p4,p5,p6) FillBoth(p1); FillBoth(p2); FillViewPort(p3); FillBoth(p4); FillBoth(p5); FillBoth(p6);
		TestRet(Vec3Project, 6, (&Out, &v, &vp, &proj, &view, &world)); 
		#undef FillPre6
		//reset FillPre6 the way it should be
		#define FillPre6(p1,p2,p3,p4,p5,p6) FillBoth(p1); FillBoth(p2); FillBoth(p3); FillBoth(p4); FillBoth(p5); FillBoth(p6);
	}
	{	InitSpd;
		typedef D3DVIEWPORT8 XGVIEWPORT8, D3DXVIEWPORT8;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(VECTOR3, v); Dec(VIEWPORT8, vp); DecMat(proj); DecMat(view); DecMat(world);
		#undef FillPre6
		#define FillPre6(p1,p2,p3,p4,p5,p6) FillBoth(p1); FillBoth(p2); FillDword(p3,0,640); FillBoth(p4); FillBoth(p5); FillBoth(p6);
		TestRet(Vec3Unproject, 6, (&Out, &v, &vp, &proj, &view, &world)); 
		#undef FillPre6
		#define FillPre6(p1,p2,p3,p4,p5,p6) FillBoth(p1); FillBoth(p2); FillBoth(p3); FillBoth(p4); FillBoth(p5); FillBoth(p6);
	}

	xEndVariation(hlog);
} 
ENDTEST();

BEGINTEST(testMathVec4Inl)
{
	xStartVariation(hlog, "Vector4 inline tests");

	{   InitSpd;
		DecFlt(Ret); Dec(VECTOR4, v);
		TestRet(Vec4Length, 1, (&v));	
	}
	{   InitSpd;
		DecFlt(Ret); Dec(VECTOR4, v);
		TestRet(Vec4LengthSq, 1, (&v));	
	}
	{   InitSpd;
		DecFlt(Ret); Dec(VECTOR4, v1); Dec(VECTOR4, v2);
		TestRet(Vec4Dot, 2, (&v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v1); Dec(VECTOR4, v2);
		TestRet(Vec4Add, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v1); Dec(VECTOR4, v2);
		TestRet(Vec4Subtract, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v1); Dec(VECTOR4, v2);
		TestRet(Vec4Minimize, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v1); Dec(VECTOR4, v2);
		TestRet(Vec4Maximize, 3, (&Out, &v1, &v2));	
	}
	{   InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v); DecFlt(s);
		TestRet(Vec4Scale, 3, (&Out, &v, s));	
	}
	{   InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v1); Dec(VECTOR4, v2); DecFlt(s);
		TestRet(Vec4Lerp, 4, (&Out, &v1, &v2, s));	
	}

	xEndVariation(hlog);
} 
ENDTEST();

BEGINTEST(testMathVec4NonInl)
{

	xStartVariation(hlog, "Vector4 non-inline tests");

	{	InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v);
		TestRet(Vec4Normalize, 2, (&Out, &v)); 
	}
	{	InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v1); Dec(VECTOR4, t1); Dec(VECTOR4, v2); Dec(VECTOR4, t2); DecFlt(s);
		TestRet(Vec4Hermite, 6, (&Out,&v1,&t1,&v2,&t2,s)); 
	}
	{	InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v0); Dec(VECTOR4, v1); Dec(VECTOR4, v2); Dec(VECTOR4, v3); DecFlt(s);
		TestRet(Vec4CatmullRom, 6, (&Out, &v0, &v1, &v2, &v3, s)); 
	}
	{	InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v1); Dec(VECTOR4, v2); Dec(VECTOR4, v3); DecFlt(f); DecFlt(g);
		TestRet(Vec4BaryCentric, 6, (&Out, &v1, &v2, &v3, f, g)); 
	}
	{	InitSpd;
		DecP(VECTOR4, Ret); Dec(VECTOR4, Out); Dec(VECTOR4, v); DecMat(m);
		TestRet(Vec4Transform, 3, (&Out, &v, &m)); 
	}
	
	xEndVariation(hlog);
}
ENDTEST();

BEGINTEST(testMathMatrixInl)
{
	xStartVariation(hlog, "Matrix inline tests");
	{	InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); 
		TestRet(MatrixIdentity, 1, (&Out)); 
	}
	//unimportant todo: give MatrixIsIdentity some good/bad cases
	{	InitSpd;
		DecTyp(BOOL, Ret); DecMat(m); 
		TestRet(MatrixIsIdentity, 1, (&m)); 
	}
	xEndVariation(hlog);
}
ENDTEST();

BEGINTEST(testMathMatrixNonInl)
{
	xStartVariation(hlog, "Matrix non-inline tests");
	{   InitSpd;
		DecFlt(Ret); DecMat(m);
		TestRet(MatrixfDeterminant, 1, (&m));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); DecMat(m1); DecMat(m2);
		TestRet(MatrixMultiply, 3, (&Out, &m1, &m2));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); DecMat(m);
		TestRet(MatrixTranspose, 2, (&Out, &m));
	}

	//TODO: give MatrixInverse some specific failure cases
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); Dec(Float, f); DecMat(m);
		TestRet(MatrixInverse, 3, (&Out, &f, &m));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); DecFlt(x); DecFlt(y); DecFlt(z);
		TestRet(MatrixScaling, 4, (&Out, x, y, z));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); DecFlt(x); DecFlt(y); DecFlt(z);
		TestRet(MatrixTranslation, 4, (&Out, x, y, z));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); DecFlt(x); 
		TestRet(MatrixRotationX, 2, (&Out, x));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); DecFlt(x); 
		TestRet(MatrixRotationY, 2, (&Out, x));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); DecFlt(x); 
		TestRet(MatrixRotationY, 2, (&Out, x));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); Dec(VECTOR3, v); DecFlt(a); 
		TestRet(MatrixRotationAxis, 3, (&Out, &v, a));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); Dec(QUATERNION, q); 
		TestRet(MatrixRotationQuaternion, 2, (&Out, &q));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); DecFlt(x); DecFlt(y); DecFlt(z);
		TestRet(MatrixRotationYawPitchRoll, 4, (&Out, x, y, z));
	}
	//todo: check this with NULL params
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); Dec(VECTOR3, ss); Dec(QUATERNION, sr); Dec(VECTOR3, sc); Dec(VECTOR3, rc); Dec(QUATERNION, r); Dec(VECTOR3, t); 
		TestRet(MatrixTransformation, 7, (&Out, &ss, &sr, &sc, &rc, &r, &t));
	}
	//todo: check this with null params
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); DecFlt(s); Dec(VECTOR3, rc); Dec(QUATERNION, r); Dec(VECTOR3, t); 
		TestRet(MatrixAffineTransformation, 5, (&Out, s, &rc, &r, &t));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); Dec(VECTOR3, eye); Dec(VECTOR3, at); Dec(VECTOR3, up); 
		TestRet(MatrixLookAtRH, 4, (&Out, &eye, &at, &up));
	}
	{   InitSpd;
		DecP(MATRIX, Ret); DecMat(Out); Dec(VECTOR3, eye); Dec(VECTOR3, at); Dec(VECTOR3, up); 
		TestRet(MatrixLookAtLH, 4, (&Out, &eye, &at, &up));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); DecFlt(w);DecFlt(h);DecFlt(zn);DecFlt(zf);
		TestRet(MatrixPerspectiveRH, 5, (&Out, w,h,zn,zf));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); DecFlt(w);DecFlt(h);DecFlt(zn);DecFlt(zf);
		TestRet(MatrixPerspectiveLH, 5, (&Out, w,h,zn,zf));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); DecFlt(fovy);DecFlt(a);DecFlt(zn);DecFlt(zf);
		TestRet(MatrixPerspectiveFovRH, 5, (&Out, fovy,a,zn,zf));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); DecFlt(fovy);DecFlt(a);DecFlt(zn);DecFlt(zf);
		TestRet(MatrixPerspectiveFovLH, 5, (&Out, fovy,a,zn,zf));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); DecFlt(l);DecFlt(r);DecFlt(b);DecFlt(t);DecFlt(zn);DecFlt(zf);
		TestRet(MatrixPerspectiveOffCenterRH, 7, (&Out, l,r,b,t,zn,zf));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); DecFlt(l);DecFlt(r);DecFlt(b);DecFlt(t);DecFlt(zn);DecFlt(zf);
		TestRet(MatrixPerspectiveOffCenterLH, 7, (&Out, l,r,b,t,zn,zf));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); DecFlt(w);DecFlt(h);DecFlt(zn);DecFlt(zf);
		TestRet(MatrixOrthoRH, 5, (&Out, w,h,zn,zf));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); DecFlt(w);DecFlt(h);DecFlt(zn);DecFlt(zf);
		TestRet(MatrixOrthoLH, 5, (&Out, w,h,zn,zf));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); DecFlt(l);DecFlt(r);DecFlt(b);DecFlt(t);DecFlt(zn);DecFlt(zf);
		TestRet(MatrixOrthoOffCenterRH, 7, (&Out, l,r,b,t,zn,zf));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); DecFlt(l);DecFlt(r);DecFlt(b);DecFlt(t);DecFlt(zn);DecFlt(zf);
		TestRet(MatrixOrthoOffCenterLH, 7, (&Out, l,r,b,t,zn,zf));
	}

	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); Dec(VECTOR4, light); Dec(PLANE, p);
		TestRet(MatrixShadow, 3, (&Out, &light, &p));
	}
	{   InitSpd;
		DecP(MATRIX, Ret);DecMat(Out); Dec(PLANE, p);
		TestRet(MatrixReflect, 2, (&Out, &p));
	}
	xEndVariation(hlog);
}
ENDTEST();

BEGINTEST(testMathQuatInl)
{
	xStartVariation(hlog,"Quaternion inl");
	{   InitSpd;
		DecFlt(Ret); Dec(QUATERNION, q);
		TestRet(QuaternionLength, 1, (&q));
	}
	{   InitSpd;
		DecFlt(Ret); Dec(QUATERNION, q);
		TestRet(QuaternionLengthSq, 1, (&q));
	}
	{   InitSpd;
		DecFlt(Ret); Dec(QUATERNION, q); Dec(QUATERNION, q2);
		TestRet(QuaternionDot, 2, (&q, &q2));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out);
		TestRet(QuaternionIdentity, 1, (&Out));
	}
	//unimportant todo: check boundary and close conditions
	{   InitSpd;
		DecTyp(BOOL, Ret); Dec(QUATERNION, Out);
		TestRet(QuaternionIsIdentity, 1, (&Out));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, q); Dec(QUATERNION, q2);
		TestRet(QuaternionConjugate, 2, (&q, &q2));
	}

	xEndVariation(hlog);
}
ENDTEST();

BEGINTEST(testMathQuatNonInl)
{
	xStartVariation(hlog,"Quaternion non-inl");
	{   InitSpd;
		Dec(QUATERNION, q); Dec(VECTOR3, ax); Dec(Float, an);
		Test(QuaternionToAxisAngle, 3, (&q, &ax, &an));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); DecMat(m);
		TestRet(QuaternionRotationMatrix, 2, (&Out, &m));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); Dec(VECTOR3, ax); DecFlt(an);
		TestRet(QuaternionRotationAxis, 3, (&Out, &ax, an));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); DecFlt(ya);DecFlt(pi);DecFlt(ro);
		TestRet(QuaternionRotationYawPitchRoll, 4, (&Out, ya,pi,ro));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); Dec(QUATERNION, q1); Dec(QUATERNION, q2); 
		TestRet(QuaternionMultiply, 3, (&Out, &q1, &q2));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); Dec(QUATERNION, q); 
		TestRet(QuaternionNormalize, 2, (&Out, &q));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); Dec(QUATERNION, q); 
		TestRet(QuaternionInverse, 2, (&Out, &q));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); Dec(QUATERNION, q); 
		TestRet(QuaternionLn, 2, (&Out, &q));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); Dec(QUATERNION, q); 
		TestRet(QuaternionExp, 2, (&Out, &q));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); Dec(QUATERNION, q1); Dec(QUATERNION, q2); DecFlt(t);
		TestRet(QuaternionSlerp, 4, (&Out, &q1, &q2, t));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); Dec(QUATERNION, q1); Dec(QUATERNION, q3); Dec(QUATERNION, q4); Dec(QUATERNION, q2); DecFlt(f); 
		TestRet(QuaternionSquad, 6, (&Out, &q1, &q2, &q3, &q4, f));
	}
	{   InitSpd;
		DecP(QUATERNION, Ret); Dec(QUATERNION, Out); Dec(QUATERNION, q1); Dec(QUATERNION, q3); Dec(QUATERNION, q2); DecFlt(f); DecFlt(g);
		TestRet(QuaternionBaryCentric, 6, (&Out, &q1, &q2, &q3, f,g));
	}

	xEndVariation(hlog);
}
ENDTEST();

BEGINTEST(testMathPlaneInl)
{
	xStartVariation(hlog, "Math Plane Inline");
	{   InitSpd;
		DecFlt(Ret); Dec(PLANE, p); Dec(VECTOR4, v);
		TestRet(PlaneDot, 2, (&p, &v));
	}
	{   InitSpd;
		DecFlt(Ret); Dec(PLANE, p); Dec(VECTOR3, v);
		TestRet(PlaneDotCoord, 2, (&p, &v));
	}
	{   InitSpd;
		DecFlt(Ret); Dec(PLANE, p); Dec(VECTOR3, v);
		TestRet(PlaneDotNormal, 2, (&p, &v));
	}
	xEndVariation(hlog);
}
ENDTEST();

BEGINTEST(testMathPlaneNonInl)
{
	xStartVariation(hlog, "Math Plane NonInline");
	{   InitSpd;
		DecP(PLANE, Ret); Dec(PLANE, Out); Dec(PLANE, p); 
		TestRet(PlaneNormalize, 2, (&Out, &p));
	}
	{   InitSpd;
		DecP(VECTOR3, Ret); Dec(VECTOR3, Out); Dec(PLANE, p);  Dec(VECTOR3, v1); Dec(VECTOR3, v2);
		TestRet(PlaneIntersectLine, 4, (&Out, &p,&v1,&v2));
	}
	{   InitSpd;
		DecP(PLANE, Ret); Dec(PLANE, Out);  Dec(VECTOR3, v1); Dec(VECTOR3, v2);
		TestRet(PlaneFromPointNormal, 3, (&Out, &v1,&v2));
	}
	{   InitSpd;
		DecP(PLANE, Ret); Dec(PLANE, Out); Dec(VECTOR3, v3);  Dec(VECTOR3, v1); Dec(VECTOR3, v2);
		TestRet(PlaneFromPoints, 4, (&Out, &v3,&v1,&v2));
	}
	{   InitSpd;
		DecP(PLANE, Ret); Dec(PLANE, Out); Dec(PLANE, p);  DecMat(m);
		TestRet(PlaneTransform, 3, (&Out, &p,&m));
	}
	xEndVariation(hlog);
}
ENDTEST();

BEGINTEST(testMathColor)
{
	xStartVariation(hlog, "Math Color Inline");
	{   InitSpd;
		DecP(COLOR, Ret); Dec(COLOR, Out); Dec(COLOR, c);
		TestRet(ColorNegative, 2, (&Out, &c));
	}
	{   InitSpd;
		DecP(COLOR, Ret); Dec(COLOR, Out); Dec(COLOR, c1);Dec(COLOR, c2);
		TestRet(ColorAdd, 3, (&Out, &c1, &c2));
	}
	{   InitSpd;
		DecP(COLOR, Ret); Dec(COLOR, Out); Dec(COLOR, c1);Dec(COLOR, c2);
		TestRet(ColorSubtract, 3, (&Out, &c1, &c2));
	}
	{   InitSpd;
		DecP(COLOR, Ret); Dec(COLOR, Out); Dec(COLOR, c);DecFlt(s);
		TestRet(ColorScale, 3, (&Out, &c, s));
	}
	{   InitSpd;
		DecP(COLOR, Ret); Dec(COLOR, Out); Dec(COLOR, c1);Dec(COLOR, c2);
		TestRet(ColorModulate, 3, (&Out, &c1, &c2));
	}
	{   InitSpd;
		DecP(COLOR, Ret); Dec(COLOR, Out); Dec(COLOR, c1);Dec(COLOR, c2);DecFlt(f)
		TestRet(ColorLerp, 4, (&Out, &c1, &c2,f));
	}
	{   InitSpd;
		DecP(COLOR, Ret); Dec(COLOR, Out); Dec(COLOR, c);DecFlt(f)
		TestRet(ColorAdjustSaturation, 3, (&Out, &c,f));
	}
	{   InitSpd;
		DecP(COLOR, Ret); Dec(COLOR, Out); Dec(COLOR, c);DecFlt(f)
		TestRet(ColorAdjustContrast, 3, (&Out, &c,f));
	}


	xEndVariation(hlog);
}
ENDTEST();

BEGINTEST(testMathCleanup)
{
	SetFpuAccuracy(gFpuAccuracy);
}
ENDTEST();
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\resource.cpp ===
#include "d3dapi.hpp"

LINKME(8)

#pragma data_seg(".d3dapi$test070") 

/*
	HRESULT WINAPI IDirect3DTexture8_SetPrivateData(IDirect3DTexture8 *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return IDirect3DResource8_SetPrivateData((IDirect3DResource8 *)pThis, refguid, pData, SizeOfData, Flags); }
	HRESULT WINAPI IDirect3DTexture8_GetPrivateData(IDirect3DTexture8 *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return IDirect3DResource8_GetPrivateData((IDirect3DResource8 *)pThis, refguid, pData, pSizeOfData); }
	HRESULT WINAPI IDirect3DTexture8_FreePrivateData(IDirect3DTexture8 *pThis, REFGUID refguid) { return IDirect3DResource8_FreePrivateData((IDirect3DResource8 *)pThis, refguid); }
*/


#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\sources.inc ===
!include ..\..\sources.inc

TARGETNAME=l_d3dapi
TARGETTYPE=LIBRARY
TARGETPATH=$(TEST_LIB_DEST)

#USE_MAPSYM=1

SOURCES=d3dapi.cpp				\
        math.cpp                \
        d3dapi.rc               \
		volume.cpp				\
		cubetexture.cpp			\
		volumetexture.cpp		\
		texture.cpp				\
		direct3d8apiinit.cpp	\
		direct3d8api.cpp		\
		direct3ddevice8init.cpp	\
		direct3ddevice8.cpp		\
		resource.cpp			\
		linkme.cpp				\
        vertexbuffer.cpp        

#       uma.cpp                 \ //broken for the time being
#		cursor.cpp				\
#		swizzler.cpp			\
#       lock.cpp                \
#       cubelock.cpp            \
#       volumelock.cpp          \


INCLUDES=$(SDK_INC_PATH); $(BASEDIR)\private\ntos\inc;\
         $(BASEDIR)\private\test\inc;..

USE_LIBCMT=1

TARGETLIBS= \
        $(BASEDIR)\private\test\lib\*\xlog.lib \
        $(LIBRARY_PATH)\d3d8$(D).lib \
        $(LIBRARY_PATH)\d3dx8$(D).lib
 

#        $(BASEDIR)\private\test\lib\*\xtestlib.lib \

PRECOMPILED_INCLUDE=..\d3dapi.hpp
PRECOMPILED_PCH=..\precomp.pch
PRECOMPILED_OBJ=..\precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\swiz.cpp ===
#include "d3dapi.hpp"
#include "xgraphics.h"

/*
optimized 2d swizzler & deswizzler

  Requirements: 
	src and dest buffers must be 16-byte aligned. 32-byte is prefered.
	Width of the texture must be >= 4.
	Height of the texture must be >= 2.

	If width == 1 or 2, or Height == 1, the texture looks the same swizzled or linear, so don't bother with these routines

  the bpp parameter is bytes-per-pixel of the texture (1, 2, or 4)
*/


typedef unsigned long DWORD;
#define min(a,b) (((a) < (b)) ? (a) : (b))

/*
inline DWORD Log2 (DWORD Value)
{
//    ASSERT((Value & (Value - 1)) == 0);
    __asm 
    {
        mov eax,[Value]   
        bsf ecx,eax 
		mov eax, ecx //return code is in eax
    }
}
*/

inline void GetMasks(int w, int h, DWORD* pXAnd, DWORD* pYAnd) 
{
	DWORD LogWidth, LogHeight, Log;

	LogWidth = Log2(w); 
	LogHeight = Log2(h);

	Log = min(LogWidth, LogHeight);

    DWORD LowerMask = (1 << (Log << 1)) - 1;
    DWORD UpperMask = ~LowerMask;

    DWORD XAnd = (LogWidth > LogHeight) ? (0x55555555 | UpperMask)
                                        : (0x55555555 & LowerMask);

    DWORD YAnd = (LogWidth < LogHeight) ? (0xaaaaaaaa | UpperMask)
                                        : (0xaaaaaaaa & LowerMask);

	XAnd &= ((1 << (LogWidth + LogHeight)) - 1); //we're letting u & v just loop, so
	YAnd &= ((1 << (LogWidth + LogHeight)) - 1); //we need to limit the bits to the ones we need.

	*pXAnd = XAnd;
	*pYAnd = YAnd;
}

/*
Original code:
to Swizzle:
	do { 
		do {
			dest[u | v] = *src++;
		} while(0 != (u = (u - UAnd) & UAnd));
	} while(0 != (v = (v - VAnd) & VAnd));

to UnSwizzle:
	do { 
		do {
			*dest++ = src[u | v];
		} while(0 != (u = (u - UAnd) & UAnd));
	} while(0 != (v = (v - VAnd) & VAnd));

*/
	

void unswiz2_8 (void* src, void*dest, int w, int h) 
{
	DWORD XAnd, YAnd, XAddVal, YAddVal;

	GetMasks(w, h, &XAnd, &YAnd);

	XAddVal = (-16) & XAnd;
	YAddVal = (-8) & YAnd;

	//eax = scratch
	//ebx = x
	//ecx = y
	//edx = pitch
	//esi = src (this is not changed)
	//edi = dest (this is incrimented)

	_asm {
		mov esi, src;
		mov edi, dest;

		mov edx, [w];
		xor ebx, ebx;
		xor ecx, ecx;

Start:
		//do {
		//	do {
		mov eax, ebx;
		or eax, ecx;
		movq mm0, [esi + eax];
		pshufw mm0, mm0, 11011000b; //swap mm0's Word1 and Word2
		sub ebx, [XAddVal];
		movd [edi], mm0;

		psrl mm0, 32;
		movd [edi + edx], mm0;

		add edi, 4;
		
			//} while (0 != (x = (x - XAddVal) & XAnd)));
		and ebx, [XAnd];
		jnz Start;

		//} while (0 != (y = (y - YAddVal) & Yand)));
		sub ecx, [YAddVal];

		add edi, edx; //move edi to the next row (which is actually 2 rows down where we just were)

		and ecx, [YAnd];
		jnz Start;

		emms; //we're done with emms stuff now...
	}
}

void unswiz2_16 (void* src, void*dest, int w, int h) 
{
	DWORD XAnd, YAnd, XAddVal, YAddVal;

	GetMasks(w, h, &XAnd, &YAnd);

	XAddVal = (-16) & XAnd;
	YAddVal = (-8) & YAnd;


	//eax = scratch
	//ebx = x
	//ecx = y
	//edx = pitch
	//esi = src (this is not changed)
	//edi = dest (this is incrimented)

	_asm {
		mov esi, src;
		mov edi, dest;

		mov edx, [w];
		xor ebx, ebx;
		xor ecx, ecx;
		add edx, edx; //shift [w], since we're doing 2-byte stuff now

Start:
		//do {
			//do {
		mov eax, ebx;
		or eax, ecx;
		movaps xmm0, [esi + eax*2];
		shufps xmm0, xmm0, 11011000b; //swap mm0's Word1 and Word2
		sub ebx, [XAddVal];
		movlps [edi], xmm0;

		movhps [edi + edx], xmm0;

		add edi, 8;
		
			//} while (0 != (x = (x - XAddVal) & XAnd)));
		and ebx, [XAnd];
		jnz Start;

		//} while (0 != (y = (y - YAddVal) & Yand)));
		sub ecx, [YAddVal];

		add edi, edx; //move edi to the next row (which is actually 2 rows down where we just were)

		and ecx, [YAnd];
		jnz Start;
	}
}

void unswiz2_32 (void* src, void*dest, int w, int h) 
{
	DWORD XAnd, YAnd, XAddVal, YAddVal;

	GetMasks(w, h, &XAnd, &YAnd);

	XAddVal = (-4) & XAnd;
	YAddVal = (-8) & YAnd;


	//eax = scratch
	//ebx = x
	//ecx = y
	//edx = pitch
	//esi = src (this is not changed)
	//edi = dest (this is incrimented)

	_asm {
		mov esi, src;
		mov edi, dest;

		mov edx, [w];
		xor ebx, ebx;
		xor ecx, ecx;
		shl edx, 2; //shift [w], since we're doing 4-byte stuff now

Start:
		//do {
			//do {
		mov eax, ebx;
		or eax, ecx;

		movaps xmm0, [esi+eax*4];		
		sub ebx, [XAddVal];

		movlps [edi], xmm0;
		movhps [edi + edx], xmm0;

		add edi, 8;
		
			//} while (0 != (x = (x - XAddVal) & XAnd)));
		and ebx, [XAnd];
		jnz Start;

		//} while (0 != (y = (y - YAddVal) & Yand)));
		sub ecx, [YAddVal];

		add edi, edx; //move edi to the next row (which is actually 2 rows from where we just were)

		and ecx, [YAnd];
		jnz Start;
	}
}




void swiz2_8 (void* src, void*dest, int w, int h) 
{
	DWORD XAnd, YAnd, XAddVal, YAddVal;

	GetMasks(w, h, &XAnd, &YAnd);

	XAddVal = (-16) & XAnd;
	YAddVal = (-8) & YAnd;


	//eax = scratch
	//ebx = x
	//ecx = y
	//edx = pitch
	//esi = src (this is incrimented)
	//edi = dest (this is not changed)

	_asm {
		mov esi, src;
		mov edi, dest;

		mov edx, [w];
		xor ebx, ebx;
		xor ecx, ecx;

Start:
		//do {
			//do {

		mov eax, ebx;
		movd mm0, [esi];
		or eax, ecx;
		punpcklwd mm0, [esi + edx]
		sub ebx, [XAddVal];

		movq [edi + eax], mm0;

		add esi, 4;
		
			//} while (0 != (x = (x - XAddVal) & XAnd)));
		and ebx, [XAnd];
		jnz Start;

		//} while (0 != (y = (y - YAddVal) & Yand)));
		sub ecx, [YAddVal];

		add esi, edx; //move esi to the next row (which is actually 2 rows down where we just were)

		and ecx, [YAnd];
		jnz Start;

		emms; //we're done with emms stuff now...
	}
}

void swiz2_16 (void* src, void*dest, int w, int h) 
{
	DWORD XAnd, YAnd, XAddVal, YAddVal;

	GetMasks(w, h, &XAnd, &YAnd);

	XAddVal = (-16) & XAnd;
	YAddVal = (-8) & YAnd;


	//eax = scratch
	//ebx = x
	//ecx = y
	//edx = pitch
	//esi = src (this is incrimented)
	//edi = dest (this is not changed)

	_asm {
		mov esi, src;
		mov edi, dest;

		mov edx, [w];
		xor ebx, ebx;
		xor ecx, ecx;
		add edx, edx; //shift [w], since we're doing 2-byte stuff now

Start:
		//do {
			//do {
				//dest[(u | v) + {0, 1, 2, 3}] = src[{0, 1, 4, 5}]
		mov eax, ebx;
		movlps xmm0, [esi];
		or eax, ecx;
		movlps xmm1, [esi + edx];  
		unpcklps xmm0, xmm1;  
		sub ebx, [XAddVal];

		movaps [edi + eax*2], xmm0

		add esi, 8;
		
			//} while (0 != (x = (x - XAddVal) & XAnd)));
		and ebx, [XAnd];
		jnz Start;

		//} while (0 != (y = (y - YAddVal) & Yand)));
		sub ecx, [YAddVal];

		add esi, edx; //move esi to the next row (which is actually 2 rows down where we just were)

		and ecx, [YAnd];
		jnz Start;
	}
}

void swiz2_32 (void* src, void*dest, int w, int h) 
{
	DWORD XAnd, YAnd, XAddVal, YAddVal;

	GetMasks(w, h, &XAnd, &YAnd);

	XAddVal = (-4) & XAnd;
	YAddVal = (-8) & YAnd;


	//eax = scratch
	//ebx = x
	//ecx = y
	//edx = pitch
	//esi = src (this is incrimented)
	//edi = dest (this is not changed)

	_asm {
		mov esi, src;
		mov edi, dest;

		mov edx, [w];
		xor ebx, ebx;
		xor ecx, ecx;
		shl edx, 2; //shift [w], since we're doing 4-byte stuff now

Start:
		//do {
			//do {
		mov eax, ebx;

		movlps xmm0, [esi];		

		or eax, ecx;

		movhps xmm0, [esi+edx];

		sub ebx, [XAddVal];

		movaps [edi + eax*4], xmm0;

		add esi, 8;
		
			//} while (0 != (x = (x - XAddVal) & XAnd)));
		and ebx, [XAnd];
		jnz Start;

		//} while (0 != (y = (y - YAddVal) & Yand)));
		sub ecx, [YAddVal];

		add esi, edx; //move src to the next row (which is actually 2 rows from where we just were)

		and ecx, [YAnd];
		jnz Start;
	}
}



void unswiz2 (void* src, void* dest, int bpp, int w, int h)
{
	switch(bpp) {
	case 1:
		unswiz2_8 (src, dest, w, h);
		break;
	case 2:
		unswiz2_16 (src, dest, w, h);
		break;
	case 4:
		unswiz2_32 (src, dest, w, h);
		break;
	default:
		_asm { int 3 };
	}
}

void swiz2 (void* src, void* dest, int bpp, int w, int h)
{
	switch(bpp) {
	case 1:
		swiz2_8 (src, dest, w, h);
		break;
	case 2:
		swiz2_16 (src, dest, w, h);
		break;
	case 4:
		swiz2_32 (src, dest, w, h);
		break;
	default:
		_asm { int 3 };
	}
}

LINKME(15)
#pragma data_seg(".d3dapi$test026") 

BEGINTEST(swiztest) 
{
	const int X=256;
	const int Y=256;
	const int times=16384;

	DWORD* BigSrc = new DWORD[X*Y*4+16];
	DWORD* BigDest = new DWORD[X*Y*4+16];
	DWORD* BigDest2 = new DWORD[X*Y*4+16];

	DWORD* src = (DWORD*)(((DWORD)BigSrc) & ~15);
	DWORD* dest = (DWORD*)(((DWORD)BigDest) & ~15);
	DWORD* dest2 = (DWORD*)(((DWORD)BigDest2) & ~15);
	
	__int64 Start, Finish, New, Old;

	int i;

//	__try {
		xStartVariation(hlog, "swiz 8bit");
		{
			for(i = 0; i < X*Y*4; i++) {
				((char*)src)[i] = (char)i;
				((char*)dest)[i]= (char)-i;
				((char*)dest2)[i]= (char)-i;
			}

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				swiz2(src, dest, 1, X, Y);
			}
			Finish = GetTsc();
			New = Finish - Start;

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				Swizzler_Swizzle2D(src, dest2, X, Y, 1);
			}
			Finish = GetTsc();
			Old = Finish - Start;

			xLog(hlog, XLL_INFO, "Old Time: %I64dms, New Time: %I64dms", Old / 733000, New / 733000);

			for(i = 0; i < X*Y; i++) {
				if(((char*)dest)[i] != ((char*)dest2)[i]) 
				{
					xLog(hlog, XLL_FAIL, "not equal. i=0x%x, dest=%x, dest2=%x", i, ((char*)dest)[i], ((char*)dest2)[i]); 
				}
			}

		}
		xEndVariation(hlog);
//	} __except(1) {
//		xLog(hlog, XLL_EXCEPTION, "blah!");
//		xEndVariation(hlog);
//	}
//	__try {
		xStartVariation(hlog, "swiz 16bit");
		{
			for(i = 0; i < X*Y*4; i++) {
				((char*)src)[i] = (char)i;
				((char*)dest)[i]= (char)-i;
				((char*)dest2)[i]= (char)-i;
			}

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				swiz2(src, dest, 2, X, Y);
			}
			Finish = GetTsc();
			New = Finish - Start;

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				Swizzler_Swizzle2D(src, dest2, X, Y, 2);
			}
			Finish = GetTsc();
			Old = Finish - Start;

			xLog(hlog, XLL_INFO, "Old Time: %I64dms, New Time: %I64dms", Old / 733000, New / 733000);

			for(i = 0; i < X*Y; i++) {
				if(((short*)dest)[i] != ((short*)dest2)[i]) 
				{
					xLog(hlog, XLL_FAIL, "not equal. i=0x%x, dest=%x, dest2=%x", i, ((short*)dest)[i], ((short*)dest2)[i]); 
				}
			}
		}
		xEndVariation(hlog);
//	} __except(1) {
//		xLog(hlog, XLL_EXCEPTION, "blah!");
//		xEndVariation(hlog);
//	}
//	__try {
		xStartVariation(hlog, "swiz 32bit");
		{
			for(i = 0; i < X*Y*4; i++) {
				((char*)src)[i] = (char)i;
				((char*)dest)[i]= (char)-i;
				((char*)dest2)[i]= (char)-i;
			}

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				swiz2(src, dest, 4, X, Y);
			}
			Finish = GetTsc();
			New = Finish - Start;

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				Swizzler_Swizzle2D(src, dest2, X, Y, 4);
			}
			Finish = GetTsc();
			Old = Finish - Start;

			xLog(hlog, XLL_INFO, "Old Time: %I64dms, New Time: %I64dms", Old / 733000, New / 733000);

			for(i = 0; i < X*Y; i++) {
				if(dest[i] != dest2[i]) 
				{
					xLog(hlog, XLL_FAIL, "not equal. i=0x%x, dest=%x, dest2=%x", i, dest[i], dest2[i]); 
				}
			}
		}
		xEndVariation(hlog);

//	} __except(1) {
//		xLog(hlog, XLL_EXCEPTION, "blah!");
//		xEndVariation(hlog);
//	}
//	__try {

		xStartVariation(hlog, "unswiz 8bit");
		{
			for(i = 0; i < X*Y*4; i++) {
				((char*)src)[i] = (char)i;
				((char*)dest)[i]= (char)-i;
				((char*)dest2)[i]= (char)-i;
			}

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				unswiz2(src, dest, 1, X, Y);
			}
			Finish = GetTsc();
			New = Finish - Start;

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				Swizzler_Unswizzle2D(src, dest2, X, Y, 1);
			}
			Finish = GetTsc();
			Old = Finish - Start;

			xLog(hlog, XLL_INFO, "Old Time: %I64dms, New Time: %I64dms", Old / 733000, New / 733000);

			for(i = 0; i < X*Y; i++) {
				if(((char*)dest)[i] != ((char*)dest2)[i]) 
				{
					xLog(hlog, XLL_FAIL, "not equal. i=0x%x, dest=%x, dest2=%x", i, ((char*)dest)[i], ((char*)dest2)[i]); 
				}
			}
		}
		xEndVariation(hlog);
//	} __except(1) {
//		xLog(hlog, XLL_EXCEPTION, "blah!");
//		xEndVariation(hlog);
//	}
//	__try {
		xStartVariation(hlog, "unswiz 16bit");
		{
			for(i = 0; i < X*Y*4; i++) {
				((char*)src)[i] = (char)i;
				((char*)dest)[i]= (char)-i;
				((char*)dest2)[i]= (char)-i;
			}

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				unswiz2(src, dest, 2, X, Y);
			}
			Finish = GetTsc();
			New = Finish - Start;

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				Swizzler_Unswizzle2D(src, dest2, X, Y, 2);
			}
			Finish = GetTsc();
			Old = Finish - Start;

			xLog(hlog, XLL_INFO, "Old Time: %I64dms, New Time: %I64dms", Old / 733000, New / 733000);

			for(i = 0; i < X*Y; i++) {
				if(((short*)dest)[i] != ((short*)dest2)[i]) 
				{
					xLog(hlog, XLL_FAIL, "not equal. i=0x%x, dest=%x, dest2=%x", i, ((short*)dest)[i], ((short*)dest2)[i]); 
				}
			}
		}
		xEndVariation(hlog);
//	} __except(1) {
//		xLog(hlog, XLL_EXCEPTION, "blah!");
//		xEndVariation(hlog);
//	}
//	__try {
		xStartVariation(hlog, "unswiz 32bit");
		{
			for(i = 0; i < X*Y*4; i++) {
				((char*)src)[i] = (char)i;
				((char*)dest)[i]= (char)-i;
				((char*)dest2)[i]= (char)-i;
			}

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				unswiz2(src, dest, 4, X, Y);
			}
			Finish = GetTsc();
			New = Finish - Start;

			Start = GetTsc();
			for(i = 0; i < times; i++) {
				Swizzler_Unswizzle2D(src, dest2, X, Y, 4);
			}
			Finish = GetTsc();
			Old = Finish - Start;

			xLog(hlog, XLL_INFO, "Old Time: %I64dms, New Time: %I64dms", Old / 733000, New / 733000);

			for(i = 0; i < X*Y; i++) {
				if(dest[i] != dest2[i]) 
				{
					xLog(hlog, XLL_FAIL, "not equal. i=0x%x, dest=%x, dest2=%x", i, dest[i], dest2[i]); 
				}
			}
		}
		xEndVariation(hlog);
//	} __except(1) { 
//		xLog(hlog, XLL_EXCEPTION, "blah!");
//		xEndVariation(hlog);
//	}

} 
ENDTEST()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\swizzler.h ===
#pragma once

#pragma warning(disable:4035)


/******************************************************************************
class SWIZZLER:
by Jason Gould (JGould)
last modified 18 oct 2000

Purpose: to allow simple manipulations of a swizzled texture, without the 
hassle or overhead of unswizzling the whole thing in order to tweak a few 
points on the texture. This works with texture maps, cube maps, and volume maps.

Depending on your purpose in messing with a swizzled texture, certain 
optimizations can be performed by doing things a little differently than are
done here.

Notes: 
  Most of the time when messing with a texture map, you will be incrementing 
  through it by a constant value in each dimension. In order to speed up this
  process considerably, those deltas are converted to an intermediate value
  (via the Convert(num, dim) method), which can be used to quickly increment
  or change a particular dimension.

  In all methods, the variable dim is used to specify the dimension being
  manipulated. For x (or u), use UCOORD. For y (or v), use VCOORD. For z (or 
  s?), use SCOORD.

  The type SWIZNUM is used to represent numbers returned by Convert(), also
  known as "intermediate values" in this documentation.

  Code in comments, like /* & m_and[dim] */  /* may be uncommented in order
  to provide some sort of parameter sanity. (It assures that any number 
  passed to num will only alter the dimension specified by dim)

Elements:
  m_index -- the index into the swizzled texture at the most recent (x,y,z)
    coordinates specified
  
  m_loc[] -- [UCOORD] = texture map (converted) u coordinate
  m_loc[] -- [VCOORD] = texture map (converted) v coordinate
  m_loc[] -- [SCOORD] = texture map (converted) s coordinate

  m_and[] -- [UCOORD] = internal mask for u coordinate
  m_and[] -- [VCOORD] = internal mask for v coordinate
  m_and[] -- [SCOORD] = internal mask for s coordinate

Methods:
  SWIZNUM Convert(num, dim) -- converts num to an intermediate value that can 
    be used to alter a coordinate of the dimension dim
  void Unconvert(index, dim) -- takes an index to the swizzled texture, and 
    returns the unswizzled coordinate of dimension dim
  void Set (num, dim) -- sets the coordinate of dimension dim to num, where
    num is an intermediate value returned by Convert
  void Add (num, dim) -- adds num to the coordinate of dimension dim, where
    num is an intermediate value returned by Convert
  void Sub (num, dim) -- subtracts num from the coordinate of dimension dim, 
	where num is an intermediate value returned by Convert
  void Inc (dim) -- increments the coordinate of dimension dim by 1
  void Dec (dim) -- decrements the coordinate of dimension dim by 1
  SWIZNUM Get2() -- returns the index to the swizzled standard or cube texture, 
    based on the current texture coordinates specified by the previous 5 
	methods
  SWIZNUM Get3() -- returns the index to the swizzled volume texture, based 
    on the current texture coordinates specified by the previous 5 methods
  void Swizzle2d(Dest, Src) -- Swizzles/unswizzles a 2d texture from Src to 
    Dest.
  void Swizzle3d(Dest, Src) -- Swizzles/unswizzles a volume texture from Src 
    to Dest.

Optimizations:
  Subtraction is used so that only ANDing is necessary (no ORing, as in other
  methods). For this reason, the Sub method is faster than the Add method.
  Inc and Dec are roughly the same speed, because Dec requires a shift, but
  Inc requires accessing an array.
  
  It may be better to have Convert() convert the negative of the value 
  specified, and then to reverse the roles of Add and Sub. That would make the 
  more logical manuvering routine (Add) the faster of the two.

  Arrays could probably also be removed, replacing Add() with AddU, AddV, and 
  AddS methods, in order to remove one layer of pointer dereferencing.
******************************************************************************/

#define UCOORD 0
#define VCOORD 1
#define SCOORD 2

//type returned by Convert, to be used in all other methods
typedef unsigned long DWORD;

typedef DWORD SWIZNUM; 

typedef enum {
    SWIZZLE,
    UNSWIZZLE
} WHICHSWIZ;

class SWIZZLER {
public: //private:
	DWORD m_loc[3]; //location (0 == x, 1 == y, 2 == z)
	//ORing is not needed if we use the subtraction method
	DWORD m_and[3]; //ANDer (0 == x, 1 == y, 2 == z)
	DWORD m_size[3];//size (used in swizzling/unswizzling)
	DWORD m_index;
public:
	SWIZZLER(DWORD width, DWORD height, DWORD depth) : m_index(0)
	{ 
		m_loc[UCOORD] = 0; m_loc[VCOORD] = 0; m_loc[SCOORD] = 0;
		m_and[UCOORD] = 0; m_and[VCOORD] = 0; m_and[SCOORD] = 0;

		m_size[UCOORD] = width; m_size[VCOORD] = height; m_size[SCOORD] = depth;

		DWORD i = 1;
		DWORD j = 1;
		DWORD l;
		DWORD k;
		do {
			k = 0;
			for(l = 0; l < 3; l++) {
				if(i < m_size[l]) {
					m_and[l] |= j;
					k = (j <<= 1);
				}
			}
			i <<= 1;
		} while (k);
	}
	
	__forceinline SWIZNUM Convert(DWORD num, int dim) //num == in, dim == dimension (0 for x, 1 for y, 2 for z)
	{
		DWORD i;
		SWIZNUM r = 0; //result
		for(i = 1; i <= m_and[dim]; i <<= 1) {
			if(m_and[dim] & i) {
				r |= (num & i);
			} else {
				num <<= 1;
			}
		}
		return r;
	}
	SWIZNUM Convert(DWORD x, DWORD y, DWORD z)
	{
		return Convert(x, UCOORD) | Convert(y, VCOORD) | Convert(z, SCOORD);
	}

	__forceinline DWORD Unconvert(SWIZNUM num, int dim) //num == in, dim == dimension
	{
		DWORD i;
		DWORD j;
		DWORD r = 0; //result
		for(i = 1, j = 1; i; i <<= 1) {
			if(m_and[dim] & i) {
				r |= (num & j);
				j <<= 1;
			} else {
				num >>= 1;
			}
		}
		return r;
	}

	__forceinline void Set0()
	{
		m_loc[0] = m_loc[1] = m_loc[2] = 0;
	}
	__forceinline void Set(SWIZNUM x, SWIZNUM y, SWIZNUM z) 
	{
		m_loc[UCOORD] = x; m_loc[VCOORD] = y; m_loc[SCOORD] = z;
	}
	__forceinline void Set(SWIZNUM num, int dim)
	{
		m_loc[dim] = num /* & m_and[dim] */;
	}
	__forceinline void Add(SWIZNUM num, int dim)
	{
		m_loc[dim] = (m_loc[dim] - ((0-num) & m_and[dim])) & m_and[dim];
	}
	__forceinline void Sub(SWIZNUM num, int dim)
	{
		m_loc[dim] = (m_loc[dim] - num /* & m_and[dim] */) & m_and[dim];
	}
	__forceinline DWORD Inc(int dim)
	{
		return m_loc[dim] = (m_loc[dim] - m_and[dim]) & m_and[dim];
	}
	__forceinline void Dec(int dim)
	{
		m_loc[dim] = (m_loc[dim] - 1) & m_and[dim];
	}
	__forceinline SWIZNUM Get2()
	{
		return m_index = m_loc[UCOORD] | m_loc[VCOORD];
	}
	__forceinline SWIZNUM Get3()
	{
		return m_index = m_loc[UCOORD] | m_loc[VCOORD] | m_loc[SCOORD];
	}
	SWIZZLER(){}
};

template <class TYPE>
class SWIZZLER2 : SWIZZLER
{
public:
	SWIZZLER2(DWORD width, DWORD height, DWORD depth) : SWIZZLER(width, height, depth) {}


	/* 
		note! Pass a TYPE that is 2* the size of the actual byte type, for doing FastSwizzle & FastUnswizzle!
		For instance, if the texture is 8 bit, pass WORD instead. 
		If the texture is 16-bit, use DWORD. 
		For 32-bit, use __int64 or QWORD.
	*/
	void FastSwizzle2d(TYPE* Src, TYPE* Dest)
	{
		int s = 0, u = 0, v = 0;
		int uand = m_And[UCOORD] >> 1,
			vand = m_And[VCOORD] >> 1;

		do {
			do {
				Dest[u | v] = *Src++;
			} while (0 != (u = (u - uand) & uand));
		} while (0 != (v = (v - vand) & vand));
	}
	void FastSwizzle3d(TYPE* Src, TYPE* Dest)
	{
		int s = 0, u = 0, v = 0;
		int sand = m_And[SCOORD] >> 1,
			uand = m_And[UCOORD] >> 1,
			vand = m_And[VCOORD] >> 1;

		do {
			do {
				do {
					Dest[u | v | s] = *Src++;
				} while (0 != (u = (u - uand) & uand));
			} while (0 != (v = (v - vand) & vand));
		} while (0 != (s = (s - sand) & sand));
	}

	void FastUnswizzle2d(TYPE* Src, TYPE* Dest)
	{
		int s = 0, u = 0, v = 0;
		int uand = m_And[UCOORD] >> 1,
			vand = m_And[VCOORD] >> 1;

		do {
			do {
				*Dest++ = Src[u | v];
			} while (0 != (u = (u - uand) & uand));
		} while (0 != (v = (v - vand) & vand));
	}
	void FastUnswizzle3d(TYPE* Src, TYPE* Dest)
	{
		int s = 0, u = 0, v = 0;
		int sand = m_And[SCOORD] >> 1,
			uand = m_And[UCOORD] >> 1,
			vand = m_And[VCOORD] >> 1;

		do {
			do {
				do {
					*Dest++ = Src[u | v | s];
				} while (0 != (u = (u - uand) & uand));
			} while (0 != (v = (v - vand) & vand));
		} while (0 != (s = (s - sand) & sand));
	}


	void Swizzle2d(TYPE *Src, TYPE* Dest)
	{ 		
		Set0();
		do {
			do {
				Dest[Get2()] = *Src++;
			} while (Inc(UCOORD));
		} while (Inc(VCOORD));
	}
	void Unswizzle2d(TYPE *Src, TYPE* Dest)
	{
		Set0();
		do {
			do {
				*Dest++ = Src[Get2()];
			} while (Inc(UCOORD));
		} while (Inc(VCOORD));
	}

	void Swizzle3d(TYPE *Src, TYPE* Dest)
	{
		Set0();
		do {
			do {
				do {
					Dest[Get3()] = *Src++;
				} while (Inc(UCOORD));
			} while (Inc(VCOORD));
		} while (Inc(SCOORD));
	}
	void Unswizzle3d(TYPE *Src, TYPE* Dest)
	{
		Set0();
		do {
			do {
				do {
					*Dest++ = Src[Get3()];
				} while (Inc(UCOORD));
			} while (Inc(VCOORD));
		} while (Inc(SCOORD));
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\vertexbuffer.cpp ===
#include "d3dapi.hpp"
/*
D3DVertexBuffer_AddRef(D3DVertexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DVertexBuffer_Release(D3DVertexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
//D3DVertexBuffer_GetDevice(D3DVertexBuffer *pThis, D3DDevice **ppDevice) { return D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
//D3DVertexBuffer_GetType(D3DVertexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DVertexBuffer_IsBusy(D3DVertexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DVertexBuffer_MoveResourceMemory(D3DVertexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DVertexBuffer_Register(D3DVertexBuffer *pThis) { D3DResource_Register((D3DResource *)pThis); }
D3DVertexBuffer_Deregister(D3DVertexBuffer *pThis) { D3DResource_Deregister((D3DResource *)pThis); }
D3DVertexBuffer_SetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DVertexBuffer_GetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DVertexBuffer_FreePrivateData(D3DVertexBuffer *pThis, REFGUID refguid) { return D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }
HRESULT WINAPI D3DVertexBuffer_Lock(D3DVertexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
HRESULT WINAPI D3DVertexBuffer_Unlock(D3DVertexBuffer *pThis);
//HRESULT WINAPI D3DVertexBuffer_GetDesc(D3DVertexBuffer *pThis, D3DVERTEXBUFFER_DESC *pDesc);
*/
LINKME(13);

#pragma data_seg(".d3dapi$test030") 

BEGINTEST(testCreateVertexBuffer)
{
	//this is just a call to a Mm allocation routine... 
	//doesn't require a huge amount of testing.
	D3DVertexBuffer * blah;
	DWORD hr;
	int i;

	xStartVariation(hlog, "allocate vbs");
	{
		for(i = 0; i <= 25; i++) {
			xLog(hlog, XLL_INFO, "size: %d", (1 << i));
			hr = g_pd3dd8->CreateVertexBuffer((1 << i), 0,0,(D3DPOOL)0, &blah);
			CHECKRESULT(hr == D3D_OK);
			CHECKRESULT(blah != 0);
			if(WASGOODRESULT()) {
				hr = blah->Release();
				CHECKRESULT(hr == 0);
			}
		}
	}
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testVbGetType)
{
	D3DVertexBuffer * blah;
	DWORD hr;

	xStartVariation(hlog, "gettype");
	{
		hr = g_pd3dd8->CreateVertexBuffer(23,0,0,0,&blah);
		CHECKRESULT(hr == D3D_OK);
		hr = blah->GetType();
		CHECKRESULT(hr == D3DRTYPE_VERTEXBUFFER);
	}
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testVbGetDesc)
{
	D3DVertexBuffer * blah;
	DWORD hr;
	D3DVERTEXBUFFER_DESC d;

	xStartVariation(hlog, "getdesc");
	{
		hr = g_pd3dd8->CreateVertexBuffer(23,0,0,0,&blah);
		CHECKRESULT(hr == D3D_OK);
		hr = blah->GetDesc(&d);
		CHECKRESULT(hr == D3D_OK);
		CHECKRESULT(d.Format == D3DFMT_VERTEXDATA);
		CHECKRESULT(d.Type == D3DRTYPE_VERTEXBUFFER);
		hr = blah->Release();
		CHECKRESULT(hr == 0);
	}
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testVbGetDevice)
{
	D3DVertexBuffer * blah;
	DWORD hr;
	D3DDevice* d;

	xStartVariation(hlog, "getdevice");
	{
		hr = g_pd3dd8->CreateVertexBuffer(23,0,0,0,&blah);
		CHECKRESULT(hr == D3D_OK);
		if(WASGOODRESULT()) {
			hr = blah->GetDevice(&d);
			CHECKRESULT(hr == D3D_OK);
			CHECKRESULT(d == g_pd3dd8);
			d->Release();
			hr = blah->Release();
			CHECKRESULT(hr == 0);
		}
	}
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testVbLockUnlock)
{
	D3DVertexBuffer * blah;
	DWORD hr;

	BYTE* pb[3];

	xStartVariation(hlog, "Init");
	{
		hr = g_pd3dd8->CreateVertexBuffer(100,0,0,0,&blah);
		CHECKRESULT(hr == D3D_OK);
		if(WASGOODRESULT()) {
			xEndVariation(hlog);
			xStartVariation(hlog, "Multiple Read-Only");
			{
				if(WASGOODRESULT()) {
					hr = blah->Lock(0, 0, &pb[0], 0);
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Lock(0, 0, &pb[1], D3DLOCK_READONLY);
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Lock(25, 1, &pb[2], D3DLOCK_READONLY);

					CHECKRESULT(hr == D3D_OK);
					CHECKRESULT(pb[0] == pb[1]);
					CHECKRESULT(pb[2] == pb[0] + 25);

					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
				}
			}
			xEndVariation(hlog);
			xStartVariation(hlog, "Multiple locks");
			{
				hr = g_pd3dd8->CreateVertexBuffer(100,0,0,0,&blah);
				CHECKRESULT(hr == D3D_OK);
				if(WASGOODRESULT()) {
					hr = blah->Lock(0, 0, &pb[0], 0);
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Lock(0, 0, &pb[1], 0);
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Lock(25, 1, &pb[2], 0);

					CHECKRESULT(hr == D3D_OK);
					CHECKRESULT(pb[0] == pb[1]);
					CHECKRESULT(pb[2] == pb[0] + 25);

					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
				}
			}
		}
	}
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testVbUma)
{
	D3DVertexBuffer * blah;
	DWORD hr;

	BYTE* pb[3];

	xStartVariation(hlog, "Init");
	{
		hr = g_pd3dd8->CreateVertexBuffer(2052,0,0,0,&blah);
		CHECKRESULT(hr == D3D_OK);
		if(WASGOODRESULT()) {
			xEndVariation(hlog);
			xStartVariation(hlog, "Multiple Read-Only");
			{
				if(WASGOODRESULT()) {
					hr = blah->Lock(0, 0, &pb[0], 0);
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Lock(0, 0, &pb[1], D3DLOCK_READONLY);
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Lock(25, 1, &pb[2], D3DLOCK_READONLY);

					CHECKRESULT(hr == D3D_OK);
					CHECKRESULT(pb[0] == pb[1]);
					CHECKRESULT(pb[2] == pb[0] + 25);

					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
				}
			}
			xEndVariation(hlog);
			xStartVariation(hlog, "Multiple locks");
			{
				hr = g_pd3dd8->CreateVertexBuffer(100,0,0,0,&blah);
				CHECKRESULT(hr == D3D_OK);
				if(WASGOODRESULT()) {
					hr = blah->Lock(0, 0, &pb[0], 0);
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Lock(0, 0, &pb[1], 0);
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Lock(25, 1, &pb[2], 0);

					CHECKRESULT(hr == D3D_OK);
					CHECKRESULT(pb[0] == pb[1]);
					CHECKRESULT(pb[2] == pb[0] + 25);

					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
					hr = blah->Unlock();
					CHECKRESULT(hr == D3D_OK);
				}
			}
		}
	}
	xEndVariation(hlog);
}
ENDTEST()

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\volume.cpp ===
#include "d3dapi.hpp"
LINKME(3)

#ifndef ROUNDUP
#	define ROUNDUP(a,b)    ((((a)+(b)-1)/(b))*(b))
#endif

/*
static __inline ULONG   WINAPI IDirect3DVolume8_AddRef(IDirect3DVolume8 *pThis) { return IDirect3DResource8_AddRef((IDirect3DResource8 *)pThis); }
static __inline ULONG   WINAPI IDirect3DVolume8_Release(IDirect3DVolume8 *pThis) { return IDirect3DResource8_Release((IDirect3DResource8 *)pThis); }
//static __inline HRESULT WINAPI IDirect3DVolume8_GetDevice(IDirect3DVolume8 *pThis, IDirect3DDevice8 **ppDevice) { return IDirect3DResource8_GetDevice((IDirect3DResource8 *)pThis, ppDevice); }
//static __inline D3DRESOURCETYPE WINAPI IDirect3DVolume8_GetType(IDirect3DVolume8 *pThis) { return IDirect3DResource8_GetType((IDirect3DResource8 *)pThis); }
static __inline BOOLEAN WINAPI IDirect3DVolume8_IsBusy(IDirect3DVolume8 *pThis) { return IDirect3DResource8_IsBusy((IDirect3DResource8 *)pThis); }
static __inline VOID    WINAPI IDirect3DVolume8_MoveResourceMemory(IDirect3DVolume8 *pThis, D3DMEMORY where) { IDirect3DResource8_MoveResourceMemory((IDirect3DResource8 *)pThis, where); }
static __inline HRESULT WINAPI IDirect3DVolume8_SetPrivateData(IDirect3DVolume8 *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return IDirect3DResource8_SetPrivateData((IDirect3DResource8 *)pThis, refguid, pData, SizeOfData, Flags); }
static __inline HRESULT WINAPI IDirect3DVolume8_GetPrivateData(IDirect3DVolume8 *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return IDirect3DResource8_GetPrivateData((IDirect3DResource8 *)pThis, refguid, pData, pSizeOfData); }
static __inline HRESULT WINAPI IDirect3DVolume8_FreePrivateData(IDirect3DVolume8 *pThis, REFGUID refguid) { return IDirect3DResource8_FreePrivateData((IDirect3DResource8 *)pThis, refguid); }

//HRESULT WINAPI IDirect3DVolume8_GetContainer(IDirect3DVolume8 *pThis, IDirect3DBaseTexture8 **ppBaseTexture);
//HRESULT WINAPI IDirect3DVolume8_GetDesc(IDirect3DVolume8 *pThis, D3DVOLUME_DESC *pDesc);
//HRESULT WINAPI IDirect3DVolume8_LockBox(IDirect3DVolume8 *pThis, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
//HRESULT WINAPI IDirect3DVolume8_UnlockBox(IDirect3DVolume8 *pThis);
*/


struct VSTUFF {
	int width;
	int height;
	int depth;
	D3DFORMAT f;
	int count;
	int bitdepth;
} vstuff[] = {
	{  64,  64,  64, D3DFMT_A8R8G8B8,  7, 32},
	{   4,   4,   4, D3DFMT_DXT1,      0,  4},
	{ 128, 128, 128, D3DFMT_R5G6B5,    4, 16},
	{  32, 128, 256, D3DFMT_A8R8G8B8,  2, 32},
	{   1,  64,  64, D3DFMT_A8R8G8B8,  7, 32},
	{  64,   1,  64, D3DFMT_A8R8G8B8,  7, 32},
	{  64,  64,   1, D3DFMT_A8R8G8B8,  7, 32},
};

#pragma data_seg(".d3dapi$test220") 


bool IsSwizzledD3DFORMAT(D3DFORMAT Format){
switch (Format)
{
case D3DFMT_A8R8G8B8:
case D3DFMT_R5G6B5:
case D3DFMT_A8:
return true;
case D3DFMT_DXT1:
case D3DFMT_LIN_A8R8G8B8:
case D3DFMT_LIN_R5G6B5:
case D3DFMT_LIN_A8:
return false;
default:
_asm {int 3};
}
}
namespace D3D {
//bool IsSwizzledD3DFORMAT(D3DFORMAT Format);
bool IsCompressedD3DFORMAT(D3DFORMAT Format);
}


BEGINTEST(testCreateVolume)
{
	DWORD hr;
	IDirect3DVolumeTexture8* t;
	IDirect3DVolume8* s;
	D3DVOLUME_DESC dd;
	int i; 
	unsigned int j;
	UINT w, h, d, w4,h4;

	xStartVariation(hlog, "VT::GetVolumeLevel");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(vstuff); i++) {
		hr = g_pd3dd8->CreateVolumeTexture(vstuff[i].width, vstuff[i].height, vstuff[i].depth, vstuff[i].count, 0, vstuff[i].f, D3DPOOL_DEFAULT, &t);
		w = vstuff[i].width; 
		h = vstuff[i].height;
		d = vstuff[i].depth;
		CHECKRESULT(hr == D3D_OK);
		for(j = 0; j < t->GetLevelCount(); j++) {
			t->GetVolumeLevel(j, &s);
			s->GetDesc(&dd);
			if(vstuff[i].f == D3DFMT_DXT1 || vstuff[i].f == D3DFMT_DXT2 || vstuff[i].f == D3DFMT_DXT4) {
				if(w < 4) w4 = 4; else w4 = w;
				if(h < 4) h4 = 4; else h4 = h;
            } else if (!IsSwizzledD3DFORMAT(vstuff[i].f)) {
				w4 = ROUNDUP(w, D3DTEXTURE_PITCH_MIN * 8 / vstuff[i].bitdepth);
				h4 = h;
			} else {
				w4 = w;
				h4 = h;
			}

			CHECKRESULT(dd.Size == w4 * h4 * d * vstuff[i].bitdepth / 8);
			CHECKRESULT(dd.Format == vstuff[i].f);
			w = (w >> 1) ? (w >> 1) : 1;
			h = (h >> 1) ? (h >> 1) : 1;
			d = (d >> 1) ? (d >> 1) : 1;
			hr = s->Release();
			CHECKRESULT(hr == 0);
		}
		CHECKRESULT(t->Release() == 0);
	}
	CHECKRESULT(dd.Type == D3DRTYPE_VOLUME);
	CHECKLEAKS();
	xEndVariation(hlog);

}
ENDTEST()

BEGINTEST(testVolumeGetContainer)
{
	DWORD hr;
	IDirect3DVolumeTexture8* t;
	IDirect3DVolume8* s;
	IDirect3DBaseTexture8* b;
	IDirect3DDevice8* de;
	int i;
	unsigned int j;
	UINT w, h, d;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(vstuff); i++) {
		hr = g_pd3dd8->CreateVolumeTexture(vstuff[i].width, vstuff[i].height, vstuff[i].depth, vstuff[i].count, 0, vstuff[i].f, D3DPOOL_DEFAULT, &t);
		w = vstuff[i].width; 
		h = vstuff[i].height;
		d = vstuff[i].depth;
		CHECKRESULT(hr == D3D_OK);
		for(j = 0; (j < t->GetLevelCount()); j++) {
			t->GetVolumeLevel(j, &s);
			s->GetContainer(&b);
			CHECKRESULT((void*)b == (void*)t);
			s->GetDevice(&de);
			CHECKRESULT(de == g_pd3dd8);
			de->Release();
			CHECKRESULT(D3DRTYPE_VOLUME == s->GetType());
			hr = s->Release();
			CHECKRESULT(hr == 0);
			hr = b->Release();
			CHECKRESULT(hr == 1);
		}
		CHECKRESULT(t->Release() == 0);
	}
//	CHECKRESULT(dd.Type == D3DRTYPE_VOLUMETEXTURE);
	CHECKLEAKS();
	xEndVariation(hlog);

}
ENDTEST()

/*
BEGINTEST(testVolumeGetDevice)
{
//see above
}
ENDTEST()
*/

/*
//see volumelock.cpp

BEGINTEST(testVolumeLockUnlock)
{
//create volume texture (width = x, height = y, depth = z, levels = l, format = f)
//grab random level from it
//getvolumelevel (that level)
//release that volume level
//lock (RAW)
//grab that volume level again
//set pixels in locked level
//unlock locked level
//lock volume level (unswizzled)
//check pixels
//write a few pixels
//unlock volume level
//lock texture (unswizzled)
//check for pixels
//unlock it
//release everything
	DWORD hr;
	IDirect3DVolumeTexture8* t;
	IDirect3DVolume8* s;
	IDirect3DBaseTexture8* b;
	IDirect3DDevice8* de;
	D3DVOLUME_DESC dd;
	int i;
	unsigned int j;
	UINT w, h, d;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(vstuff); i++) {
		hr = g_pd3dd8->CreateVolumeTexture(vstuff[i].width, vstuff[i].height, vstuff[i].depth, vstuff[i].count, 0, vstuff[i].f, D3DPOOL_DEFAULT, &t);
		w = vstuff[i].width; 
		h = vstuff[i].height;
		d = vstuff[i].depth;
		CHECKRESULT(hr == D3D_OK);
		hr = t->Release();
		CHECKRESULT(hr == 0);

	}

}
ENDTEST()
*/
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\volumelock.cpp ===
#include "d3dapi.hpp"

LINKME(12);
typedef struct {
	int texnum1;
	int layer1;
	bool doraw1;
	int texnum2;
	int layer2;
	bool doraw2;
} VOLUMELOCKTESTSTRUCT;

namespace d3dapi {
class VTEX {
public:
	D3DVolumeTexture* m_t;

	VTEX():m_t(0), m_pLast(0) {}

	bool Init(int width, int height, int depth, int levels, D3DFORMAT format)
	{
		m_w = width; m_h = height; m_d = depth; m_l = levels; m_f = format;
		DWORD hr;
		hr = g_pd3dd8->CreateVolumeTexture(m_w,m_h,m_d,m_l,0,m_f,D3DPOOL_DEFAULT, &m_t);
		if(hr != D3D_OK) {
			xLog(hlog, XLL_FAIL, "VTEX: create volume texture, w%d h%d d%d l%d f%d", m_w, m_h, m_d, m_l, m_f);
			return false;
		}
		m_pLast = new DWORD[m_l];
		if(!m_pLast) { 
			xLog(hlog, XLL_FAIL, "VTEX: couldn't create dword array, size %d", m_l); 
			return false; 
		}
		m_bpp = D3D::BitsPerPixelOfD3DFORMAT(format);

		return true;
	}

	~VTEX() {
		Release();
	}
	bool Release() {
		DWORD hr;
		if(m_t) {
			hr = m_t->Release();
			xLog(hlog, (hr == 0) ? XLL_PASS : XLL_FAIL, "VTEX: release volume texture: %d", hr);
			m_t = 0;
		}
		if(m_pLast) {
			delete[] m_pLast;
			m_pLast = 0;
		}
		return true;
	}

	void Set(int layer, bool raw, D3DLOCKED_BOX* pr) {  
		int r;
		DWORD col;
		int x, y, z;
		int w = max(m_w >> layer, 1);
		int h = max(m_h >> layer, 1);
		int d = max(m_d >> layer, 1);

		if(layer < 0 || layer >= m_l) _asm {int 3};
		if(!m_t || !m_pLast) _asm {int 3};
		m_pLast[layer] = rnd();
		r = m_pLast[layer];							//store the random number so we can check the location later
		col = (r + (r << 14) + (r << 27)) >> (32 - m_bpp);
		x = (r + (r << 14) + (r << 27)) & (w - 1);
		y = (r + (r << 14) + (r << 27)) / (w);
		z = (r + (r << 14) + (r << 27)) / (w * h); 
		SetPoint((x + 0) & (w - 1), (y + 0) & (h - 1), (z + 0) & (d - 1), layer, col, raw, pr);  //draw 5 points to a random location
		SetPoint((x + 1) & (w - 1), (y + 0) & (h - 1), (z + 0) & (d - 1), layer, col, raw, pr);  //draw 5 points to a random location
		SetPoint((x + 0) & (w - 1), (y + 1) & (h - 1), (z + 0) & (d - 1), layer, col, raw, pr);  //draw 5 points to a random location
		SetPoint((x + 0) & (w - 1), (y + 0) & (h - 1), (z + 1) & (d - 1), layer, col, raw, pr);  //draw 5 points to a random location
		SetPoint((x - 1) & (w - 1), (y + 0) & (h - 1), (z + 0) & (d - 1), layer, col, raw, pr);  //draw 5 points to a random location
		SetPoint((x + 0) & (w - 1), (y - 1) & (h - 1), (z + 0) & (d - 1), layer, col, raw, pr);  //draw 5 points to a random location
		SetPoint((x + 0) & (w - 1), (y + 0) & (h - 1), (z - 1) & (d - 1), layer, col, raw, pr);  //draw 5 points to a random location
		SetPoint(w - 1, h - 1, d - 1, layer, col, raw, pr);						  //draw to first pixel & last pixel
		SetPoint(0, 0, 0, layer, col, raw, pr);
	}

	bool Check(int layer, bool raw, D3DLOCKED_BOX* pr) 
	{
		int r;
		DWORD col;
		int x, y, z;
		int w = max(m_w >> layer, 1);
		int h = max(m_h >> layer, 1);
		int d = max(m_d >> layer, 1);

		if(layer < 0 || layer >= m_l) _asm {int 3};
		if(!m_t || !m_pLast) _asm {int 3};

		r = m_pLast[layer];	//get the random number from last time
		col = (r + (r << 14) + (r << 27)) >> (32 - m_bpp);
		x = (r + (r << 14) + (r << 27)) & (w - 1);
		y = (r + (r << 14) + (r << 27)) / (w);
		z = (r + (r << 14) + (r << 27)) / (w * h); 
		if(!GetPoint((x + 0) & (w - 1), (y + 0) & (h - 1), (z + 0) & (d - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 1) & (w - 1), (y + 0) & (h - 1), (z + 0) & (d - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 0) & (w - 1), (y + 1) & (h - 1), (z + 0) & (d - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 0) & (w - 1), (y + 0) & (h - 1), (z + 1) & (d - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x - 1) & (w - 1), (y + 0) & (h - 1), (z + 0) & (d - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 0) & (w - 1), (y - 1) & (h - 1), (z + 0) & (d - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint((x + 0) & (w - 1), (y + 0) & (h - 1), (z - 1) & (d - 1), layer, raw, pr, col)) goto bad;
		if(!GetPoint(w - 1, h - 1, d - 1, layer, raw, pr, col)) goto bad;
		if(!GetPoint(0, 0, 0, layer, raw, pr, col)) goto bad;
		return true;
	bad:
		return false;
	}


public: //private:
	int m_w;
	int m_h;
	int m_d;
	int m_l;
	int m_bpp;
	D3DFORMAT m_f;
	DWORD* m_pLast;

	void SetPoint(int x, int y, int z, int layer, DWORD col, bool raw, D3DLOCKED_BOX* pr) 
	{
		int i;
		if(raw) {
			SWIZZLER s(max(m_w >> layer, 1), max(m_h >> layer, 1), max(m_d >> layer, 1));
			i = s.Convert(x,y,z);
		} else {
			i = (z * (max(m_h >> layer, 1)) * (max(m_w >> layer, 1))) + (y * (max(m_w >> layer, 1))) + x;
		}
		switch (m_bpp) {
		case 4:
			i >>= 1; 
			//fall through...
		case 8:
			((BYTE*)pr->pBits)[i] = (BYTE) col;
			break;
		case 16:
			((WORD*)pr->pBits)[i] = (WORD) col;
			break;
		case 32:
			((DWORD*)pr->pBits)[i] = (DWORD) col;
			break;
		default:
			_asm {int 3};
		}
	}	
	bool GetPoint(int x, int y, int z, int layer, bool raw, D3DLOCKED_BOX* pr, DWORD col) 
	{
		int i;
//		DWORD col;
		if(raw) {
			SWIZZLER s(max(m_w >> layer, 1), max(m_h >> layer, 1), max(m_d >> layer, 1));
			i = s.Convert(x,y,z);
		} else {
			i = (z * (max(m_h >> layer, 1)) * (max(m_w >> layer, 1))) + (y * (max(m_w >> layer, 1))) + x;
		}
		switch (m_bpp) {
		case 4:
			i >>= 1; 
			//fall through...
		case 8:
			if((BYTE)col == (((BYTE*)pr->pBits)[i]))
				return true;
			else
				return false;
		case 16:
			if((WORD)col == (((WORD*)pr->pBits)[i]))
				return true;
			else
				return false;
		case 32:
			if((DWORD)col == (((DWORD*)pr->pBits)[i]))
				return true;
			else
				return false;
		default:
			_asm {int 3};
		}
		return false;
	}	

};
};

#pragma data_seg(".d3dapi$test053") //
BEGINTEST(testVolLock)
{
	DWORD hr;
	bool br;
	VTEX t[2];
	D3DLOCKED_BOX r;
	int i;

	STARTLEAKCHECK();
	xStartVariation(hlog, "Volumelock, init");
	{
		br = t[0].Init(128, 128, 128, 8, D3DFMT_R8G8B8A8);
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;

		br = t[1].Init(512, 16, 256, 10, D3DFMT_R5G6B5);
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "multi-layer locks");
	{
		VOLUMELOCKTESTSTRUCT tests [] = {
			{0, 0, false, 1, 0, false},
			{0, 1, false, 0, 0, false},
			{0, 7, false, 1, 9, false},
			{0, 0, true,  1, 0, true},
			{1, 1, true,  1, 0, false},
			{1, 0, false, 1, 9, true},
		};

		for(i = 0; i < COUNTOF(tests); i++) {
			xLog(hlog, XLL_INFO, "cubenum%d, layer%d, as%d,  cubenum%d, layer%d, as%d", 
				tests[i].texnum1, tests[i].layer1, tests[i].doraw1,
				tests[i].texnum2, tests[i].layer2, tests[i].doraw2);
			hr = t[tests[i].texnum1].m_t->LockBox(tests[i].layer1, &r, NULL, tests[i].doraw1?D3DLOCK_RAWDATA:0); 
			CHECKRESULT(hr == D3D_OK && "Lock1");
			t[tests[i].texnum1].Set(tests[i].layer1, tests[i].doraw1, &r);
			hr = t[tests[i].texnum2].m_t->LockBox(tests[i].layer2, &r, NULL, tests[i].doraw2?D3DLOCK_RAWDATA:0); 
			CHECKRESULT(hr == D3D_OK && "Lock2");
			t[tests[i].texnum2].Set(tests[i].layer2, tests[i].doraw2, &r);

			hr = t[tests[i].texnum1].m_t->UnlockBox(tests[i].layer1);
			CHECKRESULT(hr == D3D_OK && "Unlock1");       
			hr = t[tests[i].texnum2].m_t->UnlockBox(tests[i].layer2);
			CHECKRESULT(hr == D3D_OK && "Unlock2");       

			hr = t[tests[i].texnum1].m_t->LockBox(tests[i].layer1, &r, NULL, tests[i].doraw1?D3DLOCK_RAWDATA:0); 
			CHECKRESULT(hr == D3D_OK && "Lock1 again");
			br = t[tests[i].texnum1].Check(tests[i].layer1, tests[i].doraw1, &r);
			CHECKRESULT(true == br && "check for set pixels");         
			hr = t[tests[i].texnum1].m_t->UnlockBox(tests[i].layer1);
			CHECKRESULT(hr == D3D_OK && "Unlock1");       

			hr = t[tests[i].texnum2].m_t->LockBox(tests[i].layer2, &r, NULL, tests[i].doraw2?D3DLOCK_RAWDATA:0); 
			CHECKRESULT(hr == D3D_OK && "Lock2 again");
			br = t[tests[i].texnum2].Check(tests[i].layer2, tests[i].doraw2, &r);
			CHECKRESULT(true == br && "check for set pixels");         
			hr = t[tests[i].texnum2].m_t->UnlockBox(tests[i].layer2);
			CHECKRESULT(hr == D3D_OK && "Unlock2");       
		}
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "volume:makebig");
	{
		t[0].Release();
		br = t[0].Init(128,64,512, 10, D3DFMT_A8R8G8B8);
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;

		t[1].Release();
		br = t[1].Init(512,128,64, 10, D3DFMT_A8R8G8B8);
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "multi-layer locks2");
	{
		VOLUMELOCKTESTSTRUCT tests [] = {
			{0, 0, false, 1, 0, true},
			{0, 1, false, 0, 0, true},
			{0, 3, false, 1, 1, false},
			{0, 8, false, 0, 1, true},
			{0, 9, false, 1, 9, false},
		};

		for(i = 0; i < COUNTOF(tests); i++) {
			xLog(hlog, XLL_INFO, "cubenum%d, layer%d, as%d,  cubenum%d, layer%d, as%d", 
				tests[i].texnum1, tests[i].layer1, tests[i].doraw1,
				tests[i].texnum2, tests[i].layer2, tests[i].doraw2);
			hr = t[tests[i].texnum1].m_t->LockBox(tests[i].layer1, &r, NULL, tests[i].doraw1?D3DLOCK_RAWDATA:0); 
			CHECKRESULT(hr == D3D_OK && "Lock1");
			t[tests[i].texnum1].Set(tests[i].layer1, tests[i].doraw1, &r);
			hr = t[tests[i].texnum2].m_t->LockBox(tests[i].layer2, &r, NULL, tests[i].doraw2?D3DLOCK_RAWDATA:0); 
			CHECKRESULT(hr == D3D_OK && "Lock2");
			t[tests[i].texnum2].Set(tests[i].layer2, tests[i].doraw2, &r);

			hr = t[tests[i].texnum1].m_t->UnlockBox(tests[i].layer1);
			CHECKRESULT(hr == D3D_OK && "Unlock1");       
			hr = t[tests[i].texnum2].m_t->UnlockBox(tests[i].layer2);
			CHECKRESULT(hr == D3D_OK && "Unlock2");       

			hr = t[tests[i].texnum1].m_t->LockBox(tests[i].layer1, &r, NULL, tests[i].doraw1?D3DLOCK_RAWDATA:0); 
			CHECKRESULT(hr == D3D_OK && "Lock1 again");
			br = t[tests[i].texnum1].Check(tests[i].layer1, tests[i].doraw1, &r);
			CHECKRESULT(true == br && "check for set pixels");         
			hr = t[tests[i].texnum1].m_t->UnlockBox(tests[i].layer1);
			CHECKRESULT(hr == D3D_OK && "Unlock1");       

			hr = t[tests[i].texnum2].m_t->LockBox(tests[i].layer2, &r, NULL, tests[i].doraw2?D3DLOCK_RAWDATA:0); 
			CHECKRESULT(hr == D3D_OK && "Lock2 again");
			br = t[tests[i].texnum2].Check(tests[i].layer2, tests[i].doraw2, &r);
			CHECKRESULT(true == br && "check for set pixels");         
			hr = t[tests[i].texnum2].m_t->UnlockBox(tests[i].layer2);
			CHECKRESULT(hr == D3D_OK && "Unlock2");       
		}
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "D3DVOLUME lock");
	{
		D3DVolume *v;
		t[1].Release();
		br = t[1].Init(128, 128, 256, 2, D3DFMT_A8);
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;

		hr = t[0].m_t->LockBox(1, &r, NULL, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK && "Lock1");
		t[0].Set(1, true, &r);

		hr = t[1].m_t->GetVolumeLevel(0, &v);
		CHECKRESULT(hr == D3D_OK && "GetVolume");
		hr = v->LockBox(&r, NULL, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK && "Lock2");
		t[1].Set(0, true, &r);

		hr = t[0].m_t->UnlockBox(1);
		CHECKRESULT(hr == D3D_OK && "Unlock1");       
		hr = v->UnlockBox();
		CHECKRESULT(hr == D3D_OK && "Unlock2");       
		v->Release();


		
		hr = t[1].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK && "Lock1");
		br = t[1].Check(0, true, &r);
		CHECKRESULT(true == br && "check for set pixels1");         

		hr = t[0].m_t->GetVolumeLevel(1, &v);
		CHECKRESULT(hr == D3D_OK && "GetVolume");
		hr = v->LockBox(&r, NULL, 0); 
		CHECKRESULT(hr == D3D_OK && "Lock2");
		br = t[0].Check(1, false, &r);
		CHECKRESULT(true == br && "check for set pixels2");         

		hr = t[1].m_t->UnlockBox(0);
		CHECKRESULT(hr == D3D_OK && "Unlock1");       
		hr = v->UnlockBox();
		CHECKRESULT(hr == D3D_OK && "Unlock2");       
		v->Release();
		
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "cube:maketiny");
	{
		t[1].Release();
		br = t[1].Init(1, 1, 2, 2, D3DFMT_A8);
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "tinycheck");
	{
		int layer;
		for(layer = 0; layer < 2; layer++) {
			hr = t[0].m_t->LockBox(layer, &r, NULL, D3DLOCK_RAWDATA);
			CHECKRESULT(hr == D3D_OK);
			t[0].Set(layer, true, &r);
			hr = t[0].m_t->UnlockBox(layer);
			CHECKRESULT(hr == D3D_OK);

			hr = t[0].m_t->LockBox(layer, &r, NULL, 0);
			CHECKRESULT(hr == D3D_OK);
			br = t[0].Check(layer, false, &r);
			CHECKRESULT(true == br);
			hr = t[0].m_t->UnlockBox(layer);
			CHECKRESULT(hr == D3D_OK);
		}
	}

cleanup:
	CHECKLEAKS();
	xEndVariation(hlog);

}
ENDTEST()

BEGINTEST(testVolumeUpdateTexture)
{
	DWORD hr;
	bool br;
	VTEX t[2];
	D3DLOCKED_BOX r;
	int i, j, j2;

	struct {
		int w1;
		int h1;
		int d1;
		int l1;
		int w2;
		int h2;
		int d2;
		int l2;
		D3DFORMAT format;
	} tests[] = {
		{256, 256, 256,  9, 256, 256, 256,  9, D3DFMT_A8          },
		{256, 256, 128,  9, 256, 256, 128,  9, D3DFMT_R5G6B5      },
		{  1, 256, 256,  9,   1, 256, 256,  9, D3DFMT_R5G6B5      },
		{256,   1, 256,  9, 256,   1, 256,  9, D3DFMT_R5G6B5      },
		{256, 256,   1,  9, 256, 256,   1,  9, D3DFMT_R5G6B5      },
		{256, 256, 256,  3, 128, 128, 128,  2, D3DFMT_R5G6B5      },
		{256,   8,  64,  9,   1,   1,   1,  1, D3DFMT_R5G6B5      },
		{ 64,  64,  64,  7,  64,  64,  64,  7, D3DFMT_R8G8B8A8    },
//		{512, 512, 256,  8,   4,   4,   4,  1, D3DFMT_DXT1        },
	};

	STARTLEAKCHECK();
	for(i = 0; i < COUNTOF(tests); i++) {
		xStartVariation(hlog, "lock, new texture");
		{
			t[0].Release();
			t[1].Release();

			br = t[0].Init(tests[i].w1, tests[i].h1, tests[i].d1, tests[i].l1, tests[i].format);
			CHECKRESULT(br == true);
			if(WASBADRESULT()) goto cleanup;

			br = t[1].Init(tests[i].w2, tests[i].h2, tests[i].d2, tests[i].l2, tests[i].format);
			CHECKRESULT(br == true);
			if(WASBADRESULT()) goto cleanup;

			for(j2 = 0; j2 < tests[i].l2; j2++) {
				hr = t[1].m_t->LockBox(j2, &r, NULL, D3DLOCK_RAWDATA);
				CHECKRESULT(hr == D3D_OK && "Lock");
				t[1].Set(j2, true, &r);
				hr = t[1].m_t->UnlockBox(j2);
				CHECKRESULT(hr == D3D_OK && "Unlock");
			}
			for(j = 0; j < tests[i].l1; j++) {
				hr = t[0].m_t->LockBox(j, &r, NULL, D3DLOCK_RAWDATA);
				CHECKRESULT(hr == D3D_OK && "Lock");
				t[0].Set(j, true, &r);
				hr = t[0].m_t->UnlockBox(j);
				CHECKRESULT(hr == D3D_OK && "Unlock");
				j2 = (j + tests[i].l2 - tests[i].l1);
				if(j2 >= 0 && j2 < tests[i].l2) {
					t[1].m_pLast[j2] = t[0].m_pLast[j];
				}
			}
			hr = g_pd3dd8->UpdateTexture(t[0].m_t, t[1].m_t);
			CHECKRESULT(hr == D3D_OK && "Update");

			for(j2 = 0; j2 < tests[i].l2; j2++) {
				hr = t[1].m_t->LockBox(j2, &r, NULL, D3DLOCK_RAWDATA);
				CHECKRESULT(hr == D3D_OK && "Lock");
				br = t[1].Check(j2, true, &r);
				CHECKRESULT(br == true && "CHECK!");
				hr = t[1].m_t->UnlockBox(j2);
				CHECKRESULT(hr == D3D_OK && "Unlock");
			}
		}
		xEndVariation(hlog);
	}
	goto aftercleanup;

cleanup:
	xEndVariation(hlog);
aftercleanup:;

	xStartVariation(hlog, "leak check");
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()


BEGINTEST(testVolLockTextureFlags)
{
	DWORD hr;
	bool br;
	VTEX t[1];
	D3DLOCKED_BOX r, oldr;

	__int64 StartTime, EndTime;

	xStartVariation(hlog, "init");
	{
/*
		br = t[0].Init(256, 128, 128, 1, D3DFMT_R8G8B8A8);	
/*/
		br = t[0].Init(256, 128, 128, 1, D3DFMT_R5G6B5);	
/**/
		CHECKRESULT(br == true);
		if(WASBADRESULT()) goto cleanup;

	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'0");
	{
		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, true, &r);
		t[0].m_t->UnlockBox(0);

		hr = t[0].m_t->LockBox(0, &r, NULL, 0);
		CHECKRESULT(oldr.pBits != r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, false, &r);
		CHECKRESULT(br == true);
		t[0].Set(0, false, &r);
		hr = t[0].m_t->UnlockBox(0);

		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockBox(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'R/O");
	{
		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, true, &r);
		t[0].m_t->UnlockBox(0);

		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_READONLY);
		CHECKRESULT(oldr.pBits != r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, false, &r);
		CHECKRESULT(br == true);
//		t[0].Set(0, false, &r);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockBox(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to unlock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, true, &r);
//		CHECKRESULT(br == true);
		t[0].m_t->UnlockBox(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Dis");
	{
		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
//		t[0].Set(0, true, &r);
		t[0].m_t->UnlockBox(0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_DISCARD);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits != r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, false, &r);
//		CHECKRESULT(br == true);
		t[0].Set(0, false, &r);
		hr = t[0].m_t->UnlockBox(0);

		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockBox(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Raw");
	{
		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, true, &r);
		t[0].m_t->UnlockBox(0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[0].Set(0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockBox(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockBox(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Raw/RO");
	{
		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
		t[0].Set(0, true, &r);
		t[0].m_t->UnlockBox(0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA | D3DLOCK_READONLY);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
//		t[0].Set(0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockBox(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

//		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
//		CHECKRESULT(oldr.pBits == r.pBits);
//		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, true, &r);
//		CHECKRESULT(br == true);
//		t[0].m_t->UnlockBox(0);
	}
	xEndVariation(hlog);

	xStartVariation(hlog, "SW'Raw/Dis");
	{
		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		oldr = r;
		CHECKRESULT(hr == D3D_OK);
//		t[0].Set(0, true, &r);
		t[0].m_t->UnlockBox(0);

		StartTime = GetUsCount(); {
			hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA | D3DLOCK_READONLY);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to lock: %d uS", EndTime - StartTime);

		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
//		br = t[0].Check(0, true, &r);
//		CHECKRESULT(br == true);
		t[0].Set(0, true, &r);
		StartTime = GetUsCount(); {
			hr = t[0].m_t->UnlockBox(0);
		} EndTime = GetUsCount();
		CHECKRESULT(EndTime - StartTime < 10000); //it shouldn't take more than 10 milliseconds to lock.
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "time to unlock: %d uS", EndTime - StartTime);

		hr = t[0].m_t->LockBox(0, &r, NULL, D3DLOCK_RAWDATA);
		CHECKRESULT(oldr.pBits == r.pBits);
		CHECKRESULT(hr == D3D_OK);
		br = t[0].Check(0, true, &r);
		CHECKRESULT(br == true);
		t[0].m_t->UnlockBox(0);
	}
	xEndVariation(hlog);

cleanup:
	xStartVariation(hlog, "Cleanup");
	{
		t[0].Release();
	}
	xEndVariation(hlog);
}
ENDTEST()

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\texture.cpp ===
#include "d3dapi.hpp"

#include "swizzler.h"

#ifndef ROUNDUP
#	define ROUNDUP(a,b)    ((((a)+(b)-1)/(b))*(b))
#endif

#ifndef MIN
#	define MIN(A,B) ((A) <= (B) ? (A) : (B))
#endif

LINKME(0)

static D3DFORMAT TextureTypes[] = {
//    D3DFMT_R8G8B8,
    D3DFMT_A8R8G8B8,
    D3DFMT_X8R8G8B8,
    D3DFMT_R5G6B5,
    D3DFMT_X1R5G5B5,
    D3DFMT_A1R5G5B5,
    D3DFMT_A4R4G4B4,
 //   D3DFMT_R3G3B2,
    D3DFMT_A8,
//    D3DFMT_A8R3G3B2,
//    D3DFMT_X4R4G4B4,

//    D3DFMT_A8P8,
    D3DFMT_P8,

    D3DFMT_L8,
    D3DFMT_A8L8,
//    D3DFMT_A4L4,

    D3DFMT_UYVY,
    D3DFMT_YUY2,
    D3DFMT_DXT1,
    D3DFMT_DXT2,
    D3DFMT_DXT3,
    D3DFMT_DXT4,
    D3DFMT_DXT5
};

static DWORD Usages[] = {
	0, D3DUSAGE_DEPTHSTENCIL, D3DUSAGE_RENDERTARGET, D3DUSAGE_DEPTHSTENCIL | D3DUSAGE_RENDERTARGET
};

static struct {UINT x; UINT y; UINT z;} Sizes[] = {
	{ 4,  4, 4},
	{ 8,  8, 8},
	{16, 16, 16},
	{32, 32, 32},
	{64, 64, 64},
	{ 4, 64, 32}
};

static DWORD Levels[] = {
	0, 1, 2
};

struct texturestuffstruct {
	D3DFORMAT f;
	UINT bitdepth;
	UINT width;
	UINT height;
	UINT count;
	UINT expected;
} Stuff[] = {
	{  D3DFMT_A8R8G8B8, 32,  64,   64,  0,  7},
	{  D3DFMT_A8R8G8B8, 32,  64,   64,  5,  5},
	{  D3DFMT_A8R8G8B8, 32,4096,  128,  0, 13},
	{  D3DFMT_A8R8G8B8, 32,4096,  128,  8,  8},
	{  D3DFMT_A8R8G8B8, 32,2048, 2048, 12, 12},
	{  D3DFMT_A8R8G8B8, 32,   4,    4,  0,  3},
	{  D3DFMT_A8R8G8B8, 32,   2,    2,  0,  2},
	{  D3DFMT_A8R8G8B8, 32,   1,    1,  0,  1},

	{      D3DFMT_DXT1,  4,  64,   64,  0,  7},
	{      D3DFMT_DXT1,  4,  64,   64,  5,  5},
	{      D3DFMT_DXT1,  4,4096,  128,  0, 13},
	{      D3DFMT_DXT1,  4,4096,  128,  8,  8},
	{      D3DFMT_DXT1,  4,4096, 4096, 11, 11},
	{      D3DFMT_DXT1,  4,   4,    4,  0,  3},

	{    D3DFMT_R5G6B5, 16,  64,   64,  5,  5},
	{        D3DFMT_A8,  8,  64,   64,  5,  5}
	
#if 1 // NUGOOP
	                                       ,
	{D3DFMT_LIN_R5G6B5, 16,  64,   64,  0,  1},
	{D3DFMT_LIN_R5G6B5, 16,1021, 1024,  0,  1},
	{D3DFMT_LIN_R5G6B5, 16,  64,  127,  0,  1},
	{D3DFMT_LIN_R5G6B5, 16, 381,  412,  1,  1},
	{D3DFMT_LIN_R5G6B5, 16,4096, 4096,  0,  1}
#endif
};

/*
//    HRESULT WINAPI CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DTexture8 **ppTexture);
//    HRESULT WINAPI CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DVolumeTexture8 **ppVolumeTexture);
//    HRESULT WINAPI CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DCubeTexture8 **ppCubeTexture);

    HRESULT WINAPI UpdateTexture(IDirect3DBaseTexture8 *pSourceTexture, IDirect3DBaseTexture8 *pDestinationTexture);

    HRESULT WINAPI BeginStateBlock();
    HRESULT WINAPI EndStateBlock(DWORD *pToken);
    HRESULT WINAPI ApplyStateBlock(DWORD Token);
    HRESULT WINAPI CaptureStateBlock(DWORD Token);
    HRESULT WINAPI DeleteStateBlock(DWORD Token);
    HRESULT WINAPI CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken);

    HRESULT WINAPI GetTexture(DWORD Stage, IDirect3DBaseTexture8 **ppTexture);
    HRESULT WINAPI SetTexture(DWORD Stage, IDirect3DBaseTexture8 *pTexture);

    HRESULT WINAPI GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue);
    HRESULT WINAPI SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);

    HRESULT WINAPI SetCurrentTexturePalette(UINT PaletteNumber);
    HRESULT WINAPI GetCurrentTexturePalette(UINT *PaletteNumber);

//	HRESULT WINAPI IDirect3DTexture8_GetDevice(IDirect3DTexture8 *pThis, IDirect3DDevice8 **ppDevice) { return IDirect3DResource8_GetDevice((IDirect3DResource8 *)pThis, ppDevice); }
//	D3DRESOURCETYPE WINAPI IDirect3DTexture8_GetType(IDirect3DTexture8 *pThis) { return IDirect3DResource8_GetType((IDirect3DResource8 *)pThis); }
//	BOOLEAN WINAPI IDirect3DTexture8_IsBusy(IDirect3DTexture8 *pThis) { return IDirect3DResource8_IsBusy((IDirect3DResource8 *)pThis); }
//	DWORD   WINAPI IDirect3DTexture8_GetLevelCount(IDirect3DTexture8 *pThis) { return IDirect3DBaseTexture8_GetLevelCount((IDirect3DBaseTexture8 *)pThis); }

//	HRESULT WINAPI IDirect3DTexture8_GetLevelDesc(IDirect3DTexture8 *pThis, UINT Level, D3DSURFACE_DESC *pDesc);
//	HRESULT WINAPI IDirect3DTexture8_GetSurfaceLevel(IDirect3DTexture8 *pThis, UINT Level, IDirect3DSurface8 **ppSurfaceLevel);
//	HRESULT WINAPI IDirect3DTexture8_LockRect(IDirect3DTexture8 *pThis, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
//	HRESULT WINAPI IDirect3DTexture8_UnlockRect(IDirect3DTexture8 *pThis, UINT Level);

  in resource.cpp:
    HRESULT WINAPI IDirect3DTexture8_SetPrivateData(IDirect3DTexture8 *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return IDirect3DResource8_SetPrivateData((IDirect3DResource8 *)pThis, refguid, pData, SizeOfData, Flags); }
	HRESULT WINAPI IDirect3DTexture8_GetPrivateData(IDirect3DTexture8 *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return IDirect3DResource8_GetPrivateData((IDirect3DResource8 *)pThis, refguid, pData, pSizeOfData); }
	HRESULT WINAPI IDirect3DTexture8_FreePrivateData(IDirect3DTexture8 *pThis, REFGUID refguid) { return IDirect3DResource8_FreePrivateData((IDirect3DResource8 *)pThis, refguid); }

*/


#pragma data_seg(".d3dapi$test100") 

BEGINTEST(testCreateTexture)
{
	IDirect3DTexture8* t;
	DWORD hr;
	int a, b, c, d;

	xStartVariation(hlog, "CreateTexture, Formats Loop");
	STARTLEAKCHECK();

	for(a = 0; a < COUNTOF(TextureTypes); a++) {
		hr = g_pd3dd8->CreateTexture(64, 64, 0, 0, TextureTypes[a], D3DPOOL_DEFAULT, &t);
		CHECKRESULT(hr == D3D_OK);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "x: %d, y: %d, Lev: %d, Usage: %d, Format: %d",
				64, 64, 0, 0, TextureTypes[a]);
			break;
		}
		hr = t->Release();
		CHECKRESULT(hr == 0);
	}

	CHECKLEAKS();
	xEndVariation(hlog);
	xStartVariation(hlog, "CreateTexture, Size & Levels Loop");
	STARTLEAKCHECK();

	for(b = 0; b < COUNTOF(Sizes); b++) {
	for(c = 0; c < COUNTOF(Levels); c++) {
	for(d = 0; d < COUNTOF(Usages); d++) {
		hr = g_pd3dd8->CreateTexture(Sizes[b].x, Sizes[b].y, 
			Levels[c], Usages[d], D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t);
		CHECKRESULT(hr == D3D_OK);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "x: %d, y: %d, Lev: %d, Usage: %d, Format: %d",
				Sizes[b].x, Sizes[b].y,	Levels[c], Usages[d], D3DFMT_A8R8G8B8);
			break;
		}
		hr = t->Release();
		CHECKRESULT(hr == 0);
	}
	}
	}

	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

//ULONG Rnd() { return ::Rnd(); }
ULONG Rnd(int a) {
	if(a == 0) return 0;
	return ::rand() % abs(a);
}

void FillRect(void* pBits, void* pBits2, int x1, int y1, int x2, int y2, int pitch, int bpp) {
	int i, j, b;
	if(x1 == 0 && x2 == 0) {x1 = 0; x2 = pitch / bpp;}
	if(pBits2) {
		for(j = y1; j < y2; j++) {
			for(i = x1; i < x2; i++) {
				for(b = 0; b < bpp; b++) {
					((char*)pBits)[j * pitch + i*bpp + b] = (char)rand();
					((char*)pBits2)[j * pitch + i*bpp + b] = ((char*)pBits)[j * pitch + i*bpp + b];
				}
			}
		}
	} else {
		for(j = y1; j < y2; j++) {
			for(i = x1; i < x2; i++) {
				for(b = 0; b < bpp; b++) {
					((char*)pBits)[j * pitch + i*bpp + b] = (char)rand();
				}
			}
		}
	}
}

void CopyRect(void* pDest, const void*pSrc, int rx1, int ry1, int rx2, int ry2, int px, int py, int dpitch, int spitch, int bpp) {
	int i, j, b;
	int rpitch = rx2 * bpp - rx1 * bpp;
	for(j = ry1; j < ry2; j++) {
		for(i = 0; i < (rpitch & ~15); i += 16) {
			char* tempsrc = &((char*)pSrc)[(j)*spitch+ rx1*bpp + i];
			char* tempdst = &((char*)pDest)[(j - ry1 + py) * dpitch + px*bpp + i];
			_asm {
				mov esi, tempsrc
				mov edi, tempdst
				movups xmm0, [esi]
				movups [edi], xmm0
			}
		}
		for( ; i < rpitch; i++) {
			((char*)pDest)[(j - ry1 + py) * dpitch + px*bpp + i] = ((char*)pSrc)[(j)*spitch+ rx1*bpp + i];
		}
	}
}

bool FastCompare(void *pSource, void *pDest, DWORD Size)
{
    if((Size & 31) != 0) {
		_asm {int 3};
	}

    void *pSourceMax = (BYTE *)pSource + Size;
    ULONGLONG Temp;

    _asm 
    {
        mov esi, [pSource]
        mov edi, [pDest]
        mov edx, [pSourceMax]
        mov eax, 1

Start:

        ; Get the memory to compare.

        movq mm0, [esi]
        movq mm1, [esi + 8]
        movq mm2, [esi + 16]
        movq mm3, [esi + 24]
        movq mm4, [edi]
        movq mm5, [edi + 8]
        movq mm6, [edi + 16]
        movq mm7, [edi + 24]

        ; If any of these compares fails then the appopriate DWORD will be 
        ; set to zero, otherwise all bits will be set to one.

        pcmpeqd mm0, mm4
        pcmpeqd mm1, mm5
        pcmpeqd mm2, mm6
        pcmpeqd mm3, mm7

        ; Collapse all of the comparisons together.

        pand mm0, mm1
        pand mm0, mm2
        pand mm0, mm3

        ; AND the high and low DWORD of mm0.  If any of the compares
        ; failed then the result in eax will be zero.  

        movd      eax, mm0
        punpckhdq mm0, mm0
        movd      ecx, mm0
        and       eax, ecx

        jz Done

        add esi, 32
        add edi, 32

        cmp esi, edx
        jne Start

Done:
		emms
    }
}

BEGINTEST(testCopyRects)
{
    IDirect3DTexture8 *t[3] = {0,0,0};
    IDirect3DSurface8 *s[3] = {0,0,0};
	int Width[3], Height[3];
	RECT   Src[1000];
	RECT*  pSrc;
	POINT  Dest[1000];
	POINT* pDest;
	int i, NumRects, r, z, f;
	D3DLOCKED_RECT LockedRect[3];
	D3DFORMAT Formats[] = {D3DFMT_LIN_A8, D3DFMT_LIN_R5G6B5, D3DFMT_LIN_A8R8G8B8};
	D3DFORMAT SwizFormats[] = {D3DFMT_A8, D3DFMT_R5G6B5, D3DFMT_A8R8G8B8, D3DFMT_DXT1, D3DFMT_DXT2, D3DFMT_DXT4};
	int SwizBpp[] = {8,16,32,4,8,16};
//	D3DFORMAT DxtFormats[] = {};
	HRESULT hr;

/*
    g_pd3dd8->CreateTexture(32, 32, 0, 0, D3DFMT_A8R8G8B8, 0, &t[0]);
    g_pd3dd8->CreateTexture(32, 32, 0, 0, D3DFMT_A8R8G8B8, 0, &t[1]);
 
    D3DSURFACE_DESC         desc1;
    D3DSURFACE_DESC         desc2;
 
    t[0]->GetSurfaceLevel(5, &s[0]);
    t[1]->GetSurfaceLevel(5, &s[1]);
	s[0]->LockRect(&LockedRect[0],0,0);
	s[1]->LockRect(&LockedRect[1],0,0);
 
    g_pd3dd8->CopyRects(s[1], NULL, 0, s[0], NULL);

	s[0]->UnlockRect();
	s[0]->UnlockRect();
	
    s[0]->Release();
    s[1]->Release();
	t[0]->Release();
	t[1]->Release();
*/
	xStartVariation(hlog, "linear textures");
	for(i = 0; i < 3; i++) {
		for(f = 0; f < COUNTOF(Formats); f++) {
			do {
				Width[0] = Rnd(4096) + 1;
				Height[0] = Rnd(4096) + 1;
			} while (Width[0] * (1 << f) > 8128 || Width[0] * Height[0] * (1 << f) > 0x1000000);
			do {
				Width[1] = Rnd(4096) + 1;
				Height[1] = Rnd(4096) + 1;
			} while (Width[1] * (1 << f) > 8128 || Width[1] * Height[1] * (1 << f) > 0x1000000);
			Width[2] = Width[1]; Height[2] = Height[1];
			for(z = 0; z < 3; z++) {
				hr = g_pd3dd8->CreateTexture(Width[z], Height[z], 1, 0, Formats[f], D3DPOOL_DEFAULT, &t[z]);
				CHECKRESULT(hr == D3D_OK && "CreateTexture");
			}
			if(WASGOODRESULT()) {
				for(z = 0; z < 3; z++) {
					hr = t[z]->GetSurfaceLevel(0, &s[z]);
					CHECKRESULT(hr == D3D_OK && "CreateSurfaceLevel");
				}
			}
			if(WASGOODRESULT()) {
				for(z = 0; z < 3; z++) {
					hr = s[z]->LockRect(&LockedRect[z], 0, 0);
					CHECKRESULT(hr == D3D_OK && "LockRect");
				}
			}
			if(WASGOODRESULT()) {

				FillRect(LockedRect[0].pBits,                NULL, 0,0,0/*Width[0]*/,Height[0],LockedRect[0].Pitch, (1 << f));
				FillRect(LockedRect[1].pBits, LockedRect[2].pBits, 0,0,0/*Width[1]*/,Height[1],LockedRect[1].Pitch, (1 << f));
			
//				CHECKRESULT(!memcmp(LockedRect[1].pBits, LockedRect[2].pBits, Height[1] * LockedRect[1].Pitch) || !"Lin CopyRects Comparison");

				NumRects = Rnd(10);
				if(((Rnd(2) || (NumRects == 0)) && Width[0] <= Width[1]) && Height[0] <= Height[1]) {
					//null RECTs
					pSrc = NULL;

					if(Rnd(2)) {
						NumRects = 0;
						//null POINTs
						pDest = NULL;
						CopyRect(LockedRect[2].pBits, LockedRect[0].pBits, 0,0,Width[0],Height[0], 
							0,0,LockedRect[2].Pitch, LockedRect[0].Pitch, (1 << f));
					} else {
						pDest = Dest;
						for(r = 0; r < max(NumRects,1); r++) {
							Dest[r].x = Rnd(Width[1] - Width[0]);
							Dest[r].y = Rnd(Height[1] - Height[0]);
							CopyRect(LockedRect[2].pBits, LockedRect[0].pBits, 0,0,Width[0],Height[0], 
								Dest[r].x,Dest[r].y,LockedRect[2].Pitch, LockedRect[0].Pitch, (1 << f));
						}
					}
				} else {
					if(NumRects == 0) NumRects = 1;
					pSrc = Src;
					if(Rnd(2)) { 
						pDest = NULL;
						//null POINTs
						for(r = 0; r < max(NumRects,1); r++) {
							Src[r].top = Rnd(MIN(Height[0], Height[1]) - 1);
							Src[r].bottom = Src[r].top + Rnd(MIN(Height[0], Height[1]) - Src[r].top) + 1;
							Src[r].left = Rnd(MIN(Width[0], Width[1]) - 1);
							Src[r].right = Src[r].left + Rnd(MIN(Width[0], Width[1]) - Src[r].left) + 1;
							CopyRect(LockedRect[2].pBits, LockedRect[0].pBits, Src[r].left, Src[r].top, Src[r].right, Src[r].bottom, 
								Src[r].left, Src[r].top,LockedRect[2].Pitch, LockedRect[0].Pitch, (1 << f));

						}
					} else {
						pDest = Dest;
						for(r = 0; r < max(NumRects,1); r++) {
							Src[r].top = Rnd(Height[0] - 1);
							Src[r].bottom = 1 + Src[r].top + Rnd(MIN(Height[1], Height[0] - Src[r].top));
							Src[r].left = Rnd(Width[0] - 1);
							Src[r].right = 1 + Src[r].left + Rnd(MIN(Width[1], Width[0] - Src[r].left));
							Dest[r].x = Rnd(Width[1] - (Src[r].right - Src[r].left));
							Dest[r].y = Rnd(Height[1] - (Src[r].bottom - Src[r].top));
							CopyRect(LockedRect[2].pBits, LockedRect[0].pBits, Src[r].left, Src[r].top, Src[r].right, Src[r].bottom, 
								Dest[r].x, Dest[r].y,LockedRect[2].Pitch, LockedRect[0].Pitch, (1 << f));
						}
					}
				}

				xLog(hlog, XLL_INFO, "S1: %dx%d. S2: %dx%d. Rects:%d. Bpp%d. S%p D%p", Width[0],Height[0],Width[1],Height[1], NumRects, (1 << f), pSrc, pDest);
//				if (NumRects >= 2) {
//					for(r = 0; r < NumRects; r++) {
//						hr = g_pd3dd8->CopyRects(s[0], &pSrc[r], 1, s[1], &pDest[r]);
//					}
//				} else {
					hr = g_pd3dd8->CopyRects(s[0], pSrc, NumRects, s[1], pDest);
//				}
				CHECKRESULT(hr == D3D_OK && "CopyRects result");
				s[1]->BlockUntilNotBusy();
                CHECKRESULT(FastCompare(LockedRect[1].pBits, LockedRect[2].pBits, Height[1] * LockedRect[1].Pitch) || !"Lin CopyRects Comparison");
				if(WASBADRESULT()) { _asm {int 3} ; }
			} else {
				xLog(hlog, XLL_INFO, "S1: %dx%d. S2: %dx%d. Rects:%d. Bpp%d", Width[0],Height[0],Width[1],Height[1], NumRects, (1 << f));
				xLog(hlog, XLL_INFO, "copyrects: couldn't create the textures!");
			}
			for(z = 0; z < 3; z++) {
				if(s[z]) {
					s[z]->UnlockRect();
					s[z]->Release();
					t[z]->Release();
				} else if (t[z]) t[z]->Release();
				s[z]=0;t[z]=0;
			}
		}
	}
	xEndVariation(hlog);
	xStartVariation(hlog, "Swizzled Textures");
	D3DSURFACE_DESC desc;
	for(i = 0; i < 50; i++) {
		for(f = 0; f < COUNTOF(SwizFormats); f++) {
			do {
				Width[1] = Width[0] = (1 << (rand() % 12));
				Height[1] = Height[0] = (1 << (rand() % 12));
				if(i == 0) {
					Width[1] = Width[0] = 1;
					Height[1] = Height[0] = 1;
				}
				if(i == 1) {
					Width[1] = Width[0] = 2;
					Height[1] = Height[0] = 1;
				}
				if(i == 2) {
					Width[1] = Width[0] = 1;
					Height[1] = Height[0] = 2;
				}
				if(i == 3) {
					Width[1] = Width[0] = 2;
					Height[1] = Height[0] = 2;
				}
			} while ((Width[0] * Height[0] * SwizBpp[f]) / 8 > 0x2000000);
			for(z = 0; z < 2; z++) {
				hr = g_pd3dd8->CreateTexture(Width[z], Height[z], 1, 0, SwizFormats[f], D3DPOOL_DEFAULT, &t[z]);
				CHECKRESULT(hr == D3D_OK);
			}
			if(WASGOODRESULT()) {
				for(z = 0; z < 2; z++) {
					hr = t[z]->GetSurfaceLevel(0, &s[z]);
					CHECKRESULT(hr == D3D_OK);
				}
			}

			t[0]->GetLevelDesc(0,&desc);

			if(WASGOODRESULT()) {
				for(z = 0; z < 2; z++) {
					hr = s[z]->LockRect(&LockedRect[z], 0, 0);
					CHECKRESULT(hr == D3D_OK);
				}
			}
			if(WASGOODRESULT()) {
				UINT asdf;
				for(asdf = 0; asdf < desc.Size; asdf++) {
					((char*)LockedRect[0].pBits)[asdf] = (char)rand();
				}
				
//				FillRect(LockedRect[0].pBits, NULL, 0,0,Width[0],Height[0],LockedRect[0].Pitch, (1 << f));

				xLog(hlog, XLL_INFO, "S1: %dx%d. S2: %dx%d. Rects:%d. Format:%d", Width[0],Height[0],Width[1],Height[1], NumRects, f);
				hr = g_pd3dd8->CopyRects(s[0], NULL, 0, s[1], NULL);
				CHECKRESULT(hr == D3D_OK || !"CopyRects Return Value");
				s[1]->BlockUntilNotBusy();
				if(desc.Size & 31) {
					CHECKRESULT(!memcmp(LockedRect[1].pBits, LockedRect[0].pBits, desc.Size /*Height[1] * LockedRect[1].Pitch*/) && 
					"Swiz CopyRects Comparison");
				} else {
					CHECKRESULT(FastCompare(LockedRect[1].pBits, LockedRect[0].pBits, desc.Size /*Height[1] * LockedRect[1].Pitch*/) && 
					"Swiz CopyRects Comparison");
				}
			} else {
				xLog(hlog, XLL_INFO, "S1: %dx%d. S2: %dx%d. Rects:%d. Format:%d", Width[0],Height[0],Width[1],Height[1], NumRects, f);
				xLog(hlog, XLL_INFO, "copyrects: couldn't create the textures!");
			}
			for(z = 0; z < 2; z++) {
				if(s[z]) {
					s[z]->UnlockRect();
					s[z]->Release();
					t[z]->Release();
				} else if (t[z]) t[z]->Release();
				s[z]=0;t[z]=0;
			}
		}
	}
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testTextureGetDevice)
{
	DWORD hr;
	IDirect3DTexture8* t;
	IDirect3DDevice8* d;

	xStartVariation(hlog, "TextureGetDevice");
	STARTLEAKCHECK();
	hr = g_pd3dd8->CreateTexture(64, 64, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t);
	CHECKRESULT(hr == D3D_OK);
	hr = t->GetDevice(&d);
	CHECKRESULT(hr == D3D_OK);
	CHECKRESULT(d == g_pd3dd8);
	d->Release();
	CHECKRESULT(t->Release() == 0);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testTextureGetType)
{
	DWORD hr;
	IDirect3DTexture8* t;

	xStartVariation(hlog, "TextureGetType");
	STARTLEAKCHECK();
	hr = g_pd3dd8->CreateTexture(64, 64, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t);
	CHECKRESULT(hr == D3D_OK);
	CHECKRESULT(t->GetType() == D3DRTYPE_TEXTURE);
	CHECKRESULT(t->Release() == 0);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testTextureIsBusy)
{
	//#pragma TODO("test IsBusy")
}
ENDTEST()

BEGINTEST(testTextureGetLevelCount)
{
	DWORD hr;
	IDirect3DTexture8* t;
	int i;

	xStartVariation(hlog, "TextureGetLevelCount");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(Stuff); i++) {
		hr = g_pd3dd8->CreateTexture(Stuff[i].width, Stuff[i].height, Stuff[i].count, 0, Stuff[i].f, D3DPOOL_DEFAULT, &t);
		CHECKRESULT(hr == D3D_OK);
		if(WASGOODRESULT()) {
			hr = t->GetLevelCount();
			CHECKRESULT(hr == Stuff[i].expected /*GetLevelCount()*/);
			if(WASBADRESULT()) {
				xLog(hlog, XLL_INFO, "w:%d, h:%d, count:%d, format:%d, GetLevelCount():%d, expected:%d",
					Stuff[i].width, Stuff[i].height, Stuff[i].count, Stuff[i].f, hr, Stuff[i].expected);
			}
			CHECKRESULT(t->Release() == 0);
		}
	}
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

bool IsSwizzledD3DFORMAT(D3DFORMAT Format);
namespace D3D {
//bool IsSwizzledD3DFORMAT(D3DFORMAT Format);
bool IsCompressedD3DFORMAT(D3DFORMAT Format);
}

BEGINTEST(testTextureGetLevelDesc)
{
	DWORD hr;
	IDirect3DTexture8* t;
	D3DSURFACE_DESC d;
	int i;
	unsigned int j;
	UINT w, h, w4, h4;

	xStartVariation(hlog, "TextureGetLevelDesc");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(Stuff); i++) {
		hr = g_pd3dd8->CreateTexture(Stuff[i].width, Stuff[i].height, Stuff[i].count, 0, Stuff[i].f, D3DPOOL_DEFAULT, &t);
		w = Stuff[i].width; 
		h = Stuff[i].height;
		CHECKRESULT(hr == D3D_OK);
//		CHECKRESULT(t->GetLevelCount() == Stuff[i].expected);
		if(WASGOODRESULT()) { 
			for(j = 0; j < t->GetLevelCount(); j++) {
		//		if(Stuff[i].width == 381) {
		//			_asm int 3
		//		}

				hr = t->GetLevelDesc(j, &d);
				CHECKRESULT(hr == D3D_OK);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "GetLevelDesc returned %d", hr);
				CHECKRESULT(d.Width == w);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "d.Width = %d, should be %d", d.Width, w);
				CHECKRESULT(d.Height == h);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "d.Height = %d, should be %d", d.Height, h);
				if(Stuff[i].f == D3DFMT_DXT1 || Stuff[i].f == D3DFMT_DXT2 || Stuff[i].f == D3DFMT_DXT4) {
					if(w < 4) w4 = 4; else w4 = w;
					if(h < 4) h4 = 4; else h4 = h;
                } else if (!IsSwizzledD3DFORMAT(Stuff[i].f)) {
					w4 = ROUNDUP(w, D3DTEXTURE_PITCH_MIN * 8 / Stuff[i].bitdepth);
					h4 = h;
				} else {
					w4 = w;
					h4 = h;
				}
				
				CHECKRESULT(d.Size == w4 * h4 * Stuff[i].bitdepth /8);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "d.Size = %d, should be %d", d.Size, w4 * h4 * Stuff[i].bitdepth/8);
				CHECKRESULT(d.Format == Stuff[i].f);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "d.Format = %d, should be %d", d.Format, Stuff[i].f);
				w = (w >> 1) ? (w >> 1) : 1;
				h = (h >> 1) ? (h >> 1) : 1;
			}
			CHECKRESULT(t->Release() == 0);
		}
	}
	CHECKRESULT(d.Type == D3DRTYPE_TEXTURE);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testTextureGetSurfaceLevel)
{
	DWORD hr;
	IDirect3DTexture8* t;
	IDirect3DSurface8* s;
	D3DSURFACE_DESC d;
	int i;
	unsigned int j;
	UINT w, h, w4, h4;

	xStartVariation(hlog, "TextureGetSurfaceLevel");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(Stuff); i++) {
		hr = g_pd3dd8->CreateTexture(Stuff[i].width, Stuff[i].height, Stuff[i].count, 0, Stuff[i].f, D3DPOOL_DEFAULT, &t);
		w = Stuff[i].width; 
		h = Stuff[i].height;
		CHECKRESULT(hr == D3D_OK);
		if(WASGOODRESULT()) {
			for(j = 0; j < t->GetLevelCount(); j++) {
				t->GetSurfaceLevel(j, &s);
				s->GetDesc(&d);
	  			CHECKRESULT(d.Width == w);	// //basically already tested above
				if(WASBADRESULT()) {
					xLog(hlog, XLL_INFO, "width is %d, should be %d", d.Width, w);
				}
	  			CHECKRESULT(d.Height == h);
				if(WASBADRESULT()) {
					xLog(hlog, XLL_INFO, "height is %d, should be %d", d.Height, h);
				}

				if(Stuff[i].f == D3DFMT_DXT1 || Stuff[i].f == D3DFMT_DXT2 || Stuff[i].f == D3DFMT_DXT4) {
					if(w < 4) w4 = 4; else w4 = w;
					if(h < 4) h4 = 4; else h4 = h;
                } else if (!IsSwizzledD3DFORMAT(Stuff[i].f)) {
					w4 = ROUNDUP(w, D3DTEXTURE_PITCH_MIN * 8 / Stuff[i].bitdepth);
					h4 = h;
				} else {
					w4 = w;
					h4 = h;
				}
				
				CHECKRESULT(d.Size == w4 * h4 * Stuff[i].bitdepth/8);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "size is: %d, should be %d. w=%d,h=%d,f=%d. i=%d,j=%d, bpp=%d", 
					d.Size, w4*h4*Stuff[i].bitdepth/8, w,h,Stuff[i].f,i,j, Stuff[i].bitdepth);
				CHECKRESULT(d.Format == Stuff[i].f);
				w = (w >> 1) ? (w >> 1) : 1;
				h = (h >> 1) ? (h >> 1) : 1;
				hr = s->Release();
				CHECKRESULT(hr == 0);
			}
			CHECKRESULT(t->Release() == 0);
		}
	}
	CHECKRESULT(d.Type == D3DRTYPE_SURFACE);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

#if 0
	BEGINTEST(testTextureLockAndUnlockRect)
	{
		/*
		This test does the following:
			create huge texture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
			locks the top layer as RAW_DATA
			sets a few random pixels
			unlocks top layer
			locks top layer (unswizzled)
			checks if the pixels tweaked earlier are still set
			locks layer 3 (512x512), (RAW)
			sets a lot more pixels on top layer
			sets some pixels on layer 3
			unlock layer 3, lock layer 3 as unswizzled
			set more pixels on layer 3
			unlocks top layer
			locks top layer (RAW)
			lock bottom layer (RAW)
			create another texture (256x512, 1 mip layer, 32bits/pixel == 128k)
			lock second texture (unswizzled)
			write pixels to second texture
			set a pixel on bottom layer of first texture
			unlock bottom layer of first texture (RAW)
			unlock layer 3 of first texture(RAW)
			unlock second texture (unswizzled)
			checks for corruption of pixels set on RAW top layer
			unlock top layer
			lock top layer
			unlock top layer
			delete first texture
			lock second texture (RAW)
			check for corrupted pixels of second texture
			unlock second texture (RAW)
			delete second texture

		tests:
			huge textures, 
			multiple simultaneous unswizzling of texture levels
			swizzling
			unswizzling
			multiple simultaneous unswizzled textures
			1x1 mip layers
			non-square textures
			8bbp and 32bbp lock/unlock
		*/
		
		DWORD hr;
		IDirect3DTexture8* t[3] = {0,0,0};
		RECT r;
		D3DLOCKED_RECT l;
		D3DLOCKED_RECT l2;
		D3DLOCKED_RECT l3;
		D3DLOCKED_RECT l4;
		int i, j;
		int u, v;
		int p;
		bool isbad = false;

		SWIZZLER a (4096, 4096, 0);
		SWIZZLER b (2048, 256, 0);
		SWIZCOORD coords[32];

		SWIZNUM big_u = a.Convert(259, UCOORD);
		SWIZNUM big_v = a.Convert(273, VCOORD);

		xStartVariation(hlog, "Texture Lock Rect");
		STARTLEAKCHECK();

	//		create huge texture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateTexture(4096, 4096, 13, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[0]);
		CHECKRESULT(hr == D3D_OK /*Create huge texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

		r.top = 0;
		r.left = 0;
		r.right = 4095;
		r.bottom = 4095;

	//		locks the top layer as RAW_DATA
		hr = t[0]->LockRect(0, &l, &r, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock top layer RAW*/);
		CHECKRESULT(l.Pitch == 4096 /*lock top layer RAW*/);
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "l.pitch = %d, should be %d", l.Pitch, 4096);
		coords[0].Init(   2,    0,    0, &a);
		coords[1].Init(   3,    0,    0, &a);
		coords[2].Init(4095, 4094,    0, &a);
		coords[3].Init(2047, 2047,    0, &a);

	//		sets a few random pixels
		((BYTE*)l.pBits)[coords[0].c] = 0;
		((BYTE*)l.pBits)[coords[1].c] = 255;
		((BYTE*)l.pBits)[coords[2].c] = 31;
		((BYTE*)l.pBits)[coords[3].c] = 41;

	//		unlocks top layer
		hr = t[0]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*unlock top layer RAW*/);
		
	//		locks top layer (unswizzled)
		hr = t[0]->LockRect(0, &l, &r, 0); 
		CHECKRESULT(hr == D3D_OK /*lock top layer unswizzled*/);
		CHECKRESULT(l.Pitch == 4096 /*lock top layer unswizzled*/);
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "l.pitch = %d, should be %d", l.Pitch, 4096);

	//		checks if the pixels tweaked earlier are still set
		if(((BYTE*)l.pBits)[coords[0].i] != 0) isbad = true;
		if(((BYTE*)l.pBits)[coords[1].i] != 255) isbad = true;
		if(((BYTE*)l.pBits)[coords[2].i] != 31) isbad = true;
		if(((BYTE*)l.pBits)[coords[3].i] != 41) isbad = true;
		CHECKRESULT(isbad == false /*swizzle didn't work right*/);

		isbad = false;

	//		locks layer 3 (512x512), (RAW)
		hr = t[0]->LockRect(3, &l2, NULL, D3DLOCK_RAWDATA); //this should be a 512x512 texture (swizzled)
		CHECKRESULT(hr == D3D_OK /*second mipmap lock*/);

	//		sets a lot more pixels on top layer
		for(j = 0; j < 4096; j += 273) {
			for(i = 0; i < 4096; i += 259) {
				((BYTE*)l.pBits)[i + j * l.Pitch] = i + j;
			}
		}

	//		sets some pixels on layer 3
		for(i = 0; i < l2.Pitch; i++) {
			for(j = 0; j < l2.Pitch; j++) {
				((BYTE*)l2.pBits)[i + j * l2.Pitch] = 1;
			}
		}

	//		unlocks top layer
		hr = t[0]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*swizzled texture unlock*/);

	//		locks top layer (RAW)
	//	_asm int 3; 
		hr = t[0]->LockRect(0, &l, &r, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock top layer RAW*/);
		CHECKRESULT(l.Pitch == 4096 /*lock top layer RAW*/);
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "l.pitch = %d, should be %d", l.Pitch, 4096);

	//		lock bottom layer (RAW)
		hr = t[0]->LockRect(12, &l3, NULL, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock bottom layer RAW*/);
		CHECKRESULT(l3.Pitch == 1 /*lock bottom layer RAW*/);
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "l3.pitch = %d, should be %d", l3.Pitch, 1);

	//		create another texture (256x512, 1 mip layer, 32bits/pixel == 128k)
		hr = g_pd3dd8->CreateTexture(2048, 256, 1, 0, D3DFMT_R8G8B8A8, D3DPOOL_DEFAULT, &t[1]);
		CHECKRESULT(hr == D3D_OK /*create second texture while first is unlocked*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

	//		lock second texture (unswizzled)
		hr = t[1]->LockRect(0, &l4, NULL, 0); 
		CHECKRESULT(hr == D3D_OK);
		CHECKRESULT(l4.Pitch == 2048 * sizeof(DWORD));
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "l4.pitch = %d, should be %d", l4.Pitch, 2048*sizeof(DWORD));
		}

	//		write pixels to second texture
		coords[10].Init(   0,    0, 0, &b);
		coords[11].Init(   1,    0, 0, &b);
		coords[12].Init(   2,    0, 0, &b);
		coords[13].Init( 767,  255, 0, &b);
		coords[14].Init(2047,  255, 0, &b);
		coords[15].Init(2046,  254, 0, &b);
		((DWORD*)l4.pBits)[coords[10].i] = 0x12345678;
		((DWORD*)l4.pBits)[coords[11].i] = 0x11111111;
		((DWORD*)l4.pBits)[coords[12].i] = 0x33445566;
		((DWORD*)l4.pBits)[coords[13].i] = 0x91807f6e;
		((DWORD*)l4.pBits)[coords[14].i] = 0xfffefdfc;
		((DWORD*)l4.pBits)[coords[15].i] = 0x01020304;

	//		set a pixel on bottom layer of first texture
		*((BYTE*)l3.pBits) = 255;

	//		unlock bottom layer of first texture(RAW)
		hr = t[0]->UnlockRect(12);
		CHECKRESULT(hr == D3D_OK /*bottom-layer mipmap unlock*/);

	//		unlock layer 3 of first texture(RAW)
		hr = t[0]->UnlockRect(3);
		CHECKRESULT(hr == D3D_OK /*layer 3 mipmap unlock*/);

	//		unlock second texture (unswizzled)
		hr = t[1]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*second texture unlock*/);

	//		checks for corruption of pixels set on RAW top layer
		a.Set(0,VCOORD);
		for(j = 0; j < 4096; j += 273) {
			a.Set(0,UCOORD);
			for(i = 0; i < 4096; i += 259) {
				if(((BYTE*)l.pBits)[a.Get2()] != i + j) {isbad = true; break;}
				a.Add(big_u, UCOORD);
			}
			a.Add(big_v, VCOORD);
		}
		CHECKRESULT(isbad == false /*unswizzle of top layer didn't work right*/ );
		isbad = false;

	//		unlock top layer
		hr = t[0]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*unlock top layer*/);

	//		locks top layer (unswizzled)
		hr = t[0]->LockRect(0, &l, &r, 0); 
		CHECKRESULT(hr == D3D_OK /*second unswizzling of top layer*/);
		CHECKRESULT(l.Pitch == 4096 /*lock top layer of first texture*/);
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "l.pitch = %d, should be %d", l.Pitch, 4096);

	//		unlock top layer
		hr = t[0]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK /*second reswizzling of top layer*/);

	//		delete first texture
		hr = t[0]->Release();
		t[0] = 0;
		CHECKRESULT(hr == 0 /*release first texture*/);

	//		lock second texture (RAW)
		hr = t[1]->LockRect(0, &l4, NULL, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock second texture, RAW*/);
		CHECKRESULT(l4.Pitch == 2048 * sizeof(DWORD) /*second texture RAW*/);
		if(WASBADRESULT()) xLog(hlog, XLL_INFO, "l4.pitch = %d, should be %d", l4.Pitch, 2048*sizeof(DWORD));

	//		check for corrupted pixels of second texture
		if(((DWORD*)l4.pBits)[coords[10].c] != 0x12345678) isbad = true;
		if(((DWORD*)l4.pBits)[coords[11].c] != 0x11111111) isbad = true;
		if(((DWORD*)l4.pBits)[coords[12].c] != 0x33445566) isbad = true;
		if(((DWORD*)l4.pBits)[coords[13].c] != 0x91807f6e) isbad = true;
		if(((DWORD*)l4.pBits)[coords[14].c] != 0xfffefdfc) isbad = true;
		if(((DWORD*)l4.pBits)[coords[15].c] != 0x01020304) isbad = true;
		CHECKRESULT(isbad == false /*corrupted pixels of second texture*/);

		hr = t[1]->UnlockRect(0);
		CHECKRESULT(hr == D3D_OK);

	cleanup:
		for(i = 0; i < 3; i++) {
			if(t[i] != NULL) {
				hr = t[i]->Release();
				CHECKRESULT(hr == 0);
				t[i] = NULL;
			}
		}

	//check for leaks
		CHECKLEAKS();
		xEndVariation(hlog);
	}
	ENDTEST()


	BEGINTEST(testTextureUpdateTexture)
	{
		/*
		This test does the following:
			create huge texture map (4096x4096x8bit), full mips (22.3 mb)
			write random pixels to first texture (multiple layers)
			create second huge texture map (4096x4096x8bit), full mips
			use UpdateTexture to copy first texture to second
			delete first texture
			check random pixels in second texture (unswizzled)
			create 256x256 texture map, full mips
			copy lower mip layers from texture2 to texture3
			check texture3
			change pixels in texture2
			copy lower mip layers from texture2 to texture3
			check texture3
			delete texture2, texture3

		this checks:
			big texture
			full mip copy
			8-bit
			partial mip copy
			square texture
			multiple copy from same source
		*/
		DWORD hr;

		IDirect3DTexture8* t[3] = {0,0,0};
		RECT r;
		D3DLOCKED_RECT l;

		SWIZZLER a (4096, 4096, 0);
		struct COORD {
			DWORD u;
			DWORD v;
			int layer;
		} coords [] = {
			{0, 0, 0},
			{4095, 4095, 0},
			{2048, 2047, 0},
			{1022, 34, 2},
			{100, 4, 4},
			{32, 32, 5},
			{0, 15, 8},
			{6, 2, 9},
			{2, 3, 10},
			{0, 1, 11},
			{1, 0, 11},
			{0, 0, 12},
		};
		int i;
		bool isbad = false;

		xStartVariation(hlog, "");
		STARTLEAKCHECK();

	//		create huge texture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateTexture(4096, 4096, 13, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[0]);
		CHECKRESULT(hr == D3D_OK /*Create huge texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			r.bottom = 4096 / (1 << coords[i].layer) - 1;
			r.right = 4096 / (1 << coords[i].layer) - 1;
			r.left = 0;
			r.top = 0;

			hr = t[0]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = (BYTE)i;

		//		unlock layer
			hr = t[0]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);

		}

	//		create second huge texture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateTexture(4096, 4096, 13, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[1]);
		CHECKRESULT(hr == D3D_OK /*Create second huge texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

	//		use UpdateTexture to copy first texture to second
		hr = g_pd3dd8->UpdateTexture(t[0], t[1]);
		CHECKRESULT(hr == D3D_OK /*Update on huge texture*/);

	//		delete first texture
		hr = t[0]->Release();
		CHECKRESULT(hr == 0 /*release first huge texture*/);
		t[0] = 0;

	//		check bytes in second texture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != (BYTE)i) isbad = true;

		//		unlock layer
			hr = t[1]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture*/);
		isbad = false;

	//		create smaller texture (256x256, full mips, 8bits/pixel), 
		hr = g_pd3dd8->CreateTexture(256, 256, 0, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[2]);
		CHECKRESULT(hr == D3D_OK /*Create 256x256 texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

	//		use UpdateTexture to copy second texture to third
		hr = g_pd3dd8->UpdateTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small*/);
		
	//		check bytes in third texture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 4) {
				hr = t[1]->LockRect(coords[i].layer -4, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != i) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer -4);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture to smaller texture*/);
		isbad = false;

		coords[ 0].u = 255; coords[ 0].v = 255; coords[ 0].layer = 4;
		coords[ 0].u = 254; coords[ 0].v = 255; coords[ 0].layer = 4;
		coords[ 0].u = 185; coords[ 0].v =  25; coords[ 0].layer = 4;
		coords[ 0].u = 120; coords[ 0].v =   0; coords[ 0].layer = 5;
		coords[ 0].u =   0; coords[ 0].v =   0; coords[ 0].layer = 5;
		coords[ 0].u =  63; coords[ 0].v =  63; coords[ 0].layer = 6;
		coords[ 0].u =   7; coords[ 0].v =   0; coords[ 0].layer = 9;
		coords[ 0].u =   0; coords[ 0].v =   3; coords[ 0].layer =10;
		coords[ 0].u =   1; coords[ 0].v =   1; coords[ 0].layer =11;
		coords[ 0].u = 125; coords[ 0].v = 128; coords[ 0].layer = 4;
		coords[ 0].u =   0; coords[ 0].v =   0; coords[ 0].layer =12;
		coords[ 0].u =  30; coords[ 0].v =  31; coords[ 0].layer = 7;

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = -i;

		//		unlock layer
			hr = t[1]->UnlockRect(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}

		//		use UpdateTexture to copy second texture to third
		hr = g_pd3dd8->UpdateTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small again*/);

	//		check bytes in third texture again
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 4) {
				hr = t[1]->LockRect(coords[i].layer -4, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != -i) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer -4);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture to smaller texture*/);
		isbad = false;

	cleanup:
		for (i = 0; i < 3; i++)
		{
			if(t[i]) {
				hr = t[i]->Release();
				CHECKRESULT(hr == 0);
				t[i] = 0;
			}
		}
		
		CHECKLEAKS();
		xEndVariation(hlog);
	}
	ENDTEST()

	#if 0
		BEGINTEST(testTextureUpdateTextureNonSquare)
		{
			/*
			This test does the following:
				create huge texture map (4096x1024x16bit), full mips 
				write random pixels to first texture (multiple layers)
				create second huge texture map (4096x1024x16it), full mips
				use UpdateTexture to copy first texture to second
				delete first texture
				check random pixels in second texture (unswizzled)
				create 256x64x16bit texture map, full mips
				copy lower mip layers from texture2 to texture3
				check texture3
				change pixels in texture2
				copy lower mip layers from texture2 to texture3
				check texture3
				delete texture2, texture3

			this checks:
				big texture
				full mip copy
				16-bit
				partial mip copy
				square texture
				multiple copy from same source
			*/
			DWORD hr;

			IDirect3DTexture8* t[3];
			RECT r;
			D3DLOCKED_RECT l;

			SWIZZLER a (4096, 1024, 0);
			struct COORD {
				DWORD u;
				DWORD v;
				int layer;
			} coords [] = {
				{0, 0, 0},
				{4095, 1023, 0},
				{2048, 512, 0},
				{1022, 34, 2},
				{100, 4, 4},
				{32, 15, 5},
				{0,  3, 8},
				{6, 1, 9},
				{2, 0, 10},
				{0, 0, 11},
				{1, 0, 11},
				{0, 0, 12},
			};
			int i;
			bool isbad = false;

			xStartVariation(hlog, "");
			STARTLEAKCHECK();

		//		create huge texture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
			hr = g_pd3dd8->CreateTexture(4096, 1024, 13, 0, D3DFMT_R5G6B5, D3DPOOL_DEFAULT, &t[0]);
			CHECKRESULT(hr == D3D_OK /*Create huge texture*/);
			if(WASBADRESULT()) {
				goto cleanup;
			}

			for(i = 0; i < COUNTOF(coords); i++) {
			//		lock layer
				hr = t[0]->LockRect(coords[i].layer, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

			//set byte
				((WORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = (WORD)i;

			//		unlock layer
				hr = t[0]->UnlockRect(coords[i].layer);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);

			}

		//		create second huge texture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
			hr = g_pd3dd8->CreateTexture(4096, 1024, 13, 0, D3DFMT_R5G6B5, D3DPOOL_DEFAULT, &t[1]);
			CHECKRESULT(hr == D3D_OK /*Create second huge texture*/);
			if(WASBADRESULT()) {
				goto cleanup;
			}

		//		use UpdateTexture to copy first texture to second
			hr = g_pd3dd8->UpdateTexture(t[0], t[1]);
			CHECKRESULT(hr == D3D_OK /*Update on huge texture*/);

		//		delete first texture
			hr = t[0]->Release();
			CHECKRESULT(hr == 0 /*release first huge texture*/);

		//		check bytes in second texture
			for(i = 0; i < COUNTOF(coords); i++) {
			//		lock layer
				hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

			//compare byte
				if(((WORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != (WORD)i) isbad = true;

			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
			CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture*/);
			isbad = false;

		//		create smaller texture (256x256, full mips, 8bits/pixel), 
			hr = g_pd3dd8->CreateTexture(256, 64, 0, 0, D3DFMT_R5G6B5, D3DPOOL_DEFAULT, &t[2]);
			CHECKRESULT(hr == D3D_OK /*Create 256x256 texture*/);
			if(WASBADRESULT()) {
				goto cleanup;
			}

		//		use UpdateTexture to copy second texture to third
			hr = g_pd3dd8->UpdateTexture(t[1], t[2]);
			CHECKRESULT(hr == D3D_OK /*Update huge->small*/);
			
		//		check bytes in third texture
			for(i = 0; i < COUNTOF(coords); i++) {
			//		lock layer
				if (i >= 4) {
					hr = t[1]->LockRect(coords[i].layer -4, &l, &r, 0); 
					CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
			
				//compare byte
				if(((WORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != i) isbad = true;
			
				//		unlock layer
					hr = t[1]->UnlockRect(coords[i].layer -4);
					CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
				}
			}
			CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture to smaller texture*/);
			isbad = false;

			coords[ 0].u = 255; coords[ 0].v =  63; coords[ 0].layer = 4;
			coords[ 0].u = 254; coords[ 0].v =  63; coords[ 0].layer = 4;
			coords[ 0].u = 185; coords[ 0].v =  25; coords[ 0].layer = 4;
			coords[ 0].u = 120; coords[ 0].v =   0; coords[ 0].layer = 5;
			coords[ 0].u =   0; coords[ 0].v =   0; coords[ 0].layer = 5;
			coords[ 0].u =  63; coords[ 0].v =  15; coords[ 0].layer = 6;
			coords[ 0].u =   7; coords[ 0].v =   0; coords[ 0].layer = 9;
			coords[ 0].u =   0; coords[ 0].v =   3; coords[ 0].layer =10;
			coords[ 0].u =   1; coords[ 0].v =   1; coords[ 0].layer =11;
			coords[ 0].u = 125; coords[ 0].v =  32; coords[ 0].layer = 4;
			coords[ 0].u =   0; coords[ 0].v =   0; coords[ 0].layer =12;
			coords[ 0].u =  30; coords[ 0].v =   5; coords[ 0].layer = 7;

			for(i = 0; i < COUNTOF(coords); i++) {
			//		lock layer
				hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

			//set byte
				((WORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = (WORD)(-i);

			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}

			//		use UpdateTexture to copy second texture to third
			hr = g_pd3dd8->UpdateTexture(t[1], t[2]);
			CHECKRESULT(hr == D3D_OK /*Update huge->small again*/);

		//		check bytes in third texture again
			for(i = 0; i < COUNTOF(coords); i++) {
			//		lock layer
				if (i >= 4) {
					hr = t[1]->LockRect(coords[i].layer -4, &l, &r, 0); 
					CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
			
				//compare byte
				if(((WORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != (WORD)(-i)) isbad = true;
			
				//		unlock layer
					hr = t[1]->UnlockRect(coords[i].layer -4);
					CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
				}
			}
			CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture to smaller texture*/);
			isbad = false;


		cleanup:
			for(i = 0; i < 3; i++) {
				if(t[i] != NULL) {
					hr = t[i]->Release();
					CHECKRESULT(hr == 0);
					t[i] = NULL;
				}
			}

			CHECKLEAKS();
			xEndVariation(hlog);
		}
		ENDTEST()

		BEGINTEST(testTextureUpdateTextureNonSquare2)
		{
			/*
			This test does the following:
				create huge texture map (16x2048x32bit), 6 mip layers 
				write random pixels to first texture (multiple layers)
				create second huge texture map (2048x16x32it), 6 mip layers
				use UpdateTexture to copy first texture to second
				delete first texture
				check random pixels in second texture (unswizzled)
				create 1x64 texture map, 1 layer
				copy lowest mip layers from texture2 to texture3
				check texture3
				change pixels in texture2
				copy lowest mip layer from texture2 to texture3
				check texture3
				delete texture2, texture3

			this checks:
				big texture
				32-bit
				1-layer mip copy
				non-square texture
				multiple copy from same source
			*/
			
			DWORD hr;

			IDirect3DTexture8* t[3];
			RECT r;
			D3DLOCKED_RECT l;

			SWIZZLER a (16, 2048, 0);
			struct COORD {
				DWORD u;
				DWORD v;
				int layer;
			} coords [] = {
				{0, 0, 0},
				{15, 2047, 0},
				{7, 1821, 0},
				{5, 1000, 1},
				{1, 34, 2},
				{0, 4, 4},
				{0, 17, 5},
			};
			int i;
			bool isbad = false;

			xStartVariation(hlog, "Texture UpdateTexture");
			STARTLEAKCHECK();

		//		create huge texture (16x1024, 6 mip layers, 32bits/pixel), 
			hr = g_pd3dd8->CreateTexture(16, 2048, 6, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t[0]);
			CHECKRESULT(hr == D3D_OK /*Create huge texture*/);
			if(WASBADRESULT()) {
				goto cleanup;
			}

			for(i = 0; i < COUNTOF(coords); i++) {
			//		lock layer
				hr = t[0]->LockRect(coords[i].layer, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

			//set byte
				((DWORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = (DWORD)i;

			//		unlock layer
				hr = t[0]->UnlockRect(coords[i].layer);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);

			}

		//		create second huge texture (4096x4096, 6 mip layers, 32bits/pixel), 
			hr = g_pd3dd8->CreateTexture(16, 2048, 6, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t[1]);
			CHECKRESULT(hr == D3D_OK /*Create second huge texture*/);
			if(WASBADRESULT()) {
				goto cleanup;
			}

		//		use UpdateTexture to copy first texture to second
			hr = g_pd3dd8->UpdateTexture(t[0], t[1]);
			CHECKRESULT(hr == D3D_OK /*Update on huge texture*/);

		//		delete first texture
			hr = t[0]->Release();
			t[0] = 0;
			CHECKRESULT(hr == 0 /*release first huge texture*/);

		//		check bytes in second texture
			for(i = 0; i < COUNTOF(coords); i++) {
			//		lock layer
				hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

			//compare byte
				if(((DWORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != (DWORD)i) isbad = true;

			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
			CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture*/);
			isbad = false;

		//		create smaller texture (256x256, 1 layer, 32bits/pixel), 
			hr = g_pd3dd8->CreateTexture(1, 64, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t[2]);
			CHECKRESULT(hr == D3D_OK /*Create 256x256 texture*/);
			if(WASBADRESULT()) {
				goto cleanup;
			}

		//		use UpdateTexture to copy second texture to third
			hr = g_pd3dd8->UpdateTexture(t[1], t[2]);
			CHECKRESULT(hr == D3D_OK /*Update huge->small*/);
			
		//		check bytes in third texture
			for(i = 0; i < COUNTOF(coords); i++) {
			//		lock layer
				if (i >= 4) {
					hr = t[1]->LockRect(coords[i].layer -4, &l, &r, 0); 
					CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
			
				//compare byte
				if(((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != i) isbad = true;
			
				//		unlock layer
					hr = t[1]->UnlockRect(coords[i].layer -4);
					CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
				}
			}
			CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture to smaller texture*/);
			isbad = false;

			coords[ 0].u = 0; coords[ 0].v =  63; coords[ 0].layer = 6;
			coords[ 1].u = 0; coords[ 1].v =  21; coords[ 1].layer = 6;
			coords[ 2].u = 0; coords[ 2].v =   0; coords[ 2].layer = 6;
			coords[ 3].u = 0; coords[ 3].v =  13; coords[ 3].layer = 6;
			coords[ 4].u = 0; coords[ 4].v =  11; coords[ 4].layer = 6;
			coords[ 5].u = 0; coords[ 5].v =  62; coords[ 5].layer = 6;
			coords[ 6].u = 0; coords[ 6].v =  14; coords[ 6].layer = 6;

			for(i = 0; i < COUNTOF(coords); i++) {
			//		lock layer
				hr = t[1]->LockRect(coords[i].layer, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

			//set byte
				((DWORD*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] = (DWORD)(2*i);

			//		unlock layer
				hr = t[1]->UnlockRect(coords[i].layer);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}

			//		use UpdateTexture to copy second texture to third
			hr = g_pd3dd8->UpdateTexture(t[1], t[2]);
			CHECKRESULT(hr == D3D_OK /*Update huge->small again*/);

		//		check bytes in third texture again
			for(i = 0; i < COUNTOF(coords); i++) {
			//		lock layer
				if (i >= 4) {
					hr = t[1]->LockRect(coords[i].layer -6, &l, &r, 0); 
					CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
			
				//compare byte
				if(((BYTE*)l.pBits)[coords[i].u + l.Pitch * coords[i].v] != DWORD(2*i)) isbad = true;
			
				//		unlock layer
					hr = t[1]->UnlockRect(coords[i].layer -6);
					CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
				}
			}
			CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture to smaller texture*/);
			isbad = false;

		cleanup:
			for(i = 0; i < 3; i++) {
				if(t[i] != NULL) {
					hr = t[i]->Release();
					CHECKRESULT(hr == 0);
				}
			}

			CHECKLEAKS();
			xEndVariation(hlog);
		}
		ENDTEST()
	#endif

#endif

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\volumetexture.cpp ===
#include "d3dapi.hpp"
#include "swizzler.h"

LINKME(9)

static D3DFORMAT TextureTypes[] = {
//    D3DFMT_R8G8B8,
    D3DFMT_A8R8G8B8,
    D3DFMT_X8R8G8B8,
    D3DFMT_R5G6B5,
    D3DFMT_X1R5G5B5,
    D3DFMT_A1R5G5B5,
    D3DFMT_A4R4G4B4,
 //   D3DFMT_R3G3B2,
    D3DFMT_A8,
//    D3DFMT_A8R3G3B2,
//    D3DFMT_X4R4G4B4,

//    D3DFMT_A8P8,
    D3DFMT_P8,

    D3DFMT_L8,
    D3DFMT_A8L8,
//    D3DFMT_A4L4,

//    D3DFMT_UYVY,
//    D3DFMT_YUY2,
  D3DFMT_DXT1,
///  D3DFMT_DXT2,
  D3DFMT_DXT3,
  D3DFMT_DXT4,
///  D3DFMT_DXT5
};

static DWORD Usages[] = {
	0, D3DUSAGE_DEPTHSTENCIL, D3DUSAGE_RENDERTARGET, D3DUSAGE_DEPTHSTENCIL | D3DUSAGE_RENDERTARGET
};

static struct {UINT x; UINT y; UINT z;} Sizes[] = {
	{ 4,  4, 4},
	{ 8,  8, 8},
	{16, 16, 16},
	{32, 32, 32},
	{64, 64, 64},
	{ 4, 64, 32}
};

static DWORD Levels[] = {
	0, 1, 2
};

static struct volumestuffstruct {
	D3DFORMAT f;
	UINT bitdepth;
	UINT width;
	UINT height;
	UINT depth;
	UINT count;
	UINT expected;
} VolumeStuff[] = {
	{  D3DFMT_A8R8G8B8, 32, 128,  128,  512,  0, 10}, //38mb
	{  D3DFMT_A8R8G8B8, 32, 512,  512,   32,  1,  1}, //32mb
	{  D3DFMT_A8R8G8B8, 32, 512,  512,    8,  0, 10},
	{  D3DFMT_A8R8G8B8, 32, 128,  128,  128,  4,  4},
	{  D3DFMT_A8R8G8B8, 32,   1,  512,    4,  0, 10},
	{  D3DFMT_A8R8G8B8, 32,   4,    4,    4,  0,  3},
	{  D3DFMT_A8R8G8B8, 32,   2,    2,    2,  0,  2},
	{  D3DFMT_A8R8G8B8, 32,   1,    1,    1,  0,  1},

	{    D3DFMT_R5G6B5, 16,  64,   64,   16,  5,  5},
	{    D3DFMT_R5G6B5, 16, 512,  128,  256,  0, 10},

	{        D3DFMT_A8,  8,   1,    1,    1,  1,  1},
	{        D3DFMT_A8,  8,   1,   64,    1,  0,  7},
	{        D3DFMT_A8,  8, 256,  256,  512,  2,  2},
	
};

#pragma data_seg(".d3dapi$test120") 



BEGINTEST(testCreateVolumeTexture)
{
	IDirect3DVolumeTexture8* t;
	DWORD hr;
	int a, b, c, d;

	xStartVariation(hlog, "CreateTexture, Formats Loop");
	STARTLEAKCHECK();

	for(a = 0; a < COUNTOF(TextureTypes); a++) {
		hr = g_pd3dd8->CreateVolumeTexture(64, 64, 64, 0, 0, TextureTypes[a], D3DPOOL_DEFAULT, &t);
		CHECKRESULT(hr == D3D_OK);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "x: %d, y: %d, z: %d, Lev: %d, Usage: %d, Format: %d",
				64, 64, 64, 0, 0, TextureTypes[a]);
			break;
		}
		hr = t->Release();
		CHECKRESULT(hr == 0);
	}

	CHECKLEAKS();
	xEndVariation(hlog);
	xStartVariation(hlog, "CreateVolumeTexture, Size & Levels Loop");
	STARTLEAKCHECK();

	for(b = 0; b < COUNTOF(Sizes); b++) {
	for(c = 0; c < COUNTOF(Levels); c++) {
	for(d = 0; d < COUNTOF(Usages); d++) {
		hr = g_pd3dd8->CreateVolumeTexture(Sizes[b].x, Sizes[b].y, Sizes[b].z, 
			Levels[c], Usages[d], D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t);
		CHECKRESULT(hr == D3D_OK);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "x: %d, y: %d, z: %d, Lev: %d, Usage: %d, Format: %d",
				Sizes[b].x, Sizes[b].y,	Sizes[b].z,	Levels[c], Usages[d], D3DFMT_A8R8G8B8);
			break;
		}
		hr = t->Release();
		CHECKRESULT(hr == 0);
	}
	}
	}

	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()


BEGINTEST(testVolumeTextureGetDevice)
{
	DWORD hr;
	IDirect3DVolumeTexture8* t;
	IDirect3DDevice8* d;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();
	hr = g_pd3dd8->CreateVolumeTexture(64, 64, 64, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t);
	CHECKRESULT(hr == D3D_OK);
	hr = t->GetDevice(&d);
	CHECKRESULT(hr == D3D_OK);
	CHECKRESULT(d == g_pd3dd8);
	d->Release();
	CHECKRESULT(t->Release() == 0);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testVolumeTextureGetType)
{
	DWORD hr;
	IDirect3DVolumeTexture8* t;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();
	hr = g_pd3dd8->CreateVolumeTexture(64, 64, 64, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &t);
	CHECKRESULT(hr == D3D_OK);
	CHECKRESULT(t->GetType() == D3DRTYPE_VOLUMETEXTURE);
	CHECKRESULT(t->Release() == 0);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testVolumeTextureIsBusy)
{
	//#pragma TODO("test IsBusy")
}
ENDTEST()

BEGINTEST(testVolumeTextureGetLevelCount)
{
	DWORD hr;
	IDirect3DVolumeTexture8* t;
	int i;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(VolumeStuff); i++) {
		hr = g_pd3dd8->CreateVolumeTexture(VolumeStuff[i].width, VolumeStuff[i].height, VolumeStuff[i].depth, VolumeStuff[i].count, 0, VolumeStuff[i].f, D3DPOOL_DEFAULT, &t);
		CHECKRESULT(hr == D3D_OK);
		if(WASGOODRESULT()) {
			CHECKRESULT(t->GetLevelCount() == VolumeStuff[i].expected);
			if(WASBADRESULT()) xLog(hlog, XLL_INFO, "GetLevelCount returned %d, should be %d",
				t->GetLevelCount(), VolumeStuff[i].expected);
			CHECKRESULT(t->Release() == 0);
		}
	}
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()


BEGINTEST(testVolumeTextureGetLevelDesc)
{
	DWORD hr;
	IDirect3DVolumeTexture8* t;
	D3DVOLUME_DESC dd;
	int i;
	unsigned int j;
	UINT w, h, d;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(VolumeStuff); i++) {
		hr = g_pd3dd8->CreateVolumeTexture(VolumeStuff[i].width, VolumeStuff[i].height, VolumeStuff[i].depth, VolumeStuff[i].count, 0, VolumeStuff[i].f, D3DPOOL_DEFAULT, &t);
		w = VolumeStuff[i].width; 
		h = VolumeStuff[i].height;
		d = VolumeStuff[i].depth;
		CHECKRESULT(hr == D3D_OK);
		if(WASGOODRESULT()) {
	//		CHECKRESULT(t->GetLevelCount() == VolumeStuff[i].expected);
			for(j = 0; j < t->GetLevelCount(); j++) {
				t->GetLevelDesc(j, &dd);
				CHECKRESULT(dd.Width == w);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "width was: %d, should be %d", dd.Width, w);
				CHECKRESULT(dd.Height == h);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "height was: %d, should be %d", dd.Height, h);
				CHECKRESULT(dd.Depth == d);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "depth was: %d, should be %d", dd.Depth, d);
				CHECKRESULT(dd.Size == w * h * d * VolumeStuff[i].bitdepth/8);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "size was: %d, should be %d", dd.Size, w * h * d * VolumeStuff[i].bitdepth/8);
				CHECKRESULT(dd.Format == VolumeStuff[i].f);
				if(WASBADRESULT()) xLog(hlog, XLL_INFO, "width was: %d, should be %d", dd.Format, VolumeStuff[i].f);
				w = (w >> 1) ? (w >> 1) : 1;
				h = (h >> 1) ? (h >> 1) : 1;
				d = (d >> 1) ? (d >> 1) : 1;
			}
			CHECKRESULT(t->Release() == 0);
		}
	}
	CHECKRESULT(dd.Type == D3DRTYPE_VOLUMETEXTURE);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

BEGINTEST(testVolumeTextureGetVolumeLevel)
{
	DWORD hr;
	IDirect3DVolumeTexture8* t;
	IDirect3DVolume8* s;
	D3DVOLUME_DESC dd;
	int i;
	unsigned int j;
	UINT w, h, d;

	xStartVariation(hlog, " ");
	STARTLEAKCHECK();

	for(i = 0; i < COUNTOF(VolumeStuff); i++) {
		hr = g_pd3dd8->CreateVolumeTexture(VolumeStuff[i].width, VolumeStuff[i].height, VolumeStuff[i].depth, VolumeStuff[i].count, 0, VolumeStuff[i].f, D3DPOOL_DEFAULT, &t);
		w = VolumeStuff[i].width; 
		h = VolumeStuff[i].height;
		d = VolumeStuff[i].depth;
		CHECKRESULT(hr == D3D_OK);
		if(WASGOODRESULT()) {
			for(j = 0; j < t->GetLevelCount(); j++) {
				t->GetVolumeLevel(j, &s);
				s->GetDesc(&dd);
				CHECKRESULT(dd.Width == w);	// //basically already tested above
				CHECKRESULT(dd.Height == h);
				CHECKRESULT(dd.Size == w * h * d * VolumeStuff[i].bitdepth / 8);
				if(WASBADRESULT()) {
					xLog(hlog, XLL_INFO, "size was: %d, should have been: %d. i%d, w%d, h%d, d%d", 
						dd.Size, w * h * d * VolumeStuff[i].bitdepth / 8, i, w, h, d);
				}
				CHECKRESULT(dd.Format == VolumeStuff[i].f);
				w = (w >> 1) ? (w >> 1) : 1;
				h = (h >> 1) ? (h >> 1) : 1;
				d = (d >> 1) ? (d >> 1) : 1;
				hr = s->Release();
				CHECKRESULT(hr == 0);
			}
			CHECKRESULT(t->Release() == 0);
		}
	}
	CHECKRESULT(dd.Type == D3DRTYPE_VOLUME);
	CHECKLEAKS();
	xEndVariation(hlog);
}
ENDTEST()

#if 0
	BEGINTEST(testVolumeTextureLockAndUnlockBox)
	{
		/*
		This test does the following:
			create huge volume (256x256x256, 9 mip layers, 8bits/pixel == 19 mb), 
			locks the top layer as RAW_DATA
			sets a few random pixels
			unlocks top layer
			locks top layer (unswizzled)
			checks if the pixels tweaked earlier are still set
			locks layer 3 (512x512), (RAW)
			sets a lot more pixels on top layer
			sets some pixels on layer 3
			unlock layer 3, lock layer 3 as unswizzled
			set more pixels on layer 3
			unlocks top layer
			locks top layer (RAW)
			lock bottom layer (RAW)
			create another texture (256x512, 1 mip layer, 32bits/pixel == 128k)
			lock second texture (unswizzled)
			write pixels to second texture
			set a pixel on bottom layer of first texture
			unlock bottom layer of first texture (RAW)
			unlock layer 3 of first texture(RAW)
			unlock second texture (unswizzled)
			checks for corruption of pixels set on RAW top layer
			unlock top layer
			lock top layer
			unlock top layer
			delete first texture
			lock second texture (RAW)
			check for corrupted pixels of second texture
			unlock second texture (RAW)
			delete second texture

		tests:
			huge textures, 
			multiple simultaneous unswizzling of texture levels
			swizzling
			unswizzling
			multiple simultaneous unswizzled textures
			1x1 mip layers
			non-square textures
			8bbp and 32bbp lock/unlock
		*/
		


		DWORD hr;
		IDirect3DVolumeTexture8* t[3] = {0,0,0};
		D3DBOX r;
		D3DLOCKED_BOX l;
		D3DLOCKED_BOX l2;
		D3DLOCKED_BOX l3;
		D3DLOCKED_BOX l4;
		int i, j, k;
		int u, v;
		int p;
		bool isbad = false;

		SWIZZLER a (256, 256, 256);
		SWIZZLER b (256, 512, 2);
		SWIZCOORD coords[32];

		SWIZNUM big_u = a.Convert(31, UCOORD);
		SWIZNUM big_v = a.Convert(19, VCOORD);
		SWIZNUM big_s = a.Convert(32, VCOORD);



		xStartVariation(hlog, "");
		STARTLEAKCHECK();

	//		create huge texture (256x256x256, 9 mip layers, 8bits/pixel == 19.1 mb), 
		hr = g_pd3dd8->CreateVolumeTexture(256, 256, 256, 9, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[0]);
		CHECKRESULT(hr == D3D_OK /*Create huge texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

		r.Top = 0;
		r.Left = 0;
		r.Front = 0;
		r.Right = 255;
		r.Bottom = 255;
		r.Back = 255;

	//		locks the top layer as RAW_DATA
		hr = t[0]->LockBox(0, &l, &r, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock top layer RAW*/);
		CHECKRESULT(l.RowPitch == 256 /*lock top layer RAW*/);
		CHECKRESULT(l.SlicePitch == 256*256 /*lock top layer RAW*/);
		coords[0].Init(  2,   0,   0, &a);
		coords[1].Init(  3,   0,   0, &a);
		coords[2].Init(255, 254,   0, &a);
		coords[3].Init(255, 255,   0, &a);

	//		sets a few random pixels
		((BYTE*)l.pBits)[coords[0].c] = 0;
		((BYTE*)l.pBits)[coords[1].c] = 255;
		((BYTE*)l.pBits)[coords[2].c] = 31;
		((BYTE*)l.pBits)[coords[3].c] = 41;

	//		unlocks top layer
		hr = t[0]->UnlockBox(0);
		CHECKRESULT(hr == D3D_OK /*unlock top layer RAW*/);
		
	//		locks top layer (unswizzled)
		hr = t[0]->LockBox(0, &l, &r, 0); 
		CHECKRESULT(hr == D3D_OK /*lock top layer unswizzled*/);
		CHECKRESULT(l.RowPitch == 256 /*lock top layer unswizzled*/);
		CHECKRESULT(l.SlicePitch == 256 * 256 /*lock top layer unswizzled*/);

	//		checks if the pixels tweaked earlier are still set
		if(((BYTE*)l.pBits)[coords[0].i] != 0) isbad = true;
		if(((BYTE*)l.pBits)[coords[1].i] != 255) isbad = true;
		if(((BYTE*)l.pBits)[coords[2].i] != 31) isbad = true;
		if(((BYTE*)l.pBits)[coords[3].i] != 41) isbad = true;
		CHECKRESULT(isbad == false /*swizzle didn't work right*/);
		isbad = false;

	//		locks layer 3 (512x512), (RAW)
		hr = t[0]->LockBox(3, &l2, NULL, D3DLOCK_RAWDATA); //this should be a 512x512 texture (swizzled)
		CHECKRESULT(hr == D3D_OK /*second mipmap lock*/);

	//		sets a lot more pixels on top layer
		for(k = 0; k < 256; k += 32) {
			for(j = 0; j < 256; j += 19) {
				for(i = 0; i < 256; i += 31) {
					((BYTE*)l.pBits)[i + j * l.RowPitch + k * l.SlicePitch] = i + j * (k - 1);
				}
			}
		}

	//		sets some pixels on layer 3
		for(k = 0; k < 32; k++) {
			for(j = 0; j < 32; j++) {
				for(i = 0; i < 32; i++) {
					((BYTE*)l2.pBits)[i + j * l2.RowPitch + k * l2.SlicePitch] = 1;
				}
			}
		}

	//		unlocks top layer
		hr = t[0]->UnlockBox(0);
		CHECKRESULT(hr == D3D_OK /*swizzled texture unlock*/);

	//		locks top layer (RAW)
		hr = t[0]->LockBox(0, &l, &r, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock top layer RAW*/);
		CHECKRESULT(l.RowPitch == 256 /*lock top layer RAW*/);
		CHECKRESULT(l.SlicePitch == 65536 /*lock top layer RAW*/);

	//		lock bottom layer (RAW)
		hr = t[0]->LockBox(8, &l3, NULL, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock bottom layer RAW*/);
		CHECKRESULT(l3.RowPitch == 1 /*lock bottom layer RAW*/);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "RowPitch was %d, should be %d", l3.RowPitch, 1);
		}
		CHECKRESULT(l3.SlicePitch == 1 /*lock bottom layer RAW*/);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "SlicePitch was %d, should be %d", l3.SlicePitch, 1);
		}

	//		create another texture (256x512x2, 1 mip layer, 32bits/pixel == 128k)
		hr = g_pd3dd8->CreateVolumeTexture(256, 512, 2, 1, 0, D3DFMT_R8G8B8A8, D3DPOOL_DEFAULT, &t[1]);
		CHECKRESULT(hr == D3D_OK /*create second texture while first is unlocked*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

	//		lock second texture (unswizzled)
		hr = t[1]->LockBox(0, &l4, NULL, 0); 
		CHECKRESULT(hr == D3D_OK);
		CHECKRESULT(l.RowPitch == 256 * sizeof(DWORD));
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "RowPitch was %d, should be %d", l.RowPitch, 256*sizeof(DWORD));
		}
		CHECKRESULT(l.SlicePitch == 256 * 512 * sizeof(DWORD));
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "SlicePitch was %d, should be %d", l.SlicePitch, 256*512*sizeof(DWORD));
		}

	//		write pixels to second texture
		coords[10].Init(   0,    0, 0, &b);
		coords[11].Init(   1,    0, 1, &b);
		coords[12].Init(   2,    0, 0, &b);
		coords[13].Init( 211,  255, 1, &b);
		coords[14].Init(  30,  255, 0, &b);
		coords[15].Init(  31,  255, 0, &b);
		((DWORD*)l4.pBits)[coords[10].i] = 0x12345678;
		((DWORD*)l4.pBits)[coords[11].i] = 0x11111111;
		((DWORD*)l4.pBits)[coords[12].i] = 0x33445566;
		((DWORD*)l4.pBits)[coords[13].i] = 0x91807f6e;
		((DWORD*)l4.pBits)[coords[14].i] = 0xfffefdfc;
		((DWORD*)l4.pBits)[coords[15].i] = 0x01020304;

	//		set a pixel on bottom layer of first texture
		*((BYTE*)l3.pBits) = 255;

	//		unlock bottom layer of first texture(RAW)
		hr = t[0]->UnlockBox(8);
		CHECKRESULT(hr == D3D_OK /*bottom-layer mipmap unlock*/);

	//		unlock layer 3 of first texture(RAW)
		hr = t[0]->UnlockBox(3);
		CHECKRESULT(hr == D3D_OK /*layer 3 mipmap unlock*/);

	//		unlock second texture (unswizzled)
		hr = t[1]->UnlockBox(0);
		CHECKRESULT(hr == D3D_OK /*second texture unlock*/);

	//		checks for corruption of pixels set on RAW top layer

		a.Set(0,SCOORD);
		for(k = 0; k < 256; k += 32) {
			a.Set(0,VCOORD);
			for(j = 0; j < 256; j += 19) {
				a.Set(0,UCOORD);
				for(i = 0; i < 256; i += 31) {
					if(((BYTE*)l.pBits)[a.Get3()] != i + j * (k - 1)) {isbad = true; break;}
					a.Add(big_u, UCOORD);
				}
				a.Add(big_v, VCOORD);
			}
			a.Add(big_v, VCOORD);
		}
		CHECKRESULT(isbad == false /*unswizzle of top layer didn't work right*/ );
		isbad = false;

	//		unlock top layer
		hr = t[0]->UnlockBox(0);
		CHECKRESULT(hr == D3D_OK /*unlock top layer*/);

	//		locks top layer (unswizzled)
		hr = t[0]->LockBox(0, &l, &r, 0); 
		CHECKRESULT(hr == D3D_OK /*second unswizzling of top layer*/);
		CHECKRESULT(l.RowPitch == 256 /*lock top layer of first texture*/);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "RowPitch was %d, should be %d", l.RowPitch, 256);
		}
		CHECKRESULT(l.SlicePitch == 65536 /*lock top layer of first texture*/);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "Slicepitch was %d, should be %d", l.SlicePitch, 65536);
		}

	//		unlock top layer
		hr = t[0]->UnlockBox(0);
		CHECKRESULT(hr == D3D_OK /*second reswizzling of top layer*/);

	//		delete first texture
		hr = t[0]->Release();
		CHECKRESULT(hr == 0 /*release first texture*/);
		t[0] = 0;

	//		lock second texture (RAW)
		hr = t[1]->LockBox(0, &l4, NULL, D3DLOCK_RAWDATA); 
		CHECKRESULT(hr == D3D_OK /*lock second texture, RAW*/);
		CHECKRESULT(l.RowPitch == 256 * sizeof(DWORD) /*second texture RAW*/);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "RowPitch was %d, should be %d", l.RowPitch, 256*sizeof(DWORD));
		}
		CHECKRESULT(l.SlicePitch == 512 * 256 * sizeof(DWORD) /*second texture RAW*/);
		if(WASBADRESULT()) {
			xLog(hlog, XLL_INFO, "Slicepitch was %d, should be %d", l.SlicePitch, 256*512*sizeof(DWORD));
		}

	//		check for corrupted pixels of second texture
		if(((DWORD*)l4.pBits)[coords[10].c] != 0x12345678) isbad = true;
		if(((DWORD*)l4.pBits)[coords[11].c] != 0x11111111) isbad = true;
		if(((DWORD*)l4.pBits)[coords[12].c] != 0x33445566) isbad = true;
		if(((DWORD*)l4.pBits)[coords[13].c] != 0x91807f6e) isbad = true;
		if(((DWORD*)l4.pBits)[coords[14].c] != 0xfffefdfc) isbad = true;
		if(((DWORD*)l4.pBits)[coords[15].c] != 0x01020304) isbad = true;
		CHECKRESULT(isbad == false /*corrupted pixels of second texture*/);

		//		unlock second texture (RAW)
		hr = t[1]->UnlockBox(0);
		CHECKRESULT(hr == D3D_OK /*second texture unlock*/);

	cleanup:
		for(i = 0; i < 3; i++) {
			if(t[i] != NULL) {
				hr = t[i]->Release();
				CHECKRESULT(hr == 0);
				t[i] = 0;
			}
		}

	//check for leaks
		CHECKLEAKS();
		xEndVariation(hlog);
	}
	ENDTEST()



	BEGINTEST(testVolumeTextureUpdateTexture)
	{
		/*
		This test does the following:
			create huge volume map (256x256x256x8bit), full mips (19 mb)
			write random pixels to first texture (multiple layers)
			create second huge texture map (256x256x256x8bit), full mips
			use UpdateTexture to copy first texture to second
			delete first texture
			check random pixels in second texture (unswizzled)
			create 8x8x8 volume map, full mips
			copy lower mip layers from texture2 to texture3
			check texture3
			change pixels in texture2
			copy lower mip layers from texture2 to texture3
			check texture3
			delete texture2, texture3

		this checks:
			big texture
			full mip copy
			8-bit
			partial mip copy
			square texture
			multiple copy from same source
		*/

		DWORD hr;

		IDirect3DVolumeTexture8* t[3] = {0,0,0};
		D3DBOX r;
		D3DLOCKED_BOX l;

		SWIZZLER a (256, 256, 256);
		struct COORD {
			DWORD u;
			DWORD v;
			DWORD s;
			int layer;
		} coords [] = {
			{0, 0, 0, 0},
			{255, 255, 255, 0},
			{1, 0, 0, 0},
			{0, 1, 0, 0},
			{0, 0, 1, 0},
			{32, 32, 5, 1},
			{63, 63, 63, 2},
			{38, 23, 19, 3},
			{2, 3, 10, 4},
			{3, 3, 10, 4},
			{1, 0, 1, 7},
			{0, 0, 0, 8},
		};
		int i;
		bool isbad = false;

		xStartVariation(hlog, " ");
		STARTLEAKCHECK();

	//		create huge texture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateVolumeTexture(256, 256, 256, 9, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[0]);
		CHECKRESULT(hr == D3D_OK /*Create huge texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[0]->LockBox(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((BYTE*)l.pBits)[coords[i].u + l.RowPitch * coords[i].v + l.SlicePitch * coords[i].s] = (BYTE)i;

		//		unlock layer
			hr = t[0]->UnlockBox(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);

		}

	//		create second huge texture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateVolumeTexture(256, 256, 256, 9, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[1]);
		CHECKRESULT(hr == D3D_OK /*Create second huge texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

	//		use UpdateTexture to copy first texture to second
		hr = g_pd3dd8->UpdateTexture(t[0], t[1]);
		CHECKRESULT(hr == D3D_OK /*Update on huge texture*/);

	//		delete first texture
		hr = t[0]->Release();
		CHECKRESULT(hr == 0 /*release first huge texture*/);
		t[0] = 0;

	//		check bytes in second texture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockBox(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.RowPitch * coords[i].v + l.SlicePitch * coords[i].s] != (BYTE)i) isbad = true;

		//		unlock layer
			hr = t[1]->UnlockBox(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture*/);
		isbad = false;

	//		create smaller texture (256x256, full mips, 8bits/pixel), 
		hr = g_pd3dd8->CreateVolumeTexture(8, 8, 8, 0, 0, D3DFMT_A8, D3DPOOL_DEFAULT, &t[2]);
		CHECKRESULT(hr == D3D_OK /*Create 256x256 texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

	//		use UpdateTexture to copy second texture to third
		hr = g_pd3dd8->UpdateTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small*/);
		
	//		check bytes in third texture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 5) {
				hr = t[1]->LockBox(coords[i].layer -5, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.RowPitch * coords[i].v + l.SlicePitch * coords[i].s] != i) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockBox(coords[i].layer -5);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture to smaller texture*/);
		isbad = false;

		coords[ 0].u =   7; coords[ 0].v =   7; coords[ 0].s =   7; coords[ 0].layer = 5;
		coords[ 1].u =   6; coords[ 1].v =   7; coords[ 1].s =   7; coords[ 1].layer = 5;
		coords[ 2].u =   5; coords[ 2].v =   7; coords[ 2].s =   7; coords[ 2].layer = 5;
		coords[ 3].u =   0; coords[ 3].v =   1; coords[ 3].s =   4; coords[ 3].layer = 5;
		coords[ 4].u =   3; coords[ 4].v =   1; coords[ 4].s =   3; coords[ 4].layer = 5;
		coords[ 5].u =   3; coords[ 5].v =   1; coords[ 5].s =   1; coords[ 5].layer = 6;
		coords[ 6].u =   0; coords[ 6].v =   3; coords[ 6].s =   2; coords[ 6].layer = 6;
		coords[ 7].u =   1; coords[ 7].v =   1; coords[ 7].s =   1; coords[ 7].layer = 7;
		coords[ 8].u =   0; coords[ 8].v =   0; coords[ 8].s =   0; coords[ 8].layer = 7;
		coords[ 9].u =   1; coords[ 9].v =   0; coords[ 9].s =   1; coords[ 9].layer = 7;
		coords[10].u =   1; coords[10].v =   0; coords[10].s =   0; coords[10].layer = 7;
		coords[11].u =   0; coords[11].v =   0; coords[11].s =   0; coords[11].layer = 8;

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockBox(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((BYTE*)l.pBits)[coords[i].u + l.RowPitch * coords[i].v + l.SlicePitch * coords[i].s] = -i;

		//		unlock layer
			hr = t[1]->UnlockBox(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}

		//		use UpdateTexture to copy second texture to third
		hr = g_pd3dd8->UpdateTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small again*/);

	//		check bytes in third texture again
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 5) {
				hr = t[1]->LockBox(coords[i].layer -5, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((BYTE*)l.pBits)[coords[i].u + l.RowPitch * coords[i].v + l.SlicePitch * coords[i].s] != -i) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockBox(coords[i].layer -5);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture to smaller texture*/);
		isbad = false;


	cleanup:
		for(i = 0; i < 3; i++) {
			if(t[i] != NULL) {
				hr = t[i]->Release();
				CHECKRESULT(hr == 0);
				t[i] = 0;
			}
		}

		CHECKLEAKS();
		xEndVariation(hlog);
	}
	ENDTEST()

	BEGINTEST(testVolumeTextureUpdateTextureNonSquare)
	{
		/*
		This test does the following:
			create huge texture map (512x8x1024x16bit), full mips 
			write random pixels to first texture (multiple layers)
			create second huge texture map (512x8x1024x16it), full mips
			use UpdateTexture to copy first texture to second
			delete first texture
			check random pixels in second texture (unswizzled)
			create 16x1x32 bit texture map, full mips
			copy lower mip layers from texture2 to texture3
			check texture3
			change pixels in texture2
			copy lower mip layers from texture2 to texture3
			check texture3
			delete texture2, texture3

		this checks:
			big texture
			full mip copy
			16-bit
			partial mip copy
			square texture
			multiple copy from same source
		*/
		DWORD hr;

		IDirect3DVolumeTexture8* t[3] = {0,0,0};
		D3DBOX r;
		D3DLOCKED_BOX l;

		SWIZZLER a (256, 4, 512);
		struct COORD {
			DWORD u;
			DWORD v;
			DWORD s;
			int layer;
		} coords [] = {
			{0, 0, 0, 0},
			{255, 3, 511, 0},
			{1, 0, 0, 0},
			{123, 1, 510, 0},
			{65, 3, 512, 0},
			{79, 1, 238, 1},
			{46, 0, 6, 1},
			{6, 0, 9, 3},
			{2, 0, 10, 5},
			{0, 0, 11, 8},
			{1, 0, 11, 9},
			{0, 0, 12, 10},
		};
		int i;
		bool isbad = false;

		xStartVariation(hlog, "Texture UpdateTexture");
		STARTLEAKCHECK();

	//		create huge texture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateVolumeTexture(256, 4, 512, 0, 0, D3DFMT_R5G6B5, D3DPOOL_DEFAULT, &t[0]);
		CHECKRESULT(hr == D3D_OK /*Create huge texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

		r.Front = r.Left = r.Top = 0;
		r.Bottom = r.Right = r.Back = 1;

		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer

			hr = t[0]->LockBox(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((WORD*)l.pBits)[coords[i].u + l.RowPitch * coords[i].v + l.SlicePitch * coords[i].s] = (WORD)i;

		//		unlock layer
			hr = t[0]->UnlockBox(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);

		}

	//		create second huge texture (4096x4096, 13 mip layers, 8bits/pixel == 22.3 mb), 
		hr = g_pd3dd8->CreateVolumeTexture(256, 4, 512, 0, 0, D3DFMT_R5G6B5, D3DPOOL_DEFAULT, &t[1]);
		CHECKRESULT(hr == D3D_OK /*Create second huge texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

	//		use UpdateTexture to copy first texture to second
		hr = g_pd3dd8->UpdateTexture(t[0], t[1]);
		CHECKRESULT(hr == D3D_OK /*Update on huge texture*/);

	//		delete first texture
		hr = t[0]->Release();
		CHECKRESULT(hr == 0 /*release first huge texture*/);
		t[0] = 0;

	//		check bytes in second texture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockBox(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//compare byte
			if(((WORD*)l.pBits)[coords[i].u + l.RowPitch * coords[i].v + l.SlicePitch * coords[i].s] != (WORD)i) isbad = true;

		//		unlock layer
			hr = t[1]->UnlockBox(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture*/);
		isbad = false;

	//		create smaller texture (256x256, full mips, 8bits/pixel), 
		hr = g_pd3dd8->CreateVolumeTexture(16, 1, 32, 0, 0, D3DFMT_R5G6B5, D3DPOOL_DEFAULT, &t[2]);
		CHECKRESULT(hr == D3D_OK /*Create 256x256 texture*/);
		if(WASBADRESULT()) {
			goto cleanup;
		}

	//		use UpdateTexture to copy second texture to third
		hr = g_pd3dd8->UpdateTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small*/);
		
	//		check bytes in third texture
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 4) {
				hr = t[1]->LockBox(coords[i].layer -4, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((WORD*)l.pBits)[coords[i].u + l.RowPitch * coords[i].v + l.SlicePitch * coords[i].s] != i) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockBox(coords[i].layer -4);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture to smaller texture*/);
		isbad = false;

		coords[ 0].u =   0; coords[ 0].v =   0; coords[ 0].s =   0; coords[ 0].layer = 5;
		coords[ 1].u =  15; coords[ 1].v =   0; coords[ 1].s =  31; coords[ 1].layer = 5;
		coords[ 2].u =  14; coords[ 2].v =   0; coords[ 2].s =  31; coords[ 2].layer = 5;
		coords[ 3].u =  15; coords[ 3].v =   0; coords[ 3].s =  30; coords[ 3].layer = 5;
		coords[ 4].u =  15; coords[ 4].v =   0; coords[ 4].s =  29; coords[ 4].layer = 5;
		coords[ 5].u =   3; coords[ 5].v =   0; coords[ 5].s =   1; coords[ 5].layer = 6;
		coords[ 6].u =   7; coords[ 6].v =   0; coords[ 6].s =   2; coords[ 6].layer = 6;
		coords[ 7].u =   1; coords[ 7].v =   0; coords[ 7].s =   1; coords[ 7].layer = 7;
		coords[ 8].u =   0; coords[ 8].v =   0; coords[ 8].s =   3; coords[ 8].layer = 7;
		coords[ 9].u =   1; coords[ 9].v =   0; coords[ 9].s =   1; coords[ 9].layer = 7;
		coords[10].u =   1; coords[10].v =   0; coords[10].s =   0; coords[10].layer = 7;
		coords[11].u =   0; coords[11].v =   0; coords[11].s =   0; coords[11].layer = 8;
		coords[12].u =   0; coords[12].v =   0; coords[12].s =   0; coords[12].layer = 9;



		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			hr = t[1]->LockBox(coords[i].layer, &l, &r, 0); 
			CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);

		//set byte
			((WORD*)l.pBits)[coords[i].u + l.RowPitch * coords[i].v + l.SlicePitch * coords[i].s] = (WORD)(-i);

		//		unlock layer
			hr = t[1]->UnlockBox(coords[i].layer);
			CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
		}

		//		use UpdateTexture to copy second texture to third
		hr = g_pd3dd8->UpdateTexture(t[1], t[2]);
		CHECKRESULT(hr == D3D_OK /*Update huge->small again*/);

	//		check bytes in third texture again
		for(i = 0; i < COUNTOF(coords); i++) {
		//		lock layer
			if (i >= 4) {
				hr = t[1]->LockBox(coords[i].layer -4, &l, &r, 0); 
				CHECKRESULT(hr == D3D_OK /*locking layer coords[i].layer*/);
		
			//compare byte
			if(((WORD*)l.pBits)[coords[i].u + l.RowPitch * coords[i].v + l.SlicePitch * coords[i].s] != (WORD)(-i)) isbad = true;
		
			//		unlock layer
				hr = t[1]->UnlockBox(coords[i].layer -4);
				CHECKRESULT(hr == D3D_OK /*unlocking layer coords[i].layer*/);
			}
		}
		CHECKRESULT(isbad == false /*checking pixels copied by UpdateTexture to smaller texture*/);
		isbad = false;

	cleanup:
		for(i = 0; i < 3; i++) {
			if(t[i] != NULL) {
				hr = t[i]->Release();
				CHECKRESULT(hr == 0);
				t[i] = NULL;
			}
		}

		CHECKLEAKS();
		xEndVariation(hlog);
	}
	ENDTEST()

#endif

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\uma.cpp ===
#include "d3dapi.hpp"

LINKME(14);

#pragma data_seg(".d3dapi$test032") 


//BEGINTEST(testUmaTextureStuff) 
//{
//
//}
//ENDTEST()

//BEGINTEST(testUmaVertexBuffer) 
//{
//
//}
//ENDTEST()

/*
TODO!!!
BEGINTEST(testUmaPalette)
{
}
ENDTEST()
*/

BEGINTEST(testAllocateAndFreeMemory) 
{
	void* b;
	int i;
	xStartVariation(hlog, "Sizes loop");
	{
		for(i = 0; i <= 25; i++) {
			xLog(hlog, XLL_INFO, "1<<i: %d, (1<<i)-1: %d", (1 << i), (1 << i)-1);

			b = D3D_AllocContiguousMemory((1 << i), 1);
			CHECKRESULT(b != NULL);
			if(WASGOODRESULT()) {
				D3D_FreeContiguousMemory(b);
			}

			if(i) {
				b = D3D_AllocContiguousMemory((1 << i) - 1, 1);
				CHECKRESULT(b != NULL);
				if(WASGOODRESULT()) {
					D3D_FreeContiguousMemory(b);
				}
			}
		}
	}
	xEndVariation(hlog);

}
ENDTEST()

BEGINTEST(testCopyMemory) 
{
	char* buf[2];
	int i, j;

	xStartVariation(hlog, "");
	for(i = 1; i != (1 << 24) / 5 + 1; i += i / 5 + 1) { //loop through a bunch of sizes
		if (i > 28000000) i = (1 << 24);		//when we're done, get a nice big power of 2 also.


		xLog(hlog, XLL_INFO, "Size: %d", i);
		buf[0] = (char*)D3D_AllocContiguousMemory(i, 1);
		buf[1] = (char*)D3D_AllocContiguousMemory(i, 1);
		
		if(!buf[0]) {
			xLog(hlog, XLL_FAIL, "malloc(%d) failed!", i);
			break;
		}
		if(!buf[1]) {
			D3D_FreeContiguousMemory(buf[0]);
			xLog(hlog, XLL_FAIL, "second malloc(%d) failed!", i);
			break;
		}

		for(j = 0; j < i; j++) {
			buf[0][j] = (char)j;
			buf[1][j] = (char)~j;
		}

		D3D_CopyContiguousMemory(buf[0], buf[1], i);

		for(j = 0; j < i; j++) {
			if(buf[0][j] != buf[1][j]) {
				xLog(hlog, XLL_FAIL, "copy didn't work right??? Source byte %d = %d, dest = %d", i, buf[0][j], buf[1][j]);
			}
		}

		D3D_FreeContiguousMemory(buf[0]);
		D3D_FreeContiguousMemory(buf[1]);
		if(i == (1 << 24)) break;
	}
}
ENDTEST()

BEGINTEST(testCopyToVideo)
{
	char* buf;
	int i, j;
	for(i = 1; i != (1 << 24) / 5 + 1; i += i / 5 + 1) { //loop through a bunch of sizes
		if (i > 28000000) i = (1 << 24);		//when we're done, get a nice big power of 2 also.


		xLog(hlog, XLL_INFO, "Size: %d", i);
		buf = (char*)D3D_AllocContiguousMemory(i, 1);
		
		if(!buf) {
			xLog(hlog, XLL_FAIL, "malloc(%d) failed!", i);
			break;
		}

		for(j = 0; j < i; j++) {
			buf[j] = (char)j;
		}

		D3D_CopyContiguousMemoryToVideo(buf);
		//all this test can really do is just make sure that it didn't crash...

		D3D_FreeContiguousMemory(buf);
		if(i == (1 << 24)) break;
	}
} 
ENDTEST()

BEGINTEST(testRegister)
{
	D3DTexture* t;
	D3DTexture* n;

	char* d;

	//g_pd3dd8->CreateTexture(
}
ENDTEST()


#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\exe\sources.inc ===
TARGETNAME=d3dapi
TARGETTYPE=PROGRAM
TARGETPATH=obj


BROWSER_INFO=1
USE_MAPSYM=1

!include ..\..\..\sources.inc

UMRES=$(TEST_RES_PATH)\d3dapi.res

TARGETLIBS=\
    $(TARGETLIBS) \
    $(TEST_LIB_PATH)\l_d3dapi.lib \
    $(TEST_LIB_PATH)\xlog.lib \

SOURCES=\
    main.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\api\exe\main.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    main.cpp

Description:

    Direct3D Build Verification Tests.

*******************************************************************************/

#include <xtl.h>
#include <xlog.h>

extern "C" void D3DAPISTART(HANDLE h);
extern "C" void DebugPrint(char*, ...);


#ifndef UNDER_XBOX
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, int nCmdShow) 
#else
int __cdecl main()
#endif // UNDER_XBOX
{
	HANDLE log;
	WEB_SERVER_INFO wsi = {
		L"",
		L"",
		L"",
		L"",
		L"",
	};

	log = xCreateLog(L"t:\\d3dapi.log", NULL, INVALID_SOCKET, XLL_LOGALL, XLO_DEBUG | XLO_CONFIG | XLO_STATE | XLO_REFRESH);
	DebugPrint("%p\n", log);
	D3DAPISTART(log);
	xCloseLog(log);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\cubetex8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    cubetex8.cpp

Description:

    IDirect3DCubeTexture8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IDirect3DCubeTexture8 inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TCTX8_GetLevelDesc(PTESTTABLEENTRY ptte) {

    LPDIRECT3DCUBETEXTURE8  pd3dtc;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3dtc = GetCubeTexture8();
    if (!pd3dtc) {
        return TR_ABORT;
    }

    return TSHR8_GetLevelDesc(ptte, (LPVOID)pd3dtc);
}

//******************************************************************************
TESTPROCAPI TCTX8_LockRect(PTESTTABLEENTRY ptte) {

    LPDIRECT3DCUBETEXTURE8  pd3dtc;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3dtc = GetCubeTexture8();
    if (!pd3dtc) {
        return TR_ABORT;
    }

    return TSHR8_LockRect(ptte, (LPVOID)pd3dtc);
}

//******************************************************************************
TESTPROCAPI TCTX8_UnlockRect(PTESTTABLEENTRY ptte) {

    LPDIRECT3DCUBETEXTURE8  pd3dtc;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3dtc = GetCubeTexture8();
    if (!pd3dtc) {
        return TR_ABORT;
    }

    return TSHR8_UnlockRect(ptte, (LPVOID)pd3dtc);
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TCTX8_AddDirtyRect(PTESTTABLEENTRY ptte) {

    LPDIRECT3DCUBETEXTURE8  pd3dtc;

    pd3dtc = GetCubeTexture8();
    if (!pd3dtc) {
        return TR_ABORT;
    }

    return TSHR8_AddDirtyRect(ptte, (LPVOID)pd3dtc);
}

#endif // !UNDER_XBOX

//******************************************************************************
TESTPROCAPI TCTX8_GetCubeMapSurface(PTESTTABLEENTRY ptte) {

    LPDIRECT3DCUBETEXTURE8  pd3dtc;

    pd3dtc = GetCubeTexture8();
    if (!pd3dtc) {
        return TR_ABORT;
    }

    return TSHR8_GetSurfaceLevel(ptte, (LPVOID)pd3dtc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\basetex8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    basetex8.cpp

Description:

    IDirect3DBaseTexture8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IDirect3DBaseTexture8 helper functions
//******************************************************************************

//******************************************************************************
LPDIRECT3DBASETEXTURE8 GetBaseTexture8(D3DIFACETYPE d3dift) {

    LPDIRECT3DBASETEXTURE8 pd3dtb = NULL;

    switch (d3dift) {

        case ITEXTURE8:
            pd3dtb = (LPDIRECT3DBASETEXTURE8)GetTexture8();
            break;
        case ICUBETEXTURE8:
            pd3dtb = (LPDIRECT3DBASETEXTURE8)GetCubeTexture8();
            break;
        case IVOLUMETEXTURE8:
            pd3dtb = (LPDIRECT3DBASETEXTURE8)GetVolumeTexture8();
            break;
    }

    return pd3dtb;
}

//******************************************************************************
// IDirect3DBaseTexture8 inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TBTX8_GetLevelCount(PTESTTABLEENTRY ptte) {

    LPDIRECT3DBASETEXTURE8  pd3dtb;
    UINT                    uLevels;
    DWORD                   dwLevels;
    TRESULT                 tr = TR_PASS;

    pd3dtb = GetBaseTexture8(ptte->dwData);
    if (!pd3dtb) {
        return TR_ABORT;
    }

    for (uLevels = 1; 0x1 << (uLevels - 1) != TEXTUREDIM; uLevels++);

    dwLevels = pd3dtb->GetLevelCount();
    if (dwLevels != uLevels) {
        Log(LOG_FAIL, TEXT("%s::GetLevelCount returned an incorrect number of levels: %d"), ptte->szInterface, dwLevels);
        tr = TR_FAIL;
    }

    return tr;
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TBTX8_GetLOD(PTESTTABLEENTRY ptte) {

    LPDIRECT3DBASETEXTURE8  pd3dtb;
    DWORD                   dwLOD;
    TRESULT                 tr = TR_PASS;

    pd3dtb = GetBaseTexture8(ptte->dwData);
    if (!pd3dtb) {
        return TR_ABORT;
    }

    dwLOD = pd3dtb->GetLOD();
    if (dwLOD != 0) {
        Log(LOG_FAIL, TEXT("%s::GetLOD returned a level of detail of %d for a nonmanaged texture"), ptte->szInterface, dwLOD);
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TBTX8_SetLOD(PTESTTABLEENTRY ptte) {

    LPDIRECT3DBASETEXTURE8  pd3dtb;
    UINT                    uLevels;
    DWORD                   dwLOD;
    TRESULT                 tr = TR_PASS;

    pd3dtb = GetBaseTexture8(ptte->dwData);
    if (!pd3dtb) {
        return TR_ABORT;
    }

    for (uLevels = 1; 0x1 << (uLevels - 1) != TEXTUREDIM; uLevels++);

    pd3dtb->SetLOD(rand() % uLevels);

    dwLOD = pd3dtb->SetLOD(rand() % uLevels);
    if (dwLOD != 0) {
        Log(LOG_FAIL, TEXT("%s::SetLOD returned a level of detail of %d for a nonmanaged resource"), ptte->szInterface, dwLOD);
        tr = TR_FAIL;
    }

    return tr;
}

#endif // !UNDER_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\d3d8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    d3d8.cpp

Description:

    IDirect3D8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#ifdef UNDER_XBOX
#define DEMO_HACK
#endif

#ifndef UNDER_XBOX
#define INITIAL_MODE_WIDTH      640
#define INITIAL_MODE_HEIGHT     480
#define INITIAL_MODE_REFRESH    60
#define INITIAL_MODE_FORMAT     D3DFMT_R5G6B5
#else
#define INITIAL_MODE_WIDTH      0
#define INITIAL_MODE_HEIGHT     0
#define INITIAL_MODE_REFRESH    0
#define INITIAL_MODE_FORMAT     0
#endif

//******************************************************************************
// IDirect3D8 inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TD3D8_GetAdapterCount(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8 pd3d;
    UINT        uCount;
    TRESULT     tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    uCount = pd3d->GetAdapterCount();
    if (uCount != 1) {
        Log(LOG_FAIL, TEXT("IDirect3D8::GetAdapterCount returned %d adapters"), uCount);
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TD3D8_GetAdapterDisplayMode(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8     pd3d;
    D3DDISPLAYMODE  d3ddm;
    HRESULT         hr;
    TRESULT         tr = TR_PASS;

    ReleaseDirect3D8();

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    hr = pd3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &d3ddm);
    if (ResultFailed(hr, TEXT("IDirect3D8::GetAdapterDisplayMode"))) {
        return TR_FAIL;
    }

    if (d3ddm.Width != INITIAL_MODE_WIDTH || 
        d3ddm.Height != INITIAL_MODE_HEIGHT ||
        d3ddm.RefreshRate != INITIAL_MODE_REFRESH || 
        d3ddm.Format != INITIAL_MODE_FORMAT)
    {
        Log(LOG_FAIL, TEXT("IDirect3D8::GetAdapterDisplayMode returned an incorrect initial display mode"));
        return TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TD3D8_GetAdapterIdentifier(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8             pd3d;
    D3DADAPTER_IDENTIFIER8  d3dai;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    hr = pd3d->GetAdapterIdentifier(D3DADAPTER_DEFAULT, 0, &d3dai);
    if (ResultFailed(hr, TEXT("IDirect3D8::GetAdapterIdentifier"))) {
        return TR_FAIL;
    }

    // TODO: Verify the adapter identifier fields

    return tr;
}

//******************************************************************************
TESTPROCAPI TD3D8_GetAdapterModeCount(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8 pd3d;
    UINT        uNumModes;
    TRESULT     tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    uNumModes = pd3d->GetAdapterModeCount(D3DADAPTER_DEFAULT);

    // TODO: Verify the correct number of modes are returned for each output type
    Log(LOG_COMMENT, TEXT("IDirect3D8::GetAdapterModeCount returned %d modes"), uNumModes);

    return tr;
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TD3D8_GetAdapterMonitor(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8 pd3d;
    HMONITOR    hmon;
    HRESULT     hr;
    TRESULT     tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    hmon = pd3d->GetAdapterMonitor(D3DADAPTER_DEFAULT);
    if (hmon != NULL) {
        Log(LOG_FAIL, TEXT("IDirect3D8::GetAdapterMonitor"));
        return TR_FAIL;
    }

    return tr;
}

#endif // !UNDER_XBOX

//******************************************************************************
TESTPROCAPI TD3D8_GetDeviceCaps(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8 pd3d;
    D3DCAPS8    d3dcaps;
    HRESULT     hr;
    TRESULT     tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    hr = pd3d->GetDeviceCaps(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, &d3dcaps);
    if (ResultFailed(hr, TEXT("IDirect3D8::GetDeviceCaps"))) {
        return TR_FAIL;
    }

    // TODO: Verify the device caps

    return tr;
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TD3D8_RegisterSoftwareDevice(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8 pd3d;
    TCHAR       szError[512];
    HRESULT     hr;
    TRESULT     tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    hr = pd3d->RegisterSoftwareDevice((LPVOID)TD3D8_RegisterSoftwareDevice);
    if (hr != E_NOTIMPL) {
        D3DXGetErrorString(hr, szError, 512);
        Log(LOG_FAIL, TEXT("IDirect3D8::RegisterSoftwareDevice returned %s instead of D3DERR_UNSUPPORTED"), szError);
        tr = TR_FAIL;
    }

    return tr;
}

#endif // !UNDER_XBOX

//******************************************************************************
TESTPROCAPI TD3D8_CheckDeviceFormat(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8 pd3d;
    HRESULT     hr;
    TRESULT     tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    hr = pd3d->CheckDeviceFormat(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, D3DFMT_R5G6B5, 0, D3DRTYPE_TEXTURE, D3DFMT_A4R4G4B4);
    if (hr != D3D_OK) {
        tr = TR_FAIL;
    }

    hr = pd3d->CheckDeviceFormat(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, D3DFMT_R5G6B5, D3DUSAGE_RENDERTARGET, D3DRTYPE_TEXTURE, D3DFMT_A4R4G4B4);
    if (hr != D3DERR_NOTAVAILABLE) {
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TD3D8_CheckDeviceMultiSampleType(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8 pd3d;
    HRESULT     hr;
    TRESULT     tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

#ifndef UNDER_XBOX
    hr = pd3d->CheckDeviceMultiSampleType(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, D3DFMT_R5G6B5, FALSE, D3DMULTISAMPLE_4_SAMPLES);
#else
    hr = pd3d->CheckDeviceMultiSampleType(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, D3DFMT_R5G6B5, FALSE, D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR);
#endif
    if (ResultFailed(hr, TEXT("IDirect3D8::CheckDeviceMultisampleType"))) {
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TD3D8_CheckDeviceType(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8 pd3d;
    HRESULT     hr;
    TRESULT     tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    hr = pd3d->CheckDeviceType(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, D3DFMT_X1R5G5B5, D3DFMT_X1R5G5B5, FALSE);
    if (ResultFailed(hr, TEXT("IDirect3D8::CheckDeviceType"))) {
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TD3D8_CheckDepthStencilMatch(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8 pd3d;
    HRESULT     hr;
    TRESULT     tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

#ifndef UNDER_XBOX
    hr = pd3d->CheckDepthStencilMatch(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, D3DFMT_X8R8G8B8, D3DFMT_A8R8G8B8, D3DFMT_D24S8);
#else
    hr = pd3d->CheckDepthStencilMatch(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, D3DFMT_LIN_X8R8G8B8, D3DFMT_A8R8G8B8, D3DFMT_LIN_F24S8);
#endif
    if (ResultFailed(hr, TEXT("IDirect3D8::CheckDeviceType"))) {
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TD3D8_CreateDevice(PTESTTABLEENTRY ptte) {

    D3DPRESENT_PARAMETERS   d3dpp;
    LPDIRECT3D8             pd3d;
    LPDIRECT3DDEVICE8       pd3dd;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    ReleaseDevice8();

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    // Initialize the presentation parameters
    memset(&d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth                   = 640;
    d3dpp.BackBufferHeight                  = 480;
    d3dpp.BackBufferFormat                  = D3DFMT_A8R8G8B8;
    d3dpp.MultiSampleType                   = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.AutoDepthStencilFormat            = D3DFMT_D24S8;
    d3dpp.FullScreen_RefreshRateInHz        = 0;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_ONE;
    d3dpp.BackBufferCount                   = 2;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                     = NULL;
    d3dpp.Windowed                          = FALSE;
    d3dpp.EnableAutoDepthStencil            = TRUE;

    // Create the device
    hr = pd3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &pd3dd);
    if (ResultFailed(hr, TEXT("IDirect3D8::CreateDevice failed"))) {
        return FALSE;
    }

    // Verify the interface
    d3dpp.EnableAutoDepthStencil = FALSE;
    d3dpp.BackBufferCount = 1;
    pd3dd->Reset(&d3dpp);

    pd3dd->Release();

    return tr;
}

//******************************************************************************
TESTPROCAPI TD3D8_EnumAdapterModes(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8     pd3d;
    D3DDISPLAYMODE  d3ddm;
    UINT            uNumModes, i;
    HRESULT         hr;
    TRESULT         tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    uNumModes = pd3d->GetAdapterModeCount(D3DADAPTER_DEFAULT);

    for (i = 0; i < uNumModes; i++) {
        hr = pd3d->EnumAdapterModes(D3DADAPTER_DEFAULT, i, &d3ddm);
        if (ResultFailed(hr, TEXT("IDirect3D8::EnumAdapterModes"))) {
            tr = TR_FAIL;
        }
        else {
            Log(LOG_COMMENT, TEXT("Adapter mode %d - Width: %4d, Height: %4d, Refresh: %3d, Format: 0x%X"), i, d3ddm.Width, d3ddm.Height, d3ddm.RefreshRate, d3ddm.Format);
        }
    }

    return tr;
}

/*
//******************************************************************************
TESTPROCAPI TD3D8_GetAdapterCount(PTESTTABLEENTRY ptte) {

    LPDIRECT3D8 pd3d;
    HRESULT     hr;
    TRESULT     tr = TR_PASS;

    pd3d = GetDirect3D8();
    if (!pd3d) {
        return TR_ABORT;
    }

    return tr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\d3dbvt.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    d3dbvt.cpp

Description:

    Direct3D Build Verification Tests.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"
#include "util.h"

#ifdef UNDER_XBOX
#define DEMO_HACK
#endif

//******************************************************************************
// Globals
//******************************************************************************

HINSTANCE                       g_hInstance;
HWND                            g_hWnd = NULL;
static LPDIRECT3D8              g_pd3d8 = NULL;
static LPDIRECT3DDEVICE8        g_pd3dd8 = NULL;
static LPDIRECT3DTEXTURE8       g_pd3dt8 = NULL;
static LPDIRECT3DCUBETEXTURE8   g_pd3dtc8 = NULL;
static LPDIRECT3DVOLUMETEXTURE8 g_pd3dtv8 = NULL;
static LPDIRECT3DVERTEXBUFFER8  g_pd3dr8 = NULL;
static LPDIRECT3DINDEXBUFFER8   g_pd3di8 = NULL;
static LPDIRECT3DTEXTURE8       g_pd3dtSurf8 = NULL;
static LPDIRECT3DSURFACE8       g_pd3ds8 = NULL;
static LPDIRECT3DCUBETEXTURE8   g_pd3dtcSurf8 = NULL;
static LPDIRECT3DSURFACE8       g_pd3dsc8 = NULL;
static LPDIRECT3DVOLUMETEXTURE8 g_pd3dtvVol8 = NULL;
static LPDIRECT3DVOLUME8        g_pd3dv8 = NULL;
#ifndef UNDER_XBOX
static LPDIRECT3DSWAPCHAIN8     g_pd3dsw8 = NULL;
#endif // !UNDER_XBOX

GUID GUID_PRIVATEDATA = {
    0x6a2cb1ee, 0x8781, 0x11d1, {0x7c, 0xe9, 0x0, 0xaa, 0x0, 0xbd, 0xcb, 0xb0}
};

//******************************************************************************
// Function prototypes
//******************************************************************************

#ifndef UNDER_XBOX
static LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif // UNDER_XBOX
static BOOL             SetViewport(DWORD dwWidth, DWORD dwHeight);

using namespace D3DBVT;

//******************************************************************************
// Test table
//******************************************************************************
static TESTTABLEENTRY g_pTestTable[] = {

    {TEXT("IDirect3D8"),                 TEXT("AddRef"),                             IDIRECT3D8,        TUNK_AddRef},
    {TEXT("IDirect3D8"),                 TEXT("Release"),                            IDIRECT3D8,        TUNK_Release},
#ifndef UNDER_XBOX
    {TEXT("IDirect3D8"),                 TEXT("QueryInterface"),                     IDIRECT3D8,        TUNK_QueryInterface},
#endif // !UNDER_XBOX
    {TEXT("IDirect3D8"),                 TEXT("GetAdapterCount"),                    0,                 TD3D8_GetAdapterCount},
    {TEXT("IDirect3D8"),                 TEXT("GetAdapterDisplayMode"),              0,                 TD3D8_GetAdapterDisplayMode},
    {TEXT("IDirect3D8"),                 TEXT("GetAdapterIdentifier"),               0,                 TD3D8_GetAdapterIdentifier},
    {TEXT("IDirect3D8"),                 TEXT("GetAdapterModeCount"),                0,                 TD3D8_GetAdapterModeCount},
#ifndef UNDER_XBOX
    {TEXT("IDirect3D8"),                 TEXT("GetAdapterMonitor"),                  0,                 TD3D8_GetAdapterMonitor},
#endif // !UNDER_XBOX
    {TEXT("IDirect3D8"),                 TEXT("GetDeviceCaps"),                      0,                 TD3D8_GetDeviceCaps},
#ifndef UNDER_XBOX
    {TEXT("IDirect3D8"),                 TEXT("RegisterSoftwareDevice"),             0,                 TD3D8_RegisterSoftwareDevice},
#endif // !UNDER_XBOX
    {TEXT("IDirect3D8"),                 TEXT("CheckDeviceFormat"),                  0,                 TD3D8_CheckDeviceFormat},
    {TEXT("IDirect3D8"),                 TEXT("CheckDeviceMultiSampleType"),         0,                 TD3D8_CheckDeviceMultiSampleType},
    {TEXT("IDirect3D8"),                 TEXT("CheckDeviceType"),                    0,                 TD3D8_CheckDeviceType},
    {TEXT("IDirect3D8"),                 TEXT("CheckDepthStencilMatch"),             0,                 TD3D8_CheckDepthStencilMatch},
    {TEXT("IDirect3D8"),                 TEXT("CreateDevice"),                       0,                 TD3D8_CreateDevice},
    {TEXT("IDirect3D8"),                 TEXT("EnumAdapterModes"),                   0,                 TD3D8_EnumAdapterModes},

    {TEXT("IDirect3DDevice8"),           TEXT("AddRef"),                             IDEVICE8,          TUNK_AddRef},
    {TEXT("IDirect3DDevice8"),           TEXT("Release"),                            IDEVICE8,          TUNK_Release},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DDevice8"),           TEXT("QueryInterface"),                     IDEVICE8,          TUNK_QueryInterface},
    {TEXT("IDirect3DDevice8"),           TEXT("CreateAdditionalSwapChain"),          0,                 TDEV8_CreateAdditionalSwapChain},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DDevice8"),           TEXT("CreateCubeTexture"),                  0,                 TDEV8_CreateCubeTexture},
    {TEXT("IDirect3DDevice8"),           TEXT("CreateDepthStencilSurface"),          0,                 TDEV8_CreateDepthStencilSurface},
    {TEXT("IDirect3DDevice8"),           TEXT("CreateImageSurface"),                 0,                 TDEV8_CreateImageSurface},
    {TEXT("IDirect3DDevice8"),           TEXT("CreateIndexBuffer"),                  0,                 TDEV8_CreateIndexBuffer},
    {TEXT("IDirect3DDevice8"),           TEXT("CreateRenderTarget"),                 0,                 TDEV8_CreateRenderTarget},
    {TEXT("IDirect3DDevice8"),           TEXT("CreateTexture"),                      0,                 TDEV8_CreateTexture},
    {TEXT("IDirect3DDevice8"),           TEXT("CreateVertexBuffer"),                 0,                 TDEV8_CreateVertexBuffer},
    {TEXT("IDirect3DDevice8"),           TEXT("CreateVolumeTexture"),                0,                 TDEV8_CreateVolumeTexture},
    {TEXT("IDirect3DDevice8"),           TEXT("ApplyStateBlock"),                    0,                 TDEV8_ApplyStateBlock},
    {TEXT("IDirect3DDevice8"),           TEXT("BeginStateBlock"),                    0,                 TDEV8_BeginStateBlock},
    {TEXT("IDirect3DDevice8"),           TEXT("EndStateBlock"),                      0,                 TDEV8_EndStateBlock},
    {TEXT("IDirect3DDevice8"),           TEXT("CreateStateBlock"),                   0,                 TDEV8_CreateStateBlock},
    {TEXT("IDirect3DDevice8"),           TEXT("DeleteStateBlock"),                   0,                 TDEV8_DeleteStateBlock},
    {TEXT("IDirect3DDevice8"),           TEXT("CaptureStateBlock"),                  0,                 TDEV8_CaptureStateBlock},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DDevice8"),           TEXT("GetClipStatus"),                      0,                 TDEV8_GetClipStatus},
    {TEXT("IDirect3DDevice8"),           TEXT("SetClipStatus"),                      0,                 TDEV8_SetClipStatus},
#endif
    {TEXT("IDirect3DDevice8"),           TEXT("GetRenderState"),                     0,                 TDEV8_GetRenderState},
    {TEXT("IDirect3DDevice8"),           TEXT("SetRenderState"),                     0,                 TDEV8_SetRenderState},
    {TEXT("IDirect3DDevice8"),           TEXT("GetRenderTarget"),                    0,                 TDEV8_GetRenderTarget},
    {TEXT("IDirect3DDevice8"),           TEXT("SetRenderTarget"),                    0,                 TDEV8_SetRenderTarget},
    {TEXT("IDirect3DDevice8"),           TEXT("GetTransform"),                       0,                 TDEV8_GetTransform},
    {TEXT("IDirect3DDevice8"),           TEXT("SetTransform"),                       0,                 TDEV8_SetTransform},
    {TEXT("IDirect3DDevice8"),           TEXT("MultiplyTransform"),                  0,                 TDEV8_MultiplyTransform},
    {TEXT("IDirect3DDevice8"),           TEXT("Clear"),                              0,                 TDEV8_Clear},
    {TEXT("IDirect3DDevice8"),           TEXT("GetViewport"),                        0,                 TDEV8_GetViewport},
    {TEXT("IDirect3DDevice8"),           TEXT("SetViewport"),                        0,                 TDEV8_SetViewport},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DDevice8"),           TEXT("GetClipPlane"),                       0,                 TDEV8_GetClipPlane},
    {TEXT("IDirect3DDevice8"),           TEXT("SetClipPlane"),                       0,                 TDEV8_SetClipPlane},
#endif
    {TEXT("IDirect3DDevice8"),           TEXT("GetLight"),                           0,                 TDEV8_GetLight},
    {TEXT("IDirect3DDevice8"),           TEXT("SetLight"),                           0,                 TDEV8_SetLight},
    {TEXT("IDirect3DDevice8"),           TEXT("LightEnable"),                        0,                 TDEV8_LightEnable},
    {TEXT("IDirect3DDevice8"),           TEXT("GetLightEnable"),                     0,                 TDEV8_GetLightEnable},
    {TEXT("IDirect3DDevice8"),           TEXT("GetMaterial"),                        0,                 TDEV8_GetMaterial},
    {TEXT("IDirect3DDevice8"),           TEXT("SetMaterial"),                        0,                 TDEV8_SetMaterial},
    {TEXT("IDirect3DDevice8"),           TEXT("GetTexture"),                         0,                 TDEV8_GetTexture},
    {TEXT("IDirect3DDevice8"),           TEXT("SetTexture"),                         0,                 TDEV8_SetTexture},
    {TEXT("IDirect3DDevice8"),           TEXT("GetTextureStageState"),               0,                 TDEV8_GetTextureStageState},
    {TEXT("IDirect3DDevice8"),           TEXT("SetTextureStageState"),               0,                 TDEV8_SetTextureStageState},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DDevice8"),           TEXT("UpdateTexture"),                      0,                 TDEV8_UpdateTexture},
    {TEXT("IDirect3DDevice8"),           TEXT("ValidateDevice"),                     0,                 TDEV8_ValidateDevice},
    {TEXT("IDirect3DDevice8"),           TEXT("GetCurrentTexturePalette"),           0,                 TDEV8_GetCurrentTexturePalette},
    {TEXT("IDirect3DDevice8"),           TEXT("SetCurrentTexturePalette"),           0,                 TDEV8_SetCurrentTexturePalette},
    {TEXT("IDirect3DDevice8"),           TEXT("GetPaletteEntries"),                  0,                 TDEV8_GetPaletteEntries},
    {TEXT("IDirect3DDevice8"),           TEXT("SetPaletteEntries"),                  0,                 TDEV8_SetPaletteEntries},
#endif
    {TEXT("IDirect3DDevice8"),           TEXT("CreateVertexShader"),                 0,                 TDEV8_CreateVertexShader},
    {TEXT("IDirect3DDevice8"),           TEXT("DeleteVertexShader"),                 0,                 TDEV8_DeleteVertexShader},
    {TEXT("IDirect3DDevice8"),           TEXT("GetVertexShader"),                    0,                 TDEV8_GetVertexShader},
    {TEXT("IDirect3DDevice8"),           TEXT("SetVertexShader"),                    0,                 TDEV8_SetVertexShader},
    {TEXT("IDirect3DDevice8"),           TEXT("GetVertexShaderConstant"),            0,                 TDEV8_GetVertexShaderConstant},
    {TEXT("IDirect3DDevice8"),           TEXT("SetVertexShaderConstant"),            0,                 TDEV8_SetVertexShaderConstant},
    {TEXT("IDirect3DDevice8"),           TEXT("GetVertexShaderDeclaration"),         0,                 TDEV8_GetVertexShaderDeclaration},
    {TEXT("IDirect3DDevice8"),           TEXT("GetVertexShaderFunction"),            0,                 TDEV8_GetVertexShaderFunction},
    {TEXT("IDirect3DDevice8"),           TEXT("CreatePixelShader"),                  0,                 TDEV8_CreatePixelShader},
    {TEXT("IDirect3DDevice8"),           TEXT("DeletePixelShader"),                  0,                 TDEV8_DeletePixelShader},
    {TEXT("IDirect3DDevice8"),           TEXT("GetPixelShader"),                     0,                 TDEV8_GetPixelShader},
    {TEXT("IDirect3DDevice8"),           TEXT("SetPixelShader"),                     0,                 TDEV8_SetPixelShader},
    {TEXT("IDirect3DDevice8"),           TEXT("GetPixelShaderConstant"),             0,                 TDEV8_GetPixelShaderConstant},
    {TEXT("IDirect3DDevice8"),           TEXT("SetPixelShaderConstant"),             0,                 TDEV8_SetPixelShaderConstant},
    {TEXT("IDirect3DDevice8"),           TEXT("GetPixelShaderFunction"),             0,                 TDEV8_GetPixelShaderFunction},
    {TEXT("IDirect3DDevice8"),           TEXT("Present"),                            0,                 TDEV8_Present},
    {TEXT("IDirect3DDevice8"),           TEXT("Reset"),                              0,                 TDEV8_Reset},
    {TEXT("IDirect3DDevice8"),           TEXT("BeginScene"),                         0,                 TDEV8_BeginScene},
    {TEXT("IDirect3DDevice8"),           TEXT("EndScene"),                           0,                 TDEV8_EndScene},
    {TEXT("IDirect3DDevice8"),           TEXT("DrawIndexedPrimitive"),               0,                 TDEV8_DrawIndexedPrimitive},
    {TEXT("IDirect3DDevice8"),           TEXT("DrawIndexedPrimitiveUP"),             0,                 TDEV8_DrawIndexedPrimitiveUP},
    {TEXT("IDirect3DDevice8"),           TEXT("DrawPrimitive"),                      0,                 TDEV8_DrawPrimitive},
    {TEXT("IDirect3DDevice8"),           TEXT("DrawPrimitiveUP"),                    0,                 TDEV8_DrawPrimitiveUP},
    {TEXT("IDirect3DDevice8"),           TEXT("DeleteSurfaceHandle"),                0,                 TDEV8_DeleteSurfaceHandle},
    {TEXT("IDirect3DDevice8"),           TEXT("DrawRectSurface"),                    0,                 TDEV8_DrawRectSurface},
    {TEXT("IDirect3DDevice8"),           TEXT("DrawTriSurface"),                     0,                 TDEV8_DrawTriSurface},
    {TEXT("IDirect3DDevice8"),           TEXT("GetStreamSource"),                    0,                 TDEV8_GetStreamSource},
    {TEXT("IDirect3DDevice8"),           TEXT("SetStreamSource"),                    0,                 TDEV8_SetStreamSource},
    {TEXT("IDirect3DDevice8"),           TEXT("GetIndices"),                         0,                 TDEV8_GetIndices},
    {TEXT("IDirect3DDevice8"),           TEXT("SetIndices"),                         0,                 TDEV8_SetIndices},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DDevice8"),           TEXT("GetAvailableTextureMem"),             0,                 TDEV8_GetAvailableTextureMem},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DDevice8"),           TEXT("GetCreationParameters"),              0,                 TDEV8_GetCreationParameters},
    {TEXT("IDirect3DDevice8"),           TEXT("GetDeviceCaps"),                      0,                 TDEV8_GetDeviceCaps},
    {TEXT("IDirect3DDevice8"),           TEXT("GetDirect3D"),                        0,                 TDEV8_GetDirect3D},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DDevice8"),           TEXT("GetInfo"),                            0,                 TDEV8_GetInfo},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DDevice8"),           TEXT("GetRasterStatus"),                    0,                 TDEV8_GetRasterStatus},
    {TEXT("IDirect3DDevice8"),           TEXT("GetBackBuffer"),                      0,                 TDEV8_GetBackBuffer},
    {TEXT("IDirect3DDevice8"),           TEXT("GetDepthStencilSurface"),             0,                 TDEV8_GetDepthStencilSurface},
    {TEXT("IDirect3DDevice8"),           TEXT("GetGammaRamp"),                       0,                 TDEV8_GetGammaRamp},
    {TEXT("IDirect3DDevice8"),           TEXT("SetGammaRamp"),                       0,                 TDEV8_SetGammaRamp},
    {TEXT("IDirect3DDevice8"),           TEXT("CopyRects"),                          0,                 TDEV8_CopyRects},
    {TEXT("IDirect3DDevice8"),           TEXT("GetFrontBufferRectangle"),            0,                 TDEV8_GetFrontBufferRectangle},
    {TEXT("IDirect3DDevice8"),           TEXT("ProcessVertices"),                    0,                 TDEV8_ProcessVertices},
    {TEXT("IDirect3DDevice8"),           TEXT("ResourceManagerDiscardBytes"),        0,                 TDEV8_ResourceManagerDiscardBytes},
    {TEXT("IDirect3DDevice8"),           TEXT("TestCooperativeLevel"),               0,                 TDEV8_TestCooperativeLevel},
    {TEXT("IDirect3DDevice8"),           TEXT("SetCursorPosition"),                  0,                 TDEV8_SetCursorPosition},
    {TEXT("IDirect3DDevice8"),           TEXT("SetCursorProperties"),                0,                 TDEV8_SetCursorProperties},
    {TEXT("IDirect3DDevice8"),           TEXT("ShowCursor"),                         0,                 TDEV8_ShowCursor},

#ifndef UNDER_XBOX
    {TEXT("IDirect3DSwapChain8"),        TEXT("AddRef"),                             ISWAPCHAIN8,       TUNK_AddRef},
    {TEXT("IDirect3DSwapChain8"),        TEXT("Release"),                            ISWAPCHAIN8,       TUNK_Release},
    {TEXT("IDirect3DSwapChain8"),        TEXT("QueryInterface"),                     ISWAPCHAIN8,       TUNK_QueryInterface},
    {TEXT("IDirect3DSwapChain8"),        TEXT("Present"),                            0,                 TSWC8_Present},
    {TEXT("IDirect3DSwapChain8"),        TEXT("GetBackBuffer"),                      0,                 TSWC8_GetBackBuffer},
#endif // !UNDER_XBOX

    {TEXT("IDirect3DTexture8"),          TEXT("AddRef"),                             ITEXTURE8,         TUNK_AddRef},
    {TEXT("IDirect3DTexture8"),          TEXT("Release"),                            ITEXTURE8,         TUNK_Release},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DTexture8"),          TEXT("QueryInterface"),                     ITEXTURE8,         TUNK_QueryInterface},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DTexture8"),          TEXT("GetType"),                            ITEXTURE8,         TRES8_GetType},
    {TEXT("IDirect3DTexture8"),          TEXT("GetDevice"),                          ITEXTURE8,         TRES8_GetDevice},
    {TEXT("IDirect3DTexture8"),          TEXT("GetPrivateData"),                     ITEXTURE8,         TRES8_GetPrivateData},
    {TEXT("IDirect3DTexture8"),          TEXT("SetPrivateData"),                     ITEXTURE8,         TRES8_SetPrivateData},
    {TEXT("IDirect3DTexture8"),          TEXT("FreePrivateData"),                    ITEXTURE8,         TRES8_FreePrivateData},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DTexture8"),          TEXT("GetPriority"),                        ITEXTURE8,         TRES8_GetPriority},
    {TEXT("IDirect3DTexture8"),          TEXT("SetPriority"),                        ITEXTURE8,         TRES8_SetPriority},
    {TEXT("IDirect3DTexture8"),          TEXT("PreLoad"),                            ITEXTURE8,         TRES8_PreLoad},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DTexture8"),          TEXT("GetLevelCount"),                      ITEXTURE8,         TBTX8_GetLevelCount},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DTexture8"),          TEXT("GetLOD"),                             ITEXTURE8,         TBTX8_GetLOD},
    {TEXT("IDirect3DTexture8"),          TEXT("SetLOD"),                             ITEXTURE8,         TBTX8_SetLOD},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DTexture8"),          TEXT("GetLevelDesc"),                       ITEXTURE8,         TTEX8_GetLevelDesc},
    {TEXT("IDirect3DTexture8"),          TEXT("LockRect"),                           ITEXTURE8,         TTEX8_LockRect},
    {TEXT("IDirect3DTexture8"),          TEXT("UnlockRect"),                         ITEXTURE8,         TTEX8_UnlockRect},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DTexture8"),          TEXT("AddDirtyRect"),                       ITEXTURE8,         TTEX8_AddDirtyRect},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DTexture8"),          TEXT("GetSurfaceLevel"),                    ITEXTURE8,         TTEX8_GetSurfaceLevel},

    {TEXT("IDirect3DCubeTexture8"),      TEXT("AddRef"),                             ICUBETEXTURE8,     TUNK_AddRef},
    {TEXT("IDirect3DCubeTexture8"),      TEXT("Release"),                            ICUBETEXTURE8,     TUNK_Release},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DCubeTexture8"),      TEXT("QueryInterface"),                     ICUBETEXTURE8,     TUNK_QueryInterface},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DCubeTexture8"),      TEXT("GetType"),                            ICUBETEXTURE8,     TRES8_GetType},
    {TEXT("IDirect3DCubeTexture8"),      TEXT("GetDevice"),                          ICUBETEXTURE8,     TRES8_GetDevice},
    {TEXT("IDirect3DCubeTexture8"),      TEXT("GetPrivateData"),                     ICUBETEXTURE8,     TRES8_GetPrivateData},
    {TEXT("IDirect3DCubeTexture8"),      TEXT("SetPrivateData"),                     ICUBETEXTURE8,     TRES8_SetPrivateData},
    {TEXT("IDirect3DCubeTexture8"),      TEXT("FreePrivateData"),                    ICUBETEXTURE8,     TRES8_FreePrivateData},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DCubeTexture8"),      TEXT("GetPriority"),                        ICUBETEXTURE8,     TRES8_GetPriority},
    {TEXT("IDirect3DCubeTexture8"),      TEXT("SetPriority"),                        ICUBETEXTURE8,     TRES8_SetPriority},
    {TEXT("IDirect3DCubeTexture8"),      TEXT("PreLoad"),                            ICUBETEXTURE8,     TRES8_PreLoad},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DCubeTexture8"),      TEXT("GetLevelCount"),                      ICUBETEXTURE8,     TBTX8_GetLevelCount},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DCubeTexture8"),      TEXT("GetLOD"),                             ICUBETEXTURE8,     TBTX8_GetLOD},
    {TEXT("IDirect3DCubeTexture8"),      TEXT("SetLOD"),                             ICUBETEXTURE8,     TBTX8_SetLOD},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DCubeTexture8"),      TEXT("GetLevelDesc"),                       ICUBETEXTURE8,     TCTX8_GetLevelDesc},
    {TEXT("IDirect3DCubeTexture8"),      TEXT("LockRect"),                           ICUBETEXTURE8,     TCTX8_LockRect},
    {TEXT("IDirect3DCubeTexture8"),      TEXT("UnlockRect"),                         ICUBETEXTURE8,     TCTX8_UnlockRect},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DCubeTexture8"),      TEXT("AddDirtyRect"),                       ICUBETEXTURE8,     TCTX8_AddDirtyRect},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DCubeTexture8"),      TEXT("GetCubeMapSurface"),                  ICUBETEXTURE8,     TCTX8_GetCubeMapSurface},

    {TEXT("IDirect3DVolumeTexture8"),    TEXT("AddRef"),                             IVOLUMETEXTURE8,   TUNK_AddRef},
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("Release"),                            IVOLUMETEXTURE8,   TUNK_Release},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("QueryInterface"),                     IVOLUMETEXTURE8,   TUNK_QueryInterface},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("GetType"),                            IVOLUMETEXTURE8,   TRES8_GetType},
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("GetDevice"),                          IVOLUMETEXTURE8,   TRES8_GetDevice},
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("GetPrivateData"),                     IVOLUMETEXTURE8,   TRES8_GetPrivateData},
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("SetPrivateData"),                     IVOLUMETEXTURE8,   TRES8_SetPrivateData},
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("FreePrivateData"),                    IVOLUMETEXTURE8,   TRES8_FreePrivateData},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("GetPriority"),                        IVOLUMETEXTURE8,   TRES8_GetPriority},
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("SetPriority"),                        IVOLUMETEXTURE8,   TRES8_SetPriority},
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("PreLoad"),                            IVOLUMETEXTURE8,   TRES8_PreLoad},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("GetLevelCount"),                      IVOLUMETEXTURE8,   TBTX8_GetLevelCount},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("GetLOD"),                             IVOLUMETEXTURE8,   TBTX8_GetLOD},
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("SetLOD"),                             IVOLUMETEXTURE8,   TBTX8_SetLOD},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("GetLevelDesc"),                       0,                 TVTX8_GetLevelDesc},
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("LockBox"),                            IVOLUMETEXTURE8,   TVTX8_LockBox},
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("UnlockBox"),                          IVOLUMETEXTURE8,   TVTX8_UnlockBox},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("AddDirtyBox"),                        0,                 TVTX8_AddDirtyBox},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DVolumeTexture8"),    TEXT("GetVolumeLevel"),                     0,                 TVTX8_GetVolumeLevel},

    {TEXT("IDirect3DVertexBuffer8"),     TEXT("AddRef"),                             IVERTEXBUFFER8,    TUNK_AddRef},
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("Release"),                            IVERTEXBUFFER8,    TUNK_Release},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("QueryInterface"),                     IVERTEXBUFFER8,    TUNK_QueryInterface},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("GetType"),                            IVERTEXBUFFER8,    TRES8_GetType},
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("GetDevice"),                          IVERTEXBUFFER8,    TRES8_GetDevice},
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("GetPrivateData"),                     IVERTEXBUFFER8,    TRES8_GetPrivateData},
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("SetPrivateData"),                     IVERTEXBUFFER8,    TRES8_SetPrivateData},
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("FreePrivateData"),                    IVERTEXBUFFER8,    TRES8_FreePrivateData},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("GetPriority"),                        IVERTEXBUFFER8,    TRES8_GetPriority},
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("SetPriority"),                        IVERTEXBUFFER8,    TRES8_SetPriority},
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("PreLoad"),                            IVERTEXBUFFER8,    TRES8_PreLoad},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("GetDesc"),                            0,                 TVRB8_GetDesc},
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("Lock"),                               IVERTEXBUFFER8,    TVRB8_Lock},
    {TEXT("IDirect3DVertexBuffer8"),     TEXT("Unlock"),                             IVERTEXBUFFER8,    TVRB8_Unlock},

    {TEXT("IDirect3DIndexBuffer8"),      TEXT("AddRef"),                             IINDEXBUFFER8,     TUNK_AddRef},
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("Release"),                            IINDEXBUFFER8,     TUNK_Release},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("QueryInterface"),                     IINDEXBUFFER8,     TUNK_QueryInterface},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("GetType"),                            IINDEXBUFFER8,     TRES8_GetType},
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("GetDevice"),                          IINDEXBUFFER8,     TRES8_GetDevice},
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("GetPrivateData"),                     IINDEXBUFFER8,     TRES8_GetPrivateData},
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("SetPrivateData"),                     IINDEXBUFFER8,     TRES8_SetPrivateData},
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("FreePrivateData"),                    IINDEXBUFFER8,     TRES8_FreePrivateData},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("GetPriority"),                        IINDEXBUFFER8,     TRES8_GetPriority},
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("SetPriority"),                        IINDEXBUFFER8,     TRES8_SetPriority},
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("PreLoad"),                            IINDEXBUFFER8,     TRES8_PreLoad},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("GetDesc"),                            0,                 TIXB8_GetDesc},
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("Lock"),                               IINDEXBUFFER8,     TIXB8_Lock},
    {TEXT("IDirect3DIndexBuffer8"),      TEXT("Unlock"),                             IINDEXBUFFER8,     TIXB8_Unlock},

    {TEXT("IDirect3DSurface8"),          TEXT("AddRef"),                             ISURFACE8,         TUNK_AddRef},
    {TEXT("IDirect3DSurface8"),          TEXT("Release"),                            ISURFACE8,         TUNK_Release},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DSurface8"),          TEXT("QueryInterface"),                     ISURFACE8,         TUNK_QueryInterface},
#endif // !UNDER_XBOX
    {TEXT("IDirect3DSurface8"),          TEXT("GetContainer"),                       0,                 TSUR8_GetContainer},
    {TEXT("IDirect3DSurface8"),          TEXT("GetDevice"),                          ISURFACE8,         TSUR8_GetDevice},
    {TEXT("IDirect3DSurface8"),          TEXT("GetDesc"),                            0,                 TSUR8_GetDesc},
    {TEXT("IDirect3DSurface8"),          TEXT("LockRect"),                           ISURFACE8,         TSUR8_LockRect},
    {TEXT("IDirect3DSurface8"),          TEXT("UnlockRect"),                         ISURFACE8,         TSUR8_UnlockRect},
    {TEXT("IDirect3DSurface8"),          TEXT("GetPrivateData"),                     ISURFACE8,         TSUR8_GetPrivateData},
    {TEXT("IDirect3DSurface8"),          TEXT("SetPrivateData"),                     ISURFACE8,         TSUR8_SetPrivateData},
    {TEXT("IDirect3DSurface8"),          TEXT("FreePrivateData"),                    ISURFACE8,         TSUR8_FreePrivateData},

    {TEXT("IDirect3DVolume8"),           TEXT("AddRef"),                             IVOLUME8,          TUNK_AddRef},
    {TEXT("IDirect3DVolume8"),           TEXT("Release"),                            IVOLUME8,          TUNK_Release},
#ifndef UNDER_XBOX
    {TEXT("IDirect3DVolume8"),           TEXT("QueryInterface"),                     IVOLUME8,          TUNK_QueryInterface},
#endif // !UNDER_XBOX
#ifndef DEMO_HACK
    {TEXT("IDirect3DVolume8"),           TEXT("GetContainer"),                       0,                 TVOL8_GetContainer},
#endif
    {TEXT("IDirect3DVolume8"),           TEXT("GetDevice"),                          IVOLUME8,          TVOL8_GetDevice},
    {TEXT("IDirect3DVolume8"),           TEXT("GetDesc"),                            0,                 TVOL8_GetDesc},
    {TEXT("IDirect3DVolume8"),           TEXT("LockBox"),                            IVOLUME8,          TVOL8_LockBox},
    {TEXT("IDirect3DVolume8"),           TEXT("UnlockBox"),                          IVOLUME8,          TVOL8_UnlockBox},
    {TEXT("IDirect3DVolume8"),           TEXT("GetPrivateData"),                     IVOLUME8,          TVOL8_GetPrivateData},
    {TEXT("IDirect3DVolume8"),           TEXT("SetPrivateData"),                     IVOLUME8,          TVOL8_SetPrivateData},
    {TEXT("IDirect3DVolume8"),           TEXT("FreePrivateData"),                    IVOLUME8,          TVOL8_FreePrivateData},

// ##REMOVE: Temporary video test
    {TEXT("IDirect3DDevice8"),           TEXT("Present"),                            0,                 TTMP_VideoTest},
// ##REMOVE END
};

//******************************************************************************
void ExecuteTests(HINSTANCE hInstance, HANDLE hLog) {

    TCHAR   szName[2048];
    UINT    uCount = countof(g_pTestTable);
    UINT    uPass = 0, uFail = 0, uSkip = 0, uAbort = 0;
    DWORD   dwSeed;
    UINT    i;
    TRESULT tr;

    g_hInstance = hInstance;

    // Create a heap for the tests
    if (!CreateHeap()) {
        return;
    }

    CreateLog(hLog);

    // Seed the random number generator
    dwSeed = GetTickCount();
    srand(dwSeed);

    Log(LOG_TEXT, TEXT("********************************************************************************\n"));
    Log(LOG_TEXT, TEXT("* TEST SUITE                                                                   *\n"));
    Log(LOG_TEXT, TEXT("*                                                                              *\n"));
    Log(LOG_TEXT, TEXT("* Name:              Direct3D Build Verification Tests                         *\n"));
    Log(LOG_TEXT, TEXT("* Number of tests:   %-10d                                                *\n"), uCount);
    Log(LOG_TEXT, TEXT("* Seed:              %-20d                                      *\n"), dwSeed);
    Log(LOG_TEXT, TEXT("*                                                                              *\n"));
    Log(LOG_TEXT, TEXT("********************************************************************************\n\n"));

    for (i = 0; i < uCount; i++) {

        LogComponent(TEXT("Direct3D"), g_pTestTable[i].szInterface);
        LogFunction(g_pTestTable[i].szMethod);
        wsprintf(szName, TEXT("%s::%s"), g_pTestTable[i].szInterface, g_pTestTable[i].szMethod);
        Log(LOG_TEXT, TEXT("\n********************************************************************************\n"));
        Log(LOG_TEXT, TEXT("* TEST STARTING                                                                *\n"));
        Log(LOG_TEXT, TEXT("*                                                                              *\n"));
        Log(LOG_TEXT, TEXT("* Name:   %-68s *\n"), szName);
        Log(LOG_TEXT, TEXT("*                                                                              *\n"));
        Log(LOG_TEXT, TEXT("********************************************************************************\n"));
        LogBeginVariation(g_pTestTable[i].szMethod);
        tr = g_pTestTable[i].pfnTest(&g_pTestTable[i]);
        if (tr == TR_PASS) {
            Log(LOG_PASS, szName);
        }
        LogEndVariation();
        Log(LOG_TEXT, TEXT("********************************************************************************\n"));
        Log(LOG_TEXT, TEXT("* TEST COMPLETED                                                               *\n"));
        Log(LOG_TEXT, TEXT("*                                                                              *\n"));
        Log(LOG_TEXT, TEXT("* Name:     %-66s *\n"), szName);
        switch (tr) {
            case TR_FAIL:
                Log(LOG_TEXT, TEXT("* Result:   %-7s"), TEXT("Failed"));
                uFail++;
                break;
            case TR_ABORT:
                Log(LOG_TEXT, TEXT("* Result:   %-7s"), TEXT("Aborted"));
                uAbort++;
                break;
            case TR_SKIP:
                Log(LOG_TEXT, TEXT("* Result:   %-7s"), TEXT("Skipped"));
                uSkip++;
                break;
            case TR_PASS:
                Log(LOG_TEXT, TEXT("* Result:   %-7s"), TEXT("Passed"));
                uPass++;
                break;
        }
        Log(LOG_TEXT, TEXT("                                                            *\n"));
        Log(LOG_TEXT, TEXT("*                                                                              *\n"));
        Log(LOG_TEXT, TEXT("********************************************************************************\n"));
    }

    // Print results
    Log(LOG_TEXT, TEXT("\n\n********************************************************************************\n"));
    Log(LOG_TEXT, TEXT("* RESULT SUMMARY                                                               *\n"));
    Log(LOG_TEXT, TEXT("********************************************************************************\n"));
    Log(LOG_TEXT, TEXT("* Passed:        %10d                                                    *\n"), uPass);
    Log(LOG_TEXT, TEXT("* Failed:        %10d                                                    *\n"), uFail);
    Log(LOG_TEXT, TEXT("* Aborted:       %10d                                                    *\n"), uAbort);
    Log(LOG_TEXT, TEXT("* Skipped:       %10d                                                    *\n"), uSkip);
    Log(LOG_TEXT, TEXT("* -------------------------                                                    *\n"));
    Log(LOG_TEXT, TEXT("* Total:         %10d                                                    *\n"), uCount);
    Log(LOG_TEXT, TEXT("********************************************************************************\n\n"));

    // Release Direct3D objects
    ReleaseDeviceObjects8();
    ReleaseDevice8();
    ReleaseDirect3D8();

    ReleaseLog();

    // Release the heap
    ReleaseHeap();
}

//******************************************************************************
LPDIRECT3D8 GetDirect3D8() {

    if (g_pd3dd8) {
        ReleaseDevice8();
    }

    if (g_pd3d8) {
        return g_pd3d8;
    }

    g_pd3d8 = Direct3DCreate8(D3D_SDK_VERSION);
    if (!g_pd3d8) {
        Log(LOG_ABORT, TEXT("Direct3DCreate8 failed"));
    }

    return g_pd3d8;
}

//******************************************************************************
LPDIRECT3D8 GetDeviceDirect3D8() {

    if (g_pd3d8) {
        return g_pd3d8;
    }

    g_pd3d8 = Direct3DCreate8(D3D_SDK_VERSION);
    if (!g_pd3d8) {
        Log(LOG_ABORT, TEXT("Direct3DCreate8 failed"));
    }

    return g_pd3d8;
}

//******************************************************************************
void ReleaseDirect3D8() {
    
    if (g_pd3d8) {
        g_pd3d8->Release();
        g_pd3d8 = NULL;
    }
}

//******************************************************************************
LPDIRECT3DDEVICE8 GetDevice8() {

#ifndef UNDER_XBOX
	WNDCLASS                wc;
    MSG                     msg;
#endif
    D3DPRESENT_PARAMETERS   d3dpp;
    D3DXMATRIX              mTransform;
    UINT                    i;
    HRESULT                 hr;

    if (g_pd3dd8) {
        return g_pd3dd8;
    }

    GetDirect3D8();

#ifndef UNDER_XBOX
    
    // Register the window class
    memset(&wc, 0, sizeof(WNDCLASS));
    wc.style            = 0;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_hInstance;
    wc.hIcon            = NULL;
    wc.hbrBackground    = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT("Direct3D BVT");

    if (!RegisterClass(&wc)) {
        Log(LOG_ABORT, TEXT("RegisterClass failed"));
        return NULL;
    }

    // Create the main application window
    g_hWnd = CreateWindowEx(0, TEXT("Direct3D BVT"), 
                            TEXT("Direct3D BVT"), 
                            WS_OVERLAPPEDWINDOW | WS_VISIBLE, 0, 0,
                            GetSystemMetrics(SM_CXSCREEN), 
                            GetSystemMetrics(SM_CYSCREEN),
                            NULL, NULL, g_hInstance, NULL);

    if (!g_hWnd) {
        Log(LOG_ABORT, TEXT("CreateWindowEx failed"));
        ReleaseDevice8();
		return NULL;
    }

    UpdateWindow(g_hWnd);

    // Pump any messages
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

#else

    g_hWnd = NULL;

#endif // UNDER_XBOX

    // Initialize the presentation parameters
    memset(&d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth                   = TARGET_WIDTH;
    d3dpp.BackBufferHeight                  = TARGET_HEIGHT;
#ifndef UNDER_XBOX
    d3dpp.BackBufferFormat                  = D3DFMT_R5G6B5;
#else
    d3dpp.BackBufferFormat                  = D3DFMT_LIN_R5G6B5;
#endif
    d3dpp.MultiSampleType                   = D3DMULTISAMPLE_NONE;
#ifndef UNDER_XBOX
    d3dpp.AutoDepthStencilFormat            = D3DFMT_D16;
#else
    d3dpp.AutoDepthStencilFormat            = D3DFMT_LIN_D16;
#endif
    d3dpp.FullScreen_RefreshRateInHz        = 0;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                     = g_hWnd;
    d3dpp.Windowed                          = FALSE;
    d3dpp.EnableAutoDepthStencil            = TRUE;

    // Create the device
    hr = g_pd3d8->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, g_hWnd, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pd3dd8);
    if (FAILED(hr)) {
        Log(LOG_ABORT, TEXT("IDirect3D8::CreateDevice failed"));
        return NULL;
    }

    // Initialize the viewport
    if (!SetViewport(640, 480)) {
        Log(LOG_WARN, TEXT("SetViewport failed"));
    }

    // Initialize the view matrix
    SetView(&mTransform, &D3DXVECTOR3(0.0f, 0.0f, -20.0f), &D3DXVECTOR3(0.0f, 0.0f, 0.0f), 
            &D3DXVECTOR3(0.0f, 1.0f, 0.0f));

    hr = g_pd3dd8->SetTransform(D3DTS_VIEW, &mTransform);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetTransform failed"));
    }

    // Initialize the projection matrix
    SetPerspectiveProjection(&mTransform, 0.1f, 1000.0f, 
            M_PI / 4.0f, 480.0f / 640.0f);

    hr = g_pd3dd8->SetTransform(D3DTS_PROJECTION, &mTransform);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetTransform failed"));
    }

    // Set ambient lighting
    hr = g_pd3dd8->SetRenderState(D3DRS_AMBIENT, 
                                      (DWORD)RGBA_MAKE(128, 128, 128, 128));
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetRenderState failed"));
    }

    // Set the texture filters
    for (i = 0; i < 4; i++) {
        hr = g_pd3dd8->SetTextureStageState(i, D3DTSS_MINFILTER, (DWORD)D3DTEXF_LINEAR);
        if (FAILED(hr)) {
            Log(LOG_WARN, TEXT("IDirect3DDevice8::SetTextureStageState"));
        }

        hr = g_pd3dd8->SetTextureStageState(i, D3DTSS_MAGFILTER, (DWORD)D3DTEXF_LINEAR);
        if (FAILED(hr)) {
            Log(LOG_WARN, TEXT("IDirect3DDevice8::SetTextureStageState"));
        }
    }

    // Set blend modes
    hr = g_pd3dd8->SetRenderState(D3DRS_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetRenderState failed"));
    }

    hr = g_pd3dd8->SetRenderState(D3DRS_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetRenderState failed"));
    }

    // Modulate color and alpha texture stages
    hr = g_pd3dd8->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetTextureStageState"));
    }

    hr = g_pd3dd8->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetTextureStageState"));
    }

    hr = g_pd3dd8->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetTextureStageState"));
    }

    // Set the alpha comparison function
    hr = g_pd3dd8->SetRenderState(D3DRS_ALPHAFUNC, (DWORD)D3DCMP_GREATEREQUAL);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetRenderState failed"));
    }

    // Set the alpha reference value to opaque
    hr = g_pd3dd8->SetRenderState(D3DRS_ALPHAREF, 0xFF);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetRenderState failed"));
    }

    // Turn on specular highlights
    hr = g_pd3dd8->SetRenderState(D3DRS_SPECULARENABLE, (DWORD)TRUE);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetRenderState failed"));
    }

    // Enable dithering
    hr = g_pd3dd8->SetRenderState(D3DRS_DITHERENABLE, (DWORD)TRUE);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetRenderState failed"));
    }

    // Disable per-vertex color
    hr = g_pd3dd8->SetRenderState(D3DRS_COLORVERTEX, (DWORD)FALSE);
    if (FAILED(hr)) {
        Log(LOG_WARN, TEXT("IDirect3DDevice8::SetRenderState failed"));
    }

    return g_pd3dd8;
}

//******************************************************************************
void ReleaseDevice8() {

    if (g_pd3dd8) {
        g_pd3dd8->Release();
        g_pd3dd8 = NULL;
    }

#ifndef UNDER_XBOX

    DestroyWindow(g_hWnd);

    // Unregister the window class
    UnregisterClass(TEXT("Direct3D BVT"), g_hInstance);

#endif // UNDER_XBOX
    
    ReleaseDirect3D8();
}

//******************************************************************************
static BOOL SetViewport(DWORD dwWidth, DWORD dwHeight) {

    D3DVIEWPORT8    viewport;
    HRESULT         hr;

    // Set a viewport for the device
    viewport.X = 0;
    viewport.Y = 0;
    viewport.Width = dwWidth;
    viewport.Height = dwHeight;
    viewport.MinZ = 0.0f;
    viewport.MaxZ = 1.0f;

    hr = g_pd3dd8->SetViewport(&viewport);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetViewport"))) {
        return FALSE;
    }

    return TRUE;
}

#ifndef UNDER_XBOX
//******************************************************************************
LPDIRECT3DSWAPCHAIN8 GetSwapChain8() {

    LPDIRECT3DDEVICE8       pd3dd;
    D3DPRESENT_PARAMETERS   d3dpp;
    HRESULT                 hr;

    if (g_pd3dsw8) {
        return g_pd3dsw8;
    }

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return NULL;
    }

    memset(&d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth                   = TARGET_WIDTH;
    d3dpp.BackBufferHeight                  = TARGET_HEIGHT;
    d3dpp.BackBufferFormat                  = D3DFMT_R5G6B5;
    d3dpp.MultiSampleType                   = D3DMULTISAMPLE_NONE;
    d3dpp.AutoDepthStencilFormat            = D3DFMT_D16;
    d3dpp.FullScreen_RefreshRateInHz        = 0;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                     = g_hWnd;
    d3dpp.Windowed                          = FALSE;
    d3dpp.EnableAutoDepthStencil            = TRUE;

    hr = pd3dd->CreateAdditionalSwapChain(&d3dpp, &g_pd3dsw8);
    ResultFailed(hr, TEXT("IDirect3DDevice8::CreateAdditionalSwapChain"));

    return g_pd3dsw8;
}
#endif // !UNDER_XBOX

//******************************************************************************
LPDIRECT3DTEXTURE8 GetTexture8() {

    LPDIRECT3DDEVICE8 pd3dd;
    HRESULT           hr;

    if (g_pd3dt8) {
        return g_pd3dt8;
    }

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return NULL;
    }

    hr = pd3dd->CreateTexture(TEXTUREDIM, TEXTUREDIM, 0, 0, D3DFMT_A1R5G5B5, D3DPOOL_MANAGED, &g_pd3dt8);
    ResultFailed(hr, TEXT("IDirect3DDevice8::CreateTexture"));

    return g_pd3dt8;
}

//******************************************************************************
LPDIRECT3DCUBETEXTURE8 GetCubeTexture8() {

    LPDIRECT3DDEVICE8 pd3dd;
    HRESULT           hr;

    if (g_pd3dtc8) {
        return g_pd3dtc8;
    }

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return NULL;
    }

    hr = pd3dd->CreateCubeTexture(TEXTUREDIM, 0, 0, D3DFMT_A1R5G5B5, D3DPOOL_MANAGED, &g_pd3dtc8);
    ResultFailed(hr, TEXT("IDirect3DDevice8::CreateCubeTexture"));

    return g_pd3dtc8;
}

//******************************************************************************
LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture8() {

    LPDIRECT3DDEVICE8 pd3dd;
    HRESULT           hr;

    if (g_pd3dtv8) {
        return g_pd3dtv8;
    }

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return NULL;
    }

    hr = pd3dd->CreateVolumeTexture(TEXTUREDIM, TEXTUREDIM, TEXTUREDIM, 0, 0, D3DFMT_A1R5G5B5, D3DPOOL_MANAGED, &g_pd3dtv8);
    ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVolumeTexture"));

    return g_pd3dtv8;
}

//******************************************************************************
LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer8() {

    LPDIRECT3DDEVICE8 pd3dd;
    HRESULT           hr;

    if (g_pd3dr8) {
        return g_pd3dr8;
    }

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return NULL;
    }

    hr = pd3dd->CreateVertexBuffer(VERTBUFFSIZE, 0, VERTBUFFFORMAT, D3DPOOL_MANAGED, &g_pd3dr8);
    ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexBuffer"));

    return g_pd3dr8;
}

//******************************************************************************
LPDIRECT3DINDEXBUFFER8 GetIndexBuffer8() {

    LPDIRECT3DDEVICE8 pd3dd;
    HRESULT           hr;

    if (g_pd3di8) {
        return g_pd3di8;
    }

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return NULL;
    }

    hr = pd3dd->CreateIndexBuffer(INDXBUFFSIZE, 0, D3DFMT_INDEX16, D3DPOOL_MANAGED, &g_pd3di8);
    ResultFailed(hr, TEXT("IDirect3DDevice8::CreateIndexBuffer"));

    return g_pd3di8;
}

//******************************************************************************
LPDIRECT3DSURFACE8 GetSurface8(LPDIRECT3DTEXTURE8* ppd3dt) {

    LPDIRECT3DDEVICE8 pd3dd;
    HRESULT           hr;

    if (!g_pd3ds8) {

        if (ppd3dt) {
            *ppd3dt = NULL;
        }

        pd3dd = GetDevice8();
        if (!pd3dd) {
            return NULL;
        }

        hr = pd3dd->CreateTexture(TEXTUREDIM, TEXTUREDIM, 0, 0, D3DFMT_A1R5G5B5, D3DPOOL_MANAGED, &g_pd3dtSurf8);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateTexture"))) {
            return NULL;
        }

        hr = g_pd3dtSurf8->GetSurfaceLevel(0, &g_pd3ds8);
        if (ResultFailed(hr, TEXT("IDirect3DTexture8::GetSurfaceLevel"))) {
            g_pd3dtSurf8->Release();
            g_pd3dtSurf8 = NULL;
        }
    }

    if (ppd3dt) {
        *ppd3dt = g_pd3dtSurf8;
    }

    return g_pd3ds8;
}

//******************************************************************************
LPDIRECT3DSURFACE8 GetCubeSurface8(LPDIRECT3DCUBETEXTURE8* ppd3dtc) {

    LPDIRECT3DDEVICE8 pd3dd;
    HRESULT           hr;

    if (!g_pd3dsc8) {

        if (ppd3dtc) {
            *ppd3dtc = NULL;
        }

        pd3dd = GetDevice8();
        if (!pd3dd) {
            return NULL;
        }

        hr = pd3dd->CreateCubeTexture(TEXTUREDIM, 0, 0, D3DFMT_A1R5G5B5, D3DPOOL_MANAGED, &g_pd3dtcSurf8);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateCubeTexture"))) {
            return NULL;
        }

        hr = g_pd3dtcSurf8->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_X, 0, &g_pd3dsc8);
        if (ResultFailed(hr, TEXT("IDirect3DTexture8::GetSurfaceLevel"))) {
            g_pd3dtcSurf8->Release();
            g_pd3dtcSurf8 = NULL;
        }
    }

    if (ppd3dtc) {
        *ppd3dtc = g_pd3dtcSurf8;
    }

    return g_pd3dsc8;
}

//******************************************************************************
LPDIRECT3DVOLUME8 GetVolume8(LPDIRECT3DVOLUMETEXTURE8* ppd3dtv) {

    LPDIRECT3DDEVICE8 pd3dd;
    HRESULT           hr;

    if (!g_pd3dv8) {

        if (ppd3dtv) {
            *ppd3dtv = NULL;
        }

        pd3dd = GetDevice8();
        if (!pd3dd) {
            return NULL;
        }

        hr = pd3dd->CreateVolumeTexture(TEXTUREDIM, TEXTUREDIM, TEXTUREDIM, 0, 0, D3DFMT_A1R5G5B5, D3DPOOL_MANAGED, &g_pd3dtvVol8);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVolumeTexture"))) {
            return NULL;
        }

        hr = g_pd3dtvVol8->GetVolumeLevel(0, &g_pd3dv8);
        if (ResultFailed(hr, TEXT("IDirect3DVolumeTexture8::GetVolumeLevel"))) {
            g_pd3dtvVol8->Release();
            g_pd3dtvVol8 = NULL;
        }
    }

    if (ppd3dtv) {
        *ppd3dtv = g_pd3dtvVol8;
    }

    return g_pd3dv8;
}

//******************************************************************************
void ReleaseDeviceObjects8() {

#ifndef UNDER_XBOX
    if (g_pd3dsw8) {
        g_pd3dsw8->Release();
        g_pd3dsw8 = NULL;
    }
#endif // !UNDER_XBOX
    if (g_pd3dt8) {
        g_pd3dt8->Release();
        g_pd3dt8 = NULL;
    }
    if (g_pd3dtc8) {
        g_pd3dtc8->Release();
        g_pd3dtc8 = NULL;
    }
    if (g_pd3dtv8) {
        g_pd3dtv8->Release();
        g_pd3dtv8 = NULL;
    }
    if (g_pd3dr8) {
        g_pd3dr8->Release();
        g_pd3dr8 = NULL;
    }
    if (g_pd3di8) {
        g_pd3di8->Release();
        g_pd3di8 = NULL;
    }
    if (g_pd3dtSurf8) {
        g_pd3dtSurf8->Release();
        g_pd3dtSurf8 = NULL;
    }
    if (g_pd3ds8) {
        g_pd3ds8->Release();
        g_pd3ds8 = NULL;
    }
    if (g_pd3dtcSurf8) {
        g_pd3dtcSurf8->Release();
        g_pd3dtcSurf8 = NULL;
    }
    if (g_pd3dsc8) {
        g_pd3dsc8->Release();
        g_pd3dsc8 = NULL;
    }
    if (g_pd3dtvVol8) {
        g_pd3dtvVol8->Release();
        g_pd3dtvVol8 = NULL;
    }
    if (g_pd3dv8) {
        g_pd3dv8->Release();
        g_pd3dv8 = NULL;
    }
}

//******************************************************************************
// ##REMOVE: Temporary video test
#define NUM_ITERATIONS 256

typedef struct _COMPLEXNUM {
    float a;
    float b;
} COMPLEXNUM, *PCOMPLEXNUM;

D3DXVECTOR3 CubicInterpolate(D3DXVECTOR3* pv, float f) {

    D3DXVECTOR3 a, b, c;
    float fSq = f * f;

    a = (*(pv + 3) - *(pv + 2)) - (*pv - *(pv + 1));
    b = (*pv - *(pv + 1)) - a;
    c = *(pv + 2) - *pv;

    return a * (fSq * f) + b * fSq + c * f + *(pv + 1);
}

TESTPROCAPI TTMP_VideoTest(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    LPDIRECT3DSURFACE8  pdds;
    D3DLOCKED_RECT      d3dlr;
    LPWORD              pwPixel;
    PCOMPLEXNUM         pcnFractal, pcnZ;
    float               a, b;
    UINT                zooms, iterations;
    COMPLEXNUM          cnBase;
    float               fDelta, fA, fB;
    WORD                pwPalette[NUM_ITERATIONS];
    UINT                i, j;
    D3DXVECTOR3         vColor;
    D3DXVECTOR3         pvControl[7];
    UINT                puControl[5];
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    srand(GetTickCount());

    ReleaseDevice8();

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_FAIL;
    }

//    puControl[0] = 0;
//    puControl[2] = NUM_ITERATIONS / 2;
//    puControl[1] = puControl[2] / 2;
//    puControl[3] = puControl[1] + puControl[2];
//    puControl[4] = NUM_ITERATIONS;

    puControl[0] = 0;
    puControl[3] = NUM_ITERATIONS / 2;
    puControl[2] = puControl[3] / 2;
    puControl[1] = puControl[2] / 2;
    puControl[4] = NUM_ITERATIONS;

//    for (i = 0; i < NUM_ITERATIONS; i++) {
//        pwPalette[i] = ((BYTE)((float)0 / (float)(NUM_ITERATIONS-1) * 255.0f) & 0xF8) << 8 |
//                       ((BYTE)((float)i / (float)(NUM_ITERATIONS-1) * 255.0f) & 0xFC) << 5 |
//                       ((BYTE)((float)255 / (float)(NUM_ITERATIONS-1) * 255.0f) & 0xF8) >> 3;
//    }

    pcnFractal = (PCOMPLEXNUM)MemAlloc32(TARGET_WIDTH * TARGET_HEIGHT * sizeof(COMPLEXNUM));
    if (!pcnFractal) {
        return TR_ABORT;
    }
    memset(pcnFractal, 0, TARGET_WIDTH * TARGET_HEIGHT * sizeof(COMPLEXNUM));

    hr = pd3dd->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pdds);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetBackBuffer"))) {
        MemFree32(pcnFractal);
        return TR_FAIL;
    }

    cnBase.a = -1.75f;
    cnBase.b = 0.9375f;
    fDelta = 0.00390625f;

//    cnBase.a = -1.0f;
//    cnBase.b = 0.4f;
//    fDelta = 0.0005f;

//    cnBase.a = -1.1f;
//    cnBase.b = 0.38f;
//    fDelta = 0.00025f;

#ifndef UNDER_XBOX
    for (zooms = 0; zooms < 8; zooms++) {
#else
    for (zooms = 0; zooms < 2; zooms++) {
#endif // UNDER_XBOX

        for (i = 0; i < 7; i++) {
            pvControl[i] = D3DXVECTOR3(RND(), RND(), RND());;
        }

        for (i = 0; i < 4; i++) {
            for (j = puControl[i]; j < puControl[i+1]; j++) {
                vColor = CubicInterpolate(&pvControl[i], (float)(j - puControl[i]) / (float)(puControl[i+1] - puControl[i]));
                pwPalette[j] = ((BYTE)(vColor.x * 255.0f) & 0xF8) << 8 |
                               ((BYTE)(vColor.y * 255.0f) & 0xFC) << 5 |
                               ((BYTE)(vColor.z * 255.0f) & 0xF8) >> 3;
            }
        }

        for (iterations = 0; iterations < NUM_ITERATIONS; iterations++) {

#ifndef UNDER_XBOX
            hr = pdds->LockRect(&d3dlr, NULL, 0);
#else
            hr = pdds->LockRect(&d3dlr, NULL, D3DLOCK_TILED);
#endif // UNDER_XBOX
            if (ResultFailed(hr, TEXT("IDirect3DSurface8::LockRect"))) {
                pdds->Release();
                MemFree32(pcnFractal);
                return TR_FAIL;
            }

            pwPixel = (LPWORD)d3dlr.pBits;
            pcnZ = pcnFractal;

            for (i = 0, fB = cnBase.b; i < TARGET_HEIGHT; i++, fB -= fDelta) {

                for (j = 0, fA = cnBase.a; j < TARGET_WIDTH; j++, fA += fDelta) {

                    if (pcnZ[j].a == FLT_MAX) {
                        pwPixel[j] = pwPalette[(UINT)pcnZ[j].b];
                    }
                    else {

                        a = pcnZ[j].a;
                        b = pcnZ[j].b;
                        pcnZ[j].a = (a * a - b * b) + fA;
                        pcnZ[j].b = (2.0f * a * b) + fB;
                        if (pcnZ[j].a * pcnZ[j].a + pcnZ[j].b * pcnZ[j].b > 4.0f) {
                            pcnZ[j].a = FLT_MAX;
                            pcnZ[j].b = (float)iterations;
                            pwPixel[j] = pwPalette[iterations];
                        }
                        else {
                            pwPixel[j] = 0;
                        }
                    }
                }

                pwPixel += d3dlr.Pitch / 2;
                pcnZ += TARGET_WIDTH;
            }
    
            hr = pdds->UnlockRect();
            if (ResultFailed(hr, TEXT("IDirect3DSurface8::UnlockRect"))) {
                pdds->Release();
                MemFree32(pcnFractal);
                return TR_FAIL;
            }

            hr = pd3dd->Present(NULL, NULL, NULL, NULL);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::Present"))) {
                pdds->Release();
                MemFree32(pcnFractal);
                return TR_FAIL;
            }
        }

        for (iterations = 0; iterations < 51200; iterations++) {
            i = rand() % TARGET_HEIGHT;
            j = rand() % TARGET_WIDTH;
            pcnZ = &pcnFractal[i * TARGET_WIDTH + j];
            fB = 1.0f + 1.0f * (float)(iterations / 100);
            fA = (float)NUM_ITERATIONS / 2.0f - fB;
            fB = fA + fB + fB;
            if (pcnZ->a == FLT_MAX && pcnZ->b > fA && pcnZ->b < fB) {
                cnBase.a += (float)j * fDelta;
                cnBase.b -= (float)i * fDelta;
                break;
            }
        }
        if (iterations == 51200) {
            zooms = (UINT)-2;
        }

        fDelta /= 4.0f;
        cnBase.a -= (160.0f * fDelta);
        cnBase.b += (120.0f * fDelta);

        memset(pcnFractal, 0, TARGET_WIDTH * TARGET_HEIGHT * sizeof(COMPLEXNUM));
    }

    MemFree32(pcnFractal);
    pdds->Release();

    return tr;
}
/*
TESTPROCAPI TTMP_VideoTest(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    LPDIRECT3DSURFACE8  pdds;
    D3DLOCKED_RECT      d3dlr;
    LPWORD              pwPixel;
    UINT                i, j;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_FAIL;
    }

    hr = pd3dd->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pdds);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetBackBuffer"))) {
        return TR_FAIL;
    }

    hr = pdds->LockRect(&d3dlr, NULL, 0);
    if (ResultFailed(hr, TEXT("IDirect3DSurface8::LockRect"))) {
        return TR_FAIL;
    }

    pwPixel = (LPWORD)d3dlr.pBits;

    for (i = 0; i < TARGET_HEIGHT; i++) {

        for (j = 0; j < TARGET_WIDTH; j++) {

            pwPixel[j] = 0xFFFF;
        }

        pwPixel += d3dlr.Pitch / 2;
    }
    
    hr = pdds->UnlockRect();
    if (ResultFailed(hr, TEXT("IDirect3DSurface8::UnlockRect"))) {
        return TR_FAIL;
    }

    hr = pd3dd->Present(NULL, NULL, NULL, NULL);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::Present"))) {
        return TR_FAIL;
    }

    pdds->Release();

Sleep(1000);
    return tr;
}
*/
// ##REMOVE END

//******************************************************************************
// Shared tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TSHR8_GetDevice(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    LPDIRECT3DDEVICE8   pd3dd, pd3ddR;
    ULONG               uRef1, uRef2;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    pd3dd->AddRef();
    uRef1 = pd3dd->Release();

    switch (ptte->dwData) {
        case ISURFACE8:
            hr = ((LPDIRECT3DSURFACE8)pvObject)->GetDevice(&pd3ddR);
            break;
        case IVOLUME8:
            hr = ((LPDIRECT3DVOLUME8)pvObject)->GetDevice(&pd3ddR);
            break;
        default:
            hr = ((LPDIRECT3DRESOURCE8)pvObject)->GetDevice(&pd3ddR);
            break;
    }

    if (FAILED(hr)) {
        Log(LOG_FAIL, TEXT("%s::GetDevice failed [0x%X]"), ptte->szInterface, hr);
        return TR_FAIL;
    }

    pd3dd->AddRef();
    uRef2 = pd3dd->Release();

    if (uRef2 != uRef1 + 1) {
        Log(LOG_FAIL, TEXT("%s::GetDevice failed to increment the reference count of the device object"), ptte->szInterface);
        tr = TR_FAIL;
    }

    pd3dd->Release();

    if (pd3ddR != pd3dd) {
        Log(LOG_FAIL, TEXT("%s::GetDevice returned an incorrect pointer to the device object: 0x%X"), ptte->szInterface, pd3ddR);
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSHR8_GetPrivateData(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    HRESULT             hr;
    BYTE                pdataSet[2971];
    BYTE                pdataGet[2972];
    DWORD               dwSize;
    UINT                i;
    TRESULT             tr = TR_PASS;

    for (i = 0; i < 2971; i++) {
        pdataSet[i] = rand() % 256;
    }
    memcpy(pdataGet, pdataSet, 2971);

    LogBeginVariation(TEXT("%s::GetPrivateData when no data has been set"), ptte->szInterface);
    {
        dwSize = PRESET;
        switch (ptte->dwData) {
            case ISURFACE8:
                hr = ((LPDIRECT3DSURFACE8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataGet, &dwSize);
                break;
            case IVOLUME8:
                hr = ((LPDIRECT3DVOLUME8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataGet, &dwSize);
                break;
            default:
                hr = ((LPDIRECT3DRESOURCE8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataGet, &dwSize);
                break;
        }

        if (hr != D3DERR_NOTFOUND) {
            Log(LOG_FAIL, TEXT("%s::GetPrivateData returned 0x%X instead of D3DERR_NOTFOUND when given an identifier to non-existant data"), ptte->szInterface);
            tr = TR_FAIL;
        }
        if (dwSize != PRESET) {
            Log(LOG_FAIL, TEXT("%s::GetPrivateData incorrectly modified the data size pointer on failure"), ptte->szInterface);
            tr = TR_FAIL;
        }
        if (memcmp(pdataGet, pdataSet, 2971)) {
            Log(LOG_FAIL, TEXT("%s::GetPrivateData incorrectly modified the data buffer on failure"), ptte->szInterface);
            tr = TR_FAIL;
        }
    }
    LogEndVariation();
    
    switch (ptte->dwData) {
        case ISURFACE8:
            hr = ((LPDIRECT3DSURFACE8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataSet, 2971, 0);
            break;
        case IVOLUME8:
            hr = ((LPDIRECT3DVOLUME8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataSet, 2971, 0);
            break;
        default:
            hr = ((LPDIRECT3DRESOURCE8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataSet, 2971, 0);
            break;
    }

    if (FAILED(hr)) {
        Log(LOG_FAIL, TEXT("%s::SetPrivateData failed [0x%X]"), ptte->szInterface, hr);
        return TR_FAIL;
    }

    LogBeginVariation(TEXT("%s::GetPrivateData given too small a buffer"), ptte->szInterface);
    {
        memset(pdataGet, 0, 2971);
        dwSize = 2970;
        switch (ptte->dwData) {
            case ISURFACE8:
                hr = ((LPDIRECT3DSURFACE8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataGet, &dwSize);
                break;
            case IVOLUME8:
                hr = ((LPDIRECT3DVOLUME8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataGet, &dwSize);
                break;
            default:
                hr = ((LPDIRECT3DRESOURCE8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataGet, &dwSize);
                break;
        }

        if (hr != D3DERR_MOREDATA) {
            Log(LOG_FAIL, TEXT("%s::GetPrivateData returned 0x%X instead of D3DERR_MOREDATA when given too small a buffer"), ptte->szInterface);
            tr = TR_FAIL;
        }
        if (dwSize != 2971) {
            Log(LOG_FAIL, TEXT("%s::GetPrivateData set the wrong size for the data buffer when given too small a buffer"), ptte->szInterface);
            tr = TR_FAIL;
        }
        for (i = 0; i < 2971; i++) {
            if (pdataGet[i]) {
                Log(LOG_FAIL, TEXT("%s::GetPrivateData incorrectly modified the data buffer on failure from too small a buffer"), ptte->szInterface);
                tr = TR_FAIL;
                break;
            }
        }
    }
    LogEndVariation();

    LogBeginVariation(TEXT("%s::GetPrivateData given a correct buffer size"), ptte->szInterface);
    {
        memset(pdataGet, 0, 2971);
        pdataGet[2971] = 0x4C;
        dwSize = 3000;
        switch (ptte->dwData) {
            case ISURFACE8:
                hr = ((LPDIRECT3DSURFACE8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataGet, &dwSize);
                break;
            case IVOLUME8:
                hr = ((LPDIRECT3DVOLUME8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataGet, &dwSize);
                break;
            default:
                hr = ((LPDIRECT3DRESOURCE8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataGet, &dwSize);
                break;
        }

        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::GetPrivateData failed [0x%X]"), ptte->szInterface, hr);
            return TR_FAIL;
        }
#ifndef UNDER_XBOX
        if (dwSize != 3000) {
            Log(LOG_FAIL, TEXT("%s::GetPrivateData incorrectly modified the size for the data buffer on success"), ptte->szInterface);
            tr = TR_FAIL;
        }
#endif // !UNDER_XBOX
        if (memcmp(pdataGet, pdataSet, 2971)) {
            Log(LOG_FAIL, TEXT("%s::GetPrivateData returned incorrect data on success"), ptte->szInterface);
            tr = TR_FAIL;
        }
        if (pdataGet[2971] != 0x4C) {
            Log(LOG_FAIL, TEXT("%s::GetPrivate data incorrectly modified data past the end of the buffer on success"), ptte->szInterface);
            tr = TR_FAIL;
        }
    }
    LogEndVariation();

    switch (ptte->dwData) {
        case ISURFACE8:
            hr = ((LPDIRECT3DSURFACE8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
            break;
        case IVOLUME8:
            hr = ((LPDIRECT3DVOLUME8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
            break;
        default:
            hr = ((LPDIRECT3DRESOURCE8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
            break;
    }

    if (FAILED(hr)) {
        Log(LOG_FAIL, TEXT("%s::FreePrivateData failed [0x%X]"), ptte->szInterface, hr);
        return TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSHR8_SetPrivateData(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    HRESULT             hr;
    LPDIRECT3DDEVICE8   pd3dd;
    IUnknown*           punk;
    ULONG               uRef1, uRef2;
    DWORD               dwSize;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

#ifndef UNDER_XBOX

    pd3dd->AddRef();
    uRef1 = pd3dd->Release();

    LogBeginVariation(TEXT("%s::SetPrivateData on an interface"), ptte->szInterface);
    {
        switch (ptte->dwData) {
            case ISURFACE8:
                hr = ((LPDIRECT3DSURFACE8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)&pd3dd, sizeof(IUnknown*), D3DSPD_IUNKNOWN);
                break;
            case IVOLUME8:
                hr = ((LPDIRECT3DVOLUME8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)&pd3dd, sizeof(IUnknown*), D3DSPD_IUNKNOWN);
                break;
            default:
                hr = ((LPDIRECT3DRESOURCE8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)&pd3dd, sizeof(IUnknown*), D3DSPD_IUNKNOWN);
                break;
        }

        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::SetPrivateData failed on D3DSPD_IUNKNOWN [0x%X]"), ptte->szInterface, hr);
            return TR_FAIL;
        }

        pd3dd->AddRef();
        uRef2 = pd3dd->Release();

        if (uRef2 != uRef1 + 1) {
            Log(LOG_FAIL, TEXT("%s::SetPrivateData failed to increment the reference count on the given object"), ptte->szInterface);
            tr = TR_FAIL;
        }

        dwSize = sizeof(IUnknown*);
        switch (ptte->dwData) {
            case ISURFACE8:
                hr = ((LPDIRECT3DSURFACE8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)&punk, &dwSize);
                break;
            case IVOLUME8:
                hr = ((LPDIRECT3DVOLUME8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)&punk, &dwSize);
                break;
            default:
                hr = ((LPDIRECT3DRESOURCE8)pvObject)->GetPrivateData(GUID_PRIVATEDATA, (LPVOID)&punk, &dwSize);
                break;
        }

        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::GetPrivateData failed [0x%X]"), ptte->szInterface, hr);
            return TR_FAIL;
        }

        if ((LPVOID)punk != (LPVOID)pd3dd) {
            Log(LOG_FAIL, TEXT("%s::GetPrivateData returned an incorrect pointer for an interface set with D3DSPD_IUNKNOWN"), ptte->szInterface);
            tr = TR_FAIL;
        }

        switch (ptte->dwData) {
            case ISURFACE8:
                hr = ((LPDIRECT3DSURFACE8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
                break;
            case IVOLUME8:
                hr = ((LPDIRECT3DVOLUME8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
                break;
            default:
                hr = ((LPDIRECT3DRESOURCE8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
                break;
        }

        pd3dd->AddRef();
        uRef2 = pd3dd->Release();

        if (uRef1 != uRef2) {
            Log(LOG_FAIL, TEXT("%s::FreePrivateData failed to decrement the reference count on the interface whose pointer was set"), ptte->szInterface);
            tr = TR_FAIL;
        }
    }
    LogEndVariation();

    LogBeginVariation(TEXT("%s::SetPrivateData to replace an interface pointer with data"), ptte->szInterface);
    {
        switch (ptte->dwData) {
            case ISURFACE8:
                hr = ((LPDIRECT3DSURFACE8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)&pd3dd, sizeof(IUnknown*), D3DSPD_IUNKNOWN);
                break;
            case IVOLUME8:
                hr = ((LPDIRECT3DVOLUME8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)&pd3dd, sizeof(IUnknown*), D3DSPD_IUNKNOWN);
                break;
            default:
                hr = ((LPDIRECT3DRESOURCE8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)&pd3dd, sizeof(IUnknown*), D3DSPD_IUNKNOWN);
                break;
        }

        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::SetPrivateData failed on D3DSPD_IUNKNOWN [0x%X]"), ptte->szInterface, hr);
            return TR_FAIL;
        }

        switch (ptte->dwData) {
            case ISURFACE8:
                hr = ((LPDIRECT3DSURFACE8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)&pd3dd, sizeof(IUnknown*), 0);
                break;
            case IVOLUME8:
                hr = ((LPDIRECT3DVOLUME8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)&pd3dd, sizeof(IUnknown*), 0);
                break;
            default:
                hr = ((LPDIRECT3DRESOURCE8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)&pd3dd, sizeof(IUnknown*), 0);
                break;
        }

        pd3dd->AddRef();
        uRef2 = pd3dd->Release();

        if (uRef1 != uRef2) {
            Log(LOG_FAIL, TEXT("%s::SetPrivateData failed to decrement the reference count on the interface whose pointer was replaced"), ptte->szInterface);
            tr = TR_FAIL;
        }
    }
    LogEndVariation();

    switch (ptte->dwData) {
        case ISURFACE8:
            hr = ((LPDIRECT3DSURFACE8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
            break;
        case IVOLUME8:
            hr = ((LPDIRECT3DVOLUME8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
            break;
        default:
            hr = ((LPDIRECT3DRESOURCE8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
            break;
    }

    if (FAILED(hr)) {
        Log(LOG_FAIL, TEXT("%s::FreePrivateData failed [0x%X]"), ptte->szInterface, hr);
        return TR_FAIL;
    }

#endif // !UNDER_XBOX
    
    return tr;
}

//******************************************************************************
TESTPROCAPI TSHR8_FreePrivateData(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    HRESULT             hr;
    BYTE                pdataSet[2971];
    TRESULT             tr = TR_PASS;

    LogBeginVariation(TEXT("%s::FreePrivateData using a reference with no data set"), ptte->szInterface);
    {
        switch (ptte->dwData) {
            case ISURFACE8:
                hr = ((LPDIRECT3DSURFACE8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
                break;
            case IVOLUME8:
                hr = ((LPDIRECT3DVOLUME8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
                break;
            default:
                hr = ((LPDIRECT3DRESOURCE8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
                break;
        }

#ifndef UNDER_XBOX
        if (hr != D3DERR_NOTFOUND) {
            Log(LOG_FAIL, TEXT("%s::FreePrivateData returned 0x%X instead of D3DERR_NOTFOUND using a reference with no data set"), ptte->szInterface, hr);
            tr = TR_FAIL;
        }
#endif
    }
    LogEndVariation();

    switch (ptte->dwData) {
        case ISURFACE8:
            hr = ((LPDIRECT3DSURFACE8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataSet, 2971, 0);
            break;
        case IVOLUME8:
            hr = ((LPDIRECT3DVOLUME8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataSet, 2971, 0);
            break;
        default:
            hr = ((LPDIRECT3DRESOURCE8)pvObject)->SetPrivateData(GUID_PRIVATEDATA, (LPVOID)pdataSet, 2971, 0);
            break;
    }

    if (FAILED(hr)) {
        Log(LOG_FAIL, TEXT("%s::SetPrivateData failed [0x%X]"), ptte->szInterface, hr);
        return TR_FAIL;
    }

    LogBeginVariation(TEXT("%s::FreePrivateData on a block of data"), ptte->szInterface);
    {
        switch (ptte->dwData) {
            case ISURFACE8:
                hr = ((LPDIRECT3DSURFACE8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
                break;
            case IVOLUME8:
                hr = ((LPDIRECT3DVOLUME8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
                break;
            default:
                hr = ((LPDIRECT3DRESOURCE8)pvObject)->FreePrivateData(GUID_PRIVATEDATA);
                break;
        }

        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::FreePrivateData failed [0x%X]"), ptte->szInterface, hr);
            return TR_FAIL;
        }
    }
    LogEndVariation();

    return tr;
}

//******************************************************************************
TESTPROCAPI TSHR8_LockRect(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    D3DLOCKED_RECT      d3dlr;
    RECT                rect, *prect[2];
    HRESULT             hr;
    UINT                i, j;
    BYTE                byte;
    D3DCUBEMAP_FACES    d3dcf;
    TRESULT             tr = TR_PASS;
    DWORD               dwFlags[] = {
                            0,
#ifndef UNDER_XBOX
                            D3DLOCK_DISCARD, 
                            D3DLOCK_NO_DIRTY_UPDATE, 
                            D3DLOCK_NOSYSLOCK, 
#endif
                            D3DLOCK_READONLY, 
                        };
    LPCTSTR             szFlags[] = {
                            TEXT("no"),
#ifndef UNDER_XBOX
                            TEXT("D3DLOCK_DISCARD"), 
                            TEXT("D3DLOCK_NO_DIRTY_UPDATE"), 
                            TEXT("D3DLOCK_NOSYSLOCK"), 
#endif
                            TEXT("D3DLOCK_READONLY"), 
                        };

    rect.left = 1;
    rect.top = 1;
    rect.right = 10;
    rect.bottom = 10;
    prect[0] = NULL;
    prect[1] = &rect;

    for (i = 0; i < 2; i++) {

        for (j = 0; j < countof(dwFlags); j++) {

            LogBeginVariation(TEXT("%s::LockRect using a %srect and %s flag"), ptte->szInterface, i ? TEXT("sub") : TEXT("NULL "), szFlags[j]);
            {
                d3dlr.Pitch = 0;
                d3dlr.pBits = NULL;

                switch (ptte->dwData) {

                    case ISURFACE8:
                        hr = ((LPDIRECT3DSURFACE8)pvObject)->LockRect(&d3dlr, prect[i], dwFlags[j]);
                        break;

                    case ITEXTURE8:
                        hr = ((LPDIRECT3DTEXTURE8)pvObject)->LockRect(0, &d3dlr, prect[i], dwFlags[j]);
                        break;

                    case ICUBETEXTURE8:
                        d3dcf = (D3DCUBEMAP_FACES)(rand() % 6);
                        hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->LockRect(d3dcf, 0, &d3dlr, prect[i], dwFlags[j]);
                        break;

                    default:
                        LogEndVariation();
                        return TR_ABORT;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::LockRect failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (d3dlr.Pitch < 2 * TEXTUREDIM) {
                    Log(LOG_FAIL, TEXT("%s::LockRect returned an incorrect pitch of %d for the locked rect"), ptte->szInterface, d3dlr.Pitch);
                    tr = TR_FAIL;
                }

                if (!d3dlr.pBits) {
                    Log(LOG_FAIL, TEXT("%s::LockRect returned a NULL pointer to resource memory"), ptte->szInterface);
                    tr = TR_FAIL;
                }
                else {

                    // Reference the memory
                    byte = *((LPBYTE)d3dlr.pBits);
                    if (j != 3) {
                        *((LPBYTE)d3dlr.pBits) = byte;
                    }
                }

                switch (ptte->dwData) {

                    case ISURFACE8:
                        hr = ((LPDIRECT3DSURFACE8)pvObject)->UnlockRect();
                        break;

                    case ITEXTURE8:
                        hr = ((LPDIRECT3DTEXTURE8)pvObject)->UnlockRect(0);
                        break;

                    case ICUBETEXTURE8:
                        hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->UnlockRect(d3dcf, 0);
                        break;

                    default:
                        LogEndVariation();
                        return TR_ABORT;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::UnlockRect failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }
            }

            LogEndVariation();
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSHR8_UnlockRect(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    D3DLOCKED_RECT      d3dlr;
    RECT                rect, *prect[2];
    HRESULT             hr;
    UINT                i, j;
    WORD                wPixel;
    D3DCUBEMAP_FACES    d3dcf;
    TRESULT             tr = TR_PASS;
    DWORD               dwFlags[] = {
                            0,
#ifndef UNDER_XBOX
                            D3DLOCK_DISCARD, 
                            D3DLOCK_NO_DIRTY_UPDATE, 
                            D3DLOCK_NOSYSLOCK, 
#endif
                        };
    LPCTSTR             szFlags[] = {
                            TEXT("no"),
#ifndef UNDER_XBOX
                            TEXT("D3DLOCK_DISCARD"), 
                            TEXT("D3DLOCK_NO_DIRTY_UPDATE"), 
                            TEXT("D3DLOCK_NOSYSLOCK"), 
#endif
                        };

    rect.left = 1;
    rect.top = 1;
    rect.right = 10;
    rect.bottom = 10;
    prect[0] = NULL;
    prect[1] = &rect;

    for (i = 0; i < 2; i++) {

        for (j = 0; j < countof(dwFlags); j++) {

            LogBeginVariation(TEXT("%s::UnlockRect using a %srect and %s flag"), ptte->szInterface, i ? TEXT("sub") : TEXT("NULL "), szFlags[j]);
            {
                switch (ptte->dwData) {

                    case ISURFACE8:
                        hr = ((LPDIRECT3DSURFACE8)pvObject)->LockRect(&d3dlr, prect[i], dwFlags[j]);
                        break;

                    case ITEXTURE8:
                        hr = ((LPDIRECT3DTEXTURE8)pvObject)->LockRect(0, &d3dlr, prect[i], dwFlags[j]);
                        break;

                    case ICUBETEXTURE8:
                        d3dcf = (D3DCUBEMAP_FACES)(rand() % 6);
                        hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->LockRect(d3dcf, 0, &d3dlr, prect[i], dwFlags[j]);
                        break;

                    default:
                        LogEndVariation();
                        return TR_ABORT;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::LockRect failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (!d3dlr.pBits) {
                    Log(LOG_FAIL, TEXT("%s::LockRect returned a NULL pointer to resource memory"), ptte->szInterface);
                    tr = TR_FAIL;
                }
                else {

                    wPixel = rand() % 0xFFFF;
                    *((LPWORD)d3dlr.pBits) = wPixel;
                }

                switch (ptte->dwData) {

                    case ISURFACE8:
                        hr = ((LPDIRECT3DSURFACE8)pvObject)->UnlockRect();
                        break;

                    case ITEXTURE8:
                        hr = ((LPDIRECT3DTEXTURE8)pvObject)->UnlockRect(0);
                        break;

                    case ICUBETEXTURE8:
                        hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->UnlockRect(d3dcf, 0);
                        break;

                    default:
                        LogEndVariation();
                        return TR_ABORT;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::UnlockRect failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                d3dlr.pBits = NULL;

                switch (ptte->dwData) {

                    case ISURFACE8:
                        hr = ((LPDIRECT3DSURFACE8)pvObject)->LockRect(&d3dlr, prect[i], dwFlags[j]);
                        break;

                    case ITEXTURE8:
                        hr = ((LPDIRECT3DTEXTURE8)pvObject)->LockRect(0, &d3dlr, prect[i], dwFlags[j]);
                        break;

                    case ICUBETEXTURE8:
                        hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->LockRect(d3dcf, 0, &d3dlr, prect[i], dwFlags[j]);
                        break;

                    default:
                        LogEndVariation();
                        return TR_ABORT;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::LockRect failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (*((LPWORD)d3dlr.pBits) != wPixel) {
                    Log(LOG_FAIL, TEXT("Pixel data failed to persist after calling %s::UnlockRect (set 0x%X, retrieved 0x%X"), ptte->szInterface, wPixel, *((LPWORD)d3dlr.pBits));
                    tr = TR_FAIL;
                }

                switch (ptte->dwData) {

                    case ISURFACE8:
                        hr = ((LPDIRECT3DSURFACE8)pvObject)->UnlockRect();
                        break;

                    case ITEXTURE8:
                        hr = ((LPDIRECT3DTEXTURE8)pvObject)->UnlockRect(0);
                        break;

                    case ICUBETEXTURE8:
                        hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->UnlockRect(d3dcf, 0);
                        break;

                    default:
                        LogEndVariation();
                        return TR_ABORT;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::UnlockRect failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (i) {

                    d3dlr.pBits = NULL;

                    switch (ptte->dwData) {

                        case ISURFACE8:
                            hr = ((LPDIRECT3DSURFACE8)pvObject)->LockRect(&d3dlr, NULL, dwFlags[j]);
                            break;

                        case ITEXTURE8:
                            hr = ((LPDIRECT3DTEXTURE8)pvObject)->LockRect(0, &d3dlr, NULL, dwFlags[j]);
                            break;

                        case ICUBETEXTURE8:
                            hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->LockRect(d3dcf, 0, &d3dlr, NULL, dwFlags[j]);
                            break;

                        default:
                            LogEndVariation();
                            return TR_ABORT;
                    }

                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("%s::LockRect failed [0x%X]"), ptte->szInterface, hr);
                        LogEndVariation();
                        return TR_FAIL;
                    }

                    if (*((LPWORD)((LPBYTE)d3dlr.pBits + d3dlr.Pitch + 2)) != wPixel) {
                        Log(LOG_FAIL, TEXT("Surface pointer inconsistent with the rectangle given in %s::LockRect"), ptte->szInterface);
                        tr = TR_FAIL;
                    }

                    switch (ptte->dwData) {

                        case ISURFACE8:
                            hr = ((LPDIRECT3DSURFACE8)pvObject)->UnlockRect();
                            break;

                        case ITEXTURE8:
                            hr = ((LPDIRECT3DTEXTURE8)pvObject)->UnlockRect(0);
                            break;

                        case ICUBETEXTURE8:
                            hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->UnlockRect(d3dcf, 0);
                            break;

                        default:
                            LogEndVariation();
                            return TR_ABORT;
                    }

                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("%s::UnlockRect failed [0x%X]"), ptte->szInterface, hr);
                        LogEndVariation();
                        return TR_FAIL;
                    }
                }
            }

            LogEndVariation();
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSHR8_LockBox(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    D3DLOCKED_BOX       d3dlb;
    D3DBOX              box, *pbox[2];
    HRESULT             hr;
    UINT                i, j;
    BYTE                byte;
    TRESULT             tr = TR_PASS;
    DWORD               dwFlags[] = {
                            0,
#ifndef UNDER_XBOX
                            D3DLOCK_DISCARD, 
                            D3DLOCK_NO_DIRTY_UPDATE, 
                            D3DLOCK_NOSYSLOCK, 
#endif
                            D3DLOCK_READONLY, 
                        };
    LPCTSTR             szFlags[] = {
                            TEXT("no"),
#ifndef UNDER_XBOX
                            TEXT("D3DLOCK_DISCARD"), 
                            TEXT("D3DLOCK_NO_DIRTY_UPDATE"), 
                            TEXT("D3DLOCK_NOSYSLOCK"), 
#endif
                            TEXT("D3DLOCK_READONLY"), 
                        };

    box.Left = 1;
    box.Top = 1;
    box.Front = 1;
    box.Right = 10;
    box.Bottom = 10;
    box.Back = 10;
    pbox[0] = NULL;
    pbox[1] = &box;

    for (i = 0; i < 2; i++) {

        for (j = 0; j < countof(dwFlags); j++) {

            LogBeginVariation(TEXT("%s::LockBox using a %sbox and %s flag"), ptte->szInterface, i ? TEXT("sub") : TEXT("NULL "), szFlags[j]);
            {
                d3dlb.RowPitch = 0;
                d3dlb.SlicePitch = 0;
                d3dlb.pBits = NULL;

                switch (ptte->dwData) {

                    case IVOLUME8:
                        hr = ((LPDIRECT3DVOLUME8)pvObject)->LockBox(&d3dlb, pbox[i], dwFlags[j]);
                        break;

                    case IVOLUMETEXTURE8:
                        hr = ((LPDIRECT3DVOLUMETEXTURE8)pvObject)->LockBox(0, &d3dlb, pbox[i], dwFlags[j]);
                        break;

                    default:
                        LogEndVariation();
                        return TR_ABORT;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::LockBox failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (d3dlb.RowPitch < 2 * TEXTUREDIM) {
                    Log(LOG_FAIL, TEXT("%s::LockBox returned an incorrect row pitch of %d for the locked box"), ptte->szInterface, d3dlb.RowPitch);
                    tr = TR_FAIL;
                }

                if (d3dlb.SlicePitch < TEXTUREDIM * d3dlb.RowPitch) {
                    Log(LOG_FAIL, TEXT("%s::LockBox returned an incorrect slice pitch of %d for the locked box"), ptte->szInterface, d3dlb.SlicePitch);
                    tr = TR_FAIL;
                }

                if (!d3dlb.pBits) {
                    Log(LOG_FAIL, TEXT("%s::LockBox returned a NULL pointer to resource memory"), ptte->szInterface);
                    tr = TR_FAIL;
                }
                else {

                    // Reference the memory
                    byte = *((LPBYTE)d3dlb.pBits);
                    if (j != 3) {
                        *((LPBYTE)d3dlb.pBits) = byte;
                    }
                }

                switch (ptte->dwData) {

                    case IVOLUME8:
                        hr = ((LPDIRECT3DVOLUME8)pvObject)->UnlockBox();
                        break;

                    case IVOLUMETEXTURE8:
                        hr = ((LPDIRECT3DVOLUMETEXTURE8)pvObject)->UnlockBox(0);
                        break;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::UnlockBox failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }
            }

            LogEndVariation();
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSHR8_UnlockBox(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    D3DLOCKED_BOX       d3dlb;
    D3DBOX              box, *pbox[2];
    HRESULT             hr;
    UINT                i, j;
    WORD                wPixel;
    TRESULT             tr = TR_PASS;
    DWORD               dwFlags[] = {
                            0,
#ifndef UNDER_XBOX
                            D3DLOCK_DISCARD, 
                            D3DLOCK_NO_DIRTY_UPDATE, 
                            D3DLOCK_NOSYSLOCK, 
#endif
                        };
    LPCTSTR             szFlags[] = {
                            TEXT("no"),
#ifndef UNDER_XBOX
                            TEXT("D3DLOCK_DISCARD"), 
                            TEXT("D3DLOCK_NO_DIRTY_UPDATE"), 
                            TEXT("D3DLOCK_NOSYSLOCK"), 
#endif
                        };

    box.Left = 1;
    box.Top = 1;
    box.Front = 1;
    box.Right = 10;
    box.Bottom = 10;
    box.Back = 10;
    pbox[0] = NULL;
    pbox[1] = &box;

    for (i = 0; i < 2; i++) {

        for (j = 0; j < countof(dwFlags); j++) {

            LogBeginVariation(TEXT("%s::UnlockBox using a %sbox and %s flag"), ptte->szInterface, i ? TEXT("sub") : TEXT("NULL "), szFlags[j]);
            {
                switch (ptte->dwData) {

                    case IVOLUME8:
                        hr = ((LPDIRECT3DVOLUME8)pvObject)->LockBox(&d3dlb, pbox[i], dwFlags[j]);
                        break;

                    case IVOLUMETEXTURE8:
                        hr = ((LPDIRECT3DVOLUMETEXTURE8)pvObject)->LockBox(0, &d3dlb, pbox[i], dwFlags[j]);
                        break;

                    default:
                        LogEndVariation();
                        return TR_ABORT;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::LockBox failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (!d3dlb.pBits) {
                    Log(LOG_FAIL, TEXT("%s::LockBox returned a NULL pointer to resource memory"), ptte->szInterface);
                    tr = TR_FAIL;
                }
                else {

                    wPixel = rand() % 0xFFFF;
                    *((LPWORD)d3dlb.pBits) = wPixel;
                }

                switch (ptte->dwData) {

                    case IVOLUME8:
                        hr = ((LPDIRECT3DVOLUME8)pvObject)->UnlockBox();
                        break;

                    case IVOLUMETEXTURE8:
                        hr = ((LPDIRECT3DVOLUMETEXTURE8)pvObject)->UnlockBox(0);
                        break;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::UnlockBox failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                d3dlb.pBits = NULL;

                switch (ptte->dwData) {

                    case IVOLUME8:
                        hr = ((LPDIRECT3DVOLUME8)pvObject)->LockBox(&d3dlb, pbox[i], dwFlags[j]);
                        break;

                    case IVOLUMETEXTURE8:
                        hr = ((LPDIRECT3DVOLUMETEXTURE8)pvObject)->LockBox(0, &d3dlb, pbox[i], dwFlags[j]);
                        break;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::LockBox failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (*((LPWORD)d3dlb.pBits) != wPixel) {
                    Log(LOG_FAIL, TEXT("Pixel data failed to persist after calling %s::UnlockBox"), ptte->szInterface);
                    tr = TR_FAIL;
                }

                switch (ptte->dwData) {

                    case IVOLUME8:
                        hr = ((LPDIRECT3DVOLUME8)pvObject)->UnlockBox();
                        break;

                    case IVOLUMETEXTURE8:
                        hr = ((LPDIRECT3DVOLUMETEXTURE8)pvObject)->UnlockBox(0);
                        break;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::UnlockBox failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (i) {

                    d3dlb.pBits = NULL;

                    switch (ptte->dwData) {

                        case IVOLUME8:
                            hr = ((LPDIRECT3DVOLUME8)pvObject)->LockBox(&d3dlb, NULL, dwFlags[j]);
                            break;

                        case IVOLUMETEXTURE8:
                            hr = ((LPDIRECT3DVOLUMETEXTURE8)pvObject)->LockBox(0, &d3dlb, NULL, dwFlags[j]);
                            break;
                    }

                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("%s::LockBox failed [0x%X]"), ptte->szInterface, hr);
                        LogEndVariation();
                        return TR_FAIL;
                    }

                    if (*((LPWORD)((LPBYTE)d3dlb.pBits + d3dlb.SlicePitch + d3dlb.RowPitch + 2)) != wPixel) {
                        Log(LOG_FAIL, TEXT("Surface pointer inconsistent with the box given in %s::LockBox"), ptte->szInterface);
                        tr = TR_FAIL;
                    }

                    switch (ptte->dwData) {

                        case IVOLUME8:
                            hr = ((LPDIRECT3DVOLUME8)pvObject)->UnlockBox();
                            break;

                        case IVOLUMETEXTURE8:
                            hr = ((LPDIRECT3DVOLUMETEXTURE8)pvObject)->UnlockBox(0);
                            break;
                    }

                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("%s::UnlockBox failed [0x%X]"), ptte->szInterface, hr);
                        LogEndVariation();
                        return TR_FAIL;
                    }
                }
            }

            LogEndVariation();
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSHR8_GetLevelDesc(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    D3DSURFACE_DESC     d3dsd;
    UINT                uLength;
    UINT                uLevels;
    UINT                i;
    D3DRESOURCETYPE     d3drt;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    for (uLevels = 1; 0x1 << (uLevels - 1) != TEXTUREDIM; uLevels++);

    for (i = 0; i < uLevels; i++) {

        switch (ptte->dwData) {

            case ITEXTURE8:
                LogBeginVariation(TEXT("IDirect3DTexture8::GetLevelDesc on texture level %d"), i);
                hr = ((LPDIRECT3DTEXTURE8)pvObject)->GetLevelDesc(i, &d3dsd);
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::%s failed for level %d [0x%X]"), ptte->szInterface, ptte->szMethod, i, hr);
                    return TR_FAIL;
                }
                d3drt = D3DRTYPE_TEXTURE;
                break;

            case ICUBETEXTURE8:
                LogBeginVariation(TEXT("IDirect3DCubeTexture8::GetLevelDesc on cube texture level %d"), i);
                hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->GetLevelDesc(i, &d3dsd);
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::%s failed for level %d [0x%X]"), ptte->szInterface, ptte->szMethod, i, hr);
                    return TR_FAIL;
                }
                d3drt = D3DRTYPE_CUBETEXTURE;
                break;

            default:
                return TR_ABORT;
        }

        uLength = (0x1 << ((uLevels - 1) - i));

        if (d3dsd.Width != uLength) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect width of %d instead of %d for level %d"), ptte->szInterface, d3dsd.Width, uLength, i);
            tr = TR_FAIL;
        }

        if (d3dsd.Height != uLength) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect height of %d instead of %d for level %d"), ptte->szInterface, d3dsd.Height, uLength, i);
            tr = TR_FAIL;
        }

        if (d3dsd.Size < uLength * uLength * 2) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect size of %d for level %d"), ptte->szInterface, d3dsd.Size, i);
            tr = TR_FAIL;
        }

#ifndef UNDER_XBOX
        if (d3dsd.Pool != D3DPOOL_MANAGED) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect pool for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }
#endif // !UNDER_XBOX

        if (d3dsd.Usage != 0) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect usage for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }

        if (d3dsd.Type != d3drt) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect type for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }

        if (d3dsd.Format != D3DFMT_A1R5G5B5) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect format for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }

        LogEndVariation();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSHR8_GetSurfaceLevel(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    LPDIRECT3DSURFACE8  pd3ds, pd3ds2;
    D3DSURFACE_DESC     d3dsd;
    ULONG               uRef1, uRef2;
    UINT                uLevels;
    UINT                uLength;
    UINT                i;
    D3DCUBEMAP_FACES    d3dcf;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    for (uLevels = 1; 0x1 << (uLevels - 1) != TEXTUREDIM; uLevels++);

    for (i = 0; i < uLevels; i++) {

        switch (ptte->dwData) {

            case ITEXTURE8:
                LogBeginVariation(TEXT("IDirect3DTexture8::GetSurfaceLevel on texture level %d"), i);
                hr = ((LPDIRECT3DTEXTURE8)pvObject)->GetSurfaceLevel(i, &pd3ds);
                break;

            case ICUBETEXTURE8:
                LogBeginVariation(TEXT("IDirect3DCubeTexture8::GetCubeMapSurface on cube texture level %d"), i);
                d3dcf = (D3DCUBEMAP_FACES)(rand() % 6);
                hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->GetCubeMapSurface(d3dcf, i, &pd3ds);
                break;

            default:
                return TR_ABORT;
        }

        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::%s failed for level %d [0x%X]"), ptte->szInterface, ptte->szMethod, i, hr);
            return TR_FAIL;
        }

        pd3ds->AddRef();
        uRef1 = pd3ds->Release();

        switch (ptte->dwData) {

            case ITEXTURE8:
                hr = ((LPDIRECT3DTEXTURE8)pvObject)->GetSurfaceLevel(i, &pd3ds2);
                break;

            case ICUBETEXTURE8:
                hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->GetCubeMapSurface(d3dcf, i, &pd3ds2);
                break;

            default:
                pd3ds->Release();
                return TR_ABORT;
        }

        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::%s failed for level %d [0x%X]"), ptte->szInterface, ptte->szMethod, i, hr);
            pd3ds->Release();
            return TR_FAIL;
        }

#ifndef UNDER_XBOX
        if (pd3ds2 != pd3ds) {
            Log(LOG_FAIL, TEXT("%s::%s returned an incorrect surface pointer for level %d"), ptte->szInterface, ptte->szMethod, i);
            tr = TR_FAIL;
        }
#endif // !UNDER_XBOX

        pd3ds->AddRef();
        uRef2 = pd3ds->Release();

#ifndef UNDER_XBOX
        if (uRef2 != uRef1 + 1) {
            Log(LOG_FAIL, TEXT("%s::%s failed to increment the reference count of the surface for level %d"), ptte->szInterface, ptte->szMethod, i);
        }
#endif // !UNDER_XBOX

        pd3ds2->Release();

        hr = pd3ds->GetDesc(&d3dsd);
        pd3ds->Release();
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("IDirect3DSurface8::GetDesc failed [0x%X]"), hr);
            return TR_FAIL;
        }

        uLength = (0x1 << ((uLevels - 1) - i));

        if (d3dsd.Width != uLength) {
            Log(LOG_FAIL, TEXT("IDirect3DSurface8::GetDesc returned an incorrect width of %d instead of %d for level %d"), ptte->szInterface, d3dsd.Width, uLength, i);
            tr = TR_FAIL;
        }

        if (d3dsd.Height != uLength) {
            Log(LOG_FAIL, TEXT("IDirect3DSurface8::GetDesc returned an incorrect height of %d instead of %d for level %d"), ptte->szInterface, d3dsd.Height, uLength, i);
            tr = TR_FAIL;
        }

        if (d3dsd.Size < uLength * uLength * 2) {
            Log(LOG_FAIL, TEXT("IDirect3DSurface8::GetDesc returned an incorrect size of %d for level %d"), ptte->szInterface, d3dsd.Size, i);
            tr = TR_FAIL;
        }

#ifndef UNDER_XBOX
        if (d3dsd.Pool != D3DPOOL_MANAGED) {
            Log(LOG_FAIL, TEXT("IDirect3DSurface8::GetDesc returned an incorrect pool for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }
#endif

        if (d3dsd.Usage != 0) {
            Log(LOG_FAIL, TEXT("IDirect3DSurface8::GetDesc returned an incorrect usage for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }

        if (d3dsd.Type != D3DRTYPE_SURFACE) {
            Log(LOG_FAIL, TEXT("IDirect3DSurface8::GetDesc returned an incorrect type for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }

        if (d3dsd.Format != D3DFMT_A1R5G5B5) {
            Log(LOG_FAIL, TEXT("IDirect3DSurface8::GetDesc returned an incorrect format for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }

        LogEndVariation();
    }

    return tr;
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TSHR8_AddDirtyRect(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    RECT                rect, *prect[2];
    UINT                i;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    rect.left = 11;
    rect.top = 9;
    rect.right = 12;
    rect.bottom = 17;
    prect[0] = NULL;
    prect[1] = &rect;

    for (i = 0; i < 2; i++) {

        switch (ptte->dwData) {

            case ITEXTURE8:
                LogBeginVariation(TEXT("IDirect3DTexture8::AddDirtyRect on a %srect"), i ? TEXT("sub") : TEXT("NULL "));
                hr = ((LPDIRECT3DTEXTURE8)pvObject)->AddDirtyRect(prect[i]);
                break;

            case ICUBETEXTURE8:
                LogBeginVariation(TEXT("IDirect3DCubeTexture8::AddDirtyRect on a %srect"), i ? TEXT("sub") : TEXT("NULL "));
                hr = ((LPDIRECT3DCUBETEXTURE8)pvObject)->AddDirtyRect((D3DCUBEMAP_FACES)(rand() % 6), prect[i]);
                break;

            default:
                return TR_ABORT;
        }

        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::AddDirtyRect failed [0x%X]"), ptte->szInterface, hr);
            tr = TR_FAIL;
        }

        LogEndVariation();
    }

    return tr;
}

#endif // !UNDER_XBOX

//******************************************************************************
TESTPROCAPI TSHR8_Lock(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    LPBYTE              pdata;
    UINT                uOffset[2];
    UINT                uSize[2];
    HRESULT             hr;
    UINT                i, j;
    BYTE                byte;
    TRESULT             tr = TR_PASS;
    DWORD               dwFlags[] = {
                            0,
#ifndef UNDER_XBOX
                            D3DLOCK_DISCARD, 
                            D3DLOCK_NO_DIRTY_UPDATE, 
                            D3DLOCK_NOSYSLOCK, 
#endif
                            D3DLOCK_NOOVERWRITE,
                            D3DLOCK_READONLY, 
                        };
    LPCTSTR             szFlags[] = {
                            TEXT("no"),
#ifndef UNDER_XBOX
                            TEXT("D3DLOCK_DISCARD"), 
                            TEXT("D3DLOCK_NO_DIRTY_UPDATE"), 
                            TEXT("D3DLOCK_NOSYSLOCK"), 
#endif
                            TEXT("D3DLOCK_NOOVERWRITE"),
                            TEXT("D3DLOCK_READONLY"), 
                        };

    uOffset[0] = 0;
    uOffset[1] = VERTBUFFSIZE < INDXBUFFSIZE ? VERTBUFFSIZE : INDXBUFFSIZE;
    uOffset[1] /= 2;

    switch (ptte->dwData) {

        case IVERTEXBUFFER8:
            uSize[0] = VERTBUFFSIZE;
            uSize[1] = VERTBUFFSIZE - uOffset[1];
            break;

        case IINDEXBUFFER8:
            uSize[0] = INDXBUFFSIZE;
            uSize[1] = INDXBUFFSIZE - uOffset[1];
            break;

        default:
            return TR_ABORT;
    }

    for (i = 0; i < 2; i++) {

        for (j = 0; j < countof(dwFlags); j++) {

            LogBeginVariation(TEXT("%s::Lock %s an offset and using %s flag"), ptte->szInterface, i ? TEXT("with") : TEXT("without"), szFlags[j]);
            {
                pdata = NULL;

                switch (ptte->dwData) {

                    case IVERTEXBUFFER8:
                        hr = ((LPDIRECT3DVERTEXBUFFER8)pvObject)->Lock(uOffset[i], uSize[i], &pdata, dwFlags[j]);
                        break;

                    case IINDEXBUFFER8:
                        hr = ((LPDIRECT3DINDEXBUFFER8)pvObject)->Lock(uOffset[i], uSize[i], &pdata, dwFlags[j]);
                        break;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::Lock failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (!pdata) {
                    Log(LOG_FAIL, TEXT("%s::Lock returned a NULL pointer to buffer memory"), ptte->szInterface);
                    tr = TR_FAIL;
                }
                else {

                    // Reference the memory
                    byte = *pdata;
                    if (j != 4) {
                        *pdata = byte;
                    }
                }

                switch (ptte->dwData) {

                    case IVERTEXBUFFER8:
                        hr = ((LPDIRECT3DVERTEXBUFFER8)pvObject)->Unlock();
                        break;

                    case IINDEXBUFFER8:
                        hr = ((LPDIRECT3DINDEXBUFFER8)pvObject)->Unlock();
                        break;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::Unlock failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }
            }

            LogEndVariation();
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSHR8_Unlock(PTESTTABLEENTRY ptte, LPVOID pvObject) {

    LPBYTE              pdata;
    UINT                uOffset[2];
    UINT                uSize[2];
    HRESULT             hr;
    UINT                i, j;
    BYTE                byte;
    TRESULT             tr = TR_PASS;
    DWORD               dwFlags[] = {
                            0,
#ifndef UNDER_XBOX
                            D3DLOCK_DISCARD, 
                            D3DLOCK_NO_DIRTY_UPDATE, 
                            D3DLOCK_NOSYSLOCK, 
#endif
                            D3DLOCK_NOOVERWRITE,
                        };
    LPCTSTR             szFlags[] = {
                            TEXT("no"),
#ifndef UNDER_XBOX
                            TEXT("D3DLOCK_DISCARD"), 
                            TEXT("D3DLOCK_NO_DIRTY_UPDATE"), 
                            TEXT("D3DLOCK_NOSYSLOCK"), 
#endif
                            TEXT("D3DLOCK_NOOVERWRITE"),
                        };

    uOffset[0] = 0;
    uOffset[1] = VERTBUFFSIZE < INDXBUFFSIZE ? VERTBUFFSIZE : INDXBUFFSIZE;
    uOffset[1] /= 2;

    switch (ptte->dwData) {

        case IVERTEXBUFFER8:
            uSize[0] = rand() % 2 ? VERTBUFFSIZE : 0;
            uSize[1] = VERTBUFFSIZE - uOffset[1];
            break;

        case IINDEXBUFFER8:
            uSize[0] = rand() % 2 ? INDXBUFFSIZE : 0;
            uSize[1] = INDXBUFFSIZE - uOffset[1];
            break;

        default:
            return TR_ABORT;
    }

    for (i = 0; i < 2; i++) {

        for (j = 0; j < countof(dwFlags); j++) {

            LogBeginVariation(TEXT("%s::Unlock %s an offset and using %s flag"), ptte->szInterface, i ? TEXT("with") : TEXT("without"), szFlags[j]);
            {
                switch (ptte->dwData) {

                    case IVERTEXBUFFER8:
                        hr = ((LPDIRECT3DVERTEXBUFFER8)pvObject)->Lock(uOffset[i], uSize[i], &pdata, dwFlags[j]);
                        break;

                    case IINDEXBUFFER8:
                        hr = ((LPDIRECT3DINDEXBUFFER8)pvObject)->Lock(uOffset[i], uSize[i], &pdata, dwFlags[j]);
                        break;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::Lock failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (!pdata) {
                    Log(LOG_FAIL, TEXT("%s::Lock returned a NULL pointer to buffer memory"), ptte->szInterface);
                    tr = TR_FAIL;
                }
                else {

                    byte = rand() % 256;
                    *pdata = byte;
                }

                switch (ptte->dwData) {

                    case IVERTEXBUFFER8:
                        hr = ((LPDIRECT3DVERTEXBUFFER8)pvObject)->Unlock();
                        break;

                    case IINDEXBUFFER8:
                        hr = ((LPDIRECT3DINDEXBUFFER8)pvObject)->Unlock();
                        break;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::Unlock failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                pdata = NULL;

                switch (ptte->dwData) {

                    case IVERTEXBUFFER8:
                        hr = ((LPDIRECT3DVERTEXBUFFER8)pvObject)->Lock(uOffset[i], uSize[i], &pdata, dwFlags[j]);
                        break;

                    case IINDEXBUFFER8:
                        hr = ((LPDIRECT3DINDEXBUFFER8)pvObject)->Lock(uOffset[i], uSize[i], &pdata, dwFlags[j]);
                        break;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::Lock failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (*pdata != byte) {
                    Log(LOG_FAIL, TEXT("Buffer data failed to persist after calling %s::Rect"), ptte->szInterface);
                    tr = TR_FAIL;
                }

                switch (ptte->dwData) {

                    case IVERTEXBUFFER8:
                        hr = ((LPDIRECT3DVERTEXBUFFER8)pvObject)->Unlock();
                        break;

                    case IINDEXBUFFER8:
                        hr = ((LPDIRECT3DINDEXBUFFER8)pvObject)->Unlock();
                        break;
                }

                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("%s::Unlock failed [0x%X]"), ptte->szInterface, hr);
                    LogEndVariation();
                    return TR_FAIL;
                }

                if (i) {

                pdata = NULL;

                    switch (ptte->dwData) {

                        case IVERTEXBUFFER8:
                            hr = ((LPDIRECT3DVERTEXBUFFER8)pvObject)->Lock(0, 0, &pdata, dwFlags[j]);
                            break;

                        case IINDEXBUFFER8:
                            hr = ((LPDIRECT3DINDEXBUFFER8)pvObject)->Lock(0, 0, &pdata, dwFlags[j]);
                            break;
                    }

                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("%s::Lock failed [0x%X]"), ptte->szInterface, hr);
                        LogEndVariation();
                        return TR_FAIL;
                    }

                    if (*(pdata + uOffset[1]) != byte) {
                        Log(LOG_FAIL, TEXT("Buffer pointer inconsistent with the offset given in %s::Lock"), ptte->szInterface);
                        tr = TR_FAIL;
                    }

                    switch (ptte->dwData) {

                        case IVERTEXBUFFER8:
                            hr = ((LPDIRECT3DVERTEXBUFFER8)pvObject)->Unlock();
                            break;

                        case IINDEXBUFFER8:
                            hr = ((LPDIRECT3DINDEXBUFFER8)pvObject)->Unlock();
                            break;
                    }

                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("%s::Unlock failed [0x%X]"), ptte->szInterface, hr);
                        LogEndVariation();
                        return TR_FAIL;
                    }
                }
            }

            LogEndVariation();
        }
    }

    return tr;
}

#ifndef UNDER_XBOX

//******************************************************************************
// WndProc
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     WndProc
//
// Description:
//
//     Window procedure to process messages for the main application window
//
// Arguments:
//
//     HWND hWnd                - Application window
//
//     UINT message             - Message to process
//
//     WPARAM wParam            - First message parameter
//
//     LPARAM lParam            - Second message parameter
//
// Return Value:
//
//     0 if the message was handled, the return of DefWindowProc otherwise.
//
//******************************************************************************
LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    switch (uMsg) {

        case WM_SETCURSOR:

            SetCursor(NULL);
            return TRUE;

        case WM_MOUSEMOVE:

            if (g_pd3dd8) {
                POINT point;
                GetCursorPos(&point);
                ScreenToClient(hWnd, &point);
                g_pd3dd8->SetCursorPosition(point.x, point.y, D3DCURSOR_IMMEDIATE_UPDATE);
            }
            break;

        case WM_CLOSE:
            DestroyWindow(hWnd);
            return 0;

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

#endif // UNDER_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\d3dbvt.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    d3dbvt.h

Description:

    Direct3D Build Verification Tests.

*******************************************************************************/

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#ifndef UNDER_XBOX
#define INVALID_TESTS
#endif

#define countof(x)      (sizeof(x) / sizeof(*(x)))

#define TESTPROCAPI     TRESULT WINAPI

#define TR_SKIP         2
#define TR_PASS         3
#define TR_FAIL         4
#define TR_ABORT        5

#define IDIRECT3D8      1
#define IDEVICE8        2
#define ISWAPCHAIN8     3
#define ITEXTURE8       4
#define ICUBETEXTURE8   5
#define IVOLUMETEXTURE8 6
#define IVERTEXBUFFER8  7
#define IINDEXBUFFER8   8
#define ISURFACE8       9
#define IVOLUME8        10

#define TARGET_WIDTH    640
#define TARGET_HEIGHT   480
#define TEXTUREDIM      128 // Must be a power of 2
#define VERTBUFFSIZE    (2048 * (2 * sizeof(D3DVECTOR) + 2 * sizeof(float)))
#define VERTBUFFFORMAT  (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)
#define INDXBUFFSIZE    (2048 * sizeof(WORD))

#define DEAD_PTR        ((LPVOID)0xdeadbeef)
#define PRESET          0xFFFFFFFE

//******************************************************************************
// Data types
//******************************************************************************

typedef struct _TESTTABLEENTRY *PTESTTABLEENTRY;

typedef DWORD TRESULT;

typedef TRESULT (WINAPI *TESTPROC)(PTESTTABLEENTRY ptte);

typedef struct _TESTTABLEENTRY {
    LPCTSTR     szInterface;
    LPCTSTR     szMethod;
    DWORD       dwData;
    TESTPROC    pfnTest;
} TESTTABLEENTRY, *PTESTTABLEENTRY;

typedef DWORD D3DIFACETYPE;

extern HINSTANCE    g_hInstance;
extern HWND         g_hWnd;
extern GUID         GUID_PRIVATEDATA;

//******************************************************************************
// Test function prototypes
//******************************************************************************

// ##REMOVE: Temporary video test
TESTPROCAPI TTMP_VideoTest(PTESTTABLEENTRY ptte);
// ##REMOVE END

// IUnknown
TESTPROCAPI TUNK_AddRef(PTESTTABLEENTRY ptte);
TESTPROCAPI TUNK_Release(PTESTTABLEENTRY ptte);
TESTPROCAPI TUNK_QueryInterface(PTESTTABLEENTRY ptte);

// IDirect3D8
TESTPROCAPI TD3D8_GetAdapterCount(PTESTTABLEENTRY ptte);
TESTPROCAPI TD3D8_GetAdapterDisplayMode(PTESTTABLEENTRY ptte);
TESTPROCAPI TD3D8_GetAdapterIdentifier(PTESTTABLEENTRY ptte);
TESTPROCAPI TD3D8_GetAdapterModeCount(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TD3D8_GetAdapterMonitor(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX
TESTPROCAPI TD3D8_GetDeviceCaps(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TD3D8_RegisterSoftwareDevice(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX
TESTPROCAPI TD3D8_CheckDeviceFormat(PTESTTABLEENTRY ptte);
TESTPROCAPI TD3D8_CheckDeviceMultiSampleType(PTESTTABLEENTRY ptte);
TESTPROCAPI TD3D8_CheckDeviceType(PTESTTABLEENTRY ptte);
TESTPROCAPI TD3D8_CheckDepthStencilMatch(PTESTTABLEENTRY ptte);
TESTPROCAPI TD3D8_CreateDevice(PTESTTABLEENTRY ptte);
TESTPROCAPI TD3D8_EnumAdapterModes(PTESTTABLEENTRY ptte);

// IDirect3DDevice8
#ifndef UNDER_XBOX
TESTPROCAPI TDEV8_CreateAdditionalSwapChain(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX
TESTPROCAPI TDEV8_CreateCubeTexture(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CreateDepthStencilSurface(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CreateImageSurface(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CreateIndexBuffer(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CreateRenderTarget(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CreateTexture(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CreateVertexBuffer(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CreateVolumeTexture(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_ApplyStateBlock(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_BeginStateBlock(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_EndStateBlock(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CreateStateBlock(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_DeleteStateBlock(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CaptureStateBlock(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TDEV8_GetClipStatus(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetClipStatus(PTESTTABLEENTRY ptte);
#endif
TESTPROCAPI TDEV8_GetRenderState(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetRenderState(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetRenderTarget(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetRenderTarget(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetTransform(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetTransform(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_MultiplyTransform(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_Clear(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetViewport(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetViewport(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TDEV8_GetClipPlane(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetClipPlane(PTESTTABLEENTRY ptte);
#endif
TESTPROCAPI TDEV8_GetLight(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetLight(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_LightEnable(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetLightEnable(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetMaterial(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetMaterial(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetTexture(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetTexture(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetTextureStageState(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetTextureStageState(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TDEV8_UpdateTexture(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_ValidateDevice(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetCurrentTexturePalette(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetCurrentTexturePalette(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetPaletteEntries(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetPaletteEntries(PTESTTABLEENTRY ptte);
#else

#endif
TESTPROCAPI TDEV8_CreateVertexShader(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_DeleteVertexShader(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetVertexShader(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetVertexShader(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetVertexShaderConstant(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetVertexShaderConstant(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetVertexShaderDeclaration(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetVertexShaderFunction(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CreatePixelShader(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_DeletePixelShader(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetPixelShader(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetPixelShader(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetPixelShaderConstant(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetPixelShaderConstant(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetPixelShaderFunction(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_Present(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_Reset(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_BeginScene(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_EndScene(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_DrawIndexedPrimitive(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_DrawIndexedPrimitiveUP(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_DrawPrimitive(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_DrawPrimitiveUP(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_DeleteSurfaceHandle(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_DrawRectSurface(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_DrawTriSurface(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetStreamSource(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetStreamSource(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetIndices(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetIndices(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TDEV8_GetAvailableTextureMem(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX
TESTPROCAPI TDEV8_GetCreationParameters(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetDeviceCaps(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetDirect3D(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TDEV8_GetInfo(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX
TESTPROCAPI TDEV8_GetRasterStatus(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetBackBuffer(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetDepthStencilSurface(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetGammaRamp(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetGammaRamp(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_CopyRects(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_GetFrontBufferRectangle(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_ProcessVertices(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_ResourceManagerDiscardBytes(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_TestCooperativeLevel(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetCursorPosition(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_SetCursorProperties(PTESTTABLEENTRY ptte);
TESTPROCAPI TDEV8_ShowCursor(PTESTTABLEENTRY ptte);

// IDirect3DSwapChain8
#ifndef UNDER_XBOX
TESTPROCAPI TSWC8_Present(PTESTTABLEENTRY ptte);
TESTPROCAPI TSWC8_GetBackBuffer(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX

// IDirect3DResource8
TESTPROCAPI TRES8_GetType(PTESTTABLEENTRY ptte);
TESTPROCAPI TRES8_GetDevice(PTESTTABLEENTRY ptte);
TESTPROCAPI TRES8_GetPrivateData(PTESTTABLEENTRY ptte);
TESTPROCAPI TRES8_SetPrivateData(PTESTTABLEENTRY ptte);
TESTPROCAPI TRES8_FreePrivateData(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TRES8_GetPriority(PTESTTABLEENTRY ptte);
TESTPROCAPI TRES8_SetPriority(PTESTTABLEENTRY ptte);
TESTPROCAPI TRES8_PreLoad(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX

// IDirect3DBaseTexture8
TESTPROCAPI TBTX8_GetLevelCount(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TBTX8_GetLOD(PTESTTABLEENTRY ptte);
TESTPROCAPI TBTX8_SetLOD(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX

// IDirect3DTexture8
TESTPROCAPI TTEX8_GetLevelDesc(PTESTTABLEENTRY ptte);
TESTPROCAPI TTEX8_LockRect(PTESTTABLEENTRY ptte);
TESTPROCAPI TTEX8_UnlockRect(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TTEX8_AddDirtyRect(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX
TESTPROCAPI TTEX8_GetSurfaceLevel(PTESTTABLEENTRY ptte);

// IDirect3DCubeTexture8
TESTPROCAPI TCTX8_GetLevelDesc(PTESTTABLEENTRY ptte);
TESTPROCAPI TCTX8_LockRect(PTESTTABLEENTRY ptte);
TESTPROCAPI TCTX8_UnlockRect(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TCTX8_AddDirtyRect(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX
TESTPROCAPI TCTX8_GetCubeMapSurface(PTESTTABLEENTRY ptte);

// IDirect3DVolumeTexture8
TESTPROCAPI TVTX8_GetLevelDesc(PTESTTABLEENTRY ptte);
TESTPROCAPI TVTX8_LockBox(PTESTTABLEENTRY ptte);
TESTPROCAPI TVTX8_UnlockBox(PTESTTABLEENTRY ptte);
#ifndef UNDER_XBOX
TESTPROCAPI TVTX8_AddDirtyBox(PTESTTABLEENTRY ptte);
#endif // !UNDER_XBOX
TESTPROCAPI TVTX8_GetVolumeLevel(PTESTTABLEENTRY ptte);

// IDirect3DVertexBuffer8
TESTPROCAPI TVRB8_GetDesc(PTESTTABLEENTRY ptte);
TESTPROCAPI TVRB8_Lock(PTESTTABLEENTRY ptte);
TESTPROCAPI TVRB8_Unlock(PTESTTABLEENTRY ptte);

// IDirect3DIndexBuffer8
TESTPROCAPI TIXB8_GetDesc(PTESTTABLEENTRY ptte);
TESTPROCAPI TIXB8_Lock(PTESTTABLEENTRY ptte);
TESTPROCAPI TIXB8_Unlock(PTESTTABLEENTRY ptte);

// IDirect3DSurface8
TESTPROCAPI TSUR8_GetContainer(PTESTTABLEENTRY ptte);
TESTPROCAPI TSUR8_GetDevice(PTESTTABLEENTRY ptte);
TESTPROCAPI TSUR8_GetDesc(PTESTTABLEENTRY ptte);
TESTPROCAPI TSUR8_LockRect(PTESTTABLEENTRY ptte);
TESTPROCAPI TSUR8_UnlockRect(PTESTTABLEENTRY ptte);
TESTPROCAPI TSUR8_GetPrivateData(PTESTTABLEENTRY ptte);
TESTPROCAPI TSUR8_SetPrivateData(PTESTTABLEENTRY ptte);
TESTPROCAPI TSUR8_FreePrivateData(PTESTTABLEENTRY ptte);

// IDirect3DVolume8
TESTPROCAPI TVOL8_GetContainer(PTESTTABLEENTRY ptte);
TESTPROCAPI TVOL8_GetDevice(PTESTTABLEENTRY ptte);
TESTPROCAPI TVOL8_GetDesc(PTESTTABLEENTRY ptte);
TESTPROCAPI TVOL8_LockBox(PTESTTABLEENTRY ptte);
TESTPROCAPI TVOL8_UnlockBox(PTESTTABLEENTRY ptte);
TESTPROCAPI TVOL8_GetPrivateData(PTESTTABLEENTRY ptte);
TESTPROCAPI TVOL8_SetPrivateData(PTESTTABLEENTRY ptte);
TESTPROCAPI TVOL8_FreePrivateData(PTESTTABLEENTRY ptte);

// Shared
TESTPROCAPI TSHR8_GetDevice(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_LockRect(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_UnlockRect(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_LockBox(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_UnlockBox(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_GetPrivateData(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_SetPrivateData(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_FreePrivateData(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_GetLevelDesc(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_GetSurfaceLevel(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_AddDirtyRect(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_Lock(PTESTTABLEENTRY ptte, LPVOID pvObject);
TESTPROCAPI TSHR8_Unlock(PTESTTABLEENTRY ptte, LPVOID pvObject);

//******************************************************************************
// Function prototypes
//******************************************************************************

LPDIRECT3D8                 GetDirect3D8();
LPDIRECT3D8                 GetDeviceDirect3D8();
void                        ReleaseDirect3D8();
LPDIRECT3DDEVICE8           GetDevice8();
void                        ReleaseDevice8();
#ifndef UNDER_XBOX
LPDIRECT3DSWAPCHAIN8        GetSwapChain8();
#endif // !UNDER_XBOX
LPDIRECT3DTEXTURE8          GetTexture8();
LPDIRECT3DCUBETEXTURE8      GetCubeTexture8();
LPDIRECT3DVOLUMETEXTURE8    GetVolumeTexture8();
LPDIRECT3DVERTEXBUFFER8     GetVertexBuffer8();
LPDIRECT3DINDEXBUFFER8      GetIndexBuffer8();
LPDIRECT3DSURFACE8          GetSurface8(LPDIRECT3DTEXTURE8* ppd3dt = NULL);
LPDIRECT3DSURFACE8          GetCubeSurface8(LPDIRECT3DCUBETEXTURE8* ppd3dtc = NULL);
LPDIRECT3DVOLUME8           GetVolume8(LPDIRECT3DVOLUMETEXTURE8* ppd3dv = NULL);
void                        ReleaseDeviceObjects8();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\device8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    dev8.cpp

Description:

    IDirect3DDevice8 interface BVTs.

*******************************************************************************/

#define D3DCOMPILE_BEGINSTATEBLOCK 1

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include <xgraphics.h>
#include "d3dbvt.h"
#include "log.h"
#include "util.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define FLT_RND     ((-1.0f + 2.0f * RND()) * FLT_MAX)
// #define FLT_MAX 3.402823466e+38F

//******************************************************************************
// Globals
//******************************************************************************

char g_szVertexShader[] = {

    ";\n"
    "; Vertex input registers:\n"
    ";\n"
    "; v0            Vertex position\n"
    "; v3            Vertex normal\n"
    "; v7            Vertex texture coordinates\n"
    ";\n"
    "; Constant registers:\n"
    ";\n"
    "; c0 - c3       Transposed concatenation of world, view, and projection matrices\n"
    ";\n"
    "; c4            Normalized light direction\n"
    "; c5            View position\n"
    "; c6.x          Material power\n"
    "; c6.y          0.0f\n"
    "; c6.z          1.0f\n"
    "; c7            Diffuse base color (diffuse light color modulated with diffuse material color)\n"
    "; c8            Diffuse offset color (ambient room color modulated with ambient material color +\n"
    ";                                     ambient light color modulated with ambient material color +\n"
    ";                                     emissive material color)\n"
    "; c9            Specular base color (specular light color modulated with specular material color)\n"
    ";\n"

    "vs.1.0								; Vertex shader version 1.0\n"

    "; Transform the vertex\n"

    "dp4 oPos.x, v0, c0\n"
    "dp4 oPos.y, v0, c1\n"
    "dp4 oPos.z, v0, c2\n"
    "dp4 oPos.w, v0, c3\n"

    "; Light the vertex with a directional light\n"

    "dp3 r2.x, v3, -c4                   ; Diffuse intensity = dotproduct(vertex normal, light direction)\n"

    "add r0, v0, -c5                     ; Calculate a vector from the eye to the vertex\n"
    "dp3 r1.w, r0, r0                    ; nm3 r0, r0\n"
    "rsq r1.w, r1.w\n"
    "mul r1.xyz, r0, r1.w\n"
    "add r0, r1, c4                      ; Calculate the half-vector\n"
    "dp3 r1.w, r0, r0                    ; nm3 r0, r0\n"
    "rsq r1.w, r1.w\n"
    "mul r1.xyz, r0, r1.w\n"
    "dp3 r2.y, v3, -r1                   ; Specular intensity = dotproduct(vertex normal, light/eye half-vector)\n"

    "mov r2.w, c6.x                      ; Material power\n"

    "lit r3, r2                          ; Light coefficients\n"

    ";mad r0.xyz, r3.y, c7.xyz, c8.xyz    ; Diffuse color = diffuse intensity * diffuse base color + diffuse offset color\n"
    "mul r0.xyz, r3.y, c7.xyz\n"
    "add r0.xyz, r0.xyz, c8.xyz\n"

    "mov r0.w, c7.w                      ; Diffuse alpha = diffuse base alpha\n"
    "min oD0, r0, r3.w                   ; Clamp diffuse colors to 1.0f\n"

    "mul r0.xyz, r3.z, c9.xyz            ; Specular color = specular intensity * specular base color\n"
    "mov r0.w, c9.w                      ; Specular alpha = specular base alpha\n"
    "min oD1, r0, r3.w                   ; Clamp specular colors to 1.0f\n"

    "mov oT0, v7                         ; Propagate texture coordinates\n"
};

char g_szPixelShader[] = {

    ";\n"
    "; Color input registers:\n"
    ";\n"
    "; v0            Diffuse color\n"
    "; v1            Specular color\n"
    ";\n"

    "ps.1.0              ; Pixel shader version 1.0\n"
    "tex t0              ; Sample the texture set in stage 0\n"
    "mul r1, t0, v0      ; Modulate the pixel's diffuse color with the texel color\n"
    "add r0.xyz, r1, v1  ; Add the pixel's specular color\n"
    "mov r0.a, r1.a      ; Use the modulated diffuse/texel alpha for the pixel\n"
};

//******************************************************************************
BOOL IsCompressedFormat(D3DFORMAT fmt) {

    switch (fmt) {
        case D3DFMT_DXT1:
        case D3DFMT_DXT2:
#ifndef UNDER_XBOX
        case D3DFMT_DXT3:
#endif
        case D3DFMT_DXT4:
#ifndef UNDER_XBOX
        case D3DFMT_DXT5:
#endif
            return TRUE;
        default:
            return FALSE;
    }
}

//******************************************************************************
// IDirect3DDevice8 inteface tests
//******************************************************************************

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_CreateAdditionalSwapChain(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DSWAPCHAIN8    pd3dsw;
    D3DPRESENT_PARAMETERS   d3dpp;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // Initialize the presentation parameters
    memset(&d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth                   = 640;
    d3dpp.BackBufferHeight                  = 480;
    d3dpp.BackBufferFormat                  = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                   = D3DMULTISAMPLE_NONE;
    d3dpp.AutoDepthStencilFormat            = D3DFMT_D24S8;
    d3dpp.FullScreen_RefreshRateInHz        = 0;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                     = g_hWnd;
    d3dpp.Windowed                          = FALSE;
    d3dpp.EnableAutoDepthStencil            = FALSE;

    pd3dsw = (LPDIRECT3DSWAPCHAIN8)DEAD_PTR;

    hr = pd3dd->CreateAdditionalSwapChain(&d3dpp, &pd3dsw);
    if (hr != E_NOTIMPL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateAdditionalSwapChain returned 0x%X instead of E_NOTIMPL"), hr);
        tr = TR_FAIL;
        if (SUCCEEDED(hr)) {
            pd3dsw->Release();
        }
    }
    else {
        if (pd3dsw != NULL) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateAdditionalSwapChain failed to set the swap chain pointer to NULL on failure"));
            tr = TR_FAIL;
        }
    }

    return tr;
}

#endif // !UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_CreateCubeTexture(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DCUBETEXTURE8  pd3dtc;
    UINT                    i, j, k, uNumFormats;
    D3DFORMAT*              pfmt;
    D3DLOCKED_RECT          d3dlr;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    DWORD                   dwUsage[] = {
                                0,
                                D3DUSAGE_RENDERTARGET,
#ifndef UNDER_XBOX
                                D3DUSAGE_DEPTHSTENCIL,
#endif // !UNDER_XBOX
                            };
    UINT                    uLevels[] = {
                                0,
                                1,
                                2,
                                9,
                                10
                            };
    D3DFORMAT               fmt[] = {
                                D3DFMT_A8R8G8B8,
                                D3DFMT_X8R8G8B8,
                                D3DFMT_R5G6B5,
                                D3DFMT_X1R5G5B5,
                                D3DFMT_A1R5G5B5,
                                D3DFMT_A4R4G4B4,
                                D3DFMT_A8,
                                D3DFMT_P8,
                                D3DFMT_L8,
                                D3DFMT_A8L8,
                                D3DFMT_V8U8,
                                D3DFMT_L6V5U5,
                                D3DFMT_X8L8V8U8,
                                D3DFMT_Q8W8V8U8,
                                D3DFMT_V16U16,
#ifndef UNDER_XBOX
                                D3DFMT_UYVY,
                                D3DFMT_YUY2,
#endif
                                D3DFMT_DXT1,
                                D3DFMT_DXT2,
                                D3DFMT_DXT3,
                                D3DFMT_DXT4,
                                D3DFMT_DXT5,
#ifdef UNDER_XBOX
                                D3DFMT_A8B8G8R8,
                                D3DFMT_B8G8R8A8,
                                D3DFMT_R4G4B4A4,
                                D3DFMT_R5G5B5A1,
                                D3DFMT_R8G8B8A8,
                                D3DFMT_R8B8,
                                D3DFMT_G8B8,
                                D3DFMT_AL8,
                                D3DFMT_L16,
#if 0
                                D3DFMT_LIN_A1R5G5B5,
                                D3DFMT_LIN_A4R4G4B4,
                                D3DFMT_LIN_A8,
                                D3DFMT_LIN_A8B8G8R8,
                                D3DFMT_LIN_A8R8G8B8,
                                D3DFMT_LIN_B8G8R8A8,
                                D3DFMT_LIN_G8B8,
                                D3DFMT_LIN_R4G4B4A4,
                                D3DFMT_LIN_R5G5B5A1,
                                D3DFMT_LIN_R5G6B5,
                                D3DFMT_LIN_R6G5B5,
                                D3DFMT_LIN_R8B8,
                                D3DFMT_LIN_R8G8B8A8,
                                D3DFMT_LIN_X1R5G5B5,
                                D3DFMT_LIN_X8R8G8B8,
                                D3DFMT_LIN_A8L8,
                                D3DFMT_LIN_AL8,
                                D3DFMT_LIN_L16,
                                D3DFMT_LIN_L8,
#endif
#endif // UNDER_XBOX
                            };

    D3DFORMAT               fmtr[] = {
                                D3DFMT_X1R5G5B5,
                                D3DFMT_R5G6B5,
                                D3DFMT_X8R8G8B8,
                                D3DFMT_A8R8G8B8,
#if 0 // UNDER_XBOX
                                D3DFMT_LIN_X1R5G5B5,
                                D3DFMT_LIN_R5G6B5,
                                D3DFMT_LIN_X8R8G8B8,
                                D3DFMT_LIN_A8R8G8B8,
#endif // UNDER_XBOX
                            };

#ifndef UNDER_XBOX
    D3DFORMAT               fmtd[] = {
                                D3DFMT_D16_LOCKABLE,
                                D3DFMT_D16,
                                D3DFMT_D24S8,
#ifdef UNDER_XBOX
                                D3DFMT_F16,
                                D3DFMT_F24S8,
#if 0
                                D3DFMT_LIN_D24S8,
                                D3DFMT_LIN_F24S8,
                                D3DFMT_LIN_D16,
                                D3DFMT_LIN_F16,
#endif
#endif // UNDER_XBOX
                            };
#endif // !UNDER_XBOX

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 0; i < countof(dwUsage); i++) {

        LogBeginVariation(TEXT("IDirect3DDevice8::CreateCubeTexture with a usage of %d"), dwUsage[i]);

#ifndef UNDER_XBOX
        if (i == 2) {
            pfmt = fmtd;
            uNumFormats = countof(fmtd);
        }
        else if (i == 1) {
#else
        if (i == 1) {
#endif // UNDER_XBOX
            pfmt = fmtr;
            uNumFormats = countof(fmtr);
        }
        else {
            pfmt = fmt;
            uNumFormats = countof(fmt);
        }

        for (j = 0; j < uNumFormats; j++) {

            LogBeginVariation(TEXT("Cube textures with a format of %d"), pfmt[j]);

            for (k = 0; k < countof(uLevels); k++) {

                hr = pd3dd->CreateCubeTexture(512, uLevels[k], dwUsage[i], pfmt[j], D3DPOOL_MANAGED, &pd3dtc);
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateCubeTexture failed given %d levels [0x%X]"), uLevels[k], hr);
                    tr = TR_FAIL;
                }
                else {
                    // Verify the texture
                    hr = pd3dtc->LockRect(D3DCUBEMAP_FACE_NEGATIVE_Z, 0, &d3dlr, NULL, 0);
                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("IDirect3DCubeTexture8::LockRect failed on created texture [0x%X]"), hr);
                        tr = TR_FAIL;
                    }
                    else {
                        *((LPBYTE)d3dlr.pBits) = 0x3C;
                        pd3dtc->UnlockRect(D3DCUBEMAP_FACE_NEGATIVE_Z, 0);
                    }
                    pd3dtc->Release();
                }
            }

            LogEndVariation();
        }

        LogEndVariation();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CreateDepthStencilSurface(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DSURFACE8      pd3ds;
    UINT                    i, j, k, l;
    D3DLOCKED_RECT          d3dlr;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    UINT                    uWidth[] = {
                                640,
                                512,
                                213,
                            };
    UINT                    uHeight[] = {
                                480,
                                512,
                                7
                            };
    D3DFORMAT               fmtd[] = {
                                D3DFMT_D16_LOCKABLE,
                                D3DFMT_D16,
                                D3DFMT_D24S8,
#ifdef UNDER_XBOX
                                D3DFMT_F16,
                                D3DFMT_F24S8,
                                D3DFMT_LIN_D24S8,
                                D3DFMT_LIN_F24S8,
                                D3DFMT_LIN_D16,
                                D3DFMT_LIN_F16,
#endif // UNDER_XBOX
                            };
    D3DMULTISAMPLE_TYPE     mst[] = {
                                D3DMULTISAMPLE_NONE,
#ifndef UNDER_XBOX
                                D3DMULTISAMPLE_2_SAMPLES,
                                D3DMULTISAMPLE_4_SAMPLES,
#endif
                            };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (j = 0; j < countof(fmtd); j++) {

        LogBeginVariation(TEXT("Depth/stencil buffers with a format of %d"), fmtd[j]);

        for (k = 0; k < countof(mst); k++) {

            LogBeginVariation(TEXT("Depth/stencil buffers with a multisample type of %d samples"), k * 2);

            for (l = 0; l < countof(uWidth); l++) {

#ifdef UNDER_XBOX
                if (!XGIsSwizzledFormat(fmtd[j])) {
#endif // UNDER_XBOX
                    hr = pd3dd->CreateDepthStencilSurface(uWidth[l], uHeight[l], fmtd[j], mst[k], &pd3ds);
#ifdef UNDER_XBOX
                }
                else {
                    hr = pd3dd->CreateDepthStencilSurface(uWidth[1], uHeight[1], fmtd[j], mst[k], &pd3ds);
                }
#endif // UNDER_XBOX
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateDepthStencilSurface failed for a %d x %d surface [0x%X]"), uWidth[l], uHeight[l], hr);
                    tr = TR_FAIL;
                }
                else {
                    // Verify the surface
                    hr = pd3ds->LockRect(&d3dlr, NULL, 0);
                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("IDirect3DSurface8::LockRect failed on created %d x %d surface [0x%X]"), uWidth[l], uHeight[l], hr);
                        tr = TR_FAIL;
                    }
                    else {
                        *((LPBYTE)d3dlr.pBits) = 0x3C;
                        pd3ds->UnlockRect();
                    }
                    pd3ds->Release();
                }
            }

            LogEndVariation();
        }

        LogEndVariation();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CreateImageSurface(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DSURFACE8      pd3ds;
    UINT                    i, j;
    D3DLOCKED_RECT          d3dlr;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    UINT                    uWidth[] = {
                                640,
                                512,
                                212,
                            };
    UINT                    uHeight[] = {
                                480,
                                512,
                                8
                            };
    D3DFORMAT               fmt[] = {
                                D3DFMT_A8R8G8B8,
                                D3DFMT_X8R8G8B8,
                                D3DFMT_R5G6B5,
                                D3DFMT_X1R5G5B5,
                                D3DFMT_A1R5G5B5,
                                D3DFMT_A4R4G4B4,
                                D3DFMT_A8,
                                D3DFMT_P8,
                                D3DFMT_L8,
                                D3DFMT_A8L8,
                                D3DFMT_V8U8,
                                D3DFMT_L6V5U5,
                                D3DFMT_X8L8V8U8,
                                D3DFMT_Q8W8V8U8,
                                D3DFMT_V16U16,
                                D3DFMT_UYVY,
                                D3DFMT_YUY2,
                                D3DFMT_DXT1,
                                D3DFMT_DXT2,
                                D3DFMT_DXT3,
                                D3DFMT_DXT4,
                                D3DFMT_DXT5,
#ifdef UNDER_XBOX
                                D3DFMT_A8B8G8R8,
                                D3DFMT_B8G8R8A8,
                                D3DFMT_R4G4B4A4,
                                D3DFMT_R5G5B5A1,
                                D3DFMT_R8G8B8A8,
                                D3DFMT_R8B8,
                                D3DFMT_G8B8,
                                D3DFMT_AL8,
                                D3DFMT_L16,
                                D3DFMT_LIN_A1R5G5B5,
                                D3DFMT_LIN_A4R4G4B4,
                                D3DFMT_LIN_A8,
                                D3DFMT_LIN_A8B8G8R8,
                                D3DFMT_LIN_A8R8G8B8,
                                D3DFMT_LIN_B8G8R8A8,
                                D3DFMT_LIN_G8B8,
                                D3DFMT_LIN_R4G4B4A4,
                                D3DFMT_LIN_R5G5B5A1,
                                D3DFMT_LIN_R5G6B5,
                                D3DFMT_LIN_R6G5B5,
                                D3DFMT_LIN_R8B8,
                                D3DFMT_LIN_R8G8B8A8,
                                D3DFMT_LIN_X1R5G5B5,
                                D3DFMT_LIN_X8R8G8B8,
                                D3DFMT_LIN_A8L8,
                                D3DFMT_LIN_AL8,
                                D3DFMT_LIN_L16,
                                D3DFMT_LIN_L8,
#endif // UNDER_XBOX
                            };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 0; i < countof(fmt); i++) {

        LogBeginVariation(TEXT("Image surfaces with a format of %d"), fmt[i]);

        for (j = 0; j < countof(uWidth); j++) {

#ifdef UNDER_XBOX
                if (!(XGIsSwizzledFormat(fmt[i]) || IsCompressedFormat(fmt[i]))) {
#endif // UNDER_XBOX
                    hr = pd3dd->CreateImageSurface(uWidth[j], uHeight[j], fmt[i], &pd3ds);
#ifdef UNDER_XBOX
                }
                else {
                    hr = pd3dd->CreateImageSurface(uWidth[1], uHeight[1], fmt[i], &pd3ds);
                }
#endif // UNDER_XBOX
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateImageSurface failed for a %d x %d surface [0x%X]"), uWidth[j], uHeight[j], hr);
                tr = TR_FAIL;
            }
            else {
                // Verify the surface
                hr = pd3ds->LockRect(&d3dlr, NULL, 0);
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("IDirect3DSurface8::LockRect failed on created %d x %d surface [0x%X]"), uWidth[j], uHeight[j], hr);
                    tr = TR_FAIL;
                }
                else {
                    *((LPBYTE)d3dlr.pBits) = 0x3C;
                    pd3ds->UnlockRect();
                }
                pd3ds->Release();
            }
        }

        LogEndVariation();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CreateIndexBuffer(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DINDEXBUFFER8  pd3di;
    LPBYTE                  pdata;
    UINT                    i, j;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    D3DFORMAT               fmt[] = {
                                D3DFMT_INDEX16,
#ifndef UNDER_XBOX
                                D3DFMT_INDEX32,
#endif // !UNDER_XBOX
                            };
    DWORD                   dwUsage[] = {
                                0,
                                D3DUSAGE_POINTS,
                                D3DUSAGE_RTPATCHES,
                                D3DUSAGE_WRITEONLY,
                                D3DUSAGE_POINTS | D3DUSAGE_WRITEONLY,
                                D3DUSAGE_RTPATCHES |D3DUSAGE_WRITEONLY,
                            };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 0; i < countof(dwUsage); i++) {

        LogBeginVariation(TEXT("IDirect3DDevice8::CreateIndexBuffer with a usage of %d"), dwUsage[i]);

        for (j = 0; j < countof(fmt); j++) {

            hr = pd3dd->CreateIndexBuffer(11561, dwUsage[i], fmt[j], D3DPOOL_MANAGED, &pd3di);
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateIndexBuffer failed for a buffer with %d bit indices [0x%X]"), j ? 32 : 16, hr);
                tr = TR_FAIL;
            }
            else {
                // Verify the buffer
                hr = pd3di->Lock(13, 511, &pdata, 0);
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("IDirect3DIndexBuffer8::Lock failed on a buffer with %d bit indices [0x%X]"), j ? 32 : 16, hr);
                    tr = TR_FAIL;
                }
                else {
                    *pdata = 0x3C;
                    pd3di->Unlock();
                }
                pd3di->Release();
            }
        }

        LogEndVariation();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CreateRenderTarget(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DSURFACE8      pd3ds;
    UINT                    i, j, k, l;
    D3DLOCKED_RECT          d3dlr;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    DWORD                   dwLockable[] = {
                                TRUE,
                                FALSE,
                            };
    UINT                    uWidth[] = {
                                640,
                                512,
                                211,
                            };
    UINT                    uHeight[] = {
                                480,
                                512,
                                7
                            };
    D3DFORMAT               fmtr[] = {
                                D3DFMT_X1R5G5B5,
                                D3DFMT_R5G6B5,
                                D3DFMT_X8R8G8B8,
                                D3DFMT_A8R8G8B8,
#ifdef UNDER_XBOX
                                D3DFMT_LIN_X1R5G5B5,
                                D3DFMT_LIN_R5G6B5,
                                D3DFMT_LIN_X8R8G8B8,
                                D3DFMT_LIN_A8R8G8B8,
#endif
                            };
    D3DMULTISAMPLE_TYPE     mst[] = {
                                D3DMULTISAMPLE_NONE,
#ifndef UNDER_XBOX
                                D3DMULTISAMPLE_2_SAMPLES,
                                D3DMULTISAMPLE_4_SAMPLES,
#endif
                            };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 0; i < countof(dwLockable); i++) {

        LogBeginVariation(TEXT("IDirect3DDevice8::CreateRenderTarget for a %slocable target"), dwLockable[i] ? TEXT("") : TEXT("non-"));

        for (j = 0; j < countof(fmtr); j++) {

            LogBeginVariation(TEXT("Render targets with a format of %d"), fmtr[j]);

            for (k = 0; k < countof(mst); k++) {

                LogBeginVariation(TEXT("Render targets with a multisample type of %d samples"), k * 2);

                for (l = 0; l < countof(uWidth); l++) {

#ifdef UNDER_XBOX
                    if (!XGIsSwizzledFormat(fmtr[j])) {
#endif // UNDER_XBOX
                        hr = pd3dd->CreateRenderTarget(uWidth[l], uHeight[l], fmtr[j], mst[k], dwLockable[i], &pd3ds);
#ifdef UNDER_XBOX
                    }
                    else {
                        hr = pd3dd->CreateRenderTarget(uWidth[1], uHeight[1], fmtr[j], mst[k], dwLockable[i], &pd3ds);
                    }
#endif // UNDER_XBOX
                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateRenderTarget failed for a %d x %d surface [0x%X]"), uWidth[l], uHeight[l], hr);
                        tr = TR_FAIL;
                    }
                    else {
                        // Verify the surface
                        hr = pd3ds->LockRect(&d3dlr, NULL, 0);
                        if (FAILED(hr)) {
                            Log(LOG_FAIL, TEXT("IDirect3DSurface8::LockRect failed on created %d x %d surface [0x%X]"), uWidth[l], uHeight[l], hr);
                            tr = TR_FAIL;
                        }
                        else {
                            *((LPBYTE)d3dlr.pBits) = 0x3C;
                            pd3ds->UnlockRect();
                        }
                        pd3ds->Release();
                    }
                }

                LogEndVariation();
            }

            LogEndVariation();
        }

        LogEndVariation();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CreateTexture(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DTEXTURE8      pd3dt;
    UINT                    i, j, k, l, uNumFormats;
    D3DFORMAT*              pfmt;
    D3DLOCKED_RECT          d3dlr;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    DWORD                   dwUsage[] = {
                                0,
                                D3DUSAGE_RENDERTARGET,
                                D3DUSAGE_DEPTHSTENCIL,
                            };
    UINT                    uLevels[] = {
                                0,
                                1,
                                2,
                            };
    UINT                    uWidth[] = {
                                512,
                                128,
                                212,
                            };
    UINT                    uHeight[] = {
                                512,
                                256,
                                8,
                            };
    D3DFORMAT               fmt[] = {
                                D3DFMT_A8R8G8B8,
                                D3DFMT_X8R8G8B8,
                                D3DFMT_R5G6B5,
                                D3DFMT_X1R5G5B5,
                                D3DFMT_A1R5G5B5,
                                D3DFMT_A4R4G4B4,
                                D3DFMT_A8,
                                D3DFMT_P8,
                                D3DFMT_L8,
                                D3DFMT_A8L8,
                                D3DFMT_V8U8,
                                D3DFMT_L6V5U5,
                                D3DFMT_X8L8V8U8,
                                D3DFMT_Q8W8V8U8,
                                D3DFMT_V16U16,
                                D3DFMT_UYVY,
                                D3DFMT_YUY2,
                                D3DFMT_DXT1,
                                D3DFMT_DXT2,
                                D3DFMT_DXT3,
                                D3DFMT_DXT4,
                                D3DFMT_DXT5,
#ifdef UNDER_XBOX
                                D3DFMT_A8B8G8R8,
                                D3DFMT_B8G8R8A8,
                                D3DFMT_R4G4B4A4,
                                D3DFMT_R5G5B5A1,
                                D3DFMT_R8G8B8A8,
                                D3DFMT_R8B8,
                                D3DFMT_G8B8,
                                D3DFMT_AL8,
                                D3DFMT_L16,
                                D3DFMT_LIN_A1R5G5B5,
                                D3DFMT_LIN_A4R4G4B4,
                                D3DFMT_LIN_A8,
                                D3DFMT_LIN_A8B8G8R8,
                                D3DFMT_LIN_A8R8G8B8,
                                D3DFMT_LIN_B8G8R8A8,
                                D3DFMT_LIN_G8B8,
                                D3DFMT_LIN_R4G4B4A4,
                                D3DFMT_LIN_R5G5B5A1,
                                D3DFMT_LIN_R5G6B5,
                                D3DFMT_LIN_R6G5B5,
                                D3DFMT_LIN_R8B8,
                                D3DFMT_LIN_R8G8B8A8,
                                D3DFMT_LIN_X1R5G5B5,
                                D3DFMT_LIN_X8R8G8B8,
                                D3DFMT_LIN_A8L8,
                                D3DFMT_LIN_AL8,
                                D3DFMT_LIN_L16,
                                D3DFMT_LIN_L8,
#endif // UNDER_XBOX
                            };

    D3DFORMAT               fmtr[] = {
                                D3DFMT_X1R5G5B5,
                                D3DFMT_R5G6B5,
                                D3DFMT_X8R8G8B8,
                                D3DFMT_A8R8G8B8,
#ifdef UNDER_XBOX
                                D3DFMT_LIN_X1R5G5B5,
                                D3DFMT_LIN_R5G6B5,
                                D3DFMT_LIN_X8R8G8B8,
                                D3DFMT_LIN_A8R8G8B8,
#endif // UNDER_XBOX
                            };

    D3DFORMAT               fmtd[] = {
                                D3DFMT_D16_LOCKABLE,
                                D3DFMT_D16,
                                D3DFMT_D24S8,
#ifdef UNDER_XBOX
                                D3DFMT_F16,
                                D3DFMT_F24S8,
                                D3DFMT_LIN_D24S8,
                                D3DFMT_LIN_F24S8,
                                D3DFMT_LIN_D16,
                                D3DFMT_LIN_F16,
#endif // UNDER_XBOX
                            };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 0; i < countof(dwUsage); i++) {

        LogBeginVariation(TEXT("IDirect3DDevice8::CreateTexture with a usage of %d"), dwUsage[i]);

        if (i == 2) {
            pfmt = fmtd;
            uNumFormats = countof(fmtd);
        }
        else if (i == 1) {
            pfmt = fmtr;
            uNumFormats = countof(fmtr);
        }
        else {
            pfmt = fmt;
            uNumFormats = countof(fmt);
        }

        for (j = 0; j < uNumFormats; j++) {

            LogBeginVariation(TEXT("Textures with a format of %d"), pfmt[j]);

            for (k = 0; k < countof(uLevels); k++) {

                for (l = 0; l < countof(uWidth); l++) {

#ifdef UNDER_XBOX
                    if (!(XGIsSwizzledFormat(pfmt[j]) || IsCompressedFormat(pfmt[j]))) {
#endif // UNDER_XBOX
                        hr = pd3dd->CreateTexture(uWidth[l], uHeight[l], 1, dwUsage[i], pfmt[j], D3DPOOL_MANAGED, &pd3dt);
#ifdef UNDER_XBOX
                    }
                    else {
                        hr = pd3dd->CreateTexture(uWidth[l%2], uHeight[l%2], uLevels[k], dwUsage[i], pfmt[j], D3DPOOL_MANAGED, &pd3dt);
                    }
#endif // UNDER_XBOX
                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateTexture failed given a %d x %d texture with %d levels [0x%X]"), uWidth[l], uHeight[l], uLevels[k], hr);
                        tr = TR_FAIL;
                    }
                    else {
                        // Verify the texture
                        hr = pd3dt->LockRect(0, &d3dlr, NULL, 0);
                        if (FAILED(hr)) {
                            Log(LOG_FAIL, TEXT("IDirect3DTexture8::LockRect failed on created texture [0x%X]"), hr);
                            tr = TR_FAIL;
                        }
                        else {
                            *((LPBYTE)d3dlr.pBits) = 0x3C;
                            pd3dt->UnlockRect(0);
                        }
                        pd3dt->Release();
                    }
                }
            }

            LogEndVariation();
        }

        LogEndVariation();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CreateVertexBuffer(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DVERTEXBUFFER8 pd3dr;
    LPBYTE                  pdata;
    UINT                    i, j;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    DWORD                   dwFVF[] = {
                                0,
                                D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1,
                                D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEXCOORDSIZE3(0),
                                D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX4 | D3DFVF_XYZB3,
                                D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_TEX1,
                                D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_TEX1,
                            };
    DWORD                   dwUsage[] = {
                                0,
                                D3DUSAGE_POINTS,
                                D3DUSAGE_RTPATCHES,
                                D3DUSAGE_WRITEONLY,
                                D3DUSAGE_POINTS | D3DUSAGE_WRITEONLY,
                                D3DUSAGE_RTPATCHES | D3DUSAGE_WRITEONLY,
                            };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 0; i < countof(dwUsage); i++) {

        LogBeginVariation(TEXT("IDirect3DDevice8::CreateVertexBuffer with a usage of %d"), dwUsage[i]);

        for (j = 0; j < countof(dwFVF); j++) {

            hr = pd3dd->CreateVertexBuffer(2147, dwUsage[i], dwFVF[j], D3DPOOL_MANAGED, &pd3dr);
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateVertexBuffer failed for a buffer with an FVF of 0x%X [0x%X]"), dwFVF[j], hr);
                tr = TR_FAIL;
            }
            else {
                // Verify the buffer
                hr = pd3dr->Lock(13, 511, &pdata, 0);
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("IDirect3DVertexBuffer8::Lock failed on 0x%X FVF buffer [0x%X]"), dwFVF[j], hr);
                    tr = TR_FAIL;
                }
                else {
                    *pdata = 0x3C;
                    pd3dr->Unlock();
                }
                pd3dr->Release();
            }
        }

        LogEndVariation();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CreateVolumeTexture(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DVOLUMETEXTURE8 pd3dtv;
    UINT                    i, j, k, l;
    D3DLOCKED_BOX           d3dlb;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    DWORD                   dwUsage[] = {
                                0,
                            };
    UINT                    uLevels[] = {
                                0,
                                1,
                                2,
                            };
    UINT                    uWidth[] = {
                                256,
                                128,
                                1,
                            };
    UINT                    uHeight[] = {
                                64,
                                256,
                                8,
                            };
    UINT                    uDepth[] = {
                                256,
                                64,
                                512,
                            };
    D3DFORMAT               fmt[] = {
                                D3DFMT_A8R8G8B8,
                                D3DFMT_X8R8G8B8,
                                D3DFMT_R5G6B5,
                                D3DFMT_X1R5G5B5,
                                D3DFMT_A1R5G5B5,
                                D3DFMT_A4R4G4B4,
                                D3DFMT_A8,
                                D3DFMT_P8,
                                D3DFMT_L8,
                                D3DFMT_A8L8,
                                D3DFMT_V8U8,
                                D3DFMT_L6V5U5,
                                D3DFMT_X8L8V8U8,
                                D3DFMT_Q8W8V8U8,
                                D3DFMT_V16U16,
#ifndef UNDER_XBOX
                                D3DFMT_UYVY,
                                D3DFMT_YUY2,
#endif
                                D3DFMT_DXT1,
                                D3DFMT_DXT2,
                                D3DFMT_DXT3,
                                D3DFMT_DXT4,
                                D3DFMT_DXT5,
#ifdef UNDER_XBOX
                                D3DFMT_A8B8G8R8,
                                D3DFMT_B8G8R8A8,
                                D3DFMT_R4G4B4A4,
                                D3DFMT_R5G5B5A1,
                                D3DFMT_R8G8B8A8,
                                D3DFMT_R8B8,
                                D3DFMT_G8B8,
                                D3DFMT_AL8,
                                D3DFMT_L16,
#if 0 // Non-swizzled textures cannot be volume textures
                                D3DFMT_LIN_A1R5G5B5,
                                D3DFMT_LIN_A4R4G4B4,
                                D3DFMT_LIN_A8,
                                D3DFMT_LIN_A8B8G8R8,
                                D3DFMT_LIN_A8R8G8B8,
                                D3DFMT_LIN_B8G8R8A8,
                                D3DFMT_LIN_G8B8,
                                D3DFMT_LIN_R4G4B4A4,
                                D3DFMT_LIN_R5G5B5A1,
                                D3DFMT_LIN_R5G6B5,
                                D3DFMT_LIN_R6G5B5,
                                D3DFMT_LIN_R8B8,
                                D3DFMT_LIN_R8G8B8A8,
                                D3DFMT_LIN_X1R5G5B5,
                                D3DFMT_LIN_X8R8G8B8,
                                D3DFMT_LIN_A8L8,
                                D3DFMT_LIN_AL8,
                                D3DFMT_LIN_L16,
                                D3DFMT_LIN_L8,
#endif
#endif // UNDER_XBOX
                            };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 0; i < countof(dwUsage); i++) {

        LogBeginVariation(TEXT("IDirect3DDevice8::CreateVolumeTexture with a usage of %d"), dwUsage[i]);

        for (j = 0; j < countof(fmt); j++) {

            LogBeginVariation(TEXT("Volume textures with a format of %d"), fmt[j]);

            for (k = 0; k < countof(uLevels); k++) {

                for (l = 0; l < countof(uWidth); l++) {

                    hr = pd3dd->CreateVolumeTexture(uWidth[l], uHeight[l], uDepth[l], uLevels[k], dwUsage[i], fmt[j], D3DPOOL_MANAGED, &pd3dtv);
                    if (FAILED(hr)) {
                        Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateVolumeTexture failed given a %d x %d x%d texture with %d levels [0x%X]"), uWidth[l], uHeight[l], uDepth[l], uLevels[k], hr);
                        tr = TR_FAIL;
                    }
                    else {
                        // Verify the texture
                        hr = pd3dtv->LockBox(0, &d3dlb, NULL, 0);
                        if (FAILED(hr)) {
                            Log(LOG_FAIL, TEXT("IDirect3DVolumeTexture8::LockBox failed on created volume texture [0x%X]"), hr);
                            tr = TR_FAIL;
                        }
                        else {
                            *((LPBYTE)d3dlb.pBits) = 0x3C;
                            pd3dtv->UnlockBox(0);
                        }
                        pd3dtv->Release();
                    }
                }
            }

            LogEndVariation();
        }

        LogEndVariation();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_ApplyStateBlock(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwSet, dwGet;
    DWORD               dwToken;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->BeginStateBlock();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::BeginStateBlock"))) {
        return TR_ABORT;
    }

    dwSet = (DWORD)RGBA_MAKE(127, 32, 255, 69);

    hr = pd3dd->SetRenderState(D3DRS_TEXTUREFACTOR, dwSet);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        return TR_ABORT;
    }

    hr = pd3dd->EndStateBlock(&dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::EndStateBlock"))) {
        return TR_ABORT;
    }

    hr = pd3dd->SetRenderState(D3DRS_TEXTUREFACTOR, 0);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        return TR_ABORT;
    }

    hr = pd3dd->ApplyStateBlock(dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::ApplyStateBlock"))) {
        return TR_FAIL;
    }

    hr = pd3dd->GetRenderState(D3DRS_TEXTUREFACTOR, &dwGet);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetRenderState"))) {
        return TR_ABORT;
    }

    if (dwGet != dwSet) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::ApplyStateBlock failed to correctly apply the block"));
        tr = TR_FAIL;
    }

    hr = pd3dd->DeleteStateBlock(dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::DeleteStateBlock"))) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_BeginStateBlock(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwToken;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->BeginStateBlock();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::BeginStateBlock"))) {
        return TR_FAIL;
    }

    hr = pd3dd->SetRenderState(D3DRS_SPECULARENABLE, TRUE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        return TR_ABORT;
    }

#ifdef INVALID_TESTS
    hr = pd3dd->BeginStateBlock();
    if (hr != D3DERR_INVALIDCALL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::BeginStateBlock returned 0x%X when called with recording already in progress"), hr);
        tr = TR_FAIL;
    }
#endif // INVALID_TESTS

    hr = pd3dd->EndStateBlock(&dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::EndStateBlock"))) {
        return TR_ABORT;
    }

    hr = pd3dd->DeleteStateBlock(dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::DeleteStateBlock"))) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_EndStateBlock(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwToken;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

#ifdef INVALID_TESTS
    hr = pd3dd->EndStateBlock(&dwToken);
    if (hr != D3DERR_INVALIDCALL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::EndStateBlock returned 0x%X when called without a prior call to BeginStateBlock"), hr);
        tr = TR_FAIL;
    }
#endif // INVALID_TESTS

    hr = pd3dd->BeginStateBlock();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::BeginStateBlock"))) {
        return TR_ABORT;
    }

    hr = pd3dd->EndStateBlock(&dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::EndStateBlock"))) {
        return TR_FAIL;
    }

    hr = pd3dd->DeleteStateBlock(dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::DeleteStateBlock"))) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CreateStateBlock(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    UINT                i;
    DWORD               dwToken;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    D3DSTATEBLOCKTYPE   sbt[] = {
                            D3DSBT_ALL,
                            D3DSBT_VERTEXSTATE,
                            D3DSBT_PIXELSTATE,
                        };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 0; i < countof(sbt); i++) {

        hr = pd3dd->CreateStateBlock(sbt[i], &dwToken);
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::CreateStateBlock with type %d failed [0x%X]"), sbt[i], hr);
            tr = TR_FAIL;
        }
        else {
            hr = pd3dd->DeleteStateBlock(dwToken);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::DeleteStateBlock"))) {
                tr = TR_ABORT;
            }
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_DeleteStateBlock(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwToken;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

#ifdef INVALID_TESTS
    hr = pd3dd->DeleteStateBlock(0);
    if (hr != D3DERR_INVALIDCALL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::DeleteStateBlock returned 0x%X when called on a non-existant block"), hr);
        return TR_FAIL;
    }
#endif // INVALID_TESTS

    hr = pd3dd->BeginStateBlock();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::BeginStateBlock"))) {
        return TR_ABORT;
    }

    hr = pd3dd->EndStateBlock(&dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::EndStateBlock"))) {
        return TR_ABORT;
    }

    hr = pd3dd->DeleteStateBlock(dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::DeleteStateBlock on a recorded block"))) {
        tr = TR_FAIL;
    }

    hr = pd3dd->CreateStateBlock(D3DSBT_ALL, &dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::BeginStateBlock"))) {
        return TR_ABORT;
    }

    hr = pd3dd->DeleteStateBlock(dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::DeleteStateBlock on a created block"))) {
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CaptureStateBlock(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwSet, dwGet;
    DWORD               dwToken;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->BeginStateBlock();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::BeginStateBlock"))) {
        return TR_ABORT;
    }

    hr = pd3dd->SetRenderState(D3DRS_TEXTUREFACTOR, rand() % 0xFFFFFFFF);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        return TR_ABORT;
    }

    hr = pd3dd->EndStateBlock(&dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::EndStateBlock"))) {
        return TR_ABORT;
    }

    dwSet = (DWORD)RGBA_MAKE(27, 132, 55, 169);

    hr = pd3dd->SetRenderState(D3DRS_TEXTUREFACTOR, dwSet);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderState"))) {
        return TR_ABORT;
    }

    hr = pd3dd->CaptureStateBlock(dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CaptureStateBlock"))) {
        return TR_FAIL;
    }

    hr = pd3dd->ApplyStateBlock(dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::ApplyStateBlock"))) {
        return TR_ABORT;
    }

    hr = pd3dd->GetRenderState(D3DRS_TEXTUREFACTOR, &dwGet);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetRenderState"))) {
        return TR_ABORT;
    }

    if (dwGet != dwSet) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::CaptureStateBlock failed to correctly capture the block"));
        tr = TR_FAIL;
    }

    hr = pd3dd->DeleteStateBlock(dwToken);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::DeleteStateBlock"))) {
        return TR_ABORT;
    }

    return tr;
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_GetClipStatus(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetClipStatus(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    UINT                i;
    D3DCLIPSTATUS8      d3dcsSet, d3dcsGet;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    DWORD               dwClip[] = {
// ##HACK
//                            D3DCS_ALL,
                            D3DCS_BACK | D3DCS_BOTTOM | D3DCS_FRONT | D3DCS_LEFT | D3DCS_RIGHT | D3DCS_TOP | D3DCS_PLANE0 | D3DCS_PLANE1 | D3DCS_PLANE1 | D3DCS_PLANE3 | D3DCS_PLANE4 | D3DCS_PLANE5,
                            D3DCS_BACK,
                            D3DCS_BOTTOM,
                            D3DCS_FRONT,
                            D3DCS_LEFT,
                            D3DCS_RIGHT,
                            D3DCS_TOP,
                            D3DCS_PLANE0,
                            D3DCS_PLANE1,
                            D3DCS_PLANE2,
                            D3DCS_PLANE3,
                            D3DCS_PLANE4,
                            D3DCS_PLANE5,
                            D3DCS_BACK | D3DCS_BOTTOM | D3DCS_FRONT | D3DCS_LEFT | D3DCS_RIGHT | D3DCS_TOP | D3DCS_PLANE0 | D3DCS_PLANE1 | D3DCS_PLANE1 | D3DCS_PLANE3 | D3DCS_PLANE4 | D3DCS_PLANE5,
                        };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    Log(LOG_FAIL, TEXT("Line 136 of d3dtypes8.h incorrectly puts a semicolon at the end of the #define for D3DCS_ALL"));

    for (i = 0; i < countof(dwClip) - 1; i++) {

        d3dcsSet.ClipUnion = dwClip[i];
        d3dcsSet.ClipIntersection = dwClip[i+1];

        hr = pd3dd->SetClipStatus(&d3dcsSet);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetClipStatus"))) {
            tr = TR_FAIL;
        }
        else {
            hr = pd3dd->GetClipStatus(&d3dcsGet);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetClipStatus"))) {
                tr = TR_FAIL;
            }
            else {
                if (memcmp(&d3dcsSet, &d3dcsGet, sizeof(D3DCLIPSTATUS8))) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetClipStatus failed to set the clip status for union 0x%X and intersection 0x%X"), d3dcsSet.ClipUnion, d3dcsSet.ClipIntersection);
                    tr = TR_FAIL;
                }
            }
        }
    }

    return tr;
}

#endif // !UNDER_XBOX

//******************************************************************************
#define TestRenderState(state, value)                       \
    dwRStateSet = (DWORD)(value);                           \
    hr = pd3dd->SetRenderState(state, dwRStateSet);         \
    if (FAILED(hr)) {                                       \
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderState failed for ") TEXT(#state)); \
        tr = TR_FAIL;                                       \
    }                                                       \
    else {                                                  \
        hr = pd3dd->GetRenderState(state, &dwRStateGet);    \
        if (FAILED(hr)) {                                   \
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetRenderState failed for ") TEXT(#state)); \
            tr = TR_FAIL;                                   \
        }                                                   \
        else {                                              \
            if (dwRStateSet != dwRStateGet) {               \
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetRenderState returned %d for a state set as ") TEXT(#state), dwRStateGet); \
                tr = TR_FAIL;                               \
            }                                               \
        }                                                   \
    }

//******************************************************************************
#define FailRenderState(state, value)                       \
    dwRStateSet = (DWORD)(value);                           \
    hr = pd3dd->SetRenderState(state, dwRStateSet);         \
    if (hr != E_NOTIMPL) {                                  \
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderState returned 0x%X instead of E_NOTIMPL for ") TEXT(#state), hr); \
        tr = TR_FAIL;                                       \
    }                                                       \
                                                            \
    hr = pd3dd->GetRenderState(state, &dwRStateGet);        \
    if (hr != E_NOTIMPL) {                                  \
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetRenderState returned 0x%X instead of E_NOTIMPL for ") TEXT(#state), hr); \
        tr = TR_FAIL;                                       \
    }

//******************************************************************************
TESTPROCAPI TDEV8_GetRenderState(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwState;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->GetRenderState(D3DRS_SHADEMODE, &dwState);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetRenderState(D3DRS_SHADEMODE, ..."))) {
        tr = TR_FAIL;
    }
    else {
        if (dwState != D3DSHADE_GOURAUD) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetRenderState(D3DRS_SHADEMODE, ...) returned %d"), dwState);
            tr = TR_FAIL;
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetRenderState(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwRStateSet, dwRStateGet;
#ifndef UNDER_XBOX
    D3DLINEPATTERN      d3dlp;
#endif
    float               fStart, fEnd, fDensity;
    float               fPSize, fPSizeMin, fPSizeMax, fPScaleA, fPScaleB, fPScaleC;
    DWORD               dwBlock;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->CreateStateBlock(D3DSBT_ALL, &dwBlock);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateStateBlock"))) {
        return TR_ABORT;
    }

    TestRenderState(D3DRS_ZENABLE, D3DZB_USEW);                        // Z Enable
    TestRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);                // Fill Mode
    TestRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);                   // Shade Mode
#ifndef UNDER_XBOX
    d3dlp.wRepeatFactor = 1;
    d3dlp.wLinePattern = 0xF3C7;
    TestRenderState(D3DRS_LINEPATTERN, *((DWORD*)&d3dlp));             // Line Pattern
#endif // !UNDER_XBOX
    TestRenderState(D3DRS_ZWRITEENABLE, FALSE);                        // Z Writes
    TestRenderState(D3DRS_ALPHATESTENABLE, TRUE);                      // Alpha tests
#ifndef UNDER_XBOX
    TestRenderState(D3DRS_LASTPIXEL, FALSE);                           // Last pixel
#endif // !UNDER_XBOX
    TestRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);                // Source blend
    TestRenderState(D3DRS_DESTBLEND, D3DBLEND_INVDESTALPHA);           // Destination blend
    TestRenderState(D3DRS_CULLMODE, D3DCULL_CW);                       // Back-face culling mode
    TestRenderState(D3DRS_ZFUNC, D3DCMP_GREATEREQUAL);                 // Z Comparison function
    TestRenderState(D3DRS_ALPHAREF, 1);                                // Reference alpha value
    TestRenderState(D3DRS_ALPHAFUNC, D3DCMP_NEVER);                    // Alpha comparison function
    TestRenderState(D3DRS_DITHERENABLE, TRUE);                         // Enable dithering
    TestRenderState(D3DRS_ALPHABLENDENABLE, TRUE);                     // Enable alpha blending
    TestRenderState(D3DRS_FOGENABLE, TRUE);                            // Enable fog
    TestRenderState(D3DRS_SPECULARENABLE, TRUE);                       // Specular highlights
    TestRenderState(D3DRS_FOGCOLOR, 
                    RGBA_MAKE(rand()%256, rand()%256, rand()%256, rand()%256)); // Fog Color
    TestRenderState(D3DRS_FOGTABLEMODE, D3DFOG_EXP);                   // Fog mode
    fStart = (float)(rand() % 10);
    TestRenderState(D3DRS_FOGSTART, *((LPDWORD)(&fStart)));            // Fog start
    fEnd = (float)(rand()%90 + 10);
    TestRenderState(D3DRS_FOGEND, *((LPDWORD)(&fEnd)));                // Fog end
    fDensity = RND();
    TestRenderState(D3DRS_FOGDENSITY, *((LPDWORD)(&fDensity)));        // Fog density
    TestRenderState(D3DRS_EDGEANTIALIAS, TRUE);                        // Antialias edges
    TestRenderState(D3DRS_ZBIAS, rand()%16);                           // Z bias
    TestRenderState(D3DRS_RANGEFOGENABLE, TRUE);                       // Enable range-based fog
    TestRenderState(D3DRS_STENCILENABLE, TRUE);                        // Enable stenciling
    TestRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_REPLACE);          // Operation to perform on fail
    TestRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_REPLACE);         // Operation if stencil test passes and z test fails
    TestRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_REPLACE);          // Operation if stencil and z tests pass
    TestRenderState(D3DRS_STENCILFUNC, D3DCMP_LESSEQUAL);              // Stencil comparison function
    TestRenderState(D3DRS_STENCILREF, 1);                              // Stencil test reference value
    TestRenderState(D3DRS_STENCILMASK, 0x5C6F3D12);                    // Stencil mask
    TestRenderState(D3DRS_STENCILWRITEMASK, 0x5CC7E632);               // Stecil write mask
    TestRenderState(D3DRS_TEXTUREFACTOR, 
                    RGBA_MAKE(rand()%256, rand()%256, rand()%256, rand()%256)); // Texture factor
    TestRenderState(D3DRS_WRAP0, 
                    D3DWRAPCOORD_0 | D3DWRAPCOORD_1 | D3DWRAPCOORD_2 | D3DWRAPCOORD_3); // Texture wrapping
    TestRenderState(D3DRS_WRAP1, 
                    D3DWRAPCOORD_0 | D3DWRAPCOORD_1 | D3DWRAPCOORD_2 | D3DWRAPCOORD_3); // Texture wrapping
    TestRenderState(D3DRS_WRAP2, 
                    D3DWRAPCOORD_0 | D3DWRAPCOORD_1 | D3DWRAPCOORD_2 | D3DWRAPCOORD_3); // Texture wrapping
    TestRenderState(D3DRS_WRAP3, 
                    D3DWRAPCOORD_0 | D3DWRAPCOORD_1 | D3DWRAPCOORD_2 | D3DWRAPCOORD_3); // Texture wrapping
#ifndef UNDER_XBOX
    TestRenderState(D3DRS_WRAP4, 
                    D3DWRAPCOORD_0 | D3DWRAPCOORD_1 | D3DWRAPCOORD_2 | D3DWRAPCOORD_3); // Texture wrapping
    TestRenderState(D3DRS_WRAP5, 
                    D3DWRAPCOORD_0 | D3DWRAPCOORD_1 | D3DWRAPCOORD_2 | D3DWRAPCOORD_3); // Texture wrapping
    TestRenderState(D3DRS_WRAP6, 
                    D3DWRAPCOORD_0 | D3DWRAPCOORD_1 | D3DWRAPCOORD_2 | D3DWRAPCOORD_3); // Texture wrapping
    TestRenderState(D3DRS_WRAP7, 
                    D3DWRAPCOORD_0 | D3DWRAPCOORD_1 | D3DWRAPCOORD_2 | D3DWRAPCOORD_3); // Texture wrapping
    TestRenderState(D3DRS_CLIPPING, FALSE);                            // Clipping
#endif // !UNDER_XBOX
    TestRenderState(D3DRS_LIGHTING, FALSE);                            // Lighting
    TestRenderState(D3DRS_AMBIENT, 
                    RGBA_MAKE(rand()%256, rand()%256, rand()%256, rand()%256)); // Ambient
#ifndef UNDER_XBOX
    TestRenderState(D3DRS_FOGVERTEXMODE, D3DFOG_EXP);                  // Fog vertex mode
#endif // !UNDER_XBOX
    TestRenderState(D3DRS_COLORVERTEX, FALSE);                         // Per-vertex color
    TestRenderState(D3DRS_LOCALVIEWER, FALSE);                         // Camera-relative specular
    TestRenderState(D3DRS_NORMALIZENORMALS, TRUE);                     // Normalization of vertex normals
    TestRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR2);       // Diffuse material source
    TestRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_COLOR1);      // Specular material source
    TestRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_MATERIAL);     // Ambient material source
    TestRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);      // Emissive material source
    TestRenderState(D3DRS_VERTEXBLEND, D3DVBF_2WEIGHTS);               // Vertex blend
#ifndef UNDER_XBOX
    TestRenderState(D3DRS_CLIPPLANEENABLE, D3DCLIPPLANE4);             // Clip plane enable
#endif // !UNDER_XBOX
    fPSize = 9.6f;
    TestRenderState(D3DRS_POINTSIZE, *((LPDWORD)(&fPSize)));           // Sprite point size
    fPSizeMin = 9.8f;
    TestRenderState(D3DRS_POINTSIZE_MIN, *((LPDWORD)(&fPSizeMin)));    // Minimum sprite point size
    TestRenderState(D3DRS_POINTSPRITEENABLE, TRUE);                    // Enable point sprite texturing
    TestRenderState(D3DRS_POINTSCALEENABLE, TRUE);                     // Enable point scaling
    fPScaleA = 2.3f;
    TestRenderState(D3DRS_POINTSCALE_A, *((LPDWORD)&fPScaleA));      // Point scale attenuation
    fPScaleB = 7.4f;
    TestRenderState(D3DRS_POINTSCALE_B, *((LPDWORD)(&fPScaleB)));      // Point scale attenuation
    fPScaleC = 32.1f;
    TestRenderState(D3DRS_POINTSCALE_C, *((LPDWORD)(&fPScaleC)));      // Point scale attenuation
    TestRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);                // Enable multisampling
    TestRenderState(D3DRS_MULTISAMPLEMASK, 0x234C4F7A);                // Multisample mask value
    TestRenderState(D3DRS_PATCHSEGMENTS, 3);                           // Patch segments
#ifndef UNDER_XBOX
    TestRenderState(D3DRS_DEBUGMONITORTOKEN, 0);                       // ???
#endif // !UNDER_XBOX
    fPSizeMax = 9.4f;
    TestRenderState(D3DRS_POINTSIZE_MAX, *((LPDWORD)(&fPSizeMax)));    // Maximum sprite point size
#ifndef UNDER_XBOX
    TestRenderState(D3DRS_INDEXEDVERTEXBLENDENABLE, TRUE)              // Indexed vertex blending
#endif // !UNDER_XBOX
    TestRenderState(D3DRS_COLORWRITEENABLE, 
                    D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_GREEN); // Per-channel target write
#ifndef UNDER_XBOX
    FailRenderState(D3DRS_ZVISIBLE, TRUE);                             // Enable z checking
#endif // !UNDER_XBOX

#ifndef UNDER_XBOX
    hr = pd3dd->SetRenderState(D3DRS_SOFTWAREVERTEXPROCESSING, TRUE);  // Enable software vertex processing
    if (hr != E_NOTIMPL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderState returned 0x%X instead of E_NOTIMPL for D3DRS_SOFTWAREVERTEXPROCESSING"), hr);
        tr = TR_FAIL;
    }
#endif // !UNDER_XBOX

    // Clean up the mess we made
    hr = pd3dd->ApplyStateBlock(dwBlock);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::ApplyStateBlock"))) {
        tr = TR_ABORT;
    }

    pd3dd->DeleteStateBlock(dwBlock);

    ReleaseDevice8();

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetRenderTarget(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    LPDIRECT3DSURFACE8  pd3dsBack, pd3dsTarget;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pd3dsBack);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetBackBuffer"))) {
        return TR_ABORT;
    }

    hr = pd3dd->GetRenderTarget(&pd3dsTarget);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetRenderTarget"))) {
        tr = TR_FAIL;
    }
    else {
        if (pd3dsBack != pd3dsTarget) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetRenderTarget returned a target other than the back buffer"));
            tr = TR_FAIL;
        }

        pd3dsTarget->Release();
    }

    pd3dsBack->Release();

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetRenderTarget(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    LPDIRECT3DSURFACE8  pd3ds1, pd3dsd1, pd3ds2, pd3dsd2, pd3ds3, pd3dsd3;
    LPDIRECT3DTEXTURE8  pd3dt;
    ULONG               uRef1, uRef2;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // Save the original target
    hr = pd3dd->GetRenderTarget(&pd3ds1);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetRenderTarget"))) {
        return TR_ABORT;
    }

    hr = pd3dd->GetDepthStencilSurface(&pd3dsd1);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetDepthStencilSurface"))) {
        pd3ds1->Release();
        return TR_ABORT;
    }

    // Create a new target
#ifndef UNDER_XBOX
    hr = pd3dd->CreateDepthStencilSurface(512, 512, D3DFMT_D24S8, D3DMULTISAMPLE_NONE, &pd3dsd2);
#else
    hr = pd3dd->CreateDepthStencilSurface(512, 512, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &pd3dsd2);
#endif // UNDER_XBOX
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateDepthStencilSurface"))) {
        pd3dsd1->Release();
        pd3ds1->Release();
        return TR_ABORT;
    }

    hr = pd3dd->CreateTexture(512, 512, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &pd3dt);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateTexture"))) {
        pd3dsd2->Release();
        pd3ds1->Release();
        pd3dsd1->Release();
        return TR_ABORT;
    }

    hr = pd3dt->GetSurfaceLevel(0, &pd3ds2);
    pd3dt->Release();
    if (ResultFailed(hr, TEXT("IDirect3DTexture8::GetSurfaceLevel"))) {
        pd3dsd2->Release();
        pd3ds1->Release();
        pd3dsd1->Release();
        return TR_ABORT;
    }

    pd3ds1->AddRef();
    uRef1 = pd3ds1->Release();
    pd3dsd1->AddRef();
    uRef2 = pd3dsd1->Release();

    // Set the target
    hr = pd3dd->SetRenderTarget(pd3ds2, pd3dsd2);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderTarget"))) {
        pd3ds2->Release();
        pd3dsd2->Release();
        pd3ds1->Release();
        pd3dsd1->Release();
        return TR_FAIL;
    }

    // Verify the reference counts of the old buffers were correctly decremented
#if 0
    pd3ds1->AddRef();
    pd3dsd1->AddRef();
    if (pd3ds1->Release() != uRef1 + 1) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to decrement the ref count on the color buffer being replaced"));
        tr = TR_FAIL;
    }
    if (pd3dsd1->Release() != uRef2 + 1) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to decrement the ref count on the depth buffer being replaced"));
        tr = TR_FAIL;
    }

    // Verify the reference counts of the new buffers were correctly incremented
    pd3ds2->AddRef();
    pd3dsd2->AddRef();
    if (pd3ds2->Release() != 2) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to increment the ref count on the color buffer being set"));
        tr = TR_FAIL;
    }
    if (pd3dsd2->Release() != 2) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to increment the ref count on the depth buffer being set"));
        tr = TR_FAIL;
    }
#endif

    // Verify the target was correctly set
    hr = pd3dd->GetRenderTarget(&pd3ds3);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetRenderTarget"))) {
        pd3ds2->Release();
        pd3dsd2->Release();
        pd3ds1->Release();
        pd3dsd1->Release();
        return TR_ABORT;
    }

    hr = pd3dd->GetDepthStencilSurface(&pd3dsd3);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetDepthStencilSurface"))) {
        pd3ds2->Release();
        pd3dsd2->Release();
        pd3ds1->Release();
        pd3dsd1->Release();
        return TR_ABORT;
    }

    if (pd3ds3 != pd3ds2) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to correctly set the color buffer"));
        tr = TR_FAIL;
    }
    if (pd3dsd3 != pd3dsd2) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to correctly set the depth buffer"));
        tr = TR_FAIL;
    }

    pd3ds3->Release();
    pd3dsd3->Release();

    // Restore the original target
    hr = pd3dd->SetRenderTarget(pd3ds1, pd3dsd1);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderTarget"))) {
        tr = TR_ABORT;
    }

    // Release
    pd3ds2->Release();
    pd3dsd2->Release();
    pd3ds1->Release();
    pd3dsd1->Release();

    return tr;
}

/*
//******************************************************************************
TESTPROCAPI TDEV8_SetRenderTarget(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    LPDIRECT3DSURFACE8  pd3ds1, pd3dsd1, pd3ds2, pd3dsd2, pd3ds3, pd3dsd3;
    LPDIRECT3DTEXTURE8  pd3dt;
    ULONG               uRef1, uRef2;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // Save the original target
    hr = pd3dd->GetRenderTarget(&pd3ds1);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetRenderTarget"))) {
        return TR_ABORT;
    }

    hr = pd3dd->GetDepthStencilSurface(&pd3dsd1);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetDepthStencilSurface"))) {
        pd3ds1->Release();
        return TR_ABORT;
    }

    // Create a new target
#ifndef UNDER_XBOX
    hr = pd3dd->CreateDepthStencilSurface(512, 512, D3DFMT_D24S8, D3DMULTISAMPLE_NONE, &pd3dsd2);
#else
    hr = pd3dd->CreateDepthStencilSurface(512, 512, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &pd3dsd2);
#endif // UNDER_XBOX
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateDepthStencilSurface"))) {
        pd3dsd1->Release();
        pd3ds1->Release();
        return TR_ABORT;
    }

    hr = pd3dd->CreateTexture(512, 512, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &pd3dt);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateTexture"))) {
        pd3dsd2->Release();
        pd3ds1->Release();
        pd3dsd1->Release();
        return TR_ABORT;
    }

    hr = pd3dt->GetSurfaceLevel(0, &pd3ds2);
    pd3dt->Release();
    if (ResultFailed(hr, TEXT("IDirect3DTexture8::GetSurfaceLevel"))) {
        pd3dsd2->Release();
        pd3ds1->Release();
        pd3dsd1->Release();
        return TR_ABORT;
    }

    pd3ds1->AddRef();
    uRef1 = pd3ds1->Release();
    pd3dsd1->AddRef();
    uRef2 = pd3dsd1->Release();

    // Set the target
    hr = pd3dd->SetRenderTarget(pd3ds2, pd3dsd2);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderTarget"))) {
        pd3ds2->Release();
        pd3dsd2->Release();
        pd3ds1->Release();
        pd3dsd1->Release();
        return TR_FAIL;
    }

    // Verify the reference counts of the old buffers were correctly decremented
    pd3ds1->AddRef();
    pd3dsd1->AddRef();
    if (pd3ds1->Release() != uRef1 + 1) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to decrement the ref count on the color buffer being replaced"));
        tr = TR_FAIL;
    }
    if (pd3dsd1->Release() != uRef2 + 1) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to decrement the ref count on the depth buffer being replaced"));
        tr = TR_FAIL;
    }

    // Verify the reference counts of the new buffers were correctly incremented
    pd3ds2->AddRef();
    pd3dsd2->AddRef();
    if (pd3ds2->Release() != 2) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to increment the ref count on the color buffer being set"));
        tr = TR_FAIL;
    }
    if (pd3dsd2->Release() != 2) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to increment the ref count on the depth buffer being set"));
        tr = TR_FAIL;
    }

    // Verify the target was correctly set
    hr = pd3dd->GetRenderTarget(&pd3ds3);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetRenderTarget"))) {
        pd3ds2->Release();
        pd3dsd2->Release();
        pd3ds1->Release();
        pd3dsd1->Release();
        return TR_ABORT;
    }

    hr = pd3dd->GetDepthStencilSurface(&pd3dsd3);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetDepthStencilSurface"))) {
        pd3ds2->Release();
        pd3dsd2->Release();
        pd3ds1->Release();
        pd3dsd1->Release();
        return TR_ABORT;
    }

    if (pd3ds3 != pd3ds2) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to correctly set the color buffer"));
        tr = TR_FAIL;
    }
    if (pd3dsd3 != pd3dsd2) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetRenderTarget failed to correctly set the depth buffer"));
        tr = TR_FAIL;
    }

    pd3ds3->Release();
    pd3dsd3->Release();

    // Restore the original target
    hr = pd3dd->SetRenderTarget(pd3ds1, pd3dsd1);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetRenderTarget"))) {
        tr = TR_ABORT;
    }

    // Release
    pd3ds2->Release();
    pd3dsd2->Release();
    pd3ds1->Release();
    pd3dsd1->Release();

    return tr;
}
*/

//******************************************************************************
TESTPROCAPI TDEV8_GetTransform(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

#ifndef UNDER_XBOX
#define NUM_TRANSFORMS  266
#else
#define NUM_TRANSFORMS  10
#endif // UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_SetTransform(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    D3DXMATRIX              mInitial[266];
    D3DXMATRIX              mSet, mGet;
    UINT                    i;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    D3DTRANSFORMSTATETYPE   tstType[NUM_TRANSFORMS] = {
                                D3DTS_VIEW,
                                D3DTS_PROJECTION,
                                D3DTS_TEXTURE0,
                                D3DTS_TEXTURE1,
                                D3DTS_TEXTURE2,
                                D3DTS_TEXTURE3,
#ifndef UNDER_XBOX
                                D3DTS_TEXTURE4,
                                D3DTS_TEXTURE5,
                                D3DTS_TEXTURE6,
                                D3DTS_TEXTURE7,
#endif // !UNDER_XBOX
                            };
    
    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 10; i < NUM_TRANSFORMS; i++) {
        tstType[i] = D3DTS_WORLDMATRIX(i - 10);
    }

    for (i = 0; i < NUM_TRANSFORMS; i++) {
        hr = pd3dd->GetTransform(tstType[i], &mInitial[i]);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetTransform"))) {
            return TR_ABORT;
        }
    }

    for (i = 0; i < NUM_TRANSFORMS; i++) {

        mSet = D3DXMATRIX(FLT_RND, FLT_RND, FLT_RND, FLT_RND, 
                          FLT_RND, FLT_RND, FLT_RND, FLT_RND, 
                          FLT_RND, FLT_RND, FLT_RND, FLT_RND, 
                          FLT_RND, FLT_RND, FLT_RND, FLT_RND);
        if (tstType[i] == D3DTS_PROJECTION) {
            mSet._23 = RND() * FLT_MAX;
            mSet._34 = RND() * FLT_MAX;
        }

        hr = pd3dd->SetTransform(tstType[i], &mSet);
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetTransform failed for type %d"), tstType[i]);
            tr = TR_FAIL;
        }
        else {
            hr = pd3dd->GetTransform(tstType[i], &mGet);
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetTransform failed for type %d"), tstType[i]);
                tr = TR_FAIL;
            }
            else {
                if (memcmp(&mGet, &mSet, sizeof(D3DXMATRIX))) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetTransform incorrectly set the transform for type %d"), tstType[i]);
                    tr = TR_FAIL;
                }
            }
        }
    }

    // Restore the transforms
    for (i = 0; i < NUM_TRANSFORMS; i++) {
        hr = pd3dd->SetTransform(tstType[i], &mInitial[i]);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTransform"))) {
            tr = TR_ABORT;
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_MultiplyTransform(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    D3DXMATRIX              mInitial[NUM_TRANSFORMS];
    D3DXMATRIX              mSet, mGet, mMult, mResult;
    UINT                    i;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    D3DTRANSFORMSTATETYPE   tstType[266] = {
                                D3DTS_VIEW,
                                D3DTS_PROJECTION,
                                D3DTS_TEXTURE0,
                                D3DTS_TEXTURE1,
                                D3DTS_TEXTURE2,
                                D3DTS_TEXTURE3,
#ifndef UNDER_XBOX
                                D3DTS_TEXTURE4,
                                D3DTS_TEXTURE5,
                                D3DTS_TEXTURE6,
                                D3DTS_TEXTURE7,
#endif // !UNDER_XBOX
                            };
    
    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 10; i < NUM_TRANSFORMS; i++) {
        tstType[i] = D3DTS_WORLDMATRIX(i - 10);
    }

    for (i = 0; i < NUM_TRANSFORMS; i++) {
        hr = pd3dd->GetTransform(tstType[i], &mInitial[i]);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetTransform"))) {
            return TR_ABORT;
        }
    }

    for (i = 0; i < NUM_TRANSFORMS; i++) {

        mSet = D3DXMATRIX(NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, 
                          NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, 
                          NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, 
                          NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f);
        if (tstType[i] == D3DTS_PROJECTION) {
            mSet._23 = FABS(mSet._23);
            mSet._34 = FABS(mSet._34);
        }

        hr = pd3dd->SetTransform(tstType[i], &mSet);
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetTransform failed for type %d"), tstType[i]);
            tr = TR_FAIL;
        }
        else {

            mMult = D3DXMATRIX(NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, 
                               NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, 
                               NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, 
                               NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f, NRND()*1000.0f);
            if (tstType[i] == D3DTS_PROJECTION) {
                mMult._23 = FABS(mMult._23);
                mMult._34 = FABS(mMult._34);
            }

            hr = pd3dd->MultiplyTransform(tstType[i], &mMult);
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::MultiplyTransform failed for type %d"), tstType[i]);
                tr = TR_FAIL;
            }
            else {
                hr = pd3dd->GetTransform(tstType[i], &mGet);
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetTransform failed for type %d"), tstType[i]);
                    tr = TR_FAIL;
                }
                else {
                    D3DXMatrixMultiply(&mResult, &mMult, &mSet);
#ifndef UNDER_XBOX
                    if (memcmp(&mGet, &mResult, sizeof(D3DXMATRIX))) {
                        Log(LOG_FAIL, TEXT("IDirect3DDevice8::MultiplyTransform incorrently multiplied the transform for type %d"), tstType[i]);
                        tr = TR_FAIL;
                    }
#else
                    float* pfElementG, *pfElementR;
                    UINT j;
                    for (j = 0, pfElementG = &mGet._11, pfElementR = &mResult._11; j < 16; j++, pfElementG++, pfElementR++) {
                        if (FABS(*pfElementR - *pfElementG) > 1.0f) {
                            Log(LOG_FAIL, TEXT("IDirect3DDevice8::MultiplayTransform incorrectly multiplied the transform on element %d, returning %3.3f (expected %3.3f)"), j, *pfElementG, *pfElementR);
                            tr = TR_FAIL;
                            break;
                        }
                    }
#endif // UNDER_XBOX
                }
            }
        }
    }

    // Restore the transforms
    for (i = 0; i < NUM_TRANSFORMS; i++) {
        hr = pd3dd->SetTransform(tstType[i], &mInitial[i]);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetTransform"))) {
            tr = TR_ABORT;
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_Clear(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    UINT                i, j;
    D3DRECT*            prc[2];
    DWORD               dwCount[2];
    D3DRECT             rc[10];
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    DWORD               dwFlags[] = {
                            D3DCLEAR_TARGET,
                            D3DCLEAR_ZBUFFER,
                            D3DCLEAR_STENCIL,
                            D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
                            D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL,
                            D3DCLEAR_STENCIL | D3DCLEAR_TARGET,
                            D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL
                        };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    rc[0].x1 = 0;
    rc[0].y1 = 0;
    rc[0].x2 = 50;
    rc[0].y2 = 100;
    for (i = 1; i < 10; i++) {
        rc[i].x1 = rc[0].x1 + i;
        rc[i].y1 = rc[0].y1 + i;
        rc[i].x2 = rc[0].x2 + i;
        rc[i].y2 = rc[0].y2 + i;
    }

    prc[0] = NULL;
    prc[1] = rc;
    dwCount[0] = 0;
    dwCount[1] = 10;

    for (i = 0; i < countof(dwFlags); i++) {

        for (j = 0; j < 2; j++) {
            
            LogBeginVariation(TEXT("IDirect3DDevice8::Clear of %s using 0x%X flags"), j ? TEXT("rectangles") : TEXT("the entire render target"), dwFlags[i]);
            hr = pd3dd->Clear(dwCount[j], prc[j], dwFlags[i], RGBA_MAKE(rand() % 256, rand() % 256, rand() % 256, rand() % 256), RND(), rand() % 256);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::Clear"))) {
                tr = TR_FAIL;
            }
            LogEndVariation();
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetViewport(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetViewport(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    D3DVIEWPORT8        vpSet[2], vpGet, vpInitial;
    UINT                i;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    pd3dd->GetViewport(&vpInitial);

    memset(vpSet, 0, 2 * sizeof(D3DVIEWPORT8));
    vpSet[0].X = 0;
    vpSet[0].Y = 0;
    vpSet[0].Width = TARGET_WIDTH;
    vpSet[0].Height = TARGET_HEIGHT;
    vpSet[0].MinZ = 0.0f;
    vpSet[0].MaxZ = 1.0f;
    vpSet[1].X = rand() % (TARGET_WIDTH - 1);
    vpSet[1].Y = rand() % (TARGET_HEIGHT - 1);
    vpSet[1].Width = rand() % (TARGET_WIDTH - vpSet[1].X) + 1;
    vpSet[1].Height = rand() % (TARGET_HEIGHT - vpSet[1].Y) + 1;
    vpSet[1].MinZ = FRND(0.95f);
    vpSet[1].MaxZ = vpSet[1].MinZ + FRND(1.0f - vpSet[1].MinZ);

    for (i = 0; i < 2; i++) {
        hr = pd3dd->SetViewport(&vpSet[i]);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetViewport"))) {
            tr = TR_FAIL;
        }
        else {
            hr = pd3dd->GetViewport(&vpGet);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetViewport"))) {
                tr = TR_FAIL;
            }
            else {
                if (memcmp(&vpSet[i], &vpGet, sizeof(D3DVIEWPORT8))) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetViewport failed to correctly set the viewport information"));
                    tr = TR_FAIL;
                }
            }
        }
    }

    pd3dd->SetViewport(&vpInitial);

    return tr;
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_GetClipPlane(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

return TR_SKIP;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetClipPlane(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    D3DCAPS8            d3dcaps;
    D3DXVECTOR3         vPlaneNormal, vPointOnPlane;
    D3DXVECTOR4         vClipPlaneSet[D3DMAXUSERCLIPPLANES];
    D3DXVECTOR4         vClipPlaneGet;
    UINT                i;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

return TR_SKIP;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->GetDeviceCaps(&d3dcaps);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetDeviceCaps"))) {
        return TR_ABORT;
    }

    if (d3dcaps.MaxUserClipPlanes != 6) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetCaps reported an incorrect number of maximum user-defined clip planes (%d)"), d3dcaps.MaxUserClipPlanes);
        tr = TR_FAIL;
    }

    for (i = 0; i < D3DMAXUSERCLIPPLANES; i++) {
        D3DXVec3Normalize(&vPlaneNormal, &D3DXVECTOR3(NRND(), NRND(), NRND()));
        vPointOnPlane = D3DXVECTOR3(NRND() * 10.0f, NRND() * 10.0f, NRND() * 10.0f);
        vClipPlaneSet[i] = D3DXVECTOR4(vPlaneNormal.x, vPlaneNormal.y, vPlaneNormal.z,
                            -vPlaneNormal.x * vPointOnPlane.x - vPlaneNormal.y * vPointOnPlane.y
                            - vPlaneNormal.z * vPointOnPlane.z);
        hr = pd3dd->SetClipPlane(i, (float*)&vClipPlaneSet[i]);
        if (i >= d3dcaps.MaxUserClipPlanes) {
            if (hr != D3DERR_INVALIDCALL) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetClipPlane returned 0x%X instead of D3DERR_INVALIDCALL for an out of range plane index %d"), hr, i);
                tr = TR_FAIL;
            }
        }
        else {
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetClipPlane failed on index %d [0x%X]"), i, hr);
                tr = TR_FAIL;
            }
            else {
                hr = pd3dd->GetClipPlane(i, (float*)&vClipPlaneGet);
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetClipPlane failed on index %d [0x%X]"), i, hr);
                    tr = TR_FAIL;
                }
                else {
                    if (memcmp(&vClipPlaneGet, &vClipPlaneSet[i], sizeof(D3DXVECTOR4))) {
                        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetClipPlane incorrectly set the clip plane for index %d"), i);
                        tr = TR_FAIL;
                    }
                }
            }
        }
    }

    for (i = 0; i < d3dcaps.MaxUserClipPlanes; i++) {
        hr = pd3dd->GetClipPlane(i, (float*)&vClipPlaneGet);
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetClipPlane failed on index %d [0x%X]"), i, hr);
            tr = TR_FAIL;
        }
        else {
            if (memcmp(&vClipPlaneGet, &vClipPlaneSet[i], sizeof(D3DXVECTOR4))) {
                Log(LOG_FAIL, TEXT("The clip plane for index %d failed to persist"), i);
                tr = TR_FAIL;
            }
        }
    }

    return tr;
}

#endif // UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_GetLight(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetLight(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    D3DLIGHT8           lightSet[10], lightGet;
    UINT                i, j;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    D3DLIGHTTYPE        d3dlt[] = {
                            D3DLIGHT_POINT,
                            D3DLIGHT_SPOT,
                            D3DLIGHT_DIRECTIONAL,
                        };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (j = 0; j < 2; j++) {   // Overwrite existing lights on the second pass

        memset(lightSet, 0, 10 * sizeof(D3DLIGHT8));

        for (i = 0; i < 10; i++) {

            lightSet[i].Type = d3dlt[i % 3];
            lightSet[i].Diffuse.r = NRND();
            lightSet[i].Diffuse.g = NRND();
            lightSet[i].Diffuse.b = NRND();
            lightSet[i].Diffuse.a = NRND();
            lightSet[i].Specular.r = NRND();
            lightSet[i].Specular.g = NRND();
            lightSet[i].Specular.b = NRND();
            lightSet[i].Specular.a = NRND();
            lightSet[i].Ambient.r = NRND();
            lightSet[i].Ambient.g = NRND();
            lightSet[i].Ambient.b = NRND();
            lightSet[i].Ambient.a = NRND();
            lightSet[i].Position.x = NRND() * 100.0f;
            lightSet[i].Position.y = NRND() * 100.0f;
            lightSet[i].Position.z = NRND() * 100.0f;
            lightSet[i].Direction.x = NRND() * 100.0f;
            lightSet[i].Direction.y = NRND() * 100.0f;
            lightSet[i].Direction.z = NRND() * 100.0f;
            if (i < 3) {
                lightSet[i].Range = 0.0f;
            }
            else if (i < 6) {
                lightSet[i].Range = (float)sqrt(FLT_MAX);
            }
            else {
                lightSet[i].Range = RND() * (float)sqrt(FLT_MAX);
            }
            lightSet[i].Falloff = RND();
            lightSet[i].Attenuation0 = RND() * FLT_MAX;
            lightSet[i].Attenuation1 = RND() * FLT_MAX;
            lightSet[i].Attenuation2 = RND() * FLT_MAX;
            lightSet[i].Phi = RND() * M_PI;
            lightSet[i].Theta = RND() * lightSet[i].Phi;

            hr = pd3dd->SetLight(i, &lightSet[i]);
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetLight failed on index %d [0x%X]"), i, hr);
                tr = TR_FAIL;
            }
            else {
                hr = pd3dd->GetLight(i, &lightGet);
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetLight failed on index %d [0x%X]"), i, hr);
                    tr = TR_FAIL;
                }
                else {
                    switch (lightSet[i].Type) {

                        case D3DLIGHT_SPOT:
                            if (memcmp(&lightGet, &lightSet[i], sizeof(D3DLIGHT8))) {
                                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetLight incorrectly set the light for index %d"), i);
                                tr = TR_FAIL;
                            }
                            break;

                        case D3DLIGHT_DIRECTIONAL:
                            if (lightGet.Type != lightSet[i].Type ||
                                memcmp(&lightGet.Diffuse, &lightSet[i].Diffuse, sizeof(D3DCOLORVALUE)) ||
                                memcmp(&lightGet.Ambient, &lightSet[i].Ambient, sizeof(D3DCOLORVALUE)) ||
                                memcmp(&lightGet.Specular, &lightSet[i].Specular, sizeof(D3DCOLORVALUE)) ||
                                memcmp(&lightGet.Direction, &lightSet[i].Direction, sizeof(D3DVECTOR)))
                            {
                                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetLight incorrectly set the light for index %d"), i);
                                tr = TR_FAIL;
                            }
                            break;

                        case D3DLIGHT_POINT:
                             if (lightGet.Type != lightSet[i].Type ||
                                memcmp(&lightGet.Diffuse, &lightSet[i].Diffuse, sizeof(D3DCOLORVALUE)) ||
                                memcmp(&lightGet.Ambient, &lightSet[i].Ambient, sizeof(D3DCOLORVALUE)) ||
                                memcmp(&lightGet.Specular, &lightSet[i].Specular, sizeof(D3DCOLORVALUE)) ||
                                memcmp(&lightGet.Position, &lightSet[i].Position, sizeof(D3DVECTOR)) ||
                                lightGet.Range != lightSet[i].Range ||
                                lightGet.Attenuation0 != lightSet[i].Attenuation0 ||
                                lightGet.Attenuation1 != lightSet[i].Attenuation1 ||
                                lightGet.Attenuation2 != lightSet[i].Attenuation2)
                            {
                                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetLight incorrectly set the light for index %d"), i);
                                tr = TR_FAIL;
                            }
                            break;
                    }
                }
            }
        }

        for (i = 0; i < 10; i++) {

            hr = pd3dd->GetLight(i, &lightGet);
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetLight failed on index %d [0x%X]"), i, hr);
                tr = TR_FAIL;
            }
            else {
                switch (lightSet[i].Type) {

                    case D3DLIGHT_SPOT:
                        if (memcmp(&lightGet, &lightSet[i], sizeof(D3DLIGHT8))) {
                            Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetLight incorrectly set the light for index %d"), i);
                            tr = TR_FAIL;
                        }
                        break;

                    case D3DLIGHT_DIRECTIONAL:
                        if (lightGet.Type != lightSet[i].Type ||
                            memcmp(&lightGet.Diffuse, &lightSet[i].Diffuse, sizeof(D3DCOLORVALUE)) ||
                            memcmp(&lightGet.Ambient, &lightSet[i].Ambient, sizeof(D3DCOLORVALUE)) ||
                            memcmp(&lightGet.Specular, &lightSet[i].Specular, sizeof(D3DCOLORVALUE)) ||
                            memcmp(&lightGet.Direction, &lightSet[i].Direction, sizeof(D3DVECTOR)))
                        {
                            Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetLight incorrectly set the light for index %d"), i);
                            tr = TR_FAIL;
                        }
                        break;

                    case D3DLIGHT_POINT:
                         if (lightGet.Type != lightSet[i].Type ||
                            memcmp(&lightGet.Diffuse, &lightSet[i].Diffuse, sizeof(D3DCOLORVALUE)) ||
                            memcmp(&lightGet.Ambient, &lightSet[i].Ambient, sizeof(D3DCOLORVALUE)) ||
                            memcmp(&lightGet.Specular, &lightSet[i].Specular, sizeof(D3DCOLORVALUE)) ||
                            memcmp(&lightGet.Position, &lightSet[i].Position, sizeof(D3DVECTOR)) ||
                            lightGet.Range != lightSet[i].Range ||
                            lightGet.Attenuation0 != lightSet[i].Attenuation0 ||
                            lightGet.Attenuation1 != lightSet[i].Attenuation1 ||
                            lightGet.Attenuation2 != lightSet[i].Attenuation2)
                        {
                            Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetLight incorrectly set the light for index %d"), i);
                            tr = TR_FAIL;
                        }
                        break;
                }
            }
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_LightEnable(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    D3DLIGHT8           lightSet[3], lightGet;
    BOOL                bEnabled;
    UINT                i, j;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    D3DLIGHTTYPE        d3dlt[] = {
                            D3DLIGHT_POINT,
                            D3DLIGHT_SPOT,
                            D3DLIGHT_DIRECTIONAL,
                        };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    memset(lightSet, 0, 3 * sizeof(D3DLIGHT8));

    for (i = 0; i < 3; i++) {

        lightSet[i].Type = d3dlt[i];
        lightSet[i].Diffuse.r = NRND() * 2.0f;
        lightSet[i].Diffuse.g = NRND() * 2.0f;
        lightSet[i].Diffuse.b = NRND() * 2.0f;
        lightSet[i].Diffuse.a = NRND() * 2.0f;
        lightSet[i].Specular.r = NRND() * 2.0f;
        lightSet[i].Specular.g = NRND() * 2.0f;
        lightSet[i].Specular.b = NRND() * 2.0f;
        lightSet[i].Specular.a = NRND() * 2.0f;
        lightSet[i].Ambient.r = NRND() * 2.0f;
        lightSet[i].Ambient.g = NRND() * 2.0f;
        lightSet[i].Ambient.b = NRND() * 2.0f;
        lightSet[i].Ambient.a = NRND() * 2.0f;
        lightSet[i].Position.x = NRND() * 100.0f;
        lightSet[i].Position.y = NRND() * 100.0f;
        lightSet[i].Position.z = NRND() * 100.0f;
        lightSet[i].Direction.x = NRND() * 100.0f;
        lightSet[i].Direction.y = NRND() * 100.0f;
        lightSet[i].Direction.z = NRND() * 100.0f;
        lightSet[i].Range = RND() * (float)sqrt(FLT_MAX);
        lightSet[i].Falloff = RND();
        lightSet[i].Attenuation0 = RND() * FLT_MAX;
        lightSet[i].Attenuation1 = RND() * FLT_MAX;
        lightSet[i].Attenuation2 = RND() * FLT_MAX;
        lightSet[i].Phi = RND() * M_PI;
        lightSet[i].Theta = RND() * lightSet[i].Phi;

        hr = pd3dd->SetLight(i, &lightSet[i]);
        if (FAILED(hr)) {
            Log(LOG_ABORT, TEXT("IDirect3DDevice8::SetLight failed on index %d [0x%X]"), i, hr);
            return TR_ABORT;
        }

        hr = pd3dd->GetLightEnable(i, &bEnabled);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetLightEnable"))) {
            tr = TR_FAIL;
        }
        else {
            if (bEnabled) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetLightEnable incorrectly reported a disabled light as enabled"));
                tr = TR_FAIL;
            }
        }

        for (j = 0; j < 2; j++) { 
            hr = pd3dd->LightEnable(i, !j);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::LightEnable"))) {
                tr = TR_FAIL;
            }
            else {
                hr = pd3dd->GetLightEnable(i, &bEnabled);
                if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetLightEnable"))) {
                    tr = TR_FAIL;
                }
                else {
                    if (bEnabled != !j) {
                        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetLightEnable incorrectly reported a light as %s"), bEnabled ? TEXT("enabled") : TEXT("disabled"));
                        tr = TR_FAIL;
                    }
                }
            }
        }
    }

    i = 100 + rand() % 900;

#ifdef INVALID_TESTS
    hr = pd3dd->GetLightEnable(i, &bEnabled);
    if (hr != D3DERR_INVALIDCALL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetLightEnable returned 0x%X instead of D3DERR_INVALIDCALL on an invalid index %d"), hr, i);
        tr = TR_FAIL;
    }
#endif // INVALID_TESTS
    hr = pd3dd->LightEnable(i, FALSE);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::LightEnable on an index out of bounds"))) {
        tr = TR_FAIL;
    }
    else {
        hr = pd3dd->GetLight(i, &lightGet);
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetLight failed on index %d [0x%X]"), i, hr);
            tr = TR_FAIL;
        }
        else {
            if (lightGet.Type != D3DLIGHT_DIRECTIONAL ||
                lightGet.Diffuse.a != 0.0f ||
                lightGet.Diffuse.r != 1.0f ||
                lightGet.Diffuse.g != 1.0f ||
                lightGet.Diffuse.b != 1.0f ||
                lightGet.Specular.a != 0.0f ||
                lightGet.Specular.r != 0.0f ||
                lightGet.Specular.g != 0.0f ||
                lightGet.Specular.b != 0.0f ||
                lightGet.Ambient.a != 0.0f ||
                lightGet.Ambient.r != 0.0f ||
                lightGet.Ambient.g != 0.0f ||
                lightGet.Ambient.b != 0.0f ||
                lightGet.Position.x != 0.0f ||
                lightGet.Position.y != 0.0f ||
                lightGet.Position.z != 0.0f ||
                lightGet.Direction.x != 0.0f ||
                lightGet.Direction.y != 0.0f ||
                lightGet.Direction.z != 1.0f ||
                lightGet.Range != 0.0f ||
                lightGet.Falloff != 0.0f ||
                lightGet.Attenuation0 != 0.0f ||
                lightGet.Attenuation1 != 0.0f ||
                lightGet.Attenuation2 != 0.0f ||
                lightGet.Phi != 0.0f ||
                lightGet.Theta != 0.0f)
            {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::LightEnable incorrectly set a default light at index %d"), i);
                tr = TR_FAIL;
            }
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetLightEnable(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetMaterial(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetMaterial(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    D3DMATERIAL8        materialSet, materialGet;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    materialSet.Diffuse.r = NRND() * 2.0f;
    materialSet.Diffuse.g = NRND() * 2.0f;
    materialSet.Diffuse.b = NRND() * 2.0f;
    materialSet.Diffuse.a = NRND() * 2.0f;
    materialSet.Specular.r = NRND() * 2.0f;
    materialSet.Specular.g = NRND() * 2.0f;
    materialSet.Specular.b = NRND() * 2.0f;
    materialSet.Specular.a = NRND() * 2.0f;
    materialSet.Ambient.r = NRND() * 2.0f;
    materialSet.Ambient.g = NRND() * 2.0f;
    materialSet.Ambient.b = NRND() * 2.0f;
    materialSet.Ambient.a = NRND() * 2.0f;
    materialSet.Emissive.r = NRND() * 2.0f;
    materialSet.Emissive.g = NRND() * 2.0f;
    materialSet.Emissive.b = NRND() * 2.0f;
    materialSet.Emissive.a = NRND() * 2.0f;
    materialSet.Power = RND() * 200.0f;

    hr = pd3dd->SetMaterial(&materialSet);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetMaterial"))) {
        return TR_FAIL;
    }

    hr = pd3dd->GetMaterial(&materialGet);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetMaterial"))) {
        return TR_FAIL;
    }

    if (memcmp(&materialSet, &materialGet, sizeof(D3DMATERIAL8))) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetMaterial incorrectly set the material properties in the device"));
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetTexture(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetTexture(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DBASETEXTURE8  pd3dt[4], pd3dtGet;
    ULONG                   uRef1, uRef2;
    UINT                    i, j;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    pd3dt[0] = GetTexture8();
    pd3dt[1] = GetCubeTexture8();
    pd3dt[2] = GetVolumeTexture8();
    pd3dt[3] = NULL;
    if (!pd3dt[0] || !pd3dt[1] || !pd3dt[2]) {
        return TR_ABORT;
    }

    for (i = 0; i < 4; i++) {

        for (j = 0; j < 4; j++) {

            hr = pd3dd->SetTexture(j, pd3dt[i]);
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetTexture failed for texture %d on stage %d"), i, j);
                tr = TR_FAIL;
            }
            else {
                if (i != 3) {
                    pd3dt[i]->AddRef();
                    uRef1 = pd3dt[i]->Release();
                }
                hr = pd3dd->GetTexture(j, &pd3dtGet);
                if (FAILED(hr)) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetTexture failed for texture %d on stage %d"), i, j);
                    tr = TR_FAIL;
                }
                else {
                    if (pd3dt[i] != pd3dtGet) {
                        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetTexture failed to correctly set texture %d on stage %d"), i, j);
                        tr = TR_FAIL;
                    }

                    if (i != 3) {
                        pd3dt[i]->AddRef();
                        uRef2 = pd3dt[i]->Release();
                        if (uRef2 != uRef1 + 1) {
                            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetTexture failed to increment the reference count on the texture %d on stage %d"), i, j);
                        }
                        else {
                            pd3dtGet->Release();
                        }
                    }
                }
            }
        }
    }

    return tr;
}

//******************************************************************************
#define TestTextureStageState(stage, state, value)                              \
    dwTStateSet = (DWORD)(value);                                               \
    hr = pd3dd->SetTextureStageState(stage, state, dwTStateSet);                \
    if (FAILED(hr)) {                                                           \
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetTextureStageState failed for ") TEXT(#state) TEXT(" on stage %d"), stage); \
        tr = TR_FAIL;                                                           \
    }                                                                           \
    else {                                                                      \
        hr = pd3dd->GetTextureStageState(stage, state, &dwTStateGet);           \
        if (FAILED(hr)) {                                                       \
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetTextureStageState failed for ") TEXT(#state) TEXT("on stage %d"), stage); \
            tr = TR_FAIL;                                                       \
        }                                                                       \
        else {                                                                  \
            if (dwTStateSet != dwTStateGet) {                                   \
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetTextureStageState returned %d for a state set as ") TEXT(#state) TEXT(" on stage %d"), hr, stage); \
                tr = TR_FAIL;                                                   \
            }                                                                   \
        }                                                                       \
    }

//******************************************************************************
TESTPROCAPI TDEV8_GetTextureStageState(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetTextureStageState(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwBlock;
    DWORD               dwTStateSet, dwTStateGet;
    float               f00, f01, f10, f11, fBias, fLScale, fLOffset;
    UINT                i;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->CreateStateBlock(D3DSBT_ALL, &dwBlock);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateStateBlock"))) {
        return TR_ABORT;
    }

    f00 = 0.5f;
    f01 = 4.23f;
    f10 = 0.1254f;
    f11 = 0.25f;
    fBias = 0.1f;
    fLScale = 2.0f;
    fLOffset = 11.2f;

    for (i = 0; i < 4; i++) {
        TestTextureStageState(i, D3DTSS_COLOROP,                D3DTOP_DOTPRODUCT3);
        TestTextureStageState(i, D3DTSS_COLORARG1,              D3DTA_DIFFUSE);
        TestTextureStageState(i, D3DTSS_COLORARG2,              D3DTA_TEXTURE);
        TestTextureStageState(i, D3DTSS_ALPHAOP,                D3DTOP_ADD);
        TestTextureStageState(i, D3DTSS_ALPHAARG1,              D3DTA_TEXTURE);
        TestTextureStageState(i, D3DTSS_ALPHAARG2,              D3DTA_DIFFUSE);
        TestTextureStageState(i, D3DTSS_BUMPENVMAT00,           *(LPDWORD)&f00);
        TestTextureStageState(i, D3DTSS_BUMPENVMAT01,           *(LPDWORD)&f01);
        TestTextureStageState(i, D3DTSS_BUMPENVMAT10,           *(LPDWORD)&f10);
        TestTextureStageState(i, D3DTSS_BUMPENVMAT11,           *(LPDWORD)&f11);
        TestTextureStageState(i, D3DTSS_TEXCOORDINDEX,          D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR | 1);
        TestTextureStageState(i, D3DTSS_ADDRESSU,               D3DTADDRESS_CLAMP);
        TestTextureStageState(i, D3DTSS_ADDRESSV,               D3DTADDRESS_BORDER);
        TestTextureStageState(i, D3DTSS_ADDRESSW,               D3DTADDRESS_CLAMP);
        TestTextureStageState(i, D3DTSS_BORDERCOLOR,            RGBA_MAKE(196, 64, 128, 32));
        TestTextureStageState(i, D3DTSS_MAGFILTER,              D3DTEXF_LINEAR);
        TestTextureStageState(i, D3DTSS_MINFILTER,              D3DTEXF_LINEAR);
        TestTextureStageState(i, D3DTSS_MIPFILTER,              D3DTEXF_POINT);
        TestTextureStageState(i, D3DTSS_MIPMAPLODBIAS,          *(LPDWORD)&fBias);
        TestTextureStageState(i, D3DTSS_MAXMIPLEVEL,            2);
        TestTextureStageState(i, D3DTSS_MAXANISOTROPY,          rand() % 5);
        TestTextureStageState(i, D3DTSS_BUMPENVLSCALE,          *(LPDWORD)&fLScale);
        TestTextureStageState(i, D3DTSS_BUMPENVLOFFSET,         *(LPDWORD)&fLOffset);
        TestTextureStageState(i, D3DTSS_TEXTURETRANSFORMFLAGS,  D3DTTFF_COUNT4 | D3DTTFF_PROJECTED);
    }

    // Restore the texture stage states
    hr = pd3dd->ApplyStateBlock(dwBlock);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::ApplyStateBlock"))) {
        tr = TR_ABORT;
    }

    pd3dd->DeleteStateBlock(dwBlock);

    return tr;
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_UpdateTexture(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8        pd3dd;
    LPDIRECT3DTEXTURE8       pd3dtSrc, pd3dtDst;
    LPDIRECT3DCUBETEXTURE8   pd3dtcSrc, pd3dtcDst;
    LPDIRECT3DVOLUMETEXTURE8 pd3dtvSrc, pd3dtvDst;
    D3DLOCKED_RECT           d3dlr;
    D3DLOCKED_BOX            d3dlb;
    DWORD                    dwData;
    HRESULT                  hr;
    TRESULT                  tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // Texture
    hr = pd3dd->CreateTexture(256, 64, 0, 0, D3DFMT_A4R4G4B4, D3DPOOL_SYSTEMMEM, &pd3dtSrc);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateTexture"))) {
        return TR_ABORT;
    }

    hr = pd3dtSrc->LockRect(1, &d3dlr, NULL, 0);
    if (ResultFailed(hr, TEXT("IDirect3DTexture8::LockRect"))) {
        pd3dtSrc->Release();
        return TR_ABORT;
    }

    dwData = rand() % 0xFFFFFFFF + 1;
    *(LPDWORD)d3dlr.pBits = dwData;

    hr = pd3dtSrc->UnlockRect(1);
    if (ResultFailed(hr, TEXT("IDirect3DTexture8::UnlockRect"))) {
        pd3dtSrc->Release();
        return TR_ABORT;
    }

    hr = pd3dd->CreateTexture(256, 64, 3, 0, D3DFMT_A4R4G4B4, D3DPOOL_MANAGED, &pd3dtDst);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateTexture"))) {
        pd3dtSrc->Release();
        return TR_ABORT;
    }

    hr = pd3dd->UpdateTexture(pd3dtSrc, pd3dtDst);
    pd3dtSrc->Release();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::UpdateTexture"))) {
        pd3dtDst->Release();
        tr = TR_FAIL;
    }
    else {

        hr = pd3dtDst->LockRect(1, &d3dlr, NULL, 0);
        if (ResultFailed(hr, TEXT("IDirect3DTexture8::LockRect"))) {
            pd3dtDst->Release();
            return TR_ABORT;
        }

        if (*(LPDWORD)d3dlr.pBits != dwData) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::UpdateTexture failed to correctly update the destination texture"));
            tr = TR_FAIL;
        }

        hr = pd3dtDst->UnlockRect(1);
        pd3dtDst->Release();
        if (ResultFailed(hr, TEXT("IDirect3DTexture8::UnlockRect"))) {
            return TR_ABORT;
        }
    }

    // Cube Texture
    hr = pd3dd->CreateCubeTexture(128, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_SYSTEMMEM, &pd3dtcSrc);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateCubeTexture"))) {
        return TR_ABORT;
    }

    hr = pd3dtcSrc->LockRect(D3DCUBEMAP_FACE_NEGATIVE_Y, 4, &d3dlr, NULL, 0);
    if (ResultFailed(hr, TEXT("IDirect3DCubeTexture8::LockRect"))) {
        pd3dtcSrc->Release();
        return TR_ABORT;
    }

    dwData = rand() % 0xFFFFFFFF + 1;
    *(LPDWORD)d3dlr.pBits = dwData;

    hr = pd3dtcSrc->UnlockRect(D3DCUBEMAP_FACE_NEGATIVE_Y, 4);
    if (ResultFailed(hr, TEXT("IDirect3DTexture8::UnlockRect"))) {
        pd3dtcSrc->Release();
        return TR_ABORT;
    }

    hr = pd3dd->CreateCubeTexture(32, 4, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &pd3dtcDst);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateCubeTexture"))) {
        pd3dtcSrc->Release();
        return TR_ABORT;
    }

    hr = pd3dd->UpdateTexture(pd3dtcSrc, pd3dtcDst);
    pd3dtcSrc->Release();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::UpdateTexture"))) {
        pd3dtcDst->Release();
        tr = TR_FAIL;
    }
    else {

        hr = pd3dtcDst->LockRect(D3DCUBEMAP_FACE_NEGATIVE_Y, 2, &d3dlr, NULL, 0);
        if (ResultFailed(hr, TEXT("IDirect3DCubeTexture8::LockRect"))) {
            pd3dtcDst->Release();
            return TR_ABORT;
        }

        if (*(LPDWORD)d3dlr.pBits != dwData) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::UpdateTexture failed to correctly update the destination cube texture"));
            tr = TR_FAIL;
        }

        hr = pd3dtcDst->UnlockRect(D3DCUBEMAP_FACE_NEGATIVE_Y, 2);
        pd3dtcDst->Release();
        if (ResultFailed(hr, TEXT("IDirect3DCubeTexture8::UnlockRect"))) {
            return TR_ABORT;
        }
    }

    // Volume Texture
    hr = pd3dd->CreateVolumeTexture(32, 256, 64, 0, 0, D3DFMT_R5G6B5, D3DPOOL_SYSTEMMEM, &pd3dtvSrc);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVolumeTexture"))) {
        return TR_ABORT;
    }

    hr = pd3dtvSrc->LockBox(3, &d3dlb, NULL, 0);
    if (ResultFailed(hr, TEXT("IDirect3DVolumeTexture8::LockBox"))) {
        pd3dtvSrc->Release();
        return TR_ABORT;
    }

    dwData = rand() % 0xFFFFFFFF + 1;
    *(LPDWORD)d3dlb.pBits = dwData;

    hr = pd3dtvSrc->UnlockBox(3);
    if (ResultFailed(hr, TEXT("IDirect3DVolumeTexture8::UnlockBox"))) {
        pd3dtvSrc->Release();
        return TR_ABORT;
    }

    hr = pd3dd->CreateVolumeTexture(32, 256, 64, 4, 0, D3DFMT_R5G6B5, D3DPOOL_MANAGED, &pd3dtvDst);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateTexture"))) {
        pd3dtvSrc->Release();
        return TR_ABORT;
    }

    hr = pd3dd->UpdateTexture(pd3dtvSrc, pd3dtvDst);
    pd3dtvSrc->Release();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::UpdateTexture"))) {
        pd3dtvDst->Release();
        tr = TR_FAIL;
    }
    else {

        hr = pd3dtvDst->LockBox(3, &d3dlb, NULL, 0);
        if (ResultFailed(hr, TEXT("IDirect3DVolumeTexture8::LockBox"))) {
            pd3dtvDst->Release();
            return TR_ABORT;
        }

        if (*(LPDWORD)d3dlb.pBits != dwData) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::UpdateTexture failed to correctly update the destination volumetexture"));
            tr = TR_FAIL;
        }

        hr = pd3dtvDst->UnlockBox(1);
        pd3dtvDst->Release();
        if (ResultFailed(hr, TEXT("IDirect3DVolumeTexture8::UnlockBox"))) {
            return TR_ABORT;
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_ValidateDevice(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwPasses = 0;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->ValidateDevice(&dwPasses);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::ValidateDevice"))) {
        tr = TR_FAIL;
    }
    else {
        if (dwPasses == 0) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::ValidateDevice reported an incorrect number of passes"));
            tr = TR_FAIL;
        }
    }
    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetCurrentTexturePalette(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetCurrentTexturePalette(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    UINT                uPalette, uPaletteGet;
    PALETTEENTRY        ppe[256];
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    uPalette = 100 + rand() % 200;

    hr = pd3dd->SetCurrentTexturePalette(uPalette);
    if (hr != D3DERR_INVALIDCALL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetCurrentTexturePalette returned 0x%X instead of D3DERR_INVALIDCALL on an invalid entry"), hr);
        tr = TR_FAIL;
    }

    hr = pd3dd->SetPaletteEntries(uPalette, ppe);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetPaletteEntries"))) {
        return TR_ABORT;
    }

    hr = pd3dd->SetCurrentTexturePalette(uPalette);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetCurrentTexturePalette"))) {
        tr = TR_FAIL;
    }
    else {

        hr = pd3dd->GetCurrentTexturePalette(&uPaletteGet);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetCurrentTexturePalette"))) {
            tr = TR_FAIL;
        }
        else {
            if (uPalette != uPaletteGet) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetCurrentTexturePalette failed to set the current palette"));
                tr = TR_FAIL;
            }
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetPaletteEntries(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetPaletteEntries(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    PALETTEENTRY        ppeSet[256], ppeGet[256];
    UINT                i, j;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    UINT                uPalette[] = {
                            0,
                            1,
                            16,382,
                            16,383
                        };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 0; i < 4; i++) {

        for (j = 0; j < 256; j++) {
            ppeSet[j].peRed = rand() % 256;
            ppeSet[j].peGreen = rand() % 256;
            ppeSet[j].peBlue = rand() % 256;
            ppeSet[j].peFlags = rand() % 256;
        }
        hr = pd3dd->SetPaletteEntries(uPalette[i], ppeSet);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetPaletteEntries"))) {
            tr = TR_FAIL;
        }
        else {
            hr = pd3dd->GetPaletteEntries(uPalette[i], ppeGet);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetPaletteEntries"))) {
                tr = TR_FAIL;
            }
            else {
                if (memcmp(ppeSet, ppeGet, 256 * sizeof(PALETTEENTRY))) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetPaletteEntries failed to correctly set the entries for palette %d"), i);
                    tr = TR_FAIL;
                }
            }
        }
    }

    for (i = 0; i < 4; i++) {
        hr = pd3dd->SetPaletteEntries(uPalette[i], NULL);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetPaletteEntries using NULL"))) {
            tr = TR_FAIL;
        }
    }

    return tr;
}

#endif // !UNDER_XBOX

#ifndef UNDER_XBOX

#if 0

//******************************************************************************
HRESULT AssembleShader(BOOL bPixel, LPCTSTR szName, LPD3DXBUFFER* ppFunction) {

    LPD3DXBUFFER        pxbufConstants, pxbufShader, pxbufErrors;
    HRSRC               hrsrc;
    HGLOBAL             hg;
    LPBYTE              pData;
    DWORD               dwSize;
    HRESULT             hr;

    hrsrc = FindResource(g_hInstance, szName, RT_RCDATA);
    if (!hrsrc) {
        Log(LOG_ABORT, TEXT("FindResource failed to find the resource %s"), szName);
        return E_FAIL;
    }

    if (!(hg = LoadResource(g_hInstance, hrsrc))) {
        Log(LOG_ABORT, TEXT("LoadResource failed to load the resource %s"), szName);
        return E_FAIL;
    }
    if (!(pData = (LPBYTE)LockResource(hg))) {
        Log(LOG_ABORT, TEXT("LockResource failed to lock the resource %s"), szName);
        return E_FAIL;
    }

    dwSize = SizeofResource(g_hInstance, hrsrc);

    hr = D3DXAssembleShader((LPVOID)pData, dwSize, 0, &pxbufConstants, &pxbufShader, &pxbufErrors);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("D3DXAssembleVertexShader"));
        Log(LOG_ABORT, TEXT("Assembly errors:\n%s"), (LPSTR)pxbufErrors->GetBufferPointer());
        pxbufErrors->Release();
        return hr;
    }

    pxbufConstants->Release();

    *ppFunction = pxbufShader;
    return D3D_OK;
}

#else

//******************************************************************************
HRESULT AssembleShader(LPSTR szShader, LPD3DXBUFFER* ppFunction) {

    LPD3DXBUFFER        pxbufConstants, pxbufShader, pxbufErrors;
    HRESULT             hr;

    hr = D3DXAssembleShader((LPVOID)szShader, strlen(szShader), 0, &pxbufConstants, &pxbufShader, &pxbufErrors);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("D3DXAssembleVertexShader"));
        Log(LOG_ABORT, TEXT("Assembly errors:\n%s"), (LPSTR)pxbufErrors->GetBufferPointer());
        pxbufErrors->Release();
        return hr;
    }

    pxbufConstants->Release();

    *ppFunction = pxbufShader;
    return D3D_OK;
}

#endif

#endif // !UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_CreateVertexShader(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwShader;
#ifndef UNDER_XBOX
    LPD3DXBUFFER        pxbufShader;
#else
    LPXGBUFFER          pxbufShader;
#endif
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    DWORD               dwDeclFixed[] = {
                            D3DVSD_STREAM(0),
                            D3DVSD_REG(D3DVSDE_POSITION, D3DVSDT_FLOAT3),
                            D3DVSD_STREAM(4),
                            D3DVSD_REG(D3DVSDE_NORMAL, D3DVSDT_FLOAT3),
                            D3DVSD_STREAM(7),
                            D3DVSD_REG(D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
                            D3DVSD_END()
                        };
    DWORD               dwDeclProg[] = {
                            D3DVSD_STREAM(0),
                            D3DVSD_REG(D3DVSDE_POSITION, D3DVSDT_FLOAT3),
                            D3DVSD_REG(D3DVSDE_NORMAL, D3DVSDT_FLOAT3),
                            D3DVSD_REG(D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
                            D3DVSD_END()
                        };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // Fixed function shader
    hr = pd3dd->CreateVertexShader(dwDeclFixed, NULL, &dwShader, 0);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexShader for a fixed function shader"))) {
        tr = TR_FAIL;
    }
    else {
        hr = pd3dd->DeleteVertexShader(dwShader);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::DeleteVertexShader"))) {
            tr = TR_FAIL;
        }
    }

    // Programmable shader
#ifndef UNDER_XBOX
    hr = AssembleShader(g_szVertexShader, &pxbufShader);
#else
    hr = AssembleShader("<memory>", g_szVertexShader, strlen(g_szVertexShader), 0, NULL, 
                        &pxbufShader, NULL, NULL, NULL, NULL, NULL);
#endif
    if (ResultFailed(hr, TEXT("AssembleShader"))) {
        return TR_ABORT;
    }
    else {
        hr = pd3dd->CreateVertexShader(dwDeclProg, (LPDWORD)pxbufShader->GetBufferPointer(), &dwShader, 0);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexShader"))) {
            tr = TR_FAIL;
        }
        else {
            hr = pd3dd->DeleteVertexShader(dwShader);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::DeleteVertexShader"))) {
                tr = TR_FAIL;
            }
        }
        pxbufShader->Release();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_DeleteVertexShader(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

#ifdef INVALID_TESTS
    // Attempt to delete a non-existant shader
    hr = pd3dd->DeleteVertexShader(0xFFFFFFFE);
    if (hr != D3DERR_INVALIDCALL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::DeleteVertexShader returned 0x%X instead of D3DERR_INVALIDCALL"), hr);
        tr = TR_FAIL;
    }
#endif // INVALID_TESTS

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetVertexShader(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetVertexShader(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    UINT                i;
    DWORD               dwShaderGet, dwShaderSet;
#ifndef UNDER_XBOX
    LPD3DXBUFFER        pxbufShader;
#else
    LPXGBUFFER          pxbufShader;
#endif
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    DWORD               dwDeclProg[] = {
                            D3DVSD_STREAM(0),
                            D3DVSD_REG(D3DVSDE_POSITION, D3DVSDT_FLOAT3),
                            D3DVSD_REG(D3DVSDE_NORMAL, D3DVSDT_FLOAT3),
                            D3DVSD_REG(D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
                            D3DVSD_END()
                        };
    DWORD               dwFVF[] = {
                            D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX4,
                            D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX2 | D3DFVF_TEXCOORDSIZE3(0) | D3DFVF_TEXCOORDSIZE1(1),
                            D3DFVF_XYZB3 | D3DFVF_DIFFUSE | D3DFVF_SPECULAR,
                            D3DFVF_XYZRHW | D3DFVF_SPECULAR | D3DFVF_TEX1 | D3DFVF_TEXCOORDSIZE4(0),
                            D3DFVF_XYZ | D3DFVF_SPECULAR | D3DFVF_TEX2
                        };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // Fixed-function
    for (i = 0; i < countof(dwFVF); i++) {
        hr = pd3dd->SetVertexShader(dwFVF[i]);
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetVertexShader failed on FVF 0x%X [0x%X]"), dwFVF[i], hr);
            tr = TR_FAIL;
        }
        else {
            hr = pd3dd->GetVertexShader(&dwShaderGet);
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShader failed on FVF 0x%X [0x%X]"), dwFVF[i], hr);
                tr = TR_FAIL;
            }
            else {
                if (dwShaderGet != dwFVF[i]) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetVertexShader failed to correctly set shader 0x%X (GetVertexShader returned 0x%X)"), dwFVF[i], dwShaderGet);
                    tr = TR_FAIL;
                }
            }
        }
    }

    // Programmable
#ifndef UNDER_XBOX
    hr = AssembleShader(g_szVertexShader, &pxbufShader);
#else
    hr = AssembleShader("<memory>", g_szVertexShader, strlen(g_szVertexShader), 0, NULL, 
                        &pxbufShader, NULL, NULL, NULL, NULL, NULL);
#endif
    if (ResultFailed(hr, TEXT("AssembleShader"))) {
        return TR_ABORT;
    }
    else {
        hr = pd3dd->CreateVertexShader(dwDeclProg, (LPDWORD)pxbufShader->GetBufferPointer(), &dwShaderSet, 0);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexShader"))) {
            tr = TR_ABORT;
        }
        else {
            hr = pd3dd->SetVertexShader(dwShaderSet);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetVertexShader"))) {
                tr = TR_FAIL;
            }
            else {
                hr = pd3dd->GetVertexShader(&dwShaderGet);
                if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetVertexShader"))) {
                    tr = TR_FAIL;
                }
                else {
                    if (dwShaderGet != dwShaderSet) {
                        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetVertexShader failed to correctly set programmable shader 0x%X (GetVertexShader returned 0x%X)"), dwShaderSet, dwShaderGet);
                        tr = TR_FAIL;
                    }
                }
            }
            pd3dd->SetVertexShader(D3DFVF_XYZ);
            pd3dd->DeleteVertexShader(dwShaderSet);
        }
        pxbufShader->Release();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetVertexShaderConstant(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

#define VSHADER_CONSTANT_REGISTERS 96

//******************************************************************************
TESTPROCAPI TDEV8_SetVertexShaderConstant(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwRegister;
    DWORD               dwCount;
    float               fConstantSet[VSHADER_CONSTANT_REGISTERS][4];
    float               fConstantGet[VSHADER_CONSTANT_REGISTERS][4];
    UINT                i, j;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // Clear the registers
    for (i = 0; i < VSHADER_CONSTANT_REGISTERS; i++) {
        for (j = 0; j < 4; j++) {
            fConstantSet[i][j] = 0.0f;
        }
    }

    hr = pd3dd->SetVertexShaderConstant(0, fConstantSet, VSHADER_CONSTANT_REGISTERS);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetVertexShaderConstant"))) {
        return TR_FAIL;
    }

    // Set data in some of the registers
    LogBeginVariation(TEXT("IDirect3DDevice8::SetVertexShaderConstant on a subset of registers"));

    dwCount = (rand() % (VSHADER_CONSTANT_REGISTERS / 2 - 1)) + 1;

    for (i = 0; i < dwCount; i++) {
        for (j = 0; j < 4; j++) {
            fConstantSet[i][j] = NRND() * 10000.0f;
        }
    }

    dwRegister = rand() % (VSHADER_CONSTANT_REGISTERS - dwCount);

    hr = pd3dd->SetVertexShaderConstant(dwRegister, fConstantSet, dwCount);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetVertexShaderConstant"))) {
        return TR_FAIL;
    }

    hr = pd3dd->GetVertexShaderConstant(dwRegister, fConstantGet, dwCount);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetVertexShaderConstant"))) {
        return TR_FAIL;
    }

    if (memcmp(fConstantSet, fConstantGet, dwCount * 4 * sizeof(float))) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetVertexShaderConstant failed to correctly set constant data"));
        return TR_FAIL;
    }

    LogEndVariation();

    // Verify registers outside the range were not modified
    LogBeginVariation(TEXT("IDirect3DDevice8::SetVertexShaderConstant not modifying registers outside the given range"));

    hr = pd3dd->GetVertexShaderConstant(0, fConstantGet, VSHADER_CONSTANT_REGISTERS);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetVertexShaderConstant"))) {
        return TR_FAIL;
    }

    for (i = 0; i < dwRegister; i++) {
        for (j = 0; j < 4; j++) {
            if (fConstantGet[i][j] != 0.0f) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetVertexShaderConstant incorrectly modified registers outside the given range"));
                return TR_FAIL;
            }
        }
    }

    for (i = dwRegister + dwCount; i < VSHADER_CONSTANT_REGISTERS; i++) {
        for (j = 0; j < 4; j++) {
            if (fConstantGet[i][j] != 0.0f) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetVertexShaderConstant incorrectly modified registers outside the given range"));
                return TR_FAIL;
            }
        }
    }

    for (i = dwRegister; i < dwCount; i++) {
        for (j = 0; j < 4; j++) {
            if (fConstantGet[i][j] != fConstantSet[i-dwRegister][j]) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetVertexShaderConstant failed to correctly set the constant data"));
                return TR_FAIL;
            }
        }
    }

    LogEndVariation();

    // Set all registers in one call
    LogBeginVariation(TEXT("IDirect3DDevice8::SetVertexShaderConstant on all registers at once"));

    for (i = 0; i < VSHADER_CONSTANT_REGISTERS; i++) {
        for (j = 0; j < 4; j++) {
            fConstantSet[i][j] = NRND() * 10000.0f;
        }
    }

    hr = pd3dd->SetVertexShaderConstant(0, fConstantSet, VSHADER_CONSTANT_REGISTERS);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetVertexShaderConstant"))) {
        return TR_FAIL;
    }

    hr = pd3dd->GetVertexShaderConstant(0, fConstantGet, VSHADER_CONSTANT_REGISTERS);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetVertexShaderConstant"))) {
        return TR_FAIL;
    }

    if (memcmp(fConstantSet, fConstantGet, VSHADER_CONSTANT_REGISTERS * 4 * sizeof(float))) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetVertexShaderConstant failed to correctly set constant data"));
        return TR_FAIL;
    }

    LogEndVariation();

    // Set the registers one array at a time
    LogBeginVariation(TEXT("IDirect3DDevice8::SetVertexShaderConstant one array at a time"));

    for (i = 0; i < VSHADER_CONSTANT_REGISTERS; i++) {
        for (j = 0; j < 4; j++) {
            fConstantSet[i][j] = NRND() * 10000.0f;
        }
    }

    for (i = 0; i < VSHADER_CONSTANT_REGISTERS; i++) {

        hr = pd3dd->SetVertexShaderConstant(i, fConstantSet[i], 1);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetVertexShaderConstant"))) {
            return TR_FAIL;
        }

        hr = pd3dd->GetVertexShaderConstant(i, fConstantGet[i], 1);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetVertexShaderConstant"))) {
            return TR_FAIL;
        }
    }

    if (memcmp(fConstantSet, fConstantGet, VSHADER_CONSTANT_REGISTERS * 4 * sizeof(float))) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetVertexShaderConstant failed to correctly set constant data"));
        return TR_FAIL;
    }

    LogEndVariation();

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetVertexShaderDeclaration(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwShader;
#ifndef UNDER_XBOX
    LPD3DXBUFFER        pxbufShader;
#else
    LPXGBUFFER          pxbufShader;
#endif
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    DWORD               dwSize;
    BYTE                declGet[1024];
    DWORD               dwDeclFixed[] = {
                            D3DVSD_STREAM(0),
                            D3DVSD_REG(D3DVSDE_POSITION, D3DVSDT_FLOAT3),
                            D3DVSD_STREAM(1),
                            D3DVSD_REG(D3DVSDE_NORMAL, D3DVSDT_FLOAT3),
                            D3DVSD_STREAM(2),
                            D3DVSD_REG(D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
                            D3DVSD_END()
                        };
    DWORD               dwDeclProg[] = {
                            D3DVSD_STREAM(0),
                            D3DVSD_REG(D3DVSDE_POSITION, D3DVSDT_FLOAT3),
                            D3DVSD_REG(D3DVSDE_NORMAL, D3DVSDT_FLOAT3),
                            D3DVSD_REG(D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
                            D3DVSD_END()
                        };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // Fixed function shader
    hr = pd3dd->CreateVertexShader(dwDeclFixed, NULL, &dwShader, 0);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexShader for a fixed function shader"))) {
        tr = TR_ABORT;
    }
    else {
        dwSize = 1;
        declGet[0] = 0x5C;
        hr = pd3dd->GetVertexShaderDeclaration(dwShader, declGet, &dwSize);
#ifndef UNDER_XBOX
        if (hr != D3DERR_MOREDATA) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration returned 0x%X instead of D3DERR_MOREDATA for a buffer and too small a size"), hr);
            tr = TR_FAIL;
        }
#endif // !UNDER_XBOX

        if (dwSize != sizeof(dwDeclFixed)) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration returned an incorrect size of %d for the declaration buffer"), dwSize);
            tr = TR_FAIL;
        }

        if (declGet[0] != 0x5C) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration incorrectly modified the declaration buffer when given too small a buffer"));
            tr = TR_FAIL;
        }

        dwSize = 1;
        hr = pd3dd->GetVertexShaderDeclaration(dwShader, NULL, &dwSize);
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration returned 0x%X instead of D3D_OK for a NULL buffer and too small a size"), hr);
            tr = TR_FAIL;
        }

        if (dwSize != sizeof(dwDeclFixed)) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration returned an incorrect size of %d for the declaration buffer"), dwSize);
            tr = TR_FAIL;
        }

        dwSize = 1023;
        hr = pd3dd->GetVertexShaderDeclaration(dwShader, declGet, &dwSize);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration"))) {
            tr = TR_FAIL;
        }

#ifndef UNDER_XBOX
        if (dwSize != 1023) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration incorrectly modified the buffer size for the declaration buffer when given a size greater than the size of the declaration"));
            tr = TR_FAIL;
        }

        if (memcmp(declGet, dwDeclFixed, sizeof(dwDeclFixed))) {
            Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration returned an incorrect declaration for the given fixed function shader"));
            tr = TR_FAIL;
        }
#endif // !UNDER_XBOX

        pd3dd->DeleteVertexShader(dwShader);
    }

    // Programmable shader
#ifndef UNDER_XBOX
    hr = AssembleShader(g_szVertexShader, &pxbufShader);
#else
    hr = AssembleShader("<memory>", g_szVertexShader, strlen(g_szVertexShader), 0, NULL, 
                        &pxbufShader, NULL, NULL, NULL, NULL, NULL);
#endif
    if (ResultFailed(hr, TEXT("AssembleShader"))) {
        return TR_ABORT;
    }
    else {
        hr = pd3dd->CreateVertexShader(dwDeclProg, (LPDWORD)pxbufShader->GetBufferPointer(), &dwShader, 0);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexShader"))) {
            tr = TR_ABORT;
        }
        else {

            dwSize = 1023;
            hr = pd3dd->GetVertexShaderDeclaration(dwShader, declGet, &dwSize);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration"))) {
                tr = TR_FAIL;
            }

#ifndef UNDER_XBOX
            if (dwSize != 1023) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration incorrectly modified the buffer size for the declaration buffer when given a size greater than the size of the declaration"));
                tr = TR_FAIL;
            }

            if (memcmp(declGet, dwDeclProg, sizeof(dwDeclProg))) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderDeclaration returned an incorrect declaration for the given programable shader"));
                tr = TR_FAIL;
            }
#endif // !UNDER_XBOX

            pd3dd->DeleteVertexShader(dwShader);
        }
        pxbufShader->Release();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetVertexShaderFunction(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwShader;
    BYTE                funcGet[8192];
    DWORD               dwSize;
#ifndef UNDER_XBOX
    LPD3DXBUFFER        pxbufShader;
#else
    LPXGBUFFER          pxbufShader;
#endif
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    DWORD               dwDeclProg[] = {
                            D3DVSD_STREAM(0),
                            D3DVSD_REG(D3DVSDE_POSITION, D3DVSDT_FLOAT3),
                            D3DVSD_REG(D3DVSDE_NORMAL, D3DVSDT_FLOAT3),
                            D3DVSD_REG(D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
                            D3DVSD_END()
                        };

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

#ifndef UNDER_XBOX
    hr = AssembleShader(g_szVertexShader, &pxbufShader);
#else
    hr = AssembleShader("<memory>", g_szVertexShader, strlen(g_szVertexShader), 0, NULL, 
                        &pxbufShader, NULL, NULL, NULL, NULL, NULL);
#endif
    if (ResultFailed(hr, TEXT("AssembleShader"))) {
        return TR_ABORT;
    }
    else {
        hr = pd3dd->CreateVertexShader(dwDeclProg, (LPDWORD)pxbufShader->GetBufferPointer(), &dwShader, 0);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexShader"))) {
            tr = TR_ABORT;
        }
        else {

            dwSize = 1;
            funcGet[0] = 0xF1;
            hr = pd3dd->GetVertexShaderFunction(dwShader, funcGet, &dwSize);
#ifndef UNDER_XBOX
            if (hr != D3DERR_MOREDATA) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderFunction returned 0x%X instead of D3DERR_MOREDATA for a buffer and too small a size"), hr);
                tr = TR_FAIL;
            }
#endif // !UNDER_XBOX

            if (dwSize != pxbufShader->GetBufferSize()) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderFunction returned an incorrect size of %d for the function buffer"), dwSize);
                tr = TR_FAIL;
            }

            if (funcGet[0] != 0xF1) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderFunction incorrectly modified the function buffer when given too small a buffer"));
                tr = TR_FAIL;
            }

            dwSize = 1;
            hr = pd3dd->GetVertexShaderFunction(dwShader, NULL, &dwSize);
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderFunction returned 0x%X instead of D3D_OK for a NULL buffer and too small a size"), hr);
                tr = TR_FAIL;
            }

            if (dwSize != pxbufShader->GetBufferSize()) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderFunction returned an incorrect size of %d for the function buffer"), dwSize);
                tr = TR_FAIL;
            }

            dwSize = 8189;
            hr = pd3dd->GetVertexShaderFunction(dwShader, funcGet, &dwSize);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetVertexShaderFunction"))) {
                tr = TR_FAIL;
            }

#ifndef UNDER_XBOX
            if (dwSize != 8189) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderFunction incorrectly modified the buffer size for the function buffer when given a size greater than the size of the function"));
                tr = TR_FAIL;
            }

            if (memcmp(funcGet, pxbufShader->GetBufferPointer(), pxbufShader->GetBufferSize())) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetVertexShaderFunction returned an incorrect function for the given programmable shader"));
                tr = TR_FAIL;
            }
#endif // !UNDER_XBOX

            pd3dd->DeleteVertexShader(dwShader);
        }
        pxbufShader->Release();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CreatePixelShader(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwShader;
#ifndef UNDER_XBOX
    LPD3DXBUFFER        pxbufShader;
#else
    LPXGBUFFER          pxbufShader;
#endif // UNDER_XBOX
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

#ifndef UNDER_XBOX
    hr = AssembleShader(g_szPixelShader, &pxbufShader);
#else
    hr = AssembleShader("<memory>", g_szPixelShader, strlen(g_szPixelShader), 0, NULL, 
                        &pxbufShader, NULL, NULL, NULL, NULL, NULL);
#endif // UNDER_XBOX
    if (ResultFailed(hr, TEXT("AssembleShader"))) {
        return TR_ABORT;
    }
    else {
#ifndef UNDER_XBOX
        hr = pd3dd->CreatePixelShader((LPDWORD)pxbufShader->GetBufferPointer(), &dwShader);
#else
        hr = pd3dd->CreatePixelShader((D3DPIXELSHADERDEF*)pxbufShader->GetBufferPointer(), &dwShader);
#endif // UNDER_XBOX
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreatePixelShader"))) {
            tr = TR_FAIL;
        }
        else {
            hr = pd3dd->DeletePixelShader(dwShader);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::DeletePixelShader"))) {
                tr = TR_FAIL;
            }
        }
        pxbufShader->Release();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_DeletePixelShader(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

#ifdef INVALID_TESTS
    // Attempt to delete a non-existant shader
    hr = pd3dd->DeletePixelShader(0xFFFFFFFE);
    if (hr != D3DERR_INVALIDCALL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::DeletePixelShader returned 0x%X instead of D3DERR_INVALIDCALL"), hr);
        tr = TR_FAIL;
    }
#endif // INVALID_TESTS

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetPixelShader(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetPixelShader(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwShaderSet, dwShaderGet;
#ifndef UNDER_XBOX
    LPD3DXBUFFER        pxbufShader;
#else
    LPXGBUFFER          pxbufShader;
#endif // UNDER_XBOX
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // Programmable shader
#ifndef UNDER_XBOX
    hr = AssembleShader(g_szPixelShader, &pxbufShader);
#else
    hr = AssembleShader("<memory>", g_szPixelShader, strlen(g_szPixelShader), 0, NULL, 
                        &pxbufShader, NULL, NULL, NULL, NULL, NULL);
#endif // UNDER_XBOX
    if (ResultFailed(hr, TEXT("AssembleShader"))) {
        return TR_ABORT;
    }
    else {
#ifndef UNDER_XBOX
        hr = pd3dd->CreatePixelShader((LPDWORD)pxbufShader->GetBufferPointer(), &dwShaderSet);
#else
        hr = pd3dd->CreatePixelShader((D3DPIXELSHADERDEF*)pxbufShader->GetBufferPointer(), &dwShaderSet);
#endif // UNDER_XBOX
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreatePixelShader"))) {
            tr = TR_ABORT;
        }
        else {
            hr = pd3dd->SetPixelShader(dwShaderSet);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetPixelShader"))) {
                tr = TR_FAIL;
            }
            else {
                hr = pd3dd->GetPixelShader(&dwShaderGet);
                if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetPixelShader"))) {
                    tr = TR_FAIL;
                }
                else {
                    if (dwShaderGet != dwShaderSet) {
                        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetPixelShader failed to set shader 0x%X (GetPixelShader returned 0x%X)"), dwShaderSet, dwShaderGet);
                        tr = TR_FAIL;
                    }
                }
            }

            pd3dd->SetPixelShader(NULL);
            pd3dd->DeletePixelShader(dwShaderSet);
        }
        pxbufShader->Release();
    }

    // Fixed-function shader
    hr = pd3dd->SetPixelShader(NULL);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetPixelShader"))) {
        tr = TR_FAIL;
    }
    else {
        hr = pd3dd->GetPixelShader(&dwShaderGet);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetPixelShader"))) {
            tr = TR_FAIL;
        }
        else {
            if (dwShaderGet != NULL) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetPixelShader failed to set the fixed-function shader (GetPixelShader returned 0x%X)"), dwShaderGet);
                tr = TR_FAIL;
            }
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetPixelShaderConstant(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

#define PSHADER_CONSTANT_REGISTERS 8

//******************************************************************************
TESTPROCAPI TDEV8_SetPixelShaderConstant(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwRegister;
    DWORD               dwCount;
    float               fConstantSet[PSHADER_CONSTANT_REGISTERS][4];
    float               fConstantGet[PSHADER_CONSTANT_REGISTERS][4];
    UINT                i, j;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
#ifdef UNDER_XBOX
    DWORD               dwShader;
    LPXGBUFFER          pxbufShader;
#endif

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

#ifdef UNDER_XBOX
    hr = AssembleShader("<memory>", g_szPixelShader, strlen(g_szPixelShader), 0, NULL, 
                        &pxbufShader, NULL, NULL, NULL, NULL, NULL);
    if (ResultFailed(hr, TEXT("AssembleShader"))) {
        return TR_ABORT;
    }

    hr = pd3dd->CreatePixelShader((D3DPIXELSHADERDEF*)pxbufShader->GetBufferPointer(), &dwShader);
    pxbufShader->Release();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreatePixelShader"))) {
        return TR_ABORT;
    }

    hr = pd3dd->SetPixelShader(dwShader);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetPixelShader"))) {
        pd3dd->DeletePixelShader(dwShader);
        return TR_ABORT;
    }
#endif // UNDER_XBOX

    // Clear the registers
    for (i = 0; i < PSHADER_CONSTANT_REGISTERS; i++) {
        for (j = 0; j < 4; j++) {
            fConstantSet[i][j] = 0.0f;
        }
    }

    hr = pd3dd->SetPixelShaderConstant(0, fConstantSet, PSHADER_CONSTANT_REGISTERS);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetPixelShaderConstant"))) {
        tr = TR_FAIL;
        goto exit;
    }

    // Set data in some of the registers
    LogBeginVariation(TEXT("IDirect3DDevice8::SetPixelShaderConstant on a subset of registers"));

    dwCount = rand() % (PSHADER_CONSTANT_REGISTERS / 2);

    for (i = 0; i < dwCount; i++) {
        for (j = 0; j < 4; j++) {
            fConstantSet[i][j] = (float)(rand() % 256) / 255.0f;
        }
    }

    dwRegister = rand() % (PSHADER_CONSTANT_REGISTERS - dwCount);

    hr = pd3dd->SetPixelShaderConstant(dwRegister, fConstantSet, dwCount);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetPixelShaderConstant"))) {
        tr = TR_FAIL;
        goto exit;
    }

    hr = pd3dd->GetPixelShaderConstant(dwRegister, fConstantGet, dwCount);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetPixelShaderConstant"))) {
        tr = TR_FAIL;
        goto exit;
    }

    if (memcmp(fConstantSet, fConstantGet, dwCount * 4 * sizeof(float))) {
        D3DXVECTOR4 *pvSet, *pvGet;
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetPixelShaderConstant failed to correctly set constant data"));
        for (i = 0, pvSet = (D3DXVECTOR4*)fConstantSet[0], pvGet = (D3DXVECTOR4*)fConstantGet[0]; i < dwCount; i++, pvSet++, pvGet++) {
            Log(LOG_COMMENT, TEXT("Register %d: Set <%3.3f, %3.3f, %3.3f, %3.3f>, Get <%3.3f, %3.3f, %3.3f, %3.3f>"), dwRegister + i, pvSet->x, pvSet->y, pvSet->z, pvSet->w, pvGet->x, pvGet->y, pvGet->z, pvGet->w);
        }
        tr = TR_FAIL;
        goto exit;
    }

    LogEndVariation();

    // Verify registers outside the range were not modified
    LogBeginVariation(TEXT("IDirect3DDevice8::SetPixelShaderConstant not modifying registers outside the given range"));

    hr = pd3dd->GetPixelShaderConstant(0, fConstantGet, PSHADER_CONSTANT_REGISTERS);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetPixelShaderConstant"))) {
        tr = TR_FAIL;
        goto exit;
    }

    for (i = 0; i < dwRegister; i++) {
        for (j = 0; j < 4; j++) {
            if (fConstantGet[i][j] != 0.0f) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetPixelShaderConstant incorrectly modified registers outside the given range"));
                tr = TR_FAIL;
                goto exit;
            }
        }
    }

    for (i = dwRegister + dwCount; i < PSHADER_CONSTANT_REGISTERS; i++) {
        for (j = 0; j < 4; j++) {
            if (fConstantGet[i][j] != 0.0f) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetPixelShaderConstant incorrectly modified registers outside the given range"));
                tr = TR_FAIL;
                goto exit;
            }
        }
    }

    for (i = dwRegister; i < dwCount; i++) {
        for (j = 0; j < 4; j++) {
            if (fConstantGet[i][j] != fConstantSet[i-dwRegister][j]) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetPixelShaderConstant failed to correctly set the constant data"));
                tr = TR_FAIL;
                goto exit;
            }
        }
    }

    LogEndVariation();

    // Set all registers in one call
    LogBeginVariation(TEXT("IDirect3DDevice8::SetPixelShaderConstant on all registers at once"));

    for (i = 0; i < PSHADER_CONSTANT_REGISTERS; i++) {
        for (j = 0; j < 4; j++) {
            fConstantSet[i][j] = (float)(rand() % 256) / 255.0f;
        }
    }

    hr = pd3dd->SetPixelShaderConstant(0, fConstantSet, PSHADER_CONSTANT_REGISTERS);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetPixelShaderConstant"))) {
        tr = TR_FAIL;
        goto exit;
    }

    hr = pd3dd->GetPixelShaderConstant(0, fConstantGet, PSHADER_CONSTANT_REGISTERS);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetPixelShaderConstant"))) {
        tr = TR_FAIL;
        goto exit;
    }

    if (memcmp(fConstantSet, fConstantGet, PSHADER_CONSTANT_REGISTERS * 4 * sizeof(float))) {
        D3DXVECTOR4 *pvSet, *pvGet;
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetPixelShaderConstant failed to correctly set constant data"));
        for (i = 0, pvSet = (D3DXVECTOR4*)fConstantSet[0], pvGet = (D3DXVECTOR4*)fConstantGet[0]; i < PSHADER_CONSTANT_REGISTERS; i++, pvSet++, pvGet++) {
            Log(LOG_COMMENT, TEXT("Register %d: Set <%3.3f, %3.3f, %3.3f, %3.3f>, Get <%3.3f, %3.3f, %3.3f, %3.3f>"), i, pvSet->x, pvSet->y, pvSet->z, pvSet->w, pvGet->x, pvGet->y, pvGet->z, pvGet->w);
        }
        tr = TR_FAIL;
        goto exit;
    }

    LogEndVariation();

    // Set the registers one array at a time
    LogBeginVariation(TEXT("IDirect3DDevice8::SetPixelShaderConstant one array at a time"));

    for (i = 0; i < PSHADER_CONSTANT_REGISTERS; i++) {
        for (j = 0; j < 4; j++) {
            fConstantSet[i][j] = (float)(rand() % 256) / 255.0f;
        }
    }

    for (i = 0; i < PSHADER_CONSTANT_REGISTERS; i++) {

        hr = pd3dd->SetPixelShaderConstant(i, fConstantSet[i], 1);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetPixelShaderConstant"))) {
            tr = TR_FAIL;
            goto exit;
        }

        hr = pd3dd->GetPixelShaderConstant(i, fConstantGet[i], 1);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetPixelShaderConstant"))) {
            tr = TR_FAIL;
            goto exit;
        }
    }

    if (memcmp(fConstantSet, fConstantGet, PSHADER_CONSTANT_REGISTERS * 4 * sizeof(float))) {
        D3DXVECTOR4 *pvSet, *pvGet;
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::SetPixelShaderConstant failed to correctly set constant data"));
        for (i = 0, pvSet = (D3DXVECTOR4*)fConstantSet[0], pvGet = (D3DXVECTOR4*)fConstantGet[0]; i < PSHADER_CONSTANT_REGISTERS; i++, pvSet++, pvGet++) {
            Log(LOG_COMMENT, TEXT("Register %d: Set <%3.3f, %3.3f, %3.3f, %3.3f>, Get <%3.3f, %3.3f, %3.3f, %3.3f>"), i, pvSet->x, pvSet->y, pvSet->z, pvSet->w, pvGet->x, pvGet->y, pvGet->z, pvGet->w);
        }
        tr = TR_FAIL;
        goto exit;
    }

    LogEndVariation();

exit:

#ifdef UNDER_XBOX
    pd3dd->SetPixelShader(NULL);
    pd3dd->DeletePixelShader(dwShader);
#endif

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetPixelShaderFunction(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    DWORD               dwShader;
    BYTE                funcGet[8192];
    DWORD               dwSize;
#ifndef UNDER_XBOX
    LPD3DXBUFFER        pxbufShader;
#else
    LPXGBUFFER          pxbufShader;
#endif // UNDER_XBOX
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

#ifndef UNDER_XBOX
    hr = AssembleShader(g_szPixelShader, &pxbufShader);
#else
    hr = AssembleShader("<memory>", g_szPixelShader, strlen(g_szPixelShader), 0, NULL, 
                        &pxbufShader, NULL, NULL, NULL, NULL, NULL);
#endif // UNDER_XBOX
    if (ResultFailed(hr, TEXT("AssembleShader"))) {
        return TR_ABORT;
    }
    else {
#ifndef UNDER_XBOX
        hr = pd3dd->CreatePixelShader((LPDWORD)pxbufShader->GetBufferPointer(), &dwShader);
#else
        hr = pd3dd->CreatePixelShader((D3DPIXELSHADERDEF*)pxbufShader->GetBufferPointer(), &dwShader);
#endif // UNDER_XBOX
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreatePixelShader"))) {
            tr = TR_ABORT;
        }
        else {

#ifndef UNDER_XBOX

            dwSize = 1;
            funcGet[0] = 0x6E;
            hr = pd3dd->GetPixelShaderFunction(dwShader, funcGet, &dwSize);
            if (hr != D3DERR_MOREDATA) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetPixelShaderFunction returned 0x%X instead of D3DERR_MOREDATA for a buffer and too small a size"), hr);
                tr = TR_FAIL;
            }

            if (dwSize != pxbufShader->GetBufferSize()) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetPixelShaderFunction returned an incorrect size of %d for the function buffer"), dwSize);
                tr = TR_FAIL;
            }

            if (funcGet[0] != 0x6E) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetPixelShaderFunction incorrectly modified the function buffer when given too small a buffer"));
                tr = TR_FAIL;
            }

            dwSize = 1;
            hr = pd3dd->GetPixelShaderFunction(dwShader, NULL, &dwSize);
            if (FAILED(hr)) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetPixelShaderFunction returned 0x%X instead of D3D_OK for a NULL buffer and too small a size"), hr);
                tr = TR_FAIL;
            }

            if (dwSize != pxbufShader->GetBufferSize()) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetPixelShaderFunction returned an incorrect size of %d for the function buffer"), dwSize);
                tr = TR_FAIL;
            }

            dwSize = 8189;
            hr = pd3dd->GetPixelShaderFunction(dwShader, funcGet, &dwSize);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetPixelShaderFunction"))) {
                tr = TR_FAIL;
            }

            if (dwSize != 8189) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetPixelShaderFunction incorrectly modified the buffer size for the function buffer when given a size greater than the size of the function"));
                tr = TR_FAIL;
            }

            if (memcmp(funcGet, pxbufShader->GetBufferPointer(), pxbufShader->GetBufferSize())) {
                Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetPixelShaderFunction returned an incorrect function for the given programmable shader"));
                tr = TR_FAIL;
            }

#else
            D3DPIXELSHADERDEF d3dpsd;

            hr = pd3dd->GetPixelShaderFunction(dwShader, &d3dpsd);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetPixelShaderFunction"))) {
                tr = TR_FAIL;
            }
            else {
                if (memcmp(&d3dpsd, pxbufShader->GetBufferPointer(), pxbufShader->GetBufferSize())) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetPixelShaderFunction returned an incorrect definition for the given programmable shader"));
                    tr = TR_FAIL;
                }
            }
#endif

            pd3dd->DeletePixelShader(dwShader);
        }
        pxbufShader->Release();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_Present(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // ##TODO: If the copy and copyvsync swap effects are supported, test the
    // presentation of subrects and dirty regions

    hr = pd3dd->Present(NULL, NULL, NULL, NULL);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::Present"))) {
        return TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_Reset(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    D3DPRESENT_PARAMETERS   d3dpp;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    // ##REVIEW: Will calling Reset cause UMA resources to be lost on XBox?

    // Initialize the presentation parameters
    memset(&d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth                   = TARGET_WIDTH;
    d3dpp.BackBufferHeight                  = TARGET_HEIGHT;
    d3dpp.BackBufferFormat                  = D3DFMT_X8R8G8B8;
#ifndef UNDER_XBOX
    d3dpp.MultiSampleType                   = D3DMULTISAMPLE_4_SAMPLES;
#else
    d3dpp.MultiSampleType                   = D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR;
#endif
    d3dpp.AutoDepthStencilFormat            = D3DFMT_D24S8;
    d3dpp.FullScreen_RefreshRateInHz        = 0;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                     = g_hWnd;
    d3dpp.Windowed                          = FALSE;
    d3dpp.EnableAutoDepthStencil            = TRUE;

    hr = pd3dd->Reset(&d3dpp);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::Reset"))) {
        return TR_FAIL;
    }

    // Initialize the presentation parameters
    memset(&d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth                   = TARGET_WIDTH;
    d3dpp.BackBufferHeight                  = TARGET_HEIGHT;
    d3dpp.BackBufferFormat                  = D3DFMT_R5G6B5;
    d3dpp.MultiSampleType                   = D3DMULTISAMPLE_NONE;
    d3dpp.AutoDepthStencilFormat            = D3DFMT_D16;
    d3dpp.FullScreen_RefreshRateInHz        = 0;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                     = g_hWnd;
    d3dpp.Windowed                          = TRUE;
// ##HACK
//    d3dpp.EnableAutoDepthStencil            = TRUE;
    d3dpp.EnableAutoDepthStencil            = FALSE;

    hr = pd3dd->Reset(&d3dpp);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::Reset"))) {
        return TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_BeginScene(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->BeginScene();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::BeginScene"))) {
        return TR_FAIL;
    }

    hr = pd3dd->BeginScene();
#ifndef UNDER_XBOX
    if (hr != D3DERR_INVALIDCALL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::BeginScene returned 0x%X instead of D3DERR_INVALIDCALL when already in a scene"));
        tr = TR_FAIL;
    }
#endif

    pd3dd->EndScene();

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_EndScene(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    pd3dd->BeginScene();

    hr = pd3dd->EndScene();
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::EndScene"))) {
        return TR_FAIL;
    }

    hr = pd3dd->EndScene();
#ifndef UNDER_XBOX
    if (hr != D3DERR_INVALIDCALL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::EndScene returned 0x%X instead of D3DERR_INVALIDCALL when not in a scene"));
        tr = TR_FAIL;
    }
#endif

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_DrawIndexedPrimitive(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_DrawIndexedPrimitiveUP(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_DrawPrimitive(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_DrawPrimitiveUP(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_DeleteSurfaceHandle(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_DrawRectSurface(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_DrawTriSurface(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetStreamSource(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetStreamSource(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DVERTEXBUFFER8 pd3dr[8], pd3drGet;
    UINT                    uStrideGet;
    ULONG                   uRef1, uRef2;
    UINT                    i, j;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;
    DWORD                   dwFVF[] = {
                                D3DFVF_NORMAL,
                                D3DFVF_DIFFUSE,
                                D3DFVF_TEXCOORDSIZE1(1),
                                D3DFVF_XYZ,
                                D3DFVF_TEXCOORDSIZE4(3),
                                D3DFVF_SPECULAR,
                                D3DFVF_TEXCOORDSIZE2(2),
                                D3DFVF_TEXCOORDSIZE3(0),
                            };
    DWORD                   dwVSize[] = {
                                sizeof(D3DVECTOR),
                                sizeof(D3DCOLOR),
                                sizeof(float),
                                sizeof(D3DVECTOR),
                                4 * sizeof(float),
                                sizeof(D3DCOLOR),
                                2 * sizeof(float),
                                3 * sizeof(float)
                            };

/*
    DWORD                   dwFVF[] = {
                                D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX4,
                                D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEXCOORDSIZE3(0) | D3DFVF_TEXCOORDSIZE1(1),
                                D3DFVF_XYZB3 | D3DFVF_DIFFUSE | D3DFVF_SPECULAR,
                                D3DFVF_XYZRHW | D3DFVF_SPECULAR | D3DFVF_TEXCOORDSIZE4(0),
                                D3DFVF_XYZ | D3DFVF_PSIZE | D3DFVF_SPECULAR | D3DFVF_TEX2,

                            };
    DWORD                   dwVSize[] = {
                                2 * sizeof(D3DVECTOR) + 8 * sizeof(float),
                                sizeof(D3DVECTOR) + sizeof(D3DCOLOR) + 4 * sizeof(float),
                                sizeof(D3DVECTOR) + 3 * sizeof(float) + 2 * sizeof(D3DCOLOR),
                                sizeof(D3DVECTOR) + sizeof(float) + sizeof(D3DCOLOR) + 4 * sizeof(float),
                                sizeof(D3DVECTOR) + sizeof(float) + sizeof(D3DCOLOR) + 
*/

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    for (i = 0; i < 8; i++) {
        hr = pd3dd->CreateVertexBuffer(dwVSize[i] * 912, 0, dwFVF[i], D3DPOOL_MANAGED, &pd3dr[i]);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexBuffer"))) {
            for (j = 0; j < i; j++) pd3dr[j]->Release();
            return TR_ABORT;
        }
    }

    for (i = 0; i < 8; i++) {
        hr = pd3dd->SetStreamSource(i, pd3dr[i], dwVSize[i]);
        if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetStreamSource"))) {
            tr = TR_FAIL;
        }
    }

    if (tr == TR_PASS) {
        for (i = 0; i < 8; i++) {
            pd3dr[i]->AddRef();
            uRef1 = pd3dr[i]->Release();
            hr = pd3dd->GetStreamSource(i, &pd3drGet, &uStrideGet);
            if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetStreamSource"))) {
                tr = TR_FAIL;
            }
            else {
                if (pd3drGet != pd3dr[i]) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetStreamSource returned an incorrect vertex buffer pointer for stream %d"), i);
                    tr = TR_FAIL;
                }
                if (uStrideGet != dwVSize[i]) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetStreamSource returned an incorrect stride for stream %d"), i);
                    tr = TR_FAIL;
                }
                pd3dr[i]->AddRef();
                uRef2 = pd3dr[i]->Release();
                if (uRef2 != uRef1 + 1) {
                    Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetStreamSource failed to increment the reference count on the returned vertex buffer in stream %d"), i);
                    tr = TR_FAIL;
                }
                else {
                    pd3drGet->Release();
                }
            }
        }
    }

    for (i = 0; i < 8; i++) {
        pd3dr[i]->Release();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetIndices(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetIndices(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8       pd3dd;
    LPDIRECT3DINDEXBUFFER8  pd3diSet, pd3diGet;
    UINT                    uBase;
    ULONG                   uRef1, uRef2;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3dd = GetDevice8();
    pd3diSet = GetIndexBuffer8();
    if (!pd3dd || !pd3diSet) {
        return TR_ABORT;
    }

    hr = pd3dd->SetIndices(pd3diSet, 7);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::SetIndices"))) {
        return TR_FAIL;
    }

    pd3diSet->AddRef();
    uRef1 = pd3diSet->Release();

    hr = pd3dd->GetIndices(&pd3diGet, &uBase);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetIndices"))) {
        return TR_FAIL;
    }

    if (pd3diGet != pd3diSet) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetIndices returned an incorrect index buffer pointer"));
        tr = TR_FAIL;
    }
    if (uBase != 7) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetIndices returned an incorrect base index"));
        tr = TR_FAIL;
    }
    pd3diSet->AddRef();
    uRef2 = pd3diSet->Release();
    if (uRef2 != uRef1 + 1) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetIndices failed to increment the reference count on the returned index buffer"));
        tr = TR_FAIL;
    }
    else {
        pd3diGet->Release();
    }

    return tr;
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_GetAvailableTextureMem(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    UINT                uAvailable;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    uAvailable = pd3dd->GetAvailableTextureMem();

    Log(LOG_COMMENT, TEXT("IDirect3DDevice8::GetAvailableTextureMem reported %d bytes of available texture memory"));

    return tr;
}

#endif // !UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_GetCreationParameters(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8               pd3dd;
    D3DDEVICE_CREATION_PARAMETERS   d3ddcp;
    HRESULT                         hr;
    TRESULT                         tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->GetCreationParameters(&d3ddcp);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetCreationParameters"))) {
        return TR_FAIL;
    }

    if (d3ddcp.AdapterOrdinal != 0 ||
        d3ddcp.DeviceType != D3DDEVTYPE_HAL ||
        d3ddcp.BehaviorFlags != D3DCREATE_HARDWARE_VERTEXPROCESSING ||
        d3ddcp.hFocusWindow != g_hWnd) 
    {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetCreationParameters"));
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetDeviceCaps(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    D3DCAPS8            d3dcaps;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->GetDeviceCaps(&d3dcaps);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetDeviceCaps"))) {
        return TR_FAIL;
    }

    // ##TODO: Verify the device caps

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetDirect3D(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    LPDIRECT3D8         pd3d, pd3dGet;
    ULONG               uRef1, uRef2;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    pd3d = GetDeviceDirect3D8();
    if (!pd3dd || !pd3d) {
        return TR_ABORT;
    }

    pd3d->AddRef();
    uRef1 = pd3d->Release();

    hr = pd3dd->GetDirect3D(&pd3dGet);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetDirect3D"))) {
        return TR_FAIL;
    }

    if (pd3dGet != pd3d) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetDirect3D returned the incorrect interface pointer"));
        tr = TR_FAIL;
    }

    pd3d->AddRef();
    uRef2 = pd3d->Release();
#ifndef UNDER_XBOX
    if (uRef2 != uRef1 + 1) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetDirect3D failed to increment the reference count on the Direct3D object"));
        tr = TR_FAIL;
    }
    else {
#endif
        pd3dGet->Release();
#ifndef UNDER_XBOX
    }
#endif

    return tr;
}

#ifndef UNDER_XBOX
//******************************************************************************
TESTPROCAPI TDEV8_GetInfo(PTESTTABLEENTRY ptte) {

#if 0
    LPDIRECT3DDEVICE8               pd3dd;
    D3DDEVINFO_TEXTUREMANAGER       d3dinfoD3DTexMan;
    D3DDEVINFO_TEXTUREMANAGER       d3dinfoTexMan;
    D3DDEVINFO_TEXTURING            d3dinfoTex;
    HRESULT                         hr;
    TRESULT                         tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->GetInfo(D3DDEVINFOID_D3DTEXTUREMANAGER, &d3dinfoD3DTexMan, sizeof(d3dinfoD3DTexMan));
    if (hr != E_NOTIMPL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetInfo returned 0x%X instead of E_NOTIMPL"), hr);
        tr = TR_FAIL;
    }

    hr = pd3dd->GetInfo(D3DDEVINFOID_TEXTUREMANAGER, &d3dinfoTexMan, sizeof(d3dinfoTexMan));
    if (hr != E_NOTIMPL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetInfo returned 0x%X instead of E_NOTIMPL"), hr);
        tr = TR_FAIL;
    }

    hr = pd3dd->GetInfo(D3DDEVINFOID_TEXTURING, &d3dinfoTex, sizeof(d3dinfoTex));
    if (hr != E_NOTIMPL) {
        Log(LOG_FAIL, TEXT("IDirect3DDevice8::GetInfo returned 0x%X instead of E_NOTIMPL"), hr);
        tr = TR_FAIL;
    }

    return tr;

#else
    return TR_FAIL; // Since D3DDEVINFO_TEXTUREMANAGER struct is currently #defined out of DX8
#endif
}
#endif // !UNDER_XBOX

//******************************************************************************
TESTPROCAPI TDEV8_GetRasterStatus(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    D3DRASTER_STATUS    d3drs;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    hr = pd3dd->GetRasterStatus(&d3drs);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetRasterStatus"))) {
        return TR_FAIL;
    }

    Log(LOG_COMMENT, TEXT("IDirect3DDevice8::GetRasterStatus reported the raster status as %s the vblank (scan line %d)"), d3drs.InVBlank ? TEXT("in") : TEXT("not in"), d3drs.ScanLine);

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetBackBuffer(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetDepthStencilSurface(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetGammaRamp(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetGammaRamp(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_CopyRects(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_GetFrontBufferRectangle(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_ProcessVertices(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_ResourceManagerDiscardBytes(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_TestCooperativeLevel(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetCursorPosition(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_SetCursorProperties(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TDEV8_ShowCursor(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    return tr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\indxbuf8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    indxbuf8.cpp

Description:

    IDirect3DIndexBuffer8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IDirect3DIndexBuffer8 inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TIXB8_GetDesc(PTESTTABLEENTRY ptte) {

    LPDIRECT3DINDEXBUFFER8  pd3di;
    D3DINDEXBUFFER_DESC     d3did;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3di = GetIndexBuffer8();
    if (!pd3di) {
        return TR_ABORT;
    }

    hr = pd3di->GetDesc(&d3did);
    if (ResultFailed(hr, TEXT("IDirect3DIndexBuffer8::GetDesc"))) {
        return TR_FAIL;
    }

#ifndef UNDER_XBOX

    if (d3did.Size != INDXBUFFSIZE) {
        Log(LOG_FAIL, TEXT("IDirect3DIndexBuffer8::GetDesc returned an incorrect buffer size"));
        tr = TR_FAIL;
    }

    if (d3did.Pool != D3DPOOL_MANAGED) {
        Log(LOG_FAIL, TEXT("IDirect3DIndexBuffer8::GetDesc returned an incorrect buffer pool"));
        tr = TR_FAIL;
    }

    if (d3did.Usage != 0) {
        Log(LOG_FAIL, TEXT("IDirect3DIndexBuffer8::GetDesc returned an incorrect buffer usage"));
        tr = TR_FAIL;
    }

#endif

    if (d3did.Type != D3DRTYPE_INDEXBUFFER) {
        Log(LOG_FAIL, TEXT("IDirect3DIndexBuffer8::GetDesc returned an incorrect buffer type"));
        tr = TR_FAIL;
    }

    if (d3did.Format != D3DFMT_INDEX16) {
        Log(LOG_FAIL, TEXT("IDirect3DIndexBuffer8::GetDesc returned an incorrect buffer format"));
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TIXB8_Lock(PTESTTABLEENTRY ptte) {

    LPDIRECT3DINDEXBUFFER8  pd3di;

    pd3di = GetIndexBuffer8();
    if (!pd3di) {
        return TR_ABORT;
    }

    return TSHR8_Lock(ptte, (LPVOID)pd3di);
}

//******************************************************************************
TESTPROCAPI TIXB8_Unlock(PTESTTABLEENTRY ptte) {

    LPDIRECT3DINDEXBUFFER8  pd3di;

    pd3di = GetIndexBuffer8();
    if (!pd3di) {
        return TR_ABORT;
    }

    return TSHR8_Unlock(ptte, (LPVOID)pd3di);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\sources.inc ===
!include ..\..\sources.inc

TARGETNAME=l_d3dbvt
TARGETTYPE=LIBRARY
TARGETPATH=$(TEST_LIB_DEST)

SOURCES=\
    basetex8.cpp \
    cubetex8.cpp \
    d3d8.cpp \
    d3dbvt.cpp \
    device8.cpp \
    indxbuf8.cpp \
    log.cpp \
    rsource8.cpp \
    surface8.cpp \
    swapchn8.cpp \
    texture8.cpp \
    unknown.cpp \
    util.cpp \
    vertbuf8.cpp \
    voltex8.cpp \
    volume8.cpp \
    d3dbvt.rc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\unknown.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    unknown.cpp

Description:

    IUnknown interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IUnknown helper functions
//******************************************************************************

#ifndef UNDER_XBOX

//******************************************************************************
IUnknown* GetUnknown(D3DIFACETYPE d3dift) {

    IUnknown* punk = NULL;

    switch (d3dift) {

        case IDIRECT3D8:
            punk = (IUnknown*)GetDirect3D8();
            break;
        case IDEVICE8:
            punk = (IUnknown*)GetDevice8();
            break;
        case ISWAPCHAIN8:
            punk = (IUnknown*)GetSwapChain8();
            break;
        case ITEXTURE8:
            punk = (IUnknown*)GetTexture8();
            break;
        case ICUBETEXTURE8:
            punk = (IUnknown*)GetCubeTexture8();
            break;
        case IVOLUMETEXTURE8:
            punk = (IUnknown*)GetVolumeTexture8();
            break;
        case IVERTEXBUFFER8:
            punk = (IUnknown*)GetVertexBuffer8();
            break;
        case IINDEXBUFFER8:
            punk = (IUnknown*)GetIndexBuffer8();
            break;
        case ISURFACE8:
            punk = (IUnknown*)GetSurface8();
            break;
        case IVOLUME8:
            punk = (IUnknown*)GetVolume8();
            break;
    }

    return punk;
}

#endif // !UNDER_XBOX

//******************************************************************************
// IUnknown inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TUNK_AddRef(PTESTTABLEENTRY ptte) {

    IUnknown*   punk;
    ULONG       uRef1, uRef2;
    TRESULT     tr = TR_PASS;

#ifndef UNDER_XBOX

    punk = GetUnknown(ptte->dwData);
    if (!punk) {
        return TR_ABORT;
    }

    uRef1 = punk->AddRef();
    uRef2 = punk->AddRef();

    if (uRef2 != uRef1 + 1) {
        Log(LOG_FAIL, TEXT("%s::AddRef failed to increment the reference count of the object"), ptte->szInterface);
        tr = TR_FAIL;
    }

    punk->Release();
    punk->Release();

#else

#define VERIFY_ADDREF(ptr) \
    uRef1 = ptr->AddRef(); \
    uRef2 = ptr->AddRef(); \
    if (uRef2 != uRef1 + 1) { \
        Log(LOG_FAIL, TEXT("%s::AddRef failed to increment the reference count of the object"), ptte->szInterface); \
        tr = TR_FAIL; \
    } \
    ptr->Release(); \
    ptr->Release();

    switch (ptte->dwData) {

        case IDIRECT3D8:
//            VERIFY_ADDREF(GetDirect3D8())
            break;
        case IDEVICE8:
            VERIFY_ADDREF(GetDevice8())
            break;
        case ITEXTURE8:
            VERIFY_ADDREF(GetTexture8())
            break;
        case ICUBETEXTURE8:
            VERIFY_ADDREF(GetCubeTexture8())
            break;
        case IVOLUMETEXTURE8:
            VERIFY_ADDREF(GetVolumeTexture8())
            break;
        case IVERTEXBUFFER8:
            VERIFY_ADDREF(GetVertexBuffer8())
            break;
        case IINDEXBUFFER8:
            VERIFY_ADDREF(GetIndexBuffer8())
            break;
        case ISURFACE8:
            VERIFY_ADDREF(GetSurface8())
            break;
        case IVOLUME8:
            VERIFY_ADDREF(GetVolume8())
            break;
    }

#endif // UNDER_XBOX

    return tr;
}

//******************************************************************************
TESTPROCAPI TUNK_Release(PTESTTABLEENTRY ptte) {

    IUnknown*   punk;
    ULONG       uRef1, uRef2;
    TRESULT     tr = TR_PASS;

#ifndef UNDER_XBOX

    punk = GetUnknown(ptte->dwData);
    if (!punk) {
        return TR_ABORT;
    }

    punk->AddRef();
    punk->AddRef();

    uRef1 = punk->Release();
    uRef2 = punk->Release();

    if (uRef2 != uRef1 - 1) {
        Log(LOG_FAIL, TEXT("%s::Release failed to decrement the reference count of the object"), ptte->szInterface);
        tr = TR_FAIL;
    }

#else

#define VERIFY_RELEASE(ptr) \
    ptr->AddRef(); \
    ptr->AddRef(); \
    uRef1 = ptr->Release(); \
    uRef2 = ptr->Release(); \
    if (uRef2 != uRef1 - 1) { \
        Log(LOG_FAIL, TEXT("%s::Release failed to decrement the reference count of the object"), ptte->szInterface); \
        tr = TR_FAIL; \
    }

    switch (ptte->dwData) {

        case IDIRECT3D8:
//            VERIFY_RELEASE(GetDirect3D8())
            break;
        case IDEVICE8:
            VERIFY_RELEASE(GetDevice8())
            break;
        case ITEXTURE8:
            VERIFY_RELEASE(GetTexture8())
            break;
        case ICUBETEXTURE8:
            VERIFY_RELEASE(GetCubeTexture8())
            break;
        case IVOLUMETEXTURE8:
            VERIFY_RELEASE(GetVolumeTexture8())
            break;
        case IVERTEXBUFFER8:
            VERIFY_RELEASE(GetVertexBuffer8())
            break;
        case IINDEXBUFFER8:
            VERIFY_RELEASE(GetIndexBuffer8())
            break;
        case ISURFACE8:
            VERIFY_RELEASE(GetSurface8())
            break;
        case IVOLUME8:
            VERIFY_RELEASE(GetVolume8())
            break;
    }

#endif // UNDER_XBOX

    return tr;
}

//******************************************************************************
TESTPROCAPI TUNK_QueryInterface(PTESTTABLEENTRY ptte) {

    IUnknown*   punk;
    IUnknown*   punkQ;
    ULONG       uRef1, uRef2;
    HRESULT     hr;
    TRESULT     tr = TR_PASS;

#ifndef UNDER_XBOX

    punk = GetUnknown(ptte->dwData);
    if (!punk) {
        return TR_ABORT;
    }

    // ##TODO: If QueryInterface ends up being supported, verify it succeeds on
    // the object's interface and all of its base interfaces and fails on all
    // other interfaces of d3d

    punk->AddRef();
    uRef1 = punk->Release();

    hr = punk->QueryInterface(IID_IUnknown, (LPVOID*)&punkQ);
    if (FAILED(hr)) {
        Log(LOG_FAIL, TEXT("%s::QueryInterface(IID_IUnknown, ...) failed [0x%X]"), ptte->szInterface, hr);
        return TR_FAIL;
    }

    punk->AddRef();
    uRef2 = punk->Release();

    if (uRef2 != uRef1 + 1) {
        Log(LOG_FAIL, TEXT("%s::QueryInterface failed to increment the reference count of the object"), ptte->szInterface);
        return TR_FAIL;
    }

    punk->Release();

#else

#if 0

#define VERIFY_QUERYINTERFACE(ptr) \
    ptr->AddRef(); \
    uRef1 = ptr->Release(); \
\
    hr = ptr->QueryInterface(IID_IUnknown, (LPVOID*)&punkQ); \
    if (FAILED(hr)) { \
        Log(LOG_FAIL, TEXT("%s::QueryInterface(IID_IUnknown, ...) failed [0x%X]"), ptte->szInterface, hr); \
        return TR_FAIL; \
    } \
\
    ptr->AddRef(); \
    uRef2 = ptr->Release(); \
\
    if (uRef2 != uRef1 + 1) { \
        Log(LOG_FAIL, TEXT("%s::QueryInterface failed to increment the reference count of the object"), ptte->szInterface); \
        return TR_FAIL; \
    } \
\
    ptr->Release();

    switch (ptte->dwData) {

        case IDIRECT3D8:
            VERIFY_QUERYINTERFACE(GetDirect3D8())
            break;
        case IDEVICE8:
            VERIFY_QUERYINTERFACE(GetDevice8())
            break;
        case ITEXTURE8:
            VERIFY_QUERYINTERFACE(GetTexture8())
            break;
        case ICUBETEXTURE8:
            VERIFY_QUERYINTERFACE(GetCubeTexture8())
            break;
        case IVOLUMETEXTURE8:
            VERIFY_QUERYINTERFACE(GetVolumeTexture8())
            break;
        case IVERTEXBUFFER8:
            VERIFY_QUERYINTERFACE(GetVertexBuffer8())
            break;
        case IINDEXBUFFER8:
            VERIFY_QUERYINTERFACE(GetIndexBuffer8())
            break;
        case ISURFACE8:
            VERIFY_QUERYINTERFACE(GetSurface8())
            break;
        case IVOLUME8:
            VERIFY_QUERYINTERFACE(GetVolume8())
            break;
    }

#else
    tr = TR_SKIP;
#endif
#endif // UNDER_XBOX

    return tr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\log.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    log.cpp

Description:

    Logging functions.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <stdio.h>
#include <d3dx8.h>
//#include <xlog.h>
#ifndef UNDER_XBOX
#include <winsock.h>
#endif
#ifdef UNDER_XBOX
#include "xlog.h"
#endif // UNDER_XBOX
#include "log.h"
#include "util.h"

namespace D3DBVT {

//******************************************************************************
// Data types
//******************************************************************************

typedef HANDLE  (* XLOGPROC_CREATELOGW)(LPWSTR, PWEB_SERVER_INFO_W, SOCKET, DWORD, DWORD);
typedef BOOL    (* XLOGPROC_CLOSELOG)(HANDLE);
typedef BOOL    (* XLOGPROC_SETCOMPONENT)(HANDLE, LPSTR, LPSTR);
typedef BOOL    (* XLOGPROC_SETFUNCTIONNAME)(HANDLE, LPSTR);
typedef BOOL    (* XLOGPROC_STARTVARIATION)(HANDLE, LPSTR);
typedef DWORD   (* XLOGPROC_ENDVARIATION)(HANDLE);
typedef BOOL    (* XLOGPROC_LOG)(HANDLE, DWORD, LPSTR, ...);

//******************************************************************************
// Globals
//******************************************************************************

HINSTANCE                   g_hXLogDLL = NULL;
HANDLE                      g_hLog = INVALID_HANDLE_VALUE;
BOOL                        g_bLogCreated = FALSE;
XLOGPROC_CREATELOGW         g_pfnCreateLogW = NULL;
XLOGPROC_CLOSELOG           g_pfnCloseLog = NULL;
XLOGPROC_SETCOMPONENT       g_pfnSetComponent = NULL;
XLOGPROC_SETFUNCTIONNAME    g_pfnSetFunctionName = NULL;
XLOGPROC_STARTVARIATION     g_pfnStartVariation = NULL;
XLOGPROC_ENDVARIATION       g_pfnEndVariation = NULL;
XLOGPROC_LOG                g_pfnLog = NULL;
TCHAR                       g_szTextLog[2048] = {0};

//******************************************************************************
void CreateLog(HANDLE hLog) {

#ifdef UNDER_XBOX
    WEB_SERVER_INFO wsi;
#endif // UNDER_XBOX

    ReleaseLog();

#ifndef UNDER_XBOX

    g_hXLogDLL = LoadLibrary(TEXT("xlog.dll"));

    if (g_hXLogDLL) {
        g_pfnCreateLogW = (XLOGPROC_CREATELOGW)GetProcAddress(g_hXLogDLL, "xCreateLog_W");
        g_pfnCloseLog = (XLOGPROC_CLOSELOG)GetProcAddress(g_hXLogDLL, "xCloseLog");
        g_pfnSetComponent = (XLOGPROC_SETCOMPONENT)GetProcAddress(g_hXLogDLL, "xSetComponent");
        g_pfnSetFunctionName = (XLOGPROC_SETFUNCTIONNAME)GetProcAddress(g_hXLogDLL, "xSetFunctionName");
        g_pfnStartVariation = (XLOGPROC_STARTVARIATION)GetProcAddress(g_hXLogDLL, "xStartVariation");
        g_pfnEndVariation = (XLOGPROC_ENDVARIATION)GetProcAddress(g_hXLogDLL, "xEndVariation");
        g_pfnLog = (XLOGPROC_LOG)GetProcAddress(g_hXLogDLL, "xLog");

        if (g_pfnCreateLogW && g_pfnCloseLog && hLog == INVALID_HANDLE_VALUE) {
            hLog = g_pfnCreateLogW(L"d3dbvt.log", NULL, INVALID_SOCKET, XLL_LOGALL, XLO_DEBUG | XLO_CONFIG | XLO_REFRESH);
            g_bLogCreated = TRUE;
        }
    }
    else {
        hLog = INVALID_HANDLE_VALUE;
    }

    if (hLog == INVALID_HANDLE_VALUE) {

        g_pfnCreateLogW = NULL;
        g_pfnCloseLog = NULL;
        g_pfnSetComponent = NULL;
        g_pfnSetFunctionName = NULL;
        g_pfnStartVariation = NULL;
        g_pfnEndVariation = NULL;
        g_pfnLog = NULL;
    }

#else

    g_pfnCreateLogW = (XLOGPROC_CREATELOGW)xCreateLog_W;
    g_pfnCloseLog = (XLOGPROC_CLOSELOG)xCloseLog;
    g_pfnSetComponent = (XLOGPROC_SETCOMPONENT)xSetComponent;
    g_pfnSetFunctionName = (XLOGPROC_SETFUNCTIONNAME)xSetFunctionName;
    g_pfnStartVariation = (XLOGPROC_STARTVARIATION)xStartVariation;
    g_pfnEndVariation = (XLOGPROC_ENDVARIATION)xEndVariation;
    g_pfnLog = (XLOGPROC_LOG)xLog;

    memset(&wsi, 0, sizeof(WEB_SERVER_INFO));
    wsi.lpszHttpServer = TEXT("157.56.11.21");
    wsi.lpszConfigPage = TEXT("/regression/submit/sysConfig.asp");
    wsi.lpszLogPage = TEXT("/regression/submit/log.asp");

    if (g_pfnCreateLogW && g_pfnCloseLog && hLog == INVALID_HANDLE_VALUE) {
#if NOWEBLOG
        hLog = g_pfnCreateLogW(L"t:\\d3d.log", NULL, INVALID_SOCKET, XLL_LOGALL, XLO_CONFIG | XLO_REFRESH);
#else
        hLog = g_pfnCreateLogW(L"t:\\d3d.log", &wsi, INVALID_SOCKET, XLL_LOGALL, XLO_CONFIG | XLO_REFRESH);
#endif
        g_bLogCreated = TRUE;
    }

#endif // UNDER_XBOX

    g_hLog = hLog;
}

//******************************************************************************
void ReleaseLog() {

    if (g_bLogCreated && g_pfnCloseLog && g_hLog != INVALID_HANDLE_VALUE) {
        g_pfnCloseLog(g_hLog);
    }

#ifndef UNDER_XBOX
    if (g_hXLogDLL) {
        FreeLibrary(g_hXLogDLL);
    }
#endif // !UNDER_XBOX

    g_hXLogDLL = NULL;
    g_hLog = INVALID_HANDLE_VALUE;
    g_bLogCreated = FALSE;
    g_pfnCreateLogW = NULL;
    g_pfnCloseLog = NULL;
    g_pfnSetComponent = NULL;
    g_pfnSetFunctionName = NULL;
    g_pfnStartVariation = NULL;
    g_pfnEndVariation = NULL;
    g_pfnLog = NULL;
    *g_szTextLog = TEXT('\0');
}

//******************************************************************************
BOOL LogComponent(LPCTSTR szComponent, LPCTSTR szSubcomponent) {

    if (g_pfnSetComponent) {
#ifdef UNICODE
        char szComp[512], szSub[512];
        wcstombs(szComp, szComponent, 512);
        wcstombs(szSub, szSubcomponent, 512);
        g_pfnSetComponent(g_hLog, szComp, szSub);
#else
        g_pfnSetComponent(g_hLog, (LPSTR)szComponent, (LPSTR)szSubcomponent);
#endif // UNICODE        
    }

    return TRUE;
}

//******************************************************************************
BOOL LogFunction(LPCTSTR szFunction) {

    if (g_pfnSetFunctionName) {
#ifdef UNICODE
        char szFunc[512];
        wcstombs(szFunc, szFunction, 512);
        g_pfnSetFunctionName(g_hLog, szFunc);
#else
        g_pfnSetFunctionName(g_hLog, (LPSTR)szFunction);
#endif // UNICODE
    }

    return TRUE;
}

//******************************************************************************
BOOL LogBeginVariation(LPCTSTR szFormat, ...) {

    TCHAR   szBuffer[512];
    va_list vl;

    va_start(vl, szFormat);
    wvsprintf(szBuffer, szFormat, vl);
//    _vstprintf(szBuffer+8, szFormat, vl);
    va_end(vl);

    if (g_pfnStartVariation) {
#ifdef UNICODE
        char szVariation[512];
        wcstombs(szVariation, szBuffer, 512);
        g_pfnStartVariation(g_hLog, szVariation);
#else
        g_pfnStartVariation(g_hLog, szBuffer);
#endif // UNICODE
    }

    Log(LOG_TEXT, TEXT("BEGIN VARIATION: %s\n"), szBuffer);

    return TRUE;
}

//******************************************************************************
BOOL LogEndVariation() {

    if (g_pfnEndVariation) {
        g_pfnEndVariation(g_hLog);
    }

    Log(LOG_TEXT, TEXT("END VARIATION\n"));

    return TRUE;
}

//******************************************************************************
BOOL Log(LOGLEVEL ll, LPCTSTR szFormat, ...) {

    va_list vl;
    TCHAR   *pchH, *pchT;
    DWORD   dwLevel;
#ifndef UNDER_XBOX
    TCHAR   szBuffer[2048];
    TCHAR   szLog[2304];
#else
    TCHAR*  szBuffer;
    TCHAR*  szLog;
    LPTSTR  pszBuffer;

    pszBuffer = (LPTSTR)MemAlloc32(4352 * sizeof(TCHAR) + 2304 * sizeof(char));
    if (!pszBuffer) {
        OutputDebugString(TEXT("Insufficient memory for logging buffer allocation\n"));
        __asm int 3;
    }
    szBuffer = pszBuffer;
    szLog = pszBuffer + 2048;
#endif // UNDER_XBOX

    va_start(vl, szFormat);
    wvsprintf(szBuffer, szFormat, vl);
//    _vstprintf(szBuffer+8, szFormat, vl);
    va_end(vl);

    if (ll == LOG_TEXT) {

        pchH = szBuffer;
        pchT = szBuffer;

        do {
            for (; !(*pchT == TEXT('\n') || *pchT == TEXT('\0')); pchT++);
            if (*pchT == TEXT('\n')) {
                *pchT++ = TEXT('\0');
                _tcscat(g_szTextLog, pchH);
                DebugString(g_szTextLog);
                *g_szTextLog = TEXT('\0');
                pchH = pchT;
            }
        } while (*pchT != TEXT('\0'));

        _tcscat(g_szTextLog, pchH);

#ifdef UNDER_XBOX
        MemFree32(pszBuffer);
#endif // UNDER_XBOX

        return TRUE;
    }

    switch (ll) {

        case LOG_EXCEPTION:
            dwLevel = XLL_EXCEPTION;
            _tcscpy(szLog, TEXT("EXCEPTION: "));
            break;
        case LOG_FAIL:
            _tcscpy(szLog, TEXT("FAIL: "));
            dwLevel = XLL_FAIL;
            break;
        case LOG_ABORT:
            _tcscpy(szLog, TEXT("ABORT: "));
            dwLevel = XLL_BLOCK;
            break;
        case LOG_WARN:
            _tcscpy(szLog, TEXT("WARNING: "));
            dwLevel = XLL_WARN;
            break;
        case LOG_SKIP:
            _tcscpy(szLog, TEXT("SKIP: "));
            dwLevel = XLL_WARN;
            break;
        case LOG_NOTIMPL:
            _tcscpy(szLog, TEXT("NOT IMPLEMENTED: "));
            dwLevel = XLL_WARN;
            break;
        case LOG_PASS:
            _tcscpy(szLog, TEXT("PASS: "));
            dwLevel = XLL_PASS;
            break;
        case LOG_DETAIL:
            _tcscpy(szLog, TEXT("DETAIL: "));
            dwLevel = XLL_INFO;
            break;
        case LOG_COMMENT:
        default:
            *szLog = TEXT('\0');
            dwLevel = XLL_INFO;
            break;
    }

    _tcscat(szLog, szBuffer);

    if (g_pfnLog) {
#ifdef UNICODE
#ifndef UNDER_XBOX
        char szLogA[2304];
#else
        char* szLogA = (char*)(pszBuffer + 4352);
#endif // UNDER_XBOX
        wcstombs(szLogA, szLog, 2304);
        g_pfnLog(g_hLog, dwLevel, szLogA);
#else
        g_pfnLog(g_hLog, dwLevel, szLog);
#endif // UNICODE
    }

    // Echo logging to the debugger
    DebugString(szLog);

#ifdef UNDER_XBOX
    MemFree32(pszBuffer);
#endif // UNDER_XBOX

    return TRUE;
}

//******************************************************************************
// Debugging functions
//******************************************************************************

//#if defined(DEBUG) || defined(_DEBUG)
//******************************************************************************
//
// Function:
//
//     DebugString
//
// Description:
//
//     Take the formatted output, prepend the application name, and send the
//     output to the debugger.
//
// Arguments:
//
//     LPCTSTR szFormat         - Formatting string describing the output
//
//     Variable argument list   - Data to be placed in the output string
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DebugString(LPCTSTR szFormat, ...) {

    va_list vl;
#ifndef UNDER_XBOX
    TCHAR   szBuffer[2304];
#else
    TCHAR*  szBuffer = (LPTSTR)MemAlloc32(2304 * sizeof(TCHAR));
    if (!szBuffer) {
        OutputDebugString(TEXT("Insufficient memory for logging buffer allocation\n"));
        __asm int 3;
    }
#endif // UNDER_XBOX

    va_start(vl, szFormat);
#ifdef UNDER_CE
    wvsprintf(szBuffer, szFormat, vl);
#else
    _vstprintf(szBuffer, szFormat, vl);
#endif // DRAGON
    va_end(vl);

    _tcscat(szBuffer, TEXT("\r\n"));

    OutputDebugString(szBuffer);

#ifdef UNDER_XBOX
    MemFree32(szBuffer);
#endif // UNDER_XBOX
}

//******************************************************************************
//
// Function:
//
//     ResultFailed
//
// Description:
//
//     Test a given return code: if the code is an error, output a debug 
//     message with the error value.  If the code is a warning, output
//     a debug message with the warning value.
//
// Arguments:
//
//     HRESULT hr               - Return code to test for an error
//
//     LPCTSTR sz               - String describing the method that produced 
//                                the return code
//
// Return Value:
//
//     TRUE if the given return code is an error, FALSE otherwise.
//
//******************************************************************************
BOOL ResultFailed(HRESULT hr, LPCTSTR sz) {

    TCHAR szError[256];

    if (SUCCEEDED(hr)) {
        return FALSE;
    }

    D3DXGetErrorString(hr, szError, 256);

    if (FAILED(hr)) {
        Log(LOG_FAIL, TEXT("%s failed with %s [0x%X]"), sz, szError, hr);
        return TRUE;
    }
    else {
        Log(LOG_WARN, TEXT("%s returned %s [0x%X]"), sz, szError, hr);
    }

    return FALSE;
}
//#endif // DEBUG || _DEBUG

} // namespace D3DBVT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\swapchn8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    swapchn8.cpp

Description:

    IDirect3DSwapChain8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IDirect3DSwapChain8 inteface tests
//******************************************************************************

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TSWC8_Present(PTESTTABLEENTRY ptte) {

    LPDIRECT3DSWAPCHAIN8    pd3dsw;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3dsw = GetSwapChain8();
    if (!pd3dsw) {
        return TR_ABORT;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSWC8_GetBackBuffer(PTESTTABLEENTRY ptte) {

    LPDIRECT3DSWAPCHAIN8    pd3dsw;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3dsw = GetSwapChain8();
    if (!pd3dsw) {
        return TR_ABORT;
    }

    return tr;
}

#endif // !UNDER_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\log.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    log.h

Description:

    Direct3D logging functions.

*******************************************************************************/

namespace D3DBVT {

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define LOG_EXCEPTION           0
#define LOG_FAIL                2
#define LOG_ABORT               4
#define LOG_WARN                5
#define LOG_SKIP                6
#define LOG_NOTIMPL             8
#define LOG_PASS                10
#define LOG_DETAIL              12
#define LOG_COMMENT             14
#define LOG_TEXT                16
//#define LOG_BREAK?
//#define LOG_RESULT?

#ifndef UNDER_XBOX

// XLL_ logging levels
#define XLL_LOGNONE             0x00000000L  // Disables all logging
#define XLL_LOGALL              0xFFFFFFFFL  // Enables logging at all levels

#define XLL_EXCEPTION           0x00000001L  // Enables logging of exception events
#define XLL_BREAK               0x00000002L  // Enables logging to break into the debugger
#define XLL_FAIL                0x00000004L  // Enables logging of failure events
#define XLL_WARN                0x00000008L  // Enables logging of warning events
#define XLL_BLOCK               0x00000010L  // Enables logging of blocking events
#define XLL_PASS                0x00000020L  // Enables logging of pass events
#define XLL_INFO                0x00000040L  // Enables logging of informational events
#define XLL_VARIATION           0x00000080L  // Enables logging of variation start/end events

// XLO_ logging options
#define XLO_DEBUG	            0x00000001L  // Log output is echoed to the debugger
#define XLO_CONFIG	            0x00000002L  // Enables logging of system configuration when the log object is created
#define XLO_STATE	            0x00000004L  // Enables logging of system state when the log object is created and again when the log object is closed
#define XLO_REFRESH	            0x00000008L  // Creates a new log file.  If the log file already exists, overwrites the file and clears the existing attributes.

typedef struct _WEB_SERVER_INFO_W {
    LPWSTR  lpszHttpServer;                    // Pointer to a null-terminated string (UNICODE) that specifies the http server to which the web posts will be directed.  This member is NULL if no web posts will be made.
    LPWSTR  lpszConfigPage;                    // Pointer to a null-terminated string (UNICODE) that specifies the web page to which the system configuration will be web posted.  This member is NULL if no web posts will be made.
    LPWSTR  lpszStatePage;                     // Pointer to a null-terminated string (UNICODE) that specifies the web page to which the system state will be web posted.  This member is NULL if no web posts will be made.
    LPWSTR  lpszLogPage;                       // Pointer to a null-terminated string (UNICODE) that specifies the web page to which the log output will be web posted.  This member is NULL if no web posts will be made.
    LPWSTR  lpszWebPostFileName;               // Pointer to a null-terminated string (UNICODE) that specifies the file to which the web posts will be cache.  This member is NULL if web posts will not be cached and instead be made immediately.
} WEB_SERVER_INFO_W, *PWEB_SERVER_INFO_W;

#endif // !UNDER_XBOX

//******************************************************************************
// Data types
//******************************************************************************

typedef DWORD LOGLEVEL;

//******************************************************************************
// Logging function prototypes
//******************************************************************************

void                            CreateLog(HANDLE hLog);
void                            ReleaseLog();
BOOL                            LogComponent(LPCTSTR szComponent, LPCTSTR szSubcomponent);
BOOL                            LogFunction(LPCTSTR szFunction);
BOOL                            LogBeginVariation(LPCTSTR szFormat, ...);
BOOL                            LogEndVariation();
BOOL                            Log(LOGLEVEL ll, LPCTSTR szFormat, ...);

//******************************************************************************
// Debugging function prototypes
//******************************************************************************

//#if defined(DEBUG) || defined(_DEBUG)
void                            DebugString(LPCTSTR szFormat, ...);
BOOL                            ResultFailed(HRESULT hr, LPCTSTR sz);
//#else
//inline void         DebugString(LPCTSTR szFormat, ...) {}
//inline BOOL         ResultFailed(HRESULT hr, LPCTSTR sz) {return FALSE;};
//#endif

} // namespace D3DBVT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\texture8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    texture8.cpp

Description:

    IDirect3DTexture8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IDirect3DTexture8 inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TTEX8_GetLevelDesc(PTESTTABLEENTRY ptte) {

    LPDIRECT3DTEXTURE8  pd3dt;

    pd3dt = GetTexture8();
    if (!pd3dt) {
        return TR_ABORT;
    }

    return TSHR8_GetLevelDesc(ptte, (LPVOID)pd3dt);
}

//******************************************************************************
TESTPROCAPI TTEX8_LockRect(PTESTTABLEENTRY ptte) {

    LPDIRECT3DTEXTURE8  pd3dt;

    pd3dt = GetTexture8();
    if (!pd3dt) {
        return TR_ABORT;
    }

    return TSHR8_LockRect(ptte, (LPVOID)pd3dt);
}

//******************************************************************************
TESTPROCAPI TTEX8_UnlockRect(PTESTTABLEENTRY ptte) {

    LPDIRECT3DTEXTURE8  pd3dt;

    pd3dt = GetTexture8();
    if (!pd3dt) {
        return TR_ABORT;
    }

    return TSHR8_UnlockRect(ptte, (LPVOID)pd3dt);
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TTEX8_AddDirtyRect(PTESTTABLEENTRY ptte) {

    LPDIRECT3DTEXTURE8  pd3dt;

    pd3dt = GetTexture8();
    if (!pd3dt) {
        return TR_ABORT;
    }

    return TSHR8_AddDirtyRect(ptte, (LPVOID)pd3dt);
}

#endif // !UNDER_XBOX

//******************************************************************************
TESTPROCAPI TTEX8_GetSurfaceLevel(PTESTTABLEENTRY ptte) {

    LPDIRECT3DTEXTURE8  pd3dt;

    pd3dt = GetTexture8();
    if (!pd3dt) {
        return TR_ABORT;
    }

    return TSHR8_GetSurfaceLevel(ptte, (LPVOID)pd3dt);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\surface8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    surface8.cpp

Description:

    IDirect3DSurface8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IDirect3DSurface8 inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TSUR8_GetContainer(PTESTTABLEENTRY ptte) {

    LPVOID                  pvContainer1 = DEAD_PTR, pvContainer2 = DEAD_PTR,
                            pvContainer3;
    LPDIRECT3DSURFACE8      pd3ds = NULL;
    ULONG                   uRef1, uRef2;
    HRESULT                 hr1, hr2;
    UINT                    i;
    TRESULT                 tr = TR_PASS;

    for (i = 0; i < 2; i++) {

        if (i) {
            pd3ds = GetSurface8((LPDIRECT3DTEXTURE8*)&pvContainer3);
        }
        else {
            pd3ds = GetCubeSurface8((LPDIRECT3DCUBETEXTURE8*)&pvContainer3);
        }
        if (!pd3ds) {
            return TR_ABORT;
        }

#ifndef UNDER_XBOX

        ((IUnknown*)pvContainer3)->AddRef();
        uRef1 = ((IUnknown*)pvContainer3)->Release();

        hr1 = pd3ds->GetContainer(IID_IDirect3DTexture8, &pvContainer1);
        hr2 = pd3ds->GetContainer(IID_IDirect3DCubeTexture8, &pvContainer2);

        if (i) {

            if (FAILED(hr1)) {
                Log(LOG_FAIL, TEXT("%s::GetContainer failed [0x%X]"), ptte->szInterface, hr1);
                return TR_FAIL;
            }
            if (SUCCEEDED(hr2)) {
                Log(LOG_FAIL, TEXT("%s::GetContainer(IID_IDirect3DCubeTexture8, ...) succeeded on a texture surface"), ptte->szInterface);
                tr = TR_FAIL;
            }
        }
        else {

            if (FAILED(hr2)) {
                Log(LOG_FAIL, TEXT("%s::GetContainer failed [0x%X]"), ptte->szInterface, hr2);
                return TR_FAIL;
            }
            if (SUCCEEDED(hr1)) {
                Log(LOG_FAIL, TEXT("%s::GetContainer(IID_IDirect3DTexture8, ...) succeeded on a cube texture surface"), ptte->szInterface);
                tr = TR_FAIL;
            }
            pvContainer2 = (LPVOID)((DWORD)pvContainer1 ^ (DWORD)pvContainer2);
            pvContainer1 = (LPVOID)((DWORD)pvContainer1 ^ (DWORD)pvContainer2);
            pvContainer2 = (LPVOID)((DWORD)pvContainer1 ^ (DWORD)pvContainer2);
        }

        if (pvContainer2 != NULL) {
            Log(LOG_FAIL, TEXT("%s::GetContainer failed to clear the given container pointer when given an invalid reference identifier"), ptte->szInterface);
            tr = TR_FAIL;
        }

        ((IUnknown*)pvContainer3)->AddRef();
        uRef2 = ((IUnknown*)pvContainer3)->Release();
#else

        if (i) {
            ((IDirect3DTexture8*)pvContainer3)->AddRef();
            uRef1 = ((IDirect3DTexture8*)pvContainer3)->Release();
        }
        else {
            ((IDirect3DCubeTexture8*)pvContainer3)->AddRef();
            uRef1 = ((IDirect3DCubeTexture8*)pvContainer3)->Release();
        }

        hr1 = pd3ds->GetContainer((LPDIRECT3DBASETEXTURE8*)&pvContainer1);

        if (FAILED(hr1)) {
            Log(LOG_FAIL, TEXT("%s::GetContainer failed [0x%X]"), ptte->szInterface, hr1);
            return TR_FAIL;
        }

        if (i) {
            ((IDirect3DTexture8*)pvContainer3)->AddRef();
            uRef2 = ((IDirect3DTexture8*)pvContainer3)->Release();
        }
        else {
            ((IDirect3DCubeTexture8*)pvContainer3)->AddRef();
            uRef2 = ((IDirect3DCubeTexture8*)pvContainer3)->Release();
        }

#endif // UNDER_XBOX

        if (uRef2 != uRef1 + 1) {
            Log(LOG_FAIL, TEXT("%s::GetContainer failed to increment the reference count of the container object"), ptte->szInterface);
            tr = TR_FAIL;
        }

#ifndef UNDER_XBOX
        ((IUnknown*)pvContainer3)->Release();
#else
        ((LPDIRECT3DBASETEXTURE8)pvContainer1)->Release();
#endif // UNDER_XBOX

        if (pvContainer1 != pvContainer3) {
            Log(LOG_FAIL, TEXT("%s::GetContainer returned an incorrect pointer to the container object: 0x%X"), ptte->szInterface, pvContainer1);
            tr = TR_FAIL;
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSUR8_GetDevice(PTESTTABLEENTRY ptte) {

    LPDIRECT3DSURFACE8  pd3ds;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3ds = GetSurface8();
    if (!pd3ds) {
        return TR_ABORT;
    }

    return TSHR8_GetDevice(ptte, (LPVOID)pd3ds);
}

//******************************************************************************
TESTPROCAPI TSUR8_GetDesc(PTESTTABLEENTRY ptte) {

    LPDIRECT3DSURFACE8      pd3ds = NULL;
    D3DSURFACE_DESC         d3dsd1, d3dsd2;
    UINT                    i;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    for (i = 0; i < 2; i++) {

        if (i) {
            LPDIRECT3DTEXTURE8 pd3dt;
            pd3ds = GetSurface8(&pd3dt);
            if (!pd3dt) {
                return TR_ABORT;
            }
            hr = pd3dt->GetLevelDesc(0, &d3dsd1);
        }
        else {
            LPDIRECT3DCUBETEXTURE8 pd3dtc;
            pd3ds = GetCubeSurface8(&pd3dtc);
            if (!pd3dtc) {
                return TR_ABORT;
            }
            hr = pd3dtc->GetLevelDesc(0, &d3dsd1);
        }
        if (FAILED(hr) || !pd3ds) {
            return TR_ABORT;
        }

        hr = pd3ds->GetDesc(&d3dsd2);
        if (ResultFailed(hr, TEXT("IDirect3DSurface8::GetDesc"))) {
            return TR_FAIL;
        }

        if (d3dsd1.Format != d3dsd2.Format ||
            d3dsd1.Usage != d3dsd2.Usage ||
            d3dsd1.MultiSampleType != d3dsd2.MultiSampleType ||
            d3dsd1.Size != d3dsd2.Size ||
            d3dsd1.Width != d3dsd2.Width ||
            d3dsd1.Height != d3dsd2.Height)
        {
            Log(LOG_FAIL, TEXT("IDirect3DSurface8::GetDesc returned an incorrect surface description"));
            tr = TR_FAIL;
        }
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TSUR8_LockRect(PTESTTABLEENTRY ptte) {

    LPDIRECT3DSURFACE8  pd3ds;

    pd3ds = GetSurface8();
    if (!pd3ds) {
        return TR_ABORT;
    }

    return TSHR8_LockRect(ptte, (LPVOID)pd3ds);
}

//******************************************************************************
TESTPROCAPI TSUR8_UnlockRect(PTESTTABLEENTRY ptte) {

    LPDIRECT3DSURFACE8  pd3ds;

    pd3ds = GetSurface8();
    if (!pd3ds) {
        return TR_ABORT;
    }

    return TSHR8_UnlockRect(ptte, (LPVOID)pd3ds);
}

//******************************************************************************
TESTPROCAPI TSUR8_GetPrivateData(PTESTTABLEENTRY ptte) {

    LPDIRECT3DSURFACE8  pd3ds;

    pd3ds = GetSurface8();
    if (!pd3ds) {
        return TR_ABORT;
    }

    return TSHR8_GetPrivateData(ptte, (LPVOID)pd3ds);
}

//******************************************************************************
TESTPROCAPI TSUR8_SetPrivateData(PTESTTABLEENTRY ptte) {

    LPDIRECT3DSURFACE8  pd3ds;

    pd3ds = GetSurface8();
    if (!pd3ds) {
        return TR_ABORT;
    }

    return TSHR8_SetPrivateData(ptte, (LPVOID)pd3ds);
}

//******************************************************************************
TESTPROCAPI TSUR8_FreePrivateData(PTESTTABLEENTRY ptte) {

    LPDIRECT3DSURFACE8  pd3ds;

    pd3ds = GetSurface8();
    if (!pd3ds) {
        return TR_ABORT;
    }

    return TSHR8_FreePrivateData(ptte, (LPVOID)pd3ds);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\rsource8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    rsource8.cpp

Description:

    IDirect3DResource8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IDirect3DResource8 helper functions
//******************************************************************************

//******************************************************************************
LPDIRECT3DRESOURCE8 GetResource8(D3DIFACETYPE d3dift) {

    LPDIRECT3DRESOURCE8 pd3dres = NULL;

    switch (d3dift) {

        case ITEXTURE8:
            pd3dres = (LPDIRECT3DRESOURCE8)GetTexture8();
            break;
        case ICUBETEXTURE8:
            pd3dres = (LPDIRECT3DRESOURCE8)GetCubeTexture8();
            break;
        case IVOLUMETEXTURE8:
            pd3dres = (LPDIRECT3DRESOURCE8)GetVolumeTexture8();
            break;
        case IVERTEXBUFFER8:
            pd3dres = (LPDIRECT3DRESOURCE8)GetVertexBuffer8();
            break;
        case IINDEXBUFFER8:
            pd3dres = (LPDIRECT3DRESOURCE8)GetIndexBuffer8();
            break;
    }

    return pd3dres;
}

//******************************************************************************
// IDirect3DResource8 inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TRES8_GetType(PTESTTABLEENTRY ptte) {

    LPDIRECT3DRESOURCE8 pd3dres;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;
    D3DRESOURCETYPE     d3drt;
    D3DRESOURCETYPE     pd3drt[11] = {
                            (D3DRESOURCETYPE)0xFFFFFFFE,
                            (D3DRESOURCETYPE)0xFFFFFFFE,
                            (D3DRESOURCETYPE)0xFFFFFFFE,
                            (D3DRESOURCETYPE)0xFFFFFFFE,
                            D3DRTYPE_TEXTURE,
                            D3DRTYPE_CUBETEXTURE,
                            D3DRTYPE_VOLUMETEXTURE,
                            D3DRTYPE_VERTEXBUFFER,
                            D3DRTYPE_INDEXBUFFER,
                            (D3DRESOURCETYPE)0xFFFFFFFE,
                            (D3DRESOURCETYPE)0xFFFFFFFE,
                        };
                            
    pd3dres = GetResource8(ptte->dwData);
    if (!pd3dres) {
        return TR_ABORT;
    }

    d3drt = pd3dres->GetType();

    if (d3drt != pd3drt[ptte->dwData]) {
        Log(LOG_FAIL, TEXT("%s::GetType returned an incorrect type: %d"), ptte->szInterface, d3drt);
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TRES8_GetDevice(PTESTTABLEENTRY ptte) {

    LPDIRECT3DDEVICE8   pd3dd, pd3ddR;
    LPDIRECT3DRESOURCE8 pd3dres;
    ULONG               uRef1, uRef2;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dd = GetDevice8();
    if (!pd3dd) {
        return TR_ABORT;
    }

    pd3dres = GetResource8(ptte->dwData);
    if (!pd3dres) {
        return TR_ABORT;
    }

    pd3dd->AddRef();
    uRef1 = pd3dd->Release();

    hr = pd3dres->GetDevice(&pd3ddR);
    if (FAILED(hr)) {
        Log(LOG_FAIL, TEXT("%s::GetDevice failed [0x%X]"), ptte->szInterface, hr);
        return TR_FAIL;
    }

    pd3dd->AddRef();
    uRef2 = pd3dd->Release();

    if (uRef2 != uRef1 + 1) {
        Log(LOG_FAIL, TEXT("%s::GetDevice failed to increment the reference count of the device object"), ptte->szInterface);
        tr = TR_FAIL;
    }

    pd3dd->Release();

    if (pd3ddR != pd3dd) {
        Log(LOG_FAIL, TEXT("%s::GetDevice returned an incorrect pointer to the device object: 0x%X"), ptte->szInterface, pd3ddR);
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TRES8_GetPrivateData(PTESTTABLEENTRY ptte) {

    LPDIRECT3DRESOURCE8 pd3dres;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dres = GetResource8(ptte->dwData);
    if (!pd3dres) {
        return TR_ABORT;
    }

    return TSHR8_GetPrivateData(ptte, (LPVOID)pd3dres);
}

//******************************************************************************
TESTPROCAPI TRES8_SetPrivateData(PTESTTABLEENTRY ptte) {

    LPDIRECT3DRESOURCE8 pd3dres;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dres = GetResource8(ptte->dwData);
    if (!pd3dres) {
        return TR_ABORT;
    }

    return TSHR8_SetPrivateData(ptte, (LPVOID)pd3dres);
}

//******************************************************************************
TESTPROCAPI TRES8_FreePrivateData(PTESTTABLEENTRY ptte) {

    LPDIRECT3DRESOURCE8 pd3dres;
    HRESULT             hr;
    TRESULT             tr = TR_PASS;

    pd3dres = GetResource8(ptte->dwData);
    if (!pd3dres) {
        return TR_ABORT;
    }

    return TSHR8_FreePrivateData(ptte, (LPVOID)pd3dres);
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TRES8_GetPriority(PTESTTABLEENTRY ptte) {

    LPDIRECT3DRESOURCE8 pd3dres;
    DWORD               dwPriority;
    TRESULT             tr = TR_PASS;

    pd3dres = GetResource8(ptte->dwData);
    if (!pd3dres) {
        return TR_ABORT;
    }

    dwPriority = pd3dres->GetPriority();
    if (dwPriority != 0) {
        Log(LOG_FAIL, TEXT("%s::GetPriority returned a priority of %d for a nonmanaged resource"), ptte->szInterface, dwPriority);
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TRES8_SetPriority(PTESTTABLEENTRY ptte) {

    LPDIRECT3DRESOURCE8 pd3dres;
    DWORD               dwPriority;
    TRESULT             tr = TR_PASS;

    pd3dres = GetResource8(ptte->dwData);
    if (!pd3dres) {
        return TR_ABORT;
    }

    pd3dres->SetPriority(rand());

    dwPriority = pd3dres->SetPriority(rand());
    if (dwPriority != 0) {
        Log(LOG_FAIL, TEXT("%s::SetPriority returned a priority of %d for a nonmanaged resource"), ptte->szInterface, dwPriority);
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TRES8_PreLoad(PTESTTABLEENTRY ptte) {

    LPDIRECT3DRESOURCE8 pd3dres;
    TRESULT             tr = TR_PASS;

    pd3dres = GetResource8(ptte->dwData);
    if (!pd3dres) {
        return TR_ABORT;
    }

    pd3dres->PreLoad();

    return tr;
}

#endif // !UNDER_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\util.cpp ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    util.cpp

Description:

    Utility functions.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <d3dx8.h>
#include <tchar.h>
#include <stdio.h>
#include <math.h>
#include "log.h"
#include "util.h"

namespace D3DBVT {

//******************************************************************************
// Function prototypes
//******************************************************************************

//******************************************************************************
// Globals
//******************************************************************************

static HANDLE           g_hHeap = NULL;

//******************************************************************************
// Memory allocation routines
//******************************************************************************

//******************************************************************************
BOOL CreateHeap() {

    if (g_hHeap) {
        return FALSE;
    }

    g_hHeap = HeapCreate(0, 0, 0);
    if (!g_hHeap) {
        DebugString(TEXT("HeapCreate failed [%d]"), GetLastError());
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
void ReleaseHeap() {

    if (g_hHeap) {
        if (!HeapDestroy(g_hHeap)) {
            DebugString(TEXT("HeapDestroy failed [%d]"), GetLastError());
        }
        g_hHeap = NULL;
    }
}

//******************************************************************************
LPVOID MemAlloc(UINT uNumBytes) {

    LPVOID pvMem = NULL;
    if (g_hHeap) {
        pvMem = HeapAlloc(g_hHeap, 0, uNumBytes);
    }
    return pvMem;
}

//******************************************************************************
void MemFree(LPVOID pvMem) {

    if (g_hHeap) {
        if (!HeapFree(g_hHeap, 0, pvMem)) {
            DebugString(TEXT("HeapFree failed [%d]"), GetLastError());
        }
    }
}

//******************************************************************************
//
// Function:
//
//     MemAlloc32
//
// Description:
//
//     Allocate a given amount of memory whose base address is
//     aligned along a 32 byte boundary.  This memory must later be freed
//     using the MemFree32 function.
//
// Arguments:
//
//     UINT uNumBytes           - Number of bytes to allocate
//
// Return Value:
//
//     Base address of the allocated memory.
//
//******************************************************************************
LPVOID MemAlloc32(UINT uNumBytes)
{
	LPBYTE pbyAllocated, pbyAligned = NULL;

	pbyAllocated = (LPBYTE)MemAlloc(uNumBytes + 32);
    if (pbyAllocated) {
	    pbyAligned   = (LPBYTE)((((DWORD)pbyAllocated) + 32) & ~31);
	    *(((LPDWORD)pbyAligned)-1) = (DWORD)pbyAllocated;
    }
	return pbyAligned;
}

//******************************************************************************
//
// Function:
//
//     MemFree32
//
// Description:
//
//     Free an aligned block of memory that was allocated using the MemAlloc32
//     function.
//
// Arguments:
//
//     LPVOID pvAligned         - Base address of the aligned memory
//
// Return Value:
//
//     None.
//
//******************************************************************************
void MemFree32(LPVOID pvMem)
{
	LPBYTE pbyFree;

    if (pvMem) {
	    pbyFree = (LPBYTE)*(((LPDWORD)pvMem)-1);
	    MemFree(pbyFree);
    }
}

//******************************************************************************
// Matrix utility functions
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     InitMatrix
//
// Description:
//
//     Initialize the given matrix with the given values.
//
// Arguments:
//
//     LPD3DMATRIX pd3dm        - Matrix to initialize
//
//     float _11 to _44         - Initialization values
//
// Return Value:
//
//     None.
//
//******************************************************************************
void InitMatrix(D3DMATRIX* pd3dm,
                float _11, float _12, float _13, float _14,
                float _21, float _22, float _23, float _24,
                float _31, float _32, float _33, float _34,
                float _41, float _42, float _43, float _44) 
{
    if (pd3dm) {

        pd3dm->_11 = _11;
        pd3dm->_12 = _12;
        pd3dm->_13 = _13;
        pd3dm->_14 = _14;
        pd3dm->_21 = _21;
        pd3dm->_22 = _22;
        pd3dm->_23 = _23;
        pd3dm->_24 = _24;
        pd3dm->_31 = _31;
        pd3dm->_32 = _32;
        pd3dm->_33 = _33;
        pd3dm->_34 = _34;
        pd3dm->_41 = _41;
        pd3dm->_42 = _42;
        pd3dm->_43 = _43;
        pd3dm->_44 = _44;
    }
}

//******************************************************************************
//
// Function:
//
//     SetView
//
// Description:
//
//     Align the given view matrix along the given direction and up vectors with
//     the position vector as the origin.
//
// Arguments:
//
//     LPD3DXMATRIX pd3dm       - View matrix to initialize
//
//     LPD3DXVECTOR3 pvPos      - View origin
//
//     LPD3DXVECTOR3 pvAt       - View interest vector
//
//     LPD3DXVECTOR3 pvUp       - View up vector
//
// Return Value:
//
//     Initialized view matrix.
//
//******************************************************************************
void SetView(LPD3DXMATRIX pd3dm, LPD3DXVECTOR3 pvPos, LPD3DXVECTOR3 pvAt, 
                                                      LPD3DXVECTOR3 pvUp) 
{
    D3DXVECTOR3  d, u, r;

    if (pd3dm && pvPos && pvAt && pvUp && !(*pvPos == *pvAt) 
                                 && !(*pvUp == D3DXVECTOR3(0.0f, 0.0f, 0.0f))) {

        D3DXVec3Normalize(&d, &(*pvAt - *pvPos));
        u = *pvUp;

        // Project the up vector into the plane of the direction vector
        D3DXVec3Normalize(&u, &(u - (d * D3DXVec3Dot(&u, &d))));

        // Get the cross product
        D3DXVec3Cross(&r, &u, &d);

        // Initialize the view transform
        InitMatrix(pd3dm,
            r.x, u.x, d.x, 0.0f,
            r.y, u.y, d.y, 0.0f,
            r.z, u.z, d.z, 0.0f,
            -(pvPos->x * r.x + pvPos->y * r.y + pvPos->z * r.z), 
            -(pvPos->x * u.x + pvPos->y * u.y + pvPos->z * u.z), 
            -(pvPos->x * d.x + pvPos->y * d.y + pvPos->z * d.z), 
            1.0f
        );
    }
}

//******************************************************************************
//
// Function:
//
//     SetPerspectiveProjection
//
// Description:
//
//     Initialize the given projection matrix using the given front and back
//     clipping planes, field of view, and aspect ratio.
//
// Arguments:
//
//     LPD3DMATRIX pd3dm        - Projection matrix to initialize
//
//     float fFront             - Front clipping plane
//
//     float fBack              - Back clipping plane
//
//     float fFieldOfView       - Angle, in radians, of the field of view
//
//     float fAspect            - Aspect ratio (y / x) of the view plane
//
// Return Value:
//
//     Initialized projection matrix.
//
//******************************************************************************
void SetPerspectiveProjection(D3DMATRIX* pd3dm, float fFront, float fBack, 
                                    float fFieldOfView, float fAspect) {

    float fTanHalfFOV = (float)tan((double)fFieldOfView / 2.0);
    float fFar = fBack / (fBack - fFront);

    InitMatrix(pd3dm,
        1.0f, 0.0f,           0.0f,                         0.0f,
        0.0f, 1.0f / fAspect, 0.0f,                         0.0f,
        0.0f, 0.0f,           fTanHalfFOV * fFar,           fTanHalfFOV,
        0.0f, 0.0f,           -fFront * fTanHalfFOV * fFar, 0.0f
    );
}

//******************************************************************************
//
// Function:
//
//     SetParallelProjection
//
// Description:
//
//     Initialize the given projection matrix using the given front and back
//     clipping planes, field of view, and aspect ratio.
//
// Arguments:
//
//     LPD3DMATRIX pd3dm        - Projection matrix to initialize
//
//     float fFront             - Front clipping plane
//
//     float fBack              - Back clipping plane
//
//     float fFieldOfView       - Angle, in radians, of the field of view
//
//     float fAspect            - Aspect ratio (y / x) of the view plane
//
// Return Value:
//
//     Initialized projection matrix.
//
//******************************************************************************
void SetParallelProjection(D3DMATRIX* pd3dm, float fFront, float fBack, 
                                    float fWidth, float fHeight) {

//    float    f2FOV = fFieldOfView + fFieldOfView;
//    float    fFar = fBack - fFront;

    InitMatrix(pd3dm,
        2.0f / fWidth, 0.0f, 0.0f, 0.0f,
        0.0f, 2.0f / fHeight, 0.0f, 0.0f,
        0.0f, 0.0f, 1.0f / (fBack - fFront), 0.0f,
        0.0f, 0.0f, fFront / (fFront - fBack), 1.0f
    );
/*
    InitMatrix(pd3dm,
        1.0f, 0.0f, 0.0f,   0.0f,
        0.0f, 1.0f, 0.0f,   0.0f,
        0.0f, 0.0f, 0.001f, 0.0f,
        0.0f, 0.0f, 0.5f,   1.0f
    );
*/
/*
    InitMatrix(pd3dm,
        2.0f / f2FOV, 0.0f, 0.0f, 0.0f,
        0.0f, 2.0f / f2FOV, 0.0f, 0.0f,
        0.0f, 0.0f, 1.0f / fFar, 0.0f,
        0.0f, 0.0f, -fFront / fFar, 1.0f
    );
*/
}

} // namespace D3DBVT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\exe\sources.inc ===
TARGETNAME=d3dbvt
TARGETTYPE=PROGRAM
TARGETPATH=obj

!include ..\..\..\sources.inc

UMRES=$(TEST_RES_PATH)\d3dbvt.res

TARGETLIBS=\
    $(TARGETLIBS) \
    $(TEST_LIB_PATH)\l_d3dbvt.lib

SOURCES=\
    main.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\vertbuf8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    vertbuf8.cpp

Description:

    IDirect3DVertexBuffer8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IDirect3DVertexBuffer8 inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TVRB8_GetDesc(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVERTEXBUFFER8 pd3dr;
    D3DVERTEXBUFFER_DESC    d3drd;
    HRESULT                 hr;
    TRESULT                 tr = TR_PASS;

    pd3dr = GetVertexBuffer8();
    if (!pd3dr) {
        return TR_ABORT;
    }

    hr = pd3dr->GetDesc(&d3drd);
    if (ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::GetDesc"))) {
        return TR_FAIL;
    }

#ifndef UNDER_XBOX

    if (d3drd.FVF != VERTBUFFFORMAT) {
        Log(LOG_FAIL, TEXT("IDirect3DVertexBuffer8::GetDesc returned an incorrect buffer FVF"));
        tr = TR_FAIL;
    }

    if (d3drd.Size != VERTBUFFSIZE) {
        Log(LOG_FAIL, TEXT("IDirect3DVertexBuffer8::GetDesc returned an incorrect buffer size"));
        tr = TR_FAIL;
    }

    if (d3drd.Pool != D3DPOOL_MANAGED) {
        Log(LOG_FAIL, TEXT("IDirect3DVertexBuffer8::GetDesc returned an incorrect buffer pool"));
        tr = TR_FAIL;
    }

    if (d3drd.Usage != 0) {
        Log(LOG_FAIL, TEXT("IDirect3DVertexBuffer8::GetDesc returned an incorrect buffer usage"));
        tr = TR_FAIL;
    }

#endif

    if (d3drd.Type != D3DRTYPE_VERTEXBUFFER) {
        Log(LOG_FAIL, TEXT("IDirect3DVertexBuffer8::GetDesc returned an incorrect buffer type"));
        tr = TR_FAIL;
    }

    if (d3drd.Format != D3DFMT_VERTEXDATA) {
        Log(LOG_FAIL, TEXT("IDirect3DVertexBuffer8::GetDesc returned an incorrect buffer format"));
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TVRB8_Lock(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVERTEXBUFFER8 pd3dr;

    pd3dr = GetVertexBuffer8();
    if (!pd3dr) {
        return TR_ABORT;
    }

    return TSHR8_Lock(ptte, (LPVOID)pd3dr);
}

//******************************************************************************
TESTPROCAPI TVRB8_Unlock(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVERTEXBUFFER8 pd3dr;

    pd3dr = GetVertexBuffer8();
    if (!pd3dr) {
        return TR_ABORT;
    }

    return TSHR8_Unlock(ptte, (LPVOID)pd3dr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\dll\main.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    main.cpp

Description:

    Direct3D Build Verification Tests.

*******************************************************************************/

#include <xtl.h>
#ifdef UNDER_XBOX
#include "xtestlib.h"
#endif // UNDER_XBOX
#include "..\log.h"

using namespace D3DBVT;

//******************************************************************************
// Globals
//******************************************************************************

HINSTANCE                   g_hInst;
LONG                        g_lNumThreads = 0;

//******************************************************************************
// Function prototypes
//******************************************************************************

extern void                 ExecuteTests(HINSTANCE hInstance, HANDLE hLog);

//******************************************************************************
// DllMain
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     DllMain
//
// Description:
//
//     Entry point for the library.
//
// Arguments:
//
//     HINSTANCE hInstance      - Library instance handle
//
//     DWORD dwReason           - Reason the function is being called
//
//     LPVOID pvReserved        - Reserved
//
// Return Value:
//
//     When DllMain is called with DLL_PROCESS_ATTACH, TRUE is returned if
//     initialization succeeded and FALSE is returned if it failed.  The
//     return value is ignored for all other reasons.
//
//******************************************************************************
BOOL WINAPI d3dbvt_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved) {

    switch (dwReason) {

        case DLL_PROCESS_ATTACH: {
            // Allow global access to the instance handle
            g_hInst = hInstance;
            break;
        }

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}

//******************************************************************************
void WINAPI d3dbvt_StartTest(HANDLE hLog) {

    HANDLE hMutex;

    // If any other Direct3D test is running, block until it is finished
#ifndef UNDER_XBOX
    hMutex = CreateMutex(NULL, FALSE, TEXT("XBox Direct3D Test"));
#else
    hMutex = CreateMutex(NULL, FALSE, "XBox Direct3D Test");
#endif // UNDER_XBOX
    if (!hMutex) {
        DebugString(TEXT("CreateMutex failed [%d]"), GetLastError());
        return;
    }

    if (WaitForSingleObject(hMutex, INFINITE) != WAIT_OBJECT_0) {
        DebugString(TEXT("The test mutex was abandoned"));
        CloseHandle(hMutex);
        return;
    }

    // Ensure no other threads can run this test
    if (InterlockedIncrement(&g_lNumThreads) == 1) {
        ExecuteTests(g_hInst, hLog);
        InterlockedDecrement(&g_lNumThreads);
    }
    else {
        OutputDebugString(TEXT("The Direct3D BVTs are single-threaded only\n"));
    }

    ReleaseMutex(hMutex);
    CloseHandle(hMutex);
}

//******************************************************************************
void WINAPI d3dbvt_EndTest(void) {
}

#pragma data_seg(EXPORT_SECTION_NAME)
extern EXP_TABLE_ENTRY d3dbvt_ExportTableEntry[];
__EXTRN_C EXP_TABLE_DIRECTORY d3dbvt_ExportTableDirectory = {
    "d3dbvt",
    d3dbvt_ExportTableEntry
};
#pragma data_seg()

__EXTRN_C EXP_TABLE_ENTRY d3dbvt_ExportTableEntry[] = {
    { "StartTest", (PROC)d3dbvt_StartTest },
    { "EndTest",   (PROC)d3dbvt_EndTest },
    { "DllMain",   (PROC)d3dbvt_DllMain },
    { NULL, NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\exe\main.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    main.cpp

Description:

    Direct3D Build Verification Tests.

*******************************************************************************/

#include <xtl.h>

extern void                 ExecuteTests(HINSTANCE hInstance, HANDLE hLog);

//******************************************************************************
// WinMain
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     WinMain
//
// Description:
//
//     Entry point for the application.
//
// Arguments:
//
//     HINSTANCE hInstance      - Application instance handle
//
//     HINSTANCE hPrevInstance  - Previous instance of the application (always
//                                NULL for Win32 applications)
//
//     LPSTR szCmdLine          - Pointer to a string specifying the command
//                                line used in launching the application
//                                (excluding the program name)
//
//     int nCmdShow             - State specifying how the window is to be 
//                                displayed on creation
//
// Return Value:
//
//     0 on success, -1 on failure.
//
//******************************************************************************
#ifndef UNDER_XBOX
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, int nCmdShow) {
    ExecuteTests(hInstance, INVALID_HANDLE_VALUE);
    return 0;
}
#else
void __cdecl main() {
    ExecuteTests(NULL, INVALID_HANDLE_VALUE);
}
#endif // UNDER_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\util.h ===
/*******************************************************************************

Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

File Name:

    util.h

Description:

    Utility functions.

*******************************************************************************/

#ifndef __UTIL_H__
#define __UTIL_H__

//******************************************************************************
// Precomputed fractions of pi
//******************************************************************************

#define M_PI        3.14159265359f
#define M_2PI       6.28318530718f
#define M_PIDIV2    1.57079632680f
#define M_3PIDIV2   4.71238898039f
#define M_PIDIV4    0.78539816340f
#define M_3PIDIV4   2.35619449019f
#define M_5PIDIV4   3.92699081699f
#define M_7PIDIV4   5.49778714378f

//******************************************************************************
// Macros
//******************************************************************************

#define RND()       ((float)rand() / (float)RAND_MAX)
#define FRND(x)     (RND() * (x))
#define NRND()      (-1.0f + 2.0f * RND())
#define FABS(x)     ((x) < 0.0f ? -(x) : (x))

#ifndef RGB_MAKE
/*
 * Format of CI colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |         color index           |   fraction    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define CI_GETALPHA(ci)    ((ci) >> 24)
#define CI_GETINDEX(ci)    (((ci) >> 8) & 0xffff)
#define CI_GETFRACTION(ci) ((ci) & 0xff)
#define CI_ROUNDINDEX(ci)  CI_GETINDEX((ci) + 0x80)
#define CI_MASKALPHA(ci)   ((ci) & 0xffffff)
#define CI_MAKE(a, i, f)    (((a) << 24) | ((i) << 8) | (f))

/*
 * Format of RGBA colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGBA_GETALPHA(rgb)      ((rgb) >> 24)
#define RGBA_GETRED(rgb)        (((rgb) >> 16) & 0xff)
#define RGBA_GETGREEN(rgb)      (((rgb) >> 8) & 0xff)
#define RGBA_GETBLUE(rgb)       ((rgb) & 0xff)
#define RGBA_MAKE(r, g, b, a)   ((D3DCOLOR) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b)))

/* D3DRGB and D3DRGBA may be used as initialisers for D3DCOLORs
 * The float values must be in the range 0..1
 */
#define D3DRGB(r, g, b) \
    (0xff000000L | ( ((long)((r) * 255)) << 16) | (((long)((g) * 255)) << 8) | (long)((b) * 255))
#define D3DRGBA(r, g, b, a) \
    (   (((long)((a) * 255)) << 24) | (((long)((r) * 255)) << 16) \
    |   (((long)((g) * 255)) << 8) | (long)((b) * 255) \
    )

/*
 * Format of RGB colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    ignored    |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGB_GETRED(rgb)         (((rgb) >> 16) & 0xff)
#define RGB_GETGREEN(rgb)       (((rgb) >> 8) & 0xff)
#define RGB_GETBLUE(rgb)        ((rgb) & 0xff)
#define RGBA_SETALPHA(rgba, x) (((x) << 24) | ((rgba) & 0x00ffffff))
#define RGB_MAKE(r, g, b)       ((D3DCOLOR) (((r) << 16) | ((g) << 8) | (b)))
#define RGBA_TORGB(rgba)       ((D3DCOLOR) ((rgba) & 0xffffff))
#define RGB_TORGBA(rgb)        ((D3DCOLOR) ((rgb) | 0xff000000))

#endif

namespace D3DBVT {

//******************************************************************************
// Memory allocation prototypes
//******************************************************************************

BOOL                CreateHeap();
void                ReleaseHeap();
LPVOID              MemAlloc(UINT uNumBytes);
void                MemFree(LPVOID pvMem);
LPVOID              MemAlloc32(UINT uNumBytes);
void                MemFree32(LPVOID pvMem);

//******************************************************************************
// Matrix utility function prototypes
//******************************************************************************

void                InitMatrix(D3DMATRIX* pd3dm,
                        float _11, float _12, float _13, float _14,
                        float _21, float _22, float _23, float _24,
                        float _31, float _32, float _33, float _34,
                        float _41, float _42, float _43, float _44);

void                SetView(LPD3DXMATRIX pd3dm, LPD3DXVECTOR3 pvPos, 
                        LPD3DXVECTOR3 pvAt, LPD3DXVECTOR3 pvUp);

void                SetPerspectiveProjection(D3DMATRIX* pd3dm, float fFront, 
                        float fBack, float fFieldOfView, float fAspect);

void                SetParallelProjection(D3DMATRIX* pd3dm, float fFront, 
                        float fBack, float fFieldOfView, float fAspect);

//******************************************************************************
// Miscellaneous functions
//******************************************************************************

inline DWORD        F2DW(float f) {return *((LPDWORD)&f);}

} // namespace D3DBVT

#endif // __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\voltex8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    voltex8.cpp

Description:

    IDirect3DVolumeTexture8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IDirect3DVolumeTexture8 inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TVTX8_GetLevelDesc(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUMETEXTURE8    pd3dtv;
    D3DVOLUME_DESC              d3dvd;
    UINT                        uLevels;
    UINT                        uLength;
    UINT                        i;
    HRESULT                     hr;
    TRESULT                     tr = TR_PASS;

    pd3dtv = GetVolumeTexture8();
    if (!pd3dtv) {
        return TR_ABORT;
    }

    for (uLevels = 1; 0x1 << (uLevels - 1) != TEXTUREDIM; uLevels++);

    for (i = 0; i < uLevels; i++) {

        LogBeginVariation(TEXT("%s::GetLevelDesc on volume texture level %d"), ptte->szInterface, i);

        hr = pd3dtv->GetLevelDesc(i, &d3dvd);
        if (ResultFailed(hr, TEXT("IDirect3DVolumeTexture8::GetLevelDesc"))) {
            return TR_FAIL;
        }

        uLength = (0x1 << ((uLevels - 1) - i));

        if (d3dvd.Width != uLength) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect width of %d instead of %d for level %d"), ptte->szInterface, d3dvd.Width, uLength, i);
            tr = TR_FAIL;
        }

        if (d3dvd.Height != uLength) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect height of %d instead of %d for level %d"), ptte->szInterface, d3dvd.Height, uLength, i);
            tr = TR_FAIL;
        }

        if (d3dvd.Depth != uLength) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect depth of %d instead of %d for level %d"), ptte->szInterface, d3dvd.Depth, uLength, i);
            tr = TR_FAIL;
        }

        if (d3dvd.Size < uLength * uLength * 2) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect size of %d for level %d"), ptte->szInterface, d3dvd.Size, i);
            tr = TR_FAIL;
        }

#ifndef UNDER_XBOX

        if (d3dvd.Pool != D3DPOOL_MANAGED) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect pool for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }

#endif

        if (d3dvd.Usage != 0) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect usage for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }

        if (d3dvd.Type != D3DRTYPE_VOLUMETEXTURE) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect type for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }

        if (d3dvd.Format != D3DFMT_A1R5G5B5) {
            Log(LOG_FAIL, TEXT("%s::GetLevelDesc returned an incorrect format for level %d"), ptte->szInterface, i);
            tr = TR_FAIL;
        }

        LogEndVariation();
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TVTX8_LockBox(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUMETEXTURE8 pd3dtv;

    pd3dtv = GetVolumeTexture8();
    if (!pd3dtv) {
        return TR_ABORT;
    }

    return TSHR8_LockBox(ptte, (LPVOID)pd3dtv);
}

//******************************************************************************
TESTPROCAPI TVTX8_UnlockBox(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUMETEXTURE8 pd3dtv;

    pd3dtv = GetVolumeTexture8();
    if (!pd3dtv) {
        return TR_ABORT;
    }

    return TSHR8_UnlockBox(ptte, (LPVOID)pd3dtv);
}

#ifndef UNDER_XBOX

//******************************************************************************
TESTPROCAPI TVTX8_AddDirtyBox(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUMETEXTURE8 pd3dtv;
    D3DBOX                   box, *pbox[2];
    UINT                     i;
    HRESULT                  hr;
    TRESULT                  tr = TR_PASS;

    pd3dtv = GetVolumeTexture8();
    if (!pd3dtv) {
        return TR_ABORT;
    }

    box.Left = 11;
    box.Top = 9;
    box.Front = 21;
    box.Right = 12;
    box.Bottom = 17;
    box.Back = 37;
    pbox[0] = NULL;
    pbox[1] = &box;

    for (i = 0; i < 2; i++) {

        LogBeginVariation(TEXT("IDirect3DVolumeTexture8::AddDirtyBox on a %sbox"), i ? TEXT("sub") : TEXT("NULL "));

        hr = pd3dtv->AddDirtyBox(pbox[i]);
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::AddDirtyBox failed [0x%X]"), ptte->szInterface, hr);
            tr = TR_FAIL;
        }

        LogEndVariation();
    }

    return tr;
}

#endif // !UNDER_XBOX

//******************************************************************************
TESTPROCAPI TVTX8_GetVolumeLevel(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUMETEXTURE8    pd3dtv;
    LPDIRECT3DVOLUME8           pd3dv, pd3dv2;
    D3DVOLUME_DESC              d3dvd;
    ULONG                       uRef1, uRef2;
    UINT                        uLevels;
    UINT                        uLength;
    UINT                        i;
    HRESULT                     hr;
    TRESULT                     tr = TR_PASS;

    pd3dtv = GetVolumeTexture8();
    if (!pd3dtv) {
        return TR_ABORT;
    }

    for (uLevels = 1; 0x1 << (uLevels - 1) != TEXTUREDIM; uLevels++);

    for (i = 0; i < uLevels; i++) {

        LogBeginVariation(TEXT("IDirect3DVolumeTexture8::GetVolumeLevel on volume level %d"), i);

        hr = pd3dtv->GetVolumeLevel(i, &pd3dv);
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::%s failed for level %d [0x%X]"), ptte->szInterface, ptte->szMethod, i, hr);
            return TR_FAIL;
        }

        pd3dv->AddRef();
        uRef1 = pd3dv->Release();

        hr = pd3dtv->GetVolumeLevel(i, &pd3dv2);
        if (FAILED(hr)) {
            Log(LOG_FAIL, TEXT("%s::%s failed for level %d [0x%X]"), ptte->szInterface, ptte->szMethod, i, hr);
            pd3dv->Release();
            return TR_FAIL;
        }

#ifndef UNDER_XBOX
        if (pd3dv2 != pd3dv) {
            Log(LOG_FAIL, TEXT("%s::%s returned an incorrect volume pointer for level %d"), ptte->szInterface, ptte->szMethod, i);
            tr = TR_FAIL;
        }
#endif // !UNDER_XBOX

        pd3dv->AddRef();
        uRef2 = pd3dv->Release();

#ifndef UNDER_XBOX
        if (uRef2 != uRef1 + 1) {
            Log(LOG_FAIL, TEXT("%s::%s failed to increment the reference count of the volume for level %d"), ptte->szInterface, ptte->szMethod, i);
        }
#endif // !UNDER_XBOX

        pd3dv2->Release();

        hr = pd3dv->GetDesc(&d3dvd);
        pd3dv->Release();

        if (ResultFailed(hr, TEXT("IDirect3DVolume8::GetDesc"))) {
            tr = TR_FAIL;
        }
        else {

            uLength = (0x1 << ((uLevels - 1) - i));

            if (d3dvd.Width != uLength) {
                Log(LOG_FAIL, TEXT("IDirect3DVolume8::GetDesc returned an incorrect width of %d instead of %d for level %d"), ptte->szInterface, d3dvd.Width, uLength, i);
                tr = TR_FAIL;
            }

            if (d3dvd.Height != uLength) {
                Log(LOG_FAIL, TEXT("IDirect3DVolume8::GetDesc returned an incorrect height of %d instead of %d for level %d"), ptte->szInterface, d3dvd.Height, uLength, i);
                tr = TR_FAIL;
            }

            if (d3dvd.Depth != uLength) {
                Log(LOG_FAIL, TEXT("IDirect3DVolume8::GetDesc returned an incorrect depth of %d instead of %d for level %d"), ptte->szInterface, d3dvd.Depth, uLength, i);
                tr = TR_FAIL;
            }

            if (d3dvd.Size < uLength * uLength * uLength * 2) {
                Log(LOG_FAIL, TEXT("IDirect3DVolume8::GetDesc returned an incorrect size of %d for level %d"), ptte->szInterface, d3dvd.Size, i);
                tr = TR_FAIL;
            }

#ifndef UNDER_XBOX

            if (d3dvd.Pool != D3DPOOL_MANAGED) {
                Log(LOG_FAIL, TEXT("IDirect3DVolume8::GetDesc returned an incorrect pool for level %d"), ptte->szInterface, i);
                tr = TR_FAIL;
            }

#endif

            if (d3dvd.Usage != 0) {
                Log(LOG_FAIL, TEXT("IDirect3DVolume8::GetDesc returned an incorrect usage for level %d"), ptte->szInterface, i);
                tr = TR_FAIL;
            }

            if (d3dvd.Type != D3DRTYPE_VOLUME) {
                Log(LOG_FAIL, TEXT("IDirect3DVolume8::GetDesc returned an incorrect type for level %d"), ptte->szInterface, i);
                tr = TR_FAIL;
            }

            if (d3dvd.Format != D3DFMT_A1R5G5B5) {
                Log(LOG_FAIL, TEXT("IDirect3DVolume8::GetDesc returned an incorrect format for level %d"), ptte->szInterface, i);
                tr = TR_FAIL;
            }
        }

        LogEndVariation();
    }

    return tr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\dll\sources.inc ===
!include ..\..\..\sources.inc

TARGETNAME=d3dbvt
TARGETTYPE=LIBRARY
TARGETPATH=$(TEST_LIB_DEST)

TARGETLIBS=\
    $(TARGETLIBS) \
    $(TEST_LIB_PATH)\l_d3dbvt.lib

SOURCES=\
    main.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\bvt\volume8.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    volume8.cpp

Description:

    IDirect3DVolume8 interface BVTs.

*******************************************************************************/

#ifndef UNDER_XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif // UNDER_XBOX
#include <tchar.h>
#include <d3dx8.h>
#include "d3dbvt.h"
#include "log.h"

#ifdef UNDER_XBOX
#define DEMO_HACK
#endif

using namespace D3DBVT;

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//******************************************************************************
// IDirect3DVolume8 inteface tests
//******************************************************************************

//******************************************************************************
TESTPROCAPI TVOL8_GetContainer(PTESTTABLEENTRY ptte) {

    LPVOID                  pvContainer1, pvContainer2 = DEAD_PTR,
                            pvContainer3;
    LPDIRECT3DVOLUME8       pd3dv = NULL;
    ULONG                   uRef1, uRef2;
    HRESULT                 hr1, hr2;
    TRESULT                 tr = TR_PASS;

    pd3dv = GetVolume8((LPDIRECT3DVOLUMETEXTURE8*)&pvContainer3);
    if (!pd3dv) {
        return TR_ABORT;
    }

    ((IDirect3DVolumeTexture8*)pvContainer3)->AddRef();
    uRef1 = ((IDirect3DVolumeTexture8*)pvContainer3)->Release();

#ifndef UNDER_XBOX
    hr1 = pd3dv->GetContainer(IID_IDirect3DVolumeTexture8, &pvContainer1);
    hr2 = pd3dv->GetContainer(IID_IDirect3DTexture8, &pvContainer2);
#else
    hr1 = pd3dv->GetContainer((LPDIRECT3DBASETEXTURE8*)&pvContainer1);
#endif // UNDER_XBOX

    if (FAILED(hr1)) {
        Log(LOG_FAIL, TEXT("%s::GetContainer failed [0x%X]"), ptte->szInterface, hr1);
        return TR_FAIL;
    }
#ifndef UNDER_XBOX
    if (SUCCEEDED(hr2)) {
        Log(LOG_FAIL, TEXT("%s::GetContainer(IID_IDirect3DTexture8, ...) succeeded on a volume texture surface"), ptte->szInterface);
        tr = TR_FAIL;
    }

    if (pvContainer2 != NULL) {
        Log(LOG_FAIL, TEXT("%s::GetContainer failed to clean the given container pointer when given an invalid reference identifier"), ptte->szInterface);
        tr = TR_FAIL;
    }
#endif // !UNDER_XBOX

    ((IDirect3DVolumeTexture8*)pvContainer3)->AddRef();
    uRef2 = ((IDirect3DVolumeTexture8*)pvContainer3)->Release();

    if (uRef2 != uRef1 + 1) {
        Log(LOG_FAIL, TEXT("%s::GetContainer failed to increment the reference count of the container object"), ptte->szInterface);
        tr = TR_FAIL;
    }

    ((IDirect3DVolumeTexture8*)pvContainer3)->Release();

    if (pvContainer1 != pvContainer3) {
        Log(LOG_FAIL, TEXT("%s::GetContainer returned an incorrect pointer to the container object: 0x%X"), ptte->szInterface, pvContainer1);
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TVOL8_GetDevice(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUME8   pd3dv;

    pd3dv = GetVolume8();
    if (!pd3dv) {
        return TR_ABORT;
    }

    return TSHR8_GetDevice(ptte, (LPVOID)pd3dv);
}

//******************************************************************************
TESTPROCAPI TVOL8_GetDesc(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUME8        pd3dv;
    LPDIRECT3DVOLUMETEXTURE8 pd3dtv;
    D3DVOLUME_DESC           d3dvd1, d3dvd2;
    HRESULT                  hr;
    TRESULT                  tr = TR_PASS;

    pd3dv = GetVolume8(&pd3dtv);
    if (!pd3dv) {
        return TR_ABORT;
    }

    hr = pd3dtv->GetLevelDesc(0, &d3dvd1);
    if (ResultFailed(hr, TEXT("IDirect3DVolumeTexture8::GetLevelDesc"))) {
        return TR_ABORT;
    }

    hr = pd3dv->GetDesc(&d3dvd2);
    if (ResultFailed(hr, TEXT("IDirect3DVolume8::GetDesc"))) {
        return TR_FAIL;
    }

    if (d3dvd1.Format != d3dvd2.Format ||
        d3dvd1.Usage != d3dvd2.Usage ||
        d3dvd1.Size != d3dvd2.Size ||
        d3dvd1.Width != d3dvd2.Width ||
        d3dvd1.Height != d3dvd2.Height ||
        d3dvd1.Depth != d3dvd2.Depth)
    {
        Log(LOG_FAIL, TEXT("IDirect3DVolume8::GetDesc returned an incorrect volume description"));
        tr = TR_FAIL;
    }

    return tr;
}

//******************************************************************************
TESTPROCAPI TVOL8_LockBox(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUME8   pd3dv;

    pd3dv = GetVolume8();
    if (!pd3dv) {
        return TR_ABORT;
    }

    return TSHR8_LockBox(ptte, (LPVOID)pd3dv);
}

//******************************************************************************
TESTPROCAPI TVOL8_UnlockBox(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUME8   pd3dv;

    pd3dv = GetVolume8();
    if (!pd3dv) {
        return TR_ABORT;
    }

    return TSHR8_UnlockBox(ptte, (LPVOID)pd3dv);
}

//******************************************************************************
TESTPROCAPI TVOL8_GetPrivateData(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUME8   pd3dv;

    pd3dv = GetVolume8();
    if (!pd3dv) {
        return TR_ABORT;
    }

    return TSHR8_GetPrivateData(ptte, (LPVOID)pd3dv);
}

//******************************************************************************
TESTPROCAPI TVOL8_SetPrivateData(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUME8   pd3dv;

    pd3dv = GetVolume8();
    if (!pd3dv) {
        return TR_ABORT;
    }

    return TSHR8_SetPrivateData(ptte, (LPVOID)pd3dv);
}

//******************************************************************************
TESTPROCAPI TVOL8_FreePrivateData(PTESTTABLEENTRY ptte) {

    LPDIRECT3DVOLUME8   pd3dv;

    pd3dv = GetVolume8();
    if (!pd3dv) {
        return TR_ABORT;
    }

    return TSHR8_FreePrivateData(ptte, (LPVOID)pd3dv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\mirror.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "cshapes.h"
#include "Address.h"

//************************************************************************
// Mirror Test functions

CMirrorTest::CMirrorTest()
{
	m_szTestName = TEXT("Texture Address Mirror");
	m_szCommandKey = TEXT("Mirror");

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_MIRROR;
	dwAddressCapV = D3DPTADDRESSCAPS_MIRROR;
}

CMirrorTest::~CMirrorTest()
{
}

bool CMirrorTest::SetDefaultRenderStates(void)
{
	// Turn on Mirror addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_MIRROR);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_MIRROR);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESS, (DWORD)D3DTADDRESS_MIRROR);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\modulex.h ===
#define PREPEND_MODULE(Suffix) address##Suffix
#define MODULE_STRING "address"
#pragma comment(linker, "/include:_address_ExhibitScene@8")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\clamp.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "cshapes.h"
#include "Address.h"

//************************************************************************
// Clamp Test functions

CClampTest::CClampTest()
{
	m_szTestName = TEXT("Texture Address Clamp");
	m_szCommandKey = TEXT("Clamp");

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_CLAMP;
	dwAddressCapV = D3DPTADDRESSCAPS_CLAMP;
}

CClampTest::~CClampTest()
{
}

bool CClampTest::SetDefaultRenderStates(void)
{
	// Turn on Clamp addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESS, (DWORD)D3DTADDRESS_CLAMP);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\drawmesh.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "cshapes.h"
#include "Address.h"

//************************************************************************
// Internal API:    DrawGrid
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CAddressTest::DrawGrid(int nTest)
{
	int nRot, nTile, nGroup;
	float fZero, fOne;
	static DWORD dwDefault = 99;

	// Decide which group of tests we are in
	nGroup = nTest % 20;

	if (nGroup == 0)
		nGroup = 20;

	// Decide which rotation to use
	nRot = (nGroup-1) / 5;

	// Decide how much tiling to use
	nTile = nGroup - (nRot * 5);
 
	if (((nTest-1) / 20) == 0)
	{
		// Use (0,0) to (1,1) mapping
		fOne =  nTile * 1.0f;
		fZero = 0.0f;
	}
	else
	{
		// Use (-1,-1) to (1,1) mapping
		fOne =  nTile * 1.0f;
		fZero = nTile * -1.0f;
	}

	// Setup the mesh
	switch (nRot)
	{
		case (0): // Use ((1,0)(1,1)(0,0)(0,1)) mapping, White Mesh
			if (bBorder)
			{
				if (dwDefault == 99)
				{
					if (m_dwVersion >= 0x0700)
						GetTextureStageState(0, D3DTSS_BORDERCOLOR, NULL, &dwDefault, CD3D_REF);
//					else
//						m_pRefDevice3->GetRenderState(D3DRENDERSTATE_BORDERCOLOR, &dwDefault);
				}

				wsprintf(msgString, TEXT("%sDefault, "),msgString);
                m_pDevice->SetTextureStageState(0, D3DTSS_BORDERCOLOR, dwDefault);
//				SetRenderState(D3DRENDERSTATE_BORDERCOLOR, dwDefault);
			}

			if (fZero == 0.0f)
				wsprintf(msgString, TEXT("%sMap:(%d,0)(%d,%d)(0,0)(0,%d), "),msgString,nTile,nTile,nTile,nTile);
			else
				wsprintf(msgString, TEXT("%sMap:(%d,%d)(%d,%d)(%d,%d)(%d,%d), "),msgString,nTile,-nTile,nTile,nTile,-nTile,-nTile,-nTile,nTile);

			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			break;
		case (1): // Use standard ((0,0)(1,0)(0,1)(1,1)) mapping, White Mesh
			if (bBorder)
			{
				wsprintf(msgString, TEXT("%sBlue, "),msgString);
                m_pDevice->SetTextureStageState(0, D3DTSS_BORDERCOLOR, RGBA_MAKE(0,0,255,255));
//				SetRenderState(D3DRENDERSTATE_BORDERCOLOR, RGBA_MAKE(0,0,255,255));
			}

			if (fZero == 0.0f)
				wsprintf(msgString, TEXT("%sMap:(0,0)(%d,0)(0,%d)(%d,%d), "),msgString,nTile,nTile,nTile,nTile);
			else
				wsprintf(msgString, TEXT("%sMap:(%d,%d)(%d,%d)(%d,%d)(%d,%d), "),msgString,-nTile,-nTile,nTile,-nTile,-nTile,nTile,nTile,nTile);

			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			break;
		case (2): // Use ((0,1)(0,0)(1,1)(1,0)) mapping, White Mesh
			if (bBorder)
			{
				wsprintf(msgString, TEXT("%sRed, "),msgString);
                m_pDevice->SetTextureStageState(0, D3DTSS_BORDERCOLOR, RGBA_MAKE(255,0,0,255));
//				SetRenderState(D3DRENDERSTATE_BORDERCOLOR, RGBA_MAKE(255,0,0,255));
			}

			if (fZero == 0.0f)
				wsprintf(msgString, TEXT("%sMap:(0,%d)(0,0)(%d,%d)(%d,0), "),msgString,nTile,nTile,nTile,nTile);
			else
				wsprintf(msgString, TEXT("%sMap:(%d,%d)(%d,%d)(%d,%d)(%d,%d), "),msgString,-nTile,nTile,-nTile,-nTile,nTile,nTile,nTile,-nTile);

			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			break;
		case (3): // Use ((1,1)(0,1)(1,0)(0,0)) mapping, White Mesh
			if (bBorder)
			{
				wsprintf(msgString, TEXT("%sGreen, "),msgString);
                m_pDevice->SetTextureStageState(0, D3DTSS_BORDERCOLOR, RGBA_MAKE(0,255,0,255));
//				SetRenderState(D3DRENDERSTATE_BORDERCOLOR, RGBA_MAKE(0,255,0,255));
			}

			if (fZero == 0.0f)
				wsprintf(msgString, TEXT("%sMap:(%d,%d)(0,%d)(%d,0)(0,0), "),msgString,nTile,nTile,nTile,nTile);
			else
				wsprintf(msgString, TEXT("%sMap:(%d,%d)(%d,%d)(%d,%d)(%d,%d), "),msgString,nTile,nTile,-nTile,nTile,-nTile,nTile,-nTile,-nTile);

			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			break;
	}
}

//************************************************************************
// Internal API:    DrawWrapGrid
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CAddressTest::DrawWrapGrid(int nTest)
{
	float fZero, fOne;

	// Use (0,0) to (1,1) mapping
	fOne =  0.9f;
	fZero = 0.1f;

	// Setup the mesh
	switch (nTest)
	{
		case (1): // Use standard ((0,0)(1,0)(0,1)(1,1)) mapping, White Mesh
			wsprintf(msgString, TEXT("%sMap:(0,0)(1,0)(0,1)(1,1), "),msgString);

			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			break;
		case (2): // Use ((0,1)(0,0)(1,1)(1,0)) mapping, White Mesh
			wsprintf(msgString, TEXT("%sMap:(0,1)(0,0)(1,1)(1,0), "),msgString);

			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			break;
		case (3): // Use ((1,1)(0,1)(1,0)(0,0)) mapping, White Mesh
			wsprintf(msgString, TEXT("%sMap:(1,1)(0,1)(1,0)(0,0), "),msgString);

			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			break;
		case (4): // Use ((1,0)(1,1)(0,0)(0,1)) mapping, White Mesh
			wsprintf(msgString, TEXT("%sMap:(1,0)(1,1)(0,0)(0,1), "),msgString);

			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(  9.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fZero);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X,   9.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fOne, fOne);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(265.5f + (float)m_vpTest.X, 265.5f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255),0, fZero,fOne);
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\independentuv.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "cshapes.h"
#include "Address.h"

//************************************************************************
// WrapMirror Test functions

CWrapMirrorTest::CWrapMirrorTest()
{
	m_szTestName = TEXT("Texture Address WrapU MirrorV");
	m_szCommandKey = TEXT("WrapMirror");

	// Tell parent to check indpendent address modes
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_WRAP;
	dwAddressCapV = D3DPTADDRESSCAPS_MIRROR;

	// Give parent a printable name for the caps
	szAddrU = TEXT("WrapU");
	szAddrV = TEXT("MirrorV");
}

CWrapMirrorTest::~CWrapMirrorTest()
{
}

bool CWrapMirrorTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU MirrorV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_MIRROR);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_WRAP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_MIRROR);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// WrapClamp Test functions

CWrapClampTest::CWrapClampTest()
{
	m_szTestName = TEXT("Texture Address WrapU ClampV");
	m_szCommandKey = TEXT("WrapClamp");

	// Tell parent to check indpendent address modes
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_WRAP;
	dwAddressCapV = D3DPTADDRESSCAPS_CLAMP;

	// Give parent a printable name for the caps
	szAddrU = TEXT("WrapU");
	szAddrV = TEXT("ClampV");
}

CWrapClampTest::~CWrapClampTest()
{
}

bool CWrapClampTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU ClampV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_WRAP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_CLAMP);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// WrapBorder Test functions

CWrapBorderTest::CWrapBorderTest()
{
	m_szTestName = TEXT("Texture Address WrapU BorderV");
	m_szCommandKey = TEXT("WrapBorder");

	// Tell parent to use border colors and check indpendent address modes
	bBorder = true;
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_WRAP;
	dwAddressCapV = D3DPTADDRESSCAPS_BORDER;

	// Give parent a printable name for the caps
	szAddrU = TEXT("WrapU");
	szAddrV = TEXT("BorderV");
}

CWrapBorderTest::~CWrapBorderTest()
{
}

bool CWrapBorderTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU BorderV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_BORDER);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_WRAP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_BORDER);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// MirrorWrap Test functions

CMirrorWrapTest::CMirrorWrapTest()
{
	m_szTestName = TEXT("Texture Address MirrorU WrapV");
	m_szCommandKey = TEXT("MirrorWrap");

	// Tell parent to check indpendent address modes
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_MIRROR;
	dwAddressCapV = D3DPTADDRESSCAPS_WRAP;

	// Give parent a printable name for the caps
	szAddrU = TEXT("MirrorU");
	szAddrV = TEXT("WrapV");
}

CMirrorWrapTest::~CMirrorWrapTest()
{
}

bool CMirrorWrapTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU MirrorV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_MIRROR);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_MIRROR);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_WRAP);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// MirrorClamp Test functions

CMirrorClampTest::CMirrorClampTest()
{
	m_szTestName = TEXT("Texture Address MirrorU ClampV");
	m_szCommandKey = TEXT("MirrorClamp");

	// Tell parent to check indpendent address modes
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_MIRROR;
	dwAddressCapV = D3DPTADDRESSCAPS_CLAMP;

	// Give parent a printable name for the caps
	szAddrU = TEXT("MirrorU");
	szAddrV = TEXT("ClampV");
}

CMirrorClampTest::~CMirrorClampTest()
{
}

bool CMirrorClampTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU ClampV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_MIRROR);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_MIRROR);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_CLAMP);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// MirrorBorder Test functions

CMirrorBorderTest::CMirrorBorderTest()
{
	m_szTestName = TEXT("Texture Address MirrorU BorderV");
	m_szCommandKey = TEXT("MirrorBorder");

	// Tell parent to use border colors and check indpendent address modes
	bBorder = true;
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_MIRROR;
	dwAddressCapV = D3DPTADDRESSCAPS_BORDER;

	// Give parent a printable name for the caps
	szAddrU = TEXT("MirrorU");
	szAddrV = TEXT("BorderV");
}

CMirrorBorderTest::~CMirrorBorderTest()
{
}

bool CMirrorBorderTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU BorderV addressingaddressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_MIRROR);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_BORDER);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_MIRROR);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_BORDER);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// ClampWrap Test functions

CClampWrapTest::CClampWrapTest()
{
	m_szTestName = TEXT("Texture Address ClampU WrapV");
	m_szCommandKey = TEXT("ClampWrap");

	// Tell parent to check indpendent address modes
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_CLAMP;
	dwAddressCapV = D3DPTADDRESSCAPS_WRAP;

	// Give parent a printable name for the caps
	szAddrU = TEXT("ClampU");
	szAddrV = TEXT("WrapV");
}

CClampWrapTest::~CClampWrapTest()
{
}

bool CClampWrapTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU MirrorV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_CLAMP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_WRAP);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// ClampMirror Test functions

CClampMirrorTest::CClampMirrorTest()
{
	m_szTestName = TEXT("Texture Address ClampU MirrorV");
	m_szCommandKey = TEXT("ClampMirror");

	// Tell parent to check indpendent address modes
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_CLAMP;
	dwAddressCapV = D3DPTADDRESSCAPS_MIRROR;

	// Give parent a printable name for the caps
	szAddrU = TEXT("ClampU");
	szAddrV = TEXT("MirrorV");
}

CClampMirrorTest::~CClampMirrorTest()
{
}

bool CClampMirrorTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU ClampV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_MIRROR);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_CLAMP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_MIRROR);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// ClampBorder Test functions

CClampBorderTest::CClampBorderTest()
{
	m_szTestName = TEXT("Texture Address ClampU BorderV");
	m_szCommandKey = TEXT("ClampBorder");

	// Tell parent to use border colors and check indpendent address modes
	bBorder = true;
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_CLAMP;
	dwAddressCapV = D3DPTADDRESSCAPS_BORDER;

	// Give parent a printable name for the caps
	szAddrU = TEXT("ClampU");
	szAddrV = TEXT("BorderV");
}

CClampBorderTest::~CClampBorderTest()
{
}

bool CClampBorderTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU BorderV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_BORDER);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_CLAMP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_BORDER);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// BorderWrap Test functions

CBorderWrapTest::CBorderWrapTest()
{
	m_szTestName = TEXT("Texture Address BorderU WrapV");
	m_szCommandKey = TEXT("BorderWrap");

	// Tell parent to use border colors and check indpendent address modes
	bBorder = true;
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_BORDER;
	dwAddressCapV = D3DPTADDRESSCAPS_WRAP;

	// Give parent a printable name for the caps
	szAddrU = TEXT("BorderU");
	szAddrV = TEXT("WrapV");
}

CBorderWrapTest::~CBorderWrapTest()
{
}

bool CBorderWrapTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU MirrorV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_BORDER);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_BORDER);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_WRAP);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// BorderMirror Test functions

CBorderMirrorTest::CBorderMirrorTest()
{
	m_szTestName = TEXT("Texture Address BorderU MirrorV");
	m_szCommandKey = TEXT("BorderMirror");

	// Tell parent to use border colors and check indpendent address modes
	bBorder = true;
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_BORDER;
	dwAddressCapV = D3DPTADDRESSCAPS_MIRROR;

	// Give parent a printable name for the caps
	szAddrU = TEXT("BorderU");
	szAddrV = TEXT("MirrorV");
}

CBorderMirrorTest::~CBorderMirrorTest()
{
}

bool CBorderMirrorTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU ClampV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_BORDER);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_MIRROR);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_BORDER);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_MIRROR);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}

//************************************************************************
// BorderClamp Test functions

CBorderClampTest::CBorderClampTest()
{
	m_szTestName = TEXT("Texture Address BorderU ClampV");
	m_szCommandKey = TEXT("BorderClamp");

	// Tell parent to use border colors and check indpendent address modes
	bBorder = true;
	bIndependentUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_BORDER;
	dwAddressCapV = D3DPTADDRESSCAPS_CLAMP;

	// Give parent a printable name for the caps
	szAddrU = TEXT("BorderU");
	szAddrV = TEXT("ClampV");
}

CBorderClampTest::~CBorderClampTest()
{
}

bool CBorderClampTest::SetDefaultRenderStates(void)
{
	// Turn on WrapU BorderV addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_BORDER);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSU, (DWORD)D3DTADDRESS_BORDER);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESSV, (DWORD)D3DTADDRESS_CLAMP);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\address.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	Address.h
 *
 ***************************************************************************/

#ifndef __ADDRESS_H__
#define __ADDRESS_H__

//USETESTFRAME

// Defines
#define MAX_TESTS		40

// Class definition
class CAddressTest: public CD3DTest
{
    // Data
	public:
    D3DTLVERTEX     VertexList[6];
    DWORD           dwVertexCount;
	CTexture8 *		pTexture;
//	CImageData *	pImage;
	D3DCOLOR	    Gradient[4];
	DWORD			dwAddressCapU;
	DWORD			dwAddressCapV;
	LPCTSTR			szAddrU;
	LPCTSTR			szAddrV;
	bool			bIndependentUV;
	bool			bWrapUV;
	bool			bBorder;
	TCHAR			msgString[80];

    BOOL            m_bExit;

	public:
	CAddressTest();
	~CAddressTest();

	// Framework functions
	virtual UINT TestInitialize(void);
	virtual bool ClearFrame(void);
	virtual bool ExecuteTest(UINT);
	virtual void SceneRefresh(void);
	virtual bool ProcessFrame(void);
	virtual bool TestTerminate(void);

	// Helper functions
	void DrawGrid(int nTest);
	void DrawWrapGrid(int nTest);

    virtual BOOL    AbortedExit(void);

protected:

    virtual void    ProcessInput();
    virtual BOOL    WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, 
                        WPARAM wParam, LPARAM lParam);
};

// Wrap U Class definitions
class CWrapUTest: public CAddressTest
{
	public:
	CWrapUTest();
	~CWrapUTest();

	bool SetDefaultRenderStates(void);
};

// Wrap V Class definitions
class CWrapVTest: public CAddressTest
{
	public:
	CWrapVTest();
	~CWrapVTest();

	bool SetDefaultRenderStates(void);
};

// Wrap UV Class definitions
class CWrapUVTest: public CAddressTest
{
	public:
	CWrapUVTest();
	~CWrapUVTest();

	bool SetDefaultRenderStates(void);
};

// Wrap Class definitions
class CWrapTest: public CAddressTest
{
	public:
	CWrapTest();
	~CWrapTest();

	bool SetDefaultRenderStates(void);
};

// Mirror Class definitions
class CMirrorTest: public CAddressTest
{
	public:
	CMirrorTest();
	~CMirrorTest();

	bool SetDefaultRenderStates(void);
};

// Clamp Class definitions
class CClampTest: public CAddressTest
{
	public:
	CClampTest();
	~CClampTest();

	bool SetDefaultRenderStates(void);
};

// Border Class definitions
class CBorderTest: public CAddressTest
{
	public:
	CBorderTest();
	~CBorderTest();

	bool SetDefaultRenderStates(void);
};

// WrapMirror Class definitions
class CWrapMirrorTest: public CAddressTest
{
	public:
	CWrapMirrorTest();
	~CWrapMirrorTest();

	bool SetDefaultRenderStates(void);
};

// WrapClamp Class definitions
class CWrapClampTest: public CAddressTest
{
	public:
	CWrapClampTest();
	~CWrapClampTest();

	bool SetDefaultRenderStates(void);
};

// WrapBorder Class definitions
class CWrapBorderTest: public CAddressTest
{
	public:
	CWrapBorderTest();
	~CWrapBorderTest();

	bool SetDefaultRenderStates(void);
};

// MirrorWrap Class definitions
class CMirrorWrapTest: public CAddressTest
{
	public:
	CMirrorWrapTest();
	~CMirrorWrapTest();

	bool SetDefaultRenderStates(void);
};

// MirrorClamp Class definitions
class CMirrorClampTest: public CAddressTest
{
	public:
	CMirrorClampTest();
	~CMirrorClampTest();

	bool SetDefaultRenderStates(void);
};

// MirrorBorder Class definitions
class CMirrorBorderTest: public CAddressTest
{
	public:
	CMirrorBorderTest();
	~CMirrorBorderTest();

	bool SetDefaultRenderStates(void);
};

// ClampWrap Class definitions
class CClampWrapTest: public CAddressTest
{
	public:
	CClampWrapTest();
	~CClampWrapTest();

	bool SetDefaultRenderStates(void);
};

// ClampMirror Class definitions
class CClampMirrorTest: public CAddressTest
{
	public:
	CClampMirrorTest();
	~CClampMirrorTest();

	bool SetDefaultRenderStates(void);
};

// ClampBorder Class definitions
class CClampBorderTest: public CAddressTest
{
	public:
	CClampBorderTest();
	~CClampBorderTest();

	bool SetDefaultRenderStates(void);
};

// BorderWrap Class definitions
class CBorderWrapTest: public CAddressTest
{
	public:
	CBorderWrapTest();
	~CBorderWrapTest();

	bool SetDefaultRenderStates(void);
};

// BorderMirror Class definitions
class CBorderMirrorTest: public CAddressTest
{
	public:
	CBorderMirrorTest();
	~CBorderMirrorTest();

	bool SetDefaultRenderStates(void);
};

// BorderClamp Class definitions
class CBorderClampTest: public CAddressTest
{
	public:
	CBorderClampTest();
	~CBorderClampTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\border.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "cshapes.h"
#include "Address.h"

//************************************************************************
// Border Test functions

CBorderTest::CBorderTest()
{
	m_szTestName = TEXT("Texture Address Border");
	m_szCommandKey = TEXT("Border");

	// Tell parent to use border colors
	bBorder = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_BORDER;
	dwAddressCapV = D3DPTADDRESSCAPS_BORDER;
}

CBorderTest::~CBorderTest()
{
}

bool CBorderTest::SetDefaultRenderStates(void)
{
	// Turn on Border addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_BORDER);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_BORDER);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESS, (DWORD)D3DTADDRESS_BORDER);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\address.cpp ===
#define STRICT
#define BURN_IN_HELL
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "cshapes.h"
#include "Address.h"

// Global Test and App instance
//CD3DWindowFramework App;

//******************************************************************************
//
// Function:
//
//     ValidateDisplay
//
// Description:
//
//     Evaluate the given display information in order to determine whether or
//     not the display is capable of rendering the scene.  If not, the given 
//     display will not be included in the display list.
//
// Arguments:
//
//     CDirect3D8* pd3d                 - Pointer to the Direct3D object
//
//     D3DCAPS8* pd3dcaps               - Capabilities of the device
//
//     D3DDISPLAYMODE*                  - Display mode into which the device
//                                        will be placed
//
// Return Value:
//
//     TRUE if the scene can be rendered using the given display, FALSE if
//     it cannot.
//
//******************************************************************************
extern "C" BOOL PREPEND_MODULE(_ValidateDisplay)(CDirect3D8* pd3d, D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm) {

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     ExhibitScene
//
// Description:
//
//     Create the scene, pump messages, process user input,
//     update the scene, render the scene, and release the scene when finished.
//
// Arguments:
//
//     CDisplay* pDisplay           - Pointer to the Display object
//
//     int* pnExitCode              - Optional pointer to an integer that will
//                                    be set to the exit value contained in the 
//                                    wParam parameter of the WM_QUIT message 
//                                    (if received)
//
// Return Value:
//
//     TRUE if the display remains functional on exit, FALSE otherwise.
//
//******************************************************************************
extern "C" BOOL PREPEND_MODULE(_ExhibitScene)(CDisplay* pDisplay, int* pnExitCode) {

    CAddressTest* pAddrTest;
    BOOL          bQuit = FALSE, bRet = TRUE;
    UINT          i;

    // Verify that the display has been initialized
    if (!pDisplay) {
        return FALSE;
    }

    for (i = 0; i < 19 && !bQuit && bRet; i++) {

        // Create the scene
        switch (i) {
            case 0:
                pAddrTest = new CWrapUTest();
                break;
            case 1:
                pAddrTest = new CWrapVTest();
                break;
            case 2:
                pAddrTest = new CWrapUVTest();
                break;
            case 3:
                pAddrTest = new CWrapTest();
                break;
            case 4:
                pAddrTest = new CMirrorTest();
                break;
            case 5:
                pAddrTest = new CClampTest();
                break;
            case 6:
                pAddrTest = new CBorderTest();
                break;
            case 7:
                pAddrTest = new CWrapMirrorTest();
                break;
            case 8:
                pAddrTest = new CWrapClampTest();
                break;
            case 9:
                pAddrTest = new CWrapBorderTest();
                break;
            case 10:
                pAddrTest = new CMirrorWrapTest();
                break;
            case 11:
                pAddrTest = new CMirrorClampTest();
                break;
            case 12:
                pAddrTest = new CMirrorBorderTest();
                break;
            case 13:
                pAddrTest = new CClampWrapTest();
                break;
            case 14:
                pAddrTest = new CClampMirrorTest();
                break;
            case 15:
                pAddrTest = new CClampBorderTest();
                break;
            case 16:
                pAddrTest = new CBorderWrapTest();
                break;
            case 17:
                pAddrTest = new CBorderMirrorTest();
                break;
            case 18:
                pAddrTest = new CBorderClampTest();
                break;
        }

        if (!pAddrTest) {
            return FALSE;
        }

        // Initialize the scene
        if (!pAddrTest->Create(pDisplay)) {
            pAddrTest->Release();
            return FALSE;
        }

        bRet = pAddrTest->Exhibit(pnExitCode);

        bQuit = pAddrTest->AbortedExit();

        // Clean up the scene
        pAddrTest->Release();
    }

    return bRet;
}

CAddressTest::CAddressTest()
{
	// Init variables to false
	bBorder = false;
	bWrapUV = false;
	bIndependentUV = false;

	// Init the AddrU & AddrV strings to empty
	szAddrU = TEXT("");
	szAddrV = TEXT("");

    pTexture = NULL;

    m_bExit = FALSE;
}

CAddressTest::~CAddressTest()
{
    ReleaseTexture(pTexture);
    pTexture = NULL;
}

UINT CAddressTest::TestInitialize(void)
{
//    UINT n = m_pMode->nSrcDevice;

	// Setup the Test range
	if (bWrapUV)
		SetTestRange(1, 4);
//		SetTestRange(1, 4 * m_uCommonTextureFormats);
	else
		SetTestRange(1, MAX_TESTS);
//		SetTestRange(1, MAX_TESTS * m_uCommonTextureFormats);

	// Check the caps we are interested in
	DWORD dwTextureAddressCaps = m_d3dcaps.TextureAddressCaps;

	// Check the appropriate Address caps
	if (bIndependentUV)
	{
		if (!(dwTextureAddressCaps & D3DPTADDRESSCAPS_INDEPENDENTUV))
		{
			WriteToLog("Device capability not supported: Texture Address IndependentUV.\n");
			return D3DTESTINIT_SKIPALL;
		}

		if (!(dwTextureAddressCaps & dwAddressCapU))
		{
			WriteToLog("Device capability not supported: Texture Address %s.\n",szAddrU);
			return D3DTESTINIT_SKIPALL;
		}

		if (!(dwTextureAddressCaps & dwAddressCapV))
		{
			WriteToLog("Device capability not supported: Texture Address %s.\n",szAddrV);
			return D3DTESTINIT_SKIPALL;
		}
	}
	else if (!(dwTextureAddressCaps & dwAddressCapU) && !(dwTextureAddressCaps & dwAddressCapV))
	{
		WriteToLog("Device capability not supported: %s.\n",m_szTestName);
		return D3DTESTINIT_SKIPALL;
	}

	// Tell RenderPrimitive disable API cycling
	// m_dwPrimitives = 1; should be changed to something like 
    // SetAPI(RP_DP);

	// Setup the colors for the Gradient array
	Gradient[0] = RGBA_MAKE(0,0,0,255);		// Black
	Gradient[1] = RGBA_MAKE(255,0,0,255);	// Red
	Gradient[2] = RGBA_MAKE(0,255,0,255);	// Green
	Gradient[3] = RGBA_MAKE(255,255,0,255);	// Yellow

	// Create the stripe image data
//    CImageLoader    Image;
  
//    pImage = Image.LoadGradient(64,64,Gradient); 

	return D3DTESTINIT_RUN;
}

bool CAddressTest::ClearFrame(void)
{
	return Clear(RGBA_MAKE(0,0,0,255));
}

bool CAddressTest::ExecuteTest(UINT uTestNum)
{
   // Setup the tests to execute.
	int nTest;

	// Initialize some variables
	nTest = ((uTestNum-1) / 1) + 1;
//	nTest = ((uTestNum-1) m_uCommonTextureFormats) + 1;
 	dwVertexCount = 0;
	msgString[0] = 0;
	wsprintf(msgString, TEXT(""));

	// Cleanup previous texture
	SetTexture(0, NULL);
    ReleaseTexture(pTexture);

	// Let's build some triangles.
	if (bWrapUV)
		DrawWrapGrid(nTest);
	else
		DrawGrid(nTest);

	// Cycle the texture formats
//	m_pD3DMode->nTextureFormat = (uTestNum-1) % m_uCommonTextureFormats;

	// Create and set the texture
    pTexture = CreateGradientTexture(m_pDevice, 64, 64, Gradient);
//    pTexture = CreateTexture(pImage->GetWidth(),pImage->GetHeight(), CDDS_TEXTURE_VIDEO,pImage);

	// Tell the framework what texture to use
    if (NULL != pTexture)
	{
        SetTexture(0,pTexture);

        if (m_dwVersion <= 0x0700)
        {
//    		sprintf(msgString, "%sTex:",msgString);
//        	GetTexFmtDesc(&m_pCommonTextureFormats[m_pMode->nTextureFormat].ddpfPixelFormat,msgString+strlen(msgString),80-strlen(msgString));
        }
        else
    		wsprintf(msgString, TEXT("%sTex:%s"),msgString,TEXT("D3DFMT_A8R8G8B8"));//D3DFmtToString(m_pCommonTextureFormats[m_pMode->nTextureFormat].d3dfFormat));
	}
	else
	{
		WriteToLog(TEXT("CreateTexture() failed with 0x%X\n"), GetLastError());
//		TestFinish(D3DTESTFINISH_ABORT);
		return false;
	}

	// Tell the log that we are starting
	BeginTestCase(msgString);

    return true;
}

void CAddressTest::SceneRefresh()
{
	if (BeginScene())
	{
		// Render the data.
		RenderPrimitive(D3DPT_TRIANGLELIST,D3DFVF_TLVERTEX,VertexList,dwVertexCount,NULL,0,0);

		EndScene();
	}	
}

bool CAddressTest::ProcessFrame(void)
{
	char	szBuffer[80];
	static	int nPass = 0;
	static  int nFail = 0;
    bool	bResult;

     // Use the standard 15%
    bResult = GetCompareResult(0.15f, 0.78f, 0);

	// Tell the logfile how the compare went
    if (bResult)
    {
		(m_fIncrementForward) ? nPass++ : nPass--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Pass();
    }
	else
	{
		(m_fIncrementForward) ? nFail++ : nFail--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Fail();
	}

	WriteStatus("$gOverall Results",szBuffer);

    return bResult;
}

bool CAddressTest::TestTerminate()
{
	// Cleanup texture & image data
	SetTexture(0, NULL);
    ReleaseTexture(pTexture);
    pTexture = NULL;
//    RELEASE(pImage);

	return true;
}

//******************************************************************************
BOOL CAddressTest::AbortedExit(void) {

    return m_bExit;
}

//******************************************************************************
void CAddressTest::ProcessInput() {

    CD3DTest::ProcessInput();

    if (BUTTON_PRESSED(m_jsJoys, JOYBUTTON_BACK)) {
        m_bExit = TRUE;
    }
}

//******************************************************************************
BOOL CAddressTest::WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    *plr = 0;

#ifndef UNDER_XBOX

    switch (uMsg) {

        case WM_KEYDOWN:

            switch (wParam) {

                case VK_ESCAPE: // Exit
                    m_bExit = TRUE;
            }

            break;
    }

#endif // !UNDER_XBOX

    return CD3DTest::WndProc(plr, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\sources.inc ===
!include ..\..\..\sources.inc

TARGETNAME=l_addrs
TARGETTYPE=LIBRARY
TARGETPATH=$(TEST_LIB_DEST)

SYNCHRONIZE_BLOCK=1

SOURCES=\
	address.cpp \
	border.cpp \
	clamp.cpp \
	drawmesh.cpp \
	independentUV.cpp \
	mirror.cpp \
	wrap.cpp \
	wrapu.cpp \
	wrapuv.cpp \
	wrapv.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\wrap.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "cshapes.h"
#include "Address.h"

//************************************************************************
// Wrap Test functions

CWrapTest::CWrapTest()
{
	m_szTestName = TEXT("Texture Address Wrap");
	m_szCommandKey = TEXT("Wrap");

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_WRAP;
	dwAddressCapV = D3DPTADDRESSCAPS_WRAP;
}

CWrapTest::~CWrapTest()
{
}

bool CWrapTest::SetDefaultRenderStates(void)
{
	// Turn on Wrap addressing
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESS, (DWORD)D3DTADDRESS_WRAP);
    SetRenderState(D3DRS_WRAP0, 0);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\wrapu.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "cshapes.h"
#include "Address.h"

//************************************************************************
// WrapU Test functions

CWrapUTest::CWrapUTest()
{
	m_szTestName = TEXT("Texture Address WrapU");
	m_szCommandKey = TEXT("WrapU");

	// Tell parent to use wrap grid
	bWrapUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_WRAP;
	dwAddressCapV = D3DPTADDRESSCAPS_WRAP;
}

CWrapUTest::~CWrapUTest()
{
}

bool CWrapUTest::SetDefaultRenderStates(void)
{
	// Turn on Wrap addressing and the WrapU mode
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESS, (DWORD)D3DTADDRESS_WRAP);
    SetRenderState(D3DRS_WRAP0, D3DWRAP_U);
//	SetRenderState(D3DRENDERSTATE_WRAPU, (DWORD)TRUE);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\wrapuv.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "cshapes.h"
#include "Address.h"

//************************************************************************
// WrapUV Test functions

CWrapUVTest::CWrapUVTest()
{
	m_szTestName = TEXT("Texture Address WrapUV");
	m_szCommandKey = TEXT("WrapUV");

	// Tell parent to use wrap grid
	bWrapUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_WRAP;
	dwAddressCapV = D3DPTADDRESSCAPS_WRAP;
}

CWrapUVTest::~CWrapUVTest()
{
}

bool CWrapUVTest::SetDefaultRenderStates(void)
{
	// Turn on Wrap addressing and the WrapU & Wrap V modes
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESS, (DWORD)D3DTADDRESS_WRAP);
    SetRenderState(D3DRS_WRAP0, D3DWRAP_U | D3DWRAP_V);
//	SetRenderState(D3DRENDERSTATE_WRAPU, (DWORD)TRUE);
//	SetRenderState(D3DRENDERSTATE_WRAPV, (DWORD)TRUE);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\dll\sources.inc ===
!include ..\..\..\..\sources.inc

TARGETNAME=address
TARGETTYPE=LIBRARY
TARGETPATH=$(TEST_LIB_DEST)

OBJLIBFILES=\
    $(OBJLIBFILES) \
    $(TEST_LIB_PATH)\l_addrs.lib

TARGETLIBS=\
    $(TARGETLIBS) \
    $(TEST_LIB_PATH)\d3dlocus.lib \
    $(TEST_LIB_PATH)\d3dftest.lib \
    $(TEST_LIB_PATH)\3dmath.lib \
    $(TEST_LIB_PATH)\CShapes.lib \
    $(TEST_LIB_PATH)\l_addrs.lib

SOURCES=\
    include.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\dll\include.cpp ===
#include "dll\main.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\wrapv.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "cshapes.h"
#include "Address.h"

//************************************************************************
// WrapV Test functions

CWrapVTest::CWrapVTest()
{
	m_szTestName = TEXT("Texture Address WrapV");
	m_szCommandKey = TEXT("WrapV");

	// Tell parent to use wrap grid
	bWrapUV = true;

	// Tell parent class what caps to look for
	dwAddressCapU = D3DPTADDRESSCAPS_WRAP;
	dwAddressCapV = D3DPTADDRESSCAPS_WRAP;
}

CWrapVTest::~CWrapVTest()
{
}

bool CWrapVTest::SetDefaultRenderStates(void)
{
	// Turn on Wrap addressing and the WrapV mode
//	SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)FALSE);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
    m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
//	SetRenderState(D3DRENDERSTATE_TEXTUREADDRESS, (DWORD)D3DTADDRESS_WRAP);
    SetRenderState(D3DRS_WRAP0, D3DWRAP_V);
//	SetRenderState(D3DRENDERSTATE_WRAPV, (DWORD)TRUE);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\exe\include.cpp ===
#include "exe\main.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\address\exe\sources.inc ===
TARGETNAME=address
TARGETTYPE=PROGRAM
TARGETPATH=obj

!include ..\..\..\..\sources.inc

TARGETLIBS=\
    $(TARGETLIBS) \
    $(TEST_LIB_PATH)\d3dlocus.lib \
    $(TEST_LIB_PATH)\d3dftest.lib \
    $(TEST_LIB_PATH)\3dmath.lib \
    $(TEST_LIB_PATH)\CShapes.lib \
    $(TEST_LIB_PATH)\l_addrs.lib

SOURCES=\
    include.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\alphabld.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	AlphaBld.h
 *
 ***************************************************************************/

#ifndef __ALPHABLD_H__
#define __ALPHABLD_H__

//USETESTFRAME

// Defines
#define MAX_TESTS		30

// Class definition
class CAlphaBldTest: public CD3DTest
{
    // Data
	public:
    D3DTLVERTEX     VertexList[40];
    D3DTLVERTEX     BackgroundList[400];
    DWORD           dwVertexCount;
	DWORD			dwSrcCap;
	DWORD			dwDestCap;
	int				nAlphaEnable;
	int				nAlphaValue[5];
	bool			bCircle;
    bool            bBlendOps;
	int 			nBlendOp;
    DWORD           dwBlendOverride;
    DWORD           BlendOp[5];
    LPCSTR			szSrcName;
	LPCSTR			szDestName;
	char			msgString[80];
	char			szStatus[80];
	char			szBlend[80];

    BOOL            m_bExit;

	public:
	CAlphaBldTest();
	~CAlphaBldTest();

	// Framework functions
//    virtual bool AddModeList(PMODELIST pMode, PVOID pData, DWORD dwDataSize);
	virtual UINT TestInitialize(void);
    virtual bool ClearFrame(void);
	virtual bool ExecuteTest(UINT);
	virtual void SceneRefresh(void);
	virtual bool ProcessFrame(void);
    virtual bool TestTerminate(void);

	// Helper functions
	void DrawBackground(void);
	void DrawGrid(int nTest, int nMesh);
	void DrawCircle(D3DVECTOR* pCenter, float Radius, int nDivisions, D3DCOLOR Color);

    virtual BOOL    AbortedExit(void);

protected:

    virtual void    ProcessInput();
    virtual BOOL    WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, 
                        WPARAM wParam, LPARAM lParam);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\alphabld.cpp ===
#define STRICT
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "False.h"
#include "Zero.h"
#include "One.h"
#include "SrcColor.h"
#include "InvSrcColor.h"
#include "SrcAlpha.h"
#include "InvSrcAlpha.h"
#include "DestAlpha.h"
#include "InvDestAlpha.h"
#include "DestColor.h"
#include "InvDestColor.h"
#include "SrcAlphaSat.h"
#include "Both.h"

// Global App instance
//CD3DWindowFramework		App;

//******************************************************************************
//
// Function:
//
//     ValidateDisplay
//
// Description:
//
//     Evaluate the given display information in order to determine whether or
//     not the display is capable of rendering the scene.  If not, the given 
//     display will not be included in the display list.
//
// Arguments:
//
//     CDirect3D8* pd3d                 - Pointer to the Direct3D object
//
//     D3DCAPS8* pd3dcaps               - Capabilities of the device
//
//     D3DDISPLAYMODE*                  - Display mode into which the device
//                                        will be placed
//
// Return Value:
//
//     TRUE if the scene can be rendered using the given display, FALSE if
//     it cannot.
//
//******************************************************************************
extern "C" BOOL PREPEND_MODULE(_ValidateDisplay)(CDirect3D8* pd3d, D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm) {

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     ExhibitScene
//
// Description:
//
//     Create the scene, pump messages, process user input,
//     update the scene, render the scene, and release the scene when finished.
//
// Arguments:
//
//     CDisplay* pDisplay           - Pointer to the Display object
//
//     int* pnExitCode              - Optional pointer to an integer that will
//                                    be set to the exit value contained in the 
//                                    wParam parameter of the WM_QUIT message 
//                                    (if received)
//
// Return Value:
//
//     TRUE if the display remains functional on exit, FALSE otherwise.
//
//******************************************************************************
extern "C" BOOL PREPEND_MODULE(_ExhibitScene)(CDisplay* pDisplay, int* pnExitCode) {

    CAlphaBldTest* pAlphaTest;
    BOOL           bQuit = FALSE, bRet = TRUE;
    UINT           i;

    // Verify that the display has been initialized
    if (!pDisplay) {
        return FALSE;
    }

#ifndef UNDER_XBOX
    for (i = 1; i < 125 && !bQuit && bRet; i++) {
#else
    for (i = 1; i < 123 && !bQuit && bRet; i++) {
#endif // UNDER_XBOX

        // Create the scene
        switch (i) {
            case 1:
                pAlphaTest = new CFalseTest();
                break;
            case 2:
                pAlphaTest = new CZeroZeroTest();
                break;
            case 3:
                pAlphaTest = new CZeroOneTest();
                break;
            case 4:
                pAlphaTest = new CZeroSrcColorTest();
                break;
            case 5:
                pAlphaTest = new CZeroInvSrcColorTest();
                break;
            case 6:
                pAlphaTest = new CZeroSrcAlphaTest();
                break;
            case 7:
                pAlphaTest = new CZeroInvSrcAlphaTest();
                break;
            case 8:
                pAlphaTest = new CZeroDestAlphaTest();
                break;
            case 9:
                pAlphaTest = new CZeroInvDestAlphaTest();
                break;
            case 10:
                pAlphaTest = new CZeroDestColorTest();
                break;
            case 11:
                pAlphaTest = new CZeroInvDestColorTest();
                break;
            case 12:
                pAlphaTest = new CZeroSrcAlphaSatTest();
                break;
            case 13:
                pAlphaTest = new COneZeroTest();
                break;
            case 14:
                pAlphaTest = new COneOneTest();
                break;
            case 15:
                pAlphaTest = new COneSrcColorTest();
                break;
            case 16:
                pAlphaTest = new COneInvSrcColorTest();
                break;
            case 17:
                pAlphaTest = new COneSrcAlphaTest();
                break;
            case 18:
                pAlphaTest = new COneInvSrcAlphaTest();
                break;
            case 19:
                pAlphaTest = new COneDestAlphaTest();
                break;
            case 20:
                pAlphaTest = new COneInvDestAlphaTest();
                break;
            case 21:
                pAlphaTest = new COneDestColorTest();
                break;
            case 22:
                pAlphaTest = new COneInvDestColorTest();
                break;
            case 23:
                pAlphaTest = new COneSrcAlphaSatTest();
                break;
            case 24:
                pAlphaTest = new CSrcColorZeroTest();
                break;
            case 25:
                pAlphaTest = new CSrcColorOneTest();
                break;
            case 26:
                pAlphaTest = new CSrcColorSrcColorTest();
                break;
            case 27:
                pAlphaTest = new CSrcColorInvSrcColorTest();
                break;
            case 28:
                pAlphaTest = new CSrcColorSrcAlphaTest();
                break;
            case 29:
                pAlphaTest = new CSrcColorInvSrcAlphaTest();
                break;
            case 30:
                pAlphaTest = new CSrcColorDestAlphaTest();
                break;
            case 31:
                pAlphaTest = new CSrcColorInvDestAlphaTest();
                break;
            case 32:
                pAlphaTest = new CSrcColorDestColorTest();
                break;
            case 33:
                pAlphaTest = new CSrcColorInvDestColorTest();
                break;
            case 34:
                pAlphaTest = new CSrcColorSrcAlphaSatTest();
                break;
            case 35:
                pAlphaTest = new CInvSrcColorZeroTest();
                break;
            case 36:
                pAlphaTest = new CInvSrcColorOneTest();
                break;
            case 37:
                pAlphaTest = new CInvSrcColorSrcColorTest();
                break;
            case 38:
                pAlphaTest = new CInvSrcColorInvSrcColorTest();
                break;
            case 39:
                pAlphaTest = new CInvSrcColorSrcAlphaTest();
                break;
            case 40:
                pAlphaTest = new CInvSrcColorInvSrcAlphaTest();
                break;
            case 41:
                pAlphaTest = new CInvSrcColorDestAlphaTest();
                break;
            case 42:
                pAlphaTest = new CInvSrcColorInvDestAlphaTest();
                break;
            case 43:
                pAlphaTest = new CInvSrcColorDestColorTest();
                break;
            case 44:
                pAlphaTest = new CInvSrcColorInvDestColorTest();
                break;
            case 45:
                pAlphaTest = new CInvSrcColorSrcAlphaSatTest();
                break;
            case 46:
                pAlphaTest = new CSrcAlphaZeroTest();
                break;
            case 47:
                pAlphaTest = new CSrcAlphaOneTest();
                break;
            case 48:
                pAlphaTest = new CSrcAlphaSrcColorTest();
                break;
            case 49:
                pAlphaTest = new CSrcAlphaInvSrcColorTest();
                break;
            case 50:
                pAlphaTest = new CSrcAlphaSrcAlphaTest();
                break;
            case 51:
                pAlphaTest = new CSrcAlphaInvSrcAlphaTest();
                break;
            case 52:
                pAlphaTest = new CSrcAlphaDestAlphaTest();
                break;
            case 53:
                pAlphaTest = new CSrcAlphaInvDestAlphaTest();
                break;
            case 54:
                pAlphaTest = new CSrcAlphaDestColorTest();
                break;
            case 55:
                pAlphaTest = new CSrcAlphaInvDestColorTest();
                break;
            case 56:
                pAlphaTest = new CSrcAlphaSrcAlphaSatTest();
                break;
            case 57:
                pAlphaTest = new CInvSrcAlphaZeroTest();
                break;
            case 58:
                pAlphaTest = new CInvSrcAlphaOneTest();
                break;
            case 59:
                pAlphaTest = new CInvSrcAlphaSrcColorTest();
                break;
            case 60:
                pAlphaTest = new CInvSrcAlphaInvSrcColorTest();
                break;
            case 61:
                pAlphaTest = new CInvSrcAlphaSrcAlphaTest();
                break;
            case 62:
                pAlphaTest = new CInvSrcAlphaInvSrcAlphaTest();
                break;
            case 63:
                pAlphaTest = new CInvSrcAlphaDestAlphaTest();
                break;
            case 64:
                pAlphaTest = new CInvSrcAlphaInvDestAlphaTest();
                break;
            case 65:
                pAlphaTest = new CInvSrcAlphaDestColorTest();
                break;
            case 66:
                pAlphaTest = new CInvSrcAlphaInvDestColorTest();
                break;
            case 67:
                pAlphaTest = new CInvSrcAlphaSrcAlphaSatTest();
                break;
            case 68:
                pAlphaTest = new CDestAlphaZeroTest();
                break;
            case 69:
                pAlphaTest = new CDestAlphaOneTest();
                break;
            case 70:
                pAlphaTest = new CDestAlphaSrcColorTest();
                break;
            case 71:
                pAlphaTest = new CDestAlphaInvSrcColorTest();
                break;
            case 72:
                pAlphaTest = new CDestAlphaSrcAlphaTest();
                break;
            case 73:
                pAlphaTest = new CDestAlphaInvSrcAlphaTest();
                break;
            case 74:
                pAlphaTest = new CDestAlphaDestAlphaTest();
                break;
            case 75:
                pAlphaTest = new CDestAlphaInvDestAlphaTest();
                break;
            case 76:
                pAlphaTest = new CDestAlphaDestColorTest();
                break;
            case 77:
                pAlphaTest = new CDestAlphaInvDestColorTest();
                break;
            case 78:
                pAlphaTest = new CDestAlphaSrcAlphaSatTest();
                break;
            case 79:
                pAlphaTest = new CInvDestAlphaZeroTest();
                break;
            case 80:
                pAlphaTest = new CInvDestAlphaOneTest();
                break;
            case 81:
                pAlphaTest = new CInvDestAlphaSrcColorTest();
                break;
            case 82:
                pAlphaTest = new CInvDestAlphaInvSrcColorTest();
                break;
            case 83:
                pAlphaTest = new CInvDestAlphaSrcAlphaTest();
                break;
            case 84:
                pAlphaTest = new CInvDestAlphaInvSrcAlphaTest();
                break;
            case 85:
                pAlphaTest = new CInvDestAlphaDestAlphaTest();
                break;
            case 86:
                pAlphaTest = new CInvDestAlphaInvDestAlphaTest();
                break;
            case 87:
                pAlphaTest = new CInvDestAlphaDestColorTest();
                break;
            case 88:
                pAlphaTest = new CInvDestAlphaInvDestColorTest();
                break;
            case 89:
                pAlphaTest = new CInvDestAlphaSrcAlphaSatTest();
                break;
            case 90:
                pAlphaTest = new CDestColorZeroTest();
                break;
            case 91:
                pAlphaTest = new CDestColorOneTest();
                break;
            case 92:
                pAlphaTest = new CDestColorSrcColorTest();
                break;
            case 93:
                pAlphaTest = new CDestColorInvSrcColorTest();
                break;
            case 94:
                pAlphaTest = new CDestColorSrcAlphaTest();
                break;
            case 95:
                pAlphaTest = new CDestColorInvSrcAlphaTest();
                break;
            case 96:
                pAlphaTest = new CDestColorDestAlphaTest();
                break;
            case 97:
                pAlphaTest = new CDestColorInvDestAlphaTest();
                break;
            case 98:
                pAlphaTest = new CDestColorDestColorTest();
                break;
            case 99:
                pAlphaTest = new CDestColorInvDestColorTest();
                break;
            case 100:
                pAlphaTest = new CDestColorSrcAlphaSatTest();
                break;
            case 101:
                pAlphaTest = new CInvDestColorZeroTest();
                break;
            case 102:
                pAlphaTest = new CInvDestColorOneTest();
                break;
            case 103:
                pAlphaTest = new CInvDestColorSrcColorTest();
                break;
            case 104:
                pAlphaTest = new CInvDestColorInvSrcColorTest();
                break;
            case 105:
                pAlphaTest = new CInvDestColorSrcAlphaTest();
                break;
            case 106:
                pAlphaTest = new CInvDestColorInvSrcAlphaTest();
                break;
            case 107:
                pAlphaTest = new CInvDestColorDestAlphaTest();
                break;
            case 108:
                pAlphaTest = new CInvDestColorInvDestAlphaTest();
                break;
            case 109:
                pAlphaTest = new CInvDestColorDestColorTest();
                break;
            case 110:
                pAlphaTest = new CInvDestColorInvDestColorTest();
                break;
            case 111:
                pAlphaTest = new CInvDestColorSrcAlphaSatTest();
                break;
            case 112:
                pAlphaTest = new CSrcAlphaSatZeroTest();
                break;
            case 113:
                pAlphaTest = new CSrcAlphaSatOneTest();
                break;
            case 114:
                pAlphaTest = new CSrcAlphaSatSrcColorTest();
                break;
            case 115:
                pAlphaTest = new CSrcAlphaSatInvSrcColorTest();
                break;
            case 116:
                pAlphaTest = new CSrcAlphaSatSrcAlphaTest();
                break;
            case 117:
                pAlphaTest = new CSrcAlphaSatInvSrcAlphaTest();
                break;
            case 118:
                pAlphaTest = new CSrcAlphaSatDestAlphaTest();
                break;
            case 119:
                pAlphaTest = new CSrcAlphaSatInvDestAlphaTest();
                break;
            case 120:
                pAlphaTest = new CSrcAlphaSatDestColorTest();
                break;
            case 121:
                pAlphaTest = new CSrcAlphaSatInvDestColorTest();
                break;
            case 122:
                pAlphaTest = new CSrcAlphaSatSrcAlphaSatTest();
                break;
#ifndef UNDER_XBOX
            case 123:
                pAlphaTest = new CBothSrcAlphaTest();
                break;
            case 124:
                pAlphaTest = new CBothInvSrcAlphaTest();
                break;
#endif // !UNDER_XBOX
        }

        if (!pAlphaTest) {
            return FALSE;
        }

        // Initialize the scene
        if (!pAlphaTest->Create(pDisplay)) {
            pAlphaTest->Release();
            return FALSE;
        }

        bRet = pAlphaTest->Exhibit(pnExitCode);

        bQuit = pAlphaTest->AbortedExit();

        // Clean up the scene
        pAlphaTest->Release();
    }

    return bRet;
}

CAlphaBldTest::CAlphaBldTest()
{
	// Init Enable variable
	nAlphaEnable = TRUE;

	// Init Alpha value array
	nAlphaValue[0] = 0;
	nAlphaValue[1] = 64;
	nAlphaValue[2] = 128;
	nAlphaValue[3] = 192;
	nAlphaValue[4] = 255;

    // Init BlendOp variables
    dwBlendOverride = 0;
    bBlendOps = false;
    nBlendOp = 0;

    // Init the BlendOp array
    BlendOp[0] = D3DBLENDOP_ADD;
    BlendOp[1] = D3DBLENDOP_SUBTRACT;
    BlendOp[2] = D3DBLENDOP_REVSUBTRACT;
    BlendOp[3] = D3DBLENDOP_MIN; 
    BlendOp[4] = D3DBLENDOP_MAX;

    // Check for BlendOverride key
    if (KeySet("add") && !dwBlendOverride)
        dwBlendOverride = D3DBLENDOP_ADD;

    if (KeySet("subtract") && !dwBlendOverride)
        dwBlendOverride = D3DBLENDOP_SUBTRACT;

    if (KeySet("revsubtract") && !dwBlendOverride)
        dwBlendOverride = D3DBLENDOP_REVSUBTRACT;

    if (KeySet("min") && !dwBlendOverride)
        dwBlendOverride = D3DBLENDOP_MIN;

    if (KeySet("max") && !dwBlendOverride)
        dwBlendOverride = D3DBLENDOP_MAX;

    // Init the Src and Dest names to empty string
	szSrcName = "";
	szDestName = "";

    // Disable textures
    m_ModeOptions.fTextures = false;

    m_bExit = FALSE;
}

CAlphaBldTest::~CAlphaBldTest()
{
}
/*
bool CAlphaBldTest::AddModeList(PMODELIST pMode, PVOID pData, DWORD dwDataSize)
{
	// For Dx8, may need to try all five BlendOps
    if ((m_dwVersion >= 0x0800))
    {
	    DWORD dwMiscCaps = m_d3dcaps.PrimitiveMiscCaps;

	    // Check if the BlendOp cap is supported
	    if (dwMiscCaps & D3DPMISCCAPS_BLENDOP)
        {
            bBlendOps = true;

            if (dwBlendOverride)
            {
                // Use the override BlendOp
                BlendOp[0] = dwBlendOverride;

        	    CD3DTest::AddModeList(pMode,pData,dwDataSize);
            }
            else
            {
                // Use all five BlendOps 
    	        CD3DTest::AddModeList(pMode,pData,dwDataSize);
		        CD3DTest::AddModeList(pMode,pData,dwDataSize);
    	        CD3DTest::AddModeList(pMode,pData,dwDataSize);
		        CD3DTest::AddModeList(pMode,pData,dwDataSize);
    	        CD3DTest::AddModeList(pMode,pData,dwDataSize);
            }
        }
        else
        {
    		// Just use the default BlendOp
	    	CD3DTest::AddModeList(pMode,pData,dwDataSize);
        }
    }
    else
    {
		// Let the framework handle stress mode
		CD3DTest::AddModeList(pMode,pData,dwDataSize);
	}

    return true;
}
*/
UINT CAlphaBldTest::TestInitialize(void)
{
//    UINT n = m_pMode->nSrcDevice;

	// Setup the Test range
	SetTestRange(1, MAX_TESTS);

	// Check the caps we are interested in
	DWORD dwSrcBlendCaps = m_d3dcaps.SrcBlendCaps;
	DWORD dwDestBlendCaps = m_d3dcaps.DestBlendCaps;

	DWORD dwMiscCaps = m_d3dcaps.PrimitiveMiscCaps;

	// Check if the BlendOp cap is supported
	if (dwMiscCaps & D3DPMISCCAPS_BLENDOP)
    {
        bBlendOps = true;
    }

	// Check the appropriate Source Blend caps
	if (!(dwSrcBlendCaps & dwSrcCap))
	{
		WriteToLog("Device capability not supported: Source Blend %s.\n",szSrcName);
		return D3DTESTINIT_SKIPALL;
	}

	// Check the appropriate Dest Blend caps
	if (!(dwDestBlendCaps & dwDestCap))
	{
		WriteToLog("Device capability not supported: Destination Blend %s.\n",szDestName);
		return D3DTESTINIT_SKIPALL;
	}

	// Generate the checkerboard background 
//    if (KeySet("checker"))
//    	DrawBackground();

	return D3DTESTINIT_RUN;
}

bool CAlphaBldTest::ClearFrame(void)
{
	return Clear(RGBA_MAKE(116,116,116,255));
}

bool CAlphaBldTest::ExecuteTest(UINT uTestNum)
{
	int		nTest;
 
	// Initialize some variables
	nTest = (uTestNum - 1) % MAX_TESTS;
 	dwVertexCount = 0;
	msgString[0] = '\0';
	szStatus[0] = '\0';
	szBlend[0] = '\0';

//    if (bBlendOps)
        nBlendOp = (uTestNum - 1) / 6;
//    else
//        nBlendOp = 0;

	// Are we the circle test
	bCircle = (nTest % 6) ? false : true;

    // Tell log and status window which Blend Op we are using
    switch (BlendOp[nBlendOp])
    {
        case D3DBLENDOP_ADD: sprintf(szBlend, "Add (default)",szBlend);
                             sprintf(msgString, "%sBlendOp: Add, ",msgString);
                             break;

        case D3DBLENDOP_SUBTRACT: sprintf(szBlend, "Subtract",szBlend);
                                  sprintf(msgString, "%sBlendOp: Subtract, ",msgString);
                                  break;

        case D3DBLENDOP_REVSUBTRACT: sprintf(szBlend, "RevSubtract",szBlend);
                                     sprintf(msgString, "%sBlendOp: RevSubtract, ",msgString);
                                     break;

        case D3DBLENDOP_MIN: sprintf(szBlend, "Min",szBlend);
                             sprintf(msgString, "%sBlendOp: Min, ",msgString);
                             break;

        case D3DBLENDOP_MAX: sprintf(szBlend, "Max",szBlend);
                             sprintf(msgString, "%sBlendOp: Max, ",msgString);
                             break;

        default: WriteToLog("Error: Unknown BlendOp: %d.\n",BlendOp[nBlendOp]);
                 SkipTests(1);
                 return false;
    }

	// Let's build some triangles and update status window.
	if (bCircle)
	{
		sprintf(msgString, "%sOverlapping Circles: %d",msgString,nAlphaValue[nTest/6]);
		sprintf(szStatus, "%sOverlapping Circles: %d",szStatus,nAlphaValue[nTest/6]);
	}
	else
	{
		DrawGrid(nTest, (nTest / 6));

		sprintf(msgString, "%sMulticolor Mesh: %d, Triangles: %d",msgString,nAlphaValue[nTest/6],nAlphaValue[(nTest%6)-1]);
		sprintf(szStatus, "%sMulticolor Mesh: %d, Triangles: %d",szStatus,nAlphaValue[nTest/6],nAlphaValue[(nTest%6)-1]);
	}

	// Tell the log that we are starting
	BeginTestCase(msgString);

    return true;
}

void CAlphaBldTest::SceneRefresh()
{
	int nTest = (m_uLastTestNum - 1) % MAX_TESTS;

	if (BeginScene())
	{
		// Render the Background image
        if (KeySet("checker"))
        {
		    SetRenderState(D3DRS_ALPHABLENDENABLE, (DWORD)FALSE);
		    RenderPrimitive(D3DPT_TRIANGLESTRIP,D3DFVF_TLVERTEX,BackgroundList,400,NULL,0,0);
        }

		// Set the appropriate AlphaBlendEnable render state.
		SetRenderState(D3DRS_ALPHABLENDENABLE, (DWORD)nAlphaEnable);

        // If BlendOps supported, set the appropriate BlendOp
        if (bBlendOps)
            SetRenderState(D3DRS_BLENDOP, (DWORD)BlendOp[nBlendOp]);

		// Render the appropriate test case.
		if (bCircle)
		{
			D3DVECTOR Center;
			float     fRadius;
			DWORD	  dwWidth = m_vpTest.Width;//m_pSrcTarget->m_dwWidth;
			DWORD	  dwHeight = m_vpTest.Height;//m_pSrcTarget->m_dwHeight;
			D3DCOLOR  ColorArray[] = {RGBA_MAKE(255,0,0,nAlphaValue[nTest / 6]),
									  RGBA_MAKE(0,255,0,nAlphaValue[nTest / 6]),
									  RGBA_MAKE(0,0,255,nAlphaValue[nTest / 6])};

			fRadius = ((dwWidth < dwHeight) ? dwWidth : dwHeight) * 0.335f;

			for (int i=0; i < 3; i++)
			{
				Center.x = (float)m_vpTest.X + (dwWidth / 2.0f) + ((fRadius / 1.5f) * (float)cos(2.0944f * i));
				Center.y = (float)m_vpTest.Y + (dwHeight / 2.0f) + ((fRadius / 1.5f) * (float)sin(2.0944f * i));
				Center.z = 0.5f;

				Center.x -= 16.0f;

				DrawCircle(&Center, fRadius, 36, ColorArray[i]);
			}
		}
		else
		{
			RenderPrimitive(D3DPT_TRIANGLESTRIP,D3DFVF_TLVERTEX,VertexList,8,NULL,0,0);
			RenderPrimitive(D3DPT_TRIANGLELIST,D3DFVF_TLVERTEX,VertexList+8,dwVertexCount-8,NULL,0,0);
		}

		EndScene();
	}	
}

bool CAlphaBldTest::ProcessFrame(void)
{
	char	szBuffer[80];
	static	int nPass = 0;
	static  int nFail = 0;
    bool	bResult;

     // Use the standard 15%
    bResult = GetCompareResult(0.15f, 0.78f, 0);

	// Tell the logfile how the compare went
    if (bResult)
    {
		(m_fIncrementForward) ? nPass++ : nPass--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Pass();
    }
	else
	{
		(m_fIncrementForward) ? nFail++ : nFail--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Fail();
	}

	WriteStatus("$gAlpha Values$y",szStatus);
	WriteStatus("$gBlend Op$y",szBlend);
	WriteStatus("$gOverall Results",szBuffer);

    return bResult;
}

bool CAlphaBldTest::TestTerminate(void)
{
    // If BlendOps supported, advance to the next one 
    if (bBlendOps)
        nBlendOp++;

	return true;
}

//******************************************************************************
BOOL CAlphaBldTest::AbortedExit(void) {

    return m_bExit;
}

//******************************************************************************
void CAlphaBldTest::ProcessInput() {

    CD3DTest::ProcessInput();

    if (BUTTON_PRESSED(m_jsJoys, JOYBUTTON_BACK)) {
        m_bExit = TRUE;
    }
}

//******************************************************************************
BOOL CAlphaBldTest::WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    *plr = 0;

#ifndef UNDER_XBOX

    switch (uMsg) {

        case WM_KEYDOWN:

            switch (wParam) {

                case VK_ESCAPE: // Exit
                    m_bExit = TRUE;
            }

            break;
    }

#endif // !UNDER_XBOX

    return CD3DTest::WndProc(plr, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\false.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "False.h"

//************************************************************************
// False Test functions

CFalseTest::CFalseTest()
{
	m_szTestName = TEXT("False (SrcAlpha/InvSrcAlpha)");
	m_szCommandKey = TEXT("False");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "InvSrcAlpha";

	// Overwrite Enable variable
	nAlphaEnable = FALSE;
}

CFalseTest::~CFalseTest()
{
}

bool CFalseTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\both.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	Both.h
 *
 ***************************************************************************/

#ifndef __BOTH_H__
#define __BOTH_H__

#ifndef UNDER_XBOX

// BothSrcAlpha Class definitions
class CBothSrcAlphaTest: public CAlphaBldTest
{
	public:
	CBothSrcAlphaTest();
	~CBothSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// BothInvSrcAlpha Class definitions
class CBothInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CBothInvSrcAlphaTest();
	~CBothInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

#endif // !UNDER_XBOX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\both.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "Both.h"

#ifndef UNDER_XBOX

//************************************************************************
// BothSrcAlpha Test functions

CBothSrcAlphaTest::CBothSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: BothSrcAlpha");
	m_szCommandKey = TEXT("BothSrcAlpha");

	// Tell parent class what cap to look for
	dwSrcCap = D3DPBLENDCAPS_BOTHSRCALPHA;
	dwDestCap = 0xffffffff;

	// Give parent a printable name for the caps
	szSrcName = "BothSrcAlpha";
}

CBothSrcAlphaTest::~CBothSrcAlphaTest()
{
}

bool CBothSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:BothSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_BOTHSRCALPHA);

	return true;
}

//************************************************************************
// BothInvSrcAlpha Test functions

CBothInvSrcAlphaTest::CBothInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: BothInvSrcAlpha");
	m_szCommandKey = TEXT("BothSrcAlpha");

	// Tell parent class what cap to look for
	dwSrcCap = D3DPBLENDCAPS_BOTHINVSRCALPHA;
	dwDestCap = 0xffffffff;

	// Give parent a printable name for the caps
	szSrcName = "BothInvSrcAlpha";
}

CBothInvSrcAlphaTest::~CBothInvSrcAlphaTest()
{
}

bool CBothInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:BothInvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_BOTHINVSRCALPHA);

	return true;
}

#endif // !UNDER_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\destalpha.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "DestAlpha.h"

//************************************************************************
// DestAlpha/Zero Test functions

CDestAlphaZeroTest::CDestAlphaZeroTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: Zero");
	m_szCommandKey = TEXT("DestAlphaZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "Zero";
}

CDestAlphaZeroTest::~CDestAlphaZeroTest()
{
}

bool CDestAlphaZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// DestAlpha/One Test functions

CDestAlphaOneTest::CDestAlphaOneTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: One");
	m_szCommandKey = TEXT("DestAlphaOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "One";
}

CDestAlphaOneTest::~CDestAlphaOneTest()
{
}

bool CDestAlphaOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// DestAlpha/SrcColor Test functions

CDestAlphaSrcColorTest::CDestAlphaSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: SrcColor");
	m_szCommandKey = TEXT("DestAlphaSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "SrcColor";
}

CDestAlphaSrcColorTest::~CDestAlphaSrcColorTest()
{
}

bool CDestAlphaSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// DestAlpha/InvSrcColor Test functions

CDestAlphaInvSrcColorTest::CDestAlphaInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("DestAlphaInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "InvSrcColor";
}

CDestAlphaInvSrcColorTest::~CDestAlphaInvSrcColorTest()
{
}

bool CDestAlphaInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// DestAlpha/SrcAlpha Test functions

CDestAlphaSrcAlphaTest::CDestAlphaSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("DestAlphaSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "SrcAlpha";
}

CDestAlphaSrcAlphaTest::~CDestAlphaSrcAlphaTest()
{
}

bool CDestAlphaSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// DestAlpha/InvSrcAlpha Test functions

CDestAlphaInvSrcAlphaTest::CDestAlphaInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("DestAlphaInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "InvSrcAlpha";
}

CDestAlphaInvSrcAlphaTest::~CDestAlphaInvSrcAlphaTest()
{
}

bool CDestAlphaInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// DestAlpha/DestAlpha Test functions

CDestAlphaDestAlphaTest::CDestAlphaDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: DestAlpha");
	m_szCommandKey = TEXT("DestAlphaDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "DestAlpha";
}

CDestAlphaDestAlphaTest::~CDestAlphaDestAlphaTest()
{
}

bool CDestAlphaDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// DestAlpha/InvDestAlpha Test functions

CDestAlphaInvDestAlphaTest::CDestAlphaInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("DestAlphaInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "InvDestAlpha";
}

CDestAlphaInvDestAlphaTest::~CDestAlphaInvDestAlphaTest()
{
}

bool CDestAlphaInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// DestAlpha/DestColor Test functions

CDestAlphaDestColorTest::CDestAlphaDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: DestColor");
	m_szCommandKey = TEXT("DestAlphaDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "DestColor";
}

CDestAlphaDestColorTest::~CDestAlphaDestColorTest()
{
}

bool CDestAlphaDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// DestAlpha/InvDestColor Test functions

CDestAlphaInvDestColorTest::CDestAlphaInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: InvDestColor");
	m_szCommandKey = TEXT("DestAlphaInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "InvDestColor";
}

CDestAlphaInvDestColorTest::~CDestAlphaInvDestColorTest()
{
}

bool CDestAlphaInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// DestAlpha/SrcAlphaSat Test functions

CDestAlphaSrcAlphaSatTest::CDestAlphaSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: DestAlpha DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("DestAlphaSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "DestAlpha";
	szDestName = "SrcAlphaSat";
}

CDestAlphaSrcAlphaSatTest::~CDestAlphaSrcAlphaSatTest()
{
}

bool CDestAlphaSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestAlpha and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\destalpha.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	DestAlpha.h
 *
 ***************************************************************************/

#ifndef __DESTALPHA_H__
#define __DESTALPHA_H__

// DestAlpha/Zero Class definitions
class CDestAlphaZeroTest: public CAlphaBldTest
{
	public:
	CDestAlphaZeroTest();
	~CDestAlphaZeroTest();

	bool SetDefaultRenderStates(void);
};

// DestAlpha/One Class definitions
class CDestAlphaOneTest: public CAlphaBldTest
{
	public:
	CDestAlphaOneTest();
	~CDestAlphaOneTest();

	bool SetDefaultRenderStates(void);
};

// DestAlpha/SrcColor Class definitions
class CDestAlphaSrcColorTest: public CAlphaBldTest
{
	public:
	CDestAlphaSrcColorTest();
	~CDestAlphaSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// DestAlpha/InvSrcColor Class definitions
class CDestAlphaInvSrcColorTest: public CAlphaBldTest
{
	public:
	CDestAlphaInvSrcColorTest();
	~CDestAlphaInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// DestAlpha/SrcAlpha Class definitions
class CDestAlphaSrcAlphaTest: public CAlphaBldTest
{
	public:
	CDestAlphaSrcAlphaTest();
	~CDestAlphaSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// DestAlpha/InvSrcAlpha Class definitions
class CDestAlphaInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CDestAlphaInvSrcAlphaTest();
	~CDestAlphaInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// DestAlpha/DestAlpha Class definitions
class CDestAlphaDestAlphaTest: public CAlphaBldTest
{
	public:
	CDestAlphaDestAlphaTest();
	~CDestAlphaDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// DestAlpha/InvDestAlpha Class definitions
class CDestAlphaInvDestAlphaTest: public CAlphaBldTest
{
	public:
	CDestAlphaInvDestAlphaTest();
	~CDestAlphaInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// DestAlpha/DestColor Class definitions
class CDestAlphaDestColorTest: public CAlphaBldTest
{
	public:
	CDestAlphaDestColorTest();
	~CDestAlphaDestColorTest();

	bool SetDefaultRenderStates(void);
};

// DestAlpha/InvDestColor Class definitions
class CDestAlphaInvDestColorTest: public CAlphaBldTest
{
	public:
	CDestAlphaInvDestColorTest();
	~CDestAlphaInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// DestAlpha/SrcAlphaSat Class definitions
class CDestAlphaSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	CDestAlphaSrcAlphaSatTest();
	~CDestAlphaSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\destcolor.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	DestColor.h
 *
 ***************************************************************************/

#ifndef __DESTCOLOR_H__
#define __DESTCOLOR_H__

// DestColor/Zero Class definitions
class CDestColorZeroTest: public CAlphaBldTest
{
	public:
	CDestColorZeroTest();
	~CDestColorZeroTest();

	bool SetDefaultRenderStates(void);
};

// DestColor/One Class definitions
class CDestColorOneTest: public CAlphaBldTest
{
	public:
	CDestColorOneTest();
	~CDestColorOneTest();

	bool SetDefaultRenderStates(void);
};

// DestColor/SrcColor Class definitions
class CDestColorSrcColorTest: public CAlphaBldTest
{
	public:
	CDestColorSrcColorTest();
	~CDestColorSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// DestColor/InvSrcColor Class definitions
class CDestColorInvSrcColorTest: public CAlphaBldTest
{
	public:
	CDestColorInvSrcColorTest();
	~CDestColorInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// DestColor/SrcAlpha Class definitions
class CDestColorSrcAlphaTest: public CAlphaBldTest
{
	public:
	CDestColorSrcAlphaTest();
	~CDestColorSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// DestColor/InvSrcAlpha Class definitions
class CDestColorInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CDestColorInvSrcAlphaTest();
	~CDestColorInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// DestColor/DestAlpha Class definitions
class CDestColorDestAlphaTest: public CAlphaBldTest
{
	public:
	CDestColorDestAlphaTest();
	~CDestColorDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// DestColor/InvDestAlpha Class definitions
class CDestColorInvDestAlphaTest: public CAlphaBldTest
{
	public:
	CDestColorInvDestAlphaTest();
	~CDestColorInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// DestColor/DestColor Class definitions
class CDestColorDestColorTest: public CAlphaBldTest
{
	public:
	CDestColorDestColorTest();
	~CDestColorDestColorTest();

	bool SetDefaultRenderStates(void);
};

// DestColor/InvDestColor Class definitions
class CDestColorInvDestColorTest: public CAlphaBldTest
{
	public:
	CDestColorInvDestColorTest();
	~CDestColorInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// DestColor/SrcAlphaSat Class definitions
class CDestColorSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	CDestColorSrcAlphaSatTest();
	~CDestColorSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\destcolor.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "DestColor.h"

//************************************************************************
// DestColor/Zero Test functions

CDestColorZeroTest::CDestColorZeroTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: Zero");
	m_szCommandKey = TEXT("DestColorZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "Zero";
}

CDestColorZeroTest::~CDestColorZeroTest()
{
}

bool CDestColorZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// DestColor/One Test functions

CDestColorOneTest::CDestColorOneTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: One");
	m_szCommandKey = TEXT("DestColorOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "One";
}

CDestColorOneTest::~CDestColorOneTest()
{
}

bool CDestColorOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// DestColor/SrcColor Test functions

CDestColorSrcColorTest::CDestColorSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: SrcColor");
	m_szCommandKey = TEXT("DestColorSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "SrcColor";
}

CDestColorSrcColorTest::~CDestColorSrcColorTest()
{
}

bool CDestColorSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// DestColor/InvSrcColor Test functions

CDestColorInvSrcColorTest::CDestColorInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("DestColorInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "InvSrcColor";
}

CDestColorInvSrcColorTest::~CDestColorInvSrcColorTest()
{
}

bool CDestColorInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// DestColor/SrcAlpha Test functions

CDestColorSrcAlphaTest::CDestColorSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("DestColorSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "SrcAlpha";
}

CDestColorSrcAlphaTest::~CDestColorSrcAlphaTest()
{
}

bool CDestColorSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// DestColor/InvSrcAlpha Test functions

CDestColorInvSrcAlphaTest::CDestColorInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("DestColorInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "InvSrcAlpha";
}

CDestColorInvSrcAlphaTest::~CDestColorInvSrcAlphaTest()
{
}

bool CDestColorInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// DestColor/DestAlpha Test functions

CDestColorDestAlphaTest::CDestColorDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: DestAlpha");
	m_szCommandKey = TEXT("DestColorDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "DestAlpha";
}

CDestColorDestAlphaTest::~CDestColorDestAlphaTest()
{
}

bool CDestColorDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// DestColor/InvDestAlpha Test functions

CDestColorInvDestAlphaTest::CDestColorInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("DestColorInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "InvDestAlpha";
}

CDestColorInvDestAlphaTest::~CDestColorInvDestAlphaTest()
{
}

bool CDestColorInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// DestColor/DestColor Test functions

CDestColorDestColorTest::CDestColorDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: DestColor");
	m_szCommandKey = TEXT("DestColorDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "DestColor";
}

CDestColorDestColorTest::~CDestColorDestColorTest()
{
}

bool CDestColorDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// DestColor/InvDestColor Test functions

CDestColorInvDestColorTest::CDestColorInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: InvDestColor");
	m_szCommandKey = TEXT("DestColorInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "InvDestColor";
}

CDestColorInvDestColorTest::~CDestColorInvDestColorTest()
{
}

bool CDestColorInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// DestColor/SrcAlphaSat Test functions

CDestColorSrcAlphaSatTest::CDestColorSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: DestColor DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("DestColorSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_DESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "DestColor";
	szDestName = "SrcAlphaSat";
}

CDestColorSrcAlphaSatTest::~CDestColorSrcAlphaSatTest()
{
}

bool CDestColorSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:DestColor and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_DESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\draw.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "AlphaBld.h"

//************************************************************************
// Internal API:    DrawBackground
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CAlphaBldTest::DrawBackground(void)
{
	float			fWidth, fHeight, fX, fY;
	D3DCOLOR		Color[2] = {RGBA_MAKE(0,0,0,255),
								RGBA_MAKE(255,255,255,255)};
	DWORD			dwCount;
	bool			bWhite;
	int				i, j;

	dwCount = 0;
	bWhite = true;
	fWidth = (float)m_vpTest.Width / 10.0f;//m_pSrcTarget->m_dwWidth / 10.0f;
	fHeight = (float)m_vpTest.Height / 10.0f;//m_pSrcTarget->m_dwHeight / 10.0f;

	for (i=0; i < 10; i++)
	{
		fX = fWidth*i + (float)m_vpTest.X;
		bWhite = !bWhite;

		for (j=0; j < 10; j++)
		{
			fY = fHeight*j + (float)m_vpTest.Y;
			bWhite = !bWhite;

			BackgroundList[dwCount++] = cD3DTLVERTEX(cD3DVECTOR(fX+fWidth,fY,         0.9f), (1.0f / 0.9f), Color[bWhite],0, 0.0f,0.0f);
			BackgroundList[dwCount++] = cD3DTLVERTEX(cD3DVECTOR(fX+fWidth,fY+fHeight, 0.9f), (1.0f / 0.9f), Color[bWhite],0, 0.0f,0.0f);
			BackgroundList[dwCount++] = cD3DTLVERTEX(cD3DVECTOR(fX,       fY,         0.9f), (1.0f / 0.9f), Color[bWhite],0, 0.0f,0.0f);
			BackgroundList[dwCount++] = cD3DTLVERTEX(cD3DVECTOR(fX,       fY+fHeight, 0.9f), (1.0f / 0.9f), Color[bWhite],0, 0.0f,0.0f);
		}
	}
}

//************************************************************************
// Internal API:    DrawGrid
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CAlphaBldTest::DrawGrid(int nTest, int nMesh)
{
	DWORD dwWidth = m_vpTest.Width;//m_pSrcTarget->m_dwWidth;
	DWORD dwHeight = m_vpTest.Height;//m_pSrcTarget->m_dwHeight;

	// Multicolored grid
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.10f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.099f * (float)dwHeight)) + (float)m_vpTest.Y, 0.6f), (1.0f / 0.6f), RGBA_MAKE(255,0,0,nAlphaValue[nMesh]),  0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.10f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.9f * (float)dwHeight)) + (float)m_vpTest.Y,   0.6f), (1.0f / 0.6f), RGBA_MAKE(255,128,0,nAlphaValue[nMesh]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.26f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.099f * (float)dwHeight)) + (float)m_vpTest.Y, 0.6f), (1.0f / 0.6f), RGBA_MAKE(128,128,0,nAlphaValue[nMesh]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.42f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.9f * (float)dwHeight)) + (float)m_vpTest.Y,   0.6f), (1.0f / 0.6f), RGBA_MAKE(128,255,0,nAlphaValue[nMesh]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.58f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.099f * (float)dwHeight)) + (float)m_vpTest.Y, 0.6f), (1.0f / 0.6f), RGBA_MAKE(0,255,128,nAlphaValue[nMesh]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.74f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.9f * (float)dwHeight)) + (float)m_vpTest.Y,   0.6f), (1.0f / 0.6f), RGBA_MAKE(0,128,128,nAlphaValue[nMesh]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.901f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.099f * (float)dwHeight)) + (float)m_vpTest.Y, 0.6f), (1.0f / 0.6f), RGBA_MAKE(0,128,255,nAlphaValue[nMesh]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.901f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.9f * (float)dwHeight)) + (float)m_vpTest.Y,   0.6f), (1.0f / 0.6f), RGBA_MAKE(0,0,255,nAlphaValue[nMesh]),  0, 0.0f,0.0f);

	// White triangle (Bottom Left)
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.03f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.03f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.20f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.37f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.37f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.03f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);

	// Black triangle (Bottom Right)
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.63f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.03f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.80f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.37f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.97f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.03f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);

	// White/Black rectangle (Center)
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.33f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.32f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.67f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.58f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.67f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.32f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);

	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.33f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.32f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.33f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.58f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.67f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.58f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);

	// Black triangle (Top Left)
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.03f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.63f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.20f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.97f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.37f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.63f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);

	// White triangle (Top Right)
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.63f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.63f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.80f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.97f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((D3DVALUE)(int)(0.97f * (float)dwWidth + (float)m_vpTest.X), (D3DVALUE)(int)((float)dwHeight - (0.63f * (float)dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,nAlphaValue[(nTest % 6)-1]),0, 0.0f,0.0f);
}

//************************************************************************
// Internal API:    DrawCircle
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CAlphaBldTest::DrawCircle(D3DVECTOR* pCenter, float Radius, int nDivisions, D3DCOLOR Color)
{
    int             i, NumVertices;
    float           Theta, Rads;

  	dwVertexCount = 0;
	NumVertices = nDivisions + 2;
    Theta = 360.0f / nDivisions;

    // Initialize the center point
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(pCenter->x, pCenter->y, pCenter->z), (1.0f / pCenter->z), Color, 0, 0.0f,0.0f);

    for (i=1; i<NumVertices; i++)
    {
        // cos takes a radian value, so convert.
        Rads = (Theta * (i-1) * pi)/180.0f;

		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((pCenter->x + Radius * (float)cos(Rads)), (pCenter->y + Radius * (float)sin(Rads)), pCenter->z), (1.0f / pCenter->z), Color, 0, 0.0f,0.0f);
    }

	RenderPrimitive(D3DPT_TRIANGLEFAN,D3DFVF_TLVERTEX,VertexList,dwVertexCount,NULL,0,0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\false.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	False.h
 *
 ***************************************************************************/

#ifndef __FALSE_H__
#define __FALSE_H__

// False Class definitions
class CFalseTest: public CAlphaBldTest
{
	public:
	CFalseTest();
	~CFalseTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\invdestalpha.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	InvDestAlpha.h
 *
 ***************************************************************************/

#ifndef __INVDESTALPHA_H__
#define __INVDESTALPHA_H__

// InvDestAlpha/Zero Class definitions
class CInvDestAlphaZeroTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaZeroTest();
	~CInvDestAlphaZeroTest();

	bool SetDefaultRenderStates(void);
};

// InvDestAlpha/One Class definitions
class CInvDestAlphaOneTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaOneTest();
	~CInvDestAlphaOneTest();

	bool SetDefaultRenderStates(void);
};

// InvDestAlpha/SrcColor Class definitions
class CInvDestAlphaSrcColorTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaSrcColorTest();
	~CInvDestAlphaSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// InvDestAlpha/InvSrcColor Class definitions
class CInvDestAlphaInvSrcColorTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaInvSrcColorTest();
	~CInvDestAlphaInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// InvDestAlpha/SrcAlpha Class definitions
class CInvDestAlphaSrcAlphaTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaSrcAlphaTest();
	~CInvDestAlphaSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvDestAlpha/InvSrcAlpha Class definitions
class CInvDestAlphaInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaInvSrcAlphaTest();
	~CInvDestAlphaInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvDestAlpha/DestAlpha Class definitions
class CInvDestAlphaDestAlphaTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaDestAlphaTest();
	~CInvDestAlphaDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvDestAlpha/InvDestAlpha Class definitions
class CInvDestAlphaInvDestAlphaTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaInvDestAlphaTest();
	~CInvDestAlphaInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvDestAlpha/DestColor Class definitions
class CInvDestAlphaDestColorTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaDestColorTest();
	~CInvDestAlphaDestColorTest();

	bool SetDefaultRenderStates(void);
};

// InvDestAlpha/InvDestColor Class definitions
class CInvDestAlphaInvDestColorTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaInvDestColorTest();
	~CInvDestAlphaInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// InvDestAlpha/SrcAlphaSat Class definitions
class CInvDestAlphaSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	CInvDestAlphaSrcAlphaSatTest();
	~CInvDestAlphaSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\invsrcalpha.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	InvSrcAlpha.h
 *
 ***************************************************************************/

#ifndef __INVSRCALPHA_H__
#define __INVSRCALPHA_H__

// InvSrcAlpha/Zero Class definitions
class CInvSrcAlphaZeroTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaZeroTest();
	~CInvSrcAlphaZeroTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcAlpha/One Class definitions
class CInvSrcAlphaOneTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaOneTest();
	~CInvSrcAlphaOneTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcAlpha/SrcColor Class definitions
class CInvSrcAlphaSrcColorTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaSrcColorTest();
	~CInvSrcAlphaSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcAlpha/InvSrcColor Class definitions
class CInvSrcAlphaInvSrcColorTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaInvSrcColorTest();
	~CInvSrcAlphaInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcAlpha/SrcAlpha Class definitions
class CInvSrcAlphaSrcAlphaTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaSrcAlphaTest();
	~CInvSrcAlphaSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcAlpha/InvSrcAlpha Class definitions
class CInvSrcAlphaInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaInvSrcAlphaTest();
	~CInvSrcAlphaInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcAlpha/DestAlpha Class definitions
class CInvSrcAlphaDestAlphaTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaDestAlphaTest();
	~CInvSrcAlphaDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcAlpha/InvDestAlpha Class definitions
class CInvSrcAlphaInvDestAlphaTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaInvDestAlphaTest();
	~CInvSrcAlphaInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcAlpha/DestColor Class definitions
class CInvSrcAlphaDestColorTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaDestColorTest();
	~CInvSrcAlphaDestColorTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcAlpha/InvDestColor Class definitions
class CInvSrcAlphaInvDestColorTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaInvDestColorTest();
	~CInvSrcAlphaInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcAlpha/SrcAlphaSat Class definitions
class CInvSrcAlphaSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	CInvSrcAlphaSrcAlphaSatTest();
	~CInvSrcAlphaSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\invdestcolor.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	InvDestColor.h
 *
 ***************************************************************************/

#ifndef __INVDESTCOLOR_H__
#define __INVDESTCOLOR_H__

// InvDestColor/Zero Class definitions
class CInvDestColorZeroTest: public CAlphaBldTest
{
	public:
	CInvDestColorZeroTest();
	~CInvDestColorZeroTest();

	bool SetDefaultRenderStates(void);
};

// InvDestColor/One Class definitions
class CInvDestColorOneTest: public CAlphaBldTest
{
	public:
	CInvDestColorOneTest();
	~CInvDestColorOneTest();

	bool SetDefaultRenderStates(void);
};

// InvDestColor/SrcColor Class definitions
class CInvDestColorSrcColorTest: public CAlphaBldTest
{
	public:
	CInvDestColorSrcColorTest();
	~CInvDestColorSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// InvDestColor/InvSrcColor Class definitions
class CInvDestColorInvSrcColorTest: public CAlphaBldTest
{
	public:
	CInvDestColorInvSrcColorTest();
	~CInvDestColorInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// InvDestColor/SrcAlpha Class definitions
class CInvDestColorSrcAlphaTest: public CAlphaBldTest
{
	public:
	CInvDestColorSrcAlphaTest();
	~CInvDestColorSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvDestColor/InvSrcAlpha Class definitions
class CInvDestColorInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CInvDestColorInvSrcAlphaTest();
	~CInvDestColorInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvDestColor/DestAlpha Class definitions
class CInvDestColorDestAlphaTest: public CAlphaBldTest
{
	public:
	CInvDestColorDestAlphaTest();
	~CInvDestColorDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvDestColor/InvDestAlpha Class definitions
class CInvDestColorInvDestAlphaTest: public CAlphaBldTest
{
	public:
	CInvDestColorInvDestAlphaTest();
	~CInvDestColorInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvDestColor/DestColor Class definitions
class CInvDestColorDestColorTest: public CAlphaBldTest
{
	public:
	CInvDestColorDestColorTest();
	~CInvDestColorDestColorTest();

	bool SetDefaultRenderStates(void);
};

// InvDestColor/InvDestColor Class definitions
class CInvDestColorInvDestColorTest: public CAlphaBldTest
{
	public:
	CInvDestColorInvDestColorTest();
	~CInvDestColorInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// InvDestColor/SrcAlphaSat Class definitions
class CInvDestColorSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	CInvDestColorSrcAlphaSatTest();
	~CInvDestColorSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\invdestalpha.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "InvDestAlpha.h"

//************************************************************************
// InvDestAlpha/Zero Test functions

CInvDestAlphaZeroTest::CInvDestAlphaZeroTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: Zero");
	m_szCommandKey = TEXT("InvDestAlphaZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "Zero";
}

CInvDestAlphaZeroTest::~CInvDestAlphaZeroTest()
{
}

bool CInvDestAlphaZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// InvDestAlpha/One Test functions

CInvDestAlphaOneTest::CInvDestAlphaOneTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: One");
	m_szCommandKey = TEXT("InvDestAlphaOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "One";
}

CInvDestAlphaOneTest::~CInvDestAlphaOneTest()
{
}

bool CInvDestAlphaOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// InvDestAlpha/SrcColor Test functions

CInvDestAlphaSrcColorTest::CInvDestAlphaSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: SrcColor");
	m_szCommandKey = TEXT("InvDestAlphaSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "SrcColor";
}

CInvDestAlphaSrcColorTest::~CInvDestAlphaSrcColorTest()
{
}

bool CInvDestAlphaSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// InvDestAlpha/InvSrcColor Test functions

CInvDestAlphaInvSrcColorTest::CInvDestAlphaInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("InvDestAlphaInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "InvSrcColor";
}

CInvDestAlphaInvSrcColorTest::~CInvDestAlphaInvSrcColorTest()
{
}

bool CInvDestAlphaInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// InvDestAlpha/SrcAlpha Test functions

CInvDestAlphaSrcAlphaTest::CInvDestAlphaSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("InvDestAlphaSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "SrcAlpha";
}

CInvDestAlphaSrcAlphaTest::~CInvDestAlphaSrcAlphaTest()
{
}

bool CInvDestAlphaSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// InvDestAlpha/InvSrcAlpha Test functions

CInvDestAlphaInvSrcAlphaTest::CInvDestAlphaInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("InvDestAlphaInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "InvSrcAlpha";
}

CInvDestAlphaInvSrcAlphaTest::~CInvDestAlphaInvSrcAlphaTest()
{
}

bool CInvDestAlphaInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// InvDestAlpha/DestAlpha Test functions

CInvDestAlphaDestAlphaTest::CInvDestAlphaDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: DestAlpha");
	m_szCommandKey = TEXT("InvDestAlphaDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "DestAlpha";
}

CInvDestAlphaDestAlphaTest::~CInvDestAlphaDestAlphaTest()
{
}

bool CInvDestAlphaDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// InvDestAlpha/InvDestAlpha Test functions

CInvDestAlphaInvDestAlphaTest::CInvDestAlphaInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("InvDestAlphaInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "InvDestAlpha";
}

CInvDestAlphaInvDestAlphaTest::~CInvDestAlphaInvDestAlphaTest()
{
}

bool CInvDestAlphaInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// InvDestAlpha/DestColor Test functions

CInvDestAlphaDestColorTest::CInvDestAlphaDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: DestColor");
	m_szCommandKey = TEXT("InvDestAlphaDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "DestColor";
}

CInvDestAlphaDestColorTest::~CInvDestAlphaDestColorTest()
{
}

bool CInvDestAlphaDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// InvDestAlpha/InvDestColor Test functions

CInvDestAlphaInvDestColorTest::CInvDestAlphaInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: InvDestColor");
	m_szCommandKey = TEXT("InvDestAlphaInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "InvDestColor";
}

CInvDestAlphaInvDestColorTest::~CInvDestAlphaInvDestColorTest()
{
}

bool CInvDestAlphaInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// InvDestAlpha/SrcAlphaSat Test functions

CInvDestAlphaSrcAlphaSatTest::CInvDestAlphaSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestAlpha DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("InvDestAlphaSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "InvDestAlpha";
	szDestName = "SrcAlphaSat";
}

CInvDestAlphaSrcAlphaSatTest::~CInvDestAlphaSrcAlphaSatTest()
{
}

bool CInvDestAlphaSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestAlpha and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\invsrcalpha.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "InvSrcAlpha.h"

//************************************************************************
// InvSrcAlpha/Zero Test functions

CInvSrcAlphaZeroTest::CInvSrcAlphaZeroTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: Zero");
	m_szCommandKey = TEXT("InvSrcAlphaZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "Zero";
}

CInvSrcAlphaZeroTest::~CInvSrcAlphaZeroTest()
{
}

bool CInvSrcAlphaZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// InvSrcAlpha/One Test functions

CInvSrcAlphaOneTest::CInvSrcAlphaOneTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: One");
	m_szCommandKey = TEXT("InvSrcAlphaOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "One";
}

CInvSrcAlphaOneTest::~CInvSrcAlphaOneTest()
{
}

bool CInvSrcAlphaOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// InvSrcAlpha/SrcColor Test functions

CInvSrcAlphaSrcColorTest::CInvSrcAlphaSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: SrcColor");
	m_szCommandKey = TEXT("InvSrcAlphaSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "SrcColor";
}

CInvSrcAlphaSrcColorTest::~CInvSrcAlphaSrcColorTest()
{
}

bool CInvSrcAlphaSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// InvSrcAlpha/InvSrcColor Test functions

CInvSrcAlphaInvSrcColorTest::CInvSrcAlphaInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("InvSrcAlphaInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "InvSrcColor";
}

CInvSrcAlphaInvSrcColorTest::~CInvSrcAlphaInvSrcColorTest()
{
}

bool CInvSrcAlphaInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// InvSrcAlpha/SrcAlpha Test functions

CInvSrcAlphaSrcAlphaTest::CInvSrcAlphaSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("InvSrcAlphaSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "SrcAlpha";
}

CInvSrcAlphaSrcAlphaTest::~CInvSrcAlphaSrcAlphaTest()
{
}

bool CInvSrcAlphaSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// InvSrcAlpha/InvSrcAlpha Test functions

CInvSrcAlphaInvSrcAlphaTest::CInvSrcAlphaInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("InvSrcAlphaInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "InvSrcAlpha";
}

CInvSrcAlphaInvSrcAlphaTest::~CInvSrcAlphaInvSrcAlphaTest()
{
}

bool CInvSrcAlphaInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// InvSrcAlpha/DestAlpha Test functions

CInvSrcAlphaDestAlphaTest::CInvSrcAlphaDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: DestAlpha");
	m_szCommandKey = TEXT("InvSrcAlphaDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "DestAlpha";
}

CInvSrcAlphaDestAlphaTest::~CInvSrcAlphaDestAlphaTest()
{
}

bool CInvSrcAlphaDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// InvSrcAlpha/InvDestAlpha Test functions

CInvSrcAlphaInvDestAlphaTest::CInvSrcAlphaInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("InvSrcAlphaInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "InvDestAlpha";
}

CInvSrcAlphaInvDestAlphaTest::~CInvSrcAlphaInvDestAlphaTest()
{
}

bool CInvSrcAlphaInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// InvSrcAlpha/DestColor Test functions

CInvSrcAlphaDestColorTest::CInvSrcAlphaDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: DestColor");
	m_szCommandKey = TEXT("InvSrcAlphaDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "DestColor";
}

CInvSrcAlphaDestColorTest::~CInvSrcAlphaDestColorTest()
{
}

bool CInvSrcAlphaDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// InvSrcAlpha/InvDestColor Test functions

CInvSrcAlphaInvDestColorTest::CInvSrcAlphaInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: InvDestColor");
	m_szCommandKey = TEXT("InvSrcAlphaInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "InvDestColor";
}

CInvSrcAlphaInvDestColorTest::~CInvSrcAlphaInvDestColorTest()
{
}

bool CInvSrcAlphaInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// InvSrcAlpha/SrcAlphaSat Test functions

CInvSrcAlphaSrcAlphaSatTest::CInvSrcAlphaSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcAlpha DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("InvSrcAlphaSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcAlpha";
	szDestName = "SrcAlphaSat";
}

CInvSrcAlphaSrcAlphaSatTest::~CInvSrcAlphaSrcAlphaSatTest()
{
}

bool CInvSrcAlphaSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcAlpha and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\invsrccolor.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "InvSrcColor.h"

//************************************************************************
// InvSrcColor/Zero Test functions

CInvSrcColorZeroTest::CInvSrcColorZeroTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: Zero");
	m_szCommandKey = TEXT("InvSrcColorZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "Zero";
}

CInvSrcColorZeroTest::~CInvSrcColorZeroTest()
{
}

bool CInvSrcColorZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// InvSrcColor/One Test functions

CInvSrcColorOneTest::CInvSrcColorOneTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: One");
	m_szCommandKey = TEXT("InvSrcColorOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "One";
}

CInvSrcColorOneTest::~CInvSrcColorOneTest()
{
}

bool CInvSrcColorOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// InvSrcColor/SrcColor Test functions

CInvSrcColorSrcColorTest::CInvSrcColorSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: SrcColor");
	m_szCommandKey = TEXT("InvSrcColorSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "SrcColor";
}

CInvSrcColorSrcColorTest::~CInvSrcColorSrcColorTest()
{
}

bool CInvSrcColorSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// InvSrcColor/InvSrcColor Test functions

CInvSrcColorInvSrcColorTest::CInvSrcColorInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("InvSrcColorInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "InvSrcColor";
}

CInvSrcColorInvSrcColorTest::~CInvSrcColorInvSrcColorTest()
{
}

bool CInvSrcColorInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// InvSrcColor/SrcAlpha Test functions

CInvSrcColorSrcAlphaTest::CInvSrcColorSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("InvSrcColorSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "SrcAlpha";
}

CInvSrcColorSrcAlphaTest::~CInvSrcColorSrcAlphaTest()
{
}

bool CInvSrcColorSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// InvSrcColor/InvSrcAlpha Test functions

CInvSrcColorInvSrcAlphaTest::CInvSrcColorInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("InvSrcColorInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "InvSrcAlpha";
}

CInvSrcColorInvSrcAlphaTest::~CInvSrcColorInvSrcAlphaTest()
{
}

bool CInvSrcColorInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// InvSrcColor/DestAlpha Test functions

CInvSrcColorDestAlphaTest::CInvSrcColorDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: DestAlpha");
	m_szCommandKey = TEXT("InvSrcColorDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "DestAlpha";
}

CInvSrcColorDestAlphaTest::~CInvSrcColorDestAlphaTest()
{
}

bool CInvSrcColorDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// InvSrcColor/InvDestAlpha Test functions

CInvSrcColorInvDestAlphaTest::CInvSrcColorInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("InvSrcColorInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "InvDestAlpha";
}

CInvSrcColorInvDestAlphaTest::~CInvSrcColorInvDestAlphaTest()
{
}

bool CInvSrcColorInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// InvSrcColor/DestColor Test functions

CInvSrcColorDestColorTest::CInvSrcColorDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: DestColor");
	m_szCommandKey = TEXT("InvSrcColorDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "DestColor";
}

CInvSrcColorDestColorTest::~CInvSrcColorDestColorTest()
{
}

bool CInvSrcColorDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// InvSrcColor/InvDestColor Test functions

CInvSrcColorInvDestColorTest::CInvSrcColorInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: InvDestColor");
	m_szCommandKey = TEXT("InvSrcColorInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "InvDestColor";
}

CInvSrcColorInvDestColorTest::~CInvSrcColorInvDestColorTest()
{
}

bool CInvSrcColorInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// InvSrcColor/SrcAlphaSat Test functions

CInvSrcColorSrcAlphaSatTest::CInvSrcColorSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: InvSrcColor DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("InvSrcColorSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVSRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "InvSrcColor";
	szDestName = "SrcAlphaSat";
}

CInvSrcColorSrcAlphaSatTest::~CInvSrcColorSrcAlphaSatTest()
{
}

bool CInvSrcColorSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvSrcColor and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\invdestcolor.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "InvDestColor.h"

//************************************************************************
// InvDestColor/Zero Test functions

CInvDestColorZeroTest::CInvDestColorZeroTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: Zero");
	m_szCommandKey = TEXT("InvDestColorZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "Zero";
}

CInvDestColorZeroTest::~CInvDestColorZeroTest()
{
}

bool CInvDestColorZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// InvDestColor/One Test functions

CInvDestColorOneTest::CInvDestColorOneTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: One");
	m_szCommandKey = TEXT("InvDestColorOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "One";
}

CInvDestColorOneTest::~CInvDestColorOneTest()
{
}

bool CInvDestColorOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// InvDestColor/SrcColor Test functions

CInvDestColorSrcColorTest::CInvDestColorSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: SrcColor");
	m_szCommandKey = TEXT("InvDestColorSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "SrcColor";
}

CInvDestColorSrcColorTest::~CInvDestColorSrcColorTest()
{
}

bool CInvDestColorSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// InvDestColor/InvSrcColor Test functions

CInvDestColorInvSrcColorTest::CInvDestColorInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("InvDestColorInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "InvSrcColor";
}

CInvDestColorInvSrcColorTest::~CInvDestColorInvSrcColorTest()
{
}

bool CInvDestColorInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// InvDestColor/SrcAlpha Test functions

CInvDestColorSrcAlphaTest::CInvDestColorSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("InvDestColorSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "SrcAlpha";
}

CInvDestColorSrcAlphaTest::~CInvDestColorSrcAlphaTest()
{
}

bool CInvDestColorSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// InvDestColor/InvSrcAlpha Test functions

CInvDestColorInvSrcAlphaTest::CInvDestColorInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("InvDestColorInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "InvSrcAlpha";
}

CInvDestColorInvSrcAlphaTest::~CInvDestColorInvSrcAlphaTest()
{
}

bool CInvDestColorInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// InvDestColor/DestAlpha Test functions

CInvDestColorDestAlphaTest::CInvDestColorDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: DestAlpha");
	m_szCommandKey = TEXT("InvDestColorDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "DestAlpha";
}

CInvDestColorDestAlphaTest::~CInvDestColorDestAlphaTest()
{
}

bool CInvDestColorDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// InvDestColor/InvDestAlpha Test functions

CInvDestColorInvDestAlphaTest::CInvDestColorInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("InvDestColorInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "InvDestAlpha";
}

CInvDestColorInvDestAlphaTest::~CInvDestColorInvDestAlphaTest()
{
}

bool CInvDestColorInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// InvDestColor/DestColor Test functions

CInvDestColorDestColorTest::CInvDestColorDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: DestColor");
	m_szCommandKey = TEXT("InvDestColorDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "DestColor";
}

CInvDestColorDestColorTest::~CInvDestColorDestColorTest()
{
}

bool CInvDestColorDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// InvDestColor/InvDestColor Test functions

CInvDestColorInvDestColorTest::CInvDestColorInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: InvDestColor");
	m_szCommandKey = TEXT("InvDestColorInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "InvDestColor";
}

CInvDestColorInvDestColorTest::~CInvDestColorInvDestColorTest()
{
}

bool CInvDestColorInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// InvDestColor/SrcAlphaSat Test functions

CInvDestColorSrcAlphaSatTest::CInvDestColorSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: InvDestColor DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("InvDestColorSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_INVDESTCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "InvDestColor";
	szDestName = "SrcAlphaSat";
}

CInvDestColorSrcAlphaSatTest::~CInvDestColorSrcAlphaSatTest()
{
}

bool CInvDestColorSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:InvDestColor and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\modulex.h ===
#define PREPEND_MODULE(Suffix) alphabld##Suffix
#define MODULE_STRING "alphabld"
#pragma comment(linker, "/include:_alphabld_ExhibitScene@8")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\one.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	One.h
 *
 ***************************************************************************/

#ifndef __ONE_H__
#define __ONE_H__

// One/Zero Class definitions
class COneZeroTest: public CAlphaBldTest
{
	public:
	COneZeroTest();
	~COneZeroTest();

	bool SetDefaultRenderStates(void);
};

// One/One Class definitions
class COneOneTest: public CAlphaBldTest
{
	public:
	COneOneTest();
	~COneOneTest();

	bool SetDefaultRenderStates(void);
};

// One/SrcColor Class definitions
class COneSrcColorTest: public CAlphaBldTest
{
	public:
	COneSrcColorTest();
	~COneSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// One/InvSrcColor Class definitions
class COneInvSrcColorTest: public CAlphaBldTest
{
	public:
	COneInvSrcColorTest();
	~COneInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// One/SrcAlpha Class definitions
class COneSrcAlphaTest: public CAlphaBldTest
{
	public:
	COneSrcAlphaTest();
	~COneSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// One/InvSrcAlpha Class definitions
class COneInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	COneInvSrcAlphaTest();
	~COneInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// One/DestAlpha Class definitions
class COneDestAlphaTest: public CAlphaBldTest
{
	public:
	COneDestAlphaTest();
	~COneDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// One/InvDestAlpha Class definitions
class COneInvDestAlphaTest: public CAlphaBldTest
{
	public:
	COneInvDestAlphaTest();
	~COneInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// One/DestColor Class definitions
class COneDestColorTest: public CAlphaBldTest
{
	public:
	COneDestColorTest();
	~COneDestColorTest();

	bool SetDefaultRenderStates(void);
};

// One/InvDestColor Class definitions
class COneInvDestColorTest: public CAlphaBldTest
{
	public:
	COneInvDestColorTest();
	~COneInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// One/SrcAlphaSat Class definitions
class COneSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	COneSrcAlphaSatTest();
	~COneSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\sources.inc ===
!include ..\..\..\sources.inc

TARGETNAME=l_alpbld
TARGETTYPE=LIBRARY
TARGETPATH=$(TEST_LIB_DEST)

SYNCHRONIZE_BLOCK=1

SOURCES=\
	alphabld.cpp \
	both.cpp \
	destalpha.cpp \
	destcolor.cpp \
	draw.cpp \
	false.cpp \
	invdestalpha.cpp \
	invdestcolor.cpp \
	invsrcalpha.cpp \
	invsrccolor.cpp \
	one.cpp \
	srcalpha.cpp \
	srcalphasat.cpp \
	srccolor.cpp \
	zero.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\invsrccolor.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	InvSrcColor.h
 *
 ***************************************************************************/

#ifndef __INVSRCCOLOR_H__
#define __INVSRCCOLOR_H__

// InvSrcColor/Zero Class definitions
class CInvSrcColorZeroTest: public CAlphaBldTest
{
	public:
	CInvSrcColorZeroTest();
	~CInvSrcColorZeroTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcColor/One Class definitions
class CInvSrcColorOneTest: public CAlphaBldTest
{
	public:
	CInvSrcColorOneTest();
	~CInvSrcColorOneTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcColor/SrcColor Class definitions
class CInvSrcColorSrcColorTest: public CAlphaBldTest
{
	public:
	CInvSrcColorSrcColorTest();
	~CInvSrcColorSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcColor/InvSrcColor Class definitions
class CInvSrcColorInvSrcColorTest: public CAlphaBldTest
{
	public:
	CInvSrcColorInvSrcColorTest();
	~CInvSrcColorInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcColor/SrcAlpha Class definitions
class CInvSrcColorSrcAlphaTest: public CAlphaBldTest
{
	public:
	CInvSrcColorSrcAlphaTest();
	~CInvSrcColorSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcColor/InvSrcAlpha Class definitions
class CInvSrcColorInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CInvSrcColorInvSrcAlphaTest();
	~CInvSrcColorInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcColor/DestAlpha Class definitions
class CInvSrcColorDestAlphaTest: public CAlphaBldTest
{
	public:
	CInvSrcColorDestAlphaTest();
	~CInvSrcColorDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcColor/InvDestAlpha Class definitions
class CInvSrcColorInvDestAlphaTest: public CAlphaBldTest
{
	public:
	CInvSrcColorInvDestAlphaTest();
	~CInvSrcColorInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcColor/DestColor Class definitions
class CInvSrcColorDestColorTest: public CAlphaBldTest
{
	public:
	CInvSrcColorDestColorTest();
	~CInvSrcColorDestColorTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcColor/InvDestColor Class definitions
class CInvSrcColorInvDestColorTest: public CAlphaBldTest
{
	public:
	CInvSrcColorInvDestColorTest();
	~CInvSrcColorInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// InvSrcColor/SrcAlphaSat Class definitions
class CInvSrcColorSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	CInvSrcColorSrcAlphaSatTest();
	~CInvSrcColorSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\one.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "One.h"

//************************************************************************
// One/Zero Test functions

COneZeroTest::COneZeroTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: Zero");
	m_szCommandKey = TEXT("OneZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "Zero";
}

COneZeroTest::~COneZeroTest()
{
}

bool COneZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// One/One Test functions

COneOneTest::COneOneTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: One");
	m_szCommandKey = TEXT("OneOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "One";
}

COneOneTest::~COneOneTest()
{
}

bool COneOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// One/SrcColor Test functions

COneSrcColorTest::COneSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: SrcColor");
	m_szCommandKey = TEXT("OneSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "SrcColor";
}

COneSrcColorTest::~COneSrcColorTest()
{
}

bool COneSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// One/InvSrcColor Test functions

COneInvSrcColorTest::COneInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("OneInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "InvSrcColor";
}

COneInvSrcColorTest::~COneInvSrcColorTest()
{
}

bool COneInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// One/SrcAlpha Test functions

COneSrcAlphaTest::COneSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("OneSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "SrcAlpha";
}

COneSrcAlphaTest::~COneSrcAlphaTest()
{
}

bool COneSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// One/InvSrcAlpha Test functions

COneInvSrcAlphaTest::COneInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("OneInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "InvSrcAlpha";
}

COneInvSrcAlphaTest::~COneInvSrcAlphaTest()
{
}

bool COneInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// One/DestAlpha Test functions

COneDestAlphaTest::COneDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: DestAlpha");
	m_szCommandKey = TEXT("OneDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "DestAlpha";
}

COneDestAlphaTest::~COneDestAlphaTest()
{
}

bool COneDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// One/InvDestAlpha Test functions

COneInvDestAlphaTest::COneInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("OneInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "InvDestAlpha";
}

COneInvDestAlphaTest::~COneInvDestAlphaTest()
{
}

bool COneInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// One/DestColor Test functions

COneDestColorTest::COneDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: DestColor");
	m_szCommandKey = TEXT("OneDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "DestColor";
}

COneDestColorTest::~COneDestColorTest()
{
}

bool COneDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// One/InvDestColor Test functions

COneInvDestColorTest::COneInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: InvDestColor");
	m_szCommandKey = TEXT("OneInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "InvDestColor";
}

COneInvDestColorTest::~COneInvDestColorTest()
{
}

bool COneInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// One/SrcAlphaSat Test functions

COneSrcAlphaSatTest::COneSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: One DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("OneSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ONE;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "One";
	szDestName = "SrcAlphaSat";
}

COneSrcAlphaSatTest::~COneSrcAlphaSatTest()
{
}

bool COneSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:One and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ONE);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\srcalpha.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	SrcAlpha.h
 *
 ***************************************************************************/

#ifndef __SRCALPHA_H__
#define __SRCALPHA_H__

// SrcAlpha/Zero Class definitions
class CSrcAlphaZeroTest: public CAlphaBldTest
{
	public:
	CSrcAlphaZeroTest();
	~CSrcAlphaZeroTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlpha/One Class definitions
class CSrcAlphaOneTest: public CAlphaBldTest
{
	public:
	CSrcAlphaOneTest();
	~CSrcAlphaOneTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlpha/SrcColor Class definitions
class CSrcAlphaSrcColorTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSrcColorTest();
	~CSrcAlphaSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlpha/InvSrcColor Class definitions
class CSrcAlphaInvSrcColorTest: public CAlphaBldTest
{
	public:
	CSrcAlphaInvSrcColorTest();
	~CSrcAlphaInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlpha/SrcAlpha Class definitions
class CSrcAlphaSrcAlphaTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSrcAlphaTest();
	~CSrcAlphaSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlpha/InvSrcAlpha Class definitions
class CSrcAlphaInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CSrcAlphaInvSrcAlphaTest();
	~CSrcAlphaInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlpha/DestAlpha Class definitions
class CSrcAlphaDestAlphaTest: public CAlphaBldTest
{
	public:
	CSrcAlphaDestAlphaTest();
	~CSrcAlphaDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlpha/InvDestAlpha Class definitions
class CSrcAlphaInvDestAlphaTest: public CAlphaBldTest
{
	public:
	CSrcAlphaInvDestAlphaTest();
	~CSrcAlphaInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlpha/DestColor Class definitions
class CSrcAlphaDestColorTest: public CAlphaBldTest
{
	public:
	CSrcAlphaDestColorTest();
	~CSrcAlphaDestColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlpha/InvDestColor Class definitions
class CSrcAlphaInvDestColorTest: public CAlphaBldTest
{
	public:
	CSrcAlphaInvDestColorTest();
	~CSrcAlphaInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlpha/SrcAlphaSat Class definitions
class CSrcAlphaSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSrcAlphaSatTest();
	~CSrcAlphaSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\srcalpha.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "SrcAlpha.h"

//************************************************************************
// SrcAlpha/Zero Test functions

CSrcAlphaZeroTest::CSrcAlphaZeroTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: Zero");
	m_szCommandKey = TEXT("SrcAlphaZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "Zero";
}

CSrcAlphaZeroTest::~CSrcAlphaZeroTest()
{
}

bool CSrcAlphaZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// SrcAlpha/One Test functions

CSrcAlphaOneTest::CSrcAlphaOneTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: One");
	m_szCommandKey = TEXT("SrcAlphaOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "One";
}

CSrcAlphaOneTest::~CSrcAlphaOneTest()
{
}

bool CSrcAlphaOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// SrcAlpha/SrcColor Test functions

CSrcAlphaSrcColorTest::CSrcAlphaSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: SrcColor");
	m_szCommandKey = TEXT("SrcAlphaSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "SrcColor";
}

CSrcAlphaSrcColorTest::~CSrcAlphaSrcColorTest()
{
}

bool CSrcAlphaSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// SrcAlpha/InvSrcColor Test functions

CSrcAlphaInvSrcColorTest::CSrcAlphaInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("SrcAlphaInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "InvSrcColor";
}

CSrcAlphaInvSrcColorTest::~CSrcAlphaInvSrcColorTest()
{
}

bool CSrcAlphaInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// SrcAlpha/SrcAlpha Test functions

CSrcAlphaSrcAlphaTest::CSrcAlphaSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("SrcAlphaSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "SrcAlpha";
}

CSrcAlphaSrcAlphaTest::~CSrcAlphaSrcAlphaTest()
{
}

bool CSrcAlphaSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// SrcAlpha/InvSrcAlpha Test functions

CSrcAlphaInvSrcAlphaTest::CSrcAlphaInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("SrcAlphaInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "InvSrcAlpha";
}

CSrcAlphaInvSrcAlphaTest::~CSrcAlphaInvSrcAlphaTest()
{
}

bool CSrcAlphaInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// SrcAlpha/DestAlpha Test functions

CSrcAlphaDestAlphaTest::CSrcAlphaDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: DestAlpha");
	m_szCommandKey = TEXT("SrcAlphaDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "DestAlpha";
}

CSrcAlphaDestAlphaTest::~CSrcAlphaDestAlphaTest()
{
}

bool CSrcAlphaDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// SrcAlpha/InvDestAlpha Test functions

CSrcAlphaInvDestAlphaTest::CSrcAlphaInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("SrcAlphaInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "InvDestAlpha";
}

CSrcAlphaInvDestAlphaTest::~CSrcAlphaInvDestAlphaTest()
{
}

bool CSrcAlphaInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// SrcAlpha/DestColor Test functions

CSrcAlphaDestColorTest::CSrcAlphaDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: DestColor");
	m_szCommandKey = TEXT("SrcAlphaDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "DestColor";
}

CSrcAlphaDestColorTest::~CSrcAlphaDestColorTest()
{
}

bool CSrcAlphaDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// SrcAlpha/InvDestColor Test functions

CSrcAlphaInvDestColorTest::CSrcAlphaInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: InvDestColor");
	m_szCommandKey = TEXT("SrcAlphaInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "InvDestColor";
}

CSrcAlphaInvDestColorTest::~CSrcAlphaInvDestColorTest()
{
}

bool CSrcAlphaInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// SrcAlpha/SrcAlphaSat Test functions

CSrcAlphaSrcAlphaSatTest::CSrcAlphaSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlpha DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("SrcAlphaSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHA;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlpha";
	szDestName = "SrcAlphaSat";
}

CSrcAlphaSrcAlphaSatTest::~CSrcAlphaSrcAlphaSatTest()
{
}

bool CSrcAlphaSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlpha and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHA);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\dll\include.cpp ===
#include "dll\main.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\srcalphasat.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "SrcAlphaSat.h"

//************************************************************************
// SrcAlphaSat/Zero Test functions

CSrcAlphaSatZeroTest::CSrcAlphaSatZeroTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: Zero");
	m_szCommandKey = TEXT("SrcAlphaSatZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "Zero";
}

CSrcAlphaSatZeroTest::~CSrcAlphaSatZeroTest()
{
}

bool CSrcAlphaSatZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// SrcAlphaSat/One Test functions

CSrcAlphaSatOneTest::CSrcAlphaSatOneTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: One");
	m_szCommandKey = TEXT("SrcAlphaSatOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "One";
}

CSrcAlphaSatOneTest::~CSrcAlphaSatOneTest()
{
}

bool CSrcAlphaSatOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// SrcAlphaSat/SrcColor Test functions

CSrcAlphaSatSrcColorTest::CSrcAlphaSatSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: SrcColor");
	m_szCommandKey = TEXT("SrcAlphaSatSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "SrcColor";
}

CSrcAlphaSatSrcColorTest::~CSrcAlphaSatSrcColorTest()
{
}

bool CSrcAlphaSatSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// SrcAlphaSat/InvSrcColor Test functions

CSrcAlphaSatInvSrcColorTest::CSrcAlphaSatInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("SrcAlphaSatInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "InvSrcColor";
}

CSrcAlphaSatInvSrcColorTest::~CSrcAlphaSatInvSrcColorTest()
{
}

bool CSrcAlphaSatInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// SrcAlphaSat/SrcAlpha Test functions

CSrcAlphaSatSrcAlphaTest::CSrcAlphaSatSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("SrcAlphaSatSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "SrcAlpha";
}

CSrcAlphaSatSrcAlphaTest::~CSrcAlphaSatSrcAlphaTest()
{
}

bool CSrcAlphaSatSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// SrcAlphaSat/InvSrcAlpha Test functions

CSrcAlphaSatInvSrcAlphaTest::CSrcAlphaSatInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("SrcAlphaSatInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "InvSrcAlpha";
}

CSrcAlphaSatInvSrcAlphaTest::~CSrcAlphaSatInvSrcAlphaTest()
{
}

bool CSrcAlphaSatInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// SrcAlphaSat/DestAlpha Test functions

CSrcAlphaSatDestAlphaTest::CSrcAlphaSatDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: DestAlpha");
	m_szCommandKey = TEXT("SrcAlphaSatDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "DestAlpha";
}

CSrcAlphaSatDestAlphaTest::~CSrcAlphaSatDestAlphaTest()
{
}

bool CSrcAlphaSatDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// SrcAlphaSat/InvDestAlpha Test functions

CSrcAlphaSatInvDestAlphaTest::CSrcAlphaSatInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("SrcAlphaSatInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "InvDestAlpha";
}

CSrcAlphaSatInvDestAlphaTest::~CSrcAlphaSatInvDestAlphaTest()
{
}

bool CSrcAlphaSatInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// SrcAlphaSat/DestColor Test functions

CSrcAlphaSatDestColorTest::CSrcAlphaSatDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: DestColor");
	m_szCommandKey = TEXT("SrcAlphaSatDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "DestColor";
}

CSrcAlphaSatDestColorTest::~CSrcAlphaSatDestColorTest()
{
}

bool CSrcAlphaSatDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// SrcAlphaSat/InvDestColor Test functions

CSrcAlphaSatInvDestColorTest::CSrcAlphaSatInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: InvDestColor");
	m_szCommandKey = TEXT("SrcAlphaSatInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "InvDestColor";
}

CSrcAlphaSatInvDestColorTest::~CSrcAlphaSatInvDestColorTest()
{
}

bool CSrcAlphaSatInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// SrcAlphaSat/SrcAlphaSat Test functions

CSrcAlphaSatSrcAlphaSatTest::CSrcAlphaSatSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: SrcAlphaSat DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("SrcAlphaSatSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCALPHASAT;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "SrcAlphaSat";
	szDestName = "SrcAlphaSat";
}

CSrcAlphaSatSrcAlphaSatTest::~CSrcAlphaSatSrcAlphaSatTest()
{
}

bool CSrcAlphaSatSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcAlphaSat and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCALPHASAT);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\exe\include.cpp ===
#include "exe\main.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\srccolor.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	SrcColor.h
 *
 ***************************************************************************/

#ifndef __SRCCOLOR_H__
#define __SRCCOLOR_H__

// SrcColor/Zero Class definitions
class CSrcColorZeroTest: public CAlphaBldTest
{
	public:
	CSrcColorZeroTest();
	~CSrcColorZeroTest();

	bool SetDefaultRenderStates(void);
};

// SrcColor/One Class definitions
class CSrcColorOneTest: public CAlphaBldTest
{
	public:
	CSrcColorOneTest();
	~CSrcColorOneTest();

	bool SetDefaultRenderStates(void);
};

// SrcColor/SrcColor Class definitions
class CSrcColorSrcColorTest: public CAlphaBldTest
{
	public:
	CSrcColorSrcColorTest();
	~CSrcColorSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcColor/InvSrcColor Class definitions
class CSrcColorInvSrcColorTest: public CAlphaBldTest
{
	public:
	CSrcColorInvSrcColorTest();
	~CSrcColorInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcColor/SrcAlpha Class definitions
class CSrcColorSrcAlphaTest: public CAlphaBldTest
{
	public:
	CSrcColorSrcAlphaTest();
	~CSrcColorSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcColor/InvSrcAlpha Class definitions
class CSrcColorInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CSrcColorInvSrcAlphaTest();
	~CSrcColorInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcColor/DestAlpha Class definitions
class CSrcColorDestAlphaTest: public CAlphaBldTest
{
	public:
	CSrcColorDestAlphaTest();
	~CSrcColorDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcColor/InvDestAlpha Class definitions
class CSrcColorInvDestAlphaTest: public CAlphaBldTest
{
	public:
	CSrcColorInvDestAlphaTest();
	~CSrcColorInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcColor/DestColor Class definitions
class CSrcColorDestColorTest: public CAlphaBldTest
{
	public:
	CSrcColorDestColorTest();
	~CSrcColorDestColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcColor/InvDestColor Class definitions
class CSrcColorInvDestColorTest: public CAlphaBldTest
{
	public:
	CSrcColorInvDestColorTest();
	~CSrcColorInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcColor/SrcAlphaSat Class definitions
class CSrcColorSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	CSrcColorSrcAlphaSatTest();
	~CSrcColorSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\zero.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	Zero.h
 *
 ***************************************************************************/

#ifndef __ZERO_H__
#define __ZERO_H__

// Zero/Zero Class definitions
class CZeroZeroTest: public CAlphaBldTest
{
	public:
	CZeroZeroTest();
	~CZeroZeroTest();

	bool SetDefaultRenderStates(void);
};

// Zero/One Class definitions
class CZeroOneTest: public CAlphaBldTest
{
	public:
	CZeroOneTest();
	~CZeroOneTest();

	bool SetDefaultRenderStates(void);
};

// Zero/SrcColor Class definitions
class CZeroSrcColorTest: public CAlphaBldTest
{
	public:
	CZeroSrcColorTest();
	~CZeroSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// Zero/InvSrcColor Class definitions
class CZeroInvSrcColorTest: public CAlphaBldTest
{
	public:
	CZeroInvSrcColorTest();
	~CZeroInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// Zero/SrcAlpha Class definitions
class CZeroSrcAlphaTest: public CAlphaBldTest
{
	public:
	CZeroSrcAlphaTest();
	~CZeroSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// Zero/InvSrcAlpha Class definitions
class CZeroInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CZeroInvSrcAlphaTest();
	~CZeroInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// Zero/DestAlpha Class definitions
class CZeroDestAlphaTest: public CAlphaBldTest
{
	public:
	CZeroDestAlphaTest();
	~CZeroDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// Zero/InvDestAlpha Class definitions
class CZeroInvDestAlphaTest: public CAlphaBldTest
{
	public:
	CZeroInvDestAlphaTest();
	~CZeroInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// Zero/DestColor Class definitions
class CZeroDestColorTest: public CAlphaBldTest
{
	public:
	CZeroDestColorTest();
	~CZeroDestColorTest();

	bool SetDefaultRenderStates(void);
};

// Zero/InvDestColor Class definitions
class CZeroInvDestColorTest: public CAlphaBldTest
{
	public:
	CZeroInvDestColorTest();
	~CZeroInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// Zero/SrcAlphaSat Class definitions
class CZeroSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	CZeroSrcAlphaSatTest();
	~CZeroSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\srccolor.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "SrcColor.h"

//************************************************************************
// SrcColor/Zero Test functions

CSrcColorZeroTest::CSrcColorZeroTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: Zero");
	m_szCommandKey = TEXT("SrcColorZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "Zero";
}

CSrcColorZeroTest::~CSrcColorZeroTest()
{
}

bool CSrcColorZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// SrcColor/One Test functions

CSrcColorOneTest::CSrcColorOneTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: One");
	m_szCommandKey = TEXT("SrcColorOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "One";
}

CSrcColorOneTest::~CSrcColorOneTest()
{
}

bool CSrcColorOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// SrcColor/SrcColor Test functions

CSrcColorSrcColorTest::CSrcColorSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: SrcColor");
	m_szCommandKey = TEXT("SrcColorSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "SrcColor";
}

CSrcColorSrcColorTest::~CSrcColorSrcColorTest()
{
}

bool CSrcColorSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// SrcColor/InvSrcColor Test functions

CSrcColorInvSrcColorTest::CSrcColorInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("SrcColorInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "InvSrcColor";
}

CSrcColorInvSrcColorTest::~CSrcColorInvSrcColorTest()
{
}

bool CSrcColorInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// SrcColor/SrcAlpha Test functions

CSrcColorSrcAlphaTest::CSrcColorSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("SrcColorSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "SrcAlpha";
}

CSrcColorSrcAlphaTest::~CSrcColorSrcAlphaTest()
{
}

bool CSrcColorSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// SrcColor/InvSrcAlpha Test functions

CSrcColorInvSrcAlphaTest::CSrcColorInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("SrcColorInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "InvSrcAlpha";
}

CSrcColorInvSrcAlphaTest::~CSrcColorInvSrcAlphaTest()
{
}

bool CSrcColorInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// SrcColor/DestAlpha Test functions

CSrcColorDestAlphaTest::CSrcColorDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: DestAlpha");
	m_szCommandKey = TEXT("SrcColorDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "DestAlpha";
}

CSrcColorDestAlphaTest::~CSrcColorDestAlphaTest()
{
}

bool CSrcColorDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// SrcColor/InvDestAlpha Test functions

CSrcColorInvDestAlphaTest::CSrcColorInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("SrcColorInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "InvDestAlpha";
}

CSrcColorInvDestAlphaTest::~CSrcColorInvDestAlphaTest()
{
}

bool CSrcColorInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// SrcColor/DestColor Test functions

CSrcColorDestColorTest::CSrcColorDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: DestColor");
	m_szCommandKey = TEXT("SrcColorDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "DestColor";
}

CSrcColorDestColorTest::~CSrcColorDestColorTest()
{
}

bool CSrcColorDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// SrcColor/InvDestColor Test functions

CSrcColorInvDestColorTest::CSrcColorInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: InvDestColor");
	m_szCommandKey = TEXT("SrcColorInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "InvDestColor";
}

CSrcColorInvDestColorTest::~CSrcColorInvDestColorTest()
{
}

bool CSrcColorInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// SrcColor/SrcAlphaSat Test functions

CSrcColorSrcAlphaSatTest::CSrcColorSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: SrcColor DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("SrcColorSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_SRCCOLOR;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "SrcColor";
	szDestName = "SrcAlphaSat";
}

CSrcColorSrcAlphaSatTest::~CSrcColorSrcAlphaSatTest()
{
}

bool CSrcColorSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:SrcColor and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_SRCCOLOR);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\zero.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaBld.h"
#include "Zero.h"

//************************************************************************
// Zero/Zero Test functions

CZeroZeroTest::CZeroZeroTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: Zero");
	m_szCommandKey = TEXT("ZeroZero");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_ZERO;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "Zero";
}

CZeroZeroTest::~CZeroZeroTest()
{
}

bool CZeroZeroTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:Zero
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ZERO);

	return true;
}

//************************************************************************
// Zero/One Test functions

CZeroOneTest::CZeroOneTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: One");
	m_szCommandKey = TEXT("ZeroOne");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_ONE;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "One";
}

CZeroOneTest::~CZeroOneTest()
{
}

bool CZeroOneTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:One
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_ONE);

	return true;
}

//************************************************************************
// Zero/SrcColor Test functions

CZeroSrcColorTest::CZeroSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: SrcColor");
	m_szCommandKey = TEXT("ZeroSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_SRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "SrcColor";
}

CZeroSrcColorTest::~CZeroSrcColorTest()
{
}

bool CZeroSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:SrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCCOLOR);

	return true;
}

//************************************************************************
// Zero/InvSrcColor Test functions

CZeroInvSrcColorTest::CZeroInvSrcColorTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: InvSrcColor");
	m_szCommandKey = TEXT("ZeroInvSrcColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_INVSRCCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "InvSrcColor";
}

CZeroInvSrcColorTest::~CZeroInvSrcColorTest()
{
}

bool CZeroInvSrcColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:InvSrcColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCCOLOR);

	return true;
}

//************************************************************************
// Zero/SrcAlpha Test functions

CZeroSrcAlphaTest::CZeroSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: SrcAlpha");
	m_szCommandKey = TEXT("ZeroSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_SRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "SrcAlpha";
}

CZeroSrcAlphaTest::~CZeroSrcAlphaTest()
{
}

bool CZeroSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:SrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHA);

	return true;
}

//************************************************************************
// Zero/InvSrcAlpha Test functions

CZeroInvSrcAlphaTest::CZeroInvSrcAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: InvSrcAlpha");
	m_szCommandKey = TEXT("ZeroInvSrcAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_INVSRCALPHA;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "InvSrcAlpha";
}

CZeroInvSrcAlphaTest::~CZeroInvSrcAlphaTest()
{
}

bool CZeroInvSrcAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:InvSrcAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVSRCALPHA);

	return true;
}

//************************************************************************
// Zero/DestAlpha Test functions

CZeroDestAlphaTest::CZeroDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: DestAlpha");
	m_szCommandKey = TEXT("ZeroDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_DESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "DestAlpha";
}

CZeroDestAlphaTest::~CZeroDestAlphaTest()
{
}

bool CZeroDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:DestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTALPHA);

	return true;
}

//************************************************************************
// Zero/InvDestAlpha Test functions

CZeroInvDestAlphaTest::CZeroInvDestAlphaTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: InvDestAlpha");
	m_szCommandKey = TEXT("ZeroInvDestAlpha");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_INVDESTALPHA;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "InvDestAlpha";
}

CZeroInvDestAlphaTest::~CZeroInvDestAlphaTest()
{
}

bool CZeroInvDestAlphaTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:InvDestAlpha
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTALPHA);

	return true;
}

//************************************************************************
// Zero/DestColor Test functions

CZeroDestColorTest::CZeroDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: DestColor");
	m_szCommandKey = TEXT("ZeroDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_DESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "DestColor";
}

CZeroDestColorTest::~CZeroDestColorTest()
{
}

bool CZeroDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:DestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_DESTCOLOR);

	return true;
}

//************************************************************************
// Zero/InvDestColor Test functions

CZeroInvDestColorTest::CZeroInvDestColorTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: InvDestColor");
	m_szCommandKey = TEXT("ZeroInvDestColor");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_INVDESTCOLOR;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "InvDestColor";
}

CZeroInvDestColorTest::~CZeroInvDestColorTest()
{
}

bool CZeroInvDestColorTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:InvDestColor
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_INVDESTCOLOR);

	return true;
}

//************************************************************************
// Zero/SrcAlphaSat Test functions

CZeroSrcAlphaSatTest::CZeroSrcAlphaSatTest()
{
	m_szTestName = TEXT("SrcBlend: Zero DestBlend: SrcAlphaSat");
	m_szCommandKey = TEXT("ZeroSrcAlphaSat");

	// Tell parent class what caps to look for
	dwSrcCap = D3DPBLENDCAPS_ZERO;
	dwDestCap = D3DPBLENDCAPS_SRCALPHASAT;

	// Give parent a printable name for the caps
	szSrcName = "Zero";
	szDestName = "SrcAlphaSat";
}

CZeroSrcAlphaSatTest::~CZeroSrcAlphaSatTest()
{
}

bool CZeroSrcAlphaSatTest::SetDefaultRenderStates(void)
{
	// Set blend modes to Src:Zero and Dest:SrcAlphaSat
	SetRenderState(D3DRENDERSTATE_SRCBLEND, (DWORD)D3DBLEND_ZERO);
	SetRenderState(D3DRENDERSTATE_DESTBLEND, (DWORD)D3DBLEND_SRCALPHASAT);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\srcalphasat.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	SrcAlphaSat.h
 *
 ***************************************************************************/

#ifndef __SRCALPHASAT_H__
#define __SRCALPHASAT_H__

// SrcAlphaSat/Zero Class definitions
class CSrcAlphaSatZeroTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatZeroTest();
	~CSrcAlphaSatZeroTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlphaSat/One Class definitions
class CSrcAlphaSatOneTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatOneTest();
	~CSrcAlphaSatOneTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlphaSat/SrcColor Class definitions
class CSrcAlphaSatSrcColorTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatSrcColorTest();
	~CSrcAlphaSatSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlphaSat/InvSrcColor Class definitions
class CSrcAlphaSatInvSrcColorTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatInvSrcColorTest();
	~CSrcAlphaSatInvSrcColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlphaSat/SrcAlpha Class definitions
class CSrcAlphaSatSrcAlphaTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatSrcAlphaTest();
	~CSrcAlphaSatSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlphaSat/InvSrcAlpha Class definitions
class CSrcAlphaSatInvSrcAlphaTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatInvSrcAlphaTest();
	~CSrcAlphaSatInvSrcAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlphaSat/DestAlpha Class definitions
class CSrcAlphaSatDestAlphaTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatDestAlphaTest();
	~CSrcAlphaSatDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlphaSat/InvDestAlpha Class definitions
class CSrcAlphaSatInvDestAlphaTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatInvDestAlphaTest();
	~CSrcAlphaSatInvDestAlphaTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlphaSat/DestColor Class definitions
class CSrcAlphaSatDestColorTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatDestColorTest();
	~CSrcAlphaSatDestColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlphaSat/InvDestColor Class definitions
class CSrcAlphaSatInvDestColorTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatInvDestColorTest();
	~CSrcAlphaSatInvDestColorTest();

	bool SetDefaultRenderStates(void);
};

// SrcAlphaSat/SrcAlphaSat Class definitions
class CSrcAlphaSatSrcAlphaSatTest: public CAlphaBldTest
{
	public:
	CSrcAlphaSatSrcAlphaSatTest();
	~CSrcAlphaSatSrcAlphaSatTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\dll\sources.inc ===
!include ..\..\..\..\sources.inc

TARGETNAME=alphabld
TARGETTYPE=LIBRARY
TARGETPATH=$(TEST_LIB_DEST)

OBJLIBFILES=\
    $(OBJLIBFILES) \
    $(TEST_LIB_PATH)\l_alpbld.lib

TARGETLIBS=\
    $(TARGETLIBS) \
    $(TEST_LIB_PATH)\d3dlocus.lib \
    $(TEST_LIB_PATH)\d3dftest.lib \
    $(TEST_LIB_PATH)\3dmath.lib \
    $(TEST_LIB_PATH)\CShapes.lib \
    $(TEST_LIB_PATH)\l_alpbld.lib

SOURCES=\
    include.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\draw.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaCmp.h"

//************************************************************************
// Internal API:    DrawTriangle
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CAlphaCmpTest::DrawTriangle(int nAlpha)
{
    float fX = (float)m_vpTest.X, fY = (float)m_vpTest.Y;

	if (bGouraud)
	{
		// Gouraud Green Triangle
//		VertexList[dwVertexCount++] = D3DTLVERTEX(D3DVECTOR(140.0f, 10.0f,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,nAlpha-1),0, 0.0f,0.0f);
//		VertexList[dwVertexCount++] = D3DTLVERTEX(D3DVECTOR(310.0f,270.0f,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,nAlpha+1),0, 1.0f,0.0f);
//		VertexList[dwVertexCount++] = D3DTLVERTEX(D3DVECTOR( 10.0f,270.0f,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,nAlpha+1),0, 1.0f,1.0f);

		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(140.0f+fX, 10.0f+fY,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,0)  ,0, 0.0f,0.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(310.0f+fX,270.0f+fY,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255),0, 1.0f,0.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR( 10.0f+fX,270.0f+fY,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255),0, 1.0f,1.0f);
	}
	else
	{
		// Flat Green Triangle
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(140.0f+fX, 10.0f+fY,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,nAlpha),0, 0.0f,0.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(310.0f+fX,270.0f+fY,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,nAlpha),0, 1.0f,0.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR( 10.0f+fX,270.0f+fY,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,nAlpha),0, 1.0f,1.0f);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\alphacmp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	AlphaCmp.h
 *
 ***************************************************************************/

#ifndef __ALPHACMP_H__
#define __ALPHACMP_H__

//USETESTFRAME

// Defines
#define MAX_TESTS	5

// Base Class definitions
class CAlphaCmpTest: public CD3DTest
{
    // Data
	public:
    D3DTLVERTEX     VertexList[3];
    DWORD           dwVertexCount;
	DWORD			dwAlphaCmpCap;
	int				nAlphaValue[5];
	bool			bGouraud;
	char			msgString[80];
	char			szStatus[80];

    BOOL            m_bExit;

	public:
	CAlphaCmpTest();
	~CAlphaCmpTest();

	// Framework functions
	virtual UINT TestInitialize(void);
	virtual bool SetDefaultRenderStates(void);
	virtual bool ExecuteTest(UINT uTestNum);
	virtual void SceneRefresh(void);
	virtual bool ProcessFrame(void);

	// Helper functions
	void DrawTriangle(int nAlpha);

    virtual BOOL    AbortedExit(void);

protected:

    virtual void    ProcessInput();
    virtual BOOL    WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, 
                        WPARAM wParam, LPARAM lParam);
};


// Never Class definitions
class CAlphaNeverTest: public CAlphaCmpTest
{
	public:
	CAlphaNeverTest();
	~CAlphaNeverTest();

	bool SetDefaultRenderStates(void);
};

// Less Class definitions
class CAlphaLessTest: public CAlphaCmpTest
{
	public:
	CAlphaLessTest();
	~CAlphaLessTest();

	bool SetDefaultRenderStates(void);
};

// Equal Class definitions
class CAlphaEqualTest: public CAlphaCmpTest
{
	public:
	CAlphaEqualTest();
	~CAlphaEqualTest();

	bool SetDefaultRenderStates(void);
};

// LessEqual Class definitions
class CAlphaLessEqualTest: public CAlphaCmpTest
{
	public:
	CAlphaLessEqualTest();
	~CAlphaLessEqualTest();

	bool SetDefaultRenderStates(void);
};

// Greater Class definitions
class CAlphaGreaterTest: public CAlphaCmpTest
{
	public:
	CAlphaGreaterTest();
	~CAlphaGreaterTest();

	bool SetDefaultRenderStates(void);
};

// NotEqual Class definitions
class CAlphaNotEqualTest: public CAlphaCmpTest
{
	public:
	CAlphaNotEqualTest();
	~CAlphaNotEqualTest();

	bool SetDefaultRenderStates(void);
};

// GreaterEqual Class definitions
class CAlphaGreaterEqualTest: public CAlphaCmpTest
{
	public:
	CAlphaGreaterEqualTest();
	~CAlphaGreaterEqualTest();

	bool SetDefaultRenderStates(void);
};

// Always Class definitions
class CAlphaAlwaysTest: public CAlphaCmpTest
{
	public:
	CAlphaAlwaysTest();
	~CAlphaAlwaysTest();

	bool SetDefaultRenderStates(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphabld\exe\sources.inc ===
TARGETNAME=alphabld
TARGETTYPE=PROGRAM
TARGETPATH=obj

!include ..\..\..\..\sources.inc

TARGETLIBS=\
    $(TARGETLIBS) \
    $(TEST_LIB_PATH)\d3dlocus.lib \
    $(TEST_LIB_PATH)\d3dftest.lib \
    $(TEST_LIB_PATH)\3dmath.lib \
    $(TEST_LIB_PATH)\CShapes.lib \
    $(TEST_LIB_PATH)\l_alpbld.lib

SOURCES=\
    include.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\equal.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaCmp.h"

//************************************************************************
// Equal Test functions

CAlphaEqualTest::CAlphaEqualTest()
{
	m_szTestName = TEXT("Alpha Compare Equal");
	m_szCommandKey = TEXT("Equal");

	// Tell parent class what cap to look for
	dwAlphaCmpCap = D3DPCMPCAPS_EQUAL;
}

CAlphaEqualTest::~CAlphaEqualTest()
{
}

bool CAlphaEqualTest::SetDefaultRenderStates(void)
{
	// Setup the common default render states
	CAlphaCmpTest::SetDefaultRenderStates();

	// Set the Alpha compare func to Equal
	SetRenderState(D3DRENDERSTATE_ALPHAFUNC, (DWORD)D3DCMP_EQUAL);
	return true;
}

//************************************************************************
// NotEqual Test functions

CAlphaNotEqualTest::CAlphaNotEqualTest()
{
	m_szTestName = TEXT("Alpha Compare NotEqual");
	m_szCommandKey = TEXT("NotEqual");

	// Tell parent class what cap to look for
	dwAlphaCmpCap = D3DPCMPCAPS_NOTEQUAL;
}

CAlphaNotEqualTest::~CAlphaNotEqualTest()
{
}

bool CAlphaNotEqualTest::SetDefaultRenderStates(void)
{
	// Setup the common default render states
	CAlphaCmpTest::SetDefaultRenderStates();

	// Set the Alpha compare func to NotEqual
	SetRenderState(D3DRENDERSTATE_ALPHAFUNC, (DWORD)D3DCMP_NOTEQUAL);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\greater.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaCmp.h"

//************************************************************************
// Greater Test functions

CAlphaGreaterTest::CAlphaGreaterTest()
{
	m_szTestName = TEXT("Alpha Compare Greater");
	m_szCommandKey = TEXT("Greater");

	// Tell parent class what cap to look for
	dwAlphaCmpCap = D3DPCMPCAPS_GREATER;
}

CAlphaGreaterTest::~CAlphaGreaterTest()
{
}

bool CAlphaGreaterTest::SetDefaultRenderStates(void)
{
	// Setup the common default render states
	CAlphaCmpTest::SetDefaultRenderStates();

	// Set the Alpha compare func to Greater
	SetRenderState(D3DRENDERSTATE_ALPHAFUNC, (DWORD)D3DCMP_GREATER);
	return true;
}

//************************************************************************
// GreaterEqual Test functions

CAlphaGreaterEqualTest::CAlphaGreaterEqualTest()
{
	m_szTestName = TEXT("Alpha Compare GreaterEqual");
	m_szCommandKey = TEXT("GreaterEqual");

	// Tell parent class what cap to look for
	dwAlphaCmpCap = D3DPCMPCAPS_GREATEREQUAL;
}

CAlphaGreaterEqualTest::~CAlphaGreaterEqualTest()
{
}

bool CAlphaGreaterEqualTest::SetDefaultRenderStates(void)
{
	// Setup the common default render states
	CAlphaCmpTest::SetDefaultRenderStates();

	// Set the Alpha compare func to GreaterEqual
	SetRenderState(D3DRENDERSTATE_ALPHAFUNC, (DWORD)D3DCMP_GREATEREQUAL);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\dll\include.cpp ===
#include "dll\main.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\always.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaCmp.h"

//************************************************************************
// Never Test functions

CAlphaNeverTest::CAlphaNeverTest()
{
	m_szTestName = TEXT("Alpha Compare Never");
	m_szCommandKey = TEXT("Never");

	// Tell parent class what cap to look for
	dwAlphaCmpCap = D3DPCMPCAPS_NEVER;
}

CAlphaNeverTest::~CAlphaNeverTest()
{
}

bool CAlphaNeverTest::SetDefaultRenderStates(void)
{
	// Setup the common default render states
	CAlphaCmpTest::SetDefaultRenderStates();

	// Set the Alpha compare func to Never
	SetRenderState(D3DRENDERSTATE_ALPHAFUNC, (DWORD)D3DCMP_NEVER);
	return true;
}

//************************************************************************
// Always Test functions

CAlphaAlwaysTest::CAlphaAlwaysTest()
{
	m_szTestName = TEXT("Alpha Compare Always");
	m_szCommandKey = TEXT("Always");

	// Tell parent class what cap to look for
	dwAlphaCmpCap = D3DPCMPCAPS_ALWAYS;
}

CAlphaAlwaysTest::~CAlphaAlwaysTest()
{
}

bool CAlphaAlwaysTest::SetDefaultRenderStates(void)
{
	// Setup the common default render states
	CAlphaCmpTest::SetDefaultRenderStates();

	// Set the Alpha compare func to Always
	SetRenderState(D3DRENDERSTATE_ALPHAFUNC, (DWORD)D3DCMP_ALWAYS);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\exe\include.cpp ===
#include "exe\main.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\alphacmp.cpp ===
#define STRICT
#define BURN_IN_HELL
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaCmp.h"

// Global Test and App instance
//CD3DWindowFramework		App;

//******************************************************************************
//
// Function:
//
//     ValidateDisplay
//
// Description:
//
//     Evaluate the given display information in order to determine whether or
//     not the display is capable of rendering the scene.  If not, the given 
//     display will not be included in the display list.
//
// Arguments:
//
//     CDirect3D8* pd3d                 - Pointer to the Direct3D object
//
//     D3DCAPS8* pd3dcaps               - Capabilities of the device
//
//     D3DDISPLAYMODE*                  - Display mode into which the device
//                                        will be placed
//
// Return Value:
//
//     TRUE if the scene can be rendered using the given display, FALSE if
//     it cannot.
//
//******************************************************************************
extern "C" BOOL PREPEND_MODULE(_ValidateDisplay)(CDirect3D8* pd3d, D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm) {

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     ExhibitScene
//
// Description:
//
//     Create the scene, pump messages, process user input,
//     update the scene, render the scene, and release the scene when finished.
//
// Arguments:
//
//     CDisplay* pDisplay           - Pointer to the Display object
//
//     int* pnExitCode              - Optional pointer to an integer that will
//                                    be set to the exit value contained in the 
//                                    wParam parameter of the WM_QUIT message 
//                                    (if received)
//
// Return Value:
//
//     TRUE if the display remains functional on exit, FALSE otherwise.
//
//******************************************************************************
extern "C" BOOL PREPEND_MODULE(_ExhibitScene)(CDisplay* pDisplay, int* pnExitCode) {

    CAlphaCmpTest* pAlphaCmp;
    BOOL           bQuit = FALSE, bRet = TRUE;
    UINT           i;

    // Verify that the display has been initialized
    if (!pDisplay) {
        return FALSE;
    }

    for (i = 0; i < 8 && !bQuit && bRet; i++) {

        // Create the scene
        switch (i) {
            case 0:
                pAlphaCmp = new CAlphaNeverTest();
                break;
            case 1:
                pAlphaCmp = new CAlphaLessTest();
                break;
            case 2:
                pAlphaCmp = new CAlphaEqualTest();
                break;
            case 3:
                pAlphaCmp = new CAlphaLessEqualTest();
                break;
            case 4:
                pAlphaCmp = new CAlphaGreaterTest();
                break;
            case 5:
                pAlphaCmp = new CAlphaNotEqualTest();
                break;
            case 6:
                pAlphaCmp = new CAlphaGreaterEqualTest();
                break;
            case 7:
                pAlphaCmp = new CAlphaAlwaysTest();
                break;
        }

        if (!pAlphaCmp) {
            return FALSE;
        }

        // Initialize the scene
        if (!pAlphaCmp->Create(pDisplay)) {
            pAlphaCmp->Release();
            return FALSE;
        }

        bRet = pAlphaCmp->Exhibit(pnExitCode);

        bQuit = pAlphaCmp->AbortedExit();

        // Clean up the scene
        pAlphaCmp->Release();
    }

    return bRet;
}

CAlphaCmpTest::CAlphaCmpTest()
{
	// Init to flat shading
	bGouraud = false;

	// Init Alpha value array
	nAlphaValue[0] = 1;
	nAlphaValue[1] = 85;
	nAlphaValue[2] = 128;
	nAlphaValue[3] = 170;
	nAlphaValue[4] = 254;

    // Disable textures
    m_ModeOptions.fTextures = false;

    m_bExit = FALSE;
}

CAlphaCmpTest::~CAlphaCmpTest()
{
}

bool CAlphaCmpTest::SetDefaultRenderStates(void)
{
	// Turn on Alpha testing
	SetRenderState(D3DRENDERSTATE_ALPHATESTENABLE, (DWORD)TRUE);
	return true;
}

UINT CAlphaCmpTest::TestInitialize(void)
{
//    UINT n = m_pMode->nSrcDevice;

	// Are we using Gouraud?
    if (KeySet("Gouraud"))
		bGouraud = true;

	// Setup the Test range
	if (bGouraud)
		SetTestRange(1,MAX_TESTS);
	else
		SetTestRange(1,MAX_TESTS * 3);

	// Check the caps we are interested in
	DWORD dwAlphaCmpCaps = m_d3dcaps.AlphaCmpCaps;

	// Check to see if Alpha testing is supported at all
	if ((dwAlphaCmpCaps == D3DPCMPCAPS_NEVER) || (dwAlphaCmpCaps == D3DPCMPCAPS_ALWAYS))
	{
		WriteToLog("Alpha testing is not supported.\n");
		return D3DTESTINIT_SKIPALL;
	}

	// Check the appropriate Alpha Compare cap
	if (!(dwAlphaCmpCaps & dwAlphaCmpCap))
	{
		WriteToLog("Device capability not supported: %s.\n",m_szTestName);
		return D3DTESTINIT_SKIPALL;
	}
  
    // Tell RenderPrimitive disable API cycling
    // m_dwPrimitives = 1; should be changed to something like 
    // SetAPI(RP_DP);

	return D3DTESTINIT_RUN;
}

bool CAlphaCmpTest::ExecuteTest(UINT uTestNum)
{
	int nTest, nRefValue;

	// Initialize some variables
 	dwVertexCount = 0;
	msgString[0] = '\0';
	szStatus[0] = '\0';

	if (bGouraud)
	{
		nTest = uTestNum - 1;
		nRefValue = nAlphaValue[nTest];

		if (nRefValue == 1)
			nRefValue = 0;
		if (nRefValue == 254)
			nRefValue = 255;
	}
	else
	{
		nTest = (uTestNum - 1) / 3;
		nRefValue = nAlphaValue[nTest] + ((uTestNum - 1) % 3) - 1;
	}

	// Set the Reference Alpha Value
	SetRenderState(D3DRENDERSTATE_ALPHAREF, (DWORD)nRefValue);

	// Let's build some triangles
	DrawTriangle(nAlphaValue[nTest]);

	// Update the log and status window
	if (bGouraud)
	{
//		sprintf(msgString, "%sAlphaRef: %d, Green Triangle: top %d, bottom %d",msgString,nRefValue,nAlphaValue[nTest]-1,nAlphaValue[nTest]+1);
//		sprintf(szStatus, "%sAlphaRef: %d, Green Triangle: top %d, bottom %d",szStatus,nRefValue,nAlphaValue[nTest]-1,nAlphaValue[nTest]+1);

		sprintf(msgString, "%sAlphaRef: %d, Green Triangle: top 0, bottom 255",msgString,nRefValue);
		sprintf(szStatus, "%sAlphaRef: %d, Green Triangle: top 0, bottom 255",szStatus,nRefValue);
	}
	else
	{
		sprintf(msgString, "%sAlphaRef: %d, Green Triangle: %d",msgString,nRefValue,nAlphaValue[nTest]);
		sprintf(szStatus, "%sAlphaRef: %d, Green Triangle: %d",szStatus,nRefValue,nAlphaValue[nTest]);
	}


	// Tell the log that we are starting
	BeginTestCase(msgString);

    return true;
}

void CAlphaCmpTest::SceneRefresh(void)
{
	if (BeginScene())
	{
		// Render the data.
		RenderPrimitive(D3DPT_TRIANGLELIST,D3DFVF_TLVERTEX,VertexList,dwVertexCount,NULL,0,0);

		EndScene();
	}	
}

bool CAlphaCmpTest::ProcessFrame(void)
{
	char	szBuffer[80];
	static	int nPass = 0;
	static  int nFail = 0;
    bool	bResult;

     // Use the standard 15%
    bResult = GetCompareResult(0.15f, 0.78f, 0);

	// Tell the logfile how the compare went
    if (bResult)
    {
		(m_fIncrementForward) ? nPass++ : nPass--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Pass();
    }
	else
	{
		(m_fIncrementForward) ? nFail++ : nFail--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Fail();
	}

	WriteStatus("$gAlpha Values$y",szStatus);
	WriteStatus("$gOverall Results",szBuffer);

    return bResult;
}

//******************************************************************************
BOOL CAlphaCmpTest::AbortedExit(void) {

    return m_bExit;
}

//******************************************************************************
void CAlphaCmpTest::ProcessInput() {

    CD3DTest::ProcessInput();

    if (BUTTON_PRESSED(m_jsJoys, JOYBUTTON_BACK)) {
        m_bExit = TRUE;
    }
}

//******************************************************************************
BOOL CAlphaCmpTest::WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    *plr = 0;

#ifndef UNDER_XBOX

    switch (uMsg) {

        case WM_KEYDOWN:

            switch (wParam) {

                case VK_ESCAPE: // Exit
                    m_bExit = TRUE;
            }

            break;
    }

#endif // !UNDER_XBOX

    return CD3DTest::WndProc(plr, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\sources.inc ===
!include ..\..\..\sources.inc

TARGETNAME=l_alpcmp
TARGETTYPE=LIBRARY
TARGETPATH=$(TEST_LIB_DEST)

SYNCHRONIZE_BLOCK=1

SOURCES=\
	alphacmp.cpp \
	always.cpp \
	draw.cpp \
	equal.cpp \
	greater.cpp \
	less.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\modulex.h ===
#define PREPEND_MODULE(Suffix) alphacmp##Suffix
#define MODULE_STRING "alphacmp"
#pragma comment(linker, "/include:_alphacmp_ExhibitScene@8")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\dll\sources.inc ===
!include ..\..\..\..\sources.inc

TARGETNAME=alphacmp
TARGETTYPE=LIBRARY
TARGETPATH=$(TEST_LIB_DEST)

OBJLIBFILES=\
    $(OBJLIBFILES) \
    $(TEST_LIB_PATH)\l_alpcmp.lib

TARGETLIBS=\
    $(TARGETLIBS) \
    $(TEST_LIB_PATH)\d3dlocus.lib \
    $(TEST_LIB_PATH)\d3dftest.lib \
    $(TEST_LIB_PATH)\3dmath.lib \
    $(TEST_LIB_PATH)\CShapes.lib \
    $(TEST_LIB_PATH)\l_alpcmp.lib

SOURCES=\
    include.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\less.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "AlphaCmp.h"

//************************************************************************
// Less Test functions

CAlphaLessTest::CAlphaLessTest()
{
	m_szTestName = TEXT("Alpha Compare Less");
	m_szCommandKey = TEXT("Less");

	// Tell parent class what cap to look for
	dwAlphaCmpCap = D3DPCMPCAPS_LESS;
}

CAlphaLessTest::~CAlphaLessTest()
{
}

bool CAlphaLessTest::SetDefaultRenderStates(void)
{
	// Setup the common default render states
	CAlphaCmpTest::SetDefaultRenderStates();

	// Set the Alpha compare func to Less
	SetRenderState(D3DRENDERSTATE_ALPHAFUNC, (DWORD)D3DCMP_LESS);
	return true;
}

//************************************************************************
// LessEqual Test functions

CAlphaLessEqualTest::CAlphaLessEqualTest()
{
	m_szTestName = TEXT("Alpha Compare LessEqual");
	m_szCommandKey = TEXT("LessEqual");

	// Tell parent class what cap to look for
	dwAlphaCmpCap = D3DPCMPCAPS_LESSEQUAL;
}

CAlphaLessEqualTest::~CAlphaLessEqualTest()
{
}

bool CAlphaLessEqualTest::SetDefaultRenderStates(void)
{
	// Setup the common default render states
	CAlphaCmpTest::SetDefaultRenderStates();

	// Set the Alpha compare func to LessEqual
	SetRenderState(D3DRENDERSTATE_ALPHAFUNC, (DWORD)D3DCMP_LESSEQUAL);
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\alphacmp\exe\sources.inc ===
TARGETNAME=alphacmp
TARGETTYPE=PROGRAM
TARGETPATH=obj

!include ..\..\..\..\sources.inc

TARGETLIBS=\
    $(TARGETLIBS) \
    $(TEST_LIB_PATH)\d3dlocus.lib \
    $(TEST_LIB_PATH)\d3dftest.lib \
    $(TEST_LIB_PATH)\3dmath.lib \
    $(TEST_LIB_PATH)\CShapes.lib \
    $(TEST_LIB_PATH)\l_alpcmp.lib

SOURCES=\
    include.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\basicrst.cpp ===
#define STRICT
#define BURN_IN_HELL
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "BasicRst.h"

// Global Test and App instance
//CD3DWindowFramework	App;

//******************************************************************************
//
// Function:
//
//     ValidateDisplay
//
// Description:
//
//     Evaluate the given display information in order to determine whether or
//     not the display is capable of rendering the scene.  If not, the given 
//     display will not be included in the display list.
//
// Arguments:
//
//     CDirect3D8* pd3d                 - Pointer to the Direct3D object
//
//     D3DCAPS8* pd3dcaps               - Capabilities of the device
//
//     D3DDISPLAYMODE*                  - Display mode into which the device
//                                        will be placed
//
// Return Value:
//
//     TRUE if the scene can be rendered using the given display, FALSE if
//     it cannot.
//
//******************************************************************************
extern "C" BOOL PREPEND_MODULE(_ValidateDisplay)(CDirect3D8* pd3d, D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm) {

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     ExhibitScene
//
// Description:
//
//     Create the scene, pump messages, process user input,
//     update the scene, render the scene, and release the scene when finished.
//
// Arguments:
//
//     CDisplay* pDisplay           - Pointer to the Display object
//
//     int* pnExitCode              - Optional pointer to an integer that will
//                                    be set to the exit value contained in the 
//                                    wParam parameter of the WM_QUIT message 
//                                    (if received)
//
// Return Value:
//
//     TRUE if the display remains functional on exit, FALSE otherwise.
//
//******************************************************************************
extern "C" BOOL PREPEND_MODULE(_ExhibitScene)(CDisplay* pDisplay, int* pnExitCode) {

    CBasicRstTest* pBasicRst;
    BOOL           bQuit = FALSE, bRet = TRUE;
    UINT           i;

    // Verify that the display has been initialized
    if (!pDisplay) {
        return FALSE;
    }

    for (i = 0; i < 10 && !bQuit && bRet; i++) {

        // Create the scene
        switch (i) {
            case 0:
                pBasicRst = new CCullingTest();
                break;
            case 1:
                pBasicRst = new CDitherTest();
                break;
            case 2:
                pBasicRst = new CFillTest();
                break;
            case 3:
                pBasicRst = new CShadingTest();
                break;
            case 4:
                pBasicRst = new CZWriteTest();
                break;
            case 5:
                pBasicRst = new CMeshTLTest();
                break;
            case 6:
                pBasicRst = new CMeshLTest();
                break;
            case 7:
                pBasicRst = new CMeshD3DTest();
                break;
            case 8:
                pBasicRst = new CColorWriteTest();
                break;
            case 9:
                pBasicRst = new CNoDiffuseTest();
                break;
        }

        if (!pBasicRst) {
            return FALSE;
        }

        // Initialize the scene
        if (!pBasicRst->Create(pDisplay)) {
            pBasicRst->Release();
            return FALSE;
        }

        bRet = pBasicRst->Exhibit(pnExitCode);

        bQuit = pBasicRst->AbortedExit();

        // Clean up the scene
        pBasicRst->Release();
    }

    return bRet;
}

CBasicRstTest::CBasicRstTest()
{
    // Disable textures
    m_ModeOptions.fTextures = false;
    m_bExit = FALSE;
}

CBasicRstTest::~CBasicRstTest()
{
}

bool CBasicRstTest::ClearFrame(void)
{
	return Clear(RGBA_MAKE(0,0,0,255));
}

void CBasicRstTest::SceneRefresh(void)
{
	if (BeginScene())
	{
		// Render the data.
		RenderPrimitive(D3DPT_TRIANGLELIST,D3DFVF_TLVERTEX,VertexList,dwVertexCount,NULL,0,0);

		EndScene();
	}	
}
 
bool CBasicRstTest::ProcessFrame(void)
{
	char	szBuffer[80];
	static	int nPass = 0;
	static  int nFail = 0;
    bool	bResult;

     // Use the standard 15%
    bResult = GetCompareResult(0.15f, 0.78f, 0);

	// Tell the logfile how the compare went
    if (bResult)
    {
		(m_fIncrementForward) ? nPass++ : nPass--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Pass();
    }
	else
	{
		(m_fIncrementForward) ? nFail++ : nFail--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Fail();
	}

	WriteStatus("$gOverall Results",szBuffer);

    return bResult;
}

//******************************************************************************
BOOL CBasicRstTest::AbortedExit(void) {

    return m_bExit;
}

//******************************************************************************
void CBasicRstTest::ProcessInput() {

    CD3DTest::ProcessInput();

    if (BUTTON_PRESSED(m_jsJoys, JOYBUTTON_BACK)) {
        m_bExit = TRUE;
    }
}

//******************************************************************************
BOOL CBasicRstTest::WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    *plr = 0;

#ifndef UNDER_XBOX

    switch (uMsg) {

        case WM_KEYDOWN:

            switch (wParam) {

                case VK_ESCAPE: // Exit
                    m_bExit = TRUE;
            }

            break;
    }

#endif // !UNDER_XBOX

    return CD3DTest::WndProc(plr, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\colorwrite.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "BasicRst.h"

//************************************************************************
// ColorWrite Test functions

CColorWriteTest::CColorWriteTest()
{
	m_szTestName = TEXT("BasicRst ColorWrite");
	m_szCommandKey = TEXT("ColorWrite");

    pTempSurface = NULL;
    pPrevSurface = NULL;
}

CColorWriteTest::~CColorWriteTest()
{
}

UINT CColorWriteTest::TestInitialize(void)
{
//    UINT n = m_pMode->nSrcDevice;

	// Setup the Test range
	SetTestRange(1,COLORWRITE_TESTS * 3);

	// Make sure we are on at lease DX8
	if (m_dwVersion <= 0x0700)
	{
		WriteToLog("This test requires at least Dx8.\n");
		return D3DTESTINIT_SKIPALL;
	}

    // Check the caps we are interested in
	DWORD dwMiscCaps = m_d3dcaps.PrimitiveMiscCaps;

	// Check the ColorWriteEnable cap
	if (!(dwMiscCaps & D3DPMISCCAPS_COLORWRITEENABLE))
	{
		WriteToLog("Device capability not supported: Misc ColorWriteEnable.\n");
		return D3DTESTINIT_SKIPALL;
	}

     // Build up a temporary buffer with alpha channel
    if (CreateDestBuffer())
		bDestBuffer = true;
    else
        bDestBuffer = false;

    // Tell RenderPrimitive disable API cycling
    // m_dwPrimitives = 1; should be changed to something like 
    // SetAPI(RP_DP);

	return D3DTESTINIT_RUN;
}

bool CColorWriteTest::ClearFrame(void)
{
    return true;
}

bool CColorWriteTest::ExecuteTest(UINT uTestNum)
{
    int     nTest, nGroup;

	// Initialize some variables
    nTest = ((uTestNum-1) % COLORWRITE_TESTS) + 1;
    nGroup = (uTestNum-1) / COLORWRITE_TESTS;
 	dwVertexCount = 0;
	szClear[0] = '\0';
	szColor[0] = '\0';
	msgString[0] = '\0';

	// Set the render target to render to our temporary surface.
    if (bDestBuffer)
    {
        if (FAILED(m_pDevice->SetRenderTarget(pTempSurface, NULL)))
//	    if (!SetRenderTarget(pTempSurface, false, m_pSrcZBuffer))
	    {
		    WriteToLog("SetRenderTarget() to TempSurface failed\n");
		    RELEASE(pTempSurface);
//		    TestFinish(D3DTESTFINISH_ABORT);
		    return false;
	    }
    }

	// Let's build some triangles.
	DrawColorWriteTests();

    // Update clear color for logfile and status window
    if (nGroup == 0)
    {
        Clear(RGBA_MAKE(0,0,0,0));
        sprintf(szClear,"RGBA(0,0,0,0)");
    	sprintf(msgString, "%sClear: RGBA(0,0,0,0)", msgString);
    }
    else if (nGroup == 1)
    {
        Clear(RGBA_MAKE(128,128,128,128));
        sprintf(szClear,"RGBA(128,128,128,128)");
    	sprintf(msgString, "%sClear: RGBA(128,128,128,128)", msgString);
    }
    else // nGroup == 2
    {
        Clear(RGBA_MAKE(255,255,255,255));
        sprintf(szClear,"RGBA(255,255,255,255)");
    	sprintf(msgString, "%sClear: RGBA(255,255,255,255)", msgString);
    }

    // By default, don't check alpha values
    bAlphaMask = false;

	// Set the appropriate renderstate
	switch (nTest)
	{
		case (1):
			sprintf(msgString, "%s, ColorWrite: Default", msgString);
            sprintf(szColor,"Default");
            bAlphaMask = true;
			break;
		case (2):
			sprintf(msgString, "%s, ColorWrite: Red", msgString);
            sprintf(szColor,"Red");
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_RED);
			break;
		case (3):
			sprintf(msgString, "%s, ColorWrite: Green", msgString);
            sprintf(szColor,"Green");
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_GREEN);
			break;
		case (4):
			sprintf(msgString, "%s, ColorWrite: Blue", msgString);
            sprintf(szColor,"Blue");
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_BLUE);
			break;
		case (5):
			sprintf(msgString, "%s, ColorWrite: Alpha", msgString);
            sprintf(szColor,"Alpha");
            bAlphaMask = true;
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_ALPHA);
			break;
		case (6):
			sprintf(msgString, "%s, ColorWrite: Red|Green", msgString);
            sprintf(szColor,"Red|Green");
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_RED|D3DCOLORWRITEENABLE_GREEN);
			break;
		case (7):
			sprintf(msgString, "%s, ColorWrite: Red|Blue", msgString);
            sprintf(szColor,"Red|Blue");
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_RED|D3DCOLORWRITEENABLE_BLUE);
			break;
		case (8):
			sprintf(msgString, "%s, ColorWrite: Red|Alpha", msgString);
            sprintf(szColor,"Red|Alpha");
            bAlphaMask = true;
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_RED|D3DCOLORWRITEENABLE_ALPHA);
			break;
		case (9):
			sprintf(msgString, "%s, ColorWrite: Green|Blue", msgString);
            sprintf(szColor,"Green|Blue");
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_BLUE);
			break;
		case (10):
			sprintf(msgString, "%s, ColorWrite: Green|Alpha", msgString);
            sprintf(szColor,"Green|Alpha");
            bAlphaMask = true;
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_ALPHA);
			break;
		case (11):
			sprintf(msgString, "%s, ColorWrite: Blue|Alpha", msgString);
            sprintf(szColor,"Blue|Alpha");
            bAlphaMask = true;
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_BLUE|D3DCOLORWRITEENABLE_ALPHA);
			break;
		case (12):
			sprintf(msgString, "%s, ColorWrite: Red|Green|Blue", msgString);
            sprintf(szColor,"Red|Green|Blue");
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_RED|D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_BLUE);
			break;
		case (13):
			sprintf(msgString, "%s, ColorWrite: Red|Green|Alpha", msgString);
            sprintf(szColor,"Red|Green|Alpha");
            bAlphaMask = true;
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_RED|D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_ALPHA);
			break;
		case (14):
			sprintf(msgString, "%s, ColorWrite: Red|Blue|Alpha", msgString);
            sprintf(szColor,"Red|Blue|Alpha");
            bAlphaMask = true;
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_RED|D3DCOLORWRITEENABLE_BLUE|D3DCOLORWRITEENABLE_ALPHA);
			break;
		case (15):
			sprintf(msgString, "%s, ColorWrite: Green|Blue|Alpha", msgString);
            sprintf(szColor,"Green|Blue|Alpha");
            bAlphaMask = true;
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_BLUE|D3DCOLORWRITEENABLE_ALPHA);
			break;
		case (16):
			sprintf(msgString, "%s, ColorWrite: Red|Green|Blue|Alpha", msgString);
            sprintf(szColor,"Red|Green|Blue|Alpha");
            bAlphaMask = true;
			SetRenderState(D3DRS_COLORWRITEENABLE, (DWORD)D3DCOLORWRITEENABLE_RED|D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_BLUE|D3DCOLORWRITEENABLE_ALPHA);
			break;
	}

	// Tell the log that we are starting
	BeginTestCase(msgString);

    return true;
}

void CColorWriteTest::SceneRefresh(void)
{
	if (BeginScene())
	{
        HRESULT hr;

        // Render the data.
		RenderPrimitive(D3DPT_TRIANGLELIST,D3DFVF_TLVERTEX,VertexList,dwVertexCount,NULL,0,0);

		EndScene();

        if (bDestBuffer)
        {
            D3DLOCKED_RECT d3dlr;

            // Load the image back to the original back buffer
            hr = D3DXLoadSurfaceFromSurface(
		             pPrevSurface->GetIDirect3DSurface8(),
		             NULL, 
                     NULL,					    
			         pTempSurface->GetIDirect3DSurface8(), 
			         NULL,					    
			         NULL,					   
			         D3DX_FILTER_POINT, 	  
                     0);

            if (FAILED(hr))
            {
                WriteToLog("Source D3DXLoadSurfaceFromSurface() failed with HResult = %X.\n",hr);
            }

            pPrevSurface->LockRect(&d3dlr, NULL, 0);
            pPrevSurface->UnlockRect();

	        // Set the render target to our original surface
            if (FAILED(m_pDevice->SetRenderTarget(pPrevSurface, NULL)))
//	        if (!SetRenderTarget(pPrevSurface, false, m_pSrcZBuffer))
	        {
		        WriteToLog("SetRenderTarget() back to PrevSurface failed\n");
	        }
        }
	}	
}

bool CColorWriteTest::ProcessFrame(void)
{
	char	szBuffer[80];
    DWORD   dwAlphaValue;
    bool	bCompareResult;
    bool    bAlphaResult = true;
	static	int nPass = 0;
	static  int nFail = 0;

     // Use the standard 15%
    bCompareResult = GetCompareResult(0.15f, 0.78f, 0);

    if (bDestBuffer)
    {
	    RECT	rSurf;
	    DWORD	dwColor;
	    void	*pBuf, *pColor;
        D3DLOCKED_RECT d3dlr;

	    // Build the subrect we want
	    rSurf.top = 10;
	    rSurf.left = 10;
	    rSurf.bottom = 270;
	    rSurf.right = 310;

	    // Get the Surface data pointer for our subrect
        if (FAILED(pTempSurface->LockRect(&d3dlr, &rSurf, 0))) {
            pBuf = NULL;
        }
        else {
            pBuf = d3dlr.pBits;
        }
//        pBuf = pTempSurface->Lock(&rSurf);

        if (pBuf == NULL)
	    {
		    WriteToLog("ProcessFrame: Lock failed on back buffer.");
            return false;
	    }

	    // Look for Alpha pixel matches
	    for (int j=0; j < 260; j++)		// Height loop
	    {
		    pColor = (char*)pBuf + (d3dlr.Pitch * j);

		    for (int i=0; i < 300; i++)	// Width loop
		    {
//                DWORD dwFilter = (pTempSurface->m_dwAlphaMask << pTempSurface->m_nAlphaShift) | pTempSurface->m_dwFilter;
			    DWORD dwAlpha, dwClearAlpha;

//			    dwColor = pTempSurface->ReadColor(&pColor);
                dwColor = *(LPDWORD)pColor;

			    dwAlpha = RGBA_GETALPHA(dwColor);
			    dwClearAlpha = RGBA_GETALPHA(m_dwClearColor);

                if (bAlphaMask)
                {
                    if (dwAlpha != 240)
                    {
                        bAlphaResult = false;
                        dwAlphaValue = dwAlpha;
                    }
                }
                else
                {
                    if (dwAlpha != dwClearAlpha)
                    {
                        bAlphaResult = false;
                        dwAlphaValue = dwAlpha;
                    }
                }
		    }
	    }

        if (FAILED(pTempSurface->UnlockRect()))
//        if (!pTempSurface->Unlock())
 	    {
		    WriteToLog("ProcessFrame: Unlock failed on back buffer.");
            return false;
	    }
    }

	// Tell the logfile how the compare went
    if (bCompareResult && bAlphaResult)
    {
		(m_fIncrementForward) ? nPass++ : nPass--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Pass();
    }
	else if (!bAlphaResult)
    {
        if (bAlphaMask)
		    WriteToLog("Found invalid Alpha value (%d, expected 240) on destination surface.\n",dwAlphaValue);
        else
		    WriteToLog("Found invalid Alpha value (%d, expected %d) on destination surface.\n",dwAlphaValue,RGBA_GETALPHA(m_dwClearColor));

		(m_fIncrementForward) ? nFail++ : nFail--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Fail();
    }
    else
	{
		(m_fIncrementForward) ? nFail++ : nFail--;
		sprintf(szBuffer,"$yPass: %d, Fail: %d", nPass, nFail);
        Fail();
	}

    // Update the Status window
	WriteStatus("$gColorWriteEnable$y",szColor);
	WriteStatus("$gClear Color$y",szClear);
	WriteStatus("$gOverall Results",szBuffer);

    return (bCompareResult && bAlphaResult);
}

bool CColorWriteTest::TestTerminate()
{
	// Cleanup buffers that we created
	RELEASE(pTempSurface);
	RELEASE(pPrevSurface);

	return true;
}

bool CColorWriteTest::CreateDestBuffer(void)
{
    HRESULT hr;
    D3DSURFACE_DESC Desc;

    // Get the render target
    hr = m_pDevice->GetRenderTarget(&pPrevSurface);
    if (ResultFailed(hr, TEXT("IDirect3DDevice8::GetRenderTarget"))) {
        return false;
    }

    pPrevSurface->GetDesc(&Desc);

    // Create a temp surface for rendering
//    pTempSurface = new CDirectDrawSurface(this);

//    if (NULL == pTempSurface)
//	{
//		WriteToLog("Initialize failed\n");
//		RELEASE(pTempSurface);
//		return false;
//	}

//    m_pSrcTarget->GetSurfaceDescription(&Desc);

    hr = m_pSrcDevice8->CreateRenderTarget(Desc.Width, 
                                           Desc.Height,
                                           D3DFMT_LIN_A8R8G8B8,
                                           D3DMULTISAMPLE_NONE,
                                           TRUE,
                                           &pTempSurface); 
    if (FAILED(hr))
    {
	    WriteToLog("CreateRenderTarget() failed with HResult = %0x%X.\n",hr);
		RELEASE(pPrevSurface);
		return false;
	}


    // Get and process surface description 
    if (FAILED(pTempSurface->GetDesc(&Desc)))
//    if (pTempSurface->GetSurfaceDescription(&Desc))
//        pTempSurface->ProcessSurfaceDescription(&Desc);
//    else
    {
	    WriteToLog("Failed to get texture surface description.\n");
		RELEASE(pPrevSurface);
		RELEASE(pTempSurface);
		return false;
    }

	// Save a pointer to the previous surface
//	pPrevSurface = m_pSrcTarget;
//    pPrevSurface->AddRef();

	// Set the render target to render to our temporary surface.
    if (FAILED(m_pDevice->SetRenderTarget(pTempSurface, NULL)))
//	if (!SetRenderTarget(pTempSurface, false, m_pSrcZBuffer))
	{
		WriteToLog("SetRenderTarget() to TempSurface failed\n");
		RELEASE(pTempSurface);
		return false;
	}

    return true;
}

//************************************************************************
// Internal API:    DrawColorWriteTests
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CColorWriteTest::DrawColorWriteTests(void)
{
    D3DVECTOR v0 = { 10.0f, 10.0f, 0.5f};
    D3DVECTOR v1 = {160.0f, 10.0f, 0.5f};
    D3DVECTOR v2 = { 10.0f,270.0f, 0.5f};
    D3DVECTOR v3 = { 10.0f,270.0f, 0.5f};
    D3DVECTOR v4 = {160.0f, 10.0f, 0.5f};
    D3DVECTOR v5 = {160.0f,270.0f, 0.5f};
    D3DVECTOR v6 = {160.0f,270.0f, 0.5f};
    D3DVECTOR v7 = {160.0f, 10.0f, 0.5f};
    D3DVECTOR v8 = {310.0f,270.0f, 0.5f};
    D3DVECTOR v9 = {160.0f, 10.0f, 0.5f};
    D3DVECTOR v10 = {310.0f, 10.0f, 0.5f};
    D3DVECTOR v11 = {310.0f,270.0f, 0.5f};

    // RGB Triangle
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v0, (1.0f / 0.5f), RGBA_MAKE(0,255,0,240), 0, 0.5f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v1, (1.0f / 0.5f), RGBA_MAKE(0,0,255,240), 0, 1.0f,1.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v2, (1.0f / 0.5f), RGBA_MAKE(255,0,0,240), 0, 0.0f,1.0f);

    // White Triangle
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v3, (1.0f / 0.5f), RGBA_MAKE(255,255,255,240), 0, 0.5f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v4, (1.0f / 0.5f), RGBA_MAKE(255,255,255,240), 0, 1.0f,1.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v5, (1.0f / 0.5f), RGBA_MAKE(255,255,255,240), 0, 0.0f,1.0f);

    // Black Triangle
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v6, (1.0f / 0.5f), RGBA_MAKE(0,0,0,240), 0, 0.5f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v7, (1.0f / 0.5f), RGBA_MAKE(0,0,0,240), 0, 1.0f,1.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v8, (1.0f / 0.5f), RGBA_MAKE(0,0,0,240), 0, 0.0f,1.0f);

    // CMY Triangle
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v9,  (1.0f / 0.5f), RGBA_MAKE(0,255,255,240), 0, 0.5f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v10, (1.0f / 0.5f), RGBA_MAKE(255,0,255,240), 0, 1.0f,1.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(v11, (1.0f / 0.5f), RGBA_MAKE(255,255,0,240), 0, 0.0f,1.0f);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\basicrst.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	BasicRst.h
 *
 ***************************************************************************/

#ifndef __BASICRST_H__
#define __BASICRST_H__

//USETESTFRAME

// Defines
#define CULLING_TESTS	     3
#define DITHER_TESTS	     8
#define FILL_TESTS		    20
#define SHADING_TESTS	    14
#define ZWRITE_TESTS	     4
#define MESH_TL_TESTS	    20
#define MESH_L_TESTS	    19
#define MESH_D3D_TESTS	    22
#define COLORWRITE_TESTS	16

// Base Class definitions
class CBasicRstTest: public CD3DTest
{
    // Data
	public:
    D3DTLVERTEX     VertexList[400];
    DWORD           dwVertexCount;
	char			msgString[80];

    BOOL            m_bExit;

	public:
	CBasicRstTest();
	~CBasicRstTest();

	// Framework functions
	virtual bool ClearFrame(void);
	virtual void SceneRefresh(void);
	virtual bool ProcessFrame(void);

    virtual BOOL    AbortedExit(void);

protected:

    virtual void    ProcessInput();
    virtual BOOL    WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, 
                        WPARAM wParam, LPARAM lParam);
};

// Culling Class definitions
class CCullingTest: public CBasicRstTest
{
	public:
	CCullingTest();
	~CCullingTest();

	// Framework functions
	UINT TestInitialize(void);
	bool ExecuteTest(UINT uTestNum);

	// Helper functions
	void DrawCullTests(void);
};

// Dither Class definitions
class CDitherTest: public CBasicRstTest
{
	public:
	CDitherTest();
	~CDitherTest();

	// Framework functions
	UINT TestInitialize(void);
	bool ExecuteTest(UINT uTestNum);

	// Helper functions
	void DrawDitherTests(int nTest);
};

// Fill Class definitions
class CFillTest: public CBasicRstTest
{
    // Data
    DWORD	dwRasterCaps;

	public:
	CFillTest();
	~CFillTest();

	// Framework functions
	UINT TestInitialize(void);
	bool ExecuteTest(UINT uTestNum);

	// Helper functions
	void DrawFillTests(int nTest);
};

// Shading Class definitions
class CShadingTest: public CBasicRstTest
{
	// Data
	D3DPRIMITIVETYPE PrimType;
    D3DTLVERTEX      Single1List[3];
    D3DTLVERTEX      Single2List[3];
    D3DTLVERTEX      Single3List[3];

	public:
	CShadingTest();
	~CShadingTest();

	// Framework functions
	UINT TestInitialize(void);
	bool ExecuteTest(UINT uTestNum);
	void SceneRefresh(void);

	// Helper functions
	void DrawShadeListTests(int nTest);
	void DrawShadeStripTests(void);
	void DrawShadeFanTests(void);
};

// ZWrite Class definitions
class CZWriteTest: public CBasicRstTest
{
	public:
	CZWriteTest();
	~CZWriteTest();

	// Framework functions
	UINT TestInitialize(void);
	bool ExecuteTest(UINT uTestNum);

	// Helper functions
	void DrawZWriteTests(void);
};

// MeshTL Class definitions
class CMeshTLTest: public CBasicRstTest
{
    // Data
    DWORD	dwWidth;
    DWORD	dwHeight;

	public:
	CMeshTLTest();
	~CMeshTLTest();

	// Framework functions
	UINT TestInitialize(void);
	bool ExecuteTest(UINT uTestNum);
	void SceneRefresh(void);

	// Helper functions
	void DrawCircle(D3DVECTOR* pCenter, float Radius, int nDivisions, D3DCOLOR Color);
	void DrawMeshTests(int nTest);
};

// MeshL Class definitions
class CMeshLTest: public CBasicRstTest
{
    struct LLVERTEX {
        D3DVALUE     x;             /* Homogeneous coordinates */
        D3DVALUE     y;
        D3DVALUE     z;
        D3DCOLOR     color;         /* Vertex color */
        D3DCOLOR     specular;      /* Specular component of vertex */
        D3DVALUE     tu;            /* Texture coordinates */
        D3DVALUE     tv;

        LLVERTEX() { }
        LLVERTEX(const D3DVECTOR& v,
                    D3DCOLOR _color, D3DCOLOR _specular,
                    float _tu, float _tv)
            { x = v.x; y = v.y; z = v.z; 
              color = _color; specular = _specular;
              tu = _tu; tv = _tv;
            }
    };

    // Data
	LLVERTEX	LVertexList[100];

	public:
	CMeshLTest();
	~CMeshLTest();

	// Framework functions
	bool SetDefaultRenderStates(void);
	bool SetDefaultMatrices(void);
	UINT TestInitialize(void);
	bool ExecuteTest(UINT uTestNum);
	void SceneRefresh(void);

	// Helper functions
	void DrawMeshTests(int nTest);
};

// MeshD3D Class definitions
class CMeshD3DTest: public CBasicRstTest
{
    // Data
	D3DVERTEX	D3DVertexList[100];
// 	CMaterial   *pMaterial;

	public:
	CMeshD3DTest();
	~CMeshD3DTest();

	// Framework functions
	bool SetDefaultMatrices(void);
	UINT TestInitialize(void);
	bool ExecuteTest(UINT uTestNum);
	void SceneRefresh(void);
	bool TestTerminate();

	// Helper functions
	D3DCOLOR DrawMeshTests(int nTest);
};

// ColorWrite Class definitions
class CColorWriteTest: public CBasicRstTest
{
    bool    bAlphaMask;
    bool    bDestBuffer;
	char	szColor[80];
	char	szClear[80];
    CSurface8* pPrevSurface;
    CSurface8* pTempSurface;
//	CDirectDrawSurface *  pPrevSurface;
//	CDirectDrawSurface *  pTempSurface;

	public:
	CColorWriteTest();
	~CColorWriteTest();

	// Framework functions
	UINT TestInitialize(void);
	bool ClearFrame(void);
	bool ExecuteTest(UINT uTestNum);
	void SceneRefresh(void);
	bool ProcessFrame(void);
    bool TestTerminate();

	// Helper functions
    bool CreateDestBuffer(void);
	void DrawColorWriteTests(void);
};

// NoDiffuse Class definitions
class CNoDiffuseTest: public CBasicRstTest
{
    struct ND_VERTEX {
        D3DVALUE     x;     /* Homogeneous coordinates */
        D3DVALUE     y;
        D3DVALUE     z;
        D3DVALUE     rhw;   /* Reciprocal of homogeneous w */
        D3DVALUE     tu;    /* Texture coordinates */
        D3DVALUE     tv;

        ND_VERTEX() { }
        ND_VERTEX(const D3DVECTOR& v,
                    D3DVALUE _rhw,
                    float _tu, float _tv)
            { x = v.x; y = v.y; z = v.z; 
              rhw = _rhw;
              tu = _tu; tv = _tv;
            }
    };

    // Data
	ND_VERTEX	    NoDiffuseList[6];

	public:
	CNoDiffuseTest();
	~CNoDiffuseTest();

	// Framework functions
	UINT TestInitialize(void);
	bool ExecuteTest(UINT uTestNum);
	void SceneRefresh(void);

	// Helper functions
	void DrawNonDiffuseGrid(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\fill.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "BasicRst.h"

//************************************************************************
// Fill Test functions

CFillTest::CFillTest()
{
	m_szTestName = TEXT("BasicRst Fill");
	m_szCommandKey = TEXT("Fill");
}

CFillTest::~CFillTest()
{
}

UINT CFillTest::TestInitialize(void)
{
//    UINT n = m_pMode->nSrcDevice;

	// Setup the Test range
	SetTestRange(1,FILL_TESTS);

	// Get the caps we are interested in
	dwRasterCaps = m_d3dcaps.RasterCaps;

    // Tell RenderPrimitive disable API cycling
    // m_dwPrimitives = 1; should be changed to something like 
    // SetAPI(RP_DP);

	return D3DTESTINIT_RUN;
}

bool CFillTest::ExecuteTest(UINT uTestNum)
{
	// Initialize some variables
 	dwVertexCount = 0;
	msgString[0] = '\0';

	// Let's build some triangles.
	DrawFillTests(uTestNum);

	// Tell the log that we are starting
	BeginTestCase(msgString);

    if (m_dwVersion <= 0x0700)
    {
	    // Make a special cap check for the wagon wheel test
	    if (uTestNum == 20)
	    {
		    // Check the SubPixel caps
//		    if (!(dwRasterCaps & D3DPRASTERCAPS_SUBPIXEL) &&
//			    !(dwRasterCaps & D3DPRASTERCAPS_SUBPIXELX))
//		    {
			    WriteToLog("Device capability not supported: Raster Subpixel.\n");
			    Fail();
			    return false;
//		    }
	    }
    }

    return true;
}

//************************************************************************
// Internal API:    DrawFillTests
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CFillTest::DrawFillTests(int nTest)
{
	int i;

	// Color of triangles
	D3DCOLOR Color[] = { RGBA_MAKE(255,0,0,255),		// Red
						 RGBA_MAKE(0,255,0,255),		// Green
						 RGBA_MAKE(0,0,255,255),		// Blue
						 RGBA_MAKE(255,255,0,255),		// Yellow
						 RGBA_MAKE(255,0,255,255) };	// Magenta

	switch (nTest)
	{
		case (1):
			sprintf(msgString, "%sRed triangle (x = y = 0)", msgString);

			// Red triangle, Right hand edge from x & y equal zero.
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 1.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,1.0f);
			break;
		case (2):
			sprintf(msgString, "%sGreen triangle (x = 0)", msgString);

			// Green triangle, Left hand edge from x equal zero.
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 1.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 1.0f,1.0f);
			break;
		case (3):
			sprintf(msgString, "%sBlue triangle (y = 0)", msgString);

			// Blue triangle, Right hand edge from y equal zero.
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 0.0f,1.0f);
			break;
		case (4):
			sprintf(msgString, "%sYellow triangle (x = y != 0)", msgString);

			// Yellow triangle, Left hand edge from x & y not equal zero.
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 1.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 0.0f,1.0f);
			break;
		case (5):
			sprintf(msgString, "%sMagenta triangle (x = 0)", msgString);

			// Magenta triangle, Left edge from x equal zero.
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,255,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f, 5.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,255,255), 0, 1.0f,0.5f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,255,255), 0, 0.0f,1.0f);
			break;
		case (6):
			sprintf(msgString, "%sCyan triangle (y = 0)", msgString);

			// Cyan triangle, Top edge from y equal zero.
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,255,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,255,255), 0, 1.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  5.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,255,255), 0, 0.5f,1.0f);
			break;
		case (7):
			sprintf(msgString, "%sWhite triangle (y != 0)", msgString);

			// White triangle, Bottom edge from y not equal zero.
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  5.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255), 0, 0.5f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,255,255), 0, 0.0f,1.0f);
			break;
		case (8):
			sprintf(msgString, "%sRed triangle (x != 0)", msgString);

			// Red triangle, Right edge from x not equal zero.
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 1.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f, 5.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,0.5f);
			break;
		case (9):
			sprintf(msgString, "%sGreen triangle (25x25 pixels)", msgString);

			// Green Triangle 25x25 pixels
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  0.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 25.0f, 0.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 25.0f,25.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,1.0f);
			break;
		case (10): 
			sprintf(msgString, "%sLong left edge, Short bottom edge", msgString);

			// Thin Left Bottom triangles
			for (i=0; i<10; i++)
			{
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i),   10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,0.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i)+i,260.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 1.0f,1.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i),  260.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,1.0f);
			}
			break;
		case (11): 
			sprintf(msgString, "%sLong left edge, Short top edge", msgString);

			// Thin Left Top triangles
			for (i=0; i<10; i++)
			{
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i),   10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,0.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i)+i, 10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 1.0f,1.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i),  260.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,1.0f);
			}
			break;
		case (12):
			sprintf(msgString, "%sLong top edge, Short right edge", msgString);

			// Thin Top Right triangles
			for (i=0; i<10; i++)
			{
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  10.0f,10.0f+(20*i)+ (float)m_vpTest.Y,  0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,0.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 290.0f,10.0f+(20*i)+ (float)m_vpTest.Y,  0.9f),(1.0f / 0.9f), Color[i%5], 0, 1.0f,1.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 290.0f,10.0f+(20*i)+i + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,1.0f);
			}
			break;
		case (13):
			sprintf(msgString, "%sLong top edge, Short left edge", msgString);

			// Thin Top Left triangles
			for (i=0; i<10; i++)
			{
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  10.0f,10.0f+(20*i)+ (float)m_vpTest.Y,  0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,0.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 290.0f,10.0f+(20*i)+ (float)m_vpTest.Y,  0.9f),(1.0f / 0.9f), Color[i%5], 0, 1.0f,1.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  10.0f,10.0f+(20*i)+i + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,1.0f);
			}
			break;
		case (14):
			sprintf(msgString, "%sLong right edge, Short bottom edge", msgString);

			// Thin Right Bottom triangles
			for (i=0; i<10; i++)
			{
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i),   10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,0.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i),  260.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 1.0f,1.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i)-i,260.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,1.0f);
			}
			break;
		case (15):
			sprintf(msgString, "%sLong right edge, Short top edge", msgString);

			// Thin Right Top triangles
			for (i=0; i<10; i++)
			{
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i)-i, 10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,0.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i),   10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 1.0f,1.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f+(20*i),  260.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,1.0f);
			}
			break;
		case (16):
			sprintf(msgString, "%sLong bottom edge, Short right edge", msgString);

			// Thin Bottom Right triangles
			for (i=0; i<10; i++)
			{
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  10.0f,10.0f+(20*i)+ (float)m_vpTest.Y,  0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,0.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 290.0f,10.0f+(20*i)-i + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 1.0f,1.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 290.0f,10.0f+(20*i)+ (float)m_vpTest.Y,  0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,1.0f);
			}
			break;
		case (17):
			sprintf(msgString, "%sLong bottom edge, Short left edge", msgString);

			// Thin Bottom Left triangles
			for (i=0; i<10; i++)
			{
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  10.0f,10.0f+(20*i)-i + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,0.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 290.0f,10.0f+(20*i)+ (float)m_vpTest.Y,  0.9f),(1.0f / 0.9f), Color[i%5], 0, 1.0f,1.0f);
				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  10.0f,10.0f+(20*i)+ (float)m_vpTest.Y,  0.9f),(1.0f / 0.9f), Color[i%5], 0, 0.0f,1.0f);
			}
			break;
		case (18):
			sprintf(msgString, "%sEight triangles", msgString);

			// Right Angled with Left and Bottom - Red
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 50.0f,50.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f,50.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,1.0f);
			
			// Equaladiral with edge on Left - Green
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  60.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 100.0f,30.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  60.0f,50.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,1.0f);
			
			// Right Angled with Left and Top - Blue
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 110.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 150.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 110.0f,50.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 0.0f,1.0f);
			
			// Equaladiral with edge on Top - Yellow
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 160.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 200.0f,10.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 180.0f,50.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 0.0f,1.0f);
			
			// Right Angled with Right and Bottom - Red
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 50.0f,100.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 50.0f,140.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 10.0f,140.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,1.0f);
			
			// Equaladiral with edge on Right - Green
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 100.0f,100.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 100.0f,140.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +  60.0f,120.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,1.0f);
			
			// Right Angled with Right and Top - Blue
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 110.0f,100.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 150.0f,100.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 150.0f,140.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 0.0f,1.0f);
			
			// Equaladiral with edge on Bottom - Yellow
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 180.0f,100.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 200.0f,140.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 160.0f,140.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 0.0f,1.0f);
			break;
		case (19):
			sprintf(msgString, "%s5x5 grid of red & green trianges", msgString);

			{
				// Red and Green Grid
				int nRows=5, nCols=5, nPixels=50;

				for (int y=0; y < nRows*nPixels; y+=nPixels)
				{
					for (int x=0; x < nCols*nPixels; x+=nPixels)
					{
						// Red Triangle
						VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (float)x,        (float)y         + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,0.0f);
						VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (float)x+nPixels,(float)y+nPixels + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 1.0f,1.0f);
						VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (float)x,        (float)y+nPixels + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,1.0f);
			
						// Green Triangle
						VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (float)x,        (float)y+ (float)m_vpTest.Y,        0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,0.0f);
						VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (float)x+nPixels,(float)y+ (float)m_vpTest.Y,        0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 1.0f,1.0f);
						VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (float)x+nPixels,(float)y+nPixels + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,1.0f);
					}
				}
			}
			break;
		case (20):
			sprintf(msgString, "%sSubPixel Wagon Wheel", msgString);

			// SubPixel Wagon Wheel test
			float fDelta = 50.0f;

			// Top - Red
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 0.5f,0.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 2.5f,0.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 1.5f,2.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,1.0f);
			
			// Left - Green
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 0.5f,0.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 1.5f,2.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 0.5f,4.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,1.0f);
			
			// Right  - Blue
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 2.5f,0.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 2.5f,4.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 1.5f,2.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 0.0f,1.0f);
			
			// Bottom - Yellow
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 1.5f,2.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 2.5f,4.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 0.5f,4.5f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 0.0f,1.0f);

			// Top - Red
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+1.0f,1.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+3.0f,1.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+2.0f,3.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,0,0,255), 0, 0.0f,1.0f);
			
			// Left - Green
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+1.0f,1.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+2.0f,3.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+1.0f,5.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,255,0,255), 0, 0.0f,1.0f);
			
			// Right  - Blue
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+3.0f,1.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+3.0f,5.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+2.0f,3.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,255,255), 0, 0.0f,1.0f);
			
			// Bottom - Yellow
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+2.0f,3.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+3.0f,5.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 1.0f,1.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + fDelta+1.0f,5.0f + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), RGBA_MAKE(255,255,0,255), 0, 0.0f,1.0f);
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\culling.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "BasicRst.h"

//************************************************************************
// Culling Test functions

CCullingTest::CCullingTest()
{
	m_szTestName = TEXT("BasicRst Culling");
	m_szCommandKey = TEXT("Culling");
}

CCullingTest::~CCullingTest()
{
}

UINT CCullingTest::TestInitialize(void)
{
//    UINT n = m_pMode->nSrcDevice;

	// Setup the Test range
	SetTestRange(1,CULLING_TESTS);

	// Check the caps we are interested in
	DWORD dwMiscCaps = m_d3dcaps.PrimitiveMiscCaps;

	// Check the appropriate Culling caps
	if (!(dwMiscCaps & D3DPMISCCAPS_CULLNONE))
	{
		WriteToLog("Device capability not supported: Cull None.\n");
		return D3DTESTINIT_ABORT;
	}

	if (!(dwMiscCaps & D3DPMISCCAPS_CULLCW))
	{
		WriteToLog("Device capability not supported: Cull CW.\n");
		return D3DTESTINIT_ABORT;
	}

	if (!(dwMiscCaps & D3DPMISCCAPS_CULLCCW))
	{
		WriteToLog("Device capability not supported: Cull CCW.\n");
		return D3DTESTINIT_ABORT;
	}

    // Tell RenderPrimitive disable API cycling
    // m_dwPrimitives = 1; should be changed to something like 
    // SetAPI(RP_DP);

	return D3DTESTINIT_RUN;
}

bool CCullingTest::ExecuteTest(UINT uTestNum)
{
	// Initialize some variables
 	dwVertexCount = 0;
	msgString[0] = 0;
	sprintf(msgString, "");

	// Let's build some triangles.
	DrawCullTests();

	// Set the appropriate renderstate
	switch (uTestNum)
	{
		case (1):
			sprintf(msgString, "%sNone, Visible: 24 triangles (All)", msgString);
			SetRenderState(D3DRENDERSTATE_CULLMODE, (DWORD)D3DCULL_NONE);
			break;
		case (2):
			sprintf(msgString, "%sClockwise, Visible: 12 triangles (Right half)", msgString);
			SetRenderState(D3DRENDERSTATE_CULLMODE, (DWORD)D3DCULL_CW);
			break;
		case (3):
			sprintf(msgString, "%sCounterClockwise, Visible: 12 triangles (Left half)", msgString);
			SetRenderState(D3DRENDERSTATE_CULLMODE, (DWORD)D3DCULL_CCW);
			break;
	}

	// Tell the log that we are starting
	BeginTestCase(msgString);

    return true;
}


//************************************************************************
// Internal API:    DrawCullTests
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CCullingTest::DrawCullTests(void)
{
	int nRow, delta;

	// Vertices for culling triangles
	float x1 = 5.0f;
	float x2[] = {5.0f, 5.0f, 25.0f, 25.0f};
	float x3 = 45.0f;
	float y1[] = {45.0f, 105.0f, 165.0f, 205.0f};
	float y2[] = { 5.0f,  65.0f, 125.0f, 185.0f};
	float y3[] = {45.0f,  85.0f, 165.0f, 225.0f};

	// Color of triangles
	D3DCOLOR Color[] = { RGBA_MAKE(255,0,0,255),		// Red
						 RGBA_MAKE(0,255,0,255),		// Green
						 RGBA_MAKE(0,0,255,255),		// Blue
						 RGBA_MAKE(255,255,0,255) };	// Yellow


	// Build the 24 triangles for the culling tests
	for (nRow=0; nRow<4; nRow++)
	{
		// Column 0
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x1,      y1[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,0.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x2[nRow],y2[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 1.0f,1.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x3,      y3[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,1.0f);
	}

	delta = 50;
	for (nRow=0; nRow<4; nRow++)
	{
		// Column 1
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x2[nRow]+delta,y2[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,0.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x3+delta,      y3[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 1.0f,1.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x1+delta,      y1[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,1.0f);
	}

	delta = 2*50;
	for (nRow=0; nRow<4; nRow++)
	{
		// Column 2
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x3+delta,      y3[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,0.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x1+delta,      y1[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 1.0f,1.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x2[nRow]+delta,y2[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,1.0f);
	}

	delta = 3*50;
	for (nRow=0; nRow<4; nRow++)
	{
		// Column 3
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x3+delta,      y3[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,0.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x2[nRow]+delta,y2[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 1.0f,1.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x1+delta,      y1[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,1.0f);
	}

	delta = 4*50;
	for (nRow=0; nRow<4; nRow++)
	{
		// Column 4
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x2[nRow]+delta,y2[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,0.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x1+delta,      y1[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 1.0f,1.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x3+delta,      y3[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,1.0f);
	}

	delta = 5*50;
	for (nRow=0; nRow<4; nRow++)
	{
		// Column 5
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x1+delta,      y1[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,0.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x3+delta,      y3[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 1.0f,1.0f);
		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + x2[nRow]+delta,y2[nRow] + (float)m_vpTest.Y,0.9f),(1.0f / 0.9f), Color[nRow], 0, 0.0f,1.0f);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\modulex.h ===
#define PREPEND_MODULE(Suffix) basicrst##Suffix
#define MODULE_STRING "basicrst"
#pragma comment(linker, "/include:_basicrst_ExhibitScene@8")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\dither.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "BasicRst.h"

//************************************************************************
// Dither Test functions

CDitherTest::CDitherTest()
{
	m_szTestName = TEXT("BasicRst Dither");
	m_szCommandKey = TEXT("Dither");
}

CDitherTest::~CDitherTest()
{
}

UINT CDitherTest::TestInitialize(void)
{
//    UINT n = m_pMode->nSrcDevice;

	// Setup the Test range
	SetTestRange(1,DITHER_TESTS);

	// Check the caps we are interested in
	DWORD dwRasterCaps = m_d3dcaps.RasterCaps;

	// Check the Dither cap
	if (!(dwRasterCaps & D3DPRASTERCAPS_DITHER))
	{
		WriteToLog("Device capability not supported: Raster Dither.\n");
		return D3DTESTINIT_ABORT;
	}

    // Tell RenderPrimitive disable API cycling
    // m_dwPrimitives = 1; should be changed to something like 
    // SetAPI(RP_DP);

	return D3DTESTINIT_RUN;
}

bool CDitherTest::ExecuteTest(UINT uTestNum)
{
	// Initialize some variables
 	dwVertexCount = 0;
	msgString[0] = 0;
	sprintf(msgString, "");

	// Let's build some triangles.
	DrawDitherTests(uTestNum % 4);

	// Set the appropriate renderstate
	if (uTestNum <= 4)
	{
		sprintf(msgString, "%sTrue, ", msgString);
		SetRenderState(D3DRENDERSTATE_DITHERENABLE, (DWORD)TRUE);
	}
	else
	{
		sprintf(msgString, "%sFalse, ", msgString);
		SetRenderState(D3DRENDERSTATE_DITHERENABLE, (DWORD)FALSE);
	}

	switch (uTestNum % 4)
	{
		case (0):
			sprintf(msgString, "%sBlue Mesh", msgString);
			break;
		case (1):
			sprintf(msgString, "%sWhite Mesh", msgString);
			break;
		case (2):
			sprintf(msgString, "%sRed Mesh", msgString);
			break;
		case (3):
			sprintf(msgString, "%sGreen Mesh", msgString);
			break;
	}

	// Tell the log that we are starting
	BeginTestCase(msgString);

    return true;
}

//************************************************************************
// Internal API:    DrawDitherTests
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CDitherTest::DrawDitherTests(int nTest)
{
	// Color of triangles
	D3DCOLOR Color[] = { RGBA_MAKE(0,0,255,255),		// Blue
						 RGBA_MAKE(255,255,255,255),	// White
						 RGBA_MAKE(255,0,0,255),		// Red
						 RGBA_MAKE(0,255,0,255) };		// Green

	// Mesh with Black bottom right corner
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +   0.0f,   0.0f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), Color[nTest],         0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 256.0f, 256.0f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,0,255), 0, 1.0f,1.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +   0.0f, 256.0f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), Color[nTest],         0, 0.0f,1.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X +   0.0f,   0.0f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), Color[nTest],         0, 0.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 256.0f,   0.0f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), Color[nTest],         0, 1.0f,0.0f);
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + 256.0f, 256.0f + (float)m_vpTest.Y, 0.9f),(1.0f / 0.9f), RGBA_MAKE(0,0,0,255), 0, 1.0f,1.0f);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\meshl.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "BasicRst.h"

//#define FVF_LVERTEX ( D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_TEX1 )

//************************************************************************
// MeshL Test functions

CMeshLTest::CMeshLTest()
{
	m_szTestName = TEXT("BasicRst Mesh L Vertex");
	m_szCommandKey = TEXT("MeshL");
}

CMeshLTest::~CMeshLTest()
{
}

bool CMeshLTest::SetDefaultRenderStates(void)
{
	// Turn off Lighting for DX7
	if (m_dwVersion >= 0x0700)
		SetRenderState(D3DRENDERSTATE_LIGHTING, (DWORD)FALSE);

	return true;
}

bool CMeshLTest::SetDefaultMatrices(void)
{
    D3DMATRIX proj, view;

	// Set the projection matrix.
	InitMatrix(&proj,
                	D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
					D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
					D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(1.0),
					D3DVAL(0.0), D3DVAL(0.0), D3DVAL(-1.0), D3DVAL(0.0)
				  );

	// the projection looks good when set to window height and width
	proj._11 = D3DVAL(pi/1.5f);
	proj._22 = D3DVAL(pi/1.5f);

    if (!SetTransform(D3DTRANSFORMSTATE_PROJECTION,&proj))
	{
		WriteToLog("SetTransform(ProjectionMatrix) failed with HResult = %X.\n",GetLastError());
        return false;
	}

	InitMatrix(&view,
	                D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
					D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
					D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
					D3DVAL(0.0), D3DVAL(0.0), D3DVAL(2.0), D3DVAL(1.0)
				  );

    if (!SetTransform(D3DTRANSFORMSTATE_VIEW,&view))
	{
		WriteToLog("SetTransform(ViewMatrix) failed with HResult = %X.\n",GetLastError());
        return false;
	}

	D3DMATRIX identity = IdentityMatrix();

    if (!SetTransform(D3DTRANSFORMSTATE_WORLD,&identity))
	{
		WriteToLog("SetTransform(WorldMatrix) failed with HResult = %X.\n",GetLastError());
        return false;
	}

    return true;
}

UINT CMeshLTest::TestInitialize(void)
{
	// Setup the Test range
	SetTestRange(1,MESH_L_TESTS);

    // Tell RenderPrimitive disable API cycling
    // m_dwPrimitives = 1; should be changed to something like 
    // SetAPI(RP_DP);

	return D3DTESTINIT_RUN;
}

bool CMeshLTest::ExecuteTest(UINT uTestNum)
{
	// Initialize some variables
 	dwVertexCount = 0;
	msgString[0] = 0;
	sprintf(msgString, "");

	// Let's build some triangles.
	DrawMeshTests(uTestNum);

	// Tell the log that we are starting
	BeginTestCase(msgString);

    return true;
}

void CMeshLTest::SceneRefresh(void)
{
	if (BeginScene())
	{
		if (m_uLastTestNum < 16)
		{
			// Use Triangle Strips
			RenderPrimitive(D3DPT_TRIANGLESTRIP,FVF_LVERTEX,LVertexList,dwVertexCount,NULL,0,0);
		}
		else if (m_uLastTestNum < 18)
		{
			// Use Triangle Strips
			RenderPrimitive(D3DPT_TRIANGLESTRIP,FVF_LVERTEX,LVertexList,dwVertexCount/2,NULL,0,0);
			RenderPrimitive(D3DPT_TRIANGLESTRIP,FVF_LVERTEX,LVertexList+8,dwVertexCount/2,NULL,0,0);
		}
		else
		{
			// Use Triangle Fans
			RenderPrimitive(D3DPT_TRIANGLEFAN,FVF_LVERTEX,LVertexList,dwVertexCount,NULL,0,0);
		}

		EndScene();
	}	
}

//************************************************************************
// Internal API:    DrawMeshTests
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CMeshLTest::DrawMeshTests(int nTest)
{
	switch (nTest)
	{
		// Straight Triangle Strip (Horizontal), D3DPT_TRIANGLESTRIP
		//
		case (1):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Red", msgString);

			// Red Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.80f,-0.6f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.80f, 0.4f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.48f,-0.6f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.16f, 0.4f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.16f,-0.6f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.48f, 0.4f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.80f,-0.6f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.80f, 0.4f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			break;
		case (2):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Green", msgString);

			// Green Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.80f,-0.6f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.80f, 0.4f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.48f,-0.6f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.16f, 0.4f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.16f,-0.6f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.48f, 0.4f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.80f,-0.6f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.80f, 0.4f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			break;
		case (3):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Blue", msgString);

			// Blue Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.80f,-0.6f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.80f, 0.4f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.48f,-0.6f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.16f, 0.4f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.16f,-0.6f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.48f, 0.4f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.80f,-0.6f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.80f, 0.4f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			break;
		case (4):	
			sprintf(msgString, "%sHorizontal Triangle Strip: White", msgString);

			// White Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.80f,-0.6f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.80f, 0.4f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.48f,-0.6f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.16f, 0.4f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.16f,-0.6f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.48f, 0.4f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.80f,-0.6f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.80f, 0.4f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			break;
		case (5):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Multicolor", msgString);

			// Multicolor Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.80f,-0.6f, 0.5f), RGBA_MAKE(255,0,0,255),  0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.80f, 0.4f, 0.5f), RGBA_MAKE(255,128,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.48f,-0.6f, 0.5f), RGBA_MAKE(128,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.16f, 0.4f, 0.5f), RGBA_MAKE(0,255,0,255),  0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.16f,-0.6f, 0.5f), RGBA_MAKE(0,255,0,255),  0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.48f, 0.4f, 0.5f), RGBA_MAKE(0,255,128,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.80f,-0.6f, 0.5f), RGBA_MAKE(0,128,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.80f, 0.4f, 0.5f), RGBA_MAKE(0,0,255,255),  0, 0.0f,0.0f);
			break;
		//
		// Straight Triangle Strip (Vertical), D3DPT_TRIANGLESTRIP
		//
		case (6):	
			sprintf(msgString, "%sVertical Triangle Strip: Red", msgString);

			// Red Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.80f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.80f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.16f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.48f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.48f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.16f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.80f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.80f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			break;
		case (7):	
			sprintf(msgString, "%sVertical Triangle Strip: Green", msgString);

			// Green Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.80f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.80f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.16f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.48f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.48f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.16f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.80f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.80f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			break;
		case (8):	
			sprintf(msgString, "%sVertical Triangle Strip: Blue", msgString);

			// Blue Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.80f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.80f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.16f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.48f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.48f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.16f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.80f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.80f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			break;
		case (9):	
			sprintf(msgString, "%sVertical Triangle Strip: White", msgString);

			// White Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.80f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.80f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.16f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.48f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.48f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.16f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.80f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.80f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			break;
		case (10):	
			sprintf(msgString, "%sVertical Triangle Strip: Multicolor", msgString);

			// Multicolor Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.80f, 0.5f), RGBA_MAKE(255,0,0,255),  0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.80f, 0.5f), RGBA_MAKE(255,128,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.16f, 0.5f), RGBA_MAKE(128,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.48f, 0.5f), RGBA_MAKE(0,255,0,255),  0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.48f, 0.5f), RGBA_MAKE(0,255,0,255),  0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.16f, 0.5f), RGBA_MAKE(0,255,128,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.80f, 0.5f), RGBA_MAKE(0,128,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.80f, 0.5f), RGBA_MAKE(0,0,255,255),  0, 0.0f,0.0f);
			break;
		//
		// Bent Triangle Strip, D3DPT_TRIANGLESTRIP
		//
		case (11):	
			sprintf(msgString, "%sBent Triangle Strip: Red", msgString);

			// Red Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.6f,-0.6f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.6f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.2f,-0.4f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.4f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.6f,-0.2f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2f,-0.2f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.0f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.0f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2f, 0.2f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.2f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.0f, 0.6f, 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			break;
		case (12):	
			sprintf(msgString, "%sBent Triangle Strip: Green", msgString);

			// Green Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.6f,-0.6f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.6f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.2f,-0.4f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.4f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.6f,-0.2f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2f,-0.2f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.0f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.0f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2f, 0.2f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.2f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.0f, 0.6f, 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			break;
		case (13):	
			sprintf(msgString, "%sBent Triangle Strip: Blue", msgString);

			// Blue Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.6f,-0.6f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.6f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.2f,-0.4f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.4f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.6f,-0.2f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2f,-0.2f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.0f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.0f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2f, 0.2f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.2f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.0f, 0.6f, 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			break;
		case (14):	
			sprintf(msgString, "%sBent Triangle Strip: White", msgString);

			// White Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.6f,-0.6f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.6f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.2f,-0.4f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.4f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.6f,-0.2f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2f,-0.2f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.0f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.0f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2f, 0.2f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.2f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.0f, 0.6f, 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			break;
		case (15):	
			sprintf(msgString, "%sBent Triangle Strip: Multicolor", msgString);

			// Multicolor Mesh
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.6f,-0.6f, 0.5f), RGBA_MAKE(128,0,0,255),  0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.6f, 0.5f), RGBA_MAKE(255,0,0,255),  0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.2f,-0.4f, 0.5f), RGBA_MAKE(255,128,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f,-0.4f, 0.5f), RGBA_MAKE(128,128,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.6f,-0.2f, 0.5f), RGBA_MAKE(128,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2f,-0.2f, 0.5f), RGBA_MAKE(0,255,0,255),  0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f, 0.0f, 0.5f), RGBA_MAKE(0,255,128,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.0f, 0.5f), RGBA_MAKE(0,128,128,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2f, 0.2f, 0.5f), RGBA_MAKE(0,128,255,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.2f, 0.5f), RGBA_MAKE(0,0,255,255),  0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.0f, 0.6f, 0.5f), RGBA_MAKE(0,0,128,255),  0, 0.0f,0.0f);
			break;
		//
		// Two crossed strips, D3DPT_TRIANGLESTRIP
		//
		case (16):	
			sprintf(msgString, "%sCrossed Triangle Strips: Red & Green", msgString);

			// Red strip
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.8000f,-0.8f, 0.9000f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.8000f,-0.4f, 0.7857f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2666f,-0.4f, 0.6714f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2666f, 0.0f, 0.5571f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.2666f, 0.0f, 0.4429f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.2666f, 0.4f, 0.3286f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.8000f, 0.4f, 0.2143f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.8000f, 0.8f, 0.1000f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			// Green strip
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.8f,-0.8000f, 0.1000f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.8000f, 0.2143f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.2666f, 0.3286f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.0f,-0.2666f, 0.4429f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.0f, 0.2666f, 0.5571f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.4f, 0.2666f, 0.6714f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.4f, 0.8000f, 0.7857f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.8f, 0.8000f, 0.8000f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			break;
		case (17):	
			sprintf(msgString, "%sCrossed Triangle Strips: Red & Black", msgString);

			// Red strip
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.8000f,-0.8f, 0.9000f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.8000f,-0.4f, 0.7857f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2666f,-0.4f, 0.6714f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.2666f, 0.0f, 0.5571f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.2666f, 0.0f, 0.4429f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.2666f, 0.4f, 0.3286f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.8000f, 0.4f, 0.2143f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.8000f, 0.8f, 0.1000f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			// Black strip
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.8f,-0.8000f, 0.1000f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.8000f, 0.2143f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.4f,-0.2666f, 0.3286f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.0f,-0.2666f, 0.4429f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR( 0.0f, 0.2666f, 0.5571f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.4f, 0.2666f, 0.6714f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.4f, 0.8000f, 0.7857f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.8f, 0.8000f, 0.8000f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			break;
		//
		// Triangle fan Square, D3DPT_TRIANGLEFAN
		//
		case (18):	
			sprintf(msgString, "%sSquare Triangle Fan: Red & Blue", msgString);

			{
				int i, red, green, blue;

				LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.6f, 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);

				for (i = -8; i < 9; i++)
				{
					LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR((float)i / 10.0f, 0.8f, 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = 8; i > -9; i--)
				{
					LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(0.8f, (float)i / 10.0f, 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = 8; i > -9; i--)
				{
					LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR((float)i / 10.0f,-0.8f, 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = -8; i < 9; i++)
				{
					LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.8f, (float)i / 10.0f, 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}

				for (i = 1; i < 69; i++)
				{
					red = (255 - (255 * i / 68));
					green = 0;
					blue = (255 * i / 68);
					LVertexList[i].color = RGBA_MAKE(red, green, blue, 255);
				}
			}
			break;
		//
		// Jagged Triangle fan Square, D3DPT_TRIANGLEFAN
		//
		case (19):	
			sprintf(msgString, "%sJagged Triangle Fan: Red & Blue", msgString);

			{
				int i, red, green, blue;
				bool bEven;

				LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR(-0.6f, 0.6f, 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);

				bEven = true;
				for (i = -8; i < 9; i++)
				{
					bEven = (bEven ? false : true);
					LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR((float)i / 10.0f, (bEven ? 0.7f : 0.8f), (bEven ? 0.6f : 0.4f)), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = 8; i > -9; i--)
				{
					bEven = (bEven ? false : true);
					LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR((bEven ? 0.3f : 0.8f), (float)i / 10.0f, (bEven ? 0.6f : 0.4f)), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = 8; i > -9; i--)
				{
					bEven = (bEven ? false : true);
					LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR((float)i / 10.0f, (bEven ? -0.3f : -0.8f), (bEven ? 0.6f : 0.4f)), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = -8; i < 9; i++)
				{
					bEven = (bEven ? false : true);
					LVertexList[dwVertexCount++] = LLVERTEX(cD3DVECTOR((bEven ? -0.7f : -0.8f), (float)i / 10.0f, (bEven ? 0.6f : 0.4f)), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}

				for (i = 1; i < 69; i++)
				{
					red = (255 - (255 * i / 68));
					green = 0;
					blue = (255 * i / 68);
					LVertexList[i].color = RGBA_MAKE(red, green, blue, 255);
				}
			}
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\meshtl.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "BasicRst.h"

//************************************************************************
// MeshTL Test functions

CMeshTLTest::CMeshTLTest()
{
	m_szTestName = TEXT("BasicRst Mesh TL Vertex");
	m_szCommandKey = TEXT("MeshTL");
}

CMeshTLTest::~CMeshTLTest()
{
}

UINT CMeshTLTest::TestInitialize(void)
{
	// Initialize the Width and Height
	dwWidth = m_vpTest.Width;//m_pSrcTarget->m_dwWidth;
	dwHeight = m_vpTest.Height;//m_pSrcTarget->m_dwHeight;

	// Setup the Test range
	SetTestRange(1,MESH_TL_TESTS);

    // Tell RenderPrimitive disable API cycling
    // m_dwPrimitives = 1; should be changed to something like 
    // SetAPI(RP_DP);

	return D3DTESTINIT_RUN;
}

bool CMeshTLTest::ExecuteTest(UINT uTestNum)
{
	// Initialize some variables
 	dwVertexCount = 0;
	msgString[0] = 0;
	sprintf(msgString, "");

	// Let's build some triangles.
	if (uTestNum < MESH_TL_TESTS)
		DrawMeshTests(uTestNum);
	else
		sprintf(msgString, "%sTriangle Fan Circles: Various Colors", msgString);

	// Tell the log that we are starting
	BeginTestCase(msgString);

    return true;
}

void CMeshTLTest::SceneRefresh(void)
{
	if (BeginScene())
	{
		if (m_uLastTestNum < 16)
		{
			// Use Triangle Strips
			RenderPrimitive(D3DPT_TRIANGLESTRIP,D3DFVF_TLVERTEX,VertexList,dwVertexCount,NULL,0,0);
		}
		else if (m_uLastTestNum < 18)
		{
			// Use Triangle Strips
			RenderPrimitive(D3DPT_TRIANGLESTRIP,D3DFVF_TLVERTEX,VertexList,dwVertexCount/2,NULL,0,0);
			RenderPrimitive(D3DPT_TRIANGLESTRIP,D3DFVF_TLVERTEX,VertexList+8,dwVertexCount/2,NULL,0,0);
		}
		else if (m_uLastTestNum < 20)
		{
			// Use Triangle Fans
			RenderPrimitive(D3DPT_TRIANGLEFAN,D3DFVF_TLVERTEX,VertexList,dwVertexCount,NULL,0,0);
		}
		else
		{
			D3DVECTOR Center;
			float     fRadius;
			D3DCOLOR  ColorArray[] = {RGBA_MAKE(255,255,255,255),
									  RGBA_MAKE(255,0,0,255), RGBA_MAKE(200,200,0,255),
									  RGBA_MAKE(0,255,0,255), RGBA_MAKE(0,200,200,255),
									  RGBA_MAKE(0,0,255,255), RGBA_MAKE(255,0,255,255)};

			fRadius = ((dwWidth < dwHeight) ? dwWidth : dwHeight) * 0.2f;

			Center.z = 0.5f;

			for (int i=0; i<6; i++)
			{
				Center.x = (float)m_vpTest.X + ((float)dwWidth / 2.0f) + (float)(fRadius * (float)cos(1.0472f * i));
				Center.y = (float)m_vpTest.Y + ((float)dwHeight / 2.0f) + (float)(fRadius * (float)sin(1.0472f * i));

				DrawCircle(&Center, fRadius, 360, ColorArray[i+1]);
			}

			Center.x = (float)m_vpTest.X + ((float)dwWidth / 2.0f);
			Center.y = (float)m_vpTest.Y + ((float)dwHeight / 2.0f);
			DrawCircle(&Center, (fRadius / 2.0f), 360, ColorArray[0]);
		}

		EndScene();
	}	
}

//************************************************************************
// Internal API:    DrawCircle
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CMeshTLTest::DrawCircle(D3DVECTOR* pCenter, float Radius, int nDivisions, D3DCOLOR Color)
{
    int             i, NumVertices;
    float           Theta, Rads;

  	dwVertexCount = 0;
	NumVertices = nDivisions + 2;
    Theta = 360.0f / nDivisions;

    // Initialize the center point
	VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR(pCenter->x, pCenter->y, pCenter->z), (1.0f / pCenter->z), Color, 0, 0.0f,0.0f);

    for (i=1; i<NumVertices; i++)
    {
        // cos takes a radian value, so convert.
        Rads = (Theta * (i-1) * pi)/180.0f;

		VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((pCenter->x + Radius * (float)cos(Rads)), (pCenter->y + Radius * (float)sin(Rads)), pCenter->z), (1.0f / pCenter->z), Color, 0, 0.0f,0.0f);
    }

	RenderPrimitive(D3DPT_TRIANGLEFAN,D3DFVF_TLVERTEX,VertexList,dwVertexCount,NULL,0,0);
}

//************************************************************************
// Internal API:    DrawMeshTests
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CMeshTLTest::DrawMeshTests(int nTest)
{
	switch (nTest)
	{
		// Straight Triangle Strip (Horizontal), D3DPT_TRIANGLESTRIP
		//
		case (1):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Red", msgString);

			// Red Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.10f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.10f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.26f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.42f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.58f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.74f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.90f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.90f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			break;
		case (2):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Green", msgString);

			// Green Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.10f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.10f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.26f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.42f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.58f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.74f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.90f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.90f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			break;
		case (3):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Blue", msgString);

			// Blue Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.10f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.10f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.26f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.42f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.58f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.74f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.90f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.90f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			break;
		case (4):	
			sprintf(msgString, "%sHorizontal Triangle Strip: White", msgString);

			// White Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.10f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.10f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.26f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.42f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.58f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.74f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.90f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.90f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			break;
		case (5):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Multicolor", msgString);

			// Multicolor Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.10f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),  0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.10f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,128,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.26f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(128,128,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.42f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(128,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.58f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,128,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.74f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,128,128,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.90f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,128,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.90f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),  0, 0.0f,0.0f);
			break;
		//
		// Straight Triangle Strip (Vertical), D3DPT_TRIANGLESTRIP
		//
		case (6):	
			sprintf(msgString, "%sVertical Triangle Strip: Red", msgString);

			// Red Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.10f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.10f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.42f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.26f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.74f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.58f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.90f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.90f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			break;
		case (7):	
			sprintf(msgString, "%sVertical Triangle Strip: Green", msgString);

			// Green Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.10f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.10f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.42f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.26f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.74f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.58f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.90f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.90f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			break;
		case (8):	
			sprintf(msgString, "%sVertical Triangle Strip: Blue", msgString);

			// Blue Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.10f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.10f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.42f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.26f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.74f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.58f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.90f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.90f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			break;
		case (9):	
			sprintf(msgString, "%sVertical Triangle Strip: White", msgString);

			// White Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.10f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.10f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.42f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.26f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.74f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.58f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.90f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.90f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			break;
		case (10):	
			sprintf(msgString, "%sVertical Triangle Strip: Multicolor", msgString);

			// Multicolor Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.10f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),  0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.10f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,128,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.42f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(128,128,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.26f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(128,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.74f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,128,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.58f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,128,128,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.90f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,128,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.90f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),  0, 0.0f,0.0f);
			break;
		//
		// Bent Triangle Strip, D3DPT_TRIANGLESTRIP
		//
		case (11):	
			sprintf(msgString, "%sBent Triangle Strip: Red", msgString);

			// Red Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.8f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.6f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.8f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.4f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.4f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.4f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.4f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.5f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.8f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			break;
		case (12):	
			sprintf(msgString, "%sBent Triangle Strip: Green", msgString);

			// Green Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.8f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.6f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.8f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.4f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.4f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.4f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.4f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.5f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.8f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			break;
		case (13):	
			sprintf(msgString, "%sBent Triangle Strip: Blue", msgString);

			// Blue Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.8f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.6f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.8f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.4f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.4f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.4f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.4f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.5f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.8f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),0, 0.0f,0.0f);
			break;
		case (14):	
			sprintf(msgString, "%sBent Triangle Strip: White", msgString);

			// White Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.8f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.6f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.8f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.4f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.4f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.4f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.4f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.5f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.8f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,255,255,255),0, 0.0f,0.0f);
			break;
		case (15):	
			sprintf(msgString, "%sBent Triangle Strip: Multicolor", msgString);

			// Multicolor Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.8f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(128,0,0,255),  0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.2f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,0,0,255),  0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.6f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(255,128,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(128,128,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.8f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.4f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(128,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.4f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.4f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,0,255),  0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,255,128,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,128,128,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.4f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,128,255,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,255,255),  0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.5f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.8f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,128,255),  0, 0.0f,0.0f);
			break;
		//
		// Two crossed strips, D3DPT_TRIANGLESTRIP
		//
		case (16):	
			sprintf(msgString, "%sCrossed Triangle Strips: Red & Green", msgString);

			// Red Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.1000f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.1f * dwHeight)) + (float)m_vpTest.Y, 0.9000f), (1.0f / 0.9000f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.1000f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.7857f), (1.0f / 0.7857f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.3667f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.6714f), (1.0f / 0.6714f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.3667f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5571f), (1.0f / 0.5571f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.6333f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.4429f), (1.0f / 0.4429f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.6333f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.3286f), (1.0f / 0.3286f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.9000f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.2143f), (1.0f / 0.2143f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.9000f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.9f * dwHeight)) + (float)m_vpTest.Y, 0.1000f), (1.0f / 0.1000f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			// Green Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.9f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.1000f * dwHeight)) + (float)m_vpTest.Y, 0.1000f), (1.0f / 0.1000f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.1000f * dwHeight)) + (float)m_vpTest.Y, 0.2143f), (1.0f / 0.2143f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3667f * dwHeight)) + (float)m_vpTest.Y, 0.3286f), (1.0f / 0.3286f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.5f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3667f * dwHeight)) + (float)m_vpTest.Y, 0.4429f), (1.0f / 0.4429f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.5f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6333f * dwHeight)) + (float)m_vpTest.Y, 0.5571f), (1.0f / 0.5571f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.3f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6333f * dwHeight)) + (float)m_vpTest.Y, 0.6714f), (1.0f / 0.6714f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.3f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.9000f * dwHeight)) + (float)m_vpTest.Y, 0.7857f), (1.0f / 0.7857f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.1f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.9000f * dwHeight)) + (float)m_vpTest.Y, 0.8000f), (1.0f / 0.8000f), RGBA_MAKE(0,255,0,255),0, 0.0f,0.0f);
			break;
		case (17):	
			sprintf(msgString, "%sCrossed Triangle Strips: Red & Black", msgString);

			// Red Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.1000f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.1f * dwHeight)) + (float)m_vpTest.Y, 0.9000f), (1.0f / 0.9000f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.1000f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.7857f), (1.0f / 0.7857f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.3667f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3f * dwHeight)) + (float)m_vpTest.Y, 0.6714f), (1.0f / 0.6714f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.3667f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.5571f), (1.0f / 0.5571f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.6333f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.5f * dwHeight)) + (float)m_vpTest.Y, 0.4429f), (1.0f / 0.4429f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.6333f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.3286f), (1.0f / 0.3286f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.9000f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.7f * dwHeight)) + (float)m_vpTest.Y, 0.2143f), (1.0f / 0.2143f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.9000f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.9f * dwHeight)) + (float)m_vpTest.Y, 0.1000f), (1.0f / 0.1000f), RGBA_MAKE(255,0,0,255),0, 0.0f,0.0f);
			// Black Mesh
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.9f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.1000f * dwHeight)) + (float)m_vpTest.Y, 0.1000f), (1.0f / 0.1000f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.1000f * dwHeight)) + (float)m_vpTest.Y, 0.2143f), (1.0f / 0.2143f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.7f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3667f * dwHeight)) + (float)m_vpTest.Y, 0.3286f), (1.0f / 0.3286f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.5f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.3667f * dwHeight)) + (float)m_vpTest.Y, 0.4429f), (1.0f / 0.4429f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.5f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6333f * dwHeight)) + (float)m_vpTest.Y, 0.5571f), (1.0f / 0.5571f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.3f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.6333f * dwHeight)) + (float)m_vpTest.Y, 0.6714f), (1.0f / 0.6714f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.3f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.9000f * dwHeight)) + (float)m_vpTest.Y, 0.7857f), (1.0f / 0.7857f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.1f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.9000f * dwHeight)) + (float)m_vpTest.Y, 0.8000f), (1.0f / 0.8000f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
			break;
		//
		// Triangle fan Square, D3DPT_TRIANGLEFAN
		//
		case (18):	
			sprintf(msgString, "%sSquare Triangle Fan: Red & Blue", msgString);

			{
				int i, red, green, blue;

				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.8f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);

				for (i = 1; i < 10; i++)
				{
					VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(((float)i / 10.0f) * dwWidth),(D3DVALUE)(int)(dwHeight - (0.9f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = 8; i > 0; i--)
				{
					VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.9f * dwWidth),(D3DVALUE)(int)(dwHeight - (((float)i / 10.0f) * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = 8; i > 0; i--)
				{
					VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(((float)i / 10.0f) * dwWidth),(D3DVALUE)(int)(dwHeight - (0.1f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = 2; i < 10; i++)
				{
					VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.1f * dwWidth),(D3DVALUE)(int)(dwHeight - (((float)i / 10.0f) * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}

				for (i = 1; i < 34; i++)
				{
					red = (255 - (255 * i / 33));
					green = 0;
					blue = (255 * i / 33);
					VertexList[i].color = RGBA_MAKE(red, green, blue, 255);
				}
			}
			break;
		//
		// Jagged Triangle fan Square, D3DPT_TRIANGLEFAN
		//
		case (19):	
			sprintf(msgString, "%sJagged Triangle Fan: Red & Blue", msgString);

			{
				int i, red, green, blue;
				bool bEven;

				VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(0.2f * dwWidth),(D3DVALUE)(int)(dwHeight - (0.8f * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);

				bEven = true;
				for (i = 1; i < 10; i++)
				{
					bEven = (bEven ? false : true);
					VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(((float)i / 10.0f) * dwWidth),(D3DVALUE)(int)(dwHeight - ((bEven ? 0.85f : 0.9f) * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = 8; i > 0; i--)
				{
					bEven = (bEven ? false : true);
					VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)((bEven ? 0.7f : 0.9f) * dwWidth),(D3DVALUE)(int)(dwHeight - (((float)i / 10.0f) * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = 8; i > 0; i--)
				{
					bEven = (bEven ? false : true);
					VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)(((float)i / 10.0f) * dwWidth),(D3DVALUE)(int)(dwHeight - ((bEven ? 0.3f : 0.1f) * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}
				for (i = 2; i < 10; i++)
				{
					bEven = (bEven ? false : true);
					VertexList[dwVertexCount++] = cD3DTLVERTEX(cD3DVECTOR((float)m_vpTest.X + (D3DVALUE)(int)((bEven ? 0.15f : 0.1f) * dwWidth),(D3DVALUE)(int)(dwHeight - (((float)i / 10.0f) * dwHeight)) + (float)m_vpTest.Y, 0.5f), (1.0f / 0.5f), RGBA_MAKE(0,0,0,255),0, 0.0f,0.0f);
				}

				for (i = 1; i < 34; i++)
				{
					red = (255 - (255 * i / 33));
					green = 0;
					blue = (255 * i / 33);
					VertexList[i].color = RGBA_MAKE(red, green, blue, 255);
				}
			}
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\nodiffuse.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "BasicRst.h"

#define FVF_TLT1VERTEX ( D3DFVF_XYZRHW | D3DFVF_TEX1 )

//************************************************************************
// NoDiffuse Test functions

CNoDiffuseTest::CNoDiffuseTest()
{
	m_szTestName = TEXT("BasicRst NoDiffuse");
	m_szCommandKey = TEXT("NoDiffuse");
}

CNoDiffuseTest::~CNoDiffuseTest()
{
}

UINT CNoDiffuseTest::TestInitialize(void)
{
	// Setup the Test range
	SetTestRange(1, m_dwRPFullAPIListSize);

    // Tell RenderPrimitive to cycle through all APIs
    SetAPI(m_pRPFullAPIList, m_dwRPFullAPIListSize, 1);

	return D3DTESTINIT_RUN;
}

bool CNoDiffuseTest::ExecuteTest(UINT uTestNum)
{
    DWORD dwAPI;

	// Initialize some variables
 	dwVertexCount = 0;
	msgString[0] = '\0';

	// Let's build some triangles.
	DrawNonDiffuseGrid();

	// Get the current API
    dwAPI = RemapAPI(GetAPI(), D3DPT_TRIANGLELIST, FVF_TLT1VERTEX);

    // Tell log which API we are using
    switch (dwAPI)
    {
        case RP_BE:             sprintf(msgString, "%sFVF: 0x%08x, API: Begin/Vertex/End", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_BIE:            sprintf(msgString, "%sFVF: 0x%08x, API: BeginIndexed/Index/End", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DP:             sprintf(msgString, "%sFVF: 0x%08x, API: DrawPrimitive", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DIP:            sprintf(msgString, "%sFVF: 0x%08x, API: DrawIndexedPrimitive", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DPS:            sprintf(msgString, "%sFVF: 0x%08x, API: DrawPrimitiveStrided", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DIPS:           sprintf(msgString, "%sFVF: 0x%08x, API: DrawIndexedPrimitiveStrided", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DPVB:           sprintf(msgString, "%sFVF: 0x%08x, API: DrawPrimitiveVB", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DIPVB:          sprintf(msgString, "%sFVF: 0x%08x, API: DrawIndexedPrimitiveVB", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DPVB_PV:        sprintf(msgString, "%sFVF: 0x%08x, API: DrawPrimitiveVB after ProcessVertices", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DIPVB_PV:       sprintf(msgString, "%sFVF: 0x%08x, API: DrawIndexedPrimitiveVB after ProcessVertices", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DPVB_OPT:       sprintf(msgString, "%sFVF: 0x%08x, API: DrawPrimitiveVB with Optimized VB", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DIPVB_OPT:      sprintf(msgString, "%sFVF: 0x%08x, API: DrawIndexedPrimitiveVB with Optimized VB", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DPVB_OPT_PV:    sprintf(msgString, "%sFVF: 0x%08x, API: DrawPrimitiveVB after ProcessVert with Optimized VB", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DIPVB_OPT_PV:   sprintf(msgString, "%sFVF: 0x%08x, API: DrawIndexedPrimitiveVB after ProcessVert with Optimized VB", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DPVB_PVS:       sprintf(msgString, "%sFVF: 0x%08x, API: DrawPrimitiveVB after ProcessVerticesStrided", msgString, FVF_TLT1VERTEX);
                                break;
        case RP_DIPVB_PVS:      sprintf(msgString, "%sFVF: 0x%08x, API: DrawIndexedPrimitiveVB after ProcessVerticesStrided", msgString, FVF_TLT1VERTEX);
                                break;
    }

	// Tell the log that we are starting
	BeginTestCase(msgString);

    return true;
}

void CNoDiffuseTest::SceneRefresh(void)
{
	if (BeginScene())
	{
		// Render the data.
		RenderPrimitive(D3DPT_TRIANGLELIST,FVF_TLT1VERTEX,NoDiffuseList,dwVertexCount,NULL,0,0);

		EndScene();
	}	
}

//************************************************************************
// Internal API:    DrawNonDiffuseGrid
//
// Purpose:         
//
// Return:          None.
//************************************************************************

void CNoDiffuseTest::DrawNonDiffuseGrid(void)
{
	// Use standard ((0,0)(1,0)(0,1)(1,1)) mapping
	NoDiffuseList[dwVertexCount++] = ND_VERTEX(cD3DVECTOR(  9.5f,   9.5f, 0.9f), (1.0f / 0.9f), 0.0f,0.0f);
	NoDiffuseList[dwVertexCount++] = ND_VERTEX(cD3DVECTOR(265.5f, 265.5f, 0.9f), (1.0f / 0.9f), 1.0f,1.0f);
	NoDiffuseList[dwVertexCount++] = ND_VERTEX(cD3DVECTOR(  9.5f, 265.5f, 0.9f), (1.0f / 0.9f), 0.0f,1.0f);
	NoDiffuseList[dwVertexCount++] = ND_VERTEX(cD3DVECTOR(  9.5f,   9.5f, 0.9f), (1.0f / 0.9f), 0.0f,0.0f);
	NoDiffuseList[dwVertexCount++] = ND_VERTEX(cD3DVECTOR(265.5f,   9.5f, 0.9f), (1.0f / 0.9f), 1.0f,0.0f);
	NoDiffuseList[dwVertexCount++] = ND_VERTEX(cD3DVECTOR(265.5f, 265.5f, 0.9f), (1.0f / 0.9f), 1.0f,1.0f);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\conf\basicrst\meshd3d.cpp ===
//#define D3D_OVERLOADS
#include "d3dlocus.h"
#include "cd3dtest.h"
#include "3dmath.h"
#include "BasicRst.h"

//************************************************************************
// MeshD3D Test functions

CMeshD3DTest::CMeshD3DTest()
{
	m_szTestName = TEXT("BasicRst Mesh D3D Vertex");
	m_szCommandKey = TEXT("MeshD3D");
}

CMeshD3DTest::~CMeshD3DTest()
{
}

bool CMeshD3DTest::SetDefaultMatrices(void)
{
    D3DMATRIX proj, view;

	// Set the projection matrix.
	InitMatrix(&proj,
                  	D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
					D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
					D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(1.0),
					D3DVAL(0.0), D3DVAL(0.0), D3DVAL(-1.0), D3DVAL(0.0)
				  );

	// the projection looks good when set to window height and width
	proj._11 = D3DVAL(pi/1.5f);
	proj._22 = D3DVAL(pi/1.5f);

    if (!SetTransform(D3DTRANSFORMSTATE_PROJECTION,&proj))
	{
		WriteToLog("SetTransform(ProjectionMatrix) failed with HResult = %X.\n",GetLastError());
        return false;
	}

	InitMatrix(&view,
                	D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
					D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
					D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
					D3DVAL(0.0), D3DVAL(0.0), D3DVAL(2.0), D3DVAL(1.0)
				  );

    if (!SetTransform(D3DTRANSFORMSTATE_VIEW,&view))
	{
		WriteToLog("SetTransform(ViewMatrix) failed with HResult = %X.\n",GetLastError());
        return false;
	}

	D3DMATRIX identity = IdentityMatrix();

    if (!SetTransform(D3DTRANSFORMSTATE_WORLD,&identity))
	{
		WriteToLog("SetTransform(WorldMatrix) failed with HResult = %X.\n",GetLastError());
        return false;
	}

    return true;
}

UINT CMeshD3DTest::TestInitialize(void)
{
	// Setup the Test range
	SetTestRange(1,MESH_D3D_TESTS);

    // Tell RenderPrimitive disable API cycling
    // m_dwPrimitives = 1; should be changed to something like 
    // SetAPI(RP_DP);

	return D3DTESTINIT_RUN;
}

bool CMeshD3DTest::ExecuteTest(UINT uTestNum)
{
	D3DMATERIAL8 Material;
	D3DCOLOR	Color;

	// Initialize some variables
 	dwVertexCount = 0;
	msgString[0] = 0;
	sprintf(msgString, "");

	// Let's build some triangles.
	Color = DrawMeshTests(uTestNum);

	// set up the material for the lightstate.
	memset(&Material, NULL, sizeof(D3DMATERIAL8));
//	Material.dwSize = sizeof(D3DMATERIAL);
	Material.Emissive.r = (float)RGBA_GETRED(Color);
	Material.Emissive.g = (float)RGBA_GETGREEN(Color);
	Material.Emissive.b = (float)RGBA_GETBLUE(Color);
	Material.Emissive.a = (float)RGBA_GETALPHA(Color);

	// Set the appropriate material
//    RELEASE(pMaterial);
//	pMaterial = CreateMaterial();
//	pMaterial->SetMaterial(&Material);
//	SetMaterial(pMaterial);
    m_pDevice->SetMaterial(&Material);

	// Tell the log that we are starting
	BeginTestCase(msgString);

    return true;
}

void CMeshD3DTest::SceneRefresh(void)
{
	if (BeginScene())
	{
		if (m_uLastTestNum < 13)
		{
			// Use Triangle Strips
			RenderPrimitive(D3DPT_TRIANGLESTRIP,D3DFVF_VERTEX,D3DVertexList,dwVertexCount,NULL,0,0);
		}
		else if (m_uLastTestNum < 15)
		{
			D3DMATERIAL8 Material;

			// Use Triangle Strips
			RenderPrimitive(D3DPT_TRIANGLESTRIP,D3DFVF_VERTEX,D3DVertexList+8,dwVertexCount/2,NULL,0,0);

			// Setup a red material
			memset(&Material, NULL, sizeof(D3DMATERIAL8));
			Material.Emissive.r = 255.0f;
			Material.Emissive.g =   0.0f;
			Material.Emissive.b =   0.0f;
			Material.Emissive.a = 255.0f;

			// Set the appropriate material
//		    RELEASE(pMaterial);
//			pMaterial = CreateMaterial();
//			pMaterial->SetMaterial(&Material);
//			SetMaterial(pMaterial);
            m_pDevice->SetMaterial(&Material);

			// Use Triangle Strips
			RenderPrimitive(D3DPT_TRIANGLESTRIP,D3DFVF_VERTEX,D3DVertexList,dwVertexCount/2,NULL,0,0);
		}
		else
		{
			// Use Triangle Fans
			RenderPrimitive(D3DPT_TRIANGLEFAN,D3DFVF_VERTEX,D3DVertexList,dwVertexCount,NULL,0,0);
		}

		EndScene();
	}	
}

bool CMeshD3DTest::TestTerminate()
{
	// Cleanup material
//    RELEASE(pMaterial);

	return true;
}

//************************************************************************
// Internal API:    DrawMeshTests
//
// Purpose:         
//
// Return:          None.
//************************************************************************

D3DCOLOR CMeshD3DTest::DrawMeshTests(int nTest)
{
	D3DCOLOR	MaterialColor;

	switch (nTest)
	{
		// Straight Triangle Strip (Horizontal), D3DPT_TRIANGLESTRIP
		//
		case (1):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Red", msgString);

			// Red Mesh
			MaterialColor = RGBA_MAKE(255,0,0,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.80f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.80f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.48f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.16f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.16f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.48f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.80f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.80f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		case (2):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Green", msgString);

			// Green Mesh
			MaterialColor = RGBA_MAKE(0,255,0,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.80f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.80f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.48f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.16f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.16f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.48f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.80f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.80f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		case (3):	
			sprintf(msgString, "%sHorizontal Triangle Strip: Blue", msgString);

			// Blue Mesh
			MaterialColor = RGBA_MAKE(0,0,255,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.80f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.80f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.48f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.16f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.16f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.48f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.80f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.80f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		case (4):	
			sprintf(msgString, "%sHorizontal Triangle Strip: White", msgString);

			// White Mesh
			MaterialColor = RGBA_MAKE(255,255,255,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.80f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.80f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.48f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.16f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.16f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.48f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.80f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.80f, 0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		//
		// Straight Triangle Strip (Vertical), D3DPT_TRIANGLESTRIP
		//
		case (5):	
			sprintf(msgString, "%sVertical Triangle Strip: Red", msgString);

			// Red Mesh
			MaterialColor = RGBA_MAKE(255,0,0,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f,-0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f,-0.16f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.48f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.48f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.16f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		case (6):	
			sprintf(msgString, "%sVertical Triangle Strip: Green", msgString);

			// Green Mesh
			MaterialColor = RGBA_MAKE(0,255,0,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f,-0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f,-0.16f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.48f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.48f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.16f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		case (7):	
			sprintf(msgString, "%sVertical Triangle Strip: Blue", msgString);

			// Blue Mesh
			MaterialColor = RGBA_MAKE(0,0,255,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f,-0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f,-0.16f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.48f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.48f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.16f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		case (8):	
			sprintf(msgString, "%sVertical Triangle Strip: White", msgString);

			// White Mesh
			MaterialColor = RGBA_MAKE(255,255,255,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f,-0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f,-0.16f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.48f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.48f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.16f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.80f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		//
		// Bent Triangle Strip, D3DPT_TRIANGLESTRIP
		//
		case (9):	
			sprintf(msgString, "%sBent Triangle Strip: Red", msgString);

			// Red Mesh
			MaterialColor = RGBA_MAKE(255,0,0,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.6f,-0.6f, 0.5f), cD3DVECTOR(-0.3487f, -0.4650f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.2f,-0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.6f,-0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2f,-0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.0f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.0f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2f, 0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.0f, 0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		case (10):	
			sprintf(msgString, "%sBent Triangle Strip: Green", msgString);

			// Green Mesh
			MaterialColor = RGBA_MAKE(0,255,0,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.6f,-0.6f, 0.5f), cD3DVECTOR(-0.3487f, -0.4650f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.2f,-0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.6f,-0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2f,-0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.0f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.0f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2f, 0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.0f, 0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		case (11):	
			sprintf(msgString, "%sBent Triangle Strip: Blue", msgString);

			// Blue Mesh
			MaterialColor = RGBA_MAKE(0,0,255,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.6f,-0.6f, 0.5f), cD3DVECTOR(-0.3487f, -0.4650f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.2f,-0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.6f,-0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2f,-0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.0f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.0f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2f, 0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.0f, 0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		case (12):	
			sprintf(msgString, "%sBent Triangle Strip: White", msgString);

			// White Mesh
			MaterialColor = RGBA_MAKE(255,255,255,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.6f,-0.6f, 0.5f), cD3DVECTOR(-0.3487f, -0.4650f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.2f,-0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f,-0.4f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.6f,-0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2f,-0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f, 0.0f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.0f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2f, 0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.6f, 0.2f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.0f, 0.6f, 0.5f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			break;
		//
		// Two crossed strips, D3DPT_TRIANGLESTRIP
		//
		case (13):	
			sprintf(msgString, "%sCrossed Triangle Strips: Red & Green", msgString);

			// Red strip
			MaterialColor = RGBA_MAKE(255,0,0,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.8000f,-0.8f, 0.9000f), cD3DVECTOR(-0.3487f, -0.4650f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.8000f,-0.4f, 0.7857f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2666f,-0.4f, 0.6714f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2666f, 0.0f, 0.5571f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.2666f, 0.0f, 0.4429f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.2666f, 0.4f, 0.3286f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.8000f, 0.4f, 0.2143f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.8000f, 0.8f, 0.1000f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			// Green strip
			MaterialColor = RGBA_MAKE(0,255,0,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.8f,-0.8000f, 0.1000f), cD3DVECTOR(-0.4650f, 0.3487f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f,-0.8000f, 0.2143f), cD3DVECTOR(-0.4650f, 0.3487f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.4f,-0.2666f, 0.3286f), cD3DVECTOR(-0.4650f, 0.3487f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.0f,-0.2666f, 0.4429f), cD3DVECTOR(-0.4650f, 0.3487f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.0f, 0.2666f, 0.5571f), cD3DVECTOR(-0.4650f, 0.3487f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.4f, 0.2666f, 0.6714f), cD3DVECTOR(-0.4650f, 0.3487f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.4f, 0.8000f, 0.7857f), cD3DVECTOR(-0.4650f, 0.3487f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.8f, 0.8000f, 0.8000f), cD3DVECTOR(-0.4650f, 0.3487f, -0.8137f), 0.0f,0.0f);
			break;
		case (14):	
			sprintf(msgString, "%sCrossed Triangle Strips: Red & Black", msgString);

			// Red strip
			MaterialColor = RGBA_MAKE(255,0,0,255);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.8000f,-0.8f, 0.9000f), cD3DVECTOR(-0.3487f, -0.4650f, -0.8137f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.8000f,-0.4f, 0.7857f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2666f,-0.4f, 0.6714f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR(-0.2666f, 0.0f, 0.5571f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.2666f, 0.0f, 0.4429f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.2666f, 0.4f, 0.3286f), cD3DVECTOR(0.0f,0.0f,0.0f), 0.0f,0.0f);
			D3DVertexList[dwVertexCount++] = cD3DVERTEX(cD3DVECTOR( 0.800