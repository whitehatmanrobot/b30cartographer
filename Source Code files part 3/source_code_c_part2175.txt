/ __RPC__in BSTR bstrCatalogServerName,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVersion )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__out long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVersion )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__out long *plMinorVersion);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCollectionByQuery )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarQuery,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportComponent )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrCLSIDOrProgID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallComponent )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrDLL,
            /* [in] */ __RPC__in BSTR bstrTLB,
            /* [in] */ __RPC__in BSTR bstrPSDLL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ShutdownApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExportApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [optional][in] */ __RPC__in BSTR bstrDestinationDirectory,
            /* [optional][in] */ long lOptions,
            /* [optional][in] */ __RPC__in BSTR bstrUserId,
            /* [optional][in] */ __RPC__in BSTR bstrPassword,
            /* [optional][in] */ __RPC__in BSTR bstrRSN);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopRouter )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshRouter )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartRouter )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reserved1 )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reserved2 )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallMultipleComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarCLSIDs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMultipleComponentsInfo )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarCLSIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarClassNames,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarFileFlags,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarComponentFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshComponents )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BackupREGDB )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrBackupFilePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestoreREGDB )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrBackupFilePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryApplicationFile )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrApplicationName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrApplicationDescription,
            /* [out] */ __RPC__out VARIANT_BOOL *pbHasUsers,
            /* [out] */ __RPC__out VARIANT_BOOL *pbIsProxy,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarFileNames);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ServiceCheck )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ long lService,
            /* [retval][out] */ __RPC__out long *plStatus);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallMultipleEventClasses )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarCLSIDS);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallEventClass )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__in BSTR bstrDLL,
            /* [in] */ __RPC__in BSTR bstrTLB,
            /* [in] */ __RPC__in BSTR bstrPSDLL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEventClassesForIID )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrIID,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarCLSIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarProgIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarDescriptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCollectionByQuery2 )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrCollectionName,
            /* [in] */ __RPC__in VARIANT *pVarQueryStrings,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetApplicationInstanceIDFromProcessID )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ long lProcessID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrApplicationInstanceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ShutdownApplicationInstances )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PauseApplicationInstances )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ResumeApplicationInstances )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RecycleApplicationInstances )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID,
            /* [in] */ long lReasonCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AreApplicationInstancesPaused )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBoolPaused);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DumpApplicationInstance )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationInstanceID,
            /* [in] */ __RPC__in BSTR bstrDirectory,
            /* [in] */ long lMaxImages,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDumpFile);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsApplicationInstanceDumpSupported )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBoolDumpSupported);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateServiceForApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in BSTR bstrServiceName,
            /* [in] */ __RPC__in BSTR bstrStartType,
            /* [in] */ __RPC__in BSTR bstrErrorControl,
            /* [in] */ __RPC__in BSTR bstrDependencies,
            /* [in] */ __RPC__in BSTR bstrRunAs,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [in] */ VARIANT_BOOL bDesktopOk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteServiceForApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionID )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionName )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPartition )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrPartitionIDOrName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPartitionID )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPartitionName )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GlobalPartitionID )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGlobalPartitionID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FlushPartitionCache )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyApplications )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrSourcePartitionIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarApplicationID,
            /* [in] */ __RPC__in BSTR bstrDestinationPartitionIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrSourceApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [in] */ __RPC__in BSTR bstrDestinationApplicationIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrSourceApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [in] */ __RPC__in BSTR bstrDestinationApplicationIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AliasComponent )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrSrcApplicationIDOrName,
            /* [in] */ __RPC__in BSTR bstrCLSIDOrProgID,
            /* [in] */ __RPC__in BSTR bstrDestApplicationIDOrName,
            /* [in] */ __RPC__in BSTR bstrNewProgId,
            /* [in] */ __RPC__in BSTR bstrNewClsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsSafeToDelete )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrDllName,
            /* [retval][out] */ __RPC__out COMAdminInUse *pCOMAdminInUse);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportUnconfiguredComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [optional][in] */ __RPC__in VARIANT *pVarComponentType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PromoteUnconfiguredComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [optional][in] */ __RPC__in VARIANT *pVarComponentType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [optional][in] */ __RPC__in VARIANT *pVarComponentType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Is64BitCatalogServer )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIs64Bit);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExportPartition )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrPartitionIDOrName,
            /* [in] */ __RPC__in BSTR bstrPartitionFileName,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallPartition )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrFileName,
            /* [in] */ __RPC__in BSTR bstrDestDirectory,
            /* [in] */ long lOptions,
            /* [in] */ __RPC__in BSTR bstrUserID,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [in] */ __RPC__in BSTR bstrRSN);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryApplicationFile2 )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppFilesForImport);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetComponentVersionCount )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrCLSIDOrProgID,
            /* [retval][out] */ __RPC__out long *plVersionCount);
        
        END_INTERFACE
    } ICOMAdminCatalog2Vtbl;

    interface ICOMAdminCatalog2
    {
        CONST_VTBL struct ICOMAdminCatalog2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOMAdminCatalog2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICOMAdminCatalog2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICOMAdminCatalog2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICOMAdminCatalog2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICOMAdminCatalog2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICOMAdminCatalog2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICOMAdminCatalog2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICOMAdminCatalog2_GetCollection(This,bstrCollName,ppCatalogCollection)	\
    ( (This)->lpVtbl -> GetCollection(This,bstrCollName,ppCatalogCollection) ) 

#define ICOMAdminCatalog2_Connect(This,bstrCatalogServerName,ppCatalogCollection)	\
    ( (This)->lpVtbl -> Connect(This,bstrCatalogServerName,ppCatalogCollection) ) 

#define ICOMAdminCatalog2_get_MajorVersion(This,plMajorVersion)	\
    ( (This)->lpVtbl -> get_MajorVersion(This,plMajorVersion) ) 

#define ICOMAdminCatalog2_get_MinorVersion(This,plMinorVersion)	\
    ( (This)->lpVtbl -> get_MinorVersion(This,plMinorVersion) ) 

#define ICOMAdminCatalog2_GetCollectionByQuery(This,bstrCollName,ppsaVarQuery,ppCatalogCollection)	\
    ( (This)->lpVtbl -> GetCollectionByQuery(This,bstrCollName,ppsaVarQuery,ppCatalogCollection) ) 

#define ICOMAdminCatalog2_ImportComponent(This,bstrApplIDOrName,bstrCLSIDOrProgID)	\
    ( (This)->lpVtbl -> ImportComponent(This,bstrApplIDOrName,bstrCLSIDOrProgID) ) 

#define ICOMAdminCatalog2_InstallComponent(This,bstrApplIDOrName,bstrDLL,bstrTLB,bstrPSDLL)	\
    ( (This)->lpVtbl -> InstallComponent(This,bstrApplIDOrName,bstrDLL,bstrTLB,bstrPSDLL) ) 

#define ICOMAdminCatalog2_ShutdownApplication(This,bstrApplIDOrName)	\
    ( (This)->lpVtbl -> ShutdownApplication(This,bstrApplIDOrName) ) 

#define ICOMAdminCatalog2_ExportApplication(This,bstrApplIDOrName,bstrApplicationFile,lOptions)	\
    ( (This)->lpVtbl -> ExportApplication(This,bstrApplIDOrName,bstrApplicationFile,lOptions) ) 

#define ICOMAdminCatalog2_InstallApplication(This,bstrApplicationFile,bstrDestinationDirectory,lOptions,bstrUserId,bstrPassword,bstrRSN)	\
    ( (This)->lpVtbl -> InstallApplication(This,bstrApplicationFile,bstrDestinationDirectory,lOptions,bstrUserId,bstrPassword,bstrRSN) ) 

#define ICOMAdminCatalog2_StopRouter(This)	\
    ( (This)->lpVtbl -> StopRouter(This) ) 

#define ICOMAdminCatalog2_RefreshRouter(This)	\
    ( (This)->lpVtbl -> RefreshRouter(This) ) 

#define ICOMAdminCatalog2_StartRouter(This)	\
    ( (This)->lpVtbl -> StartRouter(This) ) 

#define ICOMAdminCatalog2_Reserved1(This)	\
    ( (This)->lpVtbl -> Reserved1(This) ) 

#define ICOMAdminCatalog2_Reserved2(This)	\
    ( (This)->lpVtbl -> Reserved2(This) ) 

#define ICOMAdminCatalog2_InstallMultipleComponents(This,bstrApplIDOrName,ppsaVarFileNames,ppsaVarCLSIDs)	\
    ( (This)->lpVtbl -> InstallMultipleComponents(This,bstrApplIDOrName,ppsaVarFileNames,ppsaVarCLSIDs) ) 

#define ICOMAdminCatalog2_GetMultipleComponentsInfo(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDs,ppsaVarClassNames,ppsaVarFileFlags,ppsaVarComponentFlags)	\
    ( (This)->lpVtbl -> GetMultipleComponentsInfo(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDs,ppsaVarClassNames,ppsaVarFileFlags,ppsaVarComponentFlags) ) 

#define ICOMAdminCatalog2_RefreshComponents(This)	\
    ( (This)->lpVtbl -> RefreshComponents(This) ) 

#define ICOMAdminCatalog2_BackupREGDB(This,bstrBackupFilePath)	\
    ( (This)->lpVtbl -> BackupREGDB(This,bstrBackupFilePath) ) 

#define ICOMAdminCatalog2_RestoreREGDB(This,bstrBackupFilePath)	\
    ( (This)->lpVtbl -> RestoreREGDB(This,bstrBackupFilePath) ) 

#define ICOMAdminCatalog2_QueryApplicationFile(This,bstrApplicationFile,pbstrApplicationName,pbstrApplicationDescription,pbHasUsers,pbIsProxy,ppsaVarFileNames)	\
    ( (This)->lpVtbl -> QueryApplicationFile(This,bstrApplicationFile,pbstrApplicationName,pbstrApplicationDescription,pbHasUsers,pbIsProxy,ppsaVarFileNames) ) 

#define ICOMAdminCatalog2_StartApplication(This,bstrApplIdOrName)	\
    ( (This)->lpVtbl -> StartApplication(This,bstrApplIdOrName) ) 

#define ICOMAdminCatalog2_ServiceCheck(This,lService,plStatus)	\
    ( (This)->lpVtbl -> ServiceCheck(This,lService,plStatus) ) 

#define ICOMAdminCatalog2_InstallMultipleEventClasses(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDS)	\
    ( (This)->lpVtbl -> InstallMultipleEventClasses(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDS) ) 

#define ICOMAdminCatalog2_InstallEventClass(This,bstrApplIdOrName,bstrDLL,bstrTLB,bstrPSDLL)	\
    ( (This)->lpVtbl -> InstallEventClass(This,bstrApplIdOrName,bstrDLL,bstrTLB,bstrPSDLL) ) 

#define ICOMAdminCatalog2_GetEventClassesForIID(This,bstrIID,ppsaVarCLSIDs,ppsaVarProgIDs,ppsaVarDescriptions)	\
    ( (This)->lpVtbl -> GetEventClassesForIID(This,bstrIID,ppsaVarCLSIDs,ppsaVarProgIDs,ppsaVarDescriptions) ) 


#define ICOMAdminCatalog2_GetCollectionByQuery2(This,bstrCollectionName,pVarQueryStrings,ppCatalogCollection)	\
    ( (This)->lpVtbl -> GetCollectionByQuery2(This,bstrCollectionName,pVarQueryStrings,ppCatalogCollection) ) 

#define ICOMAdminCatalog2_GetApplicationInstanceIDFromProcessID(This,lProcessID,pbstrApplicationInstanceID)	\
    ( (This)->lpVtbl -> GetApplicationInstanceIDFromProcessID(This,lProcessID,pbstrApplicationInstanceID) ) 

#define ICOMAdminCatalog2_ShutdownApplicationInstances(This,pVarApplicationInstanceID)	\
    ( (This)->lpVtbl -> ShutdownApplicationInstances(This,pVarApplicationInstanceID) ) 

#define ICOMAdminCatalog2_PauseApplicationInstances(This,pVarApplicationInstanceID)	\
    ( (This)->lpVtbl -> PauseApplicationInstances(This,pVarApplicationInstanceID) ) 

#define ICOMAdminCatalog2_ResumeApplicationInstances(This,pVarApplicationInstanceID)	\
    ( (This)->lpVtbl -> ResumeApplicationInstances(This,pVarApplicationInstanceID) ) 

#define ICOMAdminCatalog2_RecycleApplicationInstances(This,pVarApplicationInstanceID,lReasonCode)	\
    ( (This)->lpVtbl -> RecycleApplicationInstances(This,pVarApplicationInstanceID,lReasonCode) ) 

#define ICOMAdminCatalog2_AreApplicationInstancesPaused(This,pVarApplicationInstanceID,pVarBoolPaused)	\
    ( (This)->lpVtbl -> AreApplicationInstancesPaused(This,pVarApplicationInstanceID,pVarBoolPaused) ) 

#define ICOMAdminCatalog2_DumpApplicationInstance(This,bstrApplicationInstanceID,bstrDirectory,lMaxImages,pbstrDumpFile)	\
    ( (This)->lpVtbl -> DumpApplicationInstance(This,bstrApplicationInstanceID,bstrDirectory,lMaxImages,pbstrDumpFile) ) 

#define ICOMAdminCatalog2_get_IsApplicationInstanceDumpSupported(This,pVarBoolDumpSupported)	\
    ( (This)->lpVtbl -> get_IsApplicationInstanceDumpSupported(This,pVarBoolDumpSupported) ) 

#define ICOMAdminCatalog2_CreateServiceForApplication(This,bstrApplicationIDOrName,bstrServiceName,bstrStartType,bstrErrorControl,bstrDependencies,bstrRunAs,bstrPassword,bDesktopOk)	\
    ( (This)->lpVtbl -> CreateServiceForApplication(This,bstrApplicationIDOrName,bstrServiceName,bstrStartType,bstrErrorControl,bstrDependencies,bstrRunAs,bstrPassword,bDesktopOk) ) 

#define ICOMAdminCatalog2_DeleteServiceForApplication(This,bstrApplicationIDOrName)	\
    ( (This)->lpVtbl -> DeleteServiceForApplication(This,bstrApplicationIDOrName) ) 

#define ICOMAdminCatalog2_GetPartitionID(This,bstrApplicationIDOrName,pbstrPartitionID)	\
    ( (This)->lpVtbl -> GetPartitionID(This,bstrApplicationIDOrName,pbstrPartitionID) ) 

#define ICOMAdminCatalog2_GetPartitionName(This,bstrApplicationIDOrName,pbstrPartitionName)	\
    ( (This)->lpVtbl -> GetPartitionName(This,bstrApplicationIDOrName,pbstrPartitionName) ) 

#define ICOMAdminCatalog2_put_CurrentPartition(This,bstrPartitionIDOrName)	\
    ( (This)->lpVtbl -> put_CurrentPartition(This,bstrPartitionIDOrName) ) 

#define ICOMAdminCatalog2_get_CurrentPartitionID(This,pbstrPartitionID)	\
    ( (This)->lpVtbl -> get_CurrentPartitionID(This,pbstrPartitionID) ) 

#define ICOMAdminCatalog2_get_CurrentPartitionName(This,pbstrPartitionName)	\
    ( (This)->lpVtbl -> get_CurrentPartitionName(This,pbstrPartitionName) ) 

#define ICOMAdminCatalog2_get_GlobalPartitionID(This,pbstrGlobalPartitionID)	\
    ( (This)->lpVtbl -> get_GlobalPartitionID(This,pbstrGlobalPartitionID) ) 

#define ICOMAdminCatalog2_FlushPartitionCache(This)	\
    ( (This)->lpVtbl -> FlushPartitionCache(This) ) 

#define ICOMAdminCatalog2_CopyApplications(This,bstrSourcePartitionIDOrName,pVarApplicationID,bstrDestinationPartitionIDOrName)	\
    ( (This)->lpVtbl -> CopyApplications(This,bstrSourcePartitionIDOrName,pVarApplicationID,bstrDestinationPartitionIDOrName) ) 

#define ICOMAdminCatalog2_CopyComponents(This,bstrSourceApplicationIDOrName,pVarCLSIDOrProgID,bstrDestinationApplicationIDOrName)	\
    ( (This)->lpVtbl -> CopyComponents(This,bstrSourceApplicationIDOrName,pVarCLSIDOrProgID,bstrDestinationApplicationIDOrName) ) 

#define ICOMAdminCatalog2_MoveComponents(This,bstrSourceApplicationIDOrName,pVarCLSIDOrProgID,bstrDestinationApplicationIDOrName)	\
    ( (This)->lpVtbl -> MoveComponents(This,bstrSourceApplicationIDOrName,pVarCLSIDOrProgID,bstrDestinationApplicationIDOrName) ) 

#define ICOMAdminCatalog2_AliasComponent(This,bstrSrcApplicationIDOrName,bstrCLSIDOrProgID,bstrDestApplicationIDOrName,bstrNewProgId,bstrNewClsid)	\
    ( (This)->lpVtbl -> AliasComponent(This,bstrSrcApplicationIDOrName,bstrCLSIDOrProgID,bstrDestApplicationIDOrName,bstrNewProgId,bstrNewClsid) ) 

#define ICOMAdminCatalog2_IsSafeToDelete(This,bstrDllName,pCOMAdminInUse)	\
    ( (This)->lpVtbl -> IsSafeToDelete(This,bstrDllName,pCOMAdminInUse) ) 

#define ICOMAdminCatalog2_ImportUnconfiguredComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType)	\
    ( (This)->lpVtbl -> ImportUnconfiguredComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType) ) 

#define ICOMAdminCatalog2_PromoteUnconfiguredComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType)	\
    ( (This)->lpVtbl -> PromoteUnconfiguredComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType) ) 

#define ICOMAdminCatalog2_ImportComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType)	\
    ( (This)->lpVtbl -> ImportComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType) ) 

#define ICOMAdminCatalog2_get_Is64BitCatalogServer(This,pbIs64Bit)	\
    ( (This)->lpVtbl -> get_Is64BitCatalogServer(This,pbIs64Bit) ) 

#define ICOMAdminCatalog2_ExportPartition(This,bstrPartitionIDOrName,bstrPartitionFileName,lOptions)	\
    ( (This)->lpVtbl -> ExportPartition(This,bstrPartitionIDOrName,bstrPartitionFileName,lOptions) ) 

#define ICOMAdminCatalog2_InstallPartition(This,bstrFileName,bstrDestDirectory,lOptions,bstrUserID,bstrPassword,bstrRSN)	\
    ( (This)->lpVtbl -> InstallPartition(This,bstrFileName,bstrDestDirectory,lOptions,bstrUserID,bstrPassword,bstrRSN) ) 

#define ICOMAdminCatalog2_QueryApplicationFile2(This,bstrApplicationFile,ppFilesForImport)	\
    ( (This)->lpVtbl -> QueryApplicationFile2(This,bstrApplicationFile,ppFilesForImport) ) 

#define ICOMAdminCatalog2_GetComponentVersionCount(This,bstrCLSIDOrProgID,plVersionCount)	\
    ( (This)->lpVtbl -> GetComponentVersionCount(This,bstrCLSIDOrProgID,plVersionCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICOMAdminCatalog2_INTERFACE_DEFINED__ */


#ifndef __ICatalogObject_INTERFACE_DEFINED__
#define __ICatalogObject_INTERFACE_DEFINED__

/* interface ICatalogObject */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICatalogObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22871-8a19-11d0-81b6-00a0c9231c29")
    ICatalogObject : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyReadOnly( 
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Valid( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyWriteOnly( 
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICatalogObject * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICatalogObject * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICatalogObject * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [in] */ VARIANT val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            ICatalogObject * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ICatalogObject * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsPropertyReadOnly )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Valid )( 
            ICatalogObject * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsPropertyWriteOnly )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal);
        
        END_INTERFACE
    } ICatalogObjectVtbl;

    interface ICatalogObject
    {
        CONST_VTBL struct ICatalogObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICatalogObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICatalogObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICatalogObject_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICatalogObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICatalogObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICatalogObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICatalogObject_get_Value(This,bstrPropName,pvarRetVal)	\
    ( (This)->lpVtbl -> get_Value(This,bstrPropName,pvarRetVal) ) 

#define ICatalogObject_put_Value(This,bstrPropName,val)	\
    ( (This)->lpVtbl -> put_Value(This,bstrPropName,val) ) 

#define ICatalogObject_get_Key(This,pvarRetVal)	\
    ( (This)->lpVtbl -> get_Key(This,pvarRetVal) ) 

#define ICatalogObject_get_Name(This,pvarRetVal)	\
    ( (This)->lpVtbl -> get_Name(This,pvarRetVal) ) 

#define ICatalogObject_IsPropertyReadOnly(This,bstrPropName,pbRetVal)	\
    ( (This)->lpVtbl -> IsPropertyReadOnly(This,bstrPropName,pbRetVal) ) 

#define ICatalogObject_get_Valid(This,pbRetVal)	\
    ( (This)->lpVtbl -> get_Valid(This,pbRetVal) ) 

#define ICatalogObject_IsPropertyWriteOnly(This,bstrPropName,pbRetVal)	\
    ( (This)->lpVtbl -> IsPropertyWriteOnly(This,bstrPropName,pbRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICatalogObject_INTERFACE_DEFINED__ */


#ifndef __ICatalogCollection_INTERFACE_DEFINED__
#define __ICatalogCollection_INTERFACE_DEFINED__

/* interface ICatalogCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICatalogCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22872-8a19-11d0-81b6-00a0c9231c29")
    ICatalogCollection : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnumVariant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogObject) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plObjectCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Populate( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveChanges( 
            /* [retval][out] */ __RPC__out long *pcChanges) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__out VARIANT *pVarNamel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBool) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemoveEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBool) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUtilInterface( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppIDispatch) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMajorVersion( 
            /* [retval][out] */ __RPC__out long *plMajorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMinorVersion( 
            /* [retval][out] */ __RPC__out long *plMinorVersionl) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByKey( 
            /* [in] */ __RPC__in SAFEARRAY * psaKeys) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByQuery( 
            /* [in] */ __RPC__in BSTR bstrQueryString,
            /* [in] */ long lQueryType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICatalogCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICatalogCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICatalogCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICatalogCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnumVariant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ICatalogCollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogObject);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out long *plObjectCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ICatalogCollection * This,
            /* [in] */ long lIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Populate )( 
            ICatalogCollection * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveChanges )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out long *pcChanges);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCollection )( 
            ICatalogCollection * This,
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out VARIANT *pVarNamel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddEnabled )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBool);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemoveEnabled )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetUtilInterface )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppIDispatch);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataStoreMajorVersion )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataStoreMinorVersion )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out long *plMinorVersionl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PopulateByKey )( 
            ICatalogCollection * This,
            /* [in] */ __RPC__in SAFEARRAY * psaKeys);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PopulateByQuery )( 
            ICatalogCollection * This,
            /* [in] */ __RPC__in BSTR bstrQueryString,
            /* [in] */ long lQueryType);
        
        END_INTERFACE
    } ICatalogCollectionVtbl;

    interface ICatalogCollection
    {
        CONST_VTBL struct ICatalogCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICatalogCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICatalogCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICatalogCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICatalogCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICatalogCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICatalogCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICatalogCollection_get__NewEnum(This,ppEnumVariant)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppEnumVariant) ) 

#define ICatalogCollection_get_Item(This,lIndex,ppCatalogObject)	\
    ( (This)->lpVtbl -> get_Item(This,lIndex,ppCatalogObject) ) 

#define ICatalogCollection_get_Count(This,plObjectCount)	\
    ( (This)->lpVtbl -> get_Count(This,plObjectCount) ) 

#define ICatalogCollection_Remove(This,lIndex)	\
    ( (This)->lpVtbl -> Remove(This,lIndex) ) 

#define ICatalogCollection_Add(This,ppCatalogObject)	\
    ( (This)->lpVtbl -> Add(This,ppCatalogObject) ) 

#define ICatalogCollection_Populate(This)	\
    ( (This)->lpVtbl -> Populate(This) ) 

#define ICatalogCollection_SaveChanges(This,pcChanges)	\
    ( (This)->lpVtbl -> SaveChanges(This,pcChanges) ) 

#define ICatalogCollection_GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection)	\
    ( (This)->lpVtbl -> GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection) ) 

#define ICatalogCollection_get_Name(This,pVarNamel)	\
    ( (This)->lpVtbl -> get_Name(This,pVarNamel) ) 

#define ICatalogCollection_get_AddEnabled(This,pVarBool)	\
    ( (This)->lpVtbl -> get_AddEnabled(This,pVarBool) ) 

#define ICatalogCollection_get_RemoveEnabled(This,pVarBool)	\
    ( (This)->lpVtbl -> get_RemoveEnabled(This,pVarBool) ) 

#define ICatalogCollection_GetUtilInterface(This,ppIDispatch)	\
    ( (This)->lpVtbl -> GetUtilInterface(This,ppIDispatch) ) 

#define ICatalogCollection_get_DataStoreMajorVersion(This,plMajorVersion)	\
    ( (This)->lpVtbl -> get_DataStoreMajorVersion(This,plMajorVersion) ) 

#define ICatalogCollection_get_DataStoreMinorVersion(This,plMinorVersionl)	\
    ( (This)->lpVtbl -> get_DataStoreMinorVersion(This,plMinorVersionl) ) 

#define ICatalogCollection_PopulateByKey(This,psaKeys)	\
    ( (This)->lpVtbl -> PopulateByKey(This,psaKeys) ) 

#define ICatalogCollection_PopulateByQuery(This,bstrQueryString,lQueryType)	\
    ( (This)->lpVtbl -> PopulateByQuery(This,bstrQueryString,lQueryType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICatalogCollection_INTERFACE_DEFINED__ */



#ifndef __COMAdmin_LIBRARY_DEFINED__
#define __COMAdmin_LIBRARY_DEFINED__

/* library COMAdmin */
/* [helpstring][version][uuid] */ 

typedef /* [helpstring] */ 
enum COMAdminComponentType
    {	COMAdmin32BitComponent	= 0x1,
	COMAdmin64BitComponent	= 0x2
    } 	COMAdminComponentType;

typedef /* [helpstring] */ 
enum COMAdminApplicationInstallOptions
    {	COMAdminInstallNoUsers	= 0,
	COMAdminInstallUsers	= 1,
	COMAdminInstallForceOverwriteOfFiles	= 2
    } 	COMAdminApplicationInstallOptions;

typedef /* [helpstring] */ 
enum COMAdminApplicationExportOptions
    {	COMAdminExportNoUsers	= 0,
	COMAdminExportUsers	= 1,
	COMAdminExportApplicationProxy	= 2,
	COMAdminExportForceOverwriteOfFiles	= 4,
	COMAdminExportIn10Format	= 16
    } 	COMAdminApplicationExportOptions;

typedef /* [helpstring] */ 
enum COMAdminThreadingModels
    {	COMAdminThreadingModelApartment	= 0,
	COMAdminThreadingModelFree	= 1,
	COMAdminThreadingModelMain	= 2,
	COMAdminThreadingModelBoth	= 3,
	COMAdminThreadingModelNeutral	= 4,
	COMAdminThreadingModelNotSpecified	= 5
    } 	COMAdminThreadingModels;

typedef /* [helpstring] */ 
enum COMAdminTransactionOptions
    {	COMAdminTransactionIgnored	= 0,
	COMAdminTransactionNone	= 1,
	COMAdminTransactionSupported	= 2,
	COMAdminTransactionRequired	= 3,
	COMAdminTransactionRequiresNew	= 4
    } 	COMAdminTransactionOptions;

typedef /* [helpstring] */ 
enum COMAdminTxIsolationLevelOptions
    {	COMAdminTxIsolationLevelAny	= 0,
	COMAdminTxIsolationLevelReadUnCommitted	= ( COMAdminTxIsolationLevelAny + 1 ) ,
	COMAdminTxIsolationLevelReadCommitted	= ( COMAdminTxIsolationLevelReadUnCommitted + 1 ) ,
	COMAdminTxIsolationLevelRepeatableRead	= ( COMAdminTxIsolationLevelReadCommitted + 1 ) ,
	COMAdminTxIsolationLevelSerializable	= ( COMAdminTxIsolationLevelRepeatableRead + 1 ) 
    } 	COMAdminTxIsolationLevelOptions;

typedef /* [helpstring] */ 
enum COMAdminSynchronizationOptions
    {	COMAdminSynchronizationIgnored	= 0,
	COMAdminSynchronizationNone	= 1,
	COMAdminSynchronizationSupported	= 2,
	COMAdminSynchronizationRequired	= 3,
	COMAdminSynchronizationRequiresNew	= 4
    } 	COMAdminSynchronizationOptions;

typedef /* [helpstring] */ 
enum COMAdminActivationOptions
    {	COMAdminActivationInproc	= 0,
	COMAdminActivationLocal	= 1
    } 	COMAdminActivationOptions;

typedef /* [helpstring] */ 
enum COMAdminAccessChecksLevelOptions
    {	COMAdminAccessChecksApplicationLevel	= 0,
	COMAdminAccessChecksApplicationComponentLevel	= 1
    } 	COMAdminAccessChecksLevelOptions;

typedef /* [helpstring] */ 
enum COMAdminAuthenticationLevelOptions
    {	COMAdminAuthenticationDefault	= 0,
	COMAdminAuthenticationNone	= 1,
	COMAdminAuthenticationConnect	= 2,
	COMAdminAuthenticationCall	= 3,
	COMAdminAuthenticationPacket	= 4,
	COMAdminAuthenticationIntegrity	= 5,
	COMAdminAuthenticationPrivacy	= 6
    } 	COMAdminAuthenticationLevelOptions;

typedef /* [helpstring] */ 
enum COMAdminImpersonationLevelOptions
    {	COMAdminImpersonationAnonymous	= 1,
	COMAdminImpersonationIdentify	= 2,
	COMAdminImpersonationImpersonate	= 3,
	COMAdminImpersonationDelegate	= 4
    } 	COMAdminImpersonationLevelOptions;

typedef /* [helpstring] */ 
enum COMAdminAuthenticationCapabilitiesOptions
    {	COMAdminAuthenticationCapabilitiesNone	= 0,
	COMAdminAuthenticationCapabilitiesSecureReference	= 0x2,
	COMAdminAuthenticationCapabilitiesStaticCloaking	= 0x20,
	COMAdminAuthenticationCapabilitiesDynamicCloaking	= 0x40
    } 	COMAdminAuthenticationCapabilitiesOptions;

typedef /* [helpstring] */ 
enum COMAdminOS
    {	COMAdminOSNotInitialized	= 0,
	COMAdminOSWindows3_1	= 1,
	COMAdminOSWindows9x	= 2,
	COMAdminOSWindows2000	= 3,
	COMAdminOSWindows2000AdvancedServer	= 4,
	COMAdminOSWindows2000Unknown	= 5,
	COMAdminOSUnknown	= 6,
	COMAdminOSWindowsXPPersonal	= 11,
	COMAdminOSWindowsXPProfessional	= 12,
	COMAdminOSWindowsNETStandardServer	= 13,
	COMAdminOSWindowsNETEnterpriseServer	= 14,
	COMAdminOSWindowsNETDatacenterServer	= 15,
	COMAdminOSWindowsNETWebServer	= 16,
	COMAdminOSWindowsLonghornPersonal	= 17,
	COMAdminOSWindowsLonghornProfessional	= 18,
	COMAdminOSWindowsLonghornStandardServer	= 19,
	COMAdminOSWindowsLonghornEnterpriseServer	= 20,
	COMAdminOSWindowsLonghornDatacenterServer	= 21,
	COMAdminOSWindowsLonghornWebServer	= 22
    } 	COMAdminOS;

typedef /* [helpstring] */ 
enum COMAdminServiceOptions
    {	COMAdminServiceLoadBalanceRouter	= 1
    } 	COMAdminServiceOptions;

typedef /* [helpstring] */ 
enum COMAdminServiceStatusOptions
    {	COMAdminServiceStopped	= 0,
	COMAdminServiceStartPending	= ( COMAdminServiceStopped + 1 ) ,
	COMAdminServiceStopPending	= ( COMAdminServiceStartPending + 1 ) ,
	COMAdminServiceRunning	= ( COMAdminServiceStopPending + 1 ) ,
	COMAdminServiceContinuePending	= ( COMAdminServiceRunning + 1 ) ,
	COMAdminServicePausePending	= ( COMAdminServiceContinuePending + 1 ) ,
	COMAdminServicePaused	= ( COMAdminServicePausePending + 1 ) ,
	COMAdminServiceUnknownState	= ( COMAdminServicePaused + 1 ) 
    } 	COMAdminServiceStatusOptions;

typedef /* [helpstring] */ 
enum COMAdminQCMessageAuthenticateOptions
    {	COMAdminQCMessageAuthenticateSecureApps	= 0,
	COMAdminQCMessageAuthenticateOff	= 1,
	COMAdminQCMessageAuthenticateOn	= 2
    } 	COMAdminQCMessageAuthenticateOptions;

typedef /* [helpstring] */ 
enum COMAdminFileFlags
    {	COMAdminFileFlagLoadable	= 0x1,
	COMAdminFileFlagCOM	= 0x2,
	COMAdminFileFlagContainsPS	= 0x4,
	COMAdminFileFlagContainsComp	= 0x8,
	COMAdminFileFlagContainsTLB	= 0x10,
	COMAdminFileFlagSelfReg	= 0x20,
	COMAdminFileFlagSelfUnReg	= 0x40,
	COMAdminFileFlagUnloadableDLL	= 0x80,
	COMAdminFileFlagDoesNotExist	= 0x100,
	COMAdminFileFlagAlreadyInstalled	= 0x200,
	COMAdminFileFlagBadTLB	= 0x400,
	COMAdminFileFlagGetClassObjFailed	= 0x800,
	COMAdminFileFlagClassNotAvailable	= 0x1000,
	COMAdminFileFlagRegistrar	= 0x2000,
	COMAdminFileFlagNoRegistrar	= 0x4000,
	COMAdminFileFlagDLLRegsvrFailed	= 0x8000,
	COMAdminFileFlagRegTLBFailed	= 0x10000,
	COMAdminFileFlagRegistrarFailed	= 0x20000,
	COMAdminFileFlagError	= 0x40000
    } 	COMAdminFileFlags;

typedef /* [helpstring] */ 
enum COMAdminComponentFlags
    {	COMAdminCompFlagTypeInfoFound	= 0x1,
	COMAdminCompFlagCOMPlusPropertiesFound	= 0x2,
	COMAdminCompFlagProxyFound	= 0x4,
	COMAdminCompFlagInterfacesFound	= 0x8,
	COMAdminCompFlagAlreadyInstalled	= 0x10,
	COMAdminCompFlagNotInApplication	= 0x20
    } 	COMAdminComponentFlags;

#define	COMAdminCollectionRoot	( "Root" )

#define	COMAdminCollectionApplications	( "Applications" )

#define	COMAdminCollectionComponents	( "Components" )

#define	COMAdminCollectionComputerList	( "ComputerList" )

#define	COMAdminCollectionApplicationCluster	( "ApplicationCluster" )

#define	COMAdminCollectionLocalComputer	( "LocalComputer" )

#define	COMAdminCollectionInprocServers	( "InprocServers" )

#define	COMAdminCollectionRelatedCollectionInfo	( "RelatedCollectionInfo" )

#define	COMAdminCollectionPropertyInfo	( "PropertyInfo" )

#define	COMAdminCollectionRoles	( "Roles" )

#define	COMAdminCollectionErrorInfo	( "ErrorInfo" )

#define	COMAdminCollectionInterfacesForComponent	( "InterfacesForComponent" )

#define	COMAdminCollectionRolesForComponent	( "RolesForComponent" )

#define	COMAdminCollectionMethodsForInterface	( "MethodsForInterface" )

#define	COMAdminCollectionRolesForInterface	( "RolesForInterface" )

#define	COMAdminCollectionRolesForMethod	( "RolesForMethod" )

#define	COMAdminCollectionUsersInRole	( "UsersInRole" )

#define	COMAdminCollectionDCOMProtocols	( "DCOMProtocols" )

#define	COMAdminCollectionPartitions	( "Partitions" )

typedef /* [helpstring] */ 
enum COMAdminErrorCodes
    {	COMAdminErrObjectErrors	= ( HRESULT  )0x80110401L,
	COMAdminErrObjectInvalid	= ( HRESULT  )0x80110402L,
	COMAdminErrKeyMissing	= ( HRESULT  )0x80110403L,
	COMAdminErrAlreadyInstalled	= ( HRESULT  )0x80110404L,
	COMAdminErrAppFileWriteFail	= ( HRESULT  )0x80110407L,
	COMAdminErrAppFileReadFail	= ( HRESULT  )0x80110408L,
	COMAdminErrAppFileVersion	= ( HRESULT  )0x80110409L,
	COMAdminErrBadPath	= ( HRESULT  )0x8011040aL,
	COMAdminErrApplicationExists	= ( HRESULT  )0x8011040bL,
	COMAdminErrRoleExists	= ( HRESULT  )0x8011040cL,
	COMAdminErrCantCopyFile	= ( HRESULT  )0x8011040dL,
	COMAdminErrNoUser	= ( HRESULT  )0x8011040fL,
	COMAdminErrInvalidUserids	= ( HRESULT  )0x80110410L,
	COMAdminErrNoRegistryCLSID	= ( HRESULT  )0x80110411L,
	COMAdminErrBadRegistryProgID	= ( HRESULT  )0x80110412L,
	COMAdminErrAuthenticationLevel	= ( HRESULT  )0x80110413L,
	COMAdminErrUserPasswdNotValid	= ( HRESULT  )0x80110414L,
	COMAdminErrCLSIDOrIIDMismatch	= ( HRESULT  )0x80110418L,
	COMAdminErrRemoteInterface	= ( HRESULT  )0x80110419L,
	COMAdminErrDllRegisterServer	= ( HRESULT  )0x8011041aL,
	COMAdminErrNoServerShare	= ( HRESULT  )0x8011041bL,
	COMAdminErrDllLoadFailed	= ( HRESULT  )0x8011041dL,
	COMAdminErrBadRegistryLibID	= ( HRESULT  )0x8011041eL,
	COMAdminErrAppDirNotFound	= ( HRESULT  )0x8011041fL,
	COMAdminErrRegistrarFailed	= ( HRESULT  )0x80110423L,
	COMAdminErrCompFileDoesNotExist	= ( HRESULT  )0x80110424L,
	COMAdminErrCompFileLoadDLLFail	= ( HRESULT  )0x80110425L,
	COMAdminErrCompFileGetClassObj	= ( HRESULT  )0x80110426L,
	COMAdminErrCompFileClassNotAvail	= ( HRESULT  )0x80110427L,
	COMAdminErrCompFileBadTLB	= ( HRESULT  )0x80110428L,
	COMAdminErrCompFileNotInstallable	= ( HRESULT  )0x80110429L,
	COMAdminErrNotChangeable	= ( HRESULT  )0x8011042aL,
	COMAdminErrNotDeletable	= ( HRESULT  )0x8011042bL,
	COMAdminErrSession	= ( HRESULT  )0x8011042cL,
	COMAdminErrCompMoveLocked	= ( HRESULT  )0x8011042dL,
	COMAdminErrCompMoveBadDest	= ( HRESULT  )0x8011042eL,
	COMAdminErrRegisterTLB	= ( HRESULT  )0x80110430L,
	COMAdminErrSystemApp	= ( HRESULT  )0x80110433L,
	COMAdminErrCompFileNoRegistrar	= ( HRESULT  )0x80110434L,
	COMAdminErrCoReqCompInstalled	= ( HRESULT  )0x80110435L,
	COMAdminErrServiceNotInstalled	= ( HRESULT  )0x80110436L,
	COMAdminErrPropertySaveFailed	= ( HRESULT  )0x80110437L,
	COMAdminErrObjectExists	= ( HRESULT  )0x80110438L,
	COMAdminErrComponentExists	= ( HRESULT  )0x80110439L,
	COMAdminErrRegFileCorrupt	= ( HRESULT  )0x8011043bL,
	COMAdminErrPropertyOverflow	= ( HRESULT  )0x8011043cL,
	COMAdminErrNotInRegistry	= ( HRESULT  )0x8011043eL,
	COMAdminErrObjectNotPoolable	= ( HRESULT  )0x8011043fL,
	COMAdminErrApplidMatchesClsid	= ( HRESULT  )0x80110446L,
	COMAdminErrRoleDoesNotExist	= ( HRESULT  )0x80110447L,
	COMAdminErrStartAppNeedsComponents	= ( HRESULT  )0x80110448L,
	COMAdminErrRequiresDifferentPlatform	= ( HRESULT  )0x80110449L,
	COMAdminErrQueuingServiceNotAvailable	= ( HRESULT  )0x80110602L,
	COMAdminErrObjectParentMissing	= ( HRESULT  )0x80110808L,
	COMAdminErrObjectDoesNotExist	= ( HRESULT  )0x80110809L,
	COMAdminErrCanNotExportAppProxy	= ( HRESULT  )0x8011044aL,
	COMAdminErrCanNotStartApp	= ( HRESULT  )0x8011044bL,
	COMAdminErrCanNotExportSystemApp	= ( HRESULT  )0x8011044cL,
	COMAdminErrCanNotSubscribeToComponent	= ( HRESULT  )0x8011044dL,
	COMAdminErrAppNotRunning	= ( HRESULT  )0x8011080aL,
	COMAdminErrEventClassCannotBeSubscriber	= ( HRESULT  )0x8011044eL,
	COMAdminErrLibAppProxyIncompatible	= ( HRESULT  )0x8011044fL,
	COMAdminErrBasePartitionOnly	= ( HRESULT  )0x80110450L,
	COMAdminErrDuplicatePartitionName	= ( HRESULT  )0x80110457L,
	COMAdminErrPartitionInUse	= ( HRESULT  )0x80110459L,
	COMAdminErrImportedComponentsNotAllowed	= ( HRESULT  )0x8011045bL,
	COMAdminErrRegdbNotInitialized	= ( HRESULT  )0x80110472L,
	COMAdminErrRegdbNotOpen	= ( HRESULT  )0x80110473L,
	COMAdminErrRegdbSystemErr	= ( HRESULT  )0x80110474L,
	COMAdminErrRegdbAlreadyRunning	= ( HRESULT  )0x80110475L,
	COMAdminErrMigVersionNotSupported	= ( HRESULT  )0x80110480L,
	COMAdminErrMigSchemaNotFound	= ( HRESULT  )0x80110481L,
	COMAdminErrCatBitnessMismatch	= ( HRESULT  )0x80110482L,
	COMAdminErrCatUnacceptableBitness	= ( HRESULT  )0x80110483L,
	COMAdminErrCatWrongAppBitnessBitness	= ( HRESULT  )0x80110484L,
	COMAdminErrCatPauseResumeNotSupported	= ( HRESULT  )0x80110485L,
	COMAdminErrCatServerFault	= ( HRESULT  )0x80110486L,
	COMAdminErrCantRecycleLibraryApps	= ( HRESULT  )0x8011080fL,
	COMAdminErrCantRecycleServiceApps	= ( HRESULT  )0x80110811L,
	COMAdminErrProcessAlreadyRecycled	= ( HRESULT  )0x80110812L,
	COMAdminErrPausedProcessMayNotBeRecycled	= ( HRESULT  )0x80110813L,
	COMAdminErrInvalidPartition	= ( HRESULT  )0x8011080bL,
	COMAdminErrPartitionMsiOnly	= ( HRESULT  )0x80110819L,
	COMAdminErrStartAppDisabled	= ( HRESULT  )0x80110451L,
	COMAdminErrCompMoveSource	= ( HRESULT  )0x8011081cL,
	COMAdminErrCompMoveDest	= ( HRESULT  )0x8011081dL,
	COMAdminErrCompMovePrivate	= ( HRESULT  )0x8011081eL,
	COMAdminErrCannotCopyEventClass	= ( HRESULT  )0x80110820L
    } 	COMAdminErrorCodes;


EXTERN_C const IID LIBID_COMAdmin;

EXTERN_C const CLSID CLSID_COMAdminCatalog;

#ifdef __cplusplus

class DECLSPEC_UUID("F618C514-DFB8-11d1-A2CF-00805FC79235")
COMAdminCatalog;
#endif

EXTERN_C const CLSID CLSID_COMAdminCatalogObject;

#ifdef __cplusplus

class DECLSPEC_UUID("F618C515-DFB8-11d1-A2CF-00805FC79235")
COMAdminCatalogObject;
#endif

EXTERN_C const CLSID CLSID_COMAdminCatalogCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("F618C516-DFB8-11d1-A2CF-00805FC79235")
COMAdminCatalogCollection;
#endif
#endif /* __COMAdmin_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\commdlg.inl ===
/* Copyright (c) 2001-2008, Microsoft Corp. All rights reserved. */

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif


#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)


#if !defined(ISOLATION_AWARE_USE_STATIC_LIBRARY)
#define ISOLATION_AWARE_USE_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_BUILD_STATIC_LIBRARY)
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_INLINE)
#if ISOLATION_AWARE_BUILD_STATIC_LIBRARY
#define ISOLATION_AWARE_INLINE /* nothing */
#else
#if defined(__cplusplus)
#define ISOLATION_AWARE_INLINE inline
#else
#define ISOLATION_AWARE_INLINE __inline
#endif
#endif
#endif

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
FARPROC IsolationAwarePrivatenCv CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY(LPCSTR pszProcName);

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */
BOOL IsolationAwarePrivatenCv IsolationAwareGetOpenFileNameA(LPOPENFILENAMEA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareGetOpenFileNameW(LPOPENFILENAMEW unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareGetSaveFileNameA(LPOPENFILENAMEA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareGetSaveFileNameW(LPOPENFILENAMEW unnamed1);
short IsolationAwarePrivatenCv IsolationAwareGetFileTitleA(LPCSTR unnamed1,__out_ecount(cchSize) LPSTR Buf,__in WORD cchSize);
short IsolationAwarePrivatenCv IsolationAwareGetFileTitleW(LPCWSTR unnamed1,__out_ecount(cchSize) LPWSTR Buf,__in WORD cchSize);
BOOL IsolationAwarePrivatenCv IsolationAwareChooseColorA(LPCHOOSECOLORA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareChooseColorW(LPCHOOSECOLORW unnamed1);
HWND IsolationAwarePrivatenCv IsolationAwareFindTextA(LPFINDREPLACEA unnamed1);
HWND IsolationAwarePrivatenCv IsolationAwareFindTextW(LPFINDREPLACEW unnamed1);
HWND IsolationAwarePrivatenCv IsolationAwareReplaceTextA(LPFINDREPLACEA unnamed1);
HWND IsolationAwarePrivatenCv IsolationAwareReplaceTextW(LPFINDREPLACEW unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareChooseFontA(LPCHOOSEFONTA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareChooseFontW(LPCHOOSEFONTW unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwarePrintDlgA(LPPRINTDLGA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwarePrintDlgW(LPPRINTDLGW unnamed1);
#if defined(STDMETHOD) && (WINVER >= 0x0500)
HRESULT IsolationAwarePrivatenCv IsolationAwarePrintDlgExA(LPPRINTDLGEXA unnamed1);
HRESULT IsolationAwarePrivatenCv IsolationAwarePrintDlgExW(LPPRINTDLGEXW unnamed1);
#endif /* defined(STDMETHOD) && (WINVER >= 0x0500) */
DWORD IsolationAwarePrivatenCv IsolationAwareCommDlgExtendedError(void);
BOOL IsolationAwarePrivatenCv IsolationAwarePageSetupDlgA(LPPAGESETUPDLGA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwarePageSetupDlgW(LPPAGESETUPDLGW unnamed1);

ISOLATION_AWARE_INLINE HRESULT CommdlgIsolationAwarePrivateJVaQPGbueRfhYg(void)
{
    DWORD dwLastError = GetLastError();
    if (dwLastError == NO_ERROR)
        dwLastError = ERROR_INTERNAL_ERROR;
    return HRESULT_FROM_WIN32(dwLastError);
}

#if defined(UNICODE)

#define IsolationAwareChooseColor IsolationAwareChooseColorW
#define IsolationAwareChooseFont IsolationAwareChooseFontW
#define IsolationAwareFindText IsolationAwareFindTextW
#define IsolationAwareGetFileTitle IsolationAwareGetFileTitleW
#define IsolationAwareGetOpenFileName IsolationAwareGetOpenFileNameW
#define IsolationAwareGetSaveFileName IsolationAwareGetSaveFileNameW
#define IsolationAwarePageSetupDlg IsolationAwarePageSetupDlgW
#define IsolationAwarePrintDlg IsolationAwarePrintDlgW
#define IsolationAwarePrintDlgEx IsolationAwarePrintDlgExW
#define IsolationAwareReplaceText IsolationAwareReplaceTextW

#else /* UNICODE */

#define IsolationAwareChooseColor IsolationAwareChooseColorA
#define IsolationAwareChooseFont IsolationAwareChooseFontA
#define IsolationAwareFindText IsolationAwareFindTextA
#define IsolationAwareGetFileTitle IsolationAwareGetFileTitleA
#define IsolationAwareGetOpenFileName IsolationAwareGetOpenFileNameA
#define IsolationAwareGetSaveFileName IsolationAwareGetSaveFileNameA
#define IsolationAwarePageSetupDlg IsolationAwarePageSetupDlgA
#define IsolationAwarePrintDlg IsolationAwarePrintDlgA
#define IsolationAwarePrintDlgEx IsolationAwarePrintDlgExA
#define IsolationAwareReplaceText IsolationAwareReplaceTextA

#endif /* UNICODE */

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetOpenFileNameA(LPOPENFILENAMEA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPOPENFILENAMEA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetOpenFileNameA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetOpenFileNameW(LPOPENFILENAMEW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPOPENFILENAMEW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetOpenFileNameW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetSaveFileNameA(LPOPENFILENAMEA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPOPENFILENAMEA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetSaveFileNameA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetSaveFileNameW(LPOPENFILENAMEW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPOPENFILENAMEW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetSaveFileNameW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE short IsolationAwarePrivatenCv IsolationAwareGetFileTitleA(LPCSTR unnamed1,__out_ecount(cchSize) LPSTR Buf,__in WORD cchSize)
{
    short nResult = -1;
    typedef short (WINAPI* PFN)(LPCSTR unnamed1,__out_ecount(cchSize) LPSTR Buf,__in WORD cchSize);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetFileTitleA");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1,Buf,cchSize);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE short IsolationAwarePrivatenCv IsolationAwareGetFileTitleW(LPCWSTR unnamed1,__out_ecount(cchSize) LPWSTR Buf,__in WORD cchSize)
{
    short nResult = -1;
    typedef short (WINAPI* PFN)(LPCWSTR unnamed1,__out_ecount(cchSize) LPWSTR Buf,__in WORD cchSize);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetFileTitleW");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1,Buf,cchSize);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareChooseColorA(LPCHOOSECOLORA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPCHOOSECOLORA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ChooseColorA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareChooseColorW(LPCHOOSECOLORW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPCHOOSECOLORW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ChooseColorW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareFindTextA(LPFINDREPLACEA unnamed1)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(LPFINDREPLACEA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("FindTextA");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareFindTextW(LPFINDREPLACEW unnamed1)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(LPFINDREPLACEW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("FindTextW");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareReplaceTextA(LPFINDREPLACEA unnamed1)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(LPFINDREPLACEA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ReplaceTextA");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareReplaceTextW(LPFINDREPLACEW unnamed1)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(LPFINDREPLACEW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ReplaceTextW");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareChooseFontA(LPCHOOSEFONTA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPCHOOSEFONTA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ChooseFontA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareChooseFontW(LPCHOOSEFONTW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPCHOOSEFONTW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ChooseFontW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwarePrintDlgA(LPPRINTDLGA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPPRINTDLGA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PrintDlgA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwarePrintDlgW(LPPRINTDLGW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPPRINTDLGW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PrintDlgW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

#if defined(STDMETHOD) && (WINVER >= 0x0500)

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwarePrintDlgExA(LPPRINTDLGEXA unnamed1)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(LPPRINTDLGEXA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommdlgIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PrintDlgExA");
            if (s_pfn == NULL)
            {
                result = CommdlgIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwarePrintDlgExW(LPPRINTDLGEXW unnamed1)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(LPPRINTDLGEXW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommdlgIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PrintDlgExW");
            if (s_pfn == NULL)
            {
                result = CommdlgIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

#endif /* defined(STDMETHOD) && (WINVER >= 0x0500) */

ISOLATION_AWARE_INLINE DWORD IsolationAwarePrivatenCv IsolationAwareCommDlgExtendedError(void)
{
    DWORD nResult = 0 ;
    typedef DWORD (WINAPI* PFN)(void);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("CommDlgExtendedError");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn();
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwarePageSetupDlgA(LPPAGESETUPDLGA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPPAGESETUPDLGA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PageSetupDlgA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwarePageSetupDlgW(LPPAGESETUPDLGW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPPAGESETUPDLGW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PageSetupDlgW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE FARPROC IsolationAwarePrivatenCv CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY(LPCSTR pszProcName)
/* This function is shared by the other stubs in this header. */
{
    FARPROC proc = NULL;
    static HMODULE s_module;
    BOOL fActivateActCtxSuccess = FALSE;
    ULONG_PTR ulpCookie = 0;
#ifndef _M_CEE_PURE
    const static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB
        c = { IsolationAwarePrivatezlybNQyVOeNelJ, L"Comdlg32.dll"
#ifdef _M_IX86
             , IsolationAwarePrivatezlybNQyVOeNeln, "Comdlg32.dll"
#endif
    };
#else
    static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB c;
    c.WinbaseIsolationAwarePrivateybNQJ = IsolationAwarePrivatezlybNQyVOeNelJ;
    c.WinbaseIsolationAwarePrivateANZRJ = L"Comdlg32.dll";
#ifdef _M_IX86
    c.WinbaseIsolationAwarePrivateybNQn = IsolationAwarePrivatezlybNQyVOeNeln;
    c.WinbaseIsolationAwarePrivateANZRn = "Comdlg32.dll";
#endif
#endif
    static IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB m;

    __try
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            fActivateActCtxSuccess = IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
            if (!fActivateActCtxSuccess)
                __leave;
        }
        proc = IsolationAwarePrivatezltRgCebPnQQeRff(&c, &m, pszProcName);
    }
    __finally
    {
        if (
#ifdef _M_IX86
            !IsolationAwarePrivateT_SqbjaYRiRY &&
#endif
            fActivateActCtxSuccess)
        {
            const DWORD dwLastError = (proc == NULL) ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (proc == NULL)
                SetLastError(dwLastError);
        }
    }
    return proc;
}

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */

#define ChooseColorA IsolationAwareChooseColorA
#define ChooseColorW IsolationAwareChooseColorW
#define ChooseFontA IsolationAwareChooseFontA
#define ChooseFontW IsolationAwareChooseFontW
#define CommDlgExtendedError IsolationAwareCommDlgExtendedError
#define FindTextA IsolationAwareFindTextA
#define FindTextW IsolationAwareFindTextW
#define GetFileTitleA IsolationAwareGetFileTitleA
#define GetFileTitleW IsolationAwareGetFileTitleW
#define GetOpenFileNameA IsolationAwareGetOpenFileNameA
#define GetOpenFileNameW IsolationAwareGetOpenFileNameW
#define GetSaveFileNameA IsolationAwareGetSaveFileNameA
#define GetSaveFileNameW IsolationAwareGetSaveFileNameW
#define PageSetupDlgA IsolationAwarePageSetupDlgA
#define PageSetupDlgW IsolationAwarePageSetupDlgW
#define PrintDlgA IsolationAwarePrintDlgA
#define PrintDlgExA IsolationAwarePrintDlgExA
#define PrintDlgExW IsolationAwarePrintDlgExW
#define PrintDlgW IsolationAwarePrintDlgW
#define ReplaceTextA IsolationAwareReplaceTextA
#define ReplaceTextW IsolationAwareReplaceTextW

#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */


#if defined(__cplusplus)
} /* __cplusplus */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\commoncontrols.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for commoncontrols.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __commoncontrols_h__
#define __commoncontrols_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IImageList_FWD_DEFINED__
#define __IImageList_FWD_DEFINED__
typedef interface IImageList IImageList;
#endif 	/* __IImageList_FWD_DEFINED__ */


#ifndef __IImageList2_FWD_DEFINED__
#define __IImageList2_FWD_DEFINED__
typedef interface IImageList2 IImageList2;
#endif 	/* __IImageList2_FWD_DEFINED__ */


#ifndef __ImageList_FWD_DEFINED__
#define __ImageList_FWD_DEFINED__

#ifdef __cplusplus
typedef class ImageList ImageList;
#else
typedef struct ImageList ImageList;
#endif /* __cplusplus */

#endif 	/* __ImageList_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_commoncontrols_0000_0000 */
/* [local] */ 

#if (_WIN32_IE >= 0x0501)
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI
#ifdef MIDL_PASS
typedef DWORD RGBQUAD;

typedef IUnknown *HIMAGELIST;

typedef struct _IMAGELIST* HIMAGELIST;
typedef struct _IMAGELISTDRAWPARAMS
    {
    DWORD cbSize;
    HIMAGELIST himl;
    int i;
    HDC hdcDst;
    int x;
    int y;
    int cx;
    int cy;
    int xBitmap;
    int yBitmap;
    COLORREF rgbBk;
    COLORREF rgbFg;
    UINT fStyle;
    DWORD dwRop;
    DWORD fState;
    DWORD Frame;
    COLORREF crEffect;
    } 	IMAGELISTDRAWPARAMS;

typedef IMAGELISTDRAWPARAMS *LPIMAGELISTDRAWPARAMS;

typedef struct tagIMAGEINFO
    {
    HBITMAP hbmImage;
    HBITMAP hbmMask;
    int Unused1;
    int Unused2;
    RECT rcImage;
    } 	IMAGEINFO;

typedef IMAGEINFO *LPIMAGEINFO;

#endif
#if _WIN32_WINNT >= 0x0600
WINCOMMCTRLAPI HRESULT WINAPI ImageList_CoCreateInstance(
         __in  REFCLSID rclsid,
         __in  const IUnknown *punkOuter,
         __in  REFIID riid,
         __out void **ppv);
#endif
#define ILIF_ALPHA               0x00000001
#define ILIF_LOWQUALITY          0x00000002
#define ILDRF_IMAGELOWQUALITY    0x00000001
#define ILDRF_OVERLAYLOWQUALITY  0x00000010


extern RPC_IF_HANDLE __MIDL_itf_commoncontrols_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_commoncontrols_0000_0000_v0_0_s_ifspec;

#ifndef __IImageList_INTERFACE_DEFINED__
#define __IImageList_INTERFACE_DEFINED__

/* interface IImageList */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IImageList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46EB5926-582E-4017-9FDF-E8998DAA0950")
    IImageList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ 
            __in  HBITMAP hbmImage,
            /* [in] */ 
            __in  HBITMAP hbmMask,
            /* [out] */ 
            __out  int *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceIcon( 
            int i,
            /* [in] */ 
            __in  HICON hicon,
            /* [out] */ 
            __out  int *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOverlayImage( 
            int iImage,
            int iOverlay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Replace( 
            int i,
            /* [in] */ 
            __in  HBITMAP hbmImage,
            /* [in] */ 
            __in  HBITMAP hbmMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMasked( 
            /* [in] */ 
            __in  HBITMAP hbmImage,
            COLORREF crMask,
            /* [out] */ 
            __out  int *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ 
            __in  IMAGELISTDRAWPARAMS *pimldp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            int i) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcon( 
            int i,
            UINT flags,
            /* [out] */ 
            __out  HICON *picon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageInfo( 
            int i,
            /* [out] */ 
            __out  IMAGEINFO *pImageInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Copy( 
            int iDst,
            /* [in] */ 
            __in  IUnknown *punkSrc,
            int iSrc,
            UINT uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Merge( 
            int i1,
            /* [in] */ 
            __in  IUnknown *punk2,
            int i2,
            int dx,
            int dy,
            REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageRect( 
            int i,
            /* [out] */ 
            __out  RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconSize( 
            /* [out] */ 
            __out  int *cx,
            /* [out] */ 
            __out  int *cy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIconSize( 
            int cx,
            int cy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageCount( 
            /* [out] */ 
            __out  int *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImageCount( 
            UINT uNewCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBkColor( 
            COLORREF clrBk,
            /* [out] */ 
            __out  COLORREF *pclr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBkColor( 
            /* [out] */ 
            __out  COLORREF *pclr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginDrag( 
            int iTrack,
            int dxHotspot,
            int dyHotspot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndDrag( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragEnter( 
            /* [unique][in] */ 
            __in_opt  HWND hwndLock,
            int x,
            int y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragLeave( 
            /* [unique][in] */ 
            __in_opt  HWND hwndLock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragMove( 
            int x,
            int y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDragCursorImage( 
            /* [in] */ 
            __in  IUnknown *punk,
            int iDrag,
            int dxHotspot,
            int dyHotspot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragShowNolock( 
            BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDragImage( 
            /* [out] */ 
            __out_opt  POINT *ppt,
            /* [out] */ 
            __out_opt  POINT *pptHotspot,
            REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemFlags( 
            int i,
            /* [out] */ 
            __out  DWORD *dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOverlayImage( 
            int iOverlay,
            /* [out] */ 
            __out  int *piIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImageList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImageList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImageList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IImageList * This,
            /* [in] */ 
            __in  HBITMAP hbmImage,
            /* [in] */ 
            __in  HBITMAP hbmMask,
            /* [out] */ 
            __out  int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *ReplaceIcon )( 
            IImageList * This,
            int i,
            /* [in] */ 
            __in  HICON hicon,
            /* [out] */ 
            __out  int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *SetOverlayImage )( 
            IImageList * This,
            int iImage,
            int iOverlay);
        
        HRESULT ( STDMETHODCALLTYPE *Replace )( 
            IImageList * This,
            int i,
            /* [in] */ 
            __in  HBITMAP hbmImage,
            /* [in] */ 
            __in  HBITMAP hbmMask);
        
        HRESULT ( STDMETHODCALLTYPE *AddMasked )( 
            IImageList * This,
            /* [in] */ 
            __in  HBITMAP hbmImage,
            COLORREF crMask,
            /* [out] */ 
            __out  int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IImageList * This,
            /* [in] */ 
            __in  IMAGELISTDRAWPARAMS *pimldp);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IImageList * This,
            int i);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            IImageList * This,
            int i,
            UINT flags,
            /* [out] */ 
            __out  HICON *picon);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageInfo )( 
            IImageList * This,
            int i,
            /* [out] */ 
            __out  IMAGEINFO *pImageInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Copy )( 
            IImageList * This,
            int iDst,
            /* [in] */ 
            __in  IUnknown *punkSrc,
            int iSrc,
            UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Merge )( 
            IImageList * This,
            int i1,
            /* [in] */ 
            __in  IUnknown *punk2,
            int i2,
            int dx,
            int dy,
            REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IImageList * This,
            REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageRect )( 
            IImageList * This,
            int i,
            /* [out] */ 
            __out  RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconSize )( 
            IImageList * This,
            /* [out] */ 
            __out  int *cx,
            /* [out] */ 
            __out  int *cy);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconSize )( 
            IImageList * This,
            int cx,
            int cy);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageCount )( 
            IImageList * This,
            /* [out] */ 
            __out  int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *SetImageCount )( 
            IImageList * This,
            UINT uNewCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetBkColor )( 
            IImageList * This,
            COLORREF clrBk,
            /* [out] */ 
            __out  COLORREF *pclr);
        
        HRESULT ( STDMETHODCALLTYPE *GetBkColor )( 
            IImageList * This,
            /* [out] */ 
            __out  COLORREF *pclr);
        
        HRESULT ( STDMETHODCALLTYPE *BeginDrag )( 
            IImageList * This,
            int iTrack,
            int dxHotspot,
            int dyHotspot);
        
        HRESULT ( STDMETHODCALLTYPE *EndDrag )( 
            IImageList * This);
        
        HRESULT ( STDMETHODCALLTYPE *DragEnter )( 
            IImageList * This,
            /* [unique][in] */ 
            __in_opt  HWND hwndLock,
            int x,
            int y);
        
        HRESULT ( STDMETHODCALLTYPE *DragLeave )( 
            IImageList * This,
            /* [unique][in] */ 
            __in_opt  HWND hwndLock);
        
        HRESULT ( STDMETHODCALLTYPE *DragMove )( 
            IImageList * This,
            int x,
            int y);
        
        HRESULT ( STDMETHODCALLTYPE *SetDragCursorImage )( 
            IImageList * This,
            /* [in] */ 
            __in  IUnknown *punk,
            int iDrag,
            int dxHotspot,
            int dyHotspot);
        
        HRESULT ( STDMETHODCALLTYPE *DragShowNolock )( 
            IImageList * This,
            BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetDragImage )( 
            IImageList * This,
            /* [out] */ 
            __out_opt  POINT *ppt,
            /* [out] */ 
            __out_opt  POINT *pptHotspot,
            REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemFlags )( 
            IImageList * This,
            int i,
            /* [out] */ 
            __out  DWORD *dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetOverlayImage )( 
            IImageList * This,
            int iOverlay,
            /* [out] */ 
            __out  int *piIndex);
        
        END_INTERFACE
    } IImageListVtbl;

    interface IImageList
    {
        CONST_VTBL struct IImageListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IImageList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IImageList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IImageList_Add(This,hbmImage,hbmMask,pi)	\
    ( (This)->lpVtbl -> Add(This,hbmImage,hbmMask,pi) ) 

#define IImageList_ReplaceIcon(This,i,hicon,pi)	\
    ( (This)->lpVtbl -> ReplaceIcon(This,i,hicon,pi) ) 

#define IImageList_SetOverlayImage(This,iImage,iOverlay)	\
    ( (This)->lpVtbl -> SetOverlayImage(This,iImage,iOverlay) ) 

#define IImageList_Replace(This,i,hbmImage,hbmMask)	\
    ( (This)->lpVtbl -> Replace(This,i,hbmImage,hbmMask) ) 

#define IImageList_AddMasked(This,hbmImage,crMask,pi)	\
    ( (This)->lpVtbl -> AddMasked(This,hbmImage,crMask,pi) ) 

#define IImageList_Draw(This,pimldp)	\
    ( (This)->lpVtbl -> Draw(This,pimldp) ) 

#define IImageList_Remove(This,i)	\
    ( (This)->lpVtbl -> Remove(This,i) ) 

#define IImageList_GetIcon(This,i,flags,picon)	\
    ( (This)->lpVtbl -> GetIcon(This,i,flags,picon) ) 

#define IImageList_GetImageInfo(This,i,pImageInfo)	\
    ( (This)->lpVtbl -> GetImageInfo(This,i,pImageInfo) ) 

#define IImageList_Copy(This,iDst,punkSrc,iSrc,uFlags)	\
    ( (This)->lpVtbl -> Copy(This,iDst,punkSrc,iSrc,uFlags) ) 

#define IImageList_Merge(This,i1,punk2,i2,dx,dy,riid,ppv)	\
    ( (This)->lpVtbl -> Merge(This,i1,punk2,i2,dx,dy,riid,ppv) ) 

#define IImageList_Clone(This,riid,ppv)	\
    ( (This)->lpVtbl -> Clone(This,riid,ppv) ) 

#define IImageList_GetImageRect(This,i,prc)	\
    ( (This)->lpVtbl -> GetImageRect(This,i,prc) ) 

#define IImageList_GetIconSize(This,cx,cy)	\
    ( (This)->lpVtbl -> GetIconSize(This,cx,cy) ) 

#define IImageList_SetIconSize(This,cx,cy)	\
    ( (This)->lpVtbl -> SetIconSize(This,cx,cy) ) 

#define IImageList_GetImageCount(This,pi)	\
    ( (This)->lpVtbl -> GetImageCount(This,pi) ) 

#define IImageList_SetImageCount(This,uNewCount)	\
    ( (This)->lpVtbl -> SetImageCount(This,uNewCount) ) 

#define IImageList_SetBkColor(This,clrBk,pclr)	\
    ( (This)->lpVtbl -> SetBkColor(This,clrBk,pclr) ) 

#define IImageList_GetBkColor(This,pclr)	\
    ( (This)->lpVtbl -> GetBkColor(This,pclr) ) 

#define IImageList_BeginDrag(This,iTrack,dxHotspot,dyHotspot)	\
    ( (This)->lpVtbl -> BeginDrag(This,iTrack,dxHotspot,dyHotspot) ) 

#define IImageList_EndDrag(This)	\
    ( (This)->lpVtbl -> EndDrag(This) ) 

#define IImageList_DragEnter(This,hwndLock,x,y)	\
    ( (This)->lpVtbl -> DragEnter(This,hwndLock,x,y) ) 

#define IImageList_DragLeave(This,hwndLock)	\
    ( (This)->lpVtbl -> DragLeave(This,hwndLock) ) 

#define IImageList_DragMove(This,x,y)	\
    ( (This)->lpVtbl -> DragMove(This,x,y) ) 

#define IImageList_SetDragCursorImage(This,punk,iDrag,dxHotspot,dyHotspot)	\
    ( (This)->lpVtbl -> SetDragCursorImage(This,punk,iDrag,dxHotspot,dyHotspot) ) 

#define IImageList_DragShowNolock(This,fShow)	\
    ( (This)->lpVtbl -> DragShowNolock(This,fShow) ) 

#define IImageList_GetDragImage(This,ppt,pptHotspot,riid,ppv)	\
    ( (This)->lpVtbl -> GetDragImage(This,ppt,pptHotspot,riid,ppv) ) 

#define IImageList_GetItemFlags(This,i,dwFlags)	\
    ( (This)->lpVtbl -> GetItemFlags(This,i,dwFlags) ) 

#define IImageList_GetOverlayImage(This,iOverlay,piIndex)	\
    ( (This)->lpVtbl -> GetOverlayImage(This,iOverlay,piIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IImageList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_commoncontrols_0000_0001 */
/* [local] */ 

#define ILR_DEFAULT                  0x0000
#define ILR_HORIZONTAL_LEFT          0x0000
#define ILR_HORIZONTAL_CENTER        0x0001
#define ILR_HORIZONTAL_RIGHT         0x0002
#define ILR_VERTICAL_TOP             0x0000
#define ILR_VERTICAL_CENTER          0x0010
#define ILR_VERTICAL_BOTTOM          0x0020
#define ILR_SCALE_CLIP               0x0000
#define ILR_SCALE_ASPECTRATIO        0x0100


extern RPC_IF_HANDLE __MIDL_itf_commoncontrols_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_commoncontrols_0000_0001_v0_0_s_ifspec;

#ifndef __IImageList2_INTERFACE_DEFINED__
#define __IImageList2_INTERFACE_DEFINED__

/* interface IImageList2 */
/* [object][local][uuid] */ 

#define ILGOS_ALWAYS         0x00000000
#define ILGOS_FROMSTANDBY    0x00000001
#define ILFIP_ALWAYS         0x00000000
#define ILFIP_FROMSTANDBY    0x00000001
#define ILDI_PURGE       0x00000001
#define ILDI_STANDBY     0x00000002
#define ILDI_RESETACCESS 0x00000004
#define ILDI_QUERYACCESS 0x00000008
typedef struct tagIMAGELISTSTATS
    {
    DWORD cbSize;
    int cAlloc;
    int cUsed;
    int cStandby;
    } 	IMAGELISTSTATS;


EXTERN_C const IID IID_IImageList2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("192b9d83-50fc-457b-90a0-2b82a8b5dae1")
    IImageList2 : public IImageList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Resize( 
            int cxNewIconSize,
            int cyNewIconSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalSize( 
            /* [in] */ int iImage,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  int *pcx,
            /* [out] */ 
            __out  int *pcy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOriginalSize( 
            /* [in] */ int iImage,
            /* [in] */ int cx,
            /* [in] */ int cy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            /* [in] */ 
            __in  IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallback( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceImagePresent( 
            /* [in] */ int iImage,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DiscardImages( 
            /* [in] */ int iFirstImage,
            /* [in] */ int iLastImage,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreloadImages( 
            /* [in] */ 
            __in  IMAGELISTDRAWPARAMS *pimldp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [out][in] */ 
            __inout  IMAGELISTSTATS *pils) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ int cx,
            /* [in] */ int cy,
            /* [in] */ UINT flags,
            /* [in] */ int cInitial,
            /* [in] */ int cGrow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Replace2( 
            int i,
            /* [in] */ 
            __in  HBITMAP hbmImage,
            /* [in] */ 
            __in  HBITMAP hbmMask,
            /* [in] */ 
            __in  IUnknown *punk,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceFromImageList( 
            int i,
            /* [in] */ 
            __in  IImageList *pil,
            int iSrc,
            /* [in] */ 
            __in  IUnknown *punk,
            DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageList2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImageList2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImageList2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImageList2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IImageList2 * This,
            /* [in] */ 
            __in  HBITMAP hbmImage,
            /* [in] */ 
            __in  HBITMAP hbmMask,
            /* [out] */ 
            __out  int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *ReplaceIcon )( 
            IImageList2 * This,
            int i,
            /* [in] */ 
            __in  HICON hicon,
            /* [out] */ 
            __out  int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *SetOverlayImage )( 
            IImageList2 * This,
            int iImage,
            int iOverlay);
        
        HRESULT ( STDMETHODCALLTYPE *Replace )( 
            IImageList2 * This,
            int i,
            /* [in] */ 
            __in  HBITMAP hbmImage,
            /* [in] */ 
            __in  HBITMAP hbmMask);
        
        HRESULT ( STDMETHODCALLTYPE *AddMasked )( 
            IImageList2 * This,
            /* [in] */ 
            __in  HBITMAP hbmImage,
            COLORREF crMask,
            /* [out] */ 
            __out  int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IImageList2 * This,
            /* [in] */ 
            __in  IMAGELISTDRAWPARAMS *pimldp);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IImageList2 * This,
            int i);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            IImageList2 * This,
            int i,
            UINT flags,
            /* [out] */ 
            __out  HICON *picon);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageInfo )( 
            IImageList2 * This,
            int i,
            /* [out] */ 
            __out  IMAGEINFO *pImageInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Copy )( 
            IImageList2 * This,
            int iDst,
            /* [in] */ 
            __in  IUnknown *punkSrc,
            int iSrc,
            UINT uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Merge )( 
            IImageList2 * This,
            int i1,
            /* [in] */ 
            __in  IUnknown *punk2,
            int i2,
            int dx,
            int dy,
            REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IImageList2 * This,
            REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageRect )( 
            IImageList2 * This,
            int i,
            /* [out] */ 
            __out  RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconSize )( 
            IImageList2 * This,
            /* [out] */ 
            __out  int *cx,
            /* [out] */ 
            __out  int *cy);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconSize )( 
            IImageList2 * This,
            int cx,
            int cy);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageCount )( 
            IImageList2 * This,
            /* [out] */ 
            __out  int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *SetImageCount )( 
            IImageList2 * This,
            UINT uNewCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetBkColor )( 
            IImageList2 * This,
            COLORREF clrBk,
            /* [out] */ 
            __out  COLORREF *pclr);
        
        HRESULT ( STDMETHODCALLTYPE *GetBkColor )( 
            IImageList2 * This,
            /* [out] */ 
            __out  COLORREF *pclr);
        
        HRESULT ( STDMETHODCALLTYPE *BeginDrag )( 
            IImageList2 * This,
            int iTrack,
            int dxHotspot,
            int dyHotspot);
        
        HRESULT ( STDMETHODCALLTYPE *EndDrag )( 
            IImageList2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DragEnter )( 
            IImageList2 * This,
            /* [unique][in] */ 
            __in_opt  HWND hwndLock,
            int x,
            int y);
        
        HRESULT ( STDMETHODCALLTYPE *DragLeave )( 
            IImageList2 * This,
            /* [unique][in] */ 
            __in_opt  HWND hwndLock);
        
        HRESULT ( STDMETHODCALLTYPE *DragMove )( 
            IImageList2 * This,
            int x,
            int y);
        
        HRESULT ( STDMETHODCALLTYPE *SetDragCursorImage )( 
            IImageList2 * This,
            /* [in] */ 
            __in  IUnknown *punk,
            int iDrag,
            int dxHotspot,
            int dyHotspot);
        
        HRESULT ( STDMETHODCALLTYPE *DragShowNolock )( 
            IImageList2 * This,
            BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetDragImage )( 
            IImageList2 * This,
            /* [out] */ 
            __out_opt  POINT *ppt,
            /* [out] */ 
            __out_opt  POINT *pptHotspot,
            REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemFlags )( 
            IImageList2 * This,
            int i,
            /* [out] */ 
            __out  DWORD *dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetOverlayImage )( 
            IImageList2 * This,
            int iOverlay,
            /* [out] */ 
            __out  int *piIndex);
        
        HRESULT ( STDMETHODCALLTYPE *Resize )( 
            IImageList2 * This,
            int cxNewIconSize,
            int cyNewIconSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalSize )( 
            IImageList2 * This,
            /* [in] */ int iImage,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  int *pcx,
            /* [out] */ 
            __out  int *pcy);
        
        HRESULT ( STDMETHODCALLTYPE *SetOriginalSize )( 
            IImageList2 * This,
            /* [in] */ int iImage,
            /* [in] */ int cx,
            /* [in] */ int cy);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            IImageList2 * This,
            /* [in] */ 
            __in  IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallback )( 
            IImageList2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __deref_out  void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *ForceImagePresent )( 
            IImageList2 * This,
            /* [in] */ int iImage,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DiscardImages )( 
            IImageList2 * This,
            /* [in] */ int iFirstImage,
            /* [in] */ int iLastImage,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *PreloadImages )( 
            IImageList2 * This,
            /* [in] */ 
            __in  IMAGELISTDRAWPARAMS *pimldp);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IImageList2 * This,
            /* [out][in] */ 
            __inout  IMAGELISTSTATS *pils);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IImageList2 * This,
            /* [in] */ int cx,
            /* [in] */ int cy,
            /* [in] */ UINT flags,
            /* [in] */ int cInitial,
            /* [in] */ int cGrow);
        
        HRESULT ( STDMETHODCALLTYPE *Replace2 )( 
            IImageList2 * This,
            int i,
            /* [in] */ 
            __in  HBITMAP hbmImage,
            /* [in] */ 
            __in  HBITMAP hbmMask,
            /* [in] */ 
            __in  IUnknown *punk,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ReplaceFromImageList )( 
            IImageList2 * This,
            int i,
            /* [in] */ 
            __in  IImageList *pil,
            int iSrc,
            /* [in] */ 
            __in  IUnknown *punk,
            DWORD dwFlags);
        
        END_INTERFACE
    } IImageList2Vtbl;

    interface IImageList2
    {
        CONST_VTBL struct IImageList2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageList2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IImageList2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IImageList2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IImageList2_Add(This,hbmImage,hbmMask,pi)	\
    ( (This)->lpVtbl -> Add(This,hbmImage,hbmMask,pi) ) 

#define IImageList2_ReplaceIcon(This,i,hicon,pi)	\
    ( (This)->lpVtbl -> ReplaceIcon(This,i,hicon,pi) ) 

#define IImageList2_SetOverlayImage(This,iImage,iOverlay)	\
    ( (This)->lpVtbl -> SetOverlayImage(This,iImage,iOverlay) ) 

#define IImageList2_Replace(This,i,hbmImage,hbmMask)	\
    ( (This)->lpVtbl -> Replace(This,i,hbmImage,hbmMask) ) 

#define IImageList2_AddMasked(This,hbmImage,crMask,pi)	\
    ( (This)->lpVtbl -> AddMasked(This,hbmImage,crMask,pi) ) 

#define IImageList2_Draw(This,pimldp)	\
    ( (This)->lpVtbl -> Draw(This,pimldp) ) 

#define IImageList2_Remove(This,i)	\
    ( (This)->lpVtbl -> Remove(This,i) ) 

#define IImageList2_GetIcon(This,i,flags,picon)	\
    ( (This)->lpVtbl -> GetIcon(This,i,flags,picon) ) 

#define IImageList2_GetImageInfo(This,i,pImageInfo)	\
    ( (This)->lpVtbl -> GetImageInfo(This,i,pImageInfo) ) 

#define IImageList2_Copy(This,iDst,punkSrc,iSrc,uFlags)	\
    ( (This)->lpVtbl -> Copy(This,iDst,punkSrc,iSrc,uFlags) ) 

#define IImageList2_Merge(This,i1,punk2,i2,dx,dy,riid,ppv)	\
    ( (This)->lpVtbl -> Merge(This,i1,punk2,i2,dx,dy,riid,ppv) ) 

#define IImageList2_Clone(This,riid,ppv)	\
    ( (This)->lpVtbl -> Clone(This,riid,ppv) ) 

#define IImageList2_GetImageRect(This,i,prc)	\
    ( (This)->lpVtbl -> GetImageRect(This,i,prc) ) 

#define IImageList2_GetIconSize(This,cx,cy)	\
    ( (This)->lpVtbl -> GetIconSize(This,cx,cy) ) 

#define IImageList2_SetIconSize(This,cx,cy)	\
    ( (This)->lpVtbl -> SetIconSize(This,cx,cy) ) 

#define IImageList2_GetImageCount(This,pi)	\
    ( (This)->lpVtbl -> GetImageCount(This,pi) ) 

#define IImageList2_SetImageCount(This,uNewCount)	\
    ( (This)->lpVtbl -> SetImageCount(This,uNewCount) ) 

#define IImageList2_SetBkColor(This,clrBk,pclr)	\
    ( (This)->lpVtbl -> SetBkColor(This,clrBk,pclr) ) 

#define IImageList2_GetBkColor(This,pclr)	\
    ( (This)->lpVtbl -> GetBkColor(This,pclr) ) 

#define IImageList2_BeginDrag(This,iTrack,dxHotspot,dyHotspot)	\
    ( (This)->lpVtbl -> BeginDrag(This,iTrack,dxHotspot,dyHotspot) ) 

#define IImageList2_EndDrag(This)	\
    ( (This)->lpVtbl -> EndDrag(This) ) 

#define IImageList2_DragEnter(This,hwndLock,x,y)	\
    ( (This)->lpVtbl -> DragEnter(This,hwndLock,x,y) ) 

#define IImageList2_DragLeave(This,hwndLock)	\
    ( (This)->lpVtbl -> DragLeave(This,hwndLock) ) 

#define IImageList2_DragMove(This,x,y)	\
    ( (This)->lpVtbl -> DragMove(This,x,y) ) 

#define IImageList2_SetDragCursorImage(This,punk,iDrag,dxHotspot,dyHotspot)	\
    ( (This)->lpVtbl -> SetDragCursorImage(This,punk,iDrag,dxHotspot,dyHotspot) ) 

#define IImageList2_DragShowNolock(This,fShow)	\
    ( (This)->lpVtbl -> DragShowNolock(This,fShow) ) 

#define IImageList2_GetDragImage(This,ppt,pptHotspot,riid,ppv)	\
    ( (This)->lpVtbl -> GetDragImage(This,ppt,pptHotspot,riid,ppv) ) 

#define IImageList2_GetItemFlags(This,i,dwFlags)	\
    ( (This)->lpVtbl -> GetItemFlags(This,i,dwFlags) ) 

#define IImageList2_GetOverlayImage(This,iOverlay,piIndex)	\
    ( (This)->lpVtbl -> GetOverlayImage(This,iOverlay,piIndex) ) 


#define IImageList2_Resize(This,cxNewIconSize,cyNewIconSize)	\
    ( (This)->lpVtbl -> Resize(This,cxNewIconSize,cyNewIconSize) ) 

#define IImageList2_GetOriginalSize(This,iImage,dwFlags,pcx,pcy)	\
    ( (This)->lpVtbl -> GetOriginalSize(This,iImage,dwFlags,pcx,pcy) ) 

#define IImageList2_SetOriginalSize(This,iImage,cx,cy)	\
    ( (This)->lpVtbl -> SetOriginalSize(This,iImage,cx,cy) ) 

#define IImageList2_SetCallback(This,punk)	\
    ( (This)->lpVtbl -> SetCallback(This,punk) ) 

#define IImageList2_GetCallback(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetCallback(This,riid,ppv) ) 

#define IImageList2_ForceImagePresent(This,iImage,dwFlags)	\
    ( (This)->lpVtbl -> ForceImagePresent(This,iImage,dwFlags) ) 

#define IImageList2_DiscardImages(This,iFirstImage,iLastImage,dwFlags)	\
    ( (This)->lpVtbl -> DiscardImages(This,iFirstImage,iLastImage,dwFlags) ) 

#define IImageList2_PreloadImages(This,pimldp)	\
    ( (This)->lpVtbl -> PreloadImages(This,pimldp) ) 

#define IImageList2_GetStatistics(This,pils)	\
    ( (This)->lpVtbl -> GetStatistics(This,pils) ) 

#define IImageList2_Initialize(This,cx,cy,flags,cInitial,cGrow)	\
    ( (This)->lpVtbl -> Initialize(This,cx,cy,flags,cInitial,cGrow) ) 

#define IImageList2_Replace2(This,i,hbmImage,hbmMask,punk,dwFlags)	\
    ( (This)->lpVtbl -> Replace2(This,i,hbmImage,hbmMask,punk,dwFlags) ) 

#define IImageList2_ReplaceFromImageList(This,i,pil,iSrc,punk,dwFlags)	\
    ( (This)->lpVtbl -> ReplaceFromImageList(This,i,pil,iSrc,punk,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IImageList2_INTERFACE_DEFINED__ */



#ifndef __CommonControlObjects_LIBRARY_DEFINED__
#define __CommonControlObjects_LIBRARY_DEFINED__

/* library CommonControlObjects */
/* [uuid] */ 


EXTERN_C const IID LIBID_CommonControlObjects;

EXTERN_C const CLSID CLSID_ImageList;

#ifdef __cplusplus

class DECLSPEC_UUID("7C476BA2-02B1-48f4-8048-B24619DDC058")
ImageList;
#endif
#endif /* __CommonControlObjects_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_commoncontrols_0000_0002 */
/* [local] */ 

#endif // if (_WIN32_IE >= 0x0501)


extern RPC_IF_HANDLE __MIDL_itf_commoncontrols_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_commoncontrols_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\compstui.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    compstui.h


Abstract:

    This module contains global header definition for the COMMON DRIVER UI


Author:

[Environment:]

    NT Windows - Common Property Sheet UI DLL.


[Notes:]


Revision History:


--*/

#ifndef _COMPSTUI_
#define _COMPSTUI_

#ifdef __cplusplus
extern "C" {
#endif


#if (!defined(RC_INVOKED))


//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#define DUMMYUNIONNAME4     u4
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#endif
#endif

//
// Predefined ID for the TreeView Option Type
//
//


#define TVOT_2STATES        0
#define TVOT_3STATES        1
#define TVOT_UDARROW        2
#define TVOT_TRACKBAR       3
#define TVOT_SCROLLBAR      4
#define TVOT_LISTBOX        5
#define TVOT_COMBOBOX       6
#define TVOT_EDITBOX        7
#define TVOT_PUSHBUTTON     8
#define TVOT_CHKBOX         9

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define TVOT_NSTATES_EX     10
#define TVOT_LAST           TVOT_NSTATES_EX
#else
#define TVOT_LAST           TVOT_CHKBOX
#endif
#define TVOT_NONE           (TVOT_LAST + 1)

//
// Predefined ID for the TreeView Option Type
//
//
// TVOT_2STATES:
//      Count       = 2
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//
//      BegCtrlID  = 2 States Group Box ID
//      BegCtrlID+1= 2 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_3STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//
// TVOT_3STATES:
//      Count       = 3
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//      pOptParam[2]=pointer to the State 3 OPTPARAM
//
//      BegCtrlID  = 3 States Group Box ID
//      BegCtrlID+1= 3 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= state 3 Radio button ID
//      BegCtrlID+7= state 3 icon control ID
//      BegCtrlID+8= Extended Check Box/Push Button control ID
//      BegCtrlID+9= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_2STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//  ** For TVOT_2STATES, TVOT_3STSATES the 'Sel' field in the OPTITEM has
//     following definitions
//
//      State 1, Sel = 0
//      State 2, Sel = 1
//      State 3, Sel = 2
//
//      for any selection which based on false/true, no/yes, off/ontrue/false,
//      none/select then state 1 (sel=0) must always be the NO, FALSE, OFF or
//      NONE type.
//
// TVOT_NSTATES_EX:
//      Count = N
//      pOptParam[0]=pointer to the first state's OPTPARAM
//      pOptParam[1]=pointer to the second state's OPTPARAM
//        .
//        .
//      pOptParam[N-1]=pointer to the Nth state's OPTPARAM
//
//      BegCtrlID  = N States Group Box ID
//      BegCtrlID+1= N States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 1 combobox
//      BegCtrlID+5= state 2 Radio button ID
//      BegCtrlID+6= state 2 icon control ID
//      BegCtrlID+7= state 2 combobox
//        .
//        .
//      BegCtrlID+[N-1]*3+2= state N Radio button ID
//      BegCtrlID+[N-1]*3+3= state N icon control ID
//      BegCtrlID+[N-1]*3+4= state N combobox
//      BegCtrlID+[N-1]*3+5= description static text
//      BegCtrlID+[N-1]*3+6= icon ID for description static text
//      BegCtrlID+[N-1]*3+7= Extended Check Box/Push Button control ID
//      BegCtrlID+[N-1]*3+8= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_NSTATES_EX, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Pointer to a OPTCOMBO structure
//
//  * A OPTCOMBO structure contains a list of items in a combobox. Its
//    structure is defined later in this file.
//
//  * This option type can be only displayed in a non-treeview page
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to Count - 1
//     For TVOT_NSTSATES_EX the 'Sel' field in the OPTITEM has following
//     definitions
//
//      State 1, Sel = 0
//      State 2, Sel = 1
//       .
//       .
//      State N, Sel = N - 1
//
//  * In the POPTCOMBO data, each has a Sel field to indicate the current
//     selection in the state's combobox.
//
//  * For each pListItem(POPTPARAM) structure under POPTCOMBO data, the data
//    should be like following
//
//      Type    = Option parameter types, such as OPTPF_HIDE
//      pData   = Pointer to the string to describe the state
//      IconID  = Icons resource ID, or common UI standard icon ID
//      lParam  = Ignored
//
//  * It is possible that only one or two of the three states are available. In this case,
//    only the available items will be shown. If there is only one item available, all
//    three radio buttons will be hided, the description static text will be shown to
//    show the text.
//
// TVOT_UDARROW:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = (SHORT)Low range of the up-down control
//                      lParam = (SHORT)High range of the up-down control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//          if pData pointed to no help text then common UI automatically
//          set the (# - #) as help line
//
//      BegCtrlID  = udarrow Group Box ID
//      BegCtrlID+1= udarrow title static title ID
//      BegCtrlID+2= udarrow's editbox ID
//      BegCtrlID+3= udarrow icon control ID
//      BegCtrlID+4= udarrow postfix static text ID
//      BegCtrlID+5= udarrow help static text ID
//      BegCtrlID+6= udarrow arrow ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_TRACKBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the trackbar control
//                      lParam = (SHORT)High range of the trackbar control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//      BegCtrlID  = trackbar Group Box ID
//      BegCtrlID+1= trackbar static title ID
//      BegCtrlID+2= trackbar(horizontal) ID (static FRAME to define size)
//      BegCtrlID+3= trackbar icon control ID
//      BegCtrlID+4= trackbar low range text control ID
//      BegCtrlID+5= trackbar high range text control ID
//      BegCtrlID+6= trackbar postfix ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * the tick frequency is automatically to set to PageSize increment
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_SCROLLBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the scrollbar control
//                      lParam = (SHORT)High range of the scroll control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//
//      BegCtrlID  = scrollbar(horizontal) group box ID
//      BegCtrlID+1= scrollbar(horizontal) static text ID
//      BegCtrlID+2= scrollbar(horizontal) ID
//      BegCtrlID+3= scrollbar icon control ID
//      BegCtrlID+4= scrollbar low range text control ID
//      BegCtrlID+5= scrollbar high range text control ID
//      BegCtrlID+6= scrollbar postfix control ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * Style field in the OPTPARAM is ignored
//
//
//
// TVOT_LISTBOX:
// TVOT_COMBOBOX:
//      Count       = N
//      pOptParam[0]=pointer to the first OPTPARAM (pData=string pointer)
//      pOptParam[1]=pointer to the second OPTPARAM (pData=string pointer)
//          .
//          .
//      pOptParam[N-1]=pointer to the N item string
//
//      BegCtrlID  = Listbox/ComboBox group box ID
//      BegCtrlID+1= Listbox/ComboBox static title ID
//      BegCtrlID+2= Listbox/Combobox ID
//      BegCtrlID+3= Listbox/Combobox icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, the field used as
//
//          Style =Ignored by the common UI
//          pData =Pointer to the name of item
//          IconID=Icon resource ID for the item
//          lParam=ignored by the common UI
//
//      * Only SINGLE selection is supported, to do a multiple selction use
//        multiple OPTITEM and create a header for it
//
//      * an OTLBCBS_SORT style can be specified in the OPTTYPE's LBCBStyle
//        field, and the listbox or combobox will be sorted according to the
//        item's string.
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, when it get received the keyboard
//        focus then common UI will call callback function (only if
//        OPTIF_CALLBACK bit set) with reason of CPSUICB_REASON_LBCB_ACTIVE,
//        this give caller a chance to modify following structure flags/pdata
//        which associate with the current OPTITEM.   The caller's callback
//        function can ONLY modify the flags/data specified here.
//
//          OPTTYPE pointed by the pOptType from OPTITEM
//
//              Style: OTS_LBCB_SORT
//                     OTS_LBCB_INCL_ITEM_NONE
//
//          OPTPARAMs pointed by the pOptParam from the OPTTYPE
//
//              Flags: OPTPF_HIDE
//                     OPTPF_DISABLED
//
//              pData: change string name
//
//
//      * The TVOT_COMBOBOX typically only used in the tree-view if there is
//        only one selection available for that item, when there is only one
//        item then dropdown list will not enabled by the common UI
//
//
//
// TVOT_EDITBOX:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = Edit buffer sie in character pointed by pSel
//                                 this is including the NULL terminator.
//                      lParam = ignored.
//
//      BegCtrlID  = editBox group Box ID
//      BegCtrlID+1= editBox static title ID
//      BegCtrlID+2= editbox ID
//      BegCtrlID+3= editbox icon control ID
//      BegCtrlID+4= editbox postfix ID
//      BegCtrlID+5= editbox help ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//      * Style field is ignored
//
//      * pSel in the OPTITEM is the pointer to the editing string, the pSel
//        must pointed to a buffer eqaul or larger than the count of the buffer
//        (pOptParam[1]->IconID) size
//
//
// TVOT_PUSHBUTTON:
//      Count       = 1
//
//      BegCtrlID  = push button group box ID
//      BegCtrlID+1= push button static text ID (Not used by common UI)
//      BegCtrlID+2= push button ID
//      BegCtrlID+3= push button icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//      PUSHBUTTON_TYPE_xxx specified the action and content of pData in the
//      pOptParam[0] as describe in the following
//
//          PUSHBUTTON_TYPE_DLGPROC
//
//              This push button is designed to bring up caller's dialog box
//
//                  pOptParam[0].pData  = Caller's DLGPROC
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_DLGPROC
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Caller's DIALOG resource template ID
//                                        or handle to the DLGTEMPLATE depends
//                                        on the OPTPF_USE_HDLGTEMPLATE flag
//
//
//              The 'lParam' passed to the DLGPROC's WM_INITDIALOG is the
//              CPSUICBPARAM structure pointer, and the reason field is set
//              to CPSUICB_REASON_DLGPROC.
//
//
//          PUSHBUTTON_TYPE_CALLBACK
//
//              This push button is designed to have caller process the item
//              which cannot accomplished with the dialog box along.
//
//                  pOptParam[0].pData  = CPSUICALLBACK function pointer
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_CALLBACK
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//              Durning the callback the Reason field in CPSUICBPARAM will
//              set to CPSUICB_REASON_PUSHBUTTON.
//
//              ** If pOptParam[0].pData callback function is NULL then common
//                 UI will call the pfnCallBack pointer set in the
//                 COMPROPSHEETUI structure if it is not NULL
//
//              ** The callback function should put the result of the callback
//                 in the pSel/Sel of OPTITEM associate with the push button
//
//          PUSHBUTTON_TYPE_HTCLRADJ
//
//              This push button is designed to bring up halftone color
//              adjustment dialog box.
//
//                  pOptParam[0].pData  = pointer to COLORADJUSTMENT structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTCLRADJ
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam =  Not Used;
//
//
//          PUSHBUTTON_TYPE_HTSETUP
//
//              This push button is designed to bring up device halftone
//              setup dialog box.
//
//                  pOptParam[0].pData  = pointer to DEVHTADJDATA structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTSETUP
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//
//      * 'Sel' field in the OPTITEM for the PUSHBUTTON is the last returned
//        LONG result from the called dialog box or funcitons.  The result
//        only valid if OPTIF_CHANGEONCE flag is set.  The common UI will set
//        OPTIF_CHANGEONCE if push button ever pushed.
//
//      * Since common UI donot know the meaning of the return value and
//        content of the called parameter, it is up to the caller to use
//        callback function to determine the returned result.
//
//      * When returned from the push button except push botton type
//        PUSHBUTTON_TYPE_CALLBACK common ui will call the callback function
//        if the OPTIF_CALLBACK flat is set.  The callback reason is set to
//        CPSUICB_REASON_SEL_CHANGED.
//
//      * If the passed in CPSUIF_UPDATE_PERMISSION Flags in the COMPROPSHEETUI
//        is clear then the callback function must ONLY display the dialog box
//        and not changed any OPTITEM data if OTS_PUSH_ENABLE_ALWAYS
//        flag is set in the OPTTYPE
//
//
// TVOT_CHKBOX:
//      Count               = 1
//
//      pOptparam[0].Style  = CHKBOXS_FALSE_TRUE    False/True
//                            CHKBOXS_NO_YES,       No/YES
//                            CHKBOXS_OFF_ON,       Off/ON
//                            CHKBOXS_FALSEPDATA    False/pData
//                            CHKBOXS_NO_PDATA      No/pData
//                            CHKBOXS_OFF_PDATA     Off/pData
//                            CHKBOXS_NONE_PDATA    None/pData
//      pOptParam[0].pData  = Only used if Style is CHKBOXS_NONE_PDATA
//      pOptParam[0].IconID = Icon resource ID
//      pOptParam[0].lParam = Ignored
//
//
//      BegCtrlID  = check box group ID
//      BegCtrlID+1= Check Box static text (not used by common UI)
//      BegCtrlID+2= check box button ID
//      BegCtrlID+3= check box icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//  * BegCtrlID only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//    which has non-common UI dialog box template (DlgTemplateID in the DLGPAGE
//    is not standard DP_STD_xxx common ui dialog box template).    The common
//    UI used this ID to managed caller's dialog boxes item's selections and
//    initialization.
//
//  * for each item, it has group box ID (BegCtrlID) and static text ctronl ID
//    (BegCtrlID + 1).  The common UI will set the text in one of these two
//    control ID in followng seauence.
//
//      1) If group box control ID's window (BegCtrlID) is exist and the
//         OPTITEM's flag OPTIF_NO_GROUPBOX_NAME is not set then common UI will
//         set the pName from OPTITEM to the group box.
//
//      2) If the group box name is not set and static control ID's window
//         (BegCtrlID + 1) is exist then common UI will set the pName from
//         OPTITEM to the static text control.
//
//  * for TVOT_TRACKBAR and TVOT_SCROLLBAR, if pName in the OPTITEM is set to
//    either group box or static text control then common UI will also append
//    the current selection position of trackbar or scroll bar to the pName.
//
//  * If multiple OPTITEMs using the same POPTPARAM and need different
//    BegCtrlID for each control then then a separate OPTTYPE structure should
//    be generated but POPTPARAM pointed to the same OPTPARAM[]
//
//  * If a BegCtrlID+N is not used then skip that ID in your dialog box
//    template
//
//

#define CHKBOXS_FALSE_TRUE          0
#define CHKBOXS_NO_YES              1
#define CHKBOXS_OFF_ON              2
#define CHKBOXS_FALSE_PDATA         3
#define CHKBOXS_NO_PDATA            4
#define CHKBOXS_OFF_PDATA           5
#define CHKBOXS_NONE_PDATA          6


#define PUSHBUTTON_TYPE_DLGPROC     0
#define PUSHBUTTON_TYPE_CALLBACK    1
#define PUSHBUTTON_TYPE_HTCLRADJ    2
#define PUSHBUTTON_TYPE_HTSETUP     3


#define MAX_RES_STR_CHARS           160

//
// Common Printer UI's LPTSTR
//
// All string pointer in common printer UI structures can be either a real
// memory pointer or a string resource ID.  These are applied to LPTSTR type.
//
// The LPTSTR is defined to identify that the pointer can be a real string
// pointer or a resource ID (either common printer UI provided ID or caller's
// own resource ID).  common UI using following logic to get the final string.
//
//  LPTSTR  pData;
//
//      if ((pData & ~(ULONG_PTR)0xFFFF) != 0) then pData is a NULL terminated
//      string pointer
//
//          ELSE
//
//          (pData & (ULONG_PTR)0xFFFF) = Resource ID
//
//          if (Resource ID is within the common UI string resource ID range)
//          then it load the string from common UI DLL
//
//          ELSE
//
//              it load string from caller's resource
//
//
//  *  You can use MAKEINTRESOURCE(StrResID) to set this field
//
//  * The MAX characters loaded by the common UI from the resource is defined
//    as MAX_RES_STR_CHARS
//
//  * You cannot use LPTSTR as resource ID for the TVOT_EDITBOX style's
//    pSel in the OPTITEM, this pointer must be a real buffer pointer
//
//
//
// ICONs
//
//  Common UI using two types of Icons, One is 32x32 and the other is 16x16
//  plus if any monochrome icon with 32x32 and 16x16 sizes.
//
//  The 16x16 icon when displayed on the screen is using 16x17 pixel space,
//  this is ensure that downware adjacent icon is not crowded together.
//
//  In common UI, if you need to passed a ICON ID, it can either passed a
//  common UI's predefined ID or caller's own ICON resource ID.
//
//
//  * You can use to imagedit or any other Window icon editor to create the
//    icon, each icon file should have one unique icon resource ID which is
//    not overlay with the standard common UI IDI_CPSUI_xxx identifier.  For
//    each icon file, its should have both 32x32 and 16x16 size icon on
//    different display. (ie. monochrome).
//
//    Common UI will try to load the correct size of icon from the icon
//    resource, but it will stretch them if the size is not found.
//
//

//
// Flags for the OPTPARAM
//

#define OPTPF_HIDE                  0x01
#define OPTPF_DISABLED              0x02
#define OPTPF_ICONID_AS_HICON       0x04
#define OPTPF_OVERLAY_WARNING_ICON  0x08
#define OPTPF_OVERLAY_STOP_ICON     0x10
#define OPTPF_OVERLAY_NO_ICON       0x20
#define OPTPF_USE_HDLGTEMPLATE      0x40

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define OPTPF_MASK                  0x7f
#endif

typedef struct _OPTPARAM {
    WORD        cbSize;         // size of this structure
    BYTE        Flags;          // OPTPF_xxxx flags
    BYTE        Style;          // style use in this structure
    LPTSTR      pData;          // pointer to the data
    ULONG_PTR   IconID;         // iconID;
    LPARAM      lParam;         // parameter used
    ULONG_PTR   dwReserved[2];  // reserved dword, must be 0
    } OPTPARAM, *POPTPARAM;


//
// OPTPARAM
//
//  The OPTPARAM structure is used to describe each slectable item in the
//  common UI such as 'letter', 'legal' in the form slection list box
//
//  cbSize      - size of this structure
//
//  Flags       - defined as OPTPF_xxxx
//
//                  OPTPF_HIDE
//
//                      Specified hide this listed selection item and not
//                      availabe for user to select. This only available to
//                      following TVOT_xxx types
//
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//                          TVOT_NSTATES_EX
//
//                      If all the seclection items are OPTPF_HIDE then the
//                      OPTITEM is automatically hided by the common UI, if
//                      TVOT_3STATES has 2 states hide then an error is
//                      returned
//
//
//                  OPTPF_DISABLED
//
//                      Specified this listed selection item is disabled and
//                      not availabe for user to select.   This only available
//                      to following TVOT_xxx types
//
//                          TVOT_2STATES
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//                          TVOT_NSTATES_EX
//
//                  OPTPF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  OPTPF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  OPTPF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  OPTPF_OVERLAY_NO_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  Style       - Style for the OPTPARAM, it depends on the TVOT_xxx type as
//                describe below
//
//                  TVOT_PUSBUTTON
//
//                      it can be one of PUSHBUTTON_TYPE_xxxx.
//
//                  other TVOT_xxxx
//
//                      this fields is not used.
//
//
//  pData       - Is either a pointer to the item name (string) or it is
//                used to describe other data.
//
//                   * If the pData in the OPTPARAM is supposed to be a static
//                     pointer to a string and the string is a common UI
//                     standard resource ID then common UI will check if pData
//                     is equal to IDS_CPSUI_NOTINSTALLED, if true then
//                     common UI will overaly a not installed icon on top of
//                     the OPTPARAM's Icon.   This will not applied to the
//                     TVOT_EDITBOX type since the pData is not a static text
//                     pointer or a string resource ID.
//
//                  ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if OPTPF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  lParam      - Extra data used by the OPTPARAM, it depends on the TVOT_xxx
//                type.
//
//  dwReserved[]- Reserved DWORDs, must be 0
//
//

//
// Flags for the OPTCOMBO
//

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define OPTCF_HIDE      0x01

#define OPTCF_MASK      0x01

typedef struct _OPTCOMBO {
    WORD        cbSize;
    BYTE        Flags;
    WORD        cListItem;
    POPTPARAM   pListItem;
    LONG        Sel;
    DWORD       dwReserved[3];
} OPTCOMBO, *POPTCOMBO;

#endif

//
// OPTCOMBO is to describe data each combobox/listbox item in
// TVOT_NSTATES_EX option type
//
//  cbSize          - sizeof this structure
//
//  Flags           - Item flags
//
//                    OPTCF_HIDE
//
//                        Specified hide this combobox is not available
//                        for user to select.
//
//  cListItem       - Number of the list items
//
//  pListItem       - Pointer to the first list item
//
//  Sel             - Current selection for this item, range from 0 to cListItem - 1
//
//  dwReserved      - DWORD reserved, must be 0
//

//
// Flags for the OPTTYPE
//

#define OPTTF_TYPE_DISABLED             0x01
#define OPTTF_NOSPACE_BEFORE_POSTFIX    0x02

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define OPTTF_MASK                      0x03
#endif

//
// Flags for the OPTTYPE style
//

#define OTS_LBCB_SORT                   0x0001
#define OTS_LBCB_PROPPAGE_LBUSECB       0x0002
#define OTS_LBCB_PROPPAGE_CBUSELB       0x0004
#define OTS_LBCB_INCL_ITEM_NONE         0x0008
#define OTS_LBCB_NO_ICON16_IN_ITEM      0x0010
#define OTS_PUSH_INCL_SETUP_TITLE       0x0020
#define OTS_PUSH_NO_DOT_DOT_DOT         0x0040
#define OTS_PUSH_ENABLE_ALWAYS          0x0080

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define OTS_MASK                        0x00ff
#endif

typedef struct _OPTTYPE {
    WORD        cbSize;
    BYTE        Type;           // TVOT_xxxx type of OPTIONS
    BYTE        Flags;          // OPTTF_xxx flags
    WORD        Count;          // Count of pOptParam passed
    WORD        BegCtrlID;      // start of item's group window ID
    POPTPARAM   pOptParam;      // pointer to the OPTPARAM
    WORD        Style;          // option type style as OTS_xxxx
    WORD        wReserved[3];   // wReserved, must be 0
    ULONG_PTR   dwReserved[3];  // DWORD reserved field (must be 0)
} OPTTYPE, *POPTTYPE;


//
// OPTTYPE
//
//  The OPTTYPE structure is used to describe a set of selection and its
//  select method,  such as Form/Tray assignment.  It has a pointer to a set
//  of selection item (OPTPARAM)
//
//
//  cbSize      - size of this structure
//
//  Type        - Specified the option type using predefined ID as TVOT_xxxx
//
//  Flags       - currently only one flag is defined
//
//
//                  OPTTF_TYPE_DISABLED
//
//                      The whole OPTTYPE's OPTPARAMs are disabled, and non of
//                      the selection in the OPTTYPE can be selected
//
//
//                  OPTTF_NOSPACE_BEFORE_POSTFIX
//
//                      This bit only valid if the OPTTYPE's pOptParam item
//                      specified a postfix string as describe in the above
//                      section.  If this flag is set then it asked common UI
//                      do not add a space character before the postfix string
//                      when it combine the pName in the OPTITEM and postfix
//                      string.   Typeically this bit is not set for the
//                      postfix string, but sometime it may be required not to
//                      add a space character in front of it, such as '%'
//                      postfix string.
//
//
//  Count       - Count of item pointed by pOptParam.  Some predefined number
//                must be set according to the TVOT_XXX description.
//
//  BegCtrlID   - Only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//                which has non-common UI dialog box template (DlgTemplateID
//                in the DLGPAGE is not standard DP_STD_xxx common ui dialog
//                box template).    The common UI used this ID to managed
//                caller's dialog boxes item's selections and initialization.
//
//                Each OPTITEM has predefined number of window ID which
//                associated with that item, the BegCtrlID specified the start
//                control window ID.  Each control window ID in the OPTITEM
//                must have the control ID sequence as describe in the TVOT_xxx
//                above.
//
//  pOptParam   - Pointer to array of OPTPARAM to describe each selectable item
//
//  Style       - Specified the style of type of control box, certain style
//                only apply to centain type of TVOT_xxxx.
//
//                OTS_LBCB_xxx only applied to TVOT_LISTBOX, TVOT_COMBOBOX
//                OTS_PUSH_xxx only applied to TVOT_PUSHBUTTON
//
//
//                  OTS_LBCB_SORT
//
//                      Specified that the listbox or combobox item is sorted
//                      in ascending order based on the pData string
//
//
//                  OTS_LBCB_PROPAGE_LBUSECB
//
//                      Used when Type is TVOT_LISTBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is comobobox instead of listbox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_PROPAGE_CBUSELB
//
//                      Used when Type is TVOT_COMBOBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is listbox instead of combobox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_INCL_ITEM_NONE
//
//                      when this flag is specified, the common ui will
//                      automatically add a 'None' selection to the listbox or
//                      combobox.   The 'Sel' will set to -1 if 'none' is
//                      selection is selected by the user.  It will also
//                      validate the 'Sel' durning the initialization,  any
//                      out of range value will be set to -1 (None).
//
//
//                  OTS_LBCB_NO_ICON16_IN_ITEM
//
//                      By default, each listbox, combox will have a small
//                      icon (16x16) in front of item text. by specified this
//                      bit, the listbox/combobox will not includes icons
//                      in the listbox/combobox.
//
//                      If clear then it specified that in the listbox/combobox
//                      to have 16x16 Icon added to the front of each item
//
//
//                  OTS_PUSH_INCL_SETUP_TITLE
//
//                      If specified for the push button then it automatically
//                      add the 'Setup' to the end of push botton text.
//
//
//                  OTS_PUSH_NO_DOT_DOT_DOT
//
//                      If specified then common UI will not add '...' to the
//                      end of the pName in the OPTITEM and push button name
//
//
//                  OTS_PUSH_ENABLE_ALWAYS
//
//                      This flag specified that even update permissio is not
//                      allowed, it still let user push the push button, if
//                      this flag is set then callback function or dialog box
//                      proc must disable all the control which let user
//                      modified the content, but just let user view the
//                      current setting.
//
//
//  wReserved[] - Reserved fields, must be 0
//
//  dwReserved[]- Reserved fields, must be 0
//
//


//
// Following are flags for the EXTPUSH
//


#define EPF_PUSH_TYPE_DLGPROC       0x0001
#define EPF_INCL_SETUP_TITLE        0x0002
#define EPF_NO_DOT_DOT_DOT          0x0004
#define EPF_ICONID_AS_HICON         0x0008
#define EPF_OVERLAY_WARNING_ICON    0x0010
#define EPF_OVERLAY_STOP_ICON       0x0020
#define EPF_OVERLAY_NO_ICON         0x0040
#define EPF_USE_HDLGTEMPLATE        0x0080

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define EPF_MASK                    0x00ff
#endif

typedef struct _EXTPUSH {
    WORD                cbSize;         // size of the structure
    WORD                Flags;          // EPCBF_xxx flags
    LPTSTR              pTitle;         // extended push botton title
    union {
        DLGPROC         DlgProc;        // pointer to the dialog box proc
        FARPROC         pfnCallBack;    // callback function pointer
        } DUMMYUNIONNAME;
    ULONG_PTR           IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;          // dialog box template ID
        HANDLE  hDlgTemplate;           // handle to the dialog template
        } DUMMYUNIONNAME;
    ULONG_PTR   dwReserved[3];          // reserved field, must be 0
    } EXTPUSH, *PEXTPUSH;

//
// EXTPUSH structure is used to describe the extened push button available
// on OPTITEM/OPTITEM, each OPTTYPE can optional have either one extended check
// box or one extended push button callback.
//
//
//  cbSize          - size of this structure
//
//  Flags           - flags for the EXTPUSH as EPF_xxxx
//
//                      EPF_PUSH_TYPE_DLGPROC
//
//                          If this bit is set then it specified the extended
//                          push button is type of DLGPROC and DlgProc and
//                          DlgTemplateID is valid for common UI to call.
//
//                          If this bit is clear then it specfied the extended
//                          push button is the callback style and pfnCallBack
//                          should be called by the common UI
//
//
//                      EPF_INCL_SETUP_TITLE
//
//                          If specified for the extended push button then it
//                          automatically add the 'Setup' to the end of
//                          extended push button's title
//
//
//                      EPF_NO_DOT_DOT_DOT
//
//                          If specified then common UI will not add '...' to
//                          the end of the pTitle in the EXTPUSH.
//
//
//                      EPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID.
//
//
//                      EPF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                      EPF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                      EPF_OVERLAY_NO_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle          - Pointed to extended push botton title
//
//                      ** See LPTSTR description above
//
//  DlgProc         - Pointer to the DLGPROC function supplied by the caller.
//                    When user push the button the common UI will call
//                    DialogBoxParam() with this fucction pointer and passed
//                    CPSUICBPARAM structure pointer to the WM_INITDIALOG with
//                    the Reason set to CPSUICB_REASON_EXTPUSH.  If this
//                    filed is NULL then common UI assumed that EXTPUSH is
//                    disabled (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE), this
//                    fields only used if EPF_PUSH_TYPE_DLGPROC flag is set
//
//  pfnCallBack     - Pointer to CPSUICALLBACK function, this only used if
//                    EPF_PUSH_TYPE_DLGPROC bit is clear, duringing callback
//                    it passed the CPSUICBPARAM pointer as parameter
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    EPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - Specified the ressource ID for the dilaog box. If the
//                    DlgTemplateID = 0 then common UI will call the DlgProc
//                    with following parameter.
//
//                      DlgProc(hDlg, WM_USER, NULL, (LPARAM)pCPSUICBPaam);
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//  wReserved[]     - WORD reserved field, must be 0
//
//  dwReserved[]    - DWORD reserved field, must be 0
//
//
//


//
// Following are flags for the EXTCHKBOX
//

#define ECBF_CHECKNAME_AT_FRONT         0x0001
#define ECBF_CHECKNAME_ONLY_ENABLED     0x0002
#define ECBF_ICONID_AS_HICON            0x0004
#define ECBF_OVERLAY_WARNING_ICON       0x0008
#define ECBF_OVERLAY_ECBICON_IF_CHECKED 0x0010
#define ECBF_OVERLAY_STOP_ICON          0x0020
#define ECBF_OVERLAY_NO_ICON            0x0040
#define ECBF_CHECKNAME_ONLY             0x0080

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define ECBF_MASK                       0x00ff
#endif

typedef struct _EXTCHKBOX {
    WORD        cbSize;         // size of the structure
    WORD        Flags;          // ECBF_xxx flags
    LPTSTR      pTitle;         // extended checkbox title
    LPTSTR      pSeparator;     // pointer to separator string for treeview
    LPTSTR      pCheckedName;   // string to be displayed when checked
    ULONG_PTR   IconID;         // icon to be used
    WORD        wReserved[4];   // reserved word, must be 0
    ULONG_PTR   dwReserved[2];  // reserved field, must be 0
    } EXTCHKBOX, *PEXTCHKBOX;


//
// EXTCHKBOX structure is used to describe the extened check box available on
// OPTITEM/OPTITEM, each OPTTYPE can optional have one extended check box.
// When using EXTCHKBOX the selection item can be checked or not checked
// based on user input.
//
//
//  cbSize      - size of this structure
//
//  Flags       - flags for the EXTCHKBOX as ECBF_xxxx
//
//                  ECBF_CHECKNAME_AT_FRONT
//
//                      This flag specified how to display item's name and its
//                      checked name in the treeview display.   If this flag is
//                      set then the checked name is display in front of
//                      separator name, otherwise the checked name is displayed
//                      after the separator.  For Example.
//
//                      Flag Set:   pCheckedName pSeparator SelectName
//                      Flag Clear: SelectName pSeparator pCheckedName
//
//
//                  ECBF_CHECKNAME_ONLY_ENABLED
//
//                      If set then it specified that in the treeview display,
//                      it will only show the pCheckedName if this extended
//                      check box is visible and enabled.  Some items may not
//                      desired to display the pCheckedName if the extended
//                      check box is disabled, such as Copy/Collate checkbox.
//
//
//                  ECBF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  ECBF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  ECBF_OVERLAY_ECBICON_IF_CHECKED
//
//                      This bit specified to overlay the ExtChkBox's Icon to
//                      the OPTITEM's icon (or OPTPARAM) if the the extended
//                      checked box is checked
//
//
//                  ECBF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  ECBF_OVERLAY_NO_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle      - Pointed to extended check box title
//
//                  ** See LPTSTR description above
//
//  pSeparator  - Pointer to the separator to be used in the treeview
//                display or the static title control in the non-treeview
//                page,
//
//  pCheckedName- Pointed to the name to be displayed in the treeview if item
//                is checked.  pCheckedName is added according to the
//                pSeparator and the ECBF_CHECKNAME_AT_FRONT flags.
//
//                  * If the pCheckedName is equal to IDS_CPSUI_NOTINSTALLED
//                    then common UI will automatically overaly a not installed
//                    icon on top of the extended check box Icon.
//
//                      ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if ECBF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  wReserved[] - WORD reserved field, must be 0
//
//  dwReserved[]- DWORD reserved field, must be 0
//


//
// Following the the Flags for the OPTITEM
//

#define OPTIF_COLLAPSE              0x00000001L
#define OPTIF_HIDE                  0x00000002L
#define OPTIF_CALLBACK              0x00000004L
#define OPTIF_CHANGED               0x00000008L
#define OPTIF_CHANGEONCE            0x00000010L
#define OPTIF_DISABLED              0x00000020L
#define OPTIF_ECB_CHECKED           0x00000040L
#define OPTIF_EXT_HIDE              0x00000080L
#define OPTIF_EXT_DISABLED          0x00000100L
#define OPTIF_SEL_AS_HICON          0x00000200L
#define OPTIF_EXT_IS_EXTPUSH        0x00000400L
#define OPTIF_NO_GROUPBOX_NAME      0x00000800L
#define OPTIF_OVERLAY_WARNING_ICON  0x00001000L
#define OPTIF_OVERLAY_STOP_ICON     0x00002000L
#define OPTIF_OVERLAY_NO_ICON       0x00004000L
#define OPTIF_INITIAL_TVITEM        0x00008000L
#define OPTIF_HAS_POIEXT            0x00010000L

#define OPTIF_MASK                  0x0001ffffL


#define DMPUB_NONE                  0
#define DMPUB_FIRST                 1

#define DMPUB_ORIENTATION           1
#define DMPUB_SCALE                 2
#define DMPUB_COPIES_COLLATE        3
#define DMPUB_DEFSOURCE             4
#define DMPUB_PRINTQUALITY          5
#define DMPUB_COLOR                 6
#define DMPUB_DUPLEX                7
#define DMPUB_TTOPTION              8
#define DMPUB_FORMNAME              9
#define DMPUB_ICMMETHOD             10
#define DMPUB_ICMINTENT             11
#define DMPUB_MEDIATYPE             12
#define DMPUB_DITHERTYPE            13
#define DMPUB_OUTPUTBIN             14
#define DMPUB_QUALITY               15
#define DMPUB_NUP                   16
#define DMPUB_PAGEORDER             17

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define DMPUB_NUP_DIRECTION         18
#define DMPUB_MANUAL_DUPLEX         19
#define DMPUB_STAPLE                20
#define DMPUB_BOOKLET_EDGE          21
#define DMPUB_LAST                  21
#else
#define DMPUB_LAST                  17
#endif

#define DMPUB_OEM_PAPER_ITEM        97
#define DMPUB_OEM_GRAPHIC_ITEM      98
#define DMPUB_OEM_ROOT_ITEM         99
#define DMPUB_USER                  100

#define MAKE_DMPUB_HIDEBIT(DMPub)   (DWORD)(((DWORD)0x01 << ((DMPub) - 1)))
#define IS_DMPUB_HIDDEN(dw, DMPub)  (BOOL)((DWORD)(dw) &                    \
                                           MAKE_DMPUB_HIDEBIT(DMPub))

//
// DMPUB_xxxx is used in OPTITEM to identify if the item is a DEVMODE public
// field. Following it identify which field correspond to the DMPUB_xxxx
//
//
//  DMPUB_ORIENTATION   - dmOrientation
//
//  DMPUB_SCALE         - dmScale
//
//  DMPUB_COPIES_COLLATE- dmCopies/dmCollate
//
//  DMPUB_DEFSOURCE     - dmDefSource    (Should only used form by caller)
//
//  DMPUB_PRINTQUALITY  - dmPrintQuality
//
//  DMPUB_COLOR         - dmColor
//
//  DMPUB_DUPLEX        - dmDuplex
//
//  DMPUB_TTOPTION      - dmTTOption
//
//  DMPUB_FORMNAME      - dmFormName
//
//  DMPUB_ICMMETHOD     - dmICMMethod
//
//  DMPUB_ICMINTENT     - dmICMIntent
//
//  DMPUB_MEDIATYPE     - dmMediaType
//
//  DMPUB_DITHERTYPE    - dmDitherType
//
//  DMPUB_USER          - Anything greater than or equal to DMPUB_USER can be
//                        used by the caller.
//
//  DMPUB_OUTPUTBIN     - Private
//
//  DMPUB_QUALITY       - Private
//
//  DMPUB_NUP           - Private
//
//  DMPUB_PAGEORDER     - Private
//
//  DMPUB_NUP_DIRECTION - Private
//
//  DMPUB_MANUAL_DUPLEX - Private
//
//  DMPUB_STAPLE        - Private
//
// When common UI is called for the 'Document Properties' (DEVMODE), it will
// group some of public items together simillar to the following in the
// treeview. How it group is common UI version dependent and caller should not
// concern its placement
//
//      Paper/Output                (Add in by the common UI)
//        Document Form             (DMPUB_FORMNAME)
//        Output Bin                (DMPUB_OUTPUTBIN)
//        Orientation               (DMPUB_ORIENTATION)
//        Source                    (DMPUB_DEFSOURCE)
//        Media                     (DMPUB_MEDIATYPE)
//        Number of Copies          (DMPUB_COPIES_COLLATE)
//        Page Order                (DMPUB_PAGEORDER)
//        Page Per Sheet            (DMPUB_NUP)
//        Duplex                    (DMPUB_DUPLEX)
//
//      Graphic                     (Add in by the common UI)
//        Print Quality             (DMPUB_PRINTQUALITY)
//        Quality Settings          (DMPUB_QUALITY)
//        Color                     (DMPUB_COLOR)
//          Image Color Matching    (Add in by the common UI)
//              ICM Method          (DMPUB_ICMMETHOD)
//              ICM Intent          (DMPUB_ICMINTENT)
//        Scaling                   (DMPUB_SCALE)
//        Dithering                 (DMPUB_DITHERTYPE)
//        TrueType Option           (DMPUB_TTOPTION)
//
//      Options
//        Halftone Color Adjustment...
//        ALL Other Caller's Document sticky options
//
//
//  For 'Document Properties' the standard page 1 (user friendly page) will
//  consist following items if it appear in the OPTITEM array passed by the
//  caller.   These items must have following predefined TVOT_xxx type
//  defined here and specified in the OPTTYPE's Type field.
//
//  All DMPUB_xxx (except >= DMPUB_USER) public ID must have following
//  TVOT_xxxx type specified, else a CPDU_INVALID_DMPUB_TVOT error is returned
//
//      DMPUB_ORIENTATION       - TVOT_2STATES/TVOT_3STATES
//      DMPUB_SCALE             - TVOT_UDARROW
//      DMPUB_COPIES_COLLATE    - TVOT_UDARROW + EXTCHKBOX (Collate)
//      DMPUB_DEFSOURCE         - TVOT_LISTBOX
//      DMPUB_PRINTQUALITY      - TVOT_LISTBOX
//      DMPUB_COLOR             - TVOT_2STATES
//      DMPUB_DUPLEX            - TVOT_2STATES/TVOT_3STATES
//      DMPUB_TTOPTION          - TVOT_LISTBOX
//      DMPUB_FORMNAME          - TVOT_LISTBOX
//      DMPUB_ICMMETHOD         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_ICMINTENT         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_MEDIATYPE         - TVOT_LISTBOX
//      DMPUB_DITHERTYPE        - TVOT_LISTBOX
//
//


#define OIEXTF_ANSI_STRING      0x0001

typedef struct _OIEXT {
    WORD        cbSize;
    WORD        Flags;
    HINSTANCE   hInstCaller;
    LPTSTR      pHelpFile;
    ULONG_PTR   dwReserved[4];
    } OIEXT, *POIEXT;

//
// OIEXT is a data structure used as extension to the OPTITEM data structure
//
//
//  cbSize      - sizeof this structure
//
//  Flags       - One or more of OIEXTF_xxxx may be specified.
//
//                  OIEXTF_ANSI_STRING
//
//                      Specified that LPTSTR in this data structure is a ansi
//                      string (not UNICODE).  This bit only checked if the
//                      LPTSTR is not the resource string ID
//
//  hInstCaller - DLL instance handle, when this hInst is not NULL then all
//                resource string and icon loading for this OPTITEM and its
//                OPTTYPE, OPTPARAM are loaded from this hInstCaller Handle.
//                If this filed is NULL then it will use the hInstCaller handle
//                specified in the COMPROPSHEETUI data structure
//
//  pHelpFile   - Resource string ID or pointer to the help file for this
//                OPTITEM.  If this pointer is NULL then help file for the
//                help index is assume specified in the pHelpFile field in the
//                COMPROPSHEETUI data structure.
//
//  dwReserved  - These fields are not used now, and must 0
//


typedef struct _OPTITEM {
    WORD        cbSize;                 // size of this structure
    BYTE        Level;                  // level in the tree view
    BYTE        DlgPageIdx;             // Index to the pDlgPage
    DWORD       Flags;                  // OPTIF_xxxx flags
    ULONG_PTR   UserData;               // caller's own data
    LPTSTR      pName;                  // name of the item
    union {
        LONG    Sel;                    // current selection (index)
        LPTSTR  pSel;                   // current selection (pStr)
        } DUMMYUNIONNAME;
    union {
        PEXTCHKBOX  pExtChkBox;         // Pointer to EXTCHKBOX structure
        PEXTPUSH    pExtPush;           // Pointer to EXTPUSH
        } DUMMYUNIONNAME2;
    POPTTYPE    pOptType;               // pointer to OPTTYPE structure
    DWORD       HelpIndex;              // Help file index
    BYTE        DMPubID;                // Devmode public filed ID
    BYTE        UserItemID;             // caller's own item ID
    WORD        wReserved;              // reserved WORD field, must be 0
    POIEXT      pOIExt;                 // Optitem extension pointer
    ULONG_PTR   dwReserved[3];          // reserved DWORD fields (must be 0)
    } OPTITEM, *POPTITEM;

//
// OPTITEM is to describe each treeview item's name, selection type and
// possible selection
//
//  cbSize          - sizeof this structure
//
//  Level           - The level in the treeview, the root should have lowest
//                    number and number should start with level 0.  the maximum
//                    number of levels are 256.
//
//  DlgPageIdx      - Zero-based index to the DLGPAGE araay pointee by
//                    pDlgPage. The Maximum index is MAX_DLGPPAGE_COUNT, if
//                    pDlgPage is a standard CPSUI_PDLGPAGE_xxxx then this
//                    field is automatically set the common UI
//
//  Flags           - OPTIF_xxxx flags as describe above
//
//                      OPTIF_COLLAPSE
//
//                          Collaspe treeview item and its children so it is
//                          not expanded initially.
//
//
//                      OPTIF_HIDE
//
//                          Hide this item from the treeview
//
//
//                      OPTIF_CALLBACK
//
//                          Callback to the caller when user making some
//                          changes a pointer (pfnCallBack) must provided and
//                          process as defined by the common UI.
//
//
//                      OPTIF_CHANGED
//
//                          This item was changed and need to re-display. this
//                          flag only used when caller returned from callback
//                          funciton.
//
//
//                      OPTIF_CHANGEONCE
//
//                          This item has been changed at least once.
//
//
//                      OPTIF_DISABLED
//
//                          Disable this item so it become not selectable.
//
//
//                      OPTIF_ECB_CHECKED
//
//                          Specified the associated extended check box is
//                          in checked state.
//
//
//                      OPTIF_EXT_HIDE
//
//                          Hide the extended check box/extended push botton.
//
//
//                      OPTIF_EXT_DISABLED
//
//                          The Extended check box/push botton is disabled and
//                          not selectable
//
//
//                      OPTIF_SEL_AS_HICON
//
//                          This flag only used if this item has no type,
//                          pOptType=NULL that is, when pOptType is NULL then
//                          'Sel' field is the IconID. if flag is set then it
//                          indicate 'pSel' is the Icon handle rather
//                          than the icon resource ID specified in Sel.
//
//
//                      OPTIF_EXT_IS_EXTPUSH
//
//                          Specified that pExtPush should be used when this
//                          pointer is not NULL, if this pointer is not NULL
//                          and this flag is clear then pExtChkBox is assumed.
//
//
//                      OPTIF_NO_GROUPBOX_NAME
//
//                          Specified that do not overwrite the group box title
//                          text, if group box ID is defined. See the TVOT_xx
//                          description above.
//
//
//                      OPTIF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's
//                          IDI_CPSUI_WARNING icon.  This bit only used if this
//                          item has no type, pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_STOP
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_NO_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_NO
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_INITIAL_TVITEM
//
//                          Specified that this item will be the initial item
//                          to be selected and display on the treeview page.
//                          If the selected item is currently a child or
//                          collapse then common UI will expand the selection
//                          then scroll it into view.
//
//                          If this flag is clear or the set item is in hide
//                          status common UI will pick the initial item to
//                          display.
//
//                      OPTIF_HAS_POIEXT
//
//                          Specified that pOIExt field is a valid pointer that
//                          points to OIEXT data structure.  The pOIExt only
//                          used by the common UI if this bit is set.
//
//
//  UserData        - a 32-bit number used by the caller and common UI will not
//                    modify it.
//
//  pName           - Pointer to the item's name, such as 'Upper Tray',
//                    'Memory' or it is used as data as describe in
//                    OPTPARAM/OPTTYPE structure
//
//                      ** See LPTSTR description above
//
//  pSel
//  Sel             - Current selection for this item. This is a union field
//                    which can be a pointer to a string or a LONG index
//                    selection.
//
//                      ** If pOptType field is NULL then 'Sel' is the icon ID
//                         to be used for the header.
//
//  pExtPush
//  pExtChkBox      - Pointer to either EXTPUSH or EXTCHKBOX data structure,
//                    if this pointer is NULL then this item does not have
//                    ectended check box/push botton associate with it.
//
//                    When an extended check box is associate with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH must not set, the
//                    OPTIF_ECB_CHECKED flag specified if the extended check
//                    box is checked or not checked.
//
//                    When an Extended push botton is associated with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH flag must set.
//
//                    The following flags are used in both EXTCHKBOX or
//                    EXTPUSH
//
//                      OPTIF_EXT_HIDE,
//                      OPTIF_EXT_DISABLED
//                      OPTIF_EXT_CHANGEONCE
//
//
//  pOptType        - Pointer to the OPTTYPE structure to describe the display
//                    and selections of the item.   If this pointer is NULL
//                    then this this item does not have any selection. and it
//                    is used as sub-items' header.
//
//                      * When pOptType is NULL then the 'Sel' is the Icon ID.
//
//
//  HelpIndex       - a index to the help file for context sensitive help
//                    if HelpInex=0 then there is no help for this item
//
//  DMPubID         - specified if this item is one of the public fields in the
//                    DEVMODE structure and supported by the common UI.
//
//                      DMPUB_NONE              - Not DEVMODE public fields
//                      DMPUB_ORIENTATION       - dmOrientation
//                      DMPUB_SCALE             - dmScale
//                      DMPUB_COPIES_COLLATE    - dmCopies/dmCollate
//                      DMPUB_DEFSOURCE         - dmDefSource
//                      DMPUB_PRINTQUALITY      - dmPrintQuality
//                      DMPUB_COLOR             - dmColor
//                      DMPUB_DUPLEX            - dmDuplex
//                      DMPUB_TTOPTION          - dmTTOption
//                      DMPUB_FORMNAME          - dmFormName
//                      DMPUB_ICMMETHOD         - dmICMMethod
//                      DMPUB_ICMINTENT         - dmICMIntent
//                      DMPUB_MEDIATYPE         - dmMediaType
//                      DMPUB_DITHERTYPE        - dmDitherType
//
//                      ** for most of DMPUB_FIRST to DMPUB_LAST each OPTITEM's
//                         pName is automatically set to the standard
//                         IDS_CPSUI_xxx for the consistancy reason, the
//                         standard pName is set according to following table.
//
//                          DMPUB_ORIENTATION    - IDS_CPSUI_ORIENTATION
//                          DMPUB_SCALE          - IDS_CPSUI_SCALING
//                          DMPUB_COPIES_COLLATE - IDS_CPSUI_COPIES
//                          DMPUB_DEFSOURCE      - IDS_CPSUI_SOURCE
//                          DMPUB_PRINTQUALITY   - IDS_CPSUI_PRINTQUALITY
//                                                 IDS_CPSUI_RESOLUTION
//                          DMPUB_COLOR          - IDS_CPSUI_COLOR_APPERANCE
//                          DMPUB_DUPLEX         - IDS_CPSUI_DUPLEX
//                          DMPUB_TTOPTION       - IDS_CPSUI_TTOPTION
//                          DMPUB_FORMNAME       - IDS_CPSUI_FORMNAME
//                          DMPUB_ICMMETHOD      - IDS_CPSUI_ICMMETHOD
//                          DMPUB_ICMINTENT      - IDS_CPSUI_ICMINTENT
//                          DMPUB_MEDIATYPE      - IDS_CPSUI_MEDIA
//                          DMPUB_DITHERTYPE     - IDS_CPSUI_DITHERING
//
//                          for DMPUB_PRINTQUALITY, if the pName is not one of
//                          IDS_CPSUI_PRINTQUALITY or IDS_CPSUI_RESOLUTION then
//                          common UI will automatically default the pName to
//                          IDS_CPSUI_RESOLUTION.
//
//                          Each pData (OPTPARAM) selection in OPTPARAM which
//                          OPTITEM's pOptType pointed to should use as much
//                          as IDS_CPSUI_xxx standard name as possible.
//
//
//                      ** for DMPUB_COPIES_COLLATE the common UI automatically
//                         doing the following before the callback
//
//                          1) Enable/Disable the collate extended check box if
//                             OPTIF_EXT_HIDE is not specified and pExtChkBox
//                             is not NULL in the OPTITEM.
//
//                          2) Automatically change the postfix for this item
//                             to be 'Copy' if selection is one, and 'Copies'
//                             if selection is greater than one in the treeview
//                             page, and it will also set the postfix in
//                             standard document property page if the postfix
//                             ID is provided (BegCtrlID + 4)
//
//
//                      ** for DMPUB_COLOR the common UI automatically doing
//                         the following before the callback, the gray
//                         selection must be Sel=0 and Color slection must be
//                         Sel=1
//
//                          1) Calling halftone color adjustment with current
//                             color/mono selection
//
//                          2) Disable ICM when color is not selected
//
//
//                      ** Please see above DMPUB_xx description for details.
//
//  UserItemID      - This is a byte ID intented to be used by the caller to
//                    identify the item
//
//  wReserved       - WORD reserved. Must be zero
//
//  pOIExt          - Pointer to the OIEXT data structure to specified that
//                    it has a OPTITEM extenstion structure.
//
//  dwReserved[]    - DWORD reserved and must be 0
//
//

//
// predefined ID for call back reason
//

#define CPSUICB_REASON_SEL_CHANGED      0
#define CPSUICB_REASON_PUSHBUTTON       1
#define CPSUICB_REASON_ECB_CHANGED      2
#define CPSUICB_REASON_DLGPROC          3
#define CPSUICB_REASON_UNDO_CHANGES     4
#define CPSUICB_REASON_EXTPUSH          5
#define CPSUICB_REASON_APPLYNOW         6
#define CPSUICB_REASON_OPTITEM_SETFOCUS 7
#define CPSUICB_REASON_ITEMS_REVERTED   8
#define CPSUICB_REASON_ABOUT            9
#define CPSUICB_REASON_SETACTIVE        10
#define CPSUICB_REASON_KILLACTIVE       11


//
// predefined ID for call back action
//

#define CPSUICB_ACTION_NONE             0
#define CPSUICB_ACTION_OPTIF_CHANGED    1
#define CPSUICB_ACTION_REINIT_ITEMS     2
#define CPSUICB_ACTION_NO_APPLY_EXIT    3
#define CPSUICB_ACTION_ITEMS_APPLIED    4


typedef struct _CPSUICBPARAM {
    WORD        cbSize;             // size of this structure
    WORD        Reason;             // CPSUICB_REASON_XXXXX callback reason
    HWND        hDlg;               // handle of the dialog box
    POPTITEM    pOptItem;           // pOptItem field from COMPROPSHEETUI
    WORD        cOptItem;           // cOptItem field from COMPROPSHEETUI
    WORD        Flags;              // flags field from COMPROPSHEETUI
    POPTITEM    pCurItem;           // current selected item of callback
    union {
        LONG    OldSel;             // Last selection (index)
        LPTSTR  pOldSel;            // Last selection (pStr)
        } DUMMYUNIONNAME;
    ULONG_PTR   UserData;           // UserData in the COMPROPSHEETUI struct.
    ULONG_PTR   Result;             // OUT parameter for the APPLYNOW
    } CPSUICBPARAM, *PCPSUICBPARAM;


typedef LONG (APIENTRY *_CPSUICALLBACK)(PCPSUICBPARAM pCPSUICBParam);
#define CPSUICALLBACK   LONG APIENTRY


//
// CPSUICBPARAM is used when commom UI callback to the caller, this structure
// describe the nature of callback and passed all necessary parameter for the
// caller to make changes in the pOptItem and passed an action back to the
// commom UI to redisplay the tree or page 1 data
//
//
//  cbSize      - must be CPSUICBPARAM
//
//  Reason      - defined the nature of the callback
//
//                  CPSUICB_REASON_SEL_CHANGED
//
//                      User make change to the pCurItem.  if the item is
//                      DMPUB_COPIES_COLLATE then common UI automatically
//                      change the collate extended check box without callback
//                      to the caller of the extended check box changes
//
//
//                  CPSUICB_REASON_PUSHBUTTON
//
//                      User push the push button and push button item is set
//                      to PUSHBUTTON_TYPE_CALLBACK.
//
//
//                  CPSUICB_REASON_ECB_CHANGED
//
//                      User make change to the extended checked box (i.e. it
//                      eiterh checked or not checked) EXTCHKBOX in the
//                      pCurItem passed in the call back parameter.
//
//
//                  CPSUICB_REASON_DLGPROC
//
//                      The callback reason is PUSHBUTTON_TYPE_DLGPROC
//
//
//                  CPSUICB_REASON_UNDO_CHANGES
//
//                      This callback currently is not implmented.
//
//
//                  CPSUICB_REASON_EXTPUSH
//
//                      The callback is result of user push the extend push
//                      button.
//
//
//                  CPSUICB_REASON_APPLYNOW
//
//                      The user press the apply now button. Durning callback
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the active DlgPageIdx
//                      (compare to the OPTITEM's DlgPageIdx) which the page
//                      user hitting the apply now button if the page is
//                      non-treeview page, otherwise the 'OldSel' is set to -1
//                      (for treeview page) to indicate all valid item should
//                      be apply now, if the callback return
//                      CPSUICB_ACTION_NONE then the common UI will exit the
//                      property sheet and returned CPSUI_OK back to the
//                      caller, and if the callback function returned
//                      CPSUICB_ACTION_NO_APPLY_EXIT then common UI will not
//                      exit the property sheet and callback function must
//                      pop-up messages dialog box to tell user why it cannot
//                      exist the property sheet until certain action is take
//                      by the user.
//
//
//                  CPSUICB_REASON_OPTITEM_SETFOCUS
//
//                      This callback reason is used when an OPTITEM is getting
//                      the keyboard focus. and give the callback function a
//                      chance to examine the item.
//
//
//                  CPSUICB_REASON_ITEMS_REVERTED
//
//                      This callback reason is used when user changed items
//                      and decided to revert changes from the parent item in
//                      the treeview.  The callback funciton is called after
//                      all revertable items are reverted to its original.
//
//                      The CPSUICBPARAM's pCurItem is same as pOptItem and
//                      'OldSel' field is same as cOptItem field.  for each of
//                      reverted item, the OPTIF_CHANGED bit will be set in the
//                      OPTITEM by the common UI to indicate the item is revert
//                      by the common UI.   The callback function MUST NOT
//                      reset this bit if it is set.
//
//
//                  CPSUICB_REASON_ABOUT
//
//                      This callback reason is used when user hit 'About...'
//                      push button in the treeview page, and the flag
//                      CPSUIF_ABOUT_CALLBACK is set.  The pCurItem is set to
//                      same as pOptItem and 'pOldSel' is a pointer pointed to
//                      original copy of COMPROPSHEETUI data structure which
//                      passed to the common UI.
//
//
//                  CPSUICB_REASON_SETACTIVE
//                  CPSUICB_REASON_KILLACTIVE
//
//                      The current property sheet is gaining or loosing focus,
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the current active
//                      DlgPageIdx (compare to the OPTITEM's DlgPageIdx).
//                      if the page is non-treeview page, otherwise the
//                      'OldSel' is set to -1 (for treeview page).
//
//  hDlg        - The handle to the dialog box (Properties page TAB) current
//                active for the callback.
//
//                Durning the callback the caller must not change the
//                DWLP_USERDATA on hDlg, otherwise the common UI will be crash.
//                If callback function need to get/set DWLP_USERDATA it should
//                call common UI's SetCPSUIUserData() and GetCPSUIUserData()
//                functions instead.
//
//  pCurItem    - Pointed to POPTITEM which the callback is generated for.
//
//  pOldSel
//  OldSel      - The last OPTITEM's pSel/Sel field before the change was made
//                by the user.  The pOldSel/OldSel only valid if the callback
//                reason is CPSUICB_REASON_SEL_CHANGED, this give the callback
//                function a chance to check against the previous item
//                selection.  This is a union field which can be a pointer to
//                a string or a LONG index selection.
//
//  UserData    - a 32-bit user defined data in the COMPROPSHEETUI structure,
//                commom UI will not changed it.
//
//  Result      - When the reason is CPSUICB_REASON_APPLYNOW, the callback
//                function MUST set the requested result for the caller into
//                'Result' field when it returned a value other than the
//                CPSUICB_ACTION_NO_APPLY_EXIT and common UI will send the
//                'Result' field value to this page's parent.
//
//                The called function should save the current result of
//                pOptItem.  The default 'Result' is set to CPSUI_OK (1) from
//                common UI.  This function can alter this result before it
//                return back to to the common UI.
//
//
//  Return Values:
//
//      CPSUICB_ACTION_NONE             - No action need to be take by the
//                                        common UI.
//
//      CPSUICB_ACTION_OPTIF_CHANGED    - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-display because of OPTITEM's Flags
//                                        field changed or item's selection
//                                        changed.   This is different from
//                                        CPSUICB_ACTION_REINIT_ITEMS which
//                                        it assume OPTTYPE or OPTPARAM data
//                                        also changed.
//
//
//      CPSUICB_ACTION_REINIT_ITEMS     - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-initialized in the dilaog box
//                                        control.  This happened if item's
//                                        OPTTYPE or OPTPARAMs flag/pdata
//                                        changed.
//
//
//      CPSUICB_ACTION_NO_APPLY_EXIT    - This return value only valid durning
//                                        CPSUICB_REASON_APPLYNOW callback
//                                        reason, it tell common UI it has
//                                        some constraints in its OPTITEM which
//                                        must correct or confirm by the user
//                                        before exit.  The callback function
//                                        must display and/or have user taking
//                                        some actions before return this
//                                        action to the common UI
//
//      CPSUICB_ACTION_ITEMS_APPLIED    - When responsed to the
//                                        CPSUICB_REASON_APPLYNOW, if the
//                                        returned action is
//                                        CPSUICB_ACTION_ITEMS_APPLIED then
//                                        common UI will reset OPTIF_CHANGEONCE
//                                        bit and save the new default for the
//                                        future undo operations.
//
//

#define DP_STD_TREEVIEWPAGE             0xFFFF
#define DP_STD_DOCPROPPAGE2             0xFFFE
#define DP_STD_DOCPROPPAGE1             0XFFFD
#define DP_STD_RESERVED_START           0xFFF0

#define MAX_DLGPAGE_COUNT               64

#define DPF_ICONID_AS_HICON             0x0001
#define DPF_USE_HDLGTEMPLATE            0x0002

typedef struct _DLGPAGE {
    WORD        cbSize;         // size of this structure
    WORD        Flags;          // DPF_xxxx flags
    DLGPROC     DlgProc;        // caller's dialog box subclass procedue
    LPTSTR      pTabName;       // pointer to the tab name
    ULONG_PTR   IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;  // dialog box template ID
        HANDLE  hDlgTemplate;   // handle to the dialog template
        } DUMMYUNIONNAME;
    } DLGPAGE, *PDLGPAGE;


//
// DLGPAGE structure describe non-treeview page characteristics
//
//
//  cbSize          - size of this structure
//
//  Flags           - DPF_xxxx flags
//
//                      DPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID
//
//
//  DlgProc         - caller's supplied DLGPROC for sub-class the page
//                    dialog box processing,
//
//                    if DlgProc is not NULL then common UI do the following
//                    according the the message received except for the
//                    DP_STD_xxx pages
//
//
//                      WM_INITDIALOG
//
//                          Common UI initialize the dialog box and then call
//                          DlgProc(WM_INITDIALOG) the DlgProc should return
//                          exactly the behavior for the WM_INITDIALOG
//
//                          The lParam in the WM_INITDIALOG data structure is
//                          a pointer to the PROPSHEETPAGE data structure.
//
//                          the lParam field in the PROPSHEETPAGE (lParam
//                          passed to the WM_INITDIALOG) is the UserData
//                          defined in COMPROPSHEETUI data structure
//
//                          To access to the PSPINFO data structure which
//                          associate with this page, use the common UI macro
//                          PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) where
//                          lParam is the parameter passed to the
//                          WM_INITDIALOG message.
//
//                          The subclass function should save these pointers
//                          for its later use, but it MUST NOT modified the
//                          content of the PSPINFO data structure or system
//                          may crashed.
//
//
//                      OTHER DIALOG MESSAGES
//
//                          Iit call DlgProc() and if it returned the value is
//                          non-zero then common UI assume DlgProc() processed
//                          the message and will not process this message.
//
//                          If the returned vlaue from DlgProc() is zero then
//                          common UI will process this message.
//
//
//                      * Durning the DlgProc the caller must not change the
//                        DWLP_USERDATA on hDlg, otherwise the common UI will
//                        be crash.  If caller need to get/set DWLP_USERDATA it
//                        should call common UI's SetCPSUIUserData() and
//                        GetCPSUIUserData() instead.
//
//  pTabName        - Pointer to a string to describe the TAB title
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    DPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - The template id to be use for the ProPage, it can be
//                    one of DP_STD_xxxx, the DP_STD_xxx has 240 x 240 dialog
//                    box units.
//
//
//                      DP_STD_TREEVIEWPAGE
//
//                          Specified that this page is a standard treeview
//                          page provided by the common ui.  The treeview page
//                          is a page using treeview display all valid OPTITEM
//                          passed to the common UI.  User can modify every
//                          valid selectable OPTITEM from the treeview page.
//
//                      DP_STD_DOCPROPPAGE
//
//                          Specified that this page is a standard document
//                          property page provided by the common UI
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//
//  wReserved[]
//  dwReserved[]    - Reserved fields, must be 0
//
//
//  ** Tips of designing the dialog box controls
//
//      When designing the dialog box controls, each OPTITEM is correspoonds
//      to one input control plus one extended check box or extended push
//      button.  Since common UI will automatically disable and remove
//      OPTIF_HIDE items item from the property sheet and dynamically move
//      other controls, the following tips of designing the dialog box controls
//      should follow.
//
//      * Each item should have one input control plus optional of extended
//        check box/push botton, one icon control and other static controls
//
//      * Each item should occupied whole horizontal spaces of the property
//        sheet, items must not overlay in vertical direction.
//
//      * for TVOT_2STATES, TVOT_3STATES, if it araange radio buttons from
//        left to right in state order (ie. from first state's OPTPARAM to
//        last state's OPTPARAM) then the radio buttons and icons should
//        aligned in the Y coordinate.    If it arrange radio buttons from top
//        to bottom (ie. from first state's OPTPARAM to last state's OPTPARAM)
//        then the radio buttons and icons should aligned in the X coordinate.
//
//        common UI will automatically hide/move the radio buttons to compact
//        the dialog box controls.  If radio buttons/icons are arranged in
//        top/down order and there is other controls obscure in Y direction
//        then radio buttons will only be re-arranged but not remove any white
//        spaces in Y direction.
//
//      * If multiple items shared one group box, then the group box must
//        belongs to the first item (topmost in the dialog box group) in the
//        group, the group box must large enough to cover all the items in
//        side the group box.
//
//


#define CPSUIF_UPDATE_PERMISSION        0x0001
#define CPSUIF_ICONID_AS_HICON          0x0002
#define CPSUIF_ABOUT_CALLBACK           0x0004

#define CPSUI_PDLGPAGE_DOCPROP          (PDLGPAGE)1
#define CPSUI_PDLGPAGE_ADVDOCPROP       (PDLGPAGE)2
#define CPSUI_PDLGPAGE_PRINTERPROP      (PDLGPAGE)3
#define CPSUI_PDLGPAGE_TREEVIEWONLY     (PDLGPAGE)4

//
// For compatible misspelling #define
//

#define CPSUI_PDLGPAGE_TREEVIWONLY      CPSUI_PDLGPAGE_TREEVIEWONLY

typedef struct _COMPROPSHEETUI {
    WORD            cbSize;             // size of this structure
    WORD            Flags;              // CPSUIF_xxxx flags
    HINSTANCE       hInstCaller;        // caller's hInstance
    LPTSTR          pCallerName;        // pointer to the caller's name
    ULONG_PTR       UserData;           // caller's own data
    LPTSTR          pHelpFile;          // pointer to the help file
    _CPSUICALLBACK  pfnCallBack;        // callback function pointer
    POPTITEM        pOptItem;           // pointer to POPTITEM array
    PDLGPAGE        pDlgPage;           // pointer to the DLGPAGE array
    WORD            cOptItem;           // count of pOptItem array
    WORD            cDlgPage;           // count of pDlgPage array
    ULONG_PTR       IconID;             // icon to be used
    LPTSTR          pOptItemName;       // pointer to the optitem's data name
    WORD            CallerVersion;      // version for the caller apps
    WORD            OptItemVersion;     // version for the optitem name
    ULONG_PTR       dwReserved[4];      // reserved, must be 0
    } COMPROPSHEETUI, *PCOMPROPSHEETUI;


//
// COMPROPSHEETUI data structure is used when calling common UI to display dialog
// box of properties pages.
//
//
//  Size                - Must be sizeof (COMPROPSHEETUI)
//
//  Flags               - can be one or more of following
//
//                          CPSUIF_UPDATE_PERMISSION
//
//                              Specified the any valid pOptItem items are
//                              changeable by the user.
//
//
//                          CPSUIF_ICONID_AS_HICON
//
//                              If this flag is set then IconID DWORD field is
//                              treated as a handle to the icon rather then the
//                              resource ID
//
//
//                          CPSUIF_ABOUT_CALLBACK
//
//                              If this flag bit is set, then when user hit
//                              'About...' button in the treeview tab, it will
//                              call the callback function with a reason of
//                              CPSUICB_REASON_ABOUT, and callback MUST handle
//                              the about which pop-up dialog box to show user
//                              the information about the caller and OPTITEMs.
//
//                              If this bit is not set then common UI will call
//                              the ShellAbout() with formatted caller Name and
//                              pOptItemName with version numbers.
//
//
//  hInstCaller         - the caller's handle to its instance.  Commom UI use
//                        this handle to load caller's icon and other resources.
//
//  pCallerName         - Pointer to the caller's NULL terminated caller's
//                        name, most time this is driver's name,
//                        such as 'Postscript Driver'
//
//  UserData            - a 32-bit number used by the caller and common UI will
//                        not modify it.  this 32-bit number is passed back to
//                        the caller durning the callback function
//
//  pHelpFile           - specified a standard microsoft help file (path/file)
//                        for using in the common UI.  in OPTITEM specified
//                        HelpIndex for help in each item.
//
//  pfnCallBack         - Pointer to _CPSUICALLBACK callback function.  Common
//                        UI only callback to the caller if an OPTIF_CALLBACK
//                        is set OPTITEM data structure's flag fields and the
//                        item selection is changed by the user.
//
//  pOptItem            - Pointer to array of OPTITEM structure to be displayed
//                        by the common UI
//
//  pDlgPage            - Pointer to array of DLGPAGE structure to describe
//                        each property sheet page infomation, the following
//                        are the standard common ui DLGPAGEs.  When specified
//                        CPSUI_PDLGPAGE_xxxx, the common UI will automatically
//                        modify DlgPageIdx field in the OPTITEM, caller must
//                        set the iStartPage correctly.
//
//                          CPSUI_PDLGPAGE_DOCPROP
//
//                              specified this a common ui standard document
//                              property sheets. This includes two property
//                              sheets, 1) Page Setup 2) Advance (TreeView)
//
//
//                          CPSUI_PDLGPAGE_ADVDOCPROP
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page with tab of 'Advance'
//
//
//                          CPSUI_PDLGPAGE_PRINTERPROP
//
//                              Specified this is a common UI standard printer
//                              property sheet.  This only has one treeview
//                              page with tab of 'Device Options'
//
//
//                          CPSUI_PDLGPAGE_TREEVIEWONLY
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page
//
//
//
//  cOptItem            - Count of OPTITEM pointed by the pOptItem above
//
//  cDlgPage            - Count of DLGPAGE pointed by the pDlgPage.  If
//                        pDlgPage is one of the CPSUI_PDLGPAGE_xxxx then this
//                        field is ignored by the common UI.
//
//  IconID              - This is the icon identifier, which can be a common
//                        strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                        resource ID, or a handle to the caller defined icon
//                        if CPSUIF_ICONID_AS_HICON flag is set, in any case
//                        if the IconID is zero then it indicated no icon.
//
//  pOptItemName        - Pointer to the pOptItem data NULL terminated name,
//                        most time this is device name, such as 'HP 4si'
//
//  CallerVersion       - Version for the caller, the HIBYTE(CallerVersion) is
//                        the major version, and LOBYTE(CallerVersion) is the
//                        minor version, such as 0x310 display as 3.16, 0x3ff
//                        display as 3.255 and 0x30a display as 3.10
//
//  OptItemVersion      - Version for the OPTITEM's data, the
//                        HIBYTE(OptItemVersion) is the major version, and
//                        LOBYTE(OptItemVersion) is the minor version, such as
//                        0x310 display as 3.16, 0x3ff display as 3.255 and
//                        0x30a display as 3.10.
//
//  dwReserved[4]       - reserved fields, must be 0
//
//
//  ** pTitlee and TitleBarIcon only used if CommonPrinterPropSheetUI()
//     is the last one the Property sheet UI chain and call the PropertySheet()
//
//


#define CPSFUNC_ADD_HPROPSHEETPAGE          0
#define CPSFUNC_ADD_PROPSHEETPAGEW          1
#define CPSFUNC_ADD_PCOMPROPSHEETUIA        2
#define CPSFUNC_ADD_PCOMPROPSHEETUIW        3
#define CPSFUNC_ADD_PFNPROPSHEETUIA         4
#define CPSFUNC_ADD_PFNPROPSHEETUIW         5
#define CPSFUNC_DELETE_HCOMPROPSHEET        6
#define CPSFUNC_SET_HSTARTPAGE              7
#define CPSFUNC_GET_PAGECOUNT               8
#define CPSFUNC_SET_RESULT                  9
#define CPSFUNC_GET_HPSUIPAGES              10
#define CPSFUNC_LOAD_CPSUI_STRINGA          11
#define CPSFUNC_LOAD_CPSUI_STRINGW          12
#define CPSFUNC_LOAD_CPSUI_ICON             13
#define CPSFUNC_GET_PFNPROPSHEETUI_ICON     14
#define CPSFUNC_ADD_PROPSHEETPAGEA          15
#define CPSFUNC_INSERT_PSUIPAGEA            16
#define CPSFUNC_INSERT_PSUIPAGEW            17
#define CPSFUNC_SET_PSUIPAGE_TITLEA         18
#define CPSFUNC_SET_PSUIPAGE_TITLEW         19
#define CPSFUNC_SET_PSUIPAGE_ICON           20
#define CPSFUNC_SET_DATABLOCK               21
#define CPSFUNC_QUERY_DATABLOCK             22
#define CPSFUNC_SET_DMPUB_HIDEBITS          23
#define CPSFUNC_IGNORE_CPSUI_PSN_APPLY      24
#define CPSFUNC_DO_APPLY_CPSUI              25

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define CPSFUNC_SET_FUSION_CONTEXT          26
#define MAX_CPSFUNC_INDEX                   26
#else
#define MAX_CPSFUNC_INDEX                   25
#endif

#ifdef UNICODE
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIW
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIW
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGW
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEW
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEW
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEW

#else
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIA
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIA
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGA
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEA
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEA
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEA

#endif

//
// for the CPSFUNC_SET_RESULT
//

#define SR_OWNER            0
#define SR_OWNER_PARENT     1

typedef struct _SETRESULT_INFO {
    WORD        cbSize;
    WORD        wReserved;
    HANDLE      hSetResult;
    LRESULT     Result;
    } SETRESULT_INFO, *PSETRESULT_INFO;

//
// This is for CPSFUNC_INSERT_PSUIPAGE
//

#define HINSPSUIPAGE_FIRST              (HANDLE)0xFFFFFFFE
#define HINSPSUIPAGE_LAST               (HANDLE)0xFFFFFFFF
#define HINSPSUIPAGE_INDEX(i)           (HANDLE)MAKELONG(i, 0);

#define PSUIPAGEINSERT_GROUP_PARENT     0
#define PSUIPAGEINSERT_PCOMPROPSHEETUI  1
#define PSUIPAGEINSERT_PFNPROPSHEETUI   2
#define PSUIPAGEINSERT_PROPSHEETPAGE    3
#define PSUIPAGEINSERT_HPROPSHEETPAGE   4
#define PSUIPAGEINSERT_DLL              5
#define MAX_PSUIPAGEINSERT_INDEX        5


#define INSPSUIPAGE_MODE_BEFORE         0
#define INSPSUIPAGE_MODE_AFTER          1
#define INSPSUIPAGE_MODE_FIRST_CHILD    2
#define INSPSUIPAGE_MODE_LAST_CHILD     3
#define INSPSUIPAGE_MODE_INDEX          4


typedef struct _INSERTPSUIPAGE_INFO {
    WORD        cbSize;
    BYTE        Type;
    BYTE        Mode;
    ULONG_PTR   dwData1;
    ULONG_PTR   dwData2;
    ULONG_PTR   dwData3;
    } INSERTPSUIPAGE_INFO, *PINSERTPSUIPAGE_INFO;


//
// for the CPSFUNC_SET_HSTARTPAGE
//

#define SSP_TVPAGE          10000
#define SSP_STDPAGE1        10001
#define SSP_STDPAGE2        10002

typedef LONG_PTR (CALLBACK *PFNCOMPROPSHEET)(HANDLE hComPropSheet,
                                             UINT   Function,
                                             LPARAM lParam1,
                                             LPARAM lParam2);


typedef struct _PSPINFO {
    WORD            cbSize;
    WORD            wReserved;
    HANDLE          hComPropSheet;
    HANDLE          hCPSUIPage;
    PFNCOMPROPSHEET pfnComPropSheet;
    } PSPINFO, *PPSPINFO;

//
// PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) macro retrieve a pointer to the
// PSPINFO data structure. the lParam must be the lParam passed to the
// WM_INITDIALOG, otherwise the system can failed
//

#define PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam)  \
                (PPSPINFO)((LPBYTE)lParam + ((LPPROPSHEETPAGE)lParam)->dwSize)

//
// PSPINFO
//
//  This structure is used durning property sheet page's WM_INITDIALOG message.
//  At WM_INITDIALOG, the lParam is a pointer to the PROPSHEETPAGE, and
//  lParam field in the PROPSHEETPAGE is a pointer to the PSPINFO.  the
//  original lParam in the PROPSHEETPAGE is saved in the lParam field in the
//  PSPINFO data structure.
//
//  When process WM_INITDIALOG message, it should save the lParam (PSPINFO
//  structure pointer) for later to call common UI callback functions.
//
//
//  cbSize          - Size of this structure in bytes
//
//  wReserved       - Reserved, must be set to zero
//
//  hComPropSheet   - Handle to the parent page which is the hComPropSheet
//                    passed to the CPSFUNC_ADD_PROPSHEETPAGE
//
//  hCPSUIPage      - Handle to the this added common UI property sheet page.
//
//  pfnComPropSheet - Pointer to the common UI callback function, using this
//                    function pointer to do CPSFUNC_xxxx
//
//

typedef struct _CPSUIDATABLOCK {
    DWORD   cbData;
    LPBYTE  pbData;
    } CPSUIDATABLOCK, *PCPSUIDATABLOCK;


#define APPLYCPSUI_NO_NEWDEF        0x00000001
#define APPLYCPSUI_OK_CANCEL_BUTTON 0x00000002

//
// PFNCOMPROPSHEET function descriptions
//
// For each function index, it passed a handle, a Function Index and two (2)
// long parameters, the 'hComPropSheet' handle passed must be the handle passed
// from common UI when common UI called the caller supplied function
//
// pfnPropSheetUI(pPropSheetUIData);
//
// Following are the description of each function index
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_HPROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using handle to the
//      PROPSHEETPAGE
//
//
//  Parameters:
//
//      lParam1 - is a handle to the PROPSHEETPAGE that created by the caller
//                using CreatePropertySheetPage()
//
//      lParam2 - Not used, must be 0
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using PROPSHEETPAGE
//      data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to PROPSHEETPAGE data structure
//
//      lParam2 - Not used.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PCOMPROPSHEETUI
//
//      This function add propety page(s) to the hComPropSheet handle using
//      COMPROPSHEETUI data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to COMPROPSHEETUI data structure
//
//      lParam2 - pointer to a 32-bit location that received the total pages
//                added by the COMPROPSHEETUI data structure if sucessful else
//                it contains the ERR_CPSUI_xxx error codes.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PFNPROPSHEETUI
//
//      This function add property page(s) to the hChild handle using
//      lParam1 as PFNPROPSHEETUI function pointer and lParam2 as the function
//      parameter.   The common UI call supplied function as following
//
//          PROPSHEETUI_INFO    PSUIInfo;
//
//          PSUIInfo.cbSize          = sizeof(PROPSHEETUI_INFO);
//          PSUIInfo.Version         = PROPSHEETUI_INFO_VERSION;
//          PSUIInfo.Flags           = (Ansi) ? 0: PSUIINFO_UNICODE;
//          PSUIInfo.Reason          = PROPSHEETUI_REASON_INIT;
//          PSUIInfo.hComPropSheet   = hComPropSheet;
//          PSUIInfo.pfnComPropSheet = ComPropSheetUICallBack;
//          PSUIInfo.lParamInit      = lParam2;
//          PSUIInfo.UserData        = 0;
//          PSUIInfo.Result          = 0;
//
//          ((PFNPROPSHEETUI)lParam1)(&PSUIInfo, lParam2);
//
//
//          If the pfnPropSheetUI() need to add/delete any common UI pages then
//          it must use hComPropSheet as its handle when calling the
//          ComPropSheetUICallBack().
//
//
//  Parameters:
//
//      lParam1 - a PFNPROPSHEETUI function pointer.
//
//      lParam2 - a 32-bit data that will be used as lParam when calling
//                PFNPROPSHEETUI function pointer.
//
//
//  Return Value:
//
//      The return value is the newly added property pages function handle, if
//      return value is NULL then function failed or no page is added.
//
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_DELETE_HCOMPROPSHEET
//
//      This function delete child property page(s) from hComPropSheet parent
//      using the child handle passed.
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be deleted.
//                This handle must be the handle returned from CPSFUNC_ADD_xxx
//                functions.
//
//      lParam2 - not used, must be 0
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PAGECOUNT
//
//      This function return total property sheet pages belongs to a common
//      UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - not used, must be 0
//
//      lParam2 - not used, must be 0.
//
//
//  Return Value:
//
//      The return value is total page count if function sucessful or zero if
//      function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_RESULT
//
//      This function set the result of property sheet page to its owner that
//      added this page by CPSFUNC_ADD_xxx function indices
//
//  Parameters:
//
//      lParam1 - Handle to the common UI property sheet page that setting the
//                result.  If this handle is NULL then it is treated as
//                equal to the hComPropSheet.
//
//      lParam2 - a 32-bit DWORD result to be set.
//
//
//  Return Value:
//
//      > 0: Successful, return value is total count of parents set the result
//      = 0: There is no owner or parent for the lParam1 handle.
//      < 0: function failed because of invalid lParam1 handle.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_HSTARTPAGE
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be set
//                as initial page that appear when the property sheet dialog
//                boxes is created.  This handle must be the handle returned
//                from CPSFUNC_ADD_xxx functions.
//
//                If lParam1 is NULL then lParam2 is a string pointer to the
//                page name (tab) that to be set for the start page
//
//      lParam2 - a LONG number to specified the children index. if lParam1
//                handle is a parent then lParam2 specified zero base children
//                index for using as start page.
//
//                It also can be one of following special index
//
//                  SSP_TVPAGE
//
//                      set to the treeview page, this only valid if lParam1
//                      handle was added by the CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//                  SSP_STDPAGE
//
//                      Set to the standard document property sheet page
//                      (Page 1 user friendly page).  this only valid if
//                      lParam1 handle was added by the
//                      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.  This function can only be
//      called when the property sheet is not display yet so the place to
//      call is during the PROPSHEETUI_REASON_GET_INFO_HEADER callback.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_HPSUIPAGES
//
//      This function return array of children HPROPSHEETPAGE belongs to
//      the parent hComPropSheet UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - Pointer to an array of HPROPSHEETPAGE that to be stored
//                the handle upon return.
//
//      lParam2 - Count of HPROPSHEETPAGE array pointed by the lParam1
//
//
//  Return Value:
//
//      The return value is total HPROPSHEETPAGE stored in the array pointed
//      by the lParam1.   To get all hPropSheetPage for any common property
//      sheet handle's (hCPSUIPage) children, it can use following sequence.
//
//          if ((cPage = pfnComPropSheet(hComPropSheet,
//                                       CPSFUNC_GET_PAGECOUNT,
//                                       (LPARAM)hCPSUIPage,
//                                       0L))   &&
//              (phPage = ALLOCMEM(cPage * sizeof(HANDLE)))) {
//
//              pfnComPropSheet(hCPSUIPage,
//                              CPSFUNC_GET_HPSUIPAGES,
//                              (LPARAM)phPage,
//                              (LPARAM)cPage);
//          }
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_STRING
//
//      This function load the common property sheet UI resource string
//
//  Parameters:
//
//      lParam1 - Pointer to LPTSTR string which will stored the loaded
//                resource string from the common property sheet UI DLL.
//
//      lParam2 - LOWORD(lParam2) = Count of characters (includes null
//                                  terminator) which pointed by the lParam1
//
//                HIWORD(lParam2) = Common property sheet UI predefined string
//                                  resource ID as IDS_CPSUI_xxxx
//
//
//  Return Value:
//
//      > 0: Total characters stored in the string pointed by the lParam1, this
//           is not includes the null terminator
//      = 0: Invalid IDS_CPSUI_xxx passed from HIWORD(lParam)
//      < 0: Either lParam1 is NULL or count of character is 0 from
//           LOWORD(lParam2)
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_ICON
//
//      This function load the common property sheet UI resource icon.
//
//  Parameters:
//
//      lParam1 - Common property sheet UI predefined icon resource ID as
//                IDI_CPSUI_xxxx.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PFNPROPSHEETUI_ICON
//
//      This function let the caller return hIcon of its children pages that
//      was added by CPSFUNC_ADD_PFNPROPSHEETUI
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the hIcon will be
//                queried.  This handle must be the handle returned from
//                CPSFUNC_ADD_PFNPROPSHEETUI function.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_INSERT_PSUIPAGE
//
//      This function let the caller insert common property sheet pages at
//      set position.  The hComPropSheet must be the parent handle.
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the page position
//                will be inserted.  This handle must be the handle returned
//                from previous CPSFUNC_ADD_xxx or CPSFUNC_INSERT_PSUIPAGE that
//                added or inserted using the hComPropSheet if the Mode field
//                in INSPSUIPAGE_INFO data structure is one of the follwing
//
//                  INSPSUIPAGE_MODE_BEFORE
//                  INSPSUIPAGE_MODE_AFTER      - Common UI page handle
//
//                  INSPSUIPAGE_MODE_INDEX      - the lParam1 is an zero based
//                                                child index.
//
//                  INSPSUIPAGE_MODE_FIRST_CHILD
//                  INSPSUIPAGE_MODE_LAST_CHILD - The lParam1 is ignonred.
//
//
//                If lParam1 is a valid common property sheet page handle then
//                it is  the child page handle of hComPropSheet that added by
//                CPSFUNC_ADD_xxx or inserted by CPSFUNC_INSERT_PSUIPAGE.
//
//      lParam2 - A pointer that points to INSERTPSUIPAGE_INFO data structure.
//                Fields must set according to the following.
//
//                  cbSize  - size of this structure
//
//                  Type    - Type of page(s) to be inserted.  It can be one
//                            of the following
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          Insert a group parent that can be used to insert
//                          new pages under it.  This is typically used when
//                          a set of common UI pages must be group together and
//                          can be deleted later using a single group parent
//                          handle without individual deleting each page.
//
//                          This handle can be nested.  After this function
//                          returned the group parent handle, it can be used
//                          as hComPropSheet handle (first parameter in the
//                          common UI callback) as parent handle so insertion
//                          will be inserted at level below returned group
//                          parent handle.
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          Insert pages using COMPROPSHEETUI data structure,
//                          dwData1 is a pointer to the COMPROPSHEETUI data
//                          structure.
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          Insert pages using PFNPROPSHEETUI function pointer.
//                          The dwData1 is a PFNPROPSHEETUI function pointer.
//                          The common UI will call this pfnPropSheetUI()
//                          function pointer with PROPSHEETUI_REASON_INIT to
//                          have it add pages.
//
//                          When common UI call pfnPropSheetUI() (dwData1) it
//                          also passed a 32-bit parameter from the dwData2
//                          field in INSERTPSUIPAGE_INFO data structure.
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          Insert pages using PROPSHEETPAGE data structure.
//                          The dwData1 is a pointer to the PROPSHEETPAGE
//                          data structure.
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          Insert pages using HPROPSHEETPAGE handle.  The
//                          dwData1 is a PROPSHEETPAGE handle which was
//                          created by CreatePropertySheetPage().
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          Insert pages from a dynnmaic link library.  The
//                          dwData1 is a pointer to a null terminated string
//                          that specified the dynamic link library file name.
//
//                          The dwData2 is a pointer to a null terminated ASCII
//                          string that specified the pfnPropSheetUI function
//                          name. (MUST BE ASCII STRING)
//
//                          Common UI will do a LoadLibrary((LPTSTR)dwData1),
//                          pfnPropSheetUI = GetProcAddress((LPTSTR)dwData2)
//                          then call the pfnPropSheetUI with a lParam from
//                          dwData3.  The called reason from common UI is
//                          set to PROPSHEETUI_REASON_INIT.
//
//                          Using this method insert pages will guaranteed that
//                          library will be unload correctly.
//
//
//                  Mode    - Insert Mode, it can be one of the following
//
//
//                      INSPSUIPAGE_MODE_BEFORE
//
//                          Insert pages before the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_AFTER
//
//                          Insert pages after the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_FIRST_CHILD
//
//                          Insert pages as the first child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_LAST_CHILD
//
//                          Insert pages as the last child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_INDEX
//
//                          Insert pages as a zero base child index of its
//                          parent handle specified by hComPropSheet.
//
//                          The lParam1 is the zero based index special handle
//                          that must generated by HINSPSUIPAGE_INDEX(Index)
//                          macro.   If the index is greater than or equal to
//                          the total count of children then it will treat the
//                          mode same as INSPSUIPAGE_MODE_LAST_CHILD
//
//
//                  dwData1
//                  dwData2
//                  dwData3 - 32-bit data associate with the 'Type' field
//                            as following
//
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          dwData1 = Not used, must be 0
//                          dwData2 = Not used, must be 0
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          dwData1 = pointer to COMPORPSHEETUI data structure.
//                          dwData2 = at return if sucessful, it contains total
//                                    page added.  If failed, it contains the
//                                    ERR_CPSUI_xxx codes
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          dwData1 = PFNPROPSHEETUI function pointer
//                          dwData2 = 32-bit parameter passed to pfnPropSheetUI
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          dwData1 = Pointer to PROPSHEETPAGE data structure.
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          dwData1 = Is the HPROPSHEETPAGE handle that created
//                                    by a call to CreatePropertySheetPage().
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          dwData1 = Pointer to a null terminated dynamic link
//                                    library filename.
//                          dwData2 = Pointer to a null terminated function
//                                    name (PFNPROPSHEETUI) in the dynamin link
//                                    library.
//                          dwData3 = 32-bit parameter passed to pfnPropSheetUI
//                                    (PFNPROPSHEETUI) function from dwData2
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_TITLE
//
//      This function let the caller set a new title for a particular common
//      UI page title (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that title to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Pointer to a null terminated string for the new title
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_ICON
//
//      This function let the caller set a new icon for a particular common
//      UI page icon (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that icon to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Handle to Icon, this icon is best as 16x16 icon otherwise it
//                will be stretch to 16x16 (pixel).
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//      After this function is successful set the icon, the caller can destroy
//      the hIcon using DestroyIcon() if the hIcon is created by CreateIcon().
//      If the hIcon (lParam2) passed is using LoadIcon() then it does not need
//      to destroy the icon.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DATABLOCK
//
//      This function let the caller register a new data block so it can be
//      later query by other pages in the property sheet, this function should
//      call durning PSN_KILLACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2 to be set.
//
//      lParam2 - DWORD Identifier of data block to be set
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block registered.  If return value is less
//      or equal to zero then function failed and data block is not registered.
//
//      If lParam1 is NULL, (lParam1)->cbData or (lParam1)->pbbData is NULL
//      it return a -1 to indicate an error parameter passed.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_QUERY_DATABLOCK
//
//      This function let the caller query a registered data block so it can
//      used this data block to communicate between property sheet pages.
//      This function should call durning PSN_SETACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2
//
//      lParam2 - DWORD Identifier of data block to be queried
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block copied into the pointer pointed by
//      the lParam1.  If return value is less or equal to zero then function
//      failed and data block is not copied to diciate the spcified datablock
//      Identifier (lParam2) is not found.
//
//      If CPSUIDATABLOCK pointer (lParam1) is NULL, (lParam1)->cbData or
//      (lParam1)->pbData is NULL then return value is the total bytes required
//      to copy the specified datablock identifier, if return value is less or
//      equal to zero then it indicate the spcified datablock identifier is
//      not found.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DMPUB_HIDEBITS
//
//      This function let the caller hide a set of predefined OPTITEMS in the
//      pages that was created using PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI with pDlgPage equal to
//      CPSUI_PDLGPAGE_DOCPROP or CPSUI_PDLGPAGE_ADVDOCPROP.
//
//      This function MUST called BEFORE the DOCPROP or ADVDOCPROP property
//      sheet pages are added using  PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//  Parameters:
//
//      lParam1 - prdefined bit array masks to specified which DOCPROP item to
//                be hidden.  Each DMPUB item bit can be generate using macro
//                MAKE_DMPUB_HIDEBIT() and all items can be OR together.
//
//      lParam2 - Not used, MUST be 0
//
//
//  Return Value:
//
//      The return value is equal to lParam1 if this function is called before
//      DOCPROP or ADVDOCPROP pages are added. Return value is zero if these
//      pages already added which means failure.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_IGNORE_CPSUI_PSN_APPLY
//
//      This function let caller control how CPSUI process PSN_APPLY messages
//      for pages added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      If this function never called, the Default CPSUI behavior is to process
//      PSN_APPLY messages.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - A non-zero value indicate to IGNORE the PSN_APPLY messages
//                for pages handle of lParam1.
//
//                A zero value to have CPSUI nomally process (not ignored) the
//                PSN_APPLY messages for pages handle of lParam1.
//
//                WARNING: if a PSN_APPLY messages are ignored, the caller must
//                         simulate a PSN_APPLY using CPSFUNC_DO_APPLY_CPSUI
//                         function or all changes WILL NOT applied, this is
//                         true even user hit 'OK' button.
//
//  Return Value:
//
//      the return value is zero if function failed, or non-zero to indicate
//      the function is successful.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_DO_APPLY_CPSUI
//
//      This function let caller simulate an apply (PSN_APPLY) to the pages
//      which added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - 32-bit flag to indicate how to do apply, currently only
//
//                  APPLYCPSUI_NO_NEWDEF
//
//                      The APPLYCPSUI_NO_NEWDEF bit specified that after the
//                      apply is done the undo buffer for all OPTITEMs still
//                      remain unchanged, this make next undo still possible.
//
//                      If APPLYCPSUI_NO_NEWDEF bit is clear then undo buffers
//                      are re-initialized after apply is done, the current
//                      changes for all OPTITEMs become the new undo default.
//
//
//                  APPLYCPSUI_OK_CANCEL_BUTTON
//
//                      If bit is set then it specified the apply is simulate
//                      a user hit 'Ok' or 'Cancel' button, if this bit is
//                      clear then it simulate a user hit 'Close' or 'Apply'
//                      button.  If caller getting a PSN_APPLY message, it can
//                      simulated using passed PSHNOTIFY (passed as lParam in
//                      WM_NOTIFY message) structure to determine how to set
//                      this bit as follow.
//
//                          if PSHNOTIFY.lParam == 0, then clear this bit
//                          otherwise set this bit.
//
//
//  Return Value:
//
//      the return value is less or equal to zero if it encounter an error and
//      apply failed (the active page will be switch to these pages).
//
//      If return value is greater than zero then changes were applied and
//      function sucessful.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_FUSION_CONTEXT
//
//      This function is used to set a fusion activation context for
//      the specified page.
//
//  Parameters:
//
//      lParam1 - handle to fusion context. compstui duplicates the handle
//                prior attaching it to its internal structures, so the caller
//                is not bound to keep the handle around. we release the
//                passed in context handle when the compstui handle is deleted.
//
//      lParam2 - not used
//
//  Return Value:
//
//      the return value is less or equal to zero if it encounter an error and/or
//      something failed (look up the last error for details).
//
//      If return value is greater than zero then the call was sucessful.
//
// -------------------------------------------------------------------------
//


#define PROPSHEETUI_REASON_INIT             0
#define PROPSHEETUI_REASON_GET_INFO_HEADER  1
#define PROPSHEETUI_REASON_DESTROY          2
#define PROPSHEETUI_REASON_SET_RESULT       3
#define PROPSHEETUI_REASON_GET_ICON         4
#define MAX_PROPSHEETUI_REASON_INDEX        4

#define PROPSHEETUI_INFO_VERSION            0x0100

#define PSUIINFO_UNICODE                    0x0001

typedef struct _PROPSHEETUI_INFO {
    WORD            cbSize;
    WORD            Version;
    WORD            Flags;
    WORD            Reason;
    HANDLE          hComPropSheet;
    PFNCOMPROPSHEET pfnComPropSheet;
    LPARAM          lParamInit;
    ULONG_PTR       UserData;
    ULONG_PTR       Result;
    } PROPSHEETUI_INFO, *PPROPSHEETUI_INFO;


//
// For the PROPSHEETUI_REASON_GET_ICON call which lParam is a pointer to
// PROPSHEETUI_GETICON_INFO
//

typedef struct _PROPSHEETUI_GETICON_INFO {
    WORD    cbSize;
    WORD    Flags;
    WORD    cxIcon;
    WORD    cyIcon;
    HICON   hIcon;
    } PROPSHEETUI_GETICON_INFO, *PPROPSHEETUI_GETICON_INFO;


typedef LONG (FAR *PFNPROPSHEETUI)(PPROPSHEETUI_INFO   pPSUIInfo,
                                   LPARAM              lParam);


//
// PFNPROPSHEETUI
//
//  This function is user defined function which will be called by the common
//  UI when a caller wish to include the executable property sheets.
//
//  pPSUIInfo   - Pointer to PROPSHEETUI_INFO below for description of
//                PROPSHEETUI_INFO.
//
//                If this pointer is NULL then this function is not called from
//                common UI, and lParam should be used to determined the
//                action and outcome of this funciton.
//
//  lParam      - A LPARAM intented for this funciton depends on the reason.
//                If pPSUIInfo is NULL then this function is not called from
//                common UI, the lParam is the parameter which agreed with
//                the caller.
//
//                if pPSUIInfo is not NULL then this function assume the call
//                is from the common UI.  lParam has following meanion depends
//                on the reason field.
//
//                PROPSHEETUI_REASON_INIT
//
//                  The lParam is either passed from CPSFUNC_ADD_PFNPROPSHEETUI
//                  callback function's second parameter (lParam2) or it is
//                  from CommonPropertySheetUI()'s lParam (seccond parameter)
//                  without any modification.
//
//                  The lParam MUST NOT be a variable or a pointer to memory
//                  block which resides on the caller function's stack, since
//                  after this function exit, the lParam will become invalid
//                  and can cause fatal system error.
//
//                  The lParam parameter is copied to the lParamInit field in
//                  PROPSHEETUI_INFO data structure.  The lParamInit field
//                  will be passed to all subsequent pfnPropSheetUI() calls
//                  without any modification.
//
//
//                PROPSHEETUI_REASON_GET_INFO_HEADER:
//
//                  lParam is a pointer to the PROPSHEETUI_INFO_HEADER data
//                  structure. this function must correctly fill this structure
//                  fields before it returned.
//
//
//                PROPSHEETUI_REASON_DESTROY
//
//                  lParam is zero to indicate the destroy is cause either by a
//                  caller calling CPSFUNC_DELETE_HCOMPROPSHEET or failed
//                  in caller's CPSFUNC_ADD_xxxx.
//
//                  lParam is non zero to indicate the destroy is cause by
//                  exiting from the property sheet user interface.
//
//
//                PROPSHEETUI_REASON_SET_RESULT
//
//                  lParam is a pointer to SETRESULT_INFO data structure.
//                  Fields in SETRESULT_INFO data structure is set to following
//
//                      hSetResult: Handle to the common UI property sheet
//                                  pages which added by the CPSFUNC_ADD_xxx
//                                  callback function indices.
//
//                          Result: The result from the hSetResult to be set.
//                                  When return greater than zero then Result
//                                  in this field is set to its parent.
//
//
//                PROPSHEETUI_REASON_GET_ICON
//
//                  lParam is a pointer to PROPSHEETUI_GETICON_INFO data
//                  structure.  Fields in PROPSHEETUI_GETICON_INFO data
//                  structure are set to following
//
//                      cxIcon = cx Icon size in pixel
//                      cyIcon = cy Icon size in pixel
//                      hIcon  = Initial to NULL, and this function must put
//                               the created icon handle in this field before
//                               returned.
//


//
// PROPSHEETUI_INFO
//
//  This structure is used when common UI calling the caller passed function
//  entry point PFNPROPSHEETUI, the pfnPropSheetUI() return a LONG to
//  indicate result of this function.
//
//  When the pfnPropSheetUI() returned, it must also put the required result
//  in the Result field, each PROPSHEETUI_REASON_xxx has different required
//  result as describe below.
//
//
//
//  cbSize          - sizeof this structure (PROPSHEETUI_INFO)
//
//  Version         - the PROPSHEETUI_INFO data structure version. Current
//                    version is set to PROPSHEETUI_INFO_VERSION
//
//  Flags           - One or more following is may be defined
//
//                      PSUIINFO_UNICODE
//
//                          The caller's executable was original compiled was
//                          intented using unicode.
//
//
//  Reason          - Following reasons are defined.
//
//                      PROPSHEETUI_REASON_INIT
//
//                          When first time the pfnPropSheetUI() called, this
//                          reason is used to have the function initialize
//                          itself and use the pfnComPropSheet() function
//                          pointer provided to add new pages to the
//                          hComPropSheet handle passed.   The UserData in this
//                          data structure is initially set equal to zero (0).
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//                      *NOTE*
//
//                          The lParam MUST NOT be a variable or a pointer to
//                          memory block which resides on the caller function's
//                          stack, since after this function exit, the lParam
//                          will become invalid and can cause fatal system
//                          error.
//
//                          If this function reason returned failed ( <= 0),
//                          this function (pfnPropSheetUI) will received a
//                          PROPSHEETUI_REASON_DESTROY function reason right
//                          after this function reason returned.
//
//
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                          It is called after the PROPSHEETUI_REASON_INIT is
//                          successful returned.  This reason is used to asked
//                          the function fill in the PROPSHEETUI_INFO_HEADER
//                          for pop-up the property sheet dialog boxes.
//
//                          lParam in this reason is a pointer to the
//                          PROPSHEETUI_INFO_HEADER data structure, following
//                          fields are requrested to be filled in.
//
//                              Flags       - PSUIHDRF_xxx flags
//                              pTitle      - The property sheet title
//                              hWndParent  - handle to the parent of property
//                                            sheet pages.
//                              hInst       - Instance data handle for this
//                                            function.
//                              hIcon
//                              IconID      - Icon used on the title bar.
//
//                          * Return > 0 to indicate sucesful and pop-up the
//                            property sheet dialog boxes or returned <= 0 to
//                            indicate error (not property sheet UI appeared)
//
//
//                      PROPSHEETUI_REASON_DESTROY
//
//                          When the property sheet ready to dismissed or the
//                          caller is delete the common UI pages added by the
//                          pfnPropSheetUI(), the common UI will call this
//                          entry point to have it de-initialized itself and
//                          free up all the memory used for this function
//                          instance.  The UserData field passed is the
//                          'UserData' field which returned from previous
//                          PROPSHEETUI_REASON_xxxx.
//
//                          When this function called, all hComPropSheet's
//                          children are desotroyed and children's common UI
//                          handles are not longer valid.
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                          The reason is used when an added handle from
//                          CPSFUNC_ADD_xxxx whant to return the result to
//                          this pfnPropSheetUI() caller.
//
//                          The lParam in second parameter is a pointer to a
//                          SETRESULT_INFO data structure.
//
//                              hSetResult: specified the common UI property
//                                          sheet page handle which added by
//                                          this function using
//                                          CPSFUNC_ADD_xxx indicies.
//
//                                  Result: Specified the Result to be set to
//                                          this pfnPropSheetUI() form the
//                                          hSetResult property sheet page
//                                          handle. If return value is greater
//                                          than zero then the value in this
//                                          Result field will be set to its
//                                          parent if one exist, at this case
//                                          this function can alter the Result
//                                          field value for its parent.
//
//                          * Returned greater than zero to continue send to
//                            its parent, else it stop sending the Result filed
//                            value to its parent.
//
//
//                      PROPSHEETUI_REASON_GET_ICON
//
//                          The reason is used to retrived the Icon which
//                          represent this pfnPropSheetUI().
//
//                          lParam is a pointer to PROPSHEETUI_GETICON_INFO '
//                          data structure.  Fields in PROPSHEETUI_GETICON_INFO
//                          data structure are set to following
//
//                              cxIcon = cx Icon size in pixel
//                              cyIcon = cy Icon size in pixel
//                              hIcon  = Initial to NULL, and this function
//                                       must put the created icon handle in
//                                       this field before return.
//
//
//                          * Return > 0 to indicate sucesful (hIcon is the
//                            requested icon handle).   Return = 0 to indicate
//                            no icon available, or return < 0 to indicate an
//                            error.
//
//              *NOTE*
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    user defined DWORD data in the PROPSHEETUI_INFO data
//                    structure's UserData field.
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    pfnPropSheetUI() DWORD result in PROPSHEETUI_INFO data
//                    structure's Result field.
//
//
//  hComPropSheet   - Handle to the COMPROPSHEETPAGE which this function should
//                    used as hComPropSheet parameter when calling
//                    pfnComPropSheet() to add or delete common UI property
//                    sheet pages.  The hComPropSheet is the instance handle to
//                    pfnPropSheetUI() function.
//
//  pfnComPropSheet - Pointer to the common UI callback function which for the
//                    pfnPropSheetUI() to add, delete, set user data, for a
//                    completed set of callback, see CPSFUNC_xxx descriptions
//                    above.
//
//  lParamInit      - The lParam originally passed duning the the first call
//                    reason PROPSHEETUI_REASON_INIT.  The lParamInit will be
//                    passed to each PROPSHEETUI_REASON_xxx calls.
//
//  UserData        - the UserData field is an IN and OUT parameter for each
//                    of the Reason,
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Initial set to zero (0).
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_SET_RESULT
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                           IN: The UserData specified at time when returned
//                               from the previous PROPSHEETUI_REASON_xxx
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
// Result           - The Result field is an IN and OUT parameter for each of
//                    the reason.
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Set to zero (0).
//
//                          OUT: Set to default result of this PropSheetUI()
//                               function.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                           IN: The current 'Result' returned from previous
//                               PROPSHEETUI_REASON_xxx function.
//
//                          OUT: Set the new result of this PropSheetUI()
//                               function.
//
//


#define PSUIHDRF_OBSOLETE       0x0001
#define PSUIHDRF_NOAPPLYNOW     0x0002
#define PSUIHDRF_PROPTITLE      0x0004
#define PSUIHDRF_USEHICON       0x0008
#define PSUIHDRF_DEFTITLE       0x0010
#define PSUIHDRF_EXACT_PTITLE   0x0020

typedef struct _PROPSHEETUI_INFO_HEADER {
    WORD                    cbSize;
    WORD                    Flags;
    LPTSTR                  pTitle;
    HWND                    hWndParent;
    HINSTANCE               hInst;
    union {
        HICON               hIcon;
        ULONG_PTR           IconID;
        } DUMMYUNIONNAME;
    } PROPSHEETUI_INFO_HEADER, *PPROPSHEETUI_INFO_HEADER;

//
// PROPSHEETUI_INFO_HEADER
//
//  This data structure is used when common UI ready to pop-up the property
//  sheet page dialog boxes and it asked caller to provide more information.
//
//  Common property sheet UI passed this data structure as lParam when it call
//  provided pfnPropSheetUI() with PROPSHEETUI_REASON_GET_INFO_HEADER reason.
//
//
//  cbSize      - size of this structure
//
//  Flags       - PSUIHDRF_xxxx flags
//
//                  PSUIHDRF_OBSOLETE
//
//                      Not used, must not set this bit
//
//
//                  PSUIHDRF_NOAPPLYNOW
//
//                      Remove 'Apply Now' button.
//
//
//                  PSUIHDRF_PROPTITLE
//
//                      Automatically include 'Properties' in the title bar
//
//
//                  PSUIHDRF_USEHICON
//
//                      If this bit is specified then hIcon union field is
//                      a valid handle to the icon otherwise the IconID is
//                      the either caller's resource ID or common UI standard
//                      icon ID.
//
//                  PSUIHDRF_DEFTITLE
//
//                      Automatically include 'Default' in the title bar, the
//                      'Default' always added right after pTitle and before
//                      'Properties' if PSUIHDRF_PROPTITLE flag is set.
//
//                  PSUIHDRF_EXACT_PTITLE
//
//                      This flag indicate the pTitle set in this structure
//                      will be use without any modification by the compstui
//                      ie. compstui will not modified pTitle in any way and
//                      it will ignored PSUIHDRF_PROPTITLE, PSUIHDRF_DEFTITLE
//
//
//  pTitle      - Pointer to the NULL terminated caption name for the
//                property sheets.
//
//                  ** See LPTSTR typedef description above
//
//  hWndParent  - The handle of the window which will be parent of the common
//                UI property sheets, if NULL then current active window for
//                the calling thread is used.
//
//  hInst       - the caller's handle to its instance.  Commom UI use this
//                handle to load caller's icon and other resources.
//
//  hIcon
//  IconID      - Specified the icon which put on the title bar, it either a
//                handle to the icon or a icon resource ID depends on the
//                PSUIHDRF_USEHICON flag.
//



//
// LONG
// CommonPropertySheetUI(
//     HWND            hWndOwner,
//     PFNPROPSHEETUI  pfnPropSheetUI,
//     LPARAM          lParam,
//     LPDWORD         pResult
//     );
//
//
// The CommonPropSheetUI is the main entry point for the common property sheet
// user interface.   The original caller that wish to using common UI to pop-up
// property sheet will call this function and passed its own PFNPROPSHEETUI
// function address and a long parameter.
//
// If pfnPropSheetUI function return a LONG number greater than zero (0) then
// common UI will pop-up the property sheet page dialog boxes, when Property
// sheet pages is finished. (either hit Ok or Cancel) it will return the
// result of CPSUI_xxxx back to the caller.
//
// If pfnPropSheetUI function return a LONG number equal or less than zero (0)
// then it will return the CPSUI_CANCEL back to caller without pop-up the
// property sheet page dialog boxes.
//
//
//  Parameters:
//
//      hWndOwner       - Window handle for the owner of this proerty sheet
//                        pages dialog boxes.
//
//      pfnPropSheetUI  - a PFNPROPSHEETUI function pointer which is used by
//                        the caller to add its property sheet pages.
//
//      lParam          - a long parameter will be passed to the pfnPropSheetUI
//                        funciton.  The common UI called the pfnPropSheetUI as
//
//                          PROPSHEETUI_INFO    PSUIInfo;
//
//                          pfnPropSheetUI(&PSUIInfo, lParam);
//
//                        The caller must use pfnComPropSheet() to add/delete
//                        pages.  When it is done adding pages, it retuned
//                        greater than zero to indicate successful, and return
//                        less or equal to zero to indicate failure.
//
//      pResult         - a pointer to DWORD which received the final result
//                        of pfnPropSheetUI() funciton, this result is a copy
//                        from Result field of PROPSHEETUI_INFO data structure
//                        which passed to the pfnPropSheetUI() as the first
//                        parameter.  The pResult only will be set if the
//                        returned value from CommonPropertySheetUI() is not
//                        ERR_CPSUI_xxx.
//
//                        if pResult is NULL then common UI will not return
//                        pfnPropSheetUI()'s result back.
//
//
//  Return Value:
//
//      LONG    - < 0                   - property page does not displayed and
//                                        ERR_CPSUI_xxx is the error code
//                CPSUI_OK              - property page displayed.
//                CPSUI_RESTARTWINDOWS  - property page displayed and need to
//                                        restart window to take effect
//                CPSUI_REBOOTSYSTEM    - property page dispalyed and need
//                                        to reboot system to take effect
//
//


#if (NTDDI_VERSION >= NTDDI_VISTA)

LONG
APIENTRY
CommonPropertySheetUIA(
    HWND hWndOwner,
    __callback PFNPROPSHEETUI pfnPropSheetUI,
    LPARAM lParam,
    __out LPDWORD pResult
    );

LONG
APIENTRY
CommonPropertySheetUIW(
    HWND hWndOwner,
    __callback PFNPROPSHEETUI pfnPropSheetUI,
    LPARAM lParam,
    __out LPDWORD pResult
    );

#else

LONG
APIENTRY
CommonPropertySheetUIA(
    HWND hWndOwner,
    PFNPROPSHEETUI pfnPropSheetUI,
    LPARAM lParam,
    LPDWORD pResult
    );

LONG
APIENTRY
CommonPropertySheetUIW(
    HWND hWndOwner,
    PFNPROPSHEETUI pfnPropSheetUI,
    LPARAM lParam,
    LPDWORD pResult
    );

#endif


#ifdef UNICODE
#define CommonPropertySheetUI   CommonPropertySheetUIW
#else
#define CommonPropertySheetUI   CommonPropertySheetUIA
#endif



//
// GetCPSUIUserData() and SetCPSUIUserData() is used for the pages added
// by the CPSFUNC_ADD_PCOMPROPSHEETUI.  The caller add this function and has
// sub class dialog procedure should not set DWLP_USERDATA but calling these
// function instead, otherwise the system can failed.
//

ULONG_PTR
APIENTRY
GetCPSUIUserData(
    HWND    hDlg
    );

BOOL
APIENTRY
SetCPSUIUserData(
    HWND        hDlg,
    ULONG_PTR   CPSUIUserData
    );


#define CPSUI_CANCEL                        0
#define CPSUI_OK                            1
#define CPSUI_RESTARTWINDOWS                2
#define CPSUI_REBOOTSYSTEM                  3

#define ERR_CPSUI_GETLASTERROR              -1
#define ERR_CPSUI_ALLOCMEM_FAILED           -2
#define ERR_CPSUI_INVALID_PDATA             -3
#define ERR_CPSUI_INVALID_LPARAM            -4
#define ERR_CPSUI_NULL_HINST                -5
#define ERR_CPSUI_NULL_CALLERNAME           -6
#define ERR_CPSUI_NULL_OPTITEMNAME          -7
#define ERR_CPSUI_NO_PROPSHEETPAGE          -8
#define ERR_CPSUI_TOO_MANY_PROPSHEETPAGES   -9
#define ERR_CPSUI_CREATEPROPPAGE_FAILED     -10
#define ERR_CPSUI_MORE_THAN_ONE_TVPAGE      -11
#define ERR_CPSUI_MORE_THAN_ONE_STDPAGE     -12
#define ERR_CPSUI_INVALID_PDLGPAGE          -13
#define ERR_CPSUI_INVALID_DLGPAGE_CBSIZE    -14
#define ERR_CPSUI_TOO_MANY_DLGPAGES         -15
#define ERR_CPSUI_INVALID_DLGPAGEIDX        -16
#define ERR_CPSUI_SUBITEM_DIFF_DLGPAGEIDX   -17
#define ERR_CPSUI_NULL_POPTITEM             -18
#define ERR_CPSUI_INVALID_OPTITEM_CBSIZE    -19
#define ERR_CPSUI_INVALID_OPTTYPE_CBSIZE    -20
#define ERR_CPSUI_INVALID_OPTTYPE_COUNT     -21
#define ERR_CPSUI_NULL_POPTPARAM            -22
#define ERR_CPSUI_INVALID_OPTPARAM_CBSIZE   -23
#define ERR_CPSUI_INVALID_EDITBOX_PSEL      -24
#define ERR_CPSUI_INVALID_EDITBOX_BUF_SIZE  -25
#define ERR_CPSUI_INVALID_ECB_CBSIZE        -26
#define ERR_CPSUI_NULL_ECB_PTITLE           -27
#define ERR_CPSUI_NULL_ECB_PCHECKEDNAME     -28
#define ERR_CPSUI_INVALID_DMPUBID           -29
#define ERR_CPSUI_INVALID_DMPUB_TVOT        -30
#define ERR_CPSUI_CREATE_TRACKBAR_FAILED    -31
#define ERR_CPSUI_CREATE_UDARROW_FAILED     -32
#define ERR_CPSUI_CREATE_IMAGELIST_FAILED   -33
#define ERR_CPSUI_INVALID_TVOT_TYPE         -34
#define ERR_CPSUI_INVALID_LBCB_TYPE         -35
#define ERR_CPSUI_SUBITEM_DIFF_OPTIF_HIDE   -36
#define ERR_CPSUI_INVALID_PUSHBUTTON_TYPE   -38
#define ERR_CPSUI_INVALID_EXTPUSH_CBSIZE    -39
#define ERR_CPSUI_NULL_EXTPUSH_DLGPROC      -40
#define ERR_CPSUI_NO_EXTPUSH_DLGTEMPLATEID  -41
#define ERR_CPSUI_NULL_EXTPUSH_CALLBACK     -42
#define ERR_CPSUI_DMCOPIES_USE_EXTPUSH      -43
#define ERR_CPSUI_ZERO_OPTITEM              -44


#define ERR_CPSUI_FUNCTION_NOT_IMPLEMENTED  -9999
#define ERR_CPSUI_INTERNAL_ERROR            -10000

#endif  // (!defined(RC_INVOKED))



//
//****************************************************************************
//*                                                                          *
//*      Common Property Sheet UI resource ID for the ICONs and STRINGs      *
//*                                                                          *
//* The Resource ID from 64000 to 65535 are reserved for common UI and must  *
//* not used as caller resource ID else the string, icon loading will not be *
//* correct.                                                                 *
//*                                                                          *
//****************************************************************************
//


//
// Common UI standard 32x32, 16x16 color and monochrome Icon IDs
//

#define IDI_CPSUI_ICONID_FIRST          64000

#define IDI_CPSUI_EMPTY                 64000
#define IDI_CPSUI_SEL_NONE              64001
#define IDI_CPSUI_WARNING               64002
#define IDI_CPSUI_NO                    64003
#define IDI_CPSUI_YES                   64004
#define IDI_CPSUI_FALSE                 64005
#define IDI_CPSUI_TRUE                  64006
#define IDI_CPSUI_OFF                   64007
#define IDI_CPSUI_ON                    64008
#define IDI_CPSUI_PAPER_OUTPUT          64009
#define IDI_CPSUI_ENVELOPE              64010
#define IDI_CPSUI_MEM                   64011
#define IDI_CPSUI_FONTCARTHDR           64012
#define IDI_CPSUI_FONTCART              64013
#define IDI_CPSUI_STAPLER_ON            64014
#define IDI_CPSUI_STAPLER_OFF           64015
#define IDI_CPSUI_HT_HOST               64016
#define IDI_CPSUI_HT_DEVICE             64017
#define IDI_CPSUI_TT_PRINTASGRAPHIC     64018
#define IDI_CPSUI_TT_DOWNLOADSOFT       64019
#define IDI_CPSUI_TT_DOWNLOADVECT       64020
#define IDI_CPSUI_TT_SUBDEV             64021
#define IDI_CPSUI_PORTRAIT              64022
#define IDI_CPSUI_LANDSCAPE             64023
#define IDI_CPSUI_ROT_LAND              64024
#define IDI_CPSUI_AUTOSEL               64025
#define IDI_CPSUI_PAPER_TRAY            64026
#define IDI_CPSUI_PAPER_TRAY2           64027
#define IDI_CPSUI_PAPER_TRAY3           64028
#define IDI_CPSUI_TRANSPARENT           64029
#define IDI_CPSUI_COLLATE               64030
#define IDI_CPSUI_DUPLEX_NONE           64031
#define IDI_CPSUI_DUPLEX_HORZ           64032
#define IDI_CPSUI_DUPLEX_VERT           64033
#define IDI_CPSUI_RES_DRAFT             64034
#define IDI_CPSUI_RES_LOW               64035
#define IDI_CPSUI_RES_MEDIUM            64036
#define IDI_CPSUI_RES_HIGH              64037
#define IDI_CPSUI_RES_PRESENTATION      64038
#define IDI_CPSUI_MONO                  64039
#define IDI_CPSUI_COLOR                 64040
#define IDI_CPSUI_DITHER_NONE           64041
#define IDI_CPSUI_DITHER_COARSE         64042
#define IDI_CPSUI_DITHER_FINE           64043
#define IDI_CPSUI_DITHER_LINEART        64044
#define IDI_CPSUI_SCALING               64045
#define IDI_CPSUI_COPY                  64046
#define IDI_CPSUI_HTCLRADJ              64047
#define IDI_CPSUI_HALFTONE_SETUP        64048
#define IDI_CPSUI_WATERMARK             64049
#define IDI_CPSUI_ERROR                 64050
#define IDI_CPSUI_ICM_OPTION            64051
#define IDI_CPSUI_ICM_METHOD            64052
#define IDI_CPSUI_ICM_INTENT            64053
#define IDI_CPSUI_STD_FORM              64054
#define IDI_CPSUI_OUTBIN                64055
#define IDI_CPSUI_OUTPUT                64056
#define IDI_CPSUI_GRAPHIC               64057
#define IDI_CPSUI_ADVANCE               64058
#define IDI_CPSUI_DOCUMENT              64059
#define IDI_CPSUI_DEVICE                64060
#define IDI_CPSUI_DEVICE2               64061
#define IDI_CPSUI_PRINTER               64062
#define IDI_CPSUI_PRINTER2              64063
#define IDI_CPSUI_PRINTER3              64064
#define IDI_CPSUI_PRINTER4              64065
#define IDI_CPSUI_OPTION                64066
#define IDI_CPSUI_OPTION2               64067
#define IDI_CPSUI_STOP                  64068
#define IDI_CPSUI_NOTINSTALLED          64069
#define IDI_CPSUI_WARNING_OVERLAY       64070
#define IDI_CPSUI_STOP_WARNING_OVERLAY  64071
#define IDI_CPSUI_GENERIC_OPTION        64072
#define IDI_CPSUI_GENERIC_ITEM          64073
#define IDI_CPSUI_RUN_DIALOG            64074
#define IDI_CPSUI_QUESTION              64075
#define IDI_CPSUI_FORMTRAYASSIGN        64076
#define IDI_CPSUI_PRINTER_FOLDER        64077
#define IDI_CPSUI_INSTALLABLE_OPTION    64078
#define IDI_CPSUI_PRINTER_FEATURE       64079
#define IDI_CPSUI_DEVICE_FEATURE        64080
#define IDI_CPSUI_FONTSUB               64081
#define IDI_CPSUI_POSTSCRIPT            64082
#define IDI_CPSUI_TELEPHONE             64083
#define IDI_CPSUI_DUPLEX_NONE_L         64084
#define IDI_CPSUI_DUPLEX_HORZ_L         64085
#define IDI_CPSUI_DUPLEX_VERT_L         64086
#define IDI_CPSUI_LF_PEN_PLOTTER        64087
#define IDI_CPSUI_SF_PEN_PLOTTER        64088
#define IDI_CPSUI_LF_RASTER_PLOTTER     64089
#define IDI_CPSUI_SF_RASTER_PLOTTER     64090
#define IDI_CPSUI_ROLL_PAPER            64091
#define IDI_CPSUI_PEN_CARROUSEL         64092
#define IDI_CPSUI_PLOTTER_PEN           64093
#define IDI_CPSUI_MANUAL_FEED           64094
#define IDI_CPSUI_FAX                   64095
#define IDI_CPSUI_PAGE_PROTECT          64096
#define IDI_CPSUI_ENVELOPE_FEED         64097
#define IDI_CPSUI_FONTCART_SLOT         64098
#define IDI_CPSUI_LAYOUT_BMP_PORTRAIT   64099
#define IDI_CPSUI_LAYOUT_BMP_ARROWL     64100
#define IDI_CPSUI_LAYOUT_BMP_ARROWS     64101
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETL   64102
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETP   64103

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define IDI_CPSUI_LAYOUT_BMP_ARROWLR    64104
#define IDI_CPSUI_LAYOUT_BMP_ROT_PORT   64105
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETL_NB 64106
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETP_NB 64107
#define IDI_CPSUI_ROT_PORT              64110
#define IDI_CPSUI_NUP_BORDER            64111
#define IDI_CPSUI_ICONID_LAST           64111
#else
#define IDI_CPSUI_ICONID_LAST           64103
#endif

//
// Common UI standard String IDs
//


#define IDS_CPSUI_STRID_FIRST           64700

#define IDS_CPSUI_SETUP                 64700
#define IDS_CPSUI_MORE                  64701
#define IDS_CPSUI_CHANGE                64702
#define IDS_CPSUI_OPTION                64703
#define IDS_CPSUI_OF                    64704
#define IDS_CPSUI_RANGE_FROM            64705
#define IDS_CPSUI_TO                    64706
#define IDS_CPSUI_COLON_SEP             64707
#define IDS_CPSUI_LEFT_ANGLE            64708
#define IDS_CPSUI_RIGHT_ANGLE           64709
#define IDS_CPSUI_SLASH_SEP             64710
#define IDS_CPSUI_PERCENT               64711
#define IDS_CPSUI_LBCB_NOSEL            64712
#define IDS_CPSUI_PROPERTIES            64713
#define IDS_CPSUI_DEFAULTDOCUMENT       64714
#define IDS_CPSUI_DOCUMENT              64715
#define IDS_CPSUI_ADVANCEDOCUMENT       64716
#define IDS_CPSUI_PRINTER               64717
#define IDS_CPSUI_AUTOSELECT            64718
#define IDS_CPSUI_PAPER_OUTPUT          64719
#define IDS_CPSUI_GRAPHIC               64720
#define IDS_CPSUI_OPTIONS               64721
#define IDS_CPSUI_ADVANCED              64722
#define IDS_CPSUI_STDDOCPROPTAB         64723
#define IDS_CPSUI_STDDOCPROPTVTAB       64724
#define IDS_CPSUI_DEVICEOPTIONS         64725
#define IDS_CPSUI_FALSE                 64726
#define IDS_CPSUI_TRUE                  64727
#define IDS_CPSUI_NO                    64728
#define IDS_CPSUI_YES                   64729
#define IDS_CPSUI_OFF                   64730
#define IDS_CPSUI_ON                    64731
#define IDS_CPSUI_DEFAULT               64732
#define IDS_CPSUI_ERROR                 64733
#define IDS_CPSUI_NONE                  64734
#define IDS_CPSUI_NOT                   64735
#define IDS_CPSUI_EXIST                 64736
#define IDS_CPSUI_NOTINSTALLED          64737
#define IDS_CPSUI_ORIENTATION           64738
#define IDS_CPSUI_SCALING               64739
#define IDS_CPSUI_NUM_OF_COPIES         64740
#define IDS_CPSUI_SOURCE                64741
#define IDS_CPSUI_PRINTQUALITY          64742
#define IDS_CPSUI_RESOLUTION            64743
#define IDS_CPSUI_COLOR_APPERANCE       64744
#define IDS_CPSUI_DUPLEX                64745
#define IDS_CPSUI_TTOPTION              64746
#define IDS_CPSUI_FORMNAME              64747
#define IDS_CPSUI_ICM                   64748
#define IDS_CPSUI_ICMMETHOD             64749
#define IDS_CPSUI_ICMINTENT             64750
#define IDS_CPSUI_MEDIA                 64751
#define IDS_CPSUI_DITHERING             64752
#define IDS_CPSUI_PORTRAIT              64753
#define IDS_CPSUI_LANDSCAPE             64754
#define IDS_CPSUI_ROT_LAND              64755
#define IDS_CPSUI_COLLATE               64756
#define IDS_CPSUI_COLLATED              64757
#define IDS_CPSUI_PRINTFLDSETTING       64758
#define IDS_CPSUI_DRAFT                 64759
#define IDS_CPSUI_LOW                   64760
#define IDS_CPSUI_MEDIUM                64761
#define IDS_CPSUI_HIGH                  64762
#define IDS_CPSUI_PRESENTATION          64763
#define IDS_CPSUI_COLOR                 64764
#define IDS_CPSUI_GRAYSCALE             64765
#define IDS_CPSUI_MONOCHROME            64766
#define IDS_CPSUI_SIMPLEX               64767
#define IDS_CPSUI_HORIZONTAL            64768
#define IDS_CPSUI_VERTICAL              64769
#define IDS_CPSUI_LONG_SIDE             64770
#define IDS_CPSUI_SHORT_SIDE            64771
#define IDS_CPSUI_TT_PRINTASGRAPHIC     64772
#define IDS_CPSUI_TT_DOWNLOADSOFT       64773
#define IDS_CPSUI_TT_DOWNLOADVECT       64774
#define IDS_CPSUI_TT_SUBDEV             64775
#define IDS_CPSUI_ICM_BLACKWHITE        64776
#define IDS_CPSUI_ICM_NO                64777
#define IDS_CPSUI_ICM_YES               64778
#define IDS_CPSUI_ICM_SATURATION        64779
#define IDS_CPSUI_ICM_CONTRAST          64780
#define IDS_CPSUI_ICM_COLORMETRIC       64781
#define IDS_CPSUI_STANDARD              64782
#define IDS_CPSUI_GLOSSY                64783
#define IDS_CPSUI_TRANSPARENCY          64784
#define IDS_CPSUI_REGULAR               64785
#define IDS_CPSUI_BOND                  64786
#define IDS_CPSUI_COARSE                64787
#define IDS_CPSUI_FINE                  64788
#define IDS_CPSUI_LINEART               64789
#define IDS_CPSUI_ERRDIFFUSE            64790
#define IDS_CPSUI_HALFTONE              64791
#define IDS_CPSUI_HTCLRADJ              64792
#define IDS_CPSUI_USE_HOST_HT           64793
#define IDS_CPSUI_USE_DEVICE_HT         64794
#define IDS_CPSUI_USE_PRINTER_HT        64795
#define IDS_CPSUI_OUTBINASSIGN          64796
#define IDS_CPSUI_WATERMARK             64797
#define IDS_CPSUI_FORMTRAYASSIGN        64798
#define IDS_CPSUI_UPPER_TRAY            64799
#define IDS_CPSUI_ONLYONE               64800
#define IDS_CPSUI_LOWER_TRAY            64801
#define IDS_CPSUI_MIDDLE_TRAY           64802
#define IDS_CPSUI_MANUAL_TRAY           64803
#define IDS_CPSUI_ENVELOPE_TRAY         64804
#define IDS_CPSUI_ENVMANUAL_TRAY        64805
#define IDS_CPSUI_TRACTOR_TRAY          64806
#define IDS_CPSUI_SMALLFMT_TRAY         64807
#define IDS_CPSUI_LARGEFMT_TRAY         64808
#define IDS_CPSUI_LARGECAP_TRAY         64809
#define IDS_CPSUI_CASSETTE_TRAY         64810
#define IDS_CPSUI_DEFAULT_TRAY          64811
#define IDS_CPSUI_FORMSOURCE            64812
#define IDS_CPSUI_MANUALFEED            64813
#define IDS_CPSUI_PRINTERMEM_KB         64814
#define IDS_CPSUI_PRINTERMEM_MB         64815
#define IDS_CPSUI_PAGEPROTECT           64816
#define IDS_CPSUI_HALFTONE_SETUP        64817
#define IDS_CPSUI_INSTFONTCART          64818
#define IDS_CPSUI_SLOT1                 64819
#define IDS_CPSUI_SLOT2                 64820
#define IDS_CPSUI_SLOT3                 64821
#define IDS_CPSUI_SLOT4                 64822
#define IDS_CPSUI_LEFT_SLOT             64823
#define IDS_CPSUI_RIGHT_SLOT            64824
#define IDS_CPSUI_STAPLER               64825
#define IDS_CPSUI_STAPLER_ON            64826
#define IDS_CPSUI_STAPLER_OFF           64827
#define IDS_CPSUI_STACKER               64828
#define IDS_CPSUI_MAILBOX               64829
#define IDS_CPSUI_COPY                  64830
#define IDS_CPSUI_COPIES                64831
#define IDS_CPSUI_TOTAL                 64832
#define IDS_CPSUI_MAKE                  64833
#define IDS_CPSUI_PRINT                 64834
#define IDS_CPSUI_FAX                   64835
#define IDS_CPSUI_PLOT                  64836
#define IDS_CPSUI_SLOW                  64837
#define IDS_CPSUI_FAST                  64838
#define IDS_CPSUI_ROTATED               64839
#define IDS_CPSUI_RESET                 64840
#define IDS_CPSUI_ALL                   64841
#define IDS_CPSUI_DEVICE                64842
#define IDS_CPSUI_SETTINGS              64843
#define IDS_CPSUI_REVERT                64844
#define IDS_CPSUI_CHANGES               64845
#define IDS_CPSUI_CHANGED               64846
#define IDS_CPSUI_WARNING               64847
#define IDS_CPSUI_ABOUT                 64848
#define IDS_CPSUI_VERSION               64849
#define IDS_CPSUI_NO_NAME               64850
#define IDS_CPSUI_SETTING               64851
#define IDS_CPSUI_DEVICE_SETTINGS       64852
#define IDS_CPSUI_STDDOCPROPTAB1        64853
#define IDS_CPSUI_STDDOCPROPTAB2        64854
#define IDS_CPSUI_PAGEORDER             64855
#define IDS_CPSUI_FRONTTOBACK           64856
#define IDS_CPSUI_BACKTOFRONT           64857
#define IDS_CPSUI_QUALITY_SETTINGS      64858
#define IDS_CPSUI_QUALITY_DRAFT         64859
#define IDS_CPSUI_QUALITY_BETTER        64860
#define IDS_CPSUI_QUALITY_BEST          64861
#define IDS_CPSUI_QUALITY_CUSTOM        64862
#define IDS_CPSUI_OUTPUTBIN             64863
#define IDS_CPSUI_NUP                   64864
#define IDS_CPSUI_NUP_NORMAL            64865
#define IDS_CPSUI_NUP_TWOUP             64866
#define IDS_CPSUI_NUP_FOURUP            64867
#define IDS_CPSUI_NUP_SIXUP             64868
#define IDS_CPSUI_NUP_NINEUP            64869
#define IDS_CPSUI_NUP_SIXTEENUP         64870
#define IDS_CPSUI_SIDE1                 64871
#define IDS_CPSUI_SIDE2                 64872
#define IDS_CPSUI_BOOKLET               64873

#if (NTDDI_VERSION >= NTDDI_VISTA)
//NOTE: remove these poster defines when removing poster feature.
#define IDS_CPSUI_POSTER                64874
#define IDS_CPSUI_POSTER_2x2            64875
#define IDS_CPSUI_POSTER_3x3            64876
#define IDS_CPSUI_POSTER_4x4            64877

#define IDS_CPSUI_NUP_DIRECTION         64878
#define IDS_CPSUI_RIGHT_THEN_DOWN       64879
#define IDS_CPSUI_DOWN_THEN_RIGHT       64880
#define IDS_CPSUI_LEFT_THEN_DOWN        64881
#define IDS_CPSUI_DOWN_THEN_LEFT        64882

//NOTE: remove these manual duplex defines when removing the feature.
#define IDS_CPSUI_MANUAL_DUPLEX         64883
#define IDS_CPSUI_MANUAL_DUPLEX_ON      64884
#define IDS_CPSUI_MANUAL_DUPLEX_OFF     64885

#define IDS_CPSUI_ROT_PORT              64886

//NOTE: remove this staple defines when removing the feature.
#define IDS_CPSUI_STAPLE                64887

#define IDS_CPSUI_BOOKLET_EDGE          64888
#define IDS_CPSUI_BOOKLET_EDGE_LEFT     64889
#define IDS_CPSUI_BOOKLET_EDGE_RIGHT    64890
#define IDS_CPSUI_NUP_BORDER            64891
#define IDS_CPSUI_NUP_BORDERED          64892
#define IDS_CPSUI_STRID_LAST            64892
#else
#define IDS_CPSUI_STRID_LAST            64873
#endif


#ifdef __cplusplus
}
#endif

#endif      // _COMPSTUI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\control.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for control.odl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __control_h__
#define __control_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAMCollection_FWD_DEFINED__
#define __IAMCollection_FWD_DEFINED__
typedef interface IAMCollection IAMCollection;
#endif 	/* __IAMCollection_FWD_DEFINED__ */


#ifndef __IMediaControl_FWD_DEFINED__
#define __IMediaControl_FWD_DEFINED__
typedef interface IMediaControl IMediaControl;
#endif 	/* __IMediaControl_FWD_DEFINED__ */


#ifndef __IMediaEvent_FWD_DEFINED__
#define __IMediaEvent_FWD_DEFINED__
typedef interface IMediaEvent IMediaEvent;
#endif 	/* __IMediaEvent_FWD_DEFINED__ */


#ifndef __IMediaEventEx_FWD_DEFINED__
#define __IMediaEventEx_FWD_DEFINED__
typedef interface IMediaEventEx IMediaEventEx;
#endif 	/* __IMediaEventEx_FWD_DEFINED__ */


#ifndef __IMediaPosition_FWD_DEFINED__
#define __IMediaPosition_FWD_DEFINED__
typedef interface IMediaPosition IMediaPosition;
#endif 	/* __IMediaPosition_FWD_DEFINED__ */


#ifndef __IBasicAudio_FWD_DEFINED__
#define __IBasicAudio_FWD_DEFINED__
typedef interface IBasicAudio IBasicAudio;
#endif 	/* __IBasicAudio_FWD_DEFINED__ */


#ifndef __IVideoWindow_FWD_DEFINED__
#define __IVideoWindow_FWD_DEFINED__
typedef interface IVideoWindow IVideoWindow;
#endif 	/* __IVideoWindow_FWD_DEFINED__ */


#ifndef __IBasicVideo_FWD_DEFINED__
#define __IBasicVideo_FWD_DEFINED__
typedef interface IBasicVideo IBasicVideo;
#endif 	/* __IBasicVideo_FWD_DEFINED__ */


#ifndef __IBasicVideo2_FWD_DEFINED__
#define __IBasicVideo2_FWD_DEFINED__
typedef interface IBasicVideo2 IBasicVideo2;
#endif 	/* __IBasicVideo2_FWD_DEFINED__ */


#ifndef __IDeferredCommand_FWD_DEFINED__
#define __IDeferredCommand_FWD_DEFINED__
typedef interface IDeferredCommand IDeferredCommand;
#endif 	/* __IDeferredCommand_FWD_DEFINED__ */


#ifndef __IQueueCommand_FWD_DEFINED__
#define __IQueueCommand_FWD_DEFINED__
typedef interface IQueueCommand IQueueCommand;
#endif 	/* __IQueueCommand_FWD_DEFINED__ */


#ifndef __FilgraphManager_FWD_DEFINED__
#define __FilgraphManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class FilgraphManager FilgraphManager;
#else
typedef struct FilgraphManager FilgraphManager;
#endif /* __cplusplus */

#endif 	/* __FilgraphManager_FWD_DEFINED__ */


#ifndef __IFilterInfo_FWD_DEFINED__
#define __IFilterInfo_FWD_DEFINED__
typedef interface IFilterInfo IFilterInfo;
#endif 	/* __IFilterInfo_FWD_DEFINED__ */


#ifndef __IRegFilterInfo_FWD_DEFINED__
#define __IRegFilterInfo_FWD_DEFINED__
typedef interface IRegFilterInfo IRegFilterInfo;
#endif 	/* __IRegFilterInfo_FWD_DEFINED__ */


#ifndef __IMediaTypeInfo_FWD_DEFINED__
#define __IMediaTypeInfo_FWD_DEFINED__
typedef interface IMediaTypeInfo IMediaTypeInfo;
#endif 	/* __IMediaTypeInfo_FWD_DEFINED__ */


#ifndef __IPinInfo_FWD_DEFINED__
#define __IPinInfo_FWD_DEFINED__
typedef interface IPinInfo IPinInfo;
#endif 	/* __IPinInfo_FWD_DEFINED__ */


#ifndef __IAMStats_FWD_DEFINED__
#define __IAMStats_FWD_DEFINED__
typedef interface IAMStats IAMStats;
#endif 	/* __IAMStats_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __QuartzTypeLib_LIBRARY_DEFINED__
#define __QuartzTypeLib_LIBRARY_DEFINED__

/* library QuartzTypeLib */
/* [version][lcid][helpstring][uuid] */ 

typedef double REFTIME;

typedef LONG_PTR OAEVENT;

typedef LONG_PTR OAHWND;

typedef long OAFilterState;


DEFINE_GUID(LIBID_QuartzTypeLib,0x56a868b0,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifndef __IAMCollection_INTERFACE_DEFINED__
#define __IAMCollection_INTERFACE_DEFINED__

/* interface IAMCollection */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMCollection,0x56a868b9,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b9-0ad4-11ce-b03a-0020af0ba770")
    IAMCollection : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long lItem,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IAMCollection * This,
            /* [retval][out] */ __RPC__out LONG *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IAMCollection * This,
            /* [in] */ long lItem,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IAMCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppUnk);
        
        END_INTERFACE
    } IAMCollectionVtbl;

    interface IAMCollection
    {
        CONST_VTBL struct IAMCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMCollection_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IAMCollection_Item(This,lItem,ppUnk)	\
    ( (This)->lpVtbl -> Item(This,lItem,ppUnk) ) 

#define IAMCollection_get__NewEnum(This,ppUnk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMCollection_INTERFACE_DEFINED__ */


#ifndef __IMediaControl_INTERFACE_DEFINED__
#define __IMediaControl_INTERFACE_DEFINED__

/* interface IMediaControl */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaControl,0x56a868b1,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b1-0ad4-11ce-b03a-0020af0ba770")
    IMediaControl : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ LONG msTimeout,
            /* [out] */ __RPC__out OAFilterState *pfs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderFile( 
            /* [in] */ __RPC__in BSTR strFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSourceFilter( 
            /* [in] */ __RPC__in BSTR strFilename,
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterCollection( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RegFilterCollection( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopWhenReady( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaControl * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMediaControl * This,
            /* [in] */ LONG msTimeout,
            /* [out] */ __RPC__out OAFilterState *pfs);
        
        HRESULT ( STDMETHODCALLTYPE *RenderFile )( 
            IMediaControl * This,
            /* [in] */ __RPC__in BSTR strFilename);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilter )( 
            IMediaControl * This,
            /* [in] */ __RPC__in BSTR strFilename,
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterCollection )( 
            IMediaControl * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegFilterCollection )( 
            IMediaControl * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *StopWhenReady )( 
            IMediaControl * This);
        
        END_INTERFACE
    } IMediaControlVtbl;

    interface IMediaControl
    {
        CONST_VTBL struct IMediaControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaControl_Run(This)	\
    ( (This)->lpVtbl -> Run(This) ) 

#define IMediaControl_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMediaControl_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMediaControl_GetState(This,msTimeout,pfs)	\
    ( (This)->lpVtbl -> GetState(This,msTimeout,pfs) ) 

#define IMediaControl_RenderFile(This,strFilename)	\
    ( (This)->lpVtbl -> RenderFile(This,strFilename) ) 

#define IMediaControl_AddSourceFilter(This,strFilename,ppUnk)	\
    ( (This)->lpVtbl -> AddSourceFilter(This,strFilename,ppUnk) ) 

#define IMediaControl_get_FilterCollection(This,ppUnk)	\
    ( (This)->lpVtbl -> get_FilterCollection(This,ppUnk) ) 

#define IMediaControl_get_RegFilterCollection(This,ppUnk)	\
    ( (This)->lpVtbl -> get_RegFilterCollection(This,ppUnk) ) 

#define IMediaControl_StopWhenReady(This)	\
    ( (This)->lpVtbl -> StopWhenReady(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaControl_INTERFACE_DEFINED__ */


#ifndef __IMediaEvent_INTERFACE_DEFINED__
#define __IMediaEvent_INTERFACE_DEFINED__

/* interface IMediaEvent */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaEvent,0x56a868b6,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b6-0ad4-11ce-b03a-0020af0ba770")
    IMediaEvent : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventHandle( 
            /* [out] */ __RPC__out OAEVENT *hEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [out] */ __RPC__out long *lEventCode,
            /* [out] */ __RPC__out LONG_PTR *lParam1,
            /* [out] */ __RPC__out LONG_PTR *lParam2,
            /* [in] */ long msTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForCompletion( 
            /* [in] */ long msTimeout,
            /* [out] */ __RPC__out long *pEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelDefaultHandling( 
            /* [in] */ long lEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreDefaultHandling( 
            /* [in] */ long lEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeEventParams( 
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventHandle )( 
            IMediaEvent * This,
            /* [out] */ __RPC__out OAEVENT *hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMediaEvent * This,
            /* [out] */ __RPC__out long *lEventCode,
            /* [out] */ __RPC__out LONG_PTR *lParam1,
            /* [out] */ __RPC__out LONG_PTR *lParam2,
            /* [in] */ long msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IMediaEvent * This,
            /* [in] */ long msTimeout,
            /* [out] */ __RPC__out long *pEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDefaultHandling )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultHandling )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *FreeEventParams )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2);
        
        END_INTERFACE
    } IMediaEventVtbl;

    interface IMediaEvent
    {
        CONST_VTBL struct IMediaEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaEvent_GetEventHandle(This,hEvent)	\
    ( (This)->lpVtbl -> GetEventHandle(This,hEvent) ) 

#define IMediaEvent_GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)	\
    ( (This)->lpVtbl -> GetEvent(This,lEventCode,lParam1,lParam2,msTimeout) ) 

#define IMediaEvent_WaitForCompletion(This,msTimeout,pEvCode)	\
    ( (This)->lpVtbl -> WaitForCompletion(This,msTimeout,pEvCode) ) 

#define IMediaEvent_CancelDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> CancelDefaultHandling(This,lEvCode) ) 

#define IMediaEvent_RestoreDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> RestoreDefaultHandling(This,lEvCode) ) 

#define IMediaEvent_FreeEventParams(This,lEvCode,lParam1,lParam2)	\
    ( (This)->lpVtbl -> FreeEventParams(This,lEvCode,lParam1,lParam2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaEvent_INTERFACE_DEFINED__ */


#ifndef __IMediaEventEx_INTERFACE_DEFINED__
#define __IMediaEventEx_INTERFACE_DEFINED__

/* interface IMediaEventEx */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaEventEx,0x56a868c0,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868c0-0ad4-11ce-b03a-0020af0ba770")
    IMediaEventEx : public IMediaEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNotifyWindow( 
            /* [in] */ OAHWND hwnd,
            /* [in] */ long lMsg,
            /* [in] */ LONG_PTR lInstanceData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotifyFlags( 
            /* [in] */ long lNoNotifyFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNotifyFlags( 
            /* [out] */ __RPC__out long *lplNoNotifyFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEventEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEventEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEventEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaEventEx * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaEventEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaEventEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaEventEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventHandle )( 
            IMediaEventEx * This,
            /* [out] */ __RPC__out OAEVENT *hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMediaEventEx * This,
            /* [out] */ __RPC__out long *lEventCode,
            /* [out] */ __RPC__out LONG_PTR *lParam1,
            /* [out] */ __RPC__out LONG_PTR *lParam2,
            /* [in] */ long msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IMediaEventEx * This,
            /* [in] */ long msTimeout,
            /* [out] */ __RPC__out long *pEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDefaultHandling )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultHandling )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *FreeEventParams )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyWindow )( 
            IMediaEventEx * This,
            /* [in] */ OAHWND hwnd,
            /* [in] */ long lMsg,
            /* [in] */ LONG_PTR lInstanceData);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyFlags )( 
            IMediaEventEx * This,
            /* [in] */ long lNoNotifyFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetNotifyFlags )( 
            IMediaEventEx * This,
            /* [out] */ __RPC__out long *lplNoNotifyFlags);
        
        END_INTERFACE
    } IMediaEventExVtbl;

    interface IMediaEventEx
    {
        CONST_VTBL struct IMediaEventExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEventEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaEventEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaEventEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaEventEx_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaEventEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaEventEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaEventEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaEventEx_GetEventHandle(This,hEvent)	\
    ( (This)->lpVtbl -> GetEventHandle(This,hEvent) ) 

#define IMediaEventEx_GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)	\
    ( (This)->lpVtbl -> GetEvent(This,lEventCode,lParam1,lParam2,msTimeout) ) 

#define IMediaEventEx_WaitForCompletion(This,msTimeout,pEvCode)	\
    ( (This)->lpVtbl -> WaitForCompletion(This,msTimeout,pEvCode) ) 

#define IMediaEventEx_CancelDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> CancelDefaultHandling(This,lEvCode) ) 

#define IMediaEventEx_RestoreDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> RestoreDefaultHandling(This,lEvCode) ) 

#define IMediaEventEx_FreeEventParams(This,lEvCode,lParam1,lParam2)	\
    ( (This)->lpVtbl -> FreeEventParams(This,lEvCode,lParam1,lParam2) ) 


#define IMediaEventEx_SetNotifyWindow(This,hwnd,lMsg,lInstanceData)	\
    ( (This)->lpVtbl -> SetNotifyWindow(This,hwnd,lMsg,lInstanceData) ) 

#define IMediaEventEx_SetNotifyFlags(This,lNoNotifyFlags)	\
    ( (This)->lpVtbl -> SetNotifyFlags(This,lNoNotifyFlags) ) 

#define IMediaEventEx_GetNotifyFlags(This,lplNoNotifyFlags)	\
    ( (This)->lpVtbl -> GetNotifyFlags(This,lplNoNotifyFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaEventEx_INTERFACE_DEFINED__ */


#ifndef __IMediaPosition_INTERFACE_DEFINED__
#define __IMediaPosition_INTERFACE_DEFINED__

/* interface IMediaPosition */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaPosition,0x56a868b2,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b2-0ad4-11ce-b03a-0020af0ba770")
    IMediaPosition : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ __RPC__out REFTIME *plength) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ __RPC__out REFTIME *pllTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ __RPC__out REFTIME *pllTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrerollTime( 
            /* [retval][out] */ __RPC__out REFTIME *pllTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PrerollTime( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double dRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ __RPC__out double *pdRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSeekForward( 
            /* [retval][out] */ __RPC__out LONG *pCanSeekForward) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSeekBackward( 
            /* [retval][out] */ __RPC__out LONG *pCanSeekBackward) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaPosition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaPosition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaPosition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaPosition * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaPosition * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaPosition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaPosition * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out REFTIME *plength);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out REFTIME *pllTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out REFTIME *pllTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrerollTime )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out REFTIME *pllTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrerollTime )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMediaPosition * This,
            /* [in] */ double dRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *CanSeekForward )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out LONG *pCanSeekForward);
        
        HRESULT ( STDMETHODCALLTYPE *CanSeekBackward )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out LONG *pCanSeekBackward);
        
        END_INTERFACE
    } IMediaPositionVtbl;

    interface IMediaPosition
    {
        CONST_VTBL struct IMediaPositionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPosition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaPosition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaPosition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaPosition_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaPosition_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaPosition_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaPosition_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaPosition_get_Duration(This,plength)	\
    ( (This)->lpVtbl -> get_Duration(This,plength) ) 

#define IMediaPosition_put_CurrentPosition(This,llTime)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,llTime) ) 

#define IMediaPosition_get_CurrentPosition(This,pllTime)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pllTime) ) 

#define IMediaPosition_get_StopTime(This,pllTime)	\
    ( (This)->lpVtbl -> get_StopTime(This,pllTime) ) 

#define IMediaPosition_put_StopTime(This,llTime)	\
    ( (This)->lpVtbl -> put_StopTime(This,llTime) ) 

#define IMediaPosition_get_PrerollTime(This,pllTime)	\
    ( (This)->lpVtbl -> get_PrerollTime(This,pllTime) ) 

#define IMediaPosition_put_PrerollTime(This,llTime)	\
    ( (This)->lpVtbl -> put_PrerollTime(This,llTime) ) 

#define IMediaPosition_put_Rate(This,dRate)	\
    ( (This)->lpVtbl -> put_Rate(This,dRate) ) 

#define IMediaPosition_get_Rate(This,pdRate)	\
    ( (This)->lpVtbl -> get_Rate(This,pdRate) ) 

#define IMediaPosition_CanSeekForward(This,pCanSeekForward)	\
    ( (This)->lpVtbl -> CanSeekForward(This,pCanSeekForward) ) 

#define IMediaPosition_CanSeekBackward(This,pCanSeekBackward)	\
    ( (This)->lpVtbl -> CanSeekBackward(This,pCanSeekBackward) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaPosition_INTERFACE_DEFINED__ */


#ifndef __IBasicAudio_INTERFACE_DEFINED__
#define __IBasicAudio_INTERFACE_DEFINED__

/* interface IBasicAudio */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicAudio,0x56a868b3,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b3-0ad4-11ce-b03a-0020af0ba770")
    IBasicAudio : public IDispatch
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long lVolume) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ __RPC__out long *plVolume) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long lBalance) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ __RPC__out long *plBalance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicAudioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicAudio * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicAudio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicAudio * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicAudio * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicAudio * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicAudio * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicAudio * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IBasicAudio * This,
            /* [in] */ long lVolume);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IBasicAudio * This,
            /* [retval][out] */ __RPC__out long *plVolume);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IBasicAudio * This,
            /* [in] */ long lBalance);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IBasicAudio * This,
            /* [retval][out] */ __RPC__out long *plBalance);
        
        END_INTERFACE
    } IBasicAudioVtbl;

    interface IBasicAudio
    {
        CONST_VTBL struct IBasicAudioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicAudio_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBasicAudio_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBasicAudio_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBasicAudio_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBasicAudio_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBasicAudio_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBasicAudio_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBasicAudio_put_Volume(This,lVolume)	\
    ( (This)->lpVtbl -> put_Volume(This,lVolume) ) 

#define IBasicAudio_get_Volume(This,plVolume)	\
    ( (This)->lpVtbl -> get_Volume(This,plVolume) ) 

#define IBasicAudio_put_Balance(This,lBalance)	\
    ( (This)->lpVtbl -> put_Balance(This,lBalance) ) 

#define IBasicAudio_get_Balance(This,plBalance)	\
    ( (This)->lpVtbl -> get_Balance(This,plBalance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBasicAudio_INTERFACE_DEFINED__ */


#ifndef __IVideoWindow_INTERFACE_DEFINED__
#define __IVideoWindow_INTERFACE_DEFINED__

/* interface IVideoWindow */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IVideoWindow,0x56a868b4,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b4-0ad4-11ce-b03a-0020af0ba770")
    IVideoWindow : public IDispatch
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ __RPC__in BSTR strCaption) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strCaption) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowStyle( 
            /* [in] */ long WindowStyle) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowStyle( 
            /* [retval][out] */ __RPC__out long *WindowStyle) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowStyleEx( 
            /* [in] */ long WindowStyleEx) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowStyleEx( 
            /* [retval][out] */ __RPC__out long *WindowStyleEx) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AutoShow( 
            /* [in] */ long AutoShow) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AutoShow( 
            /* [retval][out] */ __RPC__out long *AutoShow) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowState( 
            /* [in] */ long WindowState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowState( 
            /* [retval][out] */ __RPC__out long *WindowState) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BackgroundPalette( 
            /* [in] */ long BackgroundPalette) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BackgroundPalette( 
            /* [retval][out] */ __RPC__out long *pBackgroundPalette) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ long Visible) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ __RPC__out long *pVisible) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long Left) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ __RPC__out long *pLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long Width) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ __RPC__out long *pWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long Top) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ __RPC__out long *pTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long Height) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ __RPC__out long *pHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Owner( 
            /* [in] */ OAHWND Owner) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Owner( 
            /* [retval][out] */ __RPC__out OAHWND *Owner) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MessageDrain( 
            /* [in] */ OAHWND Drain) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MessageDrain( 
            /* [retval][out] */ __RPC__out OAHWND *Drain) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BorderColor( 
            /* [retval][out] */ __RPC__out long *Color) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BorderColor( 
            /* [in] */ long Color) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FullScreenMode( 
            /* [retval][out] */ __RPC__out long *FullScreenMode) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FullScreenMode( 
            /* [in] */ long FullScreenMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowForeground( 
            /* [in] */ long Focus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOwnerMessage( 
            /* [in] */ OAHWND hwnd,
            /* [in] */ long uMsg,
            /* [in] */ LONG_PTR wParam,
            /* [in] */ LONG_PTR lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowPosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindowPosition( 
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinIdealImageSize( 
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxIdealImageSize( 
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRestorePosition( 
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideCursor( 
            /* [in] */ long HideCursor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCursorHidden( 
            /* [out] */ __RPC__out long *CursorHidden) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVideoWindow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVideoWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVideoWindow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Caption )( 
            IVideoWindow * This,
            /* [in] */ __RPC__in BSTR strCaption);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Caption )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strCaption);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowStyle )( 
            IVideoWindow * This,
            /* [in] */ long WindowStyle);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowStyle )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *WindowStyle);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowStyleEx )( 
            IVideoWindow * This,
            /* [in] */ long WindowStyleEx);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowStyleEx )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *WindowStyleEx);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoShow )( 
            IVideoWindow * This,
            /* [in] */ long AutoShow);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoShow )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *AutoShow);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowState )( 
            IVideoWindow * This,
            /* [in] */ long WindowState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowState )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *WindowState);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackgroundPalette )( 
            IVideoWindow * This,
            /* [in] */ long BackgroundPalette);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackgroundPalette )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pBackgroundPalette);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IVideoWindow * This,
            /* [in] */ long Visible);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pVisible);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            IVideoWindow * This,
            /* [in] */ long Left);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IVideoWindow * This,
            /* [in] */ long Width);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Top )( 
            IVideoWindow * This,
            /* [in] */ long Top);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Top )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            IVideoWindow * This,
            /* [in] */ long Height);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Owner )( 
            IVideoWindow * This,
            /* [in] */ OAHWND Owner);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Owner )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out OAHWND *Owner);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageDrain )( 
            IVideoWindow * This,
            /* [in] */ OAHWND Drain);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageDrain )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out OAHWND *Drain);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderColor )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *Color);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderColor )( 
            IVideoWindow * This,
            /* [in] */ long Color);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullScreenMode )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *FullScreenMode);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FullScreenMode )( 
            IVideoWindow * This,
            /* [in] */ long FullScreenMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowForeground )( 
            IVideoWindow * This,
            /* [in] */ long Focus);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOwnerMessage )( 
            IVideoWindow * This,
            /* [in] */ OAHWND hwnd,
            /* [in] */ long uMsg,
            /* [in] */ LONG_PTR wParam,
            /* [in] */ LONG_PTR lParam);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowPosition )( 
            IVideoWindow * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowPosition )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinIdealImageSize )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxIdealImageSize )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetRestorePosition )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *HideCursor )( 
            IVideoWindow * This,
            /* [in] */ long HideCursor);
        
        HRESULT ( STDMETHODCALLTYPE *IsCursorHidden )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out long *CursorHidden);
        
        END_INTERFACE
    } IVideoWindowVtbl;

    interface IVideoWindow
    {
        CONST_VTBL struct IVideoWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVideoWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVideoWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVideoWindow_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVideoWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVideoWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVideoWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVideoWindow_put_Caption(This,strCaption)	\
    ( (This)->lpVtbl -> put_Caption(This,strCaption) ) 

#define IVideoWindow_get_Caption(This,strCaption)	\
    ( (This)->lpVtbl -> get_Caption(This,strCaption) ) 

#define IVideoWindow_put_WindowStyle(This,WindowStyle)	\
    ( (This)->lpVtbl -> put_WindowStyle(This,WindowStyle) ) 

#define IVideoWindow_get_WindowStyle(This,WindowStyle)	\
    ( (This)->lpVtbl -> get_WindowStyle(This,WindowStyle) ) 

#define IVideoWindow_put_WindowStyleEx(This,WindowStyleEx)	\
    ( (This)->lpVtbl -> put_WindowStyleEx(This,WindowStyleEx) ) 

#define IVideoWindow_get_WindowStyleEx(This,WindowStyleEx)	\
    ( (This)->lpVtbl -> get_WindowStyleEx(This,WindowStyleEx) ) 

#define IVideoWindow_put_AutoShow(This,AutoShow)	\
    ( (This)->lpVtbl -> put_AutoShow(This,AutoShow) ) 

#define IVideoWindow_get_AutoShow(This,AutoShow)	\
    ( (This)->lpVtbl -> get_AutoShow(This,AutoShow) ) 

#define IVideoWindow_put_WindowState(This,WindowState)	\
    ( (This)->lpVtbl -> put_WindowState(This,WindowState) ) 

#define IVideoWindow_get_WindowState(This,WindowState)	\
    ( (This)->lpVtbl -> get_WindowState(This,WindowState) ) 

#define IVideoWindow_put_BackgroundPalette(This,BackgroundPalette)	\
    ( (This)->lpVtbl -> put_BackgroundPalette(This,BackgroundPalette) ) 

#define IVideoWindow_get_BackgroundPalette(This,pBackgroundPalette)	\
    ( (This)->lpVtbl -> get_BackgroundPalette(This,pBackgroundPalette) ) 

#define IVideoWindow_put_Visible(This,Visible)	\
    ( (This)->lpVtbl -> put_Visible(This,Visible) ) 

#define IVideoWindow_get_Visible(This,pVisible)	\
    ( (This)->lpVtbl -> get_Visible(This,pVisible) ) 

#define IVideoWindow_put_Left(This,Left)	\
    ( (This)->lpVtbl -> put_Left(This,Left) ) 

#define IVideoWindow_get_Left(This,pLeft)	\
    ( (This)->lpVtbl -> get_Left(This,pLeft) ) 

#define IVideoWindow_put_Width(This,Width)	\
    ( (This)->lpVtbl -> put_Width(This,Width) ) 

#define IVideoWindow_get_Width(This,pWidth)	\
    ( (This)->lpVtbl -> get_Width(This,pWidth) ) 

#define IVideoWindow_put_Top(This,Top)	\
    ( (This)->lpVtbl -> put_Top(This,Top) ) 

#define IVideoWindow_get_Top(This,pTop)	\
    ( (This)->lpVtbl -> get_Top(This,pTop) ) 

#define IVideoWindow_put_Height(This,Height)	\
    ( (This)->lpVtbl -> put_Height(This,Height) ) 

#define IVideoWindow_get_Height(This,pHeight)	\
    ( (This)->lpVtbl -> get_Height(This,pHeight) ) 

#define IVideoWindow_put_Owner(This,Owner)	\
    ( (This)->lpVtbl -> put_Owner(This,Owner) ) 

#define IVideoWindow_get_Owner(This,Owner)	\
    ( (This)->lpVtbl -> get_Owner(This,Owner) ) 

#define IVideoWindow_put_MessageDrain(This,Drain)	\
    ( (This)->lpVtbl -> put_MessageDrain(This,Drain) ) 

#define IVideoWindow_get_MessageDrain(This,Drain)	\
    ( (This)->lpVtbl -> get_MessageDrain(This,Drain) ) 

#define IVideoWindow_get_BorderColor(This,Color)	\
    ( (This)->lpVtbl -> get_BorderColor(This,Color) ) 

#define IVideoWindow_put_BorderColor(This,Color)	\
    ( (This)->lpVtbl -> put_BorderColor(This,Color) ) 

#define IVideoWindow_get_FullScreenMode(This,FullScreenMode)	\
    ( (This)->lpVtbl -> get_FullScreenMode(This,FullScreenMode) ) 

#define IVideoWindow_put_FullScreenMode(This,FullScreenMode)	\
    ( (This)->lpVtbl -> put_FullScreenMode(This,FullScreenMode) ) 

#define IVideoWindow_SetWindowForeground(This,Focus)	\
    ( (This)->lpVtbl -> SetWindowForeground(This,Focus) ) 

#define IVideoWindow_NotifyOwnerMessage(This,hwnd,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> NotifyOwnerMessage(This,hwnd,uMsg,wParam,lParam) ) 

#define IVideoWindow_SetWindowPosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetWindowPosition(This,Left,Top,Width,Height) ) 

#define IVideoWindow_GetWindowPosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetWindowPosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IVideoWindow_GetMinIdealImageSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetMinIdealImageSize(This,pWidth,pHeight) ) 

#define IVideoWindow_GetMaxIdealImageSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetMaxIdealImageSize(This,pWidth,pHeight) ) 

#define IVideoWindow_GetRestorePosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetRestorePosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IVideoWindow_HideCursor(This,HideCursor)	\
    ( (This)->lpVtbl -> HideCursor(This,HideCursor) ) 

#define IVideoWindow_IsCursorHidden(This,CursorHidden)	\
    ( (This)->lpVtbl -> IsCursorHidden(This,CursorHidden) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVideoWindow_INTERFACE_DEFINED__ */


#ifndef __IBasicVideo_INTERFACE_DEFINED__
#define __IBasicVideo_INTERFACE_DEFINED__

/* interface IBasicVideo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicVideo,0x56a868b5,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b5-0ad4-11ce-b03a-0020af0ba770")
    IBasicVideo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AvgTimePerFrame( 
            /* [retval][out] */ __RPC__out REFTIME *pAvgTimePerFrame) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitRate( 
            /* [retval][out] */ __RPC__out long *pBitRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitErrorRate( 
            /* [retval][out] */ __RPC__out long *pBitErrorRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VideoWidth( 
            /* [retval][out] */ __RPC__out long *pVideoWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VideoHeight( 
            /* [retval][out] */ __RPC__out long *pVideoHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceLeft( 
            /* [in] */ long SourceLeft) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceLeft( 
            /* [retval][out] */ __RPC__out long *pSourceLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceWidth( 
            /* [in] */ long SourceWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceWidth( 
            /* [retval][out] */ __RPC__out long *pSourceWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceTop( 
            /* [in] */ long SourceTop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceTop( 
            /* [retval][out] */ __RPC__out long *pSourceTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceHeight( 
            /* [in] */ long SourceHeight) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceHeight( 
            /* [retval][out] */ __RPC__out long *pSourceHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationLeft( 
            /* [in] */ long DestinationLeft) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationLeft( 
            /* [retval][out] */ __RPC__out long *pDestinationLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationWidth( 
            /* [in] */ long DestinationWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationWidth( 
            /* [retval][out] */ __RPC__out long *pDestinationWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationTop( 
            /* [in] */ long DestinationTop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationTop( 
            /* [retval][out] */ __RPC__out long *pDestinationTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationHeight( 
            /* [in] */ long DestinationHeight) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationHeight( 
            /* [retval][out] */ __RPC__out long *pDestinationHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSourcePosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition( 
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultSourcePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDestinationPosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestinationPosition( 
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultDestinationPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoSize( 
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPaletteEntries( 
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ __RPC__out long *pRetrieved,
            /* [out] */ __RPC__out long *pPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentImage( 
            /* [out][in] */ __RPC__inout long *pBufferSize,
            /* [out] */ __RPC__out long *pDIBImage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingDefaultSource( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingDefaultDestination( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicVideoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicVideo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicVideo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicVideo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicVideo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicVideo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicVideo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgTimePerFrame )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out REFTIME *pAvgTimePerFrame);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pBitRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitErrorRate )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pBitErrorRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pVideoWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pVideoHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceLeft )( 
            IBasicVideo * This,
            /* [in] */ long SourceLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLeft )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pSourceLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceWidth )( 
            IBasicVideo * This,
            /* [in] */ long SourceWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pSourceWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceTop )( 
            IBasicVideo * This,
            /* [in] */ long SourceTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceTop )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pSourceTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceHeight )( 
            IBasicVideo * This,
            /* [in] */ long SourceHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pSourceHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationLeft )( 
            IBasicVideo * This,
            /* [in] */ long DestinationLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationLeft )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pDestinationLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationWidth )( 
            IBasicVideo * This,
            /* [in] */ long DestinationWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pDestinationWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationTop )( 
            IBasicVideo * This,
            /* [in] */ long DestinationTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationTop )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pDestinationTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationHeight )( 
            IBasicVideo * This,
            /* [in] */ long DestinationHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pDestinationHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourcePosition )( 
            IBasicVideo * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IBasicVideo * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSourcePosition )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationPosition )( 
            IBasicVideo * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationPosition )( 
            IBasicVideo * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultDestinationPosition )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoSize )( 
            IBasicVideo * This,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPaletteEntries )( 
            IBasicVideo * This,
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ __RPC__out long *pRetrieved,
            /* [out] */ __RPC__out long *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IBasicVideo * This,
            /* [out][in] */ __RPC__inout long *pBufferSize,
            /* [out] */ __RPC__out long *pDIBImage);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultSource )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultDestination )( 
            IBasicVideo * This);
        
        END_INTERFACE
    } IBasicVideoVtbl;

    interface IBasicVideo
    {
        CONST_VTBL struct IBasicVideoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicVideo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBasicVideo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBasicVideo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBasicVideo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBasicVideo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBasicVideo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBasicVideo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBasicVideo_get_AvgTimePerFrame(This,pAvgTimePerFrame)	\
    ( (This)->lpVtbl -> get_AvgTimePerFrame(This,pAvgTimePerFrame) ) 

#define IBasicVideo_get_BitRate(This,pBitRate)	\
    ( (This)->lpVtbl -> get_BitRate(This,pBitRate) ) 

#define IBasicVideo_get_BitErrorRate(This,pBitErrorRate)	\
    ( (This)->lpVtbl -> get_BitErrorRate(This,pBitErrorRate) ) 

#define IBasicVideo_get_VideoWidth(This,pVideoWidth)	\
    ( (This)->lpVtbl -> get_VideoWidth(This,pVideoWidth) ) 

#define IBasicVideo_get_VideoHeight(This,pVideoHeight)	\
    ( (This)->lpVtbl -> get_VideoHeight(This,pVideoHeight) ) 

#define IBasicVideo_put_SourceLeft(This,SourceLeft)	\
    ( (This)->lpVtbl -> put_SourceLeft(This,SourceLeft) ) 

#define IBasicVideo_get_SourceLeft(This,pSourceLeft)	\
    ( (This)->lpVtbl -> get_SourceLeft(This,pSourceLeft) ) 

#define IBasicVideo_put_SourceWidth(This,SourceWidth)	\
    ( (This)->lpVtbl -> put_SourceWidth(This,SourceWidth) ) 

#define IBasicVideo_get_SourceWidth(This,pSourceWidth)	\
    ( (This)->lpVtbl -> get_SourceWidth(This,pSourceWidth) ) 

#define IBasicVideo_put_SourceTop(This,SourceTop)	\
    ( (This)->lpVtbl -> put_SourceTop(This,SourceTop) ) 

#define IBasicVideo_get_SourceTop(This,pSourceTop)	\
    ( (This)->lpVtbl -> get_SourceTop(This,pSourceTop) ) 

#define IBasicVideo_put_SourceHeight(This,SourceHeight)	\
    ( (This)->lpVtbl -> put_SourceHeight(This,SourceHeight) ) 

#define IBasicVideo_get_SourceHeight(This,pSourceHeight)	\
    ( (This)->lpVtbl -> get_SourceHeight(This,pSourceHeight) ) 

#define IBasicVideo_put_DestinationLeft(This,DestinationLeft)	\
    ( (This)->lpVtbl -> put_DestinationLeft(This,DestinationLeft) ) 

#define IBasicVideo_get_DestinationLeft(This,pDestinationLeft)	\
    ( (This)->lpVtbl -> get_DestinationLeft(This,pDestinationLeft) ) 

#define IBasicVideo_put_DestinationWidth(This,DestinationWidth)	\
    ( (This)->lpVtbl -> put_DestinationWidth(This,DestinationWidth) ) 

#define IBasicVideo_get_DestinationWidth(This,pDestinationWidth)	\
    ( (This)->lpVtbl -> get_DestinationWidth(This,pDestinationWidth) ) 

#define IBasicVideo_put_DestinationTop(This,DestinationTop)	\
    ( (This)->lpVtbl -> put_DestinationTop(This,DestinationTop) ) 

#define IBasicVideo_get_DestinationTop(This,pDestinationTop)	\
    ( (This)->lpVtbl -> get_DestinationTop(This,pDestinationTop) ) 

#define IBasicVideo_put_DestinationHeight(This,DestinationHeight)	\
    ( (This)->lpVtbl -> put_DestinationHeight(This,DestinationHeight) ) 

#define IBasicVideo_get_DestinationHeight(This,pDestinationHeight)	\
    ( (This)->lpVtbl -> get_DestinationHeight(This,pDestinationHeight) ) 

#define IBasicVideo_SetSourcePosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetSourcePosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo_GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetSourcePosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo_SetDefaultSourcePosition(This)	\
    ( (This)->lpVtbl -> SetDefaultSourcePosition(This) ) 

#define IBasicVideo_SetDestinationPosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetDestinationPosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo_GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo_SetDefaultDestinationPosition(This)	\
    ( (This)->lpVtbl -> SetDefaultDestinationPosition(This) ) 

#define IBasicVideo_GetVideoSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetVideoSize(This,pWidth,pHeight) ) 

#define IBasicVideo_GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)	\
    ( (This)->lpVtbl -> GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette) ) 

#define IBasicVideo_GetCurrentImage(This,pBufferSize,pDIBImage)	\
    ( (This)->lpVtbl -> GetCurrentImage(This,pBufferSize,pDIBImage) ) 

#define IBasicVideo_IsUsingDefaultSource(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultSource(This) ) 

#define IBasicVideo_IsUsingDefaultDestination(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultDestination(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBasicVideo_INTERFACE_DEFINED__ */


#ifndef __IBasicVideo2_INTERFACE_DEFINED__
#define __IBasicVideo2_INTERFACE_DEFINED__

/* interface IBasicVideo2 */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicVideo2,0x329bb360,0xf6ea,0x11d1,0x90,0x38,0x00,0xa0,0xc9,0x69,0x72,0x98);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("329bb360-f6ea-11d1-9038-00a0c9697298")
    IBasicVideo2 : public IBasicVideo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPreferredAspectRatio( 
            /* [out] */ __RPC__out long *plAspectX,
            /* [out] */ __RPC__out long *plAspectY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicVideo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicVideo2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicVideo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicVideo2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicVideo2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicVideo2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicVideo2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgTimePerFrame )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out REFTIME *pAvgTimePerFrame);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pBitRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitErrorRate )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pBitErrorRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pVideoWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pVideoHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceLeft )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLeft )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pSourceLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceWidth )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pSourceWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceTop )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceTop )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pSourceTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceHeight )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pSourceHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationLeft )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationLeft )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pDestinationLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationWidth )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pDestinationWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationTop )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationTop )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pDestinationTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationHeight )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pDestinationHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourcePosition )( 
            IBasicVideo2 * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IBasicVideo2 * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSourcePosition )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationPosition )( 
            IBasicVideo2 * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationPosition )( 
            IBasicVideo2 * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultDestinationPosition )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoSize )( 
            IBasicVideo2 * This,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPaletteEntries )( 
            IBasicVideo2 * This,
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ __RPC__out long *pRetrieved,
            /* [out] */ __RPC__out long *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IBasicVideo2 * This,
            /* [out][in] */ __RPC__inout long *pBufferSize,
            /* [out] */ __RPC__out long *pDIBImage);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultSource )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultDestination )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferredAspectRatio )( 
            IBasicVideo2 * This,
            /* [out] */ __RPC__out long *plAspectX,
            /* [out] */ __RPC__out long *plAspectY);
        
        END_INTERFACE
    } IBasicVideo2Vtbl;

    interface IBasicVideo2
    {
        CONST_VTBL struct IBasicVideo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicVideo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBasicVideo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBasicVideo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBasicVideo2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBasicVideo2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBasicVideo2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBasicVideo2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBasicVideo2_get_AvgTimePerFrame(This,pAvgTimePerFrame)	\
    ( (This)->lpVtbl -> get_AvgTimePerFrame(This,pAvgTimePerFrame) ) 

#define IBasicVideo2_get_BitRate(This,pBitRate)	\
    ( (This)->lpVtbl -> get_BitRate(This,pBitRate) ) 

#define IBasicVideo2_get_BitErrorRate(This,pBitErrorRate)	\
    ( (This)->lpVtbl -> get_BitErrorRate(This,pBitErrorRate) ) 

#define IBasicVideo2_get_VideoWidth(This,pVideoWidth)	\
    ( (This)->lpVtbl -> get_VideoWidth(This,pVideoWidth) ) 

#define IBasicVideo2_get_VideoHeight(This,pVideoHeight)	\
    ( (This)->lpVtbl -> get_VideoHeight(This,pVideoHeight) ) 

#define IBasicVideo2_put_SourceLeft(This,SourceLeft)	\
    ( (This)->lpVtbl -> put_SourceLeft(This,SourceLeft) ) 

#define IBasicVideo2_get_SourceLeft(This,pSourceLeft)	\
    ( (This)->lpVtbl -> get_SourceLeft(This,pSourceLeft) ) 

#define IBasicVideo2_put_SourceWidth(This,SourceWidth)	\
    ( (This)->lpVtbl -> put_SourceWidth(This,SourceWidth) ) 

#define IBasicVideo2_get_SourceWidth(This,pSourceWidth)	\
    ( (This)->lpVtbl -> get_SourceWidth(This,pSourceWidth) ) 

#define IBasicVideo2_put_SourceTop(This,SourceTop)	\
    ( (This)->lpVtbl -> put_SourceTop(This,SourceTop) ) 

#define IBasicVideo2_get_SourceTop(This,pSourceTop)	\
    ( (This)->lpVtbl -> get_SourceTop(This,pSourceTop) ) 

#define IBasicVideo2_put_SourceHeight(This,SourceHeight)	\
    ( (This)->lpVtbl -> put_SourceHeight(This,SourceHeight) ) 

#define IBasicVideo2_get_SourceHeight(This,pSourceHeight)	\
    ( (This)->lpVtbl -> get_SourceHeight(This,pSourceHeight) ) 

#define IBasicVideo2_put_DestinationLeft(This,DestinationLeft)	\
    ( (This)->lpVtbl -> put_DestinationLeft(This,DestinationLeft) ) 

#define IBasicVideo2_get_DestinationLeft(This,pDestinationLeft)	\
    ( (This)->lpVtbl -> get_DestinationLeft(This,pDestinationLeft) ) 

#define IBasicVideo2_put_DestinationWidth(This,DestinationWidth)	\
    ( (This)->lpVtbl -> put_DestinationWidth(This,DestinationWidth) ) 

#define IBasicVideo2_get_DestinationWidth(This,pDestinationWidth)	\
    ( (This)->lpVtbl -> get_DestinationWidth(This,pDestinationWidth) ) 

#define IBasicVideo2_put_DestinationTop(This,DestinationTop)	\
    ( (This)->lpVtbl -> put_DestinationTop(This,DestinationTop) ) 

#define IBasicVideo2_get_DestinationTop(This,pDestinationTop)	\
    ( (This)->lpVtbl -> get_DestinationTop(This,pDestinationTop) ) 

#define IBasicVideo2_put_DestinationHeight(This,DestinationHeight)	\
    ( (This)->lpVtbl -> put_DestinationHeight(This,DestinationHeight) ) 

#define IBasicVideo2_get_DestinationHeight(This,pDestinationHeight)	\
    ( (This)->lpVtbl -> get_DestinationHeight(This,pDestinationHeight) ) 

#define IBasicVideo2_SetSourcePosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetSourcePosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo2_GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetSourcePosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo2_SetDefaultSourcePosition(This)	\
    ( (This)->lpVtbl -> SetDefaultSourcePosition(This) ) 

#define IBasicVideo2_SetDestinationPosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetDestinationPosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo2_GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo2_SetDefaultDestinationPosition(This)	\
    ( (This)->lpVtbl -> SetDefaultDestinationPosition(This) ) 

#define IBasicVideo2_GetVideoSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetVideoSize(This,pWidth,pHeight) ) 

#define IBasicVideo2_GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)	\
    ( (This)->lpVtbl -> GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette) ) 

#define IBasicVideo2_GetCurrentImage(This,pBufferSize,pDIBImage)	\
    ( (This)->lpVtbl -> GetCurrentImage(This,pBufferSize,pDIBImage) ) 

#define IBasicVideo2_IsUsingDefaultSource(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultSource(This) ) 

#define IBasicVideo2_IsUsingDefaultDestination(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultDestination(This) ) 


#define IBasicVideo2_GetPreferredAspectRatio(This,plAspectX,plAspectY)	\
    ( (This)->lpVtbl -> GetPreferredAspectRatio(This,plAspectX,plAspectY) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBasicVideo2_INTERFACE_DEFINED__ */


#ifndef __IDeferredCommand_INTERFACE_DEFINED__
#define __IDeferredCommand_INTERFACE_DEFINED__

/* interface IDeferredCommand */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IDeferredCommand,0x56a868b8,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b8-0ad4-11ce-b03a-0020af0ba770")
    IDeferredCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Confidence( 
            /* [out] */ __RPC__out LONG *pConfidence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Postpone( 
            /* [in] */ REFTIME newtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHResult( 
            /* [out] */ __RPC__out HRESULT *phrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeferredCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeferredCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeferredCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeferredCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IDeferredCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Confidence )( 
            IDeferredCommand * This,
            /* [out] */ __RPC__out LONG *pConfidence);
        
        HRESULT ( STDMETHODCALLTYPE *Postpone )( 
            IDeferredCommand * This,
            /* [in] */ REFTIME newtime);
        
        HRESULT ( STDMETHODCALLTYPE *GetHResult )( 
            IDeferredCommand * This,
            /* [out] */ __RPC__out HRESULT *phrResult);
        
        END_INTERFACE
    } IDeferredCommandVtbl;

    interface IDeferredCommand
    {
        CONST_VTBL struct IDeferredCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeferredCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeferredCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeferredCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeferredCommand_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IDeferredCommand_Confidence(This,pConfidence)	\
    ( (This)->lpVtbl -> Confidence(This,pConfidence) ) 

#define IDeferredCommand_Postpone(This,newtime)	\
    ( (This)->lpVtbl -> Postpone(This,newtime) ) 

#define IDeferredCommand_GetHResult(This,phrResult)	\
    ( (This)->lpVtbl -> GetHResult(This,phrResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeferredCommand_INTERFACE_DEFINED__ */


#ifndef __IQueueCommand_INTERFACE_DEFINED__
#define __IQueueCommand_INTERFACE_DEFINED__

/* interface IQueueCommand */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IQueueCommand,0x56a868b7,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b7-0ad4-11ce-b03a-0020af0ba770")
    IQueueCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvokeAtStreamTime( 
            /* [out] */ __RPC__deref_out_opt IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ __RPC__in GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ __RPC__in VARIANT *pDispParams,
            /* [out][in] */ __RPC__inout VARIANT *pvarResult,
            /* [out] */ __RPC__out short *puArgErr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeAtPresentationTime( 
            /* [out] */ __RPC__deref_out_opt IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ __RPC__in GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ __RPC__in VARIANT *pDispParams,
            /* [out][in] */ __RPC__inout VARIANT *pvarResult,
            /* [out] */ __RPC__out short *puArgErr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueueCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueueCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueueCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueueCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeAtStreamTime )( 
            IQueueCommand * This,
            /* [out] */ __RPC__deref_out_opt IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ __RPC__in GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ __RPC__in VARIANT *pDispParams,
            /* [out][in] */ __RPC__inout VARIANT *pvarResult,
            /* [out] */ __RPC__out short *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeAtPresentationTime )( 
            IQueueCommand * This,
            /* [out] */ __RPC__deref_out_opt IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ __RPC__in GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ __RPC__in VARIANT *pDispParams,
            /* [out][in] */ __RPC__inout VARIANT *pvarResult,
            /* [out] */ __RPC__out short *puArgErr);
        
        END_INTERFACE
    } IQueueCommandVtbl;

    interface IQueueCommand
    {
        CONST_VTBL struct IQueueCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueueCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueueCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueueCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueueCommand_InvokeAtStreamTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)	\
    ( (This)->lpVtbl -> InvokeAtStreamTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr) ) 

#define IQueueCommand_InvokeAtPresentationTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)	\
    ( (This)->lpVtbl -> InvokeAtPresentationTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueueCommand_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_FilgraphManager,0xe436ebb3,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifdef __cplusplus

class DECLSPEC_UUID("e436ebb3-524f-11ce-9f53-0020af0ba770")
FilgraphManager;
#endif

#ifndef __IFilterInfo_INTERFACE_DEFINED__
#define __IFilterInfo_INTERFACE_DEFINED__

/* interface IFilterInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IFilterInfo,0x56a868ba,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ba-0ad4-11ce-b03a-0020af0ba770")
    IFilterInfo : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindPin( 
            /* [in] */ __RPC__in BSTR strPinID,
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VendorInfo( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strVendorInfo) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Pins( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsFileSource( 
            /* [retval][out] */ __RPC__out LONG *pbIsSource) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Filename( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrFilename) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Filename( 
            /* [in] */ __RPC__in BSTR strFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFilterInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFilterInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFilterInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFilterInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            IFilterInfo * This,
            /* [in] */ __RPC__in BSTR strPinID,
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VendorInfo )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strVendorInfo);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filter )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pins )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFileSource )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__out LONG *pbIsSource);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filename )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrFilename);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Filename )( 
            IFilterInfo * This,
            /* [in] */ __RPC__in BSTR strFilename);
        
        END_INTERFACE
    } IFilterInfoVtbl;

    interface IFilterInfo
    {
        CONST_VTBL struct IFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFilterInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFilterInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFilterInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFilterInfo_FindPin(This,strPinID,ppUnk)	\
    ( (This)->lpVtbl -> FindPin(This,strPinID,ppUnk) ) 

#define IFilterInfo_get_Name(This,strName)	\
    ( (This)->lpVtbl -> get_Name(This,strName) ) 

#define IFilterInfo_get_VendorInfo(This,strVendorInfo)	\
    ( (This)->lpVtbl -> get_VendorInfo(This,strVendorInfo) ) 

#define IFilterInfo_get_Filter(This,ppUnk)	\
    ( (This)->lpVtbl -> get_Filter(This,ppUnk) ) 

#define IFilterInfo_get_Pins(This,ppUnk)	\
    ( (This)->lpVtbl -> get_Pins(This,ppUnk) ) 

#define IFilterInfo_get_IsFileSource(This,pbIsSource)	\
    ( (This)->lpVtbl -> get_IsFileSource(This,pbIsSource) ) 

#define IFilterInfo_get_Filename(This,pstrFilename)	\
    ( (This)->lpVtbl -> get_Filename(This,pstrFilename) ) 

#define IFilterInfo_put_Filename(This,strFilename)	\
    ( (This)->lpVtbl -> put_Filename(This,strFilename) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterInfo_INTERFACE_DEFINED__ */


#ifndef __IRegFilterInfo_INTERFACE_DEFINED__
#define __IRegFilterInfo_INTERFACE_DEFINED__

/* interface IRegFilterInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IRegFilterInfo,0x56a868bb,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bb-0ad4-11ce-b03a-0020af0ba770")
    IRegFilterInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Filter( 
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegFilterInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRegFilterInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRegFilterInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRegFilterInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRegFilterInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IRegFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strName);
        
        HRESULT ( STDMETHODCALLTYPE *Filter )( 
            IRegFilterInfo * This,
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        END_INTERFACE
    } IRegFilterInfoVtbl;

    interface IRegFilterInfo
    {
        CONST_VTBL struct IRegFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegFilterInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRegFilterInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRegFilterInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRegFilterInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRegFilterInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRegFilterInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRegFilterInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRegFilterInfo_get_Name(This,strName)	\
    ( (This)->lpVtbl -> get_Name(This,strName) ) 

#define IRegFilterInfo_Filter(This,ppUnk)	\
    ( (This)->lpVtbl -> Filter(This,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRegFilterInfo_INTERFACE_DEFINED__ */


#ifndef __IMediaTypeInfo_INTERFACE_DEFINED__
#define __IMediaTypeInfo_INTERFACE_DEFINED__

/* interface IMediaTypeInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaTypeInfo,0x56a868bc,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bc-0ad4-11ce-b03a-0020af0ba770")
    IMediaTypeInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Subtype( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaTypeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaTypeInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaTypeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaTypeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaTypeInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaTypeInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaTypeInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaTypeInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IMediaTypeInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subtype )( 
            IMediaTypeInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strType);
        
        END_INTERFACE
    } IMediaTypeInfoVtbl;

    interface IMediaTypeInfo
    {
        CONST_VTBL struct IMediaTypeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaTypeInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaTypeInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaTypeInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaTypeInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaTypeInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaTypeInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaTypeInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaTypeInfo_get_Type(This,strType)	\
    ( (This)->lpVtbl -> get_Type(This,strType) ) 

#define IMediaTypeInfo_get_Subtype(This,strType)	\
    ( (This)->lpVtbl -> get_Subtype(This,strType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaTypeInfo_INTERFACE_DEFINED__ */


#ifndef __IPinInfo_INTERFACE_DEFINED__
#define __IPinInfo_INTERFACE_DEFINED__

/* interface IPinInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IPinInfo,0x56a868bd,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bd-0ad4-11ce-b03a-0020af0ba770")
    IPinInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Pin( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedTo( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionMediaType( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterInfo( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ __RPC__out LONG *ppDirection) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PinID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strPinID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MediaTypes( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ __RPC__in_opt IUnknown *pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectDirect( 
            /* [in] */ __RPC__in_opt IUnknown *pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectWithType( 
            /* [in] */ __RPC__in_opt IUnknown *pPin,
            /* [in] */ __RPC__in_opt IDispatch *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Render( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPinInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPinInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPinInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPinInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPinInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPinInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPinInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pin )( 
            IPinInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedTo )( 
            IPinInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionMediaType )( 
            IPinInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterInfo )( 
            IPinInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IPinInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            IPinInfo * This,
            /* [retval][out] */ __RPC__out LONG *ppDirection);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PinID )( 
            IPinInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strPinID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaTypes )( 
            IPinInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IPinInfo * This,
            /* [in] */ __RPC__in_opt IUnknown *pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IPinInfo * This,
            /* [in] */ __RPC__in_opt IUnknown *pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectWithType )( 
            IPinInfo * This,
            /* [in] */ __RPC__in_opt IUnknown *pPin,
            /* [in] */ __RPC__in_opt IDispatch *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IPinInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IPinInfo * This);
        
        END_INTERFACE
    } IPinInfoVtbl;

    interface IPinInfo
    {
        CONST_VTBL struct IPinInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPinInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPinInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPinInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPinInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IPinInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IPinInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IPinInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IPinInfo_get_Pin(This,ppUnk)	\
    ( (This)->lpVtbl -> get_Pin(This,ppUnk) ) 

#define IPinInfo_get_ConnectedTo(This,ppUnk)	\
    ( (This)->lpVtbl -> get_ConnectedTo(This,ppUnk) ) 

#define IPinInfo_get_ConnectionMediaType(This,ppUnk)	\
    ( (This)->lpVtbl -> get_ConnectionMediaType(This,ppUnk) ) 

#define IPinInfo_get_FilterInfo(This,ppUnk)	\
    ( (This)->lpVtbl -> get_FilterInfo(This,ppUnk) ) 

#define IPinInfo_get_Name(This,ppUnk)	\
    ( (This)->lpVtbl -> get_Name(This,ppUnk) ) 

#define IPinInfo_get_Direction(This,ppDirection)	\
    ( (This)->lpVtbl -> get_Direction(This,ppDirection) ) 

#define IPinInfo_get_PinID(This,strPinID)	\
    ( (This)->lpVtbl -> get_PinID(This,strPinID) ) 

#define IPinInfo_get_MediaTypes(This,ppUnk)	\
    ( (This)->lpVtbl -> get_MediaTypes(This,ppUnk) ) 

#define IPinInfo_Connect(This,pPin)	\
    ( (This)->lpVtbl -> Connect(This,pPin) ) 

#define IPinInfo_ConnectDirect(This,pPin)	\
    ( (This)->lpVtbl -> ConnectDirect(This,pPin) ) 

#define IPinInfo_ConnectWithType(This,pPin,pMediaType)	\
    ( (This)->lpVtbl -> ConnectWithType(This,pPin,pMediaType) ) 

#define IPinInfo_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IPinInfo_Render(This)	\
    ( (This)->lpVtbl -> Render(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPinInfo_INTERFACE_DEFINED__ */


#ifndef __IAMStats_INTERFACE_DEFINED__
#define __IAMStats_INTERFACE_DEFINED__

/* interface IAMStats */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMStats,0xbc9bcf80,0xdcd2,0x11d2,0xab,0xf6,0x00,0xa0,0xc9,0x05,0xf3,0x75);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc9bcf80-dcd2-11d2-abf6-00a0c905f375")
    IAMStats : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueByIndex( 
            /* [in] */ long lIndex,
            /* [out] */ __RPC__deref_out_opt BSTR *szName,
            /* [out] */ __RPC__out long *lCount,
            /* [out] */ __RPC__out double *dLast,
            /* [out] */ __RPC__out double *dAverage,
            /* [out] */ __RPC__out double *dStdDev,
            /* [out] */ __RPC__out double *dMin,
            /* [out] */ __RPC__out double *dMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueByName( 
            /* [in] */ __RPC__in BSTR szName,
            /* [out] */ __RPC__out long *lIndex,
            /* [out] */ __RPC__out long *lCount,
            /* [out] */ __RPC__out double *dLast,
            /* [out] */ __RPC__out double *dAverage,
            /* [out] */ __RPC__out double *dStdDev,
            /* [out] */ __RPC__out double *dMin,
            /* [out] */ __RPC__out double *dMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [in] */ __RPC__in BSTR szName,
            /* [in] */ long lCreate,
            /* [out] */ __RPC__out long *plIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddValue( 
            /* [in] */ long lIndex,
            /* [in] */ double dValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMStats * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMStats * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMStats * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMStats * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMStats * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAMStats * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IAMStats * This,
            /* [retval][out] */ __RPC__out LONG *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueByIndex )( 
            IAMStats * This,
            /* [in] */ long lIndex,
            /* [out] */ __RPC__deref_out_opt BSTR *szName,
            /* [out] */ __RPC__out long *lCount,
            /* [out] */ __RPC__out double *dLast,
            /* [out] */ __RPC__out double *dAverage,
            /* [out] */ __RPC__out double *dStdDev,
            /* [out] */ __RPC__out double *dMin,
            /* [out] */ __RPC__out double *dMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueByName )( 
            IAMStats * This,
            /* [in] */ __RPC__in BSTR szName,
            /* [out] */ __RPC__out long *lIndex,
            /* [out] */ __RPC__out long *lCount,
            /* [out] */ __RPC__out double *dLast,
            /* [out] */ __RPC__out double *dAverage,
            /* [out] */ __RPC__out double *dStdDev,
            /* [out] */ __RPC__out double *dMin,
            /* [out] */ __RPC__out double *dMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndex )( 
            IAMStats * This,
            /* [in] */ __RPC__in BSTR szName,
            /* [in] */ long lCreate,
            /* [out] */ __RPC__out long *plIndex);
        
        HRESULT ( STDMETHODCALLTYPE *AddValue )( 
            IAMStats * This,
            /* [in] */ long lIndex,
            /* [in] */ double dValue);
        
        END_INTERFACE
    } IAMStatsVtbl;

    interface IAMStats
    {
        CONST_VTBL struct IAMStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMStats_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMStats_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMStats_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMStats_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMStats_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMStats_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMStats_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMStats_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IAMStats_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IAMStats_GetValueByIndex(This,lIndex,szName,lCount,dLast,dAverage,dStdDev,dMin,dMax)	\
    ( (This)->lpVtbl -> GetValueByIndex(This,lIndex,szName,lCount,dLast,dAverage,dStdDev,dMin,dMax) ) 

#define IAMStats_GetValueByName(This,szName,lIndex,lCount,dLast,dAverage,dStdDev,dMin,dMax)	\
    ( (This)->lpVtbl -> GetValueByName(This,szName,lIndex,lCount,dLast,dAverage,dStdDev,dMin,dMax) ) 

#define IAMStats_GetIndex(This,szName,lCreate,plIndex)	\
    ( (This)->lpVtbl -> GetIndex(This,szName,lCreate,plIndex) ) 

#define IAMStats_AddValue(This,lIndex,dValue)	\
    ( (This)->lpVtbl -> AddValue(This,lIndex,dValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMStats_INTERFACE_DEFINED__ */

#endif /* __QuartzTypeLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\contentpartner.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for contentpartner.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __contentpartner_h__
#define __contentpartner_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMPContentContainer_FWD_DEFINED__
#define __IWMPContentContainer_FWD_DEFINED__
typedef interface IWMPContentContainer IWMPContentContainer;
#endif 	/* __IWMPContentContainer_FWD_DEFINED__ */


#ifndef __IWMPContentContainerList_FWD_DEFINED__
#define __IWMPContentContainerList_FWD_DEFINED__
typedef interface IWMPContentContainerList IWMPContentContainerList;
#endif 	/* __IWMPContentContainerList_FWD_DEFINED__ */


#ifndef __IWMPContentPartnerCallback_FWD_DEFINED__
#define __IWMPContentPartnerCallback_FWD_DEFINED__
typedef interface IWMPContentPartnerCallback IWMPContentPartnerCallback;
#endif 	/* __IWMPContentPartnerCallback_FWD_DEFINED__ */


#ifndef __IWMPContentPartner_FWD_DEFINED__
#define __IWMPContentPartner_FWD_DEFINED__
typedef interface IWMPContentPartner IWMPContentPartner;
#endif 	/* __IWMPContentPartner_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_contentpartner_0000_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//=========================================================================

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the IWMPContentPartner::GetContentPartnerInfo API for the bstrInfoName parameter.

static const WCHAR g_szContentPartnerInfo_LoginState[]             = L"LoginState";

// Synopsis: IWMPContentPartner::GetContentPartnerInfo
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BOOL, indicates whether the user is logged into the services

static const WCHAR g_szContentPartnerInfo_MediaPlayerAccountType[] = L"MediaPlayerAccountType";

// Synopsis: IWMPContentPartner::GetContentPartnerInfo
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_UI4,  - Represents a WMPAccountType value, this value is interpreted by the media player

static const WCHAR g_szContentPartnerInfo_AccountType[]            = L"AccountType";

// Synopsis: IWMPContentPartner::GetContentPartnerInfo
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR,  - Represents subscriptions services account type as a string
//                                                    -> This value is not interpreted by the media player, and may be shown to the user

static const WCHAR g_szContentPartnerInfo_HasCachedCredentials[]   = L"HasCachedCredentials";   // VT_BOOL - Returns whether plugin has cached credentials

// Synopsis: IWMPContentPartner::GetContentPartnerInfo
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BOOL, indicates whether the pluggin has cached
//                                                    -> credentials necessary to log in to the service

static const WCHAR g_szContentPartnerInfo_LicenseRefreshAdvanceWarning[] = L"LicenseRefreshAdvanceWarning";

// Synopsis: IWMPContentPartner::GetContentPartnerInfo
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_UI4, representing days  - This value is used by the player to pre-emptively refresh licenses that will expire soon.
//                                                    -> For example, if the plugin can support refreshing a playback license 5 days before it expires, then pData->ulVal should be set to 5.
//                                                    -> This value is a global setting, and cannot be different for different licenses, users, etc.

static const WCHAR g_szContentPartnerInfo_PurchasedTrackRequiresReDownload[] = L"PurchasedTrackRequiresReDownload";
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BOOL, represents whether a purchased track must be redownloaded if the content had been previously downloaded.

static const WCHAR g_szContentPartnerInfo_MaximumTrackPurchasePerPurchase[]  = L"MaximumNumberOfTracksPerPurchase";
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_UI4, indicates the maximum number of tracks that can be handled in a single IWMPContentParnter::Buy call.
//                                                       0 indicates no maximum.

static const WCHAR g_szContentPartnerInfo_AccountBalance[]  = L"AccountBalance";
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR,  - Represents account balance as a string
//                                                    -> This value is not interpreted by the media player, and may be shown to the user

static const WCHAR g_szContentPartnerInfo_UserName[]  = L"UserName";
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR,  - Represents user's account friendly name as a string
//                                                    -> This value is not interpreted by the media player, and may be shown to the user


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are returned to the HTML templates hosted in the player (returned from IWMPContentPartner::GetTemplate
// from the window.external.task API

static const WCHAR g_szMediaPlayerTask_Burn[]                    = L"Burn";
static const WCHAR g_szMediaPlayerTask_Browse[]                  = L"Browse";
static const WCHAR g_szMediaPlayerTask_Sync[]                    = L"Sync";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the IWMPContentPartner::GetItemInfo API for the bstrInfoName parameter

static const WCHAR g_szItemInfo_PopupURL[]                       = L"Popup";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_I4, indicates index of popup URL to return
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to host in HTML based dialog

static const WCHAR g_szItemInfo_AuthenticationSuccessURL[]       = L"AuthenticationSuccessURL";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_I4, indicates index of Authentication URL to return
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to navigate if authentication is successful

static const WCHAR g_szItemInfo_LoginFailureURL[]                = L"LoginFailureURL";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, indicates index of LoginFailureURL to query.  This value was passed to the player via Notify( wmpcnLoginStateChange, <value
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to navigate when loginstatechange 

static const WCHAR g_szItemInfo_HTMLViewURL[]                = L"HTMLViewURL";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_BSTR, this is the string specified in the ASX file.  For example: <param name="HTMLFLINK" value="foo" \> 
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to use for the HTMLView 

static const WCHAR g_szItemInfo_PopupCaption[]                   = L"PopupCaption";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_I4, indicates index of popup URL to return
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates caption for the HTML based dialog

static const WCHAR g_szItemInfo_ALTLoginURL[]              = L"ALTLoginURL";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_EMPTY, contains nothing
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL for the alternative login

static const WCHAR g_szItemInfo_ALTLoginCaption[]              = L"ALTLoginCaption";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_EMPTY, contains nothing
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates caption for the alternative login

static const WCHAR g_szItemInfo_ForgetPasswordURL[]              = L"ForgotPassword";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_EMPTY, contains nothing
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to navigate the service plane
//                                                    -> in the event the user has forgotten their password

static const WCHAR g_szItemInfo_CreateAccountURL[]               = L"CreateAccount";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_EMPTY, contains nothing
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to navigate the service plane
//                                                    -> which the user can manage their account

static const WCHAR g_szItemInfo_ArtistArtURL[]                   = L"ArtistArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the aritst ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve artist art

static const WCHAR g_szItemInfo_AlbumArtURL[]                    = L"AlbumArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the album ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve album art

static const WCHAR g_szItemInfo_ListArtURL[]                     = L"ListArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the list ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve list art

static const WCHAR g_szItemInfo_GenreArtURL[]                    = L"GenreArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the genre ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve genre art

static const WCHAR g_szItemInfo_SubGenreArtURL[]                 = L"SubGenreArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the sub-genre ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve sub-genre art

static const WCHAR g_szItemInfo_RadioArtURL[]                 = L"RadioArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the radio ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve radio art

static const WCHAR g_szItemInfo_TreeListIconURL[]                 = L"CPListIDIcon";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the list ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve list icon art

static const WCHAR g_szItemInfo_ErrorDescription[]                = L"CPErrorDescription";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_ERROR, containing the error code
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, text describing the error.
//                                                       Fail this call if you do not understand error code

static const WCHAR g_szItemInfo_ErrorURL[]                        = L"CPErrorURL";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_ERROR, containing the error code
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, url that the service pane will be navigated
//                                                       to when then user clicks the resolve link

static const WCHAR g_szItemInfo_ErrorURLLinkText[]                    = L"CPErrorURLLinkText";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_ERROR, containing the error code
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, text that will be used for the hyperlink
//                                                       text for the URL returned from g_szItemInfo_ErrorURL


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the all the IWMPContentPartner and IWMPContentPartnerCallback APIs
// that deal with some sort of location or object type.

static const WCHAR g_szUnknownLocation[]                         = L"UnknownLocation";

// Passed when the media player cannot determine a valid location to pass to the plugin.
// should rarely happen

static const WCHAR g_szRootLocation[]                            = L"RootLocation";           // Passed when the user is on the 'root' tree node of the service

// Passed when the action is taking place on the root content-partner node in the media player's lbrary tree

static const WCHAR g_szFlyoutMenu[]                            = L"FlyoutMenu";                 // Passed when the user selects the flyout menu of the service

// Passed when the user selects the flyout menu of the service

static const WCHAR g_szOnlineStore[]                           = L"OnlineStore";               // Used to navigate the player to the online stores page in the call to IWMPContentPartnerCallback::ChangeView

static const WCHAR g_szVideoRecent[]                           = L"VideoRecent";               // Used to navigate the player to the online stores page in the call to IWMPContentPartnerCallback::ChangeView

static const WCHAR g_szVideoRoot[]                           = L"VideoRoot";               // Used to navigate the player to the online stores page in the call to IWMPContentPartnerCallback::ChangeView

// These constants are used in the all the IWMPContentPartner and IWMPContentPartnerCallback APIs
// They indicate either a location in the library (see IWMPContentPartner::GetTemplate) or
// a type being returned via a callback (see IWMPContentPartner::GetListContents and
// IWMPContentPartnerCallback::AddListContents

static const WCHAR g_szCPListID[]                                   = L"CPListID"; 
static const WCHAR g_szAllCPListIDs[]                               = L"AllCPListIDs"; 
static const WCHAR g_szCPTrackID[]                                  = L"CPTrackID"; 
static const WCHAR g_szAllCPTrackIDs[]                              = L"AllCPTrackIDs"; 
static const WCHAR g_szCPArtistID[]                                 = L"CPArtistID"; 
static const WCHAR g_szAllCPArtistIDs[]                             = L"AllCPArtistIDs"; 
static const WCHAR g_szCPAlbumID[]                                  = L"CPAlbumID"; 
static const WCHAR g_szAllCPAlbumIDs[]                              = L"AllCPAlbumIDs"; 
static const WCHAR g_szCPGenreID[]                                  = L"CPGenreID"; 
static const WCHAR g_szAllCPGenreIDs[]                              = L"AllCPGenreIDs"; 
static const WCHAR g_szCPAlbumSubGenreID[]                          = L"CPAlbumSubGenreID"; 
static const WCHAR g_szAllCPAlbumSubGenreIDs[]                      = L"AllCPAlbumSubGenreIDs"; 
static const WCHAR g_szReleaseDateYear[]                            = L"ReleaseDateYear"; 
static const WCHAR g_szAllReleaseDateYears[]                        = L"AllReleaseDateYears"; 
static const WCHAR g_szCPRadioID[]                                  = L"CPRadioID"; 
static const WCHAR g_szAllCPRadioIDs[]                              = L"AllCPRadioIDs"; 
static const WCHAR g_szAuthor[]                                     = L"Author"; 
static const WCHAR g_szAllAuthors[]                                 = L"AllAuthors"; 
static const WCHAR g_szWMParentalRating[]                           = L"WMParentalRating"; 
static const WCHAR g_szAllWMParentalRatings[]                       = L"AllWMParentalRatings"; 
static const WCHAR g_szAllUserEffectiveRatingStarss[]               = L"AllUserEffectiveRatingStarss"; 
static const WCHAR g_szUserEffectiveRatingStars[]                   = L"UserEffectiveRatingStars"; 
static const WCHAR g_szUserPlaylist[]                               = L"UserPlaylist"; 
static ULONG g_knReservedCPTrackID_NotFound                         = (DWORD)-1; 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are to be used by the window.external.changeViewOnlineList for the bstrViewMode parameter

static const WCHAR g_szViewMode_Report[]                          = L"ViewModeReport";         // Display dynamic list contents in report mode
static const WCHAR g_szViewMode_Details[]                         = L"ViewModeDetails";        // Display dynamic list contents in details mode
static const WCHAR g_szViewMode_Icon[]                            = L"ViewModeIcon";           // Display dynamic list contents in icon mode
static const WCHAR g_szViewMode_Tile[]                            = L"ViewModeTile";           // Display dynamic list contents in tile mode
static const WCHAR g_szViewMode_OrderedList[]                     = L"ViewModeOrderedList";    // Display dynamic list contents in ordered list mode

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the IWMPContentContainer APIs for detecting fixed pricing

static const WCHAR g_szContentPrice_Unknown[]                     = L"PriceUnknown";           // The price of the content is unknown
static const WCHAR g_szContentPrice_CannotBuy[]                   = L"PriceCannotBuy";         // The content cannot be bought
static const WCHAR g_szContentPrice_Free[]                        = L"PriceFree";              // The content is free
//////////////////////////////////////////////////////////////////////
//          SERVICE CAPABILITIES THAT APPLY TO CONTENT-PARTNER-PLUGINS
//
// NOTE: If SUBSCRIPTION_CAP_IS_CONTENTPARTNER is not present, the 
// content partner plugin will NOT load
//
// These values are written in the registry as a DWORD value called 'Capabilities'
// under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MediaPlayer\Subscriptions\<ContentPartnerPluginKey>
// See the MSDN section on Online Stores Programming Reference in the Windows Media SDK
//////////////////////////////////////////////////////////////////////
#ifndef SUBSCRIPTION_CAP_DEVICEAVAILABLE
#define SUBSCRIPTION_CAP_DEVICEAVAILABLE        0x00000010
#endif
#ifndef SUBSCRIPTION_CAP_BACKGROUNDPROCESSING
#define SUBSCRIPTION_CAP_BACKGROUNDPROCESSING   0x00000008
#endif
#ifndef SUBSCRIPTION_CAP_IS_CONTENTPARTNER
#define SUBSCRIPTION_CAP_IS_CONTENTPARTNER      0x00000040
#endif
#ifndef SUBSCRIPTION_CAP_ALTLOGIN
#define SUBSCRIPTION_CAP_ALTLOGIN      0x00000080
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPPartnerNotification enum values are passed to the IWMPContentPartner::Notify API

// Synopsis - IWMPContentPartner::Notify( wmpsnBackgroundProcessingBegin 
//                                           /*input*/ VARIANT *pContenxt, type must be VT_EMPTY
// Remarks: the plugin can start background processing

// Synopsis - IWMPContentPartner::Notify( wmpsnBackgroundProcessingEnd 
//                                           /*input*/ VARIANT *pContenxt, type must be VT_EMPTY
// Remarks: the plugin should stop background processing, this enables the player to use more CPU for playback

// Synopsis - IWMPContentPartner::Notify( wmpsnCatalogDownloadFailure 
//                                           /*input*/ VARIANT *pContenxt, type must be VT_ERROR
// Remarks: indicates a failure while downloading the catalog

// Synopsis - IWMPContentPartner::Notify( wmpsnCatalogDownloadComplete 
//                                           /*input*/ VARIANT *pContenxt, type must be VT_EMPTY
// Remarks: indicates the catalog was downloaded successfully


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the IWMPContentPartner::RefreshLicesnse APIs for the reason

static const WCHAR g_szRefreshLicensePlay[]                     = L"RefreshForPlay";
static const WCHAR g_szRefreshLicenseBurn[]                     = L"RefreshForBurn";
static const WCHAR g_szRefreshLicenseSync[]                     = L"RefreshForSync";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the IWMPContentPartner::VerifyPermission APIs

static const WCHAR g_szVerifyPermissionSync[]                     = L"VerifyPermissionSync";
#ifndef __WMPNotifySubscriptionPluginAddRemove
#define __WMPNotifySubscriptionPluginAddRemove
__inline BOOL WMPNotifySubscriptionPluginAddRemove()
{
    BOOL fRet = FALSE;
    UINT  msg = RegisterWindowMessageA( "WMPlayer_PluginAddRemove" );
    if( 0 != msg ) 
     {
        fRet = PostMessage( HWND_BROADCAST, msg, 1, 0 );
     }
     return fRet;
}
#endif
typedef /* [public] */ 
enum WMPPartnerNotification
    {	wmpsnBackgroundProcessingBegin	= 1,
	wmpsnBackgroundProcessingEnd	= 2,
	wmpsnCatalogDownloadFailure	= 3,
	wmpsnCatalogDownloadComplete	= 4
    } 	WMPPartnerNotification;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPCallbackNotification enum values are passed to the IWMPContentPartner::Notify API

// Synopsis - IWMPContentPartnerCallback::Notify( wmpcnLoginStateChange 
//                                           /*input*/ VARIANT *pContext, type must be VT_BOOL or VT_UI4
// Remarks: indicates a new login state. VT_BOOL indicates a normal success or failure, while setting the type to VT_UI4 indicates
// a special condition (expired or canceled account, etc) in which case the player will query the plugin via
// GetItemInfo( g_szItemInfo_LoginFailureURL, <VT_UI4 value returned with wmpcnLoginStateChange>, <VARIANT * to receive the URL as VT_BSTR> )

// Synopsis - IWMPContentPartnerCallback::Notify( wmpcnAuthResult 
//                                           /*input*/ VARIANT *pContext, type must be VT_BOOL
// Remarks: indicates a successful auth

// Synopsis - IWMPContentPartnerCallback::Notify( wmpcnLicenseUpdated 
//                                           /*input*/ VARIANT *pContext, type must be VT_UI4
// Remarks: represents the content ID whose license has been update

// Synopsis - IWMPContentPartnerCallback::Notify( wmpcnNewCatalogAvailable 
//                                           /*input*/ VARIANT *pContext, type must be VT_EMPTY
// Remarks: Instructs the player to download a new catalog

// Synopsis - IWMPContentPartnerCallback::CallbackNotify( wmpcnNewPluginAvailable 
//                                           /*input*/ VARIANT *pContext, type must be VT_BOOL
// Remarks: Instructs the player to download a new plugin, if pContext is VARIANT_TRUE, this indicates
//          that an upgrade is required

// Synopsis - IWMPContentPartnerCallback::CallbackNotify( wmpcnDisableRadioSkipping 
//                                           /*input*/ VARIANT *pContext, type must be VT_EMPTY
// Remarks: Instructs the player to not allow any skipping of items in a radio playlist
typedef /* [public] */ 
enum WMPCallbackNotification
    {	wmpcnLoginStateChange	= 1,
	wmpcnAuthResult	= 2,
	wmpcnLicenseUpdated	= 3,
	wmpcnNewCatalogAvailable	= 4,
	wmpcnNewPluginAvailable	= 5,
	wmpcnDisableRadioSkipping	= 6
    } 	WMPCallbackNotification;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPTaskType enum values are passed to the IWMPContentPartner::GetTemplate API

// Synopsis - IWMPContentPartner::GetTemplate( wmpttBrowse 
// Remarks: Indicates that the player is in the Library task

// Synopsis - IWMPContentPartner::GetTemplate( wmpttSync 
// Remarks: Indicates that the player is in the Sync task

// Synopsis - IWMPContentPartner::GetTemplate( wmpttBurn 
// Remarks: Indicates that the player is in the Burn task

// Synopsis - IWMPContentPartner::GetTemplate( wmpttCurrent 
// Remarks: Indicates that the player is in something other than the Library, Sync or Burn task

typedef /* [public] */ 
enum WMPTaskType
    {	wmpttBrowse	= 1,
	wmpttSync	= 2,
	wmpttBurn	= 3,
	wmpttCurrent	= 4
    } 	WMPTaskType;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPContextMenuInfo is returned from the IWMPContentPartner::GetCommands API

// Synopsis - struct WMPContextMenuInfo

// Member - dwID -> Indicates the value for the command from the plugin. A value of zero will
//                  cause the media player to insert a separator in the context menu

// Member - bstrMenuText -> Indicates the text that will be show in the context menu

// Member - bstrHelpText -> Indicates help text that could be shown when the user is
//                           highlighting this menu option

typedef /* [public] */ struct WMPContextMenuInfo
    {
    DWORD dwID;
    BSTR bstrMenuText;
    BSTR bstrHelpText;
    } 	WMPContextMenuInfo;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are to be used in the IWMPContentPartner::StationEvent

static const WCHAR g_szStationEvent_Started[]                          = L"TrackStarted";  
static const WCHAR g_szStationEvent_Complete[]                         = L"TrackComplete"; 
static const WCHAR g_szStationEvent_Skipped[]                          = L"TrackSkipped";  


extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0000_v0_0_s_ifspec;

#ifndef __IWMPContentContainer_INTERFACE_DEFINED__
#define __IWMPContentContainer_INTERFACE_DEFINED__

/* interface IWMPContentContainer */
/* [unique][uuid][object] */ 


// Synopsis - GetID-> This function returns the ID for this container


// Synopsis - GetPrice-> This function returns the price for this container


// Synopsis - GetType -> This returns the type of this container. Can return g_szCPAlbumID, g_szCPListID, or g_szUnknownLocation


// Synopsis - GetContentCount -> Returns the content count held in this container.


// Synopsis - GetContentPrice -> Returns the price for a piece of content.
//               /*input*/ idxContent -> index of content to get price for. Should be less than value returned by GetContentCount
//               /*output*/ pbstrPrice -> string content the price or g_szContentPrice_Unknown, g_szContentPrice_Free, or g_szContentPrice_CannotBuy


// Synopsis - GetContentID-> Returns the identifier for a piece of content.
//               /*input*/ idxContent -> index of content to indentifier for. Should be less than value returned by GetContentCount
//               /*output*/ pContentID -> indentifier of the content


EXTERN_C const IID IID_IWMPContentContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ad7f4d9c-1a9f-4ed2-9815-ecc0b58cb616")
    IWMPContentContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ __RPC__out ULONG *pContentID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrice( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPrice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentCount( 
            /* [out] */ __RPC__out ULONG *pcContent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentPrice( 
            /* [in] */ ULONG idxContent,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPrice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentID( 
            /* [in] */ ULONG idxContent,
            /* [out] */ __RPC__out ULONG *pContentID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPContentContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPContentContainer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPContentContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPContentContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            IWMPContentContainer * This,
            /* [out] */ __RPC__out ULONG *pContentID);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrice )( 
            IWMPContentContainer * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPrice);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMPContentContainer * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentCount )( 
            IWMPContentContainer * This,
            /* [out] */ __RPC__out ULONG *pcContent);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentPrice )( 
            IWMPContentContainer * This,
            /* [in] */ ULONG idxContent,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPrice);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentID )( 
            IWMPContentContainer * This,
            /* [in] */ ULONG idxContent,
            /* [out] */ __RPC__out ULONG *pContentID);
        
        END_INTERFACE
    } IWMPContentContainerVtbl;

    interface IWMPContentContainer
    {
        CONST_VTBL struct IWMPContentContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPContentContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPContentContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPContentContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPContentContainer_GetID(This,pContentID)	\
    ( (This)->lpVtbl -> GetID(This,pContentID) ) 

#define IWMPContentContainer_GetPrice(This,pbstrPrice)	\
    ( (This)->lpVtbl -> GetPrice(This,pbstrPrice) ) 

#define IWMPContentContainer_GetType(This,pbstrType)	\
    ( (This)->lpVtbl -> GetType(This,pbstrType) ) 

#define IWMPContentContainer_GetContentCount(This,pcContent)	\
    ( (This)->lpVtbl -> GetContentCount(This,pcContent) ) 

#define IWMPContentContainer_GetContentPrice(This,idxContent,pbstrPrice)	\
    ( (This)->lpVtbl -> GetContentPrice(This,idxContent,pbstrPrice) ) 

#define IWMPContentContainer_GetContentID(This,idxContent,pContentID)	\
    ( (This)->lpVtbl -> GetContentID(This,idxContent,pContentID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPContentContainer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contentpartner_0000_0001 */
/* [local] */ 


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPTransactionType enum values are passed to the IWMPContentContainerList::GetTransactionType API

// Synopsis - wmpttNoTransaction
// Remarks: Undefined transaction, not currently used

// Synopsis - wmpttDownload
// Remarks: Indicates that this IWMPContentContainerList is to be used for a download transaction

// Synopsis - wmpttBuy
// Remarks: Indicates that this IWMPContentContainerList is to be used for a buy transaction

typedef /* [public] */ 
enum WMPTransactionType
    {	wmpttNoTransaction	= 0,
	wmpttDownload	= 1,
	wmpttBuy	= 2
    } 	WMPTransactionType;



extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0001_v0_0_s_ifspec;

#ifndef __IWMPContentContainerList_INTERFACE_DEFINED__
#define __IWMPContentContainerList_INTERFACE_DEFINED__

/* interface IWMPContentContainerList */
/* [unique][uuid][object] */ 


// Synopsis - GetTransactionType-> Returns the transaction type.
//               /*output*/ WMPTransactionType *pwmptt -> indicates whether this IWMPContentContainerList will be used to a buy or download


// Synopsis - GetContainerCount-> Returns the number of IWMPContentContainer(s) present in this container list.
//               /*output*/ ULONG *pcContainer -> returns the number of containers


// Synopsis - GetContainer-> Returns the IWMPContentContainer given an index.
//               /*input*/ ULONG idxContainer -> the index of the desired container, should be less than the number returned
//                                               by IWMPContentContainerList::GetContainerCount
//               /*output*/ IWMPContentContainer **ppContent -> will containe the requested IWMPContentContainer on success


EXTERN_C const IID IID_IWMPContentContainerList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a9937f78-0802-4af8-8b8d-e3f045bc8ab5")
    IWMPContentContainerList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTransactionType( 
            /* [out] */ __RPC__out WMPTransactionType *pwmptt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainerCount( 
            /* [out] */ __RPC__out ULONG *pcContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainer( 
            /* [in] */ ULONG idxContainer,
            /* [out] */ __RPC__deref_out_opt IWMPContentContainer **ppContent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPContentContainerListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPContentContainerList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPContentContainerList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPContentContainerList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransactionType )( 
            IWMPContentContainerList * This,
            /* [out] */ __RPC__out WMPTransactionType *pwmptt);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerCount )( 
            IWMPContentContainerList * This,
            /* [out] */ __RPC__out ULONG *pcContainer);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainer )( 
            IWMPContentContainerList * This,
            /* [in] */ ULONG idxContainer,
            /* [out] */ __RPC__deref_out_opt IWMPContentContainer **ppContent);
        
        END_INTERFACE
    } IWMPContentContainerListVtbl;

    interface IWMPContentContainerList
    {
        CONST_VTBL struct IWMPContentContainerListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPContentContainerList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPContentContainerList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPContentContainerList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPContentContainerList_GetTransactionType(This,pwmptt)	\
    ( (This)->lpVtbl -> GetTransactionType(This,pwmptt) ) 

#define IWMPContentContainerList_GetContainerCount(This,pcContainer)	\
    ( (This)->lpVtbl -> GetContainerCount(This,pcContainer) ) 

#define IWMPContentContainerList_GetContainer(This,idxContainer,ppContent)	\
    ( (This)->lpVtbl -> GetContainer(This,idxContainer,ppContent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPContentContainerList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contentpartner_0000_0002 */
/* [local] */ 


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPTemplateSize enum values are returned from the IWMPContentPartner::GetTemplate API

// Synopsis - wmptsSmall
// Remarks: indicates the media player will allocate 100 pixels in height for the template

// Synopsis - wmptsMedium
// Remarks: indicates the media player will allocate 250 pixels in height for the template

// Synopsis - wmptsLarge
// Remarks: indicates the media player will allocate all of the room expect for the necessary space
//          for the list-control to display a small set of items for the template

typedef /* [public] */ 
enum WMPTemplateSize
    {	wmptsSmall	= 0,
	wmptsMedium	= ( wmptsSmall + 1 ) ,
	wmptsLarge	= ( wmptsMedium + 1 ) 
    } 	WMPTemplateSize;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPStreamingType enum values are passed to the returned from the IWMPContentPartner::GetStreamingULR API

// Synopsis - wmpstMusic
// Remarks: indicates the plugin should return an URL for music content

// Synopsis - wmpstVideo
// Remarks: indicates the plugin should return an URL for video content

// Synopsis - wmpstRadio
// Remarks: indicates the plugin should return an URL for radio content

typedef /* [public] */ 
enum WMPStreamingType
    {	wmpstUnknown	= 0,
	wmpstMusic	= 1,
	wmpstVideo	= 2,
	wmpstRadio	= 3
    } 	WMPStreamingType;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPAccountType enum values are returned from the IWMPContentPartner::GetPartnerInfo when API
// the string is g_szContentPartnerInfo_MediaPlayerAccountType passed

// Synopsis - wmpatBuyOnly
// Remarks: indicates the user only has the option to buy content

// Synopsis - wmpatSubscription
// Remarks: indicates the user has a subcription account, which indicates buy is also required for sync to Janus device

// Synopsis - wmpatJanus
// Remarks: indicates the user has a subcirption account, and the ability to sync to Janus devices without having to buy

typedef /* [public] */ 
enum WMPAccountType
    {	wmpatBuyOnly	= 1,
	wmpatSubscription	= 2,
	wmpatJanus	= 3
    } 	WMPAccountType;



extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0002_v0_0_s_ifspec;

#ifndef __IWMPContentPartnerCallback_INTERFACE_DEFINED__
#define __IWMPContentPartnerCallback_INTERFACE_DEFINED__

/* interface IWMPContentPartnerCallback */
/* [unique][helpstring][uuid][object] */ 


// Synopsis - Notify-> This function is called to notify the media player of plugin events
//            /*input*/  WMPCallbackNotification type - Event that the plugin is notifying the player of
//            /*input*/  VARIANT * pContext - The context depends on the notification being sent. See
//                           remakrs for WMPCallbackNotification


// Synopsis - BuyComplete -> This function is called to notify the media player of that a purchase has completed
//            /*input*/  HRESULT hrResult - The success or error code of the purchase operation.
//            /*input*/  DWORD dwBuyCookie - The cookie passed to IWMPContentPartner::Buy.

// Remarks: This method should ONLY be called on SUCCESS AFTER all licenses have been delivered.

// Synopsis - DownloadTrack -> This function is called in response to a IWMPContentPartner::Download
//            /*input*/  DWORD dwCookie - The cookie passed to IWMPContentPartner::Download.
//            /*input*/  BSTR bstrTrackURL - The URL to download.
//            /*input*/  DWORD dwServiceTrackID - The content identifier of the content to download.
//            /*input*/  BSTR bstrDownloadParams - A string containing data to be passed to
//                                    IWMPContentPartnerCallback::DownloadTrackComplete.
//            /*input*/  HRESULT hrDownload - The success or error code of download operation.

// Remarks: This method should ONLY be called on SUCCESS AFTER all licenses have been delivered.
// Remarks: The tracks will NOT be download if hrDownload is not a success code.

// Synopsis - GetCatalogVersion -> This function is called to retrieve the current catalog version.
//            /*output*/  DWORD *pdwVersion- The major version of the catalog being used.
//            /*output*/  DWORD *pdwSchemaVersion - The schema of the catalog being used.
//            /*output*/  LCID *plcid- The language of the catalog being used.


// Synopsis - UpdateDeviceComplete -> This function is called to indicate that IWMPContentPartner::UpdateDevice has completed.
//            /*input*/  BSTR bstrDeviceName - The device name passed to IWMPContentPartner::UpdateDevice.


// Synopsis - ChangeView-> This function is called to navigate the media player UI
//            /*input*/  BSTR bstrType - a content partner string ID such as g_szCPArtistID, or g_szOnlineStore
//            /*input*/  BSTR bstrID -   The identifier to navigate to
//            /*input*/  BSTR bstrFilter - A filter to place in the 'word wheel' after navigating

// Remarks: When using g_szOnlineStore for bstrType, the bstrID ss a full URL to navigate the browser to
// Remarks: Use 'Back' or 'Forward' in bstrType to simulate pressing the applications back and forward navigation buttons
// Remarks: Use g_szRootLocation in bstrType to navigate to the service's root node in the libary UI


// Synopsis - AddListContents-> This function is called to add content identifiers to a list as a rsult of the 
//                               IWMPContentPartner::GetListContents API being called
//            /*input*/  DWORD dwListCookie - Cookie sent during IWMPContentParnter::GetListContents
//            /*input*/  DWORD cItems - The number of content identifiers being passed in the prgItems parameter
//            /*input*/  DWORD *prgItems - An array of content identifiers


// Synopsis - ListContentsComplete-> This function is called to indicate that the plugin has completed a IWMPContentPartner::GetListContents call
//            /*input*/  DWORD dwListCookie - Cookie sent during IWMPContentParnter::GetListContents 
//            /*input*/  HRESULT hrSuccess - The success or error code of the GetListContents operation


// Synopsis - SendMessageComplete-> This function is called to indicate that the plugin has completed a IWMPContentPartner::SendMessage call
//            /*input*/  BSTR bstrMsg - Message text sent in IWMPContentPartner::SendMessage
//            /*input*/  BSTR bstrParam - Parameter text sent in IWMPContentPartner::SendMessage
//            /*input*/  BSTR bstrResult - Result text


// Synopsis - GetContentIDsInLibrary-> This function is called to retrieve the content identifiers that are in the users
//                                     library that have been purchased or downloaded.
//            /*output*/  ULONG pcContentIDs - The number of content identifiers returned.
//            /*output*/  ULONG **pprgIDs    - An array of ULONGs containing the content identifiers. Free this array with CoTaskMemFree.


// Synopsis - RefreshLicenseComplete -> This function is called to indicate that a license refresh call has completed
//            /*input*/   DWORD dwCookie - This should be the same cookie passed to IWMPContentPartner::RefreshLicense.
//            /*input*/   ULOING contentID - This should be the same content identifier passed to IWMPContentPartner::RefreshLicense.
//            /*input*/   HRESULT hrRefresh - The success or error code of the refresh operation.


// Synopsis - ShowPopup -> This function is called to have the player show a popup dialog. Usually this happens 
//                          as a result of IWMPContentPartner::InvokeCommand being called.
//            /*input*/   long lIndex - The URL index to request from the IWMPContentPartner::GetItemInfo( g_szItemInfo_PopupURL, ... ) API.
//            /*input*/   BSTR bstrParameters - The parameters that are concatenated onto the URL returned by IWMPContentPartner::GetItemInfo( g_szItemInfo_PopupURL, ... ) API


// Synopsis - VerifyPermission-> This function is called to indicate that permission verification is complete
//            /*input*/ BSTR bstrPermission - Indicates action for which permission was requested.
//            /*input*/   VARIANT * pContext - If sync, this is the canonical name of the device. This is the same thing that was passed in as pContext in VerifyPermission.
//            /*input*/   HRESULT hrPermission - Result of permission verification.


EXTERN_C const IID IID_IWMPContentPartnerCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E8F7DA2-0695-403c-B697-DA10FAFAA676")
    IWMPContentPartnerCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ WMPCallbackNotification type,
            /* [in] */ __RPC__in VARIANT *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BuyComplete( 
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwBuyCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DownloadTrack( 
            /* [in] */ DWORD cookie,
            /* [in] */ __RPC__in BSTR bstrTrackURL,
            /* [in] */ DWORD dwServiceTrackID,
            /* [in] */ __RPC__in BSTR bstrDownloadParams,
            /* [in] */ HRESULT hrDownload) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCatalogVersion( 
            /* [out] */ __RPC__out DWORD *pdwVersion,
            /* [out] */ __RPC__out DWORD *pdwSchemaVersion,
            /* [out] */ __RPC__out LCID *plcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateDeviceComplete( 
            /* [in] */ __RPC__in BSTR bstrDeviceName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeView( 
            /* [in] */ __RPC__in BSTR bstrType,
            /* [in] */ __RPC__in BSTR bstrID,
            /* [in] */ __RPC__in BSTR bstrFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddListContents( 
            /* [in] */ DWORD dwListCookie,
            /* [in] */ DWORD cItems,
            /* [size_is][in] */ __RPC__in_ecount_full(cItems) DWORD *prgItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ListContentsComplete( 
            /* [in] */ DWORD dwListCookie,
            /* [in] */ HRESULT hrSuccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendMessageComplete( 
            /* [in] */ __RPC__in BSTR bstrMsg,
            /* [in] */ __RPC__in BSTR bstrParam,
            /* [in] */ __RPC__in BSTR bstrResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentIDsInLibrary( 
            /* [out] */ __RPC__out ULONG *pcContentIDs,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcContentIDs) ULONG **pprgIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshLicenseComplete( 
            /* [in] */ DWORD dwCookie,
            /* [in] */ ULONG contentID,
            /* [in] */ HRESULT hrRefresh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowPopup( 
            /* [in] */ long lIndex,
            /* [in] */ __RPC__in BSTR bstrParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VerifyPermissionComplete( 
            /* [in] */ __RPC__in BSTR bstrPermission,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ HRESULT hrPermission) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPContentPartnerCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPContentPartnerCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPContentPartnerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ WMPCallbackNotification type,
            /* [in] */ __RPC__in VARIANT *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *BuyComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwBuyCookie);
        
        HRESULT ( STDMETHODCALLTYPE *DownloadTrack )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ DWORD cookie,
            /* [in] */ __RPC__in BSTR bstrTrackURL,
            /* [in] */ DWORD dwServiceTrackID,
            /* [in] */ __RPC__in BSTR bstrDownloadParams,
            /* [in] */ HRESULT hrDownload);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogVersion )( 
            IWMPContentPartnerCallback * This,
            /* [out] */ __RPC__out DWORD *pdwVersion,
            /* [out] */ __RPC__out DWORD *pdwSchemaVersion,
            /* [out] */ __RPC__out LCID *plcid);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateDeviceComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ __RPC__in BSTR bstrDeviceName);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeView )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ __RPC__in BSTR bstrType,
            /* [in] */ __RPC__in BSTR bstrID,
            /* [in] */ __RPC__in BSTR bstrFilter);
        
        HRESULT ( STDMETHODCALLTYPE *AddListContents )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ DWORD dwListCookie,
            /* [in] */ DWORD cItems,
            /* [size_is][in] */ __RPC__in_ecount_full(cItems) DWORD *prgItems);
        
        HRESULT ( STDMETHODCALLTYPE *ListContentsComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ DWORD dwListCookie,
            /* [in] */ HRESULT hrSuccess);
        
        HRESULT ( STDMETHODCALLTYPE *SendMessageComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ __RPC__in BSTR bstrMsg,
            /* [in] */ __RPC__in BSTR bstrParam,
            /* [in] */ __RPC__in BSTR bstrResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentIDsInLibrary )( 
            IWMPContentPartnerCallback * This,
            /* [out] */ __RPC__out ULONG *pcContentIDs,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcContentIDs) ULONG **pprgIDs);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshLicenseComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ DWORD dwCookie,
            /* [in] */ ULONG contentID,
            /* [in] */ HRESULT hrRefresh);
        
        HRESULT ( STDMETHODCALLTYPE *ShowPopup )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ long lIndex,
            /* [in] */ __RPC__in BSTR bstrParameters);
        
        HRESULT ( STDMETHODCALLTYPE *VerifyPermissionComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ __RPC__in BSTR bstrPermission,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ HRESULT hrPermission);
        
        END_INTERFACE
    } IWMPContentPartnerCallbackVtbl;

    interface IWMPContentPartnerCallback
    {
        CONST_VTBL struct IWMPContentPartnerCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPContentPartnerCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPContentPartnerCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPContentPartnerCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPContentPartnerCallback_Notify(This,type,pContext)	\
    ( (This)->lpVtbl -> Notify(This,type,pContext) ) 

#define IWMPContentPartnerCallback_BuyComplete(This,hrResult,dwBuyCookie)	\
    ( (This)->lpVtbl -> BuyComplete(This,hrResult,dwBuyCookie) ) 

#define IWMPContentPartnerCallback_DownloadTrack(This,cookie,bstrTrackURL,dwServiceTrackID,bstrDownloadParams,hrDownload)	\
    ( (This)->lpVtbl -> DownloadTrack(This,cookie,bstrTrackURL,dwServiceTrackID,bstrDownloadParams,hrDownload) ) 

#define IWMPContentPartnerCallback_GetCatalogVersion(This,pdwVersion,pdwSchemaVersion,plcid)	\
    ( (This)->lpVtbl -> GetCatalogVersion(This,pdwVersion,pdwSchemaVersion,plcid) ) 

#define IWMPContentPartnerCallback_UpdateDeviceComplete(This,bstrDeviceName)	\
    ( (This)->lpVtbl -> UpdateDeviceComplete(This,bstrDeviceName) ) 

#define IWMPContentPartnerCallback_ChangeView(This,bstrType,bstrID,bstrFilter)	\
    ( (This)->lpVtbl -> ChangeView(This,bstrType,bstrID,bstrFilter) ) 

#define IWMPContentPartnerCallback_AddListContents(This,dwListCookie,cItems,prgItems)	\
    ( (This)->lpVtbl -> AddListContents(This,dwListCookie,cItems,prgItems) ) 

#define IWMPContentPartnerCallback_ListContentsComplete(This,dwListCookie,hrSuccess)	\
    ( (This)->lpVtbl -> ListContentsComplete(This,dwListCookie,hrSuccess) ) 

#define IWMPContentPartnerCallback_SendMessageComplete(This,bstrMsg,bstrParam,bstrResult)	\
    ( (This)->lpVtbl -> SendMessageComplete(This,bstrMsg,bstrParam,bstrResult) ) 

#define IWMPContentPartnerCallback_GetContentIDsInLibrary(This,pcContentIDs,pprgIDs)	\
    ( (This)->lpVtbl -> GetContentIDsInLibrary(This,pcContentIDs,pprgIDs) ) 

#define IWMPContentPartnerCallback_RefreshLicenseComplete(This,dwCookie,contentID,hrRefresh)	\
    ( (This)->lpVtbl -> RefreshLicenseComplete(This,dwCookie,contentID,hrRefresh) ) 

#define IWMPContentPartnerCallback_ShowPopup(This,lIndex,bstrParameters)	\
    ( (This)->lpVtbl -> ShowPopup(This,lIndex,bstrParameters) ) 

#define IWMPContentPartnerCallback_VerifyPermissionComplete(This,bstrPermission,pContext,hrPermission)	\
    ( (This)->lpVtbl -> VerifyPermissionComplete(This,bstrPermission,pContext,hrPermission) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPContentPartnerCallback_INTERFACE_DEFINED__ */


#ifndef __IWMPContentPartner_INTERFACE_DEFINED__
#define __IWMPContentPartner_INTERFACE_DEFINED__

/* interface IWMPContentPartner */
/* [unique][helpstring][uuid][object] */ 


// Synopsis - SetCallback-> This function allows gives the pugin the ability to store a callback pointer
//                          that will be necessary to communicate with the player
//             /*input*/ pCallback -> interface pointer to the media player's implementation of the IWMPContentPartnerCallback
//
// Remarks: The player will call this with a null value during its shutdown process. The plugin can use


// Synopsis - Notify-> This function is called by the player to notify the plugin of certain events
//            /*input*/ WMPPartnerNotification type - see comments for WMPPartnerNotification enum
//            /*input*/ VARIANT *pContext - see comments for WMPPartnerNotification enum


// Synopsis - GetItemInfo-> This function is called to retrieve different properties about content
//            /*input*/ VARIANT *pContext - see comments above for the strings passed into this API
//            /*out*/   VARIANT *pData - see comments abouve for the strings passed into this API


// Synopsis - GetContentPartnerInfo-> This function is called to retrieve different properties about the content partner
//            /*input*/ BSTR bstrInfoName - see comments above for the strings passed into this API 
//            /*out*/   VARIANT *pData - see comments above for the strings passed into this API


// Synopsis - GetCommands-> This function allows the plugin to return commands to be displayed in context menus
//             /*input*/  BSTR location -> location in the library (such as g_szCPArtistID)
//             /*input*/  VARIANT *pLocationContext -> location in the library (such as VT_UI4, 1231231)
//             /*input*/  BSTR itemLocation -> item type selected in library (such as g_szCPTrackID)
//             /*input*/  ULONG cItemIDs -> the number of selected items of type itemLocation
//             /*input*/  ULONG prgItemIDs -> the array of content identifiers
//             /*output*/ ULONG *pcItemIDs -> the number of context menu commands returned in pprgItems
//             /*output*/ WMPContextMenuInfo **pprgItems -> Array of WMPContenxtMenuInfo items allocated by CoTaskMemAlloc

//             Remarks: See comments for WMPContextMenuInfo for more information


// Synopsis - InvokeCommand-> This function is called when the user selects an option fro a context menu command
//                            returned by IWMPContentPartner::GetCommands
//             /*input*/  DWORD dwCommandID -> Command ID from the select WMPContextMenuInfo
//             /*input*/  The remaining parameters are the same as those passed to IWMPContentPartner::GetCommands

//             Remarks: See comments for WMPContextMenuInfo and IWMPContentPartner::GetCommands for more information


// Synopsis - GetCatalogURL -> This function is called by the player to retrieve the streaming URL
//             /*input*/  WMPStreamingType -> indicates whether the streaming type is for radio\music\video
//             /*input*/  VARIANT *pStreamContext -> VT_UI4, contains the content identifier
//             /*ouptut*/ BSTR *pbstrURL-> recieves the streaming URL of the content

//             Remarks: The streaming URL for Radio and Video must be contained in an ASX


// Synopsis - GetCatalogURL -> This function is called by the player to retrieve the catalog download URL
//             /*input*/  DWORD dwCatalogVersion -> current catalog version, or zero if none exists
//             /*input*/  DWORD dwCatalogSchemaVesrion -> current catalog schema
//             /*input*/  LCID catalogLCID -> current catalog version
//             /*output*/ DWORD *pdwNewCatalogVersion -> version of catalog that URL represents
//             /*ouptut*/ BSTR *pbstrCatalogURL-> recieves URL that the player will use to download catalog
//             /*output*/ VARIANT *pExpirationData-> Must be of type VT_DATE. This is the date at which the player will
//                           will call IWMPContentPartner::GetCatalogURL to retrieve a new catalog.


// Synopsis - UpdateDevice -> This function is called during sync to allow the plugin to do device updates.
//             /*input*/ BSTR bstrDeviceName-> name of device to update
//
// Remarks: This call should function asynchronously. Call IWMPContentPartnerCallback::UpdateDeviceComplete when finsihed.


// Synopsis - Login-> This function indicates to the plugin to begin logging in to the service
//             /*input*/ BLOB userInfo, an encrypted blob containing the user's login name
//             /*input*/ BLOB pwdInfo,  an encrypted blob containing the user's login password
//             /*input*/ VARIANT_BOOL fUsedCachedCreds, indicates to the plugin to attempt to use cached credentials
//                                                       for login if present.
//             /*input*/ VARIANT_BOOL fOkToCache, indicates that it is acceptable for the plugin to cache
//                                                 the users credential.
//
// Remarks: The plugin is responsible for calling IWMPContentPartner::Notify to indicate login state change
//
// Remarks: To unencrypt the user and password name, use 
//   CryptUnprotectData( blob, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &outBlob)


// Synopsis - Authenticate-> This function indicates to the plugin to Authenticate the credentials with the service
//             /*input*/ BLOB userInfo, an encrypted blob containing the user's login name
//             /*input*/ BLOB pwdInfo,  an encrypted blob containing the user's login password
//
// Remarks: To unencrypt the user and password name, use 
//   CryptUnprotectData( blob, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &outBlob)


// Synopsis - Logout-> This function indicates to the plugin to begin logging out from the service
// 
// Remarks: The plugin is responsible for calling IWMPContentPartner::Notify to indicate login state change
//
// Remarks: The plugin should delete any cached credentials when this API is called


// Synopsis - SendMessage -> This function allows HTML templates returned from IWMPContentPartner::GetTemplate
//                          to communicate to the plugin
//             /*input*/ bstrMsg -> value send directly from the template returned by IWMPContentPartner::GetTemplate
//                               -> via the window.external.sendMessage API
//             /*input*/ bstrParam -> parameter for the message, also sent from the window.external.sendMessage API
//
//Remarks: The plugin is reponsible for calling IWMPContentPartnerCallback::OnSendMessageComplete in order for
//         the HTML template to know that processing of the message occurs. This will be sent to the template
//         via the window.external.OnSendMessageComplete notificaiton


// Synopsis - CompareContainerListPrices-> This function is called to preform a comparison operation on tow IWMPContentContainerLists
//            /*input*/   IWMPContentContainerList *pListBase - 
//            /*input*/   IWMPContentContainerList *pListCompare - 
//            /*output*/  long *pResult* - Return less than 0 when pListBase is less than pListCompare, 0 for equal, and greather than 0 when pListBase is more than pListCompare


// Synopsis - VerifyPermission-> This function is called to get permission to perform an action
//            /*input*/ BSTR bstrPermission - Indicates action for which permission is requested
//            /*input*/   VARIANT * pContext - If sync, this is the canonical name of the device. This needs to be returned in VerifyPermissionComplete.


EXTERN_C const IID IID_IWMPContentPartner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55455073-41B5-4e75-87B8-F13BDB291D08")
    IWMPContentPartner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            /* [in] */ __RPC__in_opt IWMPContentPartnerCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ WMPPartnerNotification type,
            /* [in] */ __RPC__in VARIANT *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemInfo( 
            /* [in] */ __RPC__in BSTR bstrInfoName,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [out] */ __RPC__out VARIANT *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentPartnerInfo( 
            /* [in] */ __RPC__in BSTR bstrInfoName,
            /* [out] */ __RPC__out VARIANT *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCommands( 
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pLocationContext,
            /* [in] */ __RPC__in BSTR itemLocation,
            /* [in] */ ULONG cItemIDs,
            /* [size_is][in] */ __RPC__in_ecount_full(cItemIDs) ULONG *prgItemIDs,
            /* [out] */ __RPC__out ULONG *pcItemIDs,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcItemIDs) WMPContextMenuInfo **pprgItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeCommand( 
            /* [in] */ DWORD dwCommandID,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pLocationContext,
            /* [in] */ __RPC__in BSTR itemLocation,
            /* [in] */ ULONG cItemIDs,
            /* [size_is][in] */ __RPC__in_ecount_full(cItemIDs) ULONG *rgItemIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanBuySilent( 
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTotalPrice,
            /* [out] */ __RPC__out VARIANT_BOOL *pSilentOK) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Buy( 
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [in] */ DWORD cookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamingURL( 
            /* [in] */ WMPStreamingType st,
            /* [in] */ __RPC__in VARIANT *pStreamContext,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Download( 
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [in] */ DWORD cookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DownloadTrackComplete( 
            /* [in] */ HRESULT hrResult,
            /* [in] */ ULONG contentID,
            /* [in] */ __RPC__in BSTR downloadTrackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshLicense( 
            /* [in] */ DWORD dwCookie,
            /* [in] */ VARIANT_BOOL fLocal,
            /* [unique][in] */ __RPC__in_opt BSTR bstrURL,
            /* [in] */ WMPStreamingType type,
            /* [in] */ ULONG contentID,
            /* [in] */ __RPC__in BSTR bstrRefreshReason,
            /* [in] */ __RPC__in VARIANT *pReasonContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCatalogURL( 
            /* [in] */ DWORD dwCatalogVersion,
            /* [in] */ DWORD dwCatalogSchemaVersion,
            /* [in] */ LCID catalogLCID,
            /* [out] */ __RPC__out DWORD *pdwNewCatalogVersion,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrCatalogURL,
            /* [out] */ __RPC__out VARIANT *pExpirationDate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTemplate( 
            /* [in] */ WMPTaskType task,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ __RPC__in BSTR clickLocation,
            /* [in] */ __RPC__in VARIANT *pClickContext,
            /* [in] */ __RPC__in BSTR bstrFilter,
            /* [in] */ __RPC__in BSTR bstrViewParams,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTemplateURL,
            /* [out] */ __RPC__out WMPTemplateSize *pTemplateSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateDevice( 
            /* [in] */ __RPC__in BSTR bstrDeviceName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetListContents( 
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ __RPC__in BSTR bstrListType,
            /* [in] */ __RPC__in BSTR bstrParams,
            /* [in] */ DWORD dwListCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Login( 
            /* [in] */ BLOB userInfo,
            /* [in] */ BLOB pwdInfo,
            /* [in] */ VARIANT_BOOL fUsedCachedCreds,
            /* [in] */ VARIANT_BOOL fOkToCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Authenticate( 
            /* [in] */ BLOB userInfo,
            /* [in] */ BLOB pwdInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Logout( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendMessage( 
            /* [in] */ __RPC__in BSTR bstrMsg,
            /* [in] */ __RPC__in BSTR bstrParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StationEvent( 
            /* [in] */ __RPC__in BSTR bstrStationEventType,
            /* [in] */ ULONG StationId,
            /* [in] */ ULONG PlaylistIndex,
            /* [in] */ ULONG TrackID,
            /* [in] */ __RPC__in BSTR TrackData,
            /* [in] */ DWORD dwSecondsPlayed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareContainerListPrices( 
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pListBase,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pListCompare,
            /* [out] */ __RPC__out long *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VerifyPermission( 
            /* [in] */ __RPC__in BSTR bstrPermission,
            /* [in] */ __RPC__in VARIANT *pContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPContentPartnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPContentPartner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPContentPartner * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in_opt IWMPContentPartnerCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IWMPContentPartner * This,
            /* [in] */ WMPPartnerNotification type,
            /* [in] */ __RPC__in VARIANT *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemInfo )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrInfoName,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [out] */ __RPC__out VARIANT *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentPartnerInfo )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrInfoName,
            /* [out] */ __RPC__out VARIANT *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommands )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pLocationContext,
            /* [in] */ __RPC__in BSTR itemLocation,
            /* [in] */ ULONG cItemIDs,
            /* [size_is][in] */ __RPC__in_ecount_full(cItemIDs) ULONG *prgItemIDs,
            /* [out] */ __RPC__out ULONG *pcItemIDs,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcItemIDs) WMPContextMenuInfo **pprgItems);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeCommand )( 
            IWMPContentPartner * This,
            /* [in] */ DWORD dwCommandID,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pLocationContext,
            /* [in] */ __RPC__in BSTR itemLocation,
            /* [in] */ ULONG cItemIDs,
            /* [size_is][in] */ __RPC__in_ecount_full(cItemIDs) ULONG *rgItemIDs);
        
        HRESULT ( STDMETHODCALLTYPE *CanBuySilent )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTotalPrice,
            /* [out] */ __RPC__out VARIANT_BOOL *pSilentOK);
        
        HRESULT ( STDMETHODCALLTYPE *Buy )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [in] */ DWORD cookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamingURL )( 
            IWMPContentPartner * This,
            /* [in] */ WMPStreamingType st,
            /* [in] */ __RPC__in VARIANT *pStreamContext,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrURL);
        
        HRESULT ( STDMETHODCALLTYPE *Download )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [in] */ DWORD cookie);
        
        HRESULT ( STDMETHODCALLTYPE *DownloadTrackComplete )( 
            IWMPContentPartner * This,
            /* [in] */ HRESULT hrResult,
            /* [in] */ ULONG contentID,
            /* [in] */ __RPC__in BSTR downloadTrackParam);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshLicense )( 
            IWMPContentPartner * This,
            /* [in] */ DWORD dwCookie,
            /* [in] */ VARIANT_BOOL fLocal,
            /* [unique][in] */ __RPC__in_opt BSTR bstrURL,
            /* [in] */ WMPStreamingType type,
            /* [in] */ ULONG contentID,
            /* [in] */ __RPC__in BSTR bstrRefreshReason,
            /* [in] */ __RPC__in VARIANT *pReasonContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogURL )( 
            IWMPContentPartner * This,
            /* [in] */ DWORD dwCatalogVersion,
            /* [in] */ DWORD dwCatalogSchemaVersion,
            /* [in] */ LCID catalogLCID,
            /* [out] */ __RPC__out DWORD *pdwNewCatalogVersion,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrCatalogURL,
            /* [out] */ __RPC__out VARIANT *pExpirationDate);
        
        HRESULT ( STDMETHODCALLTYPE *GetTemplate )( 
            IWMPContentPartner * This,
            /* [in] */ WMPTaskType task,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ __RPC__in BSTR clickLocation,
            /* [in] */ __RPC__in VARIANT *pClickContext,
            /* [in] */ __RPC__in BSTR bstrFilter,
            /* [in] */ __RPC__in BSTR bstrViewParams,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTemplateURL,
            /* [out] */ __RPC__out WMPTemplateSize *pTemplateSize);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateDevice )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrDeviceName);
        
        HRESULT ( STDMETHODCALLTYPE *GetListContents )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ __RPC__in BSTR bstrListType,
            /* [in] */ __RPC__in BSTR bstrParams,
            /* [in] */ DWORD dwListCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Login )( 
            IWMPContentPartner * This,
            /* [in] */ BLOB userInfo,
            /* [in] */ BLOB pwdInfo,
            /* [in] */ VARIANT_BOOL fUsedCachedCreds,
            /* [in] */ VARIANT_BOOL fOkToCache);
        
        HRESULT ( STDMETHODCALLTYPE *Authenticate )( 
            IWMPContentPartner * This,
            /* [in] */ BLOB userInfo,
            /* [in] */ BLOB pwdInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Logout )( 
            IWMPContentPartner * This);
        
        HRESULT ( STDMETHODCALLTYPE *SendMessage )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrMsg,
            /* [in] */ __RPC__in BSTR bstrParam);
        
        HRESULT ( STDMETHODCALLTYPE *StationEvent )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrStationEventType,
            /* [in] */ ULONG StationId,
            /* [in] */ ULONG PlaylistIndex,
            /* [in] */ ULONG TrackID,
            /* [in] */ __RPC__in BSTR TrackData,
            /* [in] */ DWORD dwSecondsPlayed);
        
        HRESULT ( STDMETHODCALLTYPE *CompareContainerListPrices )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pListBase,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pListCompare,
            /* [out] */ __RPC__out long *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *VerifyPermission )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrPermission,
            /* [in] */ __RPC__in VARIANT *pContext);
        
        END_INTERFACE
    } IWMPContentPartnerVtbl;

    interface IWMPContentPartner
    {
        CONST_VTBL struct IWMPContentPartnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPContentPartner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPContentPartner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPContentPartner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPContentPartner_SetCallback(This,pCallback)	\
    ( (This)->lpVtbl -> SetCallback(This,pCallback) ) 

#define IWMPContentPartner_Notify(This,type,pContext)	\
    ( (This)->lpVtbl -> Notify(This,type,pContext) ) 

#define IWMPContentPartner_GetItemInfo(This,bstrInfoName,pContext,pData)	\
    ( (This)->lpVtbl -> GetItemInfo(This,bstrInfoName,pContext,pData) ) 

#define IWMPContentPartner_GetContentPartnerInfo(This,bstrInfoName,pData)	\
    ( (This)->lpVtbl -> GetContentPartnerInfo(This,bstrInfoName,pData) ) 

#define IWMPContentPartner_GetCommands(This,location,pLocationContext,itemLocation,cItemIDs,prgItemIDs,pcItemIDs,pprgItems)	\
    ( (This)->lpVtbl -> GetCommands(This,location,pLocationContext,itemLocation,cItemIDs,prgItemIDs,pcItemIDs,pprgItems) ) 

#define IWMPContentPartner_InvokeCommand(This,dwCommandID,location,pLocationContext,itemLocation,cItemIDs,rgItemIDs)	\
    ( (This)->lpVtbl -> InvokeCommand(This,dwCommandID,location,pLocationContext,itemLocation,cItemIDs,rgItemIDs) ) 

#define IWMPContentPartner_CanBuySilent(This,pInfo,pbstrTotalPrice,pSilentOK)	\
    ( (This)->lpVtbl -> CanBuySilent(This,pInfo,pbstrTotalPrice,pSilentOK) ) 

#define IWMPContentPartner_Buy(This,pInfo,cookie)	\
    ( (This)->lpVtbl -> Buy(This,pInfo,cookie) ) 

#define IWMPContentPartner_GetStreamingURL(This,st,pStreamContext,pbstrURL)	\
    ( (This)->lpVtbl -> GetStreamingURL(This,st,pStreamContext,pbstrURL) ) 

#define IWMPContentPartner_Download(This,pInfo,cookie)	\
    ( (This)->lpVtbl -> Download(This,pInfo,cookie) ) 

#define IWMPContentPartner_DownloadTrackComplete(This,hrResult,contentID,downloadTrackParam)	\
    ( (This)->lpVtbl -> DownloadTrackComplete(This,hrResult,contentID,downloadTrackParam) ) 

#define IWMPContentPartner_RefreshLicense(This,dwCookie,fLocal,bstrURL,type,contentID,bstrRefreshReason,pReasonContext)	\
    ( (This)->lpVtbl -> RefreshLicense(This,dwCookie,fLocal,bstrURL,type,contentID,bstrRefreshReason,pReasonContext) ) 

#define IWMPContentPartner_GetCatalogURL(This,dwCatalogVersion,dwCatalogSchemaVersion,catalogLCID,pdwNewCatalogVersion,pbstrCatalogURL,pExpirationDate)	\
    ( (This)->lpVtbl -> GetCatalogURL(This,dwCatalogVersion,dwCatalogSchemaVersion,catalogLCID,pdwNewCatalogVersion,pbstrCatalogURL,pExpirationDate) ) 

#define IWMPContentPartner_GetTemplate(This,task,location,pContext,clickLocation,pClickContext,bstrFilter,bstrViewParams,pbstrTemplateURL,pTemplateSize)	\
    ( (This)->lpVtbl -> GetTemplate(This,task,location,pContext,clickLocation,pClickContext,bstrFilter,bstrViewParams,pbstrTemplateURL,pTemplateSize) ) 

#define IWMPContentPartner_UpdateDevice(This,bstrDeviceName)	\
    ( (This)->lpVtbl -> UpdateDevice(This,bstrDeviceName) ) 

#define IWMPContentPartner_GetListContents(This,location,pContext,bstrListType,bstrParams,dwListCookie)	\
    ( (This)->lpVtbl -> GetListContents(This,location,pContext,bstrListType,bstrParams,dwListCookie) ) 

#define IWMPContentPartner_Login(This,userInfo,pwdInfo,fUsedCachedCreds,fOkToCache)	\
    ( (This)->lpVtbl -> Login(This,userInfo,pwdInfo,fUsedCachedCreds,fOkToCache) ) 

#define IWMPContentPartner_Authenticate(This,userInfo,pwdInfo)	\
    ( (This)->lpVtbl -> Authenticate(This,userInfo,pwdInfo) ) 

#define IWMPContentPartner_Logout(This)	\
    ( (This)->lpVtbl -> Logout(This) ) 

#define IWMPContentPartner_SendMessage(This,bstrMsg,bstrParam)	\
    ( (This)->lpVtbl -> SendMessage(This,bstrMsg,bstrParam) ) 

#define IWMPContentPartner_StationEvent(This,bstrStationEventType,StationId,PlaylistIndex,TrackID,TrackData,dwSecondsPlayed)	\
    ( (This)->lpVtbl -> StationEvent(This,bstrStationEventType,StationId,PlaylistIndex,TrackID,TrackData,dwSecondsPlayed) ) 

#define IWMPContentPartner_CompareContainerListPrices(This,pListBase,pListCompare,pResult)	\
    ( (This)->lpVtbl -> CompareContainerListPrices(This,pListBase,pListCompare,pResult) ) 

#define IWMPContentPartner_VerifyPermission(This,bstrPermission,pContext)	\
    ( (This)->lpVtbl -> VerifyPermission(This,bstrPermission,pContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPContentPartner_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\cor.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 **                                                                         **
 ** Cor.h - general header for the Runtime.                                 **
 **                                                                         **
 *****************************************************************************/


#ifndef _COR_H_
#define _COR_H_

//*****************************************************************************
// Required includes
#include <ole2.h>                       // Definitions of OLE types.
#include <specstrings.h>
#include "corerror.h"

//*****************************************************************************

#ifdef __cplusplus
extern "C" {
#endif

// {BED7F4EA-1A96-11d2-8F08-00A0C9A6186D}
EXTERN_GUID(LIBID_ComPlusRuntime, 0xbed7f4ea, 0x1a96, 0x11d2, 0x8f, 0x8, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d);

// {90883F05-3D28-11D2-8F17-00A0C9A6186D}
EXTERN_GUID(GUID_ExportedFromComPlus, 0x90883f05, 0x3d28, 0x11d2, 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d);

// {0F21F359-AB84-41e8-9A78-36D110E6D2F9}
EXTERN_GUID(GUID_ManagedName, 0xf21f359, 0xab84, 0x41e8, 0x9a, 0x78, 0x36, 0xd1, 0x10, 0xe6, 0xd2, 0xf9);

// {54FC8F55-38DE-4703-9C4E-250351302B1C}
EXTERN_GUID(GUID_Function2Getter, 0x54fc8f55, 0x38de, 0x4703, 0x9c, 0x4e, 0x25, 0x3, 0x51, 0x30, 0x2b, 0x1c);

// CLSID_CorMetaDataDispenserRuntime: {1EC2DE53-75CC-11d2-9775-00A0C9B4D50C}
//  Dispenser coclass for version 1.5 and 2.0 meta data.  To get the "latest" bind
//  to CLSID_MetaDataDispenser.
EXTERN_GUID(CLSID_CorMetaDataDispenserRuntime, 0x1ec2de53, 0x75cc, 0x11d2, 0x97, 0x75, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);

// {CD2BC5C9-F452-4326-B714-F9C539D4DA58}
EXTERN_GUID(GUID_DispIdOverride, 0xcd2bc5c9, 0xf452, 0x4326, 0xb7, 0x14, 0xf9, 0xc5, 0x39, 0xd4, 0xda, 0x58);

// {B64784EB-D8D4-4d9b-9ACD-0E30806426F7}
EXTERN_GUID(GUID_ForceIEnumerable, 0xb64784eb, 0xd8d4, 0x4d9b, 0x9a, 0xcd, 0x0e, 0x30, 0x80, 0x64, 0x26, 0xf7);

// {2941FF83-88D8-4F73-B6A9-BDF8712D000D}
EXTERN_GUID(GUID_PropGetCA, 0x2941ff83, 0x88d8, 0x4f73, 0xb6, 0xa9, 0xbd, 0xf8, 0x71, 0x2d, 0x00, 0x0d);

// {29533527-3683-4364-ABC0-DB1ADD822FA2}
EXTERN_GUID(GUID_PropPutCA, 0x29533527, 0x3683, 0x4364, 0xab, 0xc0, 0xdb, 0x1a, 0xdd, 0x82, 0x2f, 0xa2);

// CLSID_CLR_v1_MetaData: {005023CA-72B1-11D3-9FC4-00C04F79A0A3}
//  Used to generate v1 metadata (for v1.0 and v1.1 CLR compatibility).
EXTERN_GUID(CLSID_CLR_v1_MetaData, 0x005023ca, 0x72b1, 0x11d3, 0x9f, 0xc4, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3);

// CLSID_CLR_v2_MetaData: {EFEA471A-44FD-4862-9292-0C58D46E1F3A}
//  Used to generate v1 metadata (for v1.0 and v1.1 CLR compatibility).
EXTERN_GUID(CLSID_CLR_v2_MetaData, 0xefea471a, 0x44fd, 0x4862, 0x92, 0x92, 0xc, 0x58, 0xd4, 0x6e, 0x1f, 0x3a);


// CLSID_CorMetaDataRuntime:
// This will can always be used to generate the "latest" metadata available.
#define CLSID_CorMetaDataRuntime CLSID_CLR_v2_MetaData


// {30FE7BE8-D7D9-11D2-9F80-00C04F79A0A3}
EXTERN_GUID(MetaDataCheckDuplicatesFor, 0x30fe7be8, 0xd7d9, 0x11d2, 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3);

// {DE3856F8-D7D9-11D2-9F80-00C04F79A0A3}
EXTERN_GUID(MetaDataRefToDefCheck, 0xde3856f8, 0xd7d9, 0x11d2, 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3);

// {E5D71A4C-D7DA-11D2-9F80-00C04F79A0A3}
EXTERN_GUID(MetaDataNotificationForTokenMovement, 0xe5d71a4c, 0xd7da, 0x11d2, 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3);

// {2eee315c-d7db-11d2-9f80-00c04f79a0a3}
EXTERN_GUID(MetaDataSetUpdate, 0x2eee315c, 0xd7db, 0x11d2, 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3);
#define MetaDataSetENC MetaDataSetUpdate

// Use this guid in SetOption to indicate if the import enumerator should skip over
// delete items or not. The default is yes.
//
// {79700F36-4AAC-11d3-84C3-009027868CB1}
EXTERN_GUID(MetaDataImportOption, 0x79700f36, 0x4aac, 0x11d3, 0x84, 0xc3, 0x0, 0x90, 0x27, 0x86, 0x8c, 0xb1);

// Use this guid in the SetOption if compiler wants to have MetaData API to take reader/writer lock
//
// {F7559806-F266-42ea-8C63-0ADB45E8B234}
EXTERN_GUID(MetaDataThreadSafetyOptions, 0xf7559806, 0xf266, 0x42ea, 0x8c, 0x63, 0xa, 0xdb, 0x45, 0xe8, 0xb2, 0x34);

// Use this guid in the SetOption if compiler wants error when some tokens are emitted out of order
// {1547872D-DC03-11d2-9420-0000F8083460}
EXTERN_GUID(MetaDataErrorIfEmitOutOfOrder, 0x1547872d, 0xdc03, 0x11d2, 0x94, 0x20, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60);

// Use this guid in the SetOption to indicate if the tlbimporter should generate the
// TCE adapters for COM connection point containers.
// {DCC9DE90-4151-11d3-88D6-00902754C43A}
EXTERN_GUID(MetaDataGenerateTCEAdapters, 0xdcc9de90, 0x4151, 0x11d3, 0x88, 0xd6, 0x0, 0x90, 0x27, 0x54, 0xc4, 0x3a);

// Use this guid in the SetOption to specifiy a non-default namespace for typelib import.
// {F17FF889-5A63-11d3-9FF2-00C04FF7431A}
EXTERN_GUID(MetaDataTypeLibImportNamespace, 0xf17ff889, 0x5a63, 0x11d3, 0x9f, 0xf2, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a);

// Use this guid in the SetOption to specify the behavior of UnmarkAll. See CorLinkerOptions.
// {47E099B6-AE7C-4797-8317-B48AA645B8F9}
EXTERN_GUID(MetaDataLinkerOptions, 0x47e099b6, 0xae7c, 0x4797, 0x83, 0x17, 0xb4, 0x8a, 0xa6, 0x45, 0xb8, 0xf9);

// Use this guid in the SetOption to specify the runtime version stored in the CLR metadata.
// {47E099B7-AE7C-4797-8317-B48AA645B8F9}
EXTERN_GUID(MetaDataRuntimeVersion, 0x47e099b7, 0xae7c, 0x4797, 0x83, 0x17, 0xb4, 0x8a, 0xa6, 0x45, 0xb8, 0xf9);

// Use this guid in the SetOption to specify the behavior of the merger.
// {132D3A6E-B35D-464e-951A-42EFB9FB6601}
EXTERN_GUID(MetaDataMergerOptions, 0x132d3a6e, 0xb35d, 0x464e, 0x95, 0x1a, 0x42, 0xef, 0xb9, 0xfb, 0x66, 0x1);


interface IMetaDataImport;
interface IMetaDataAssemblyEmit;
interface IMetaDataAssemblyImport;
interface IMetaDataEmit;
interface ICeeGen;


typedef UNALIGNED void const *UVCP_CONSTANT;


// Constant for connection id and task id
#define INVALID_CONNECTION_ID   0x0
#define INVALID_TASK_ID         0x0 
#define MAX_CONNECTION_NAME     MAX_PATH

//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************

BOOL STDMETHODCALLTYPE _CorDllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);
__int32 STDMETHODCALLTYPE _CorExeMain();
__int32 STDMETHODCALLTYPE _CorExeMain2( // Executable exit code.
    PBYTE   pUnmappedPE,                // -> memory mapped code
    DWORD   cUnmappedPE,                // Size of memory mapped code
    __in LPWSTR  pImageNameIn,          // -> Executable Name
    __in LPWSTR  pLoadersFileName,      // -> Loaders Name
    __in LPWSTR  pCmdLine);             // -> Command Line

STDAPI _CorValidateImage(PVOID *ImageBase, LPCWSTR FileName);
STDAPI_(VOID) _CorImageUnloading(PVOID ImageBase);

STDAPI          CoInitializeEE(DWORD fFlags);   
STDAPI_(void)   CoUninitializeEE(BOOL fFlags);  
STDAPI_(void)   CoEEShutDownCOM(void);

#ifndef FEATURE_PAL

#define MSCOREE_SHIM_W                L"mscoree.dll"
#define MSCOREE_SHIM_A                "mscoree.dll"

#else // !FEATURE_PAL

#define MSCOREE_SHIM_W                MAKEDLLNAME_W(L"sscoree")
#define MSCOREE_SHIM_A                MAKEDLLNAME_A("sscoree")

#endif // !FEATURE_PAL

#define SWITCHOUT_HANDLE_VALUE ((HANDLE)(LONG_PTR)-2)


//
// CoInitializeCor flags.
//
typedef enum tagCOINITCOR
{
    COINITCOR_DEFAULT       = 0x0           // Default initialization mode. 
} COINITICOR;

//
// CoInitializeEE flags.
//
typedef enum tagCOINITEE
{
    COINITEE_DEFAULT        = 0x0,          // Default initialization mode. 
    COINITEE_DLL            = 0x1,          // Initialization mode for loading DLL. 
    COINITEE_MAIN           = 0x2           // Initialize prior to entering the main routine 
} COINITIEE;

//
// CoInitializeEE flags.
//
typedef enum tagCOUNINITEE
{
    COUNINITEE_DEFAULT      = 0x0,          // Default uninitialization mode.   
    COUNINITEE_DLL          = 0x1           // Uninitialization mode for unloading DLL. 
} COUNINITIEE;

//*****************************************************************************
//*****************************************************************************
//
// I L   &   F I L E   F O R M A T   D E C L A R A T I O N S    
//
//*****************************************************************************
//*****************************************************************************


// <STRIP>The following definitions will get moved into <windows.h> by RTM but are
// kept here for the Alpha's and Beta's.</STRIP>
#ifndef _WINDOWS_UPDATES_
#include <corhdr.h>
#endif // <windows.h> updates

//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************

STDAPI          CoInitializeCor(DWORD fFlags);
STDAPI_(void)   CoUninitializeCor(void);

typedef void (* TDestructorCallback)(EXCEPTION_RECORD*);
STDAPI_(void) AddDestructorCallback(int code, TDestructorCallback callback);

//
//*****************************************************************************
//*****************************************************************************

// CLSID_Cor: {bee00000-ee77-11d0-a015-00c04fbbb884}
EXTERN_GUID(CLSID_Cor, 0xbee00010, 0xee77, 0x11d0, 0xa0, 0x15, 0x00, 0xc0, 0x4f, 0xbb, 0xb8, 0x84);

// CLSID_CorMetaDataDispenser: {E5CB7A31-7512-11d2-89CE-0080C792E5D8}
//  This is the "Master Dispenser", always guaranteed to be the most recent
//  dispenser on the machine.
EXTERN_GUID(CLSID_CorMetaDataDispenser, 0xe5cb7a31, 0x7512, 0x11d2, 0x89, 0xce, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8);


// CLSID_CorMetaDataDispenserReg: {435755FF-7397-11d2-9771-00A0C9B4D50C}
//  Dispenser coclass for version 1.0 meta data.  To get the "latest" bind
//  to CLSID_CorMetaDataDispenser.
EXTERN_GUID(CLSID_CorMetaDataDispenserReg, 0x435755ff, 0x7397, 0x11d2, 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);


// CLSID_CorMetaDataReg: {87F3A1F5-7397-11d2-9771-00A0C9B4D50C}
// For COM+ Meta Data, Data Driven Registration
EXTERN_GUID(CLSID_CorMetaDataReg, 0x87f3a1f5, 0x7397, 0x11d2, 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);

// IID_IMetaDataInternal {39EE28B3-0181-4d48-B53C-2FFAFFD5FEC1}
EXTERN_GUID(IID_IMetaDataInternal, 0x39ee28b3, 0x181, 0x4d48, 0xb5, 0x3c, 0x2f, 0xfa, 0xff, 0xd5, 0xfe, 0xc1);


interface IMetaDataDispenser;

//-------------------------------------
//--- IMetaDataError
//-------------------------------------
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
EXTERN_GUID(IID_IMetaDataError, 0xb81ff171, 0x20f3, 0x11d2, 0x8d, 0xcc, 0x0, 0xa0, 0xc9, 0xb0, 0x9c, 0x19);

//---
#undef  INTERFACE
#define INTERFACE IMetaDataError
DECLARE_INTERFACE_(IMetaDataError, IUnknown)
{
    STDMETHOD(OnError)(HRESULT hrError, mdToken token) PURE;
};

//-------------------------------------
//--- IMapToken
//-------------------------------------
// IID_IMapToken: {06A3EA8B-0225-11d1-BF72-00C04FC31E12}
EXTERN_GUID(IID_IMapToken, 0x6a3ea8b, 0x225, 0x11d1, 0xbf, 0x72, 0x0, 0xc0, 0x4f, 0xc3, 0x1e, 0x12);

//---
#undef  INTERFACE
#define INTERFACE IMapToken
DECLARE_INTERFACE_(IMapToken, IUnknown)
{
    STDMETHOD(Map)(mdToken tkImp, mdToken tkEmit) PURE;
};

//-------------------------------------
//--- IMetaDataDispenser
//-------------------------------------
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
EXTERN_GUID(IID_IMetaDataDispenser, 0x809c652e, 0x7396, 0x11d2, 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);

//---
#undef  INTERFACE
#define INTERFACE IMetaDataDispenser
DECLARE_INTERFACE_(IMetaDataDispenser, IUnknown)
{
    STDMETHOD(DefineScope)(                 // Return code.
        REFCLSID    rclsid,                 // [in] What version to create.
        DWORD       dwCreateFlags,          // [in] Flags on the create.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScope)(                   // Return code.
        LPCWSTR     szScope,                // [in] The scope to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScopeOnMemory)(           // Return code.
        LPCVOID     pData,                  // [in] Location of scope data.
        ULONG       cbData,                 // [in] Size of the data pointed to by pData.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.
};

//-------------------------------------
//--- IMetaDataEmit
//-------------------------------------
// {BA3FEE4C-ECB9-4e41-83B7-183FA41CD859}
EXTERN_GUID(IID_IMetaDataEmit, 0xba3fee4c, 0xecb9, 0x4e41, 0x83, 0xb7, 0x18, 0x3f, 0xa4, 0x1c, 0xd8, 0x59);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataEmit
DECLARE_INTERFACE_(IMetaDataEmit, IUnknown)
{
    STDMETHOD(SetModuleProps)(              // S_OK or error.
        LPCWSTR     szName) PURE;           // [IN] If not NULL, the name of the module to set.

    STDMETHOD(Save)(                        // S_OK or error.
        LPCWSTR     szFile,                 // [IN] The filename to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(SaveToStream)(                // S_OK or error.
        IStream     *pIStream,              // [IN] A writable stream to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(GetSaveSize)(                 // S_OK or error.
        CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
        DWORD       *pdwSaveSize) PURE;     // [OUT] Put the size here.

    STDMETHOD(DefineTypeDef)(               // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(DefineNestedType)(            // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   tdEncloser,             // [IN] TypeDef token of the enclosing type.
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(SetHandler)(                  // S_OK.
        IUnknown    *pUnk) PURE;            // [IN] The new error handler.

    STDMETHOD(DefineMethod)(                // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwMethodFlags,          // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        ULONG       ulCodeRVA,  
        DWORD       dwImplFlags,    
        mdMethodDef *pmd) PURE;             // Put member token here     

    STDMETHOD(DefineMethodImpl)(            // S_OK or error.   
        mdTypeDef   td,                     // [IN] The class implementing the method   
        mdToken     tkBody,                 // [IN] Method body - MethodDef or MethodRef
        mdToken     tkDecl) PURE;           // [IN] Method declaration - MethodDef or MethodRef

    STDMETHOD(DefineTypeRefByName)(         // S_OK or error.   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] Name of the TypeRef.
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.    

    STDMETHOD(DefineImportType)(            // S_OK or error.   
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assembly containing the TypeDef.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *pImport,           // [IN] Scope containing the TypeDef.   
        mdTypeDef   tdImport,               // [IN] The imported TypeDef.   
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the TypeDef is imported.
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.

    STDMETHOD(DefineMemberRef)(             // S_OK or error    
        mdToken     tkImport,               // [IN] ClassRef or ClassDef importing a member.    
        LPCWSTR     szName,                 // [IN] member's name   
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] memberref token    

    STDMETHOD(DefineImportMember)(          // S_OK or error.   
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assembly containing the Member.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *pImport,           // [IN] Import scope, with member.  
        mdToken     mbMember,               // [IN] Member in import scope.   
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the Member is imported.
        mdToken     tkParent,               // [IN] Classref or classdef in emit scope.    
        mdMemberRef *pmr) PURE;             // [OUT] Put member ref here.   

    STDMETHOD(DefineEvent) (    
        mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
        LPCWSTR     szEvent,                // [IN] Name of the event   
        DWORD       dwEventFlags,           // [IN] CorEventAttr    
        mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
        mdMethodDef mdAddOn,                // [IN] required add method 
        mdMethodDef mdRemoveOn,             // [IN] required remove method  
        mdMethodDef mdFire,                 // [IN] optional fire method    
        mdMethodDef rmdOtherMethods[],      // [IN] optional array of other methods associate with the event    
        mdEvent     *pmdEvent) PURE;        // [OUT] output event token 

    STDMETHOD(SetClassLayout) (   
        mdTypeDef   td,                     // [IN] typedef 
        DWORD       dwPackSize,             // [IN] packing size specified as 1, 2, 4, 8, or 16 
        COR_FIELD_OFFSET rFieldOffsets[],   // [IN] array of layout specification   
        ULONG       ulClassSize) PURE;      // [IN] size of the class   

    STDMETHOD(DeleteClassLayout) (
        mdTypeDef   td) PURE;               // [IN] typedef whose layout is to be deleted.

    STDMETHOD(SetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a fieldDef or paramDef token  
        PCCOR_SIGNATURE pvNativeType,       // [IN] native type specification   
        ULONG       cbNativeType) PURE;     // [IN] count of bytes of pvNativeType  

    STDMETHOD(DeleteFieldMarshal) (
        mdToken     tk) PURE;               // [IN] given a fieldDef or paramDef token

    STDMETHOD(DefinePermissionSet) (    
        mdToken     tk,                     // [IN] the object to be decorated. 
        DWORD       dwAction,               // [IN] CorDeclSecurity.    
        void const  *pvPermission,          // [IN] permission blob.    
        ULONG       cbPermission,           // [IN] count of bytes of pvPermission. 
        mdPermission *ppm) PURE;            // [OUT] returned permission token. 

    STDMETHOD(SetRVA)(                      // S_OK or error.   
        mdMethodDef md,                     // [IN] Method for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset    

    STDMETHOD(GetTokenFromSig)(             // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.    
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdSignature *pmsig) PURE;           // [OUT] returned signature token.  

    STDMETHOD(DefineModuleRef)(             // S_OK or error.   
        LPCWSTR     szName,                 // [IN] DLL name    
        mdModuleRef *pmur) PURE;            // [OUT] returned   

    // <TODO>@FUTURE:  This should go away once everyone starts using SetMemberRefProps.</TODO>
    STDMETHOD(SetParent)(                   // S_OK or error.   
        mdMemberRef mr,                     // [IN] Token for the ref to be fixed up.   
        mdToken     tk) PURE;               // [IN] The ref parent. 

    STDMETHOD(GetTokenFromTypeSpec)(        // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] TypeSpec Signature to define.  
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdTypeSpec *ptypespec) PURE;        // [OUT] returned TypeSpec token.  

    STDMETHOD(SaveToMemory)(                // S_OK or error.
        void        *pbData,                // [OUT] Location to write data.
        ULONG       cbData) PURE;           // [IN] Max size of data buffer.

    STDMETHOD(DefineUserString)(            // Return code.
        LPCWSTR szString,                   // [IN] User literal string.
        ULONG       cchString,              // [IN] Length of string.
        mdString    *pstk) PURE;            // [OUT] String token.

    STDMETHOD(DeleteToken)(                 // Return code.
        mdToken     tkObj) PURE;            // [IN] The token to be deleted

    STDMETHOD(SetMethodProps)(              // S_OK or error.
        mdMethodDef md,                     // [IN] The MethodDef.
        DWORD       dwMethodFlags,          // [IN] Method attributes.
        ULONG       ulCodeRVA,              // [IN] Code RVA.
        DWORD       dwImplFlags) PURE;      // [IN] Impl flags.

    STDMETHOD(SetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] The TypeDef.
        DWORD       dwTypeDefFlags,         // [IN] TypeDef flags.
        mdToken     tkExtends,              // [IN] Base TypeDef or TypeRef.
        mdToken     rtkImplements[]) PURE;  // [IN] Implemented interfaces.

    STDMETHOD(SetEventProps)(               // S_OK or error.
        mdEvent     ev,                     // [IN] The event token.
        DWORD       dwEventFlags,           // [IN] CorEventAttr.
        mdToken     tkEventType,            // [IN] A reference (mdTypeRef or mdTypeRef) to the Event class.
        mdMethodDef mdAddOn,                // [IN] Add method.
        mdMethodDef mdRemoveOn,             // [IN] Remove method.
        mdMethodDef mdFire,                 // [IN] Fire method.
        mdMethodDef rmdOtherMethods[]) PURE;// [IN] Array of other methods associate with the event.

    STDMETHOD(SetPermissionSetProps)(       // S_OK or error.
        mdToken     tk,                     // [IN] The object to be decorated.
        DWORD       dwAction,               // [IN] CorDeclSecurity.
        void const  *pvPermission,          // [IN] Permission blob.
        ULONG       cbPermission,           // [IN] Count of bytes of pvPermission.
        mdPermission *ppm) PURE;            // [OUT] Permission token.

    STDMETHOD(DefinePinvokeMap)(            // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(SetPinvokeMap)(               // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(DeletePinvokeMap)(            // Return code.
        mdToken     tk) PURE;               // [IN] FieldDef or MethodDef.

    // New CustomAttribute functions.
    STDMETHOD(DefineCustomAttribute)(       // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdToken     tkType,                 // [IN] Type of the CustomAttribute (TypeRef/TypeDef).
        void const  *pCustomAttribute,      // [IN] The custom value data.
        ULONG       cbCustomAttribute,      // [IN] The custom value data length.
        mdCustomAttribute *pcv) PURE;       // [OUT] The custom value token value on return.

    STDMETHOD(SetCustomAttributeValue)(     // Return code.
        mdCustomAttribute pcv,              // [IN] The custom value token whose value to replace.
        void const  *pCustomAttribute,      // [IN] The custom value data.
        ULONG       cbCustomAttribute) PURE;// [IN] The custom value data length.

    STDMETHOD(DefineField)(                 // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwFieldFlags,           // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdFieldDef  *pmd) PURE;             // [OUT] Put member token here    

    STDMETHOD(DefineProperty)( 
        mdTypeDef   td,                     // [IN] the class/interface on which the property is being defined  
        LPCWSTR     szProperty,             // [IN] Name of the property    
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr 
        PCCOR_SIGNATURE pvSig,              // [IN] the required type signature 
        ULONG       cbSig,                  // [IN] the size of the type signature blob 
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] optional setter of the property 
        mdMethodDef mdGetter,               // [IN] optional getter of the property 
        mdMethodDef rmdOtherMethods[],      // [IN] an optional array of other methods  
        mdProperty  *pmdProp) PURE;         // [OUT] output property token  

    STDMETHOD(DefineParam)(
        mdMethodDef md,                     // [IN] Owning method   
        ULONG       ulParamSeq,             // [IN] Which param 
        LPCWSTR     szName,                 // [IN] Optional param name 
        DWORD       dwParamFlags,           // [IN] Optional param flags    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdParamDef  *ppd) PURE;             // [OUT] Put param token here   

    STDMETHOD(SetFieldProps)(               // S_OK or error.
        mdFieldDef  fd,                     // [IN] The FieldDef.
        DWORD       dwFieldFlags,           // [IN] Field attributes.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    STDMETHOD(SetPropertyProps)(            // S_OK or error.
        mdProperty  pr,                     // [IN] Property token.
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] Setter of the property.
        mdMethodDef mdGetter,               // [IN] Getter of the property.
        mdMethodDef rmdOtherMethods[]) PURE;// [IN] Array of other methods.

    STDMETHOD(SetParamProps)(               // Return code.
        mdParamDef  pd,                     // [IN] Param token.   
        LPCWSTR     szName,                 // [IN] Param name.
        DWORD       dwParamFlags,           // [IN] Param flags.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
        void const  *pValue,                // [OUT] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    // Specialized Custom Attributes for security.
    STDMETHOD(DefineSecurityAttributeSet)(  // Return code.
        mdToken     tkObj,                  // [IN] Class or method requiring security attributes.
        COR_SECATTR rSecAttrs[],            // [IN] Array of security attribute descriptions.
        ULONG       cSecAttrs,              // [IN] Count of elements in above array.
        ULONG       *pulErrorAttr) PURE;    // [OUT] On error, index of attribute causing problem.

    STDMETHOD(ApplyEditAndContinue)(        // S_OK or error.
        IUnknown    *pImport) PURE;         // [IN] Metadata from the delta PE.

    STDMETHOD(TranslateSigWithScope)(
        IMetaDataAssemblyImport *pAssemImport, // [IN] importing assembly interface
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *import,            // [IN] importing interface
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] emit assembly interface
        IMetaDataEmit *emit,                // [IN] emit interface
        PCOR_SIGNATURE pvTranslatedSig,     // [OUT] buffer to hold translated signature
        ULONG       cbTranslatedSigMax,
        ULONG       *pcbTranslatedSig) PURE;// [OUT] count of bytes in the translated signature

    STDMETHOD(SetMethodImplFlags)(          // [IN] S_OK or error.  
        mdMethodDef md,                     // [IN] Method for which to set ImplFlags 
        DWORD       dwImplFlags) PURE;  

    STDMETHOD(SetFieldRVA)(                 // [IN] S_OK or error.  
        mdFieldDef  fd,                     // [IN] Field for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset  

    STDMETHOD(Merge)(                       // S_OK or error.
        IMetaDataImport *pImport,           // [IN] The scope to be merged.
        IMapToken   *pHostMapToken,         // [IN] Host IMapToken interface to receive token remap notification
        IUnknown    *pHandler) PURE;        // [IN] An object to receive to receive error notification.

    STDMETHOD(MergeEnd)() PURE;             // S_OK or error.

    // This interface is sealed.  Do not change, add, or remove anything.  Instead, derive a new iterface.

};      // IMetaDataEmit

//-------------------------------------
//--- IMetaDataEmit2
//-------------------------------------
// {F5DD9950-F693-42e6-830E-7B833E8146A9}
EXTERN_GUID(IID_IMetaDataEmit2, 0xf5dd9950, 0xf693, 0x42e6, 0x83, 0xe, 0x7b, 0x83, 0x3e, 0x81, 0x46, 0xa9);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataEmit2
DECLARE_INTERFACE_(IMetaDataEmit2, IMetaDataEmit)
{
    STDMETHOD(DefineMethodSpec)(
        mdToken     tkParent,               // [IN] MethodDef or MemberRef
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMethodSpec *pmi) PURE;            // [OUT] method instantiation token

    STDMETHOD(GetDeltaSaveSize)(            // S_OK or error.
        CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
        DWORD       *pdwSaveSize) PURE;     // [OUT] Put the size here.

    STDMETHOD(SaveDelta)(                   // S_OK or error.
        LPCWSTR     szFile,                 // [IN] The filename to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(SaveDeltaToStream)(           // S_OK or error.
        IStream     *pIStream,              // [IN] A writable stream to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(SaveDeltaToMemory)(           // S_OK or error.
        void        *pbData,                // [OUT] Location to write data.
        ULONG       cbData) PURE;           // [IN] Max size of data buffer.

    STDMETHOD(DefineGenericParam)(          // S_OK or error.
        mdToken      tk,                    // [IN] TypeDef or MethodDef
        ULONG        ulParamSeq,            // [IN] Index of the type parameter
        DWORD        dwParamFlags,          // [IN] Flags, for future use (e.g. variance)
        LPCWSTR      szname,                // [IN] Name
        DWORD        reserved,              // [IN] For future use (e.g. non-type parameters)
        mdToken      rtkConstraints[],      // [IN] Array of type constraints (TypeDef,TypeRef,TypeSpec)
        mdGenericParam *pgp) PURE;          // [OUT] Put GenericParam token here

    STDMETHOD(SetGenericParamProps)(        // S_OK or error.
        mdGenericParam gp,                  // [IN] GenericParam
        DWORD        dwParamFlags,          // [IN] Flags, for future use (e.g. variance)
        LPCWSTR      szName,                // [IN] Optional name
        DWORD        reserved,              // [IN] For future use (e.g. non-type parameters)
        mdToken      rtkConstraints[]) PURE;// [IN] Array of type constraints (TypeDef,TypeRef,TypeSpec)
    
    STDMETHOD(ResetENCLog)() PURE;          // S_OK or error.

};

//-------------------------------------
//--- IMetaDataImport
//-------------------------------------
// {7DAC8207-D3AE-4c75-9B67-92801A497D44}
EXTERN_GUID(IID_IMetaDataImport, 0x7dac8207, 0xd3ae, 0x4c75, 0x9b, 0x67, 0x92, 0x80, 0x1a, 0x49, 0x7d, 0x44);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataImport
DECLARE_INTERFACE_(IMetaDataImport, IUnknown)
{
    STDMETHOD_(void, CloseEnum)(HCORENUM hEnum) PURE;
    STDMETHOD(CountEnum)(HCORENUM hEnum, ULONG *pulCount) PURE;
    STDMETHOD(ResetEnum)(HCORENUM hEnum, ULONG ulPos) PURE;
    STDMETHOD(EnumTypeDefs)(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
                            ULONG cMax, ULONG *pcTypeDefs) PURE;
    STDMETHOD(EnumInterfaceImpls)(HCORENUM *phEnum, mdTypeDef td,
                            mdInterfaceImpl rImpls[], ULONG cMax,
                            ULONG* pcImpls) PURE;
    STDMETHOD(EnumTypeRefs)(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
                            ULONG cMax, ULONG* pcTypeRefs) PURE;

    STDMETHOD(FindTypeDefByName)(           // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of the Type.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef for Enclosing class.
        mdTypeDef   *ptd) PURE;             // [OUT] Put the TypeDef token here.

    STDMETHOD(GetScopeProps)(               // S_OK or error.
      __out_ecount_part_opt(cchName, *pchName)
        LPWSTR      szName,                 // [OUT] Put the name here.
        ULONG       cchName,                // [IN] Size of name buffer in wide chars.
        ULONG       *pchName,               // [OUT] Put size of name (wide chars) here.
        GUID        *pmvid) PURE;           // [OUT, OPTIONAL] Put MVID here.

    STDMETHOD(GetModuleFromScope)(          // S_OK.
        mdModule    *pmd) PURE;             // [OUT] Put mdModule token here.

    STDMETHOD(GetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] TypeDef token for inquiry.
      __out_ecount_part_opt(cchTypeDef, pchTypeDef)
        LPWSTR      szTypeDef,              // [OUT] Put name here.
        ULONG       cchTypeDef,             // [IN] size of name buffer in wide chars.
        ULONG       *pchTypeDef,            // [OUT] put size of name (wide chars) here.
        DWORD       *pdwTypeDefFlags,       // [OUT] Put flags here.
        mdToken     *ptkExtends) PURE;      // [OUT] Put base class TypeDef/TypeRef here.

    STDMETHOD(GetInterfaceImplProps)(       // S_OK or error.
        mdInterfaceImpl iiImpl,             // [IN] InterfaceImpl token.
        mdTypeDef   *pClass,                // [OUT] Put implementing class token here.
        mdToken     *ptkIface) PURE;        // [OUT] Put implemented interface token here.  
            
    STDMETHOD(GetTypeRefProps)(             // S_OK or error.
        mdTypeRef   tr,                     // [IN] TypeRef token.
        mdToken     *ptkResolutionScope,    // [OUT] Resolution scope, ModuleRef or AssemblyRef.
      __out_ecount_part_opt(cchName, *pchName)
        LPWSTR      szName,                 // [OUT] Name of the TypeRef.
        ULONG       cchName,                // [IN] Size of buffer.
        ULONG       *pchName) PURE;         // [OUT] Size of Name.

    STDMETHOD(ResolveTypeRef)(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd) PURE;

    STDMETHOD(EnumMembers)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMembersWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethods)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.   
        ULONG       cMax,                   // [IN] Max MethodDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodsWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdMethodDef rMethods[],             // [OU] Put MethodDefs here.    
        ULONG       cMax,                   // [IN] Max MethodDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFields)(                  // S_OK, S_FALSE, or error.  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdFieldDef  rFields[],              // [OUT] Put FieldDefs here.    
        ULONG       cMax,                   // [IN] Max FieldDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFieldsWithName)(          // S_OK, S_FALSE, or error.              
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    


    STDMETHOD(EnumParams)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdParamDef  rParams[],              // [OUT] Put ParamDefs here.    
        ULONG       cMax,                   // [IN] Max ParamDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMemberRefs)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tkParent,               // [IN] Parent token to scope the enumeration.  
        mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.   
        ULONG       cMax,                   // [IN] Max MemberRefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodImpls)(             // S_OK, S_FALSE, or error  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMethodBody[],          // [OUT] Put Method Body tokens here.   
        mdToken     rMethodDecl[],          // [OUT] Put Method Declaration tokens here.
        ULONG       cMax,                   // [IN] Max tokens to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumPermissionSets)(          // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.    
        DWORD       dwActions,              // [IN] if !0, return only these actions.   
        mdPermission rPermission[],         // [OUT] Put Permissions here.  
        ULONG       cMax,                   // [IN] Max Permissions to put. 
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(FindMember)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdToken     *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMethod)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMethodDef *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindField)(   
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdFieldDef  *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMemberRef)(   
        mdTypeRef   td,                     // [IN] given typeRef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] matching memberref 

    STDMETHOD (GetMethodProps)( 
        mdMethodDef mb,                     // The method for which to get props.   
        mdTypeDef   *pClass,                // Put method's class here. 
      __out_ecount_part_opt(cchMethod, *pchMethod)
        LPWSTR      szMethod,               // Put method's name here.  
        ULONG       cchMethod,              // Size of szMethod buffer in wide chars.   
        ULONG       *pchMethod,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags) PURE;    // [OUT] Impl. Flags    

    STDMETHOD(GetMemberRefProps)(           // S_OK or error.   
        mdMemberRef mr,                     // [IN] given memberref 
        mdToken     *ptk,                   // [OUT] Put classref or classdef here. 
      __out_ecount_part_opt(cchMember, *pchMember)
        LPWSTR      szMember,               // [OUT] buffer to fill for member's name   
        ULONG       cchMember,              // [IN] the count of char of szMember   
        ULONG       *pchMember,             // [OUT] actual count of char in member name    
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value  
        ULONG       *pbSig) PURE;           // [OUT] actual size of signature blob  

    STDMETHOD(EnumProperties)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdProperty  rProperties[],          // [OUT] Put Properties here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcProperties) PURE;    // [OUT] Put # put here.    

    STDMETHOD(EnumEvents)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdEvent     rEvents[],              // [OUT] Put events here.
        ULONG       cMax,                   // [IN] Max events to put.  
        ULONG       *pcEvents) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetEventProps)(               // S_OK, S_FALSE, or error. 
        mdEvent     ev,                     // [IN] event token 
        mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.    
        LPCWSTR     szEvent,                // [OUT] Event name 
        ULONG       cchEvent,               // [IN] the count of wchar of szEvent   
        ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name 
        DWORD       *pdwEventFlags,         // [OUT] Event flags.   
        mdToken     *ptkEventType,          // [OUT] EventType class    
        mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event  
        mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event   
        mdMethodDef *pmdFire,               // [OUT] Fire method of the event   
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event  
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this event 

    STDMETHOD(EnumMethodSemantics)(         // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdToken     rEventProp[],           // [OUT] Put Event/Property here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcEventProp) PURE;     // [OUT] Put # put here.    

    STDMETHOD(GetMethodSemantics)(          // S_OK, S_FALSE, or error. 
        mdMethodDef mb,                     // [IN] method token    
        mdToken     tkEventProp,            // [IN] event/property token.   
        DWORD       *pdwSemanticsFlags) PURE; // [OUT] the role flags for the method/propevent pair 

    STDMETHOD(GetClassLayout) ( 
        mdTypeDef   td,                     // [IN] give typedef    
        DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16  
        COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array 
        ULONG       cMax,                   // [IN] size of the array   
        ULONG       *pcFieldOffset,         // [OUT] needed array size  
        ULONG       *pulClassSize) PURE;        // [OUT] the size of the class  

    STDMETHOD(GetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a field's memberdef   
        PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field  
        ULONG       *pcbNativeType) PURE;   // [OUT] the count of bytes of *ppvNativeType   

    STDMETHOD(GetRVA)(                      // S_OK or error.   
        mdToken     tk,                     // Member for which to set offset   
        ULONG       *pulCodeRVA,            // The offset   
        DWORD       *pdwImplFlags) PURE;    // the implementation flags 

    STDMETHOD(GetPermissionSetProps) (  
        mdPermission pm,                    // [IN] the permission token.   
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.   
        void const  **ppvPermission,        // [OUT] permission blob.   
        ULONG       *pcbPermission) PURE;   // [OUT] count of bytes of pvPermission.    

    STDMETHOD(GetSigFromToken)(             // S_OK or error.   
        mdSignature mdSig,                  // [IN] Signature token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.   
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetModuleRefProps)(           // S_OK or error.   
        mdModuleRef mur,                    // [IN] moduleref token.    
      __out_ecount_part_opt(cchName, *pchName)
        LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.    
        ULONG       cchName,                // [IN] size of szName in wide characters.  
        ULONG       *pchName) PURE;         // [OUT] actual count of characters in the name.    

    STDMETHOD(EnumModuleRefs)(              // S_OK or error.   
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.   
        ULONG       cmax,                   // [IN] max memberrefs to put.  
        ULONG       *pcModuleRefs) PURE;    // [OUT] put # put here.    

    STDMETHOD(GetTypeSpecFromToken)(        // S_OK or error.   
        mdTypeSpec typespec,                // [IN] TypeSpec token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to TypeSpec signature  
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetNameFromToken)(            // Not Recommended! May be removed!
        mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
        MDUTF8CSTR  *pszUtf8NamePtr) PURE;  // [OUT] Return pointer to UTF8 name in heap.

    STDMETHOD(EnumUnresolvedMethods)(       // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetUserString)(               // S_OK or error.
        mdString    stk,                    // [IN] String token.
      __out_ecount_part_opt(cchString, *pchString)
        LPWSTR      szString,               // [OUT] Copy of string.
        ULONG       cchString,              // [IN] Max chars of room in szString.
        ULONG       *pchString) PURE;       // [OUT] How many chars in actual string.

    STDMETHOD(GetPinvokeMap)(               // S_OK or error.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
      __out_ecount_part_opt(cchImportName, *pchImportName)
        LPWSTR      szImportName,           // [OUT] Import name.
        ULONG       cchImportName,          // [IN] Size of the name buffer.
        ULONG       *pchImportName,         // [OUT] Actual number of characters stored.
        mdModuleRef *pmrImportDLL) PURE;    // [OUT] ModuleRef token for the target DLL.

    STDMETHOD(EnumSignatures)(              // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdSignature rSignatures[],          // [OUT] put signatures here.   
        ULONG       cmax,                   // [IN] max signatures to put.  
        ULONG       *pcSignatures) PURE;    // [OUT] put # put here.

    STDMETHOD(EnumTypeSpecs)(               // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdTypeSpec  rTypeSpecs[],           // [OUT] put TypeSpecs here.   
        ULONG       cmax,                   // [IN] max TypeSpecs to put.  
        ULONG       *pcTypeSpecs) PURE;     // [OUT] put # put here.

    STDMETHOD(EnumUserStrings)(             // S_OK or error.
        HCORENUM    *phEnum,                // [IN/OUT] pointer to the enum.
        mdString    rStrings[],             // [OUT] put Strings here.
        ULONG       cmax,                   // [IN] max Strings to put.
        ULONG       *pcStrings) PURE;       // [OUT] put # put here.

    STDMETHOD(GetParamForMethodIndex)(      // S_OK or error.
        mdMethodDef md,                     // [IN] Method token.
        ULONG       ulParamSeq,             // [IN] Parameter sequence.
        mdParamDef  *ppd) PURE;             // [IN] Put Param token here.

    STDMETHOD(EnumCustomAttributes)(        // S_OK or error.
        HCORENUM    *phEnum,                // [IN, OUT] COR enumerator.
        mdToken     tk,                     // [IN] Token to scope the enumeration, 0 for all.
        mdToken     tkType,                 // [IN] Type of interest, 0 for all.
        mdCustomAttribute rCustomAttributes[], // [OUT] Put custom attribute tokens here.
        ULONG       cMax,                   // [IN] Size of rCustomAttributes.
        ULONG       *pcCustomAttributes) PURE;  // [OUT, OPTIONAL] Put count of token values here.

    STDMETHOD(GetCustomAttributeProps)(     // S_OK or error.
        mdCustomAttribute cv,               // [IN] CustomAttribute token.
        mdToken     *ptkObj,                // [OUT, OPTIONAL] Put object token here.
        mdToken     *ptkType,               // [OUT, OPTIONAL] Put AttrType token here.
        void const  **ppBlob,               // [OUT, OPTIONAL] Put pointer to data here.
        ULONG       *pcbSize) PURE;         // [OUT, OPTIONAL] Put size of date here.

    STDMETHOD(FindTypeRef)(   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] TypeRef Name.
        mdTypeRef   *ptr) PURE;             // [OUT] matching TypeRef.

    STDMETHOD(GetMemberProps)(  
        mdToken     mb,                     // The member for which to get props.   
        mdTypeDef   *pClass,                // Put member's class here. 
      __out_ecount_part_opt(cchMember, *pchMember)
        LPWSTR      szMember,               // Put member's name here.  
        ULONG       cchMember,              // Size of szMember buffer in wide chars.   
        ULONG       *pchMember,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        UVCP_CONSTANT *ppValue,             // [OUT] constant value 
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetFieldProps)(  
        mdFieldDef  mb,                     // The field for which to get props.    
        mdTypeDef   *pClass,                // Put field's class here.  
      __out_ecount_part_opt(cchField, *pchField)
        LPWSTR      szField,                // Put field's name here.   
        ULONG       cchField,               // Size of szField buffer in wide chars.    
        ULONG       *pchField,              // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        UVCP_CONSTANT *ppValue,             // [OUT] constant value 
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetPropertyProps)(            // S_OK, S_FALSE, or error. 
        mdProperty  prop,                   // [IN] property token  
        mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
        LPCWSTR     szProperty,             // [OUT] Property name  
        ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
        ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
        DWORD       *pdwPropFlags,          // [OUT] property flags.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
        ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        UVCP_CONSTANT *ppDefaultValue,      // [OUT] constant value 
        ULONG       *pcchDefaultValue,      // [OUT] size of constant string in chars, 0 for non-strings.
        mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
        mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this property  

    STDMETHOD(GetParamProps)(               // S_OK or error.
        mdParamDef  tk,                     // [IN]The Parameter.
        mdMethodDef *pmd,                   // [OUT] Parent Method token.
        ULONG       *pulSequence,           // [OUT] Parameter sequence.
      __out_ecount_part_opt(cchName, *pchName)
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [OUT] Size of name buffer.
        ULONG       *pchName,               // [OUT] Put actual size of name here.
        DWORD       *pdwAttr,               // [OUT] Put flags here.
        DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
        UVCP_CONSTANT *ppValue,             // [OUT] Constant value.
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetCustomAttributeByName)(    // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCWSTR     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData) PURE;         // [OUT] Put size of data here.

    STDMETHOD_(BOOL, IsValidToken)(         // True or False.
        mdToken     tk) PURE;               // [IN] Given token.

    STDMETHOD(GetNestedClassProps)(         // S_OK or error.
        mdTypeDef   tdNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptdEnclosingClass) PURE; // [OUT] EnclosingClass token.

    STDMETHOD(GetNativeCallConvFromSig)(    // S_OK or error.
        void const  *pvSig,                 // [IN] Pointer to signature.
        ULONG       cbSig,                  // [IN] Count of signature bytes.
        ULONG       *pCallConv) PURE;       // [OUT] Put calling conv here (see CorPinvokemap).                                                                                        

    STDMETHOD(IsGlobal)(                    // S_OK or error.
        mdToken     pd,                     // [IN] Type, Field, or Method token.
        int         *pbGlobal) PURE;        // [OUT] Put 1 if global, 0 otherwise.

    // This interface is sealed.  Do not change, add, or remove anything.  Instead, derive a new iterface.

};      // IMetaDataImport

//-------------------------------------
//--- IMetaDataImport2
//-------------------------------------
// {FCE5EFA0-8BBA-4f8e-A036-8F2022B08466}
EXTERN_GUID(IID_IMetaDataImport2, 0xfce5efa0, 0x8bba, 0x4f8e, 0xa0, 0x36, 0x8f, 0x20, 0x22, 0xb0, 0x84, 0x66);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataImport2
DECLARE_INTERFACE_(IMetaDataImport2, IMetaDataImport)
{
    STDMETHOD(EnumGenericParams)(
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken      tk,                    // [IN] TypeDef or MethodDef whose generic parameters are requested
        mdGenericParam rGenericParams[],    // [OUT] Put GenericParams here.   
        ULONG       cMax,                   // [IN] Max GenericParams to put.  
        ULONG       *pcGenericParams) PURE; // [OUT] Put # put here.    

    STDMETHOD(GetGenericParamProps)(        // S_OK or error.
        mdGenericParam gp,                  // [IN] GenericParam
        ULONG        *pulParamSeq,          // [OUT] Index of the type parameter
        DWORD        *pdwParamFlags,        // [OUT] Flags, for future use (e.g. variance)
        mdToken      *ptOwner,              // [OUT] Owner (TypeDef or MethodDef)
        DWORD       *reserved,              // [OUT] For future use (e.g. non-type parameters)
      __out_ecount_part_opt(cchName, *pchName)
        LPWSTR       wzname,                // [OUT] Put name here
        ULONG        cchName,               // [IN] Size of buffer
        ULONG        *pchName) PURE;        // [OUT] Put size of name (wide chars) here.

    STDMETHOD(GetMethodSpecProps)(
        mdMethodSpec mi,                    // [IN] The method instantiation
        mdToken *tkParent,                  // [OUT] MethodDef or MemberRef
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob) PURE;      // [OUT] actual size of signature blob  

    STDMETHOD(EnumGenericParamConstraints)(
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdGenericParam tk,                  // [IN] GenericParam whose constraints are requested
        mdGenericParamConstraint rGenericParamConstraints[],    // [OUT] Put GenericParamConstraints here.   
        ULONG       cMax,                   // [IN] Max GenericParamConstraints to put.  
        ULONG       *pcGenericParamConstraints) PURE; // [OUT] Put # put here.

    STDMETHOD(GetGenericParamConstraintProps)( // S_OK or error.
        mdGenericParamConstraint gpc,       // [IN] GenericParamConstraint
        mdGenericParam *ptGenericParam,     // [OUT] GenericParam that is constrained
        mdToken      *ptkConstraintType) PURE; // [OUT] TypeDef/Ref/Spec constraint

    STDMETHOD(GetPEKind)(                   // S_OK or error.
        DWORD* pdwPEKind,                   // [OUT] The kind of PE (0 - not a PE)
        DWORD* pdwMAchine) PURE;            // [OUT] Machine as defined in NT header

    STDMETHOD(GetVersionString)(            // S_OK or error.
      __out_ecount_part_opt(cchBufSize, pccBufSize)
        LPWSTR      pwzBuf,                 // [OUT[ Put version string here.
        DWORD       ccBufSize,              // [IN] size of the buffer, in wide chars
        DWORD       *pccBufSize) PURE;      // [OUT] Size of the version string, wide chars, including terminating nul.

    STDMETHOD(EnumMethodSpecs)(
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken      tk,                    // [IN] MethodDef or MemberRef whose MethodSpecs are requested
        mdMethodSpec rMethodSpecs[],        // [OUT] Put MethodSpecs here.   
        ULONG       cMax,                   // [IN] Max tokens to put.  
        ULONG       *pcMethodSpecs) PURE;   // [OUT] Put actual count here.    

}; // IMetaDataImport2

//-------------------------------------
//--- IMetaDataFilter
//-------------------------------------
// {D0E80DD1-12D4-11d3-B39D-00C04FF81795}
EXTERN_GUID(IID_IMetaDataFilter, 0xd0e80dd1, 0x12d4, 0x11d3, 0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95);

//---
#undef  INTERFACE
#define INTERFACE IMetaDataFilter
DECLARE_INTERFACE_(IMetaDataFilter, IUnknown)
{
    STDMETHOD(UnmarkAll)() PURE;
    STDMETHOD(MarkToken)(mdToken tk) PURE;
    STDMETHOD(IsTokenMarked)(mdToken tk, BOOL *pIsMarked) PURE;
};



//-------------------------------------
//--- IHostFilter
//-------------------------------------
// {D0E80DD3-12D4-11d3-B39D-00C04FF81795}
EXTERN_GUID(IID_IHostFilter, 0xd0e80dd3, 0x12d4, 0x11d3, 0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95);

//---
#undef  INTERFACE
#define INTERFACE IHostFilter
DECLARE_INTERFACE_(IHostFilter, IUnknown)
{
    STDMETHOD(MarkToken)(mdToken tk) PURE;
};


//--------------------------------------
//--- IMetaDataConverter
//--------------------------------------
// {D9DEBD79-2992-11d3-8BC1-0000F8083A57}
EXTERN_GUID(IID_IMetaDataConverter, 0xd9debd79, 0x2992, 0x11d3, 0x8b, 0xc1, 0x0, 0x0, 0xf8, 0x8, 0x3a, 0x57);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataConverter
DECLARE_INTERFACE_(IMetaDataConverter, IUnknown)
{
    STDMETHOD(GetMetaDataFromTypeInfo)(
        ITypeInfo* pITI,                    // [in] Type info
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetMetaDataFromTypeLib)(
        ITypeLib* pITL,                     // [in] Type library
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetTypeLibFromMetaData)(
        BSTR strModule,                     // [in] Module name
        BSTR strTlbName,                    // [in] Type library name
        ITypeLib** ppITL) PURE;             // [out] return ITypeLib on success
};


//*****************************************************************************
// Assembly Declarations
//*****************************************************************************

typedef struct
{
    DWORD       dwOSPlatformId;         // Operating system platform.
    DWORD       dwOSMajorVersion;       // OS Major version.
    DWORD       dwOSMinorVersion;       // OS Minor version.
} OSINFO;


typedef struct
{
    USHORT      usMajorVersion;         // Major Version.   
    USHORT      usMinorVersion;         // Minor Version.
    USHORT      usBuildNumber;          // Build Number.
    USHORT      usRevisionNumber;       // Revision Number.
    LPWSTR      szLocale;               // Locale.
    ULONG       cbLocale;               // [IN/OUT] Size of the buffer in wide chars/Actual size.
    DWORD       *rProcessor;            // Processor ID array.
    ULONG       ulProcessor;            // [IN/OUT] Size of the Processor ID array/Actual # of entries filled in.
    OSINFO      *rOS;                   // OSINFO array.
    ULONG       ulOS;                   // [IN/OUT]Size of the OSINFO array/Actual # of entries filled in.
} ASSEMBLYMETADATA;


// {211EF15B-5317-4438-B196-DEC87B887693}
EXTERN_GUID(IID_IMetaDataAssemblyEmit, 0x211ef15b, 0x5317, 0x4438, 0xb1, 0x96, 0xde, 0xc8, 0x7b, 0x88, 0x76, 0x93);

//---
#undef  INTERFACE
#define INTERFACE IMetaDataAssemblyEmit
DECLARE_INTERFACE_(IMetaDataAssemblyEmit, IUnknown)
{
    STDMETHOD(DefineAssembly)(              // S_OK or error.
        const void  *pbPublicKey,           // [IN] Public key of the assembly.
        ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags,        // [IN] Flags.
        mdAssembly  *pma) PURE;             // [OUT] Returned Assembly token.

    STDMETHOD(DefineAssemblyRef)(           // S_OK or error.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags,     // [IN] Flags.
        mdAssemblyRef *pmdar) PURE;         // [OUT] Returned AssemblyRef token.

    STDMETHOD(DefineFile)(                  // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the file.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags,            // [IN] Flags.
        mdFile      *pmdf) PURE;            // [OUT] Returned File token.

    STDMETHOD(DefineExportedType)(          // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Com Type.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdExportedType
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags,    // [IN] Flags.
        mdExportedType   *pmdct) PURE;      // [OUT] Returned ExportedType token.

    STDMETHOD(DefineManifestResource)(      // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the resource.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags,        // [IN] Flags.
        mdManifestResource  *pmdmr) PURE;   // [OUT] Returned ManifestResource token.

    STDMETHOD(SetAssemblyProps)(            // S_OK or error.
        mdAssembly  pma,                    // [IN] Assembly token.
        const void  *pbPublicKey,           // [IN] Public key of the assembly.
        ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags) PURE;  // [IN] Flags.

    STDMETHOD(SetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags) PURE; // [IN] Token for Execution Location.

    STDMETHOD(SetFileProps)(                // S_OK or error.
        mdFile      file,                   // [IN] File token.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags) PURE;      // [IN] Flags.

    STDMETHOD(SetExportedTypeProps)(        // S_OK or error.
        mdExportedType   ct,                // [IN] ExportedType token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdExportedType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags) PURE;   // [IN] Flags.

    STDMETHOD(SetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mr,             // [IN] ManifestResource token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags) PURE;  // [IN] Flags.

};  // IMetaDataAssemblyEmit


// {EE62470B-E94B-424e-9B7C-2F00C9249F93}
EXTERN_GUID(IID_IMetaDataAssemblyImport, 0xee62470b, 0xe94b, 0x424e, 0x9b, 0x7c, 0x2f, 0x0, 0xc9, 0x24, 0x9f, 0x93);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyImport
DECLARE_INTERFACE_(IMetaDataAssemblyImport, IUnknown)
{
    STDMETHOD(GetAssemblyProps)(            // S_OK or error.
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
        ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        __out_ecount_part_opt(cchName, *pchName) LPWSTR  szName, // [OUT] Buffer to fill with assembly's simply name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        DWORD       *pdwAssemblyFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
        ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
        __out_ecount_part_opt(cchName, *pchName)LPWSTR szName, // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        DWORD       *pdwAssemblyRefFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetFileProps)(                // S_OK or error.
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        __out_ecount_part_opt(cchName, *pchName) LPWSTR      szName, // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetExportedTypeProps)(        // S_OK or error.
        mdExportedType   mdct,              // [IN] The ExportedType for which to get the properties.
        __out_ecount_part_opt(cchName, *pchName) LPWSTR      szName, // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef or mdExportedType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        DWORD       *pdwExportedTypeFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        __out_ecount_part_opt(cchName, *pchName)LPWSTR      szName,  // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ManifestResource.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        DWORD       *pdwResourceFlags) PURE;// [OUT] Flags.

    STDMETHOD(EnumAssemblyRefs)(            // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
        ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumFiles)(                   // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdFile      rFiles[],               // [OUT] Put Files here.
        ULONG       cMax,                   // [IN] Max Files to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumExportedTypes)(           // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdExportedType   rExportedTypes[],  // [OUT] Put ExportedTypes here.
        ULONG       cMax,                   // [IN] Max ExportedTypes to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumManifestResources)(       // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
        ULONG       cMax,                   // [IN] Max Resources to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(GetAssemblyFromScope)(        // S_OK or error
        mdAssembly  *ptkAssembly) PURE;     // [OUT] Put token here.

    STDMETHOD(FindExportedTypeByName)(      // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ExportedType.
        mdToken     mdtExportedType,        // [IN] ExportedType for the enclosing class.
        mdExportedType   *ptkExportedType) PURE; // [OUT] Put the ExportedType token here.

    STDMETHOD(FindManifestResourceByName)(  // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
        mdManifestResource *ptkManifestResource) PURE;  // [OUT] Put the ManifestResource token here.

    STDMETHOD_(void, CloseEnum)(
        HCORENUM hEnum) PURE;               // Enum to be closed.

    STDMETHOD(FindAssembliesByName)(        // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        IUnknown *ppIUnk[],                 // [OUT] put IMetaDataAssemblyImport pointers here
        ULONG    cMax,                      // [IN] The max number to put
        ULONG    *pcAssemblies) PURE;       // [OUT] The number of assemblies returned.
};  // IMetaDataAssemblyImport


//*****************************************************************************
// End Assembly Declarations
//*****************************************************************************

//*****************************************************************************
// MetaData Validator Declarations
//*****************************************************************************

// Specifies the type of the module, PE file vs. .obj file.
typedef enum
{
    ValidatorModuleTypeInvalid      = 0x0,
    ValidatorModuleTypeMin          = 0x00000001,
    ValidatorModuleTypePE           = 0x00000001,
    ValidatorModuleTypeObj          = 0x00000002,
    ValidatorModuleTypeEnc          = 0x00000003,
    ValidatorModuleTypeIncr         = 0x00000004,
    ValidatorModuleTypeMax          = 0x00000004,
} CorValidatorModuleType;


// {4709C9C6-81FF-11D3-9FC7-00C04F79A0A3}
EXTERN_GUID(IID_IMetaDataValidate, 0x4709c9c6, 0x81ff, 0x11d3, 0x9f, 0xc7, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataValidate
DECLARE_INTERFACE_(IMetaDataValidate, IUnknown)
{
    STDMETHOD(ValidatorInit)(               // S_OK or error.
        DWORD       dwModuleType,           // [IN] Specifies the type of the module.
        IUnknown    *pUnk) PURE;            // [IN] Validation error handler.

    STDMETHOD(ValidateMetaData)(            // S_OK or error.
        ) PURE;
};  // IMetaDataValidate

//*****************************************************************************
// End MetaData Validator Declarations
//*****************************************************************************

//*****************************************************************************
// IMetaDataDispenserEx declarations.
//*****************************************************************************

// {31BCFCE2-DAFB-11D2-9F81-00C04F79A0A3}
EXTERN_GUID(IID_IMetaDataDispenserEx, 0x31bcfce2, 0xdafb, 0x11d2, 0x9f, 0x81, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3);

#undef  INTERFACE
#define INTERFACE IMetaDataDispenserEx
DECLARE_INTERFACE_(IMetaDataDispenserEx, IMetaDataDispenser)
{
    STDMETHOD(SetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        const VARIANT *value) PURE;         // [in] Value to which the option is to be set.

    STDMETHOD(GetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        VARIANT *pvalue) PURE;              // [out] Value to which the option is currently set.

    STDMETHOD(OpenScopeOnITypeInfo)(        // Return code.
        ITypeInfo   *pITI,                  // [in] ITypeInfo to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(GetCORSystemDirectory)(       // Return code.
       __out_ecount_part_opt(cchBuffer, *pchBuffer)
         LPWSTR      szBuffer,              // [out] Buffer for the directory name
         DWORD       cchBuffer,             // [in] Size of the buffer
         DWORD*      pchBuffer) PURE;       // [OUT] Number of characters returned

    STDMETHOD(FindAssembly)(                // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN] the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

    STDMETHOD(FindAssemblyModule)(          // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szModuleName,              // [IN] required - the name of the module
      __out_ecount_part_opt(cchName, *pcName)
        LPWSTR   szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN]  the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

};

//*****************************************************************************
//*****************************************************************************
//
// Registration declarations.  Will be replace by Services' Registration
//  implementation. 
//
//*****************************************************************************
//*****************************************************************************
// Various flags for use in installing a module or a composite
typedef enum 
{
    regNoCopy = 0x00000001,         // Don't copy files into destination    
    regConfig = 0x00000002,         // Is a configuration   
    regHasRefs = 0x00000004         // Has class references 
} CorRegFlags;

typedef GUID CVID;

typedef struct {
    short Major;    
    short Minor;    
    short Sub;  
    short Build;    
} CVStruct;


//*****************************************************************************
//*****************************************************************************
//
// CeeGen interfaces for generating in-memory Common Language Runtime files
//
//*****************************************************************************
//*****************************************************************************

typedef void *HCEESECTION;

typedef enum  {
    sdNone =        0,
    sdReadOnly =    IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA,
    sdReadWrite =   sdReadOnly | IMAGE_SCN_MEM_WRITE,
    sdExecute =     IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE
} CeeSectionAttr;

//
// Relocation types.
//

typedef enum  {
    // generate only a section-relative reloc, nothing into .reloc section
    srRelocAbsolute,

    // generate a .reloc for a pointer sized location, 
    // This is transformed into BASED_HIGHLOW or BASED_DIR64 based on the platform
    srRelocHighLow      = 3,

    // generate a .reloc for the top 16-bits of a 32 bit number, where the
    // bottom 16 bits are included in the next word in the .reloc table
    srRelocHighAdj,     // Never Used

    // generate a token map relocation, nothing into .reloc section 
    srRelocMapToken,

    // relative address fixup
    srRelocRelative,

    // Generate only a section-relative reloc, nothing into .reloc
    // section.  This reloc is relative to the file position of the
    // section, not the section's virtual address.
    srRelocFilePos,

    // code relative address fixup
    srRelocCodeRelative,

    // generate a .reloc for a 64 bit address in an ia64 movl instruction 
    srRelocIA64Imm64,

    // generate a .reloc for a 64 bit address
    srRelocDir64,

    // generate a .reloc for a 25-bit PC relative address in an ia64 br.call instruction 
    srRelocIA64PcRel25,

    // generate a .reloc for a 64-bit PC relative address in an ia64 brl.call instruction 
    srRelocIA64PcRel64,

    // generate a 30-bit section-relative reloc, used for tagged pointer values
    srRelocAbsoluteTagged,


    // A sentinel value to help ensure any additions to this enum are reflected 
    // in PEWriter.cpp's RelocName array.
    srRelocSentinel,

    // Flags that can be used with the above reloc types

    // do not emit base reloc
    srNoBaseReloc = 0x4000,
    
    // pre-fixup contents of memory are ptr rather than a section offset
    srRelocPtr = 0x8000,

    // legal enums which include the Ptr flag
    srRelocAbsolutePtr  = srRelocPtr + srRelocAbsolute,
    srRelocHighLowPtr   = srRelocPtr + srRelocHighLow,
    srRelocRelativePtr  = srRelocPtr + srRelocRelative,
    srRelocIA64Imm64Ptr = srRelocPtr + srRelocIA64Imm64,
    srRelocDir64Ptr     = srRelocPtr + srRelocDir64,

} CeeSectionRelocType;

#define IMAGE_REL_BASED_REL32            7
#define IMAGE_REL_BASED_IA64_PCREL21    11
#define IMAGE_REL_BASED_IA64_PCREL60    12

typedef union  {
    USHORT highAdj;
} CeeSectionRelocExtra;

//-------------------------------------
//--- ICeeGen
//-------------------------------------
// {7ED1BDFF-8E36-11d2-9C56-00A0C9B7CC45}
EXTERN_GUID(IID_ICeeGen, 0x7ed1bdff, 0x8e36, 0x11d2, 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45);

DECLARE_INTERFACE_(ICeeGen, IUnknown)
{
    STDMETHOD (EmitString) (    
      __in
        LPWSTR lpString,                    // [IN] String to emit
        ULONG *RVA) PURE;                   // [OUT] RVA for string emitted string  

    STDMETHOD (GetString) (     
        ULONG RVA,                          // [IN] RVA for string to return    
      __out_opt
        LPWSTR *lpString) PURE;             // [OUT] Returned string

    STDMETHOD (AllocateMethodBuffer) (  
        ULONG cchBuffer,                    // [IN] Length of buffer to create  
        UCHAR **lpBuffer,                   // [OUT] Returned buffer    
        ULONG *RVA) PURE;                   // [OUT] RVA for method 

    STDMETHOD (GetMethodBuffer) (   
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

    STDMETHOD (GetIMapTokenIface) (     
        IUnknown **pIMapToken) PURE;    

    STDMETHOD (GenerateCeeFile) () PURE;

    STDMETHOD (GetIlSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (GetStringSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (AddSectionReloc) (
        HCEESECTION section,    
        ULONG offset,   
        HCEESECTION relativeTo,     
        CeeSectionRelocType relocType) PURE;    

    // use these only if you have special section requirements not handled  
    // by other APIs    
    STDMETHOD (GetSectionCreate) (
        const char *name,   
        DWORD flags,    
        HCEESECTION *section) PURE; 

    STDMETHOD (GetSectionDataLen) (
        HCEESECTION section,    
        ULONG *dataLen) PURE;   

    STDMETHOD (GetSectionBlock) (
        HCEESECTION section,    
        ULONG len,  
        ULONG align=1,  
        void **ppBytes=0) PURE; 

    STDMETHOD (TruncateSection) (
        HCEESECTION section,    
        ULONG len) PURE;  

    STDMETHOD (GenerateCeeMemoryImage) (
        void **ppImage) PURE;

    STDMETHOD (ComputePointer) (   
        HCEESECTION section,    
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

};

//*****************************************************************************
//*****************************************************************************
//
// End of CeeGen declarations.
//
//*****************************************************************************

//*****************************************************************************
//*****************************************************************************
//
// CorModule interfaces for generating in-memory modules
//
//*****************************************************************************
//*****************************************************************************

typedef enum {
    CORMODULE_MATCH             =   0x00,   // find an existing module that matches interfaces supported    
    CORMODULE_NEW               =   0x01,   // always create a new module and interfaces    
} ICorModuleInitializeFlags;

//-------------------------------------
//--- ICorModule
//-------------------------------------
// {2629F8E1-95E5-11d2-9C56-00A0C9B7CC45}
EXTERN_GUID(IID_ICorModule, 0x2629f8e1, 0x95e5, 0x11d2, 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45);

DECLARE_INTERFACE_(ICorModule, IUnknown)
{
    STDMETHOD (Initialize) (
        DWORD flags,                        // [IN] flags to control emitter returned   
        REFIID riidCeeGen,                  // [IN] type of cee generator to initialize with    
        REFIID riidEmitter) PURE;           // [IN] type of emitter to initialize with

    STDMETHOD (GetCeeGen) ( 
        ICeeGen **pCeeGen) PURE;            // [OUT] cee generator

    STDMETHOD (GetMetaDataEmit) (   
        IMetaDataEmit **pEmitter) PURE;     // [OUT] emitter    
};

//*****************************************************************************
//*****************************************************************************
//
// End of CorModule declarations.
//
//*****************************************************************************

//**********************************************************************
//**********************************************************************
//--- IMetaDataTables
//-------------------------------------
// This API isn't big endian friendly since it indexes directly into the memory that
// is stored in little endian format.
// {D8F579AB-402D-4b8e-82D9-5D63B1065C68}
EXTERN_GUID(IID_IMetaDataTables, 0xd8f579ab, 0x402d, 0x4b8e, 0x82, 0xd9, 0x5d, 0x63, 0xb1, 0x6, 0x5c, 0x68);

DECLARE_INTERFACE_(IMetaDataTables, IUnknown)
{
    STDMETHOD (GetStringHeapSize) (    
        ULONG   *pcbStrings) PURE;          // [OUT] Size of the string heap.

    STDMETHOD (GetBlobHeapSize) (    
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the Blob heap.

    STDMETHOD (GetGuidHeapSize) (    
        ULONG   *pcbGuids) PURE;            // [OUT] Size of the Guid heap.

    STDMETHOD (GetUserStringHeapSize) (  
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the User String heap.

    STDMETHOD (GetNumTables) (    
        ULONG   *pcTables) PURE;            // [OUT] Count of tables.

    STDMETHOD (GetTableIndex) (   
        ULONG   token,                      // [IN] Token for which to get table index.
        ULONG   *pixTbl) PURE;              // [OUT] Put table index here.

    STDMETHOD (GetTableInfo) (    
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   *pcbRow,                    // [OUT] Size of a row, bytes.
        ULONG   *pcRows,                    // [OUT] Number of rows.
        ULONG   *pcCols,                    // [OUT] Number of columns in each row.
        ULONG   *piKey,                     // [OUT] Key column, or -1 if none.
        const char **ppName) PURE;          // [OUT] Name of the table.

    STDMETHOD (GetColumnInfo) (   
        ULONG   ixTbl,                      // [IN] Which Table
        ULONG   ixCol,                      // [IN] Which Column in the table
        ULONG   *poCol,                     // [OUT] Offset of the column in the row.
        ULONG   *pcbCol,                    // [OUT] Size of a column, bytes.
        ULONG   *pType,                     // [OUT] Type of the column.
        const char **ppName) PURE;          // [OUT] Name of the Column.

    STDMETHOD (GetCodedTokenInfo) (   
        ULONG   ixCdTkn,                    // [IN] Which kind of coded token.
        ULONG   *pcTokens,                  // [OUT] Count of tokens.
        ULONG   **ppTokens,                 // [OUT] List of tokens.
        const char **ppName) PURE;          // [OUT] Name of the CodedToken.

    STDMETHOD (GetRow) (      
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   rid,                        // [IN] Which row.
        void    **ppRow) PURE;              // [OUT] Put pointer to row here.

    STDMETHOD (GetColumn) (   
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   ixCol,                      // [IN] Which column.
        ULONG   rid,                        // [IN] Which row.
        ULONG   *pVal) PURE;                // [OUT] Put the column contents here.

    STDMETHOD (GetString) (   
        ULONG   ixString,                   // [IN] Value from a string column.
        const char **ppString) PURE;        // [OUT] Put a pointer to the string here.

    STDMETHOD (GetBlob) (     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pcbData,                   // [OUT] Put size of the blob here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the blob here.

    STDMETHOD (GetGuid) (     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        const GUID **ppGUID) PURE;          // [OUT] Put a pointer to the GUID here.

    STDMETHOD (GetUserString) (   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pcbData,                   // [OUT] Put size of the UserString here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the UserString here.

    STDMETHOD (GetNextString) (   
        ULONG   ixString,                   // [IN] Value from a string column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next string here.

    STDMETHOD (GetNextBlob) (     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the netxt blob here.

    STDMETHOD (GetNextGuid) (     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next guid here.

    STDMETHOD (GetNextUserString) (   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next user string here.

    // Interface is sealed.

};
// This API isn't big endian friendly since it indexes directly into the memory that
// is stored in little endian format.
// {BADB5F70-58DA-43a9-A1C6-D74819F19B15}
EXTERN_GUID(IID_IMetaDataTables2, 0xbadb5f70, 0x58da, 0x43a9, 0xa1, 0xc6, 0xd7, 0x48, 0x19, 0xf1, 0x9b, 0x15);

DECLARE_INTERFACE_(IMetaDataTables2, IMetaDataTables)
{
    STDMETHOD (GetMetaDataStorage) (        //@todo: name?
        const void **ppvMd,                 // [OUT] put pointer to MD section here (aka, 'BSJB').
        ULONG   *pcbMd) PURE;               // [OUT] put size of the stream here.

    STDMETHOD (GetMetaDataStreamInfo) (     // Get info about the MD stream.
        ULONG   ix,                         // [IN] Stream ordinal desired.
        const char **ppchName,              // [OUT] put pointer to stream name here.
        const void **ppv,                   // [OUT] put pointer to MD stream here.
        ULONG   *pcb) PURE;                 // [OUT] put size of the stream here.

}; // IMetaDataTables2

#ifdef _DEFINE_META_DATA_META_CONSTANTS
#ifndef _META_DATA_META_CONSTANTS_DEFINED
#define _META_DATA_META_CONSTANTS_DEFINED
const unsigned int iRidMax          = 63;
const unsigned int iCodedToken      = 64;   // base of coded tokens.
const unsigned int iCodedTokenMax   = 95;
const unsigned int iSHORT           = 96;   // fixed types.
const unsigned int iUSHORT          = 97;
const unsigned int iLONG            = 98;
const unsigned int iULONG           = 99;
const unsigned int iBYTE            = 100;
const unsigned int iSTRING          = 101;  // pool types.
const unsigned int iGUID            = 102;
const unsigned int iBLOB            = 103;

inline int IsRidType(ULONG ix) { return ix <= iRidMax; }
inline int IsCodedTokenType(ULONG ix) { return (ix >= iCodedToken) && (ix <= iCodedTokenMax); }
inline int IsRidOrToken(ULONG ix) { return ix <= iCodedTokenMax; }
inline int IsHeapType(ULONG ix) { return ix >= iSTRING; }
inline int IsFixedType(ULONG ix) { return (ix < iSTRING) && (ix > iCodedTokenMax); }
#endif
#endif

//**********************************************************************
// End of IMetaDataTables.
//**********************************************************************
// Gets the dependancies of a native image. If these change, then
// the native image cannot be used.
//
// IMetaDataImport::GetAssemblyRefProps() can be used to obtain information about
// the mdAssemblyRefs.
//*****************************************************************************

// {814C9E35-3F3F-4975-977A-371F0A878AC7}
EXTERN_GUID(IID_INativeImageDependency, 0x814c9e35, 0x3f3f, 0x4975, 0x97, 0x7a, 0x37, 0x1f, 0xa, 0x87, 0x8a, 0xc7);

struct CORCOMPILE_ASSEMBLY_SIGNATURE;
typedef GUID CORCOMPILE_NGEN_SIGNATURE;

DECLARE_INTERFACE_(INativeImageDependency, IUnknown)
{
    // Get the referenced assembly
    STDMETHOD (GetILAssemblyRef) (
        mdAssemblyRef * pAssemblyRef        // [OUT]
        ) PURE;

    // Get the post-policy assembly actually used
    STDMETHOD (GetILAssemblyDef) (
        mdAssemblyRef * ppAssemblyDef,          // [OUT]
        CORCOMPILE_ASSEMBLY_SIGNATURE * pSign   // [OUT]
        ) PURE;

    // Get the native image corresponding to GetILAssemblyDef() IF
    // there is a hard-bound (directly-referenced) native dependancy
    //
    // We do not need the configStrig because configStrings have to
    // be an exact part. Any partial matches are factored out into GetConfigMask()
    STDMETHOD (GetNativeAssemblyDef) (
        CORCOMPILE_NGEN_SIGNATURE * pNativeSign // [OUT] INVALID_NGEN_SIGNATURE if there is no hard-bound dependancy
        ) PURE;
};

//*****************************************************************************
//
// Fusion uses IFusionNativeImageInfo to obtain (and cache) informaton
// about a native image being installed into the native image cache.
// This allows Fusion to bind directly to native images
// without requiring (expensively) binding to the IL assembly first.
//
// IMetaDataAssemblyImport can be queried for this interface
//
//*****************************************************************************
// {0EA273D0-B4DA-4008-A60D-8D6EFFDD6E91}
EXTERN_GUID(IID_INativeImageInstallInfo, 0xea273d0, 0xb4da, 0x4008, 0xa6, 0xd, 0x8d, 0x6e, 0xff, 0xdd, 0x6e, 0x91);

DECLARE_INTERFACE_(INativeImageInstallInfo, IUnknown)
{
    // Signature of the ngen image
    // This matches the argument type of INativeImageDependency::GetNativeAssemblyDef
    
    STDMETHOD (GetSignature) (
        CORCOMPILE_NGEN_SIGNATURE * pNgenSign // [OUT]
        ) PURE;

    // Signature of the source IL assembly. This can be used to
    // verify that the IL image matches a candidate ngen image.
    // This matches the argument type of IAssemblyRuntimeSignature::CheckSignature
    //

    STDMETHOD (GetILSignature) (
        CORCOMPILE_ASSEMBLY_SIGNATURE * pILSign // [OUT]
        ) PURE;

    // Returns the equivalent of ISNAssemblySignature::GetSNAssemblySignature,
    // except for unsigned assemblies where the GetSNAssemblySignature will fail.
    // This can be used for matching the IL assembly in the GAC when the
    // native-image is generated/installed.
    //
    // Sets *pcbSig and returns ERROR_INSUFFICIENT_BUFFER for insufficient buffer.
    // Returns CORSEC_E_MISSING_STRONGNAME if the IL assembly is not strongly-named
    
    STDMETHOD (GetILStrongSignature) (
        BYTE        *pbSig,                 // [IN, OUT] Buffer to write signature
        DWORD       *pcbSig                 // [IN, OUT] Size of buffer, bytes written
        ) PURE;

    // Information about the contents/dependancies/assumptions of NativeImage
    // All of this information has to match for the current NativeImage to
    // be valid
    // Sets *pdwLength and returns ERROR_INSUFFICIENT_BUFFER for 
    // insufficient szConfigString

    STDMETHOD (GetConfigString) (
        __out_ecount_part_opt (*pdwLength, *pdwLength) LPWSTR szConfigString, // [OUT]
        __inout DWORD * pdwLength                   // [IN|OUT] - Number of WCHARs written including terminating NULL
        ) PURE;

    // A partial match is allowed for the current NativeImage to be valid
    
    STDMETHOD (GetConfigMask) (
        DWORD * pConfigMask // [OUT]
        ) PURE;

    // Cache data that the CLR will need to determine if the NativeImage
    // can be used (after the GetConfigString checks are satisfied)
    // Sets *pdwBufferSize and returns ERROR_INSUFFICIENT_BUFFER for insufficient ppbBuffer

    STDMETHOD (GetEvaluationDataToCache) (
        BYTE * ppbBuffer,                   // [OUT]
        DWORD * pdwBufferSize               // [IN|OUT] Total number of bytes written to *ppbBuffer
        ) PURE;

    //
    // Dependancy assemblies. The native image is only valid
    // if the dependancies have not changed.
    //

    STDMETHOD (EnumDependencies) (
        HCORENUM * phEnum,                  // [IN/OUT] - Pointer to the enum
        INativeImageDependency *rDeps[],    // [OUT]
        ULONG cMax,                         // [IN] Max dependancies to enumerate in this iteration
        DWORD * pdwCount                    // [OUT] - Number of dependancies actually enumerated
        ) PURE;
};

//*****************************************************************************
//
// Runtime callback made by Fusion into the CLR to determine if the NativeAssembly
// can be used. The pUnkBindSink argument of CAssemblyName::BindToObject() can
// be queried for this interface
//
//*****************************************************************************
// {065AA013-9BDC-447c-922F-FEE929908447}
EXTERN_GUID(IID_INativeImageEvaluate, 0x65aa013, 0x9bdc, 0x447c, 0x92, 0x2f, 0xfe, 0xe9, 0x29, 0x90, 0x84, 0x47);

interface IAssembly;

DECLARE_INTERFACE_(INativeImageEvaluate, IUnknown)
{
    // This will be called before the assemblies are actually loaded.
    //
    // Returns S_FALSE if the native-image cannot be used.
    
    STDMETHOD (Evaluate) (
        IAssembly *pILAssembly,             // [IN] IL assembly in question
        IAssembly *pNativeAssembly,         // [IN] NGen image we are trying to use for pILAssembly 
        BYTE * pbCachedData,                // [IN] Data cached when the native-image was generated
        DWORD dwDataSize                    // [IN] Size of the pbCachedData buffer
        ) PURE;
};

//**********************************************************************

//**********************************************************************
//
// Predefined CustomAttribute and structures for these custom value
//
//**********************************************************************

//
// Native Link method custom value definitions. This is for N-direct support.
//

#define COR_NATIVE_LINK_CUSTOM_VALUE        L"COMPLUS_NativeLink"   
#define COR_NATIVE_LINK_CUSTOM_VALUE_ANSI   "COMPLUS_NativeLink"    

// count of chars for COR_NATIVE_LINK_CUSTOM_VALUE(_ANSI)
#define COR_NATIVE_LINK_CUSTOM_VALUE_CC     18  

#include <pshpack1.h>
typedef struct 
{
    BYTE        m_linkType;       // see CorNativeLinkType below    
    BYTE        m_flags;          // see CorNativeLinkFlags below   
    mdMemberRef m_entryPoint;     // member ref token giving entry point, format is lib:entrypoint  
} COR_NATIVE_LINK;
#include <poppack.h>

typedef enum 
{
    nltNone         = 1,    // none of the keywords are specified   
    nltAnsi         = 2,    // ansi keyword specified   
    nltUnicode      = 3,    // unicode keyword specified    
    nltAuto         = 4,    // auto keyword specified   
    nltOle          = 5,    // ole keyword specified  
    nltMaxValue     = 7,    // used so we can assert how many bits are required for this enum
} CorNativeLinkType;

typedef enum 
{
    nlfNone         = 0x00,     // no flags 
    nlfLastError    = 0x01,     // setLastError keyword specified   
    nlfNoMangle     = 0x02,     // nomangle keyword specified
    nlfMaxValue     = 0x03,     // used so we can assert how many bits are required for this enum
} CorNativeLinkFlags;


#define COR_DUAL_CUSTOM_VALUE L"IsDual"
#define COR_DUAL_CUSTOM_VALUE_ANSI "IsDual"

#define COR_DISPATCH_CUSTOM_VALUE L"DISPID"
#define COR_DISPATCH_CUSTOM_VALUE_ANSI "DISPID"

//
// Security custom value definitions (these are all deprecated).
//

#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE L"SecPermReq_Reqd"
#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE_ANSI "SecPermReq_Reqd"

#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE L"SecPermReq_Opt"
#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE_ANSI "SecPermReq_Opt"

#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE L"SecPermReq_Refuse"
#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE_ANSI "SecPermReq_Refuse"

//
// Base class for security custom attributes.
//

#define COR_BASE_SECURITY_ATTRIBUTE_CLASS L"System.Security.Permissions.SecurityAttribute"
#define COR_BASE_SECURITY_ATTRIBUTE_CLASS_ANSI "System.Security.Permissions.SecurityAttribute"

//
// Name of custom attribute used to indicate that per-call security checks should
// be disabled for P/Invoke calls.
//

#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE L"System.Security.SuppressUnmanagedCodeSecurityAttribute"
#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI "System.Security.SuppressUnmanagedCodeSecurityAttribute"

//
// Name of custom attribute tagged on module to indicate it contains
// unverifiable code.
//

#define COR_UNVER_CODE_ATTRIBUTE L"System.Security.UnverifiableCodeAttribute"
#define COR_UNVER_CODE_ATTRIBUTE_ANSI "System.Security.UnverifiableCodeAttribute"

//
// Name of custom attribute indicating that a method requires a security object
// slot on the caller's stack.
//

#define COR_REQUIRES_SECOBJ_ATTRIBUTE L"System.Security.DynamicSecurityMethodAttribute"
#define COR_REQUIRES_SECOBJ_ATTRIBUTE_ANSI "System.Security.DynamicSecurityMethodAttribute"

#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE L"System.Runtime.CompilerServices.DiscardableAttribute"
#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE_ASNI "System.Runtime.CompilerServices.DiscardableAttribute"


#ifdef __cplusplus
}

//*****************************************************************************
//*****************************************************************************
//
// C O M +   s i g n a t u r e   s u p p o r t  
//
//*****************************************************************************
//*****************************************************************************

#ifndef FORCEINLINE
 #if _MSC_VER < 1200
   #define FORCEINLINE inline
 #else
   #define FORCEINLINE __forceinline
 #endif
#endif

// return true if it is a primitive type, i.e. only need to store CorElementType
FORCEINLINE int CorIsPrimitiveType(CorElementType elementtype)
{
    return (elementtype < ELEMENT_TYPE_PTR || elementtype == ELEMENT_TYPE_I || elementtype == ELEMENT_TYPE_U);    
}


// Return true if element type is a modifier, i.e. ELEMENT_TYPE_MODIFIER bits are 
// turned on. For now, it is checking for ELEMENT_TYPE_PTR and ELEMENT_TYPE_BYREF
// as well. This will be removed when we turn on ELEMENT_TYPE_MODIFIER bits for 
// these two enum members.
//
FORCEINLINE int CorIsModifierElementType(CorElementType elementtype)
{
    if (elementtype == ELEMENT_TYPE_PTR || elementtype == ELEMENT_TYPE_BYREF)   
        return 1;   
    return  (elementtype & ELEMENT_TYPE_MODIFIER);  
}

// Given a compress byte (*pData), return the size of the uncompressed data.
inline ULONG CorSigUncompressedDataSize(
    PCCOR_SIGNATURE pData)
{
    if ((*pData & 0x80) == 0)
        return 1;
    else if ((*pData & 0xC0) == 0x80)
        return 2;
    else
        return 4;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given a compressed integer(*pData), expand the compressed int to *pDataOut.
// Return value is the number of bytes that the integer occupies in the compressed format
// It is caller's responsibility to ensure pDataOut has at least 4 bytes to be written to.
//
// This function returns -1 if pass in with an incorrectly compressed data, such as
// (*pBytes & 0xE0) == 0XE0.
/////////////////////////////////////////////////////////////////////////////////////////////
inline ULONG CorSigUncompressBigData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    ULONG res;

    // 1 byte data is handled in CorSigUncompressData   
    //  _ASSERTE(*pData & 0x80);    

    // Medium.  
    if ((*pData & 0xC0) == 0x80)  // 10?? ????  
    {   
        res = (ULONG)((*pData++ & 0x3f) << 8);
        res |= *pData++;
    }   
    else // 110? ???? 
    {
        res = (*pData++ & 0x1f) << 24;
        res |= *pData++ << 16;
        res |= *pData++ << 8;
        res |= *pData++;
    }
    return res; 
}
FORCEINLINE ULONG CorSigUncompressData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    // Handle smallest data inline. 
    if ((*pData & 0x80) == 0x00)        // 0??? ????    
        return *pData++;    
    return CorSigUncompressBigData(pData);  
}

inline HRESULT CorSigUncompressData(      // return S_OK or E_BADIMAGEFORMAT if the signature is bad 
    PCCOR_SIGNATURE pData,              // [IN] compressed data
    DWORD       len,                    // [IN] length of the signature
    ULONG       *pDataOut,              // [OUT] the expanded *pData
    ULONG       *pDataLen)              // [OUT] length of the expanded *pData    
{   
    HRESULT hr = S_OK;        
    BYTE const  *pBytes = reinterpret_cast<BYTE const*>(pData); 

    // Smallest.    
    if ((*pBytes & 0x80) == 0x00)       // 0??? ????    
    {   
        if (len < 1)
        {
            *pDataOut = NULL;
            *pDataLen = 0;
            hr = META_E_BAD_SIGNATURE;
        }
        else
        {
            *pDataOut = *pBytes;    
            *pDataLen = 1; 
        }
    }    
    // Medium.  
    else if ((*pBytes & 0xC0) == 0x80)  // 10?? ????    
    {   
        if (len < 2)
        {
            *pDataOut = NULL;
            *pDataLen = 0;
            hr = META_E_BAD_SIGNATURE;
        }
        else
        {
            *pDataOut = (ULONG)(((*pBytes & 0x3f) << 8 | *(pBytes+1)));    
            *pDataLen = 2; 
        }
    }   
    else if ((*pBytes & 0xE0) == 0xC0)      // 110? ????    
    {   
        if (len < 4)
        {
            *pDataOut = NULL;
            *pDataLen = 0;
            hr = META_E_BAD_SIGNATURE;
        }
        else
        {
            *pDataOut = (ULONG)(((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3)));  
            *pDataLen = 4; 
        }
    }   
    else // We don't recognize this encoding
    {
        *pDataOut = NULL;
        *pDataLen = 0;
        hr = META_E_BAD_SIGNATURE;
    }

    return hr;  

}

inline ULONG CorSigUncompressData(      // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    ULONG       *pDataOut)              // [OUT] the expanded *pData    
{   

    ULONG dwSizeOfData = 0;

    // We don't know how big the signature is, so we'll just say that it's big enough
    if (FAILED(CorSigUncompressData(pData, 0xff, pDataOut, &dwSizeOfData)))
        return (ULONG)-1;


    return dwSizeOfData;
}




const static mdToken g_tkCorEncodeToken[4] ={mdtTypeDef, mdtTypeRef, mdtTypeSpec, mdtBaseType};

// uncompress a token
inline mdToken CorSigUncompressToken(   // return the token.    
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    mdToken     tk; 
    mdToken     tkType; 

    tk = CorSigUncompressData(pData);   
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    return tk;  
}


inline ULONG CorSigUncompressToken(     // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    mdToken     *pToken)                // [OUT] the expanded *pData    
{
    ULONG       cb; 
    mdToken     tk; 
    mdToken     tkType; 

    cb = CorSigUncompressData(pData, (ULONG *)&tk); 
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    *pToken = tk;   
    return cb;  
}

inline HRESULT CorSigUncompressToken(      
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    DWORD       dwLen,                  // [IN] Remaining length of sigature
    mdToken     *pToken,                // [OUT] the expanded *pData
    DWORD       *dwTokenLength)         // [OUT] The length of the token in the sigature    
{
    mdToken     tk; 
    mdToken     tkType; 

    HRESULT hr = CorSigUncompressData(pData, dwLen, (ULONG *)&tk, dwTokenLength);

    if (SUCCEEDED(hr))
    {
        tkType = g_tkCorEncodeToken[tk & 0x3];  
        tk = TokenFromRid(tk >> 2, tkType); 
        *pToken = tk;   
    }
    else
    {
        *pToken = mdTokenNil;
    }
    return hr;  
}



FORCEINLINE ULONG CorSigUncompressCallingConv(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return *pData++;    
}

FORCEINLINE HRESULT CorSigUncompressCallingConv(
    PCCOR_SIGNATURE pData,              // [IN] Signature
    DWORD           dwLen,              // [IN] Length of signature
    ULONG           *data)             // [OUT] compressed data 
{
    if (dwLen > 0)
    {
        *data = *pData;
        return S_OK;
    }
    else
    {
        *data = 0;
        return META_E_BAD_SIGNATURE;
    }
}


enum {
    SIGN_MASK_ONEBYTE  = 0xffffffc0,        // Mask the same size as the missing bits.  
    SIGN_MASK_TWOBYTE  = 0xffffe000,        // Mask the same size as the missing bits.  
    SIGN_MASK_FOURBYTE = 0xf0000000,        // Mask the same size as the missing bits.  
};

// uncompress a signed integer
inline ULONG CorSigUncompressSignedInt( // return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    int         *pInt)                  // [OUT] the expanded *pInt 
{
    ULONG       cb; 
    ULONG       ulSigned;   
    ULONG       iData;  

    cb = CorSigUncompressData(pData, &iData);   
    if (cb == (ULONG) -1) return cb;
    ulSigned = iData & 0x1; 
    iData = iData >> 1; 
    if (ulSigned)   
    {   
        if (cb == 1)    
        {   
            iData |= SIGN_MASK_ONEBYTE; 
        }   
        else if (cb == 2)   
        {   
            iData |= SIGN_MASK_TWOBYTE; 
        }   
        else    
        {   
            iData |= SIGN_MASK_FOURBYTE;    
        }   
    }   
    *pInt = (int)iData;  
    return cb;  
}


// uncompress encoded element type
FORCEINLINE CorElementType CorSigUncompressElementType(//Element type
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return (CorElementType)*pData++;    
}

inline ULONG CorSigUncompressElementType(// return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    CorElementType *pElementType)       // [OUT] the expanded *pData    
{   
    *pElementType = (CorElementType)(*pData & 0x7f);    
    return 1;   
}


/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given an uncompressed unsigned integer (iLen), Store it to pDataOut in a compressed format.
// Return value is the number of bytes that the integer occupies in the compressed format.
// It is caller's responsibilityt to ensure *pDataOut has at least 4 bytes to write to.
//
// Note that this function returns -1 if iLen is too big to be compressed. We currently can
// only represent to 0x1FFFFFFF.
//
/////////////////////////////////////////////////////////////////////////////////////////////
inline ULONG CorSigCompressData(        // return number of bytes that compressed form of iLen will take    
    ULONG       iLen,                   // [IN] given uncompressed data 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{   
    BYTE        *pBytes = reinterpret_cast<BYTE *>(pDataOut);   

    if (iLen <= 0x7F)   
    {   
        *pBytes = BYTE(iLen);    
        return 1;   
    }   

    if (iLen <= 0x3FFF) 
    {   
        *pBytes     = BYTE((iLen >> 8) | 0x80);   
        *(pBytes+1) = BYTE(iLen & 0xff);
        return 2;   
    }   

    if (iLen <= 0x1FFFFFFF) 
    {   
        *pBytes     = BYTE((iLen >> 24) | 0xC0);  
        *(pBytes+1) = BYTE((iLen >> 16) & 0xff);
        *(pBytes+2) = BYTE((iLen >> 8)  & 0xff);
        *(pBytes+3) = BYTE(iLen & 0xff);
        return 4;   
    }   
    return (ULONG) -1;  

}

// compress a token
// The least significant bit of the first compress byte will indicate the token type.
//
inline ULONG CorSigCompressToken(       // return number of bytes that compressed form of iLen will take    
    mdToken     tk,                     // [IN] given token 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    RID         rid = RidFromToken(tk); 
    ULONG32     ulTyp = TypeFromToken(tk);  

    if (rid > 0x3FFFFFF)    
        // token is too big to be compressed    
        return (ULONG) -1;  

    rid = (rid << 2);   

    // TypeDef is encoded with low bits 00  
    // TypeRef is encoded with low bits 01  
    // TypeSpec is encoded with low bits 10    
    // BaseType is encoded with low bit 11
    //
    if (ulTyp == g_tkCorEncodeToken[1]) 
    {   
        // make the last two bits 01    
        rid |= 0x1; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[2])    
    {   
        // make last two bits 0 
        rid |= 0x2; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[3])
    {
        rid |= 0x3;
    }
    return CorSigCompressData((ULONG)rid, pDataOut);   
}

// compress a signed integer
// The least significant bit of the first compress byte will be the signed bit.
//
inline ULONG CorSigCompressSignedInt(   // return number of bytes that compressed form of iData will take   
    int         iData,                  // [IN] given integer   
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    ULONG       isSigned = 0;   

    if (iData < 0)  
        isSigned = 0x1; 

    if ((iData & SIGN_MASK_ONEBYTE) == 0 || (iData & SIGN_MASK_ONEBYTE) == SIGN_MASK_ONEBYTE)   
    {   
        iData &= ~SIGN_MASK_ONEBYTE;    
    }   
    else if ((iData & SIGN_MASK_TWOBYTE) == 0 || (iData & SIGN_MASK_TWOBYTE) == SIGN_MASK_TWOBYTE)  
    {   
        iData &= ~SIGN_MASK_TWOBYTE;    
    }   

    else if ((iData & SIGN_MASK_FOURBYTE) == 0 || (iData & SIGN_MASK_FOURBYTE) == SIGN_MASK_FOURBYTE)   
    {   
        iData &= ~SIGN_MASK_FOURBYTE;   
    }   
    else    
    {   
        // out of compressable range    
        return (ULONG) -1;  
    }   
    iData = (int) (iData << 1 | isSigned);  
    return CorSigCompressData((ULONG)iData, pDataOut); 
}



// uncompress encoded element type
inline ULONG CorSigCompressElementType(// return number of bytes of that compressed data occupied in pData
    CorElementType et,                 // [OUT] the expanded *pData 
    void        *pData)                // [IN] compressed data  
{   
    BYTE        *pBytes = (BYTE *)(pData);  

    *pBytes = BYTE(et);   
    return 1;   

}

// Compress a pointer (used for internal element types only, never for persisted
// signatures).
inline ULONG CorSigCompressPointer(     // return number of bytes of that compressed data occupied
    void        *pvPointer,             // [IN] given uncompressed data 
    void        *pData)                 // [OUT] buffer where iLen will be compressed and stored.   
{   
    *((void* UNALIGNED *)pData) = pvPointer;
    return sizeof(void*);
}

// Uncompress a pointer (see above for comments).
inline ULONG CorSigUncompressPointer(   // return number of bytes of that compressed data occupied
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    void            **ppvPointer)       // [OUT] the expanded *pData    
{   
    *ppvPointer = *(void* UNALIGNED *)pData;
    return sizeof(void*);
}

#endif  // __cplusplus

#endif // _COR_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\CorError.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
/*********************************************************************
 **                                                                 **
 ** CorError.h - lists the HResults used by the .NET Framework's    **
 **              Common Language Runtime.                           **
 ** Created: September 3, 1999.                                     **
 **                                                                 **
 *********************************************************************/


#ifndef __COMMON_LANGUAGE_RUNTIME_HRESULTS__
#define __COMMON_LANGUAGE_RUNTIME_HRESULTS__

/*********************************************************************

These HRESULTs are used for mapping managed exceptions to COM error codes
and vice versa through COM Interop.  For background on COM error codes see
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/com/error_9td2.asp.

FACILITY_URT is defined as 0x13 (0x8013xxxx). The facility range is reserved
for the .NET Framework SDK teams.

Within that range, the following subranges have been allocated for different
feature areas:

0x10yy for Execution Engine
0x11yy for Metadata, TypeLib Export, and CLDB
0x12yy for MetaData Validator
0x13yy for Debugger and Profiler errors
0x14yy for Security
0x15yy for BCL
0x1600 - 0x161F for Reflection
0x1620 - 0x163F for System.IO
0x1640 - 0x165F for Security
0x1660 - 0x16FF for BCL
0x17yy for shim
0x18yy for IL Verifier
0x19yy for .NET Framework
0x1Ayy for .NET Framework
0x1Byy for MetaData Validator
0x1Cyy for more debugger errors
0x1Dyy for PE Format Validation
0x1Eyy for CLR Optimization Service errors
0x1Fyy for NGEN errors
0x30yy for VSA errors

Base class library HRESULTs are copied from this file into many different
files named __HResults.cs under the BCL directory.  Frameworks HRESULTs are
defined in src/main/HResults.cs. If you make any modifications to
the range allocations described above, please make sure the corerror.h file
gets updated.

*********************************************************************/

#include <winerror.h>

#ifndef FACILITY_URT
#define FACILITY_URT            0x13
#endif

#ifndef EMAKEHR
#define SMAKEHR(val)            MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_URT, val)
#define EMAKEHR(val)            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_URT, val)
#endif


// ******************
// FACILITY_UTF
// ******************


// ******************
// Metadata errors
// ******************

//**** ICeeFileGen errors.
#define CEE_E_ENTRYPOINT                EMAKEHR(0x1000)     // The entry point info is invalid.
#define CEE_E_CVTRES_NOT_FOUND          EMAKEHR(0x1001)     // cannot find cvtres.exe

//**** EE errors
#define MSEE_E_LOADLIBFAILED            EMAKEHR(0x1010)     // Failed to delay load library %s (Win32 error: %d).
#define MSEE_E_GETPROCFAILED            EMAKEHR(0x1011)     // Failed to get entry point %s (Win32 error: %d).
#define MSEE_E_MULTCOPIESLOADED         EMAKEHR(0x1012)     // Multiple copies of MSCOREE.dll have been loaded by the same process.
// the following two are COR to match the name used in the library
#define COR_E_APPDOMAINUNLOADED         EMAKEHR(0x1014)     // access unloaded appdomain
#define COR_E_CANNOTUNLOADAPPDOMAIN     EMAKEHR(0x1015)     // Error while unloading an appdomain
#define MSEE_E_ASSEMBLYLOADINPROGRESS   EMAKEHR(0x1016)     // Assembly is being currently being loaded
#define MSEE_E_CANNOTCREATEAPPDOMAIN    EMAKEHR(0x1017)     // Attempt to create appdomain failed
#define COR_E_FIXUPSINEXE                   EMAKEHR(0x1019)     // Attempt to load an unverifiable exe with fixups (IAT with more than 2 sections or a TLS section)
#define COR_E_NO_LOADLIBRARY_ALLOWED    EMAKEHR(0x101A)     // Attempt to LoadLibrary a managed image in an improper way (only assemblies with EAT's area allowed.)
#define COR_E_NEWER_RUNTIME             EMAKEHR(0x101B)     // The assembly is built by a runtime newer than the currently loaded runtime, and cannot be loaded.
#define COR_E_CANNOT_SET_POLICY         EMAKEHR(0x101C)     // Unable to set app domain security policy after non-GAC domain neutral assemblies are loaded
#define COR_E_CANNOT_SPECIFY_EVIDENCE   EMAKEHR(0x101D)     // Unable to use assembly evidence after non-GAC domain neutral assemblies are loaded

// The CLR hosting support reserves 0x1020-0x102F.
#define HOST_E_DEADLOCK        EMAKEHR(0x1020)             // Host detects deadlock on a blocking operation
#define HOST_E_INTERRUPTED     EMAKEHR(0x1021)             // Host interrupts a wait, similar to APC
#define HOST_E_INVALIDOPERATION     EMAKEHR(0x1022)        // The operation is invalid
#define HOST_E_CLRNOTAVAILABLE     EMAKEHR(0x1023)         // CLR has been disabled due to unrecoverable error
#define HOST_E_TIMEOUT     EMAKEHR(0x1024)                 // A wait times out
#define HOST_E_NOT_OWNER     EMAKEHR(0x1025)               //
#define HOST_E_ABANDONED     EMAKEHR(0x1026)               // An event is abandoned
#define HOST_E_EXITPROCESS_THREADABORT     EMAKEHR(0x1027) // ExitProcess due to ThreadAbort escalation
#define HOST_E_EXITPROCESS_ADUNLOAD     EMAKEHR(0x1028)    // ExitProcess due to AD Unload escalation
#define HOST_E_EXITPROCESS_TIMEOUT     EMAKEHR(0x1029)     // ExitProcess due to Timeout escalation
#define HOST_E_EXITPROCESS_OUTOFMEMORY     EMAKEHR(0x102a) // ExitProcess due to OutOfMemory escalation
#define HOST_E_EXITPROCESS_STACKOVERFLOW   EMAKEHR(0x102b) // ExitProcess due to StackOverflow escalation

//**** Assembly Cache errors
#define COR_E_MODULE_HASH_CHECK_FAILED EMAKEHR(0x1039)      // The check of the module's hash failed.
#define FUSION_E_REF_DEF_MISMATCH       EMAKEHR(0x1040)     // The located assembly's manifest definition does not match the assembly reference.
#define FUSION_E_INVALID_PRIVATE_ASM_LOCATION EMAKEHR(0x1041) // The private assembly was located outside the appbase directory.
#define FUSION_E_ASM_MODULE_MISSING     EMAKEHR(0x1042)     // A module specified in the manifest was not found.
#define FUSION_E_UNEXPECTED_MODULE_FOUND EMAKEHR(0x1043)    // Modules which are not in the manifest were streamed in.
#define FUSION_E_PRIVATE_ASM_DISALLOWED EMAKEHR(0x1044)     // A strongly-named assembly is required.
#define FUSION_E_SIGNATURE_CHECK_FAILED EMAKEHR(0x1045)     // The check of the signature failed.
#define FUSION_E_DATABASE_ERROR         EMAKEHR(0x1046)     // An unexpected error was encountered in the Assembly Cache database.
#define FUSION_E_INVALID_NAME           EMAKEHR(0x1047)     // The given assembly name or codebase was invalid.
#define FUSION_E_CODE_DOWNLOAD_DISABLED EMAKEHR(0x1048)     // HTTP download of assemblies has been disabled for this appdomain.
#define FUSION_E_UNINSTALL_DISALLOWED   EMAKEHR(0x1049)     // Uninstall of given assembly is not allowed.
#define FUSION_E_HOST_GAC_ASM_MISMATCH  EMAKEHR(0x1050)     // Assembly in host store has a different signature than assembly in GAC
#define FUSION_E_LOADFROM_BLOCKED       EMAKEHR(0x1051)     // Hosted environment doesn't permit loading by location
#define FUSION_E_CACHEFILE_FAILED       EMAKEHR(0x1052)     // Failed to add file to AppDomain cache


//=============================================================================
// THE VALIDATOR IS CURRENTLY USING ERROR CODES STARTING WITH 0x1050 ONWARDS.
// LOOK AT ERROR CODES STARTING FROM VLDTR_E_AS_NAMENULL.  JUST A NOTE IN CASE
// THE EE EVER COMES TO THE POINT OF NEEDING THOSE!!!
//=============================================================================

//**** Generic errors.
#define CLDB_E_FILE_BADREAD             EMAKEHR(0x1100)     // Error occured during a read.
#define CLDB_E_FILE_BADWRITE            EMAKEHR(0x1101)     // Error occured during a write.
#define CLDB_E_FILE_READONLY            EMAKEHR(0x1103)     // File is read only.
#define CLDB_E_NAME_ERROR               EMAKEHR(0x1105)     // An ill-formed name was given.
#define CLDB_S_TRUNCATION               SMAKEHR(0x1106)     // STATUS: Data value was truncated.
#define CLDB_E_TRUNCATION               EMAKEHR(0x1106)     // ERROR:  Data value was truncated.
#define CLDB_E_FILE_OLDVER              EMAKEHR(0x1107)     // Old version error.
#define CLDB_E_RELOCATED                EMAKEHR(0x1108)     // A shared mem open failed to open at the originally
                                                    //  assigned memory address.
#define CLDB_S_NULL                     SMAKEHR(0x1109)     // NULL data value.
#define CLDB_E_SMDUPLICATE              EMAKEHR(0x110A)     // Create of shared memory failed.  A memory mapping of the same name already exists.
#define CLDB_E_NO_DATA                  EMAKEHR(0x110B)     // There isn't .CLB data in the memory or stream.
#define CLDB_E_READONLY                 EMAKEHR(0x110C)     // Database is read only.
#define CLDB_E_INCOMPATIBLE             EMAKEHR(0x110D)     // The importing scope is not comptabile with the emitting scope

//**** Schema errors.
#define CLDB_E_FILE_CORRUPT             EMAKEHR(0x110E)     // File is corrupt.
#define CLDB_E_SCHEMA_VERNOTFOUND       EMAKEHR(0x110F)   // Version %d of schema '%s' not found.
#define CLDB_E_BADUPDATEMODE            EMAKEHR(0x1110)     // cannot open a incrementally build scope for full update

//**** Index errors.
#define CLDB_E_INDEX_NONULLKEYS         EMAKEHR(0x1121)     // Null value not allowed in unique index or primary key.
#define CLDB_E_INDEX_DUPLICATE          EMAKEHR(0x1122)     // Unique index %s has been violated.
#define CLDB_E_INDEX_BADTYPE            EMAKEHR(0x1123)     // The columns data type is not allowed in an index.
#define CLDB_E_INDEX_NOTFOUND           EMAKEHR(0x1124)     // Index %s not found.
#define CLDB_S_INDEX_TABLESCANREQUIRED  SMAKEHR(0x1125) // Table scan required to run query.

//**** Record errors.
#define CLDB_E_RECORD_NOTFOUND          EMAKEHR(0x1130)     // Record wasn't found on lookup.
#define CLDB_E_RECORD_OVERFLOW          EMAKEHR(0x1131)     // Too many records were returned for criteria.
#define CLDB_E_RECORD_DUPLICATE         EMAKEHR(0x1132)     // Record is a duplicate.
#define CLDB_E_RECORD_PKREQUIRED        EMAKEHR(0x1133)    // Primary key value is required.
#define CLDB_E_RECORD_DELETED           EMAKEHR(0x1134)     // Record is valid but deleted.
#define CLDB_E_RECORD_OUTOFORDER        EMAKEHR(0x1135)    // Record is emitted out of order.

//**** Column errors.
#define CLDB_E_COLUMN_OVERFLOW          EMAKEHR(0x1140)     // Data too large.
#define CLDB_E_COLUMN_READONLY          EMAKEHR(0x1141)     // Column cannot be changed.
#define CLDB_E_COLUMN_SPECIALCOL        EMAKEHR(0x1142)    // Too many RID or primary key columns, 1 is max.
#define CLDB_E_COLUMN_PKNONULLS         EMAKEHR(0x1143)     // Primary key column %s may not allow the null value.

//**** Table errors.
#define CLDB_E_TABLE_CANTDROP           EMAKEHR(0x1150)     // Can't auto-drop table while open.

//**** Object errors.
#define CLDB_E_OBJECT_NOTFOUND          EMAKEHR(0x1151)     // Object was not found in the database.
#define CLDB_E_OBJECT_COLNOTFOUND       EMAKEHR(0x1152)   // The column was not found.

//**** Vector errors.
#define CLDB_E_VECTOR_BADINDEX          EMAKEHR(0x1153)     // The index given was invalid.

//**** Heap errors;
#define CLDB_E_TOO_BIG                  EMAKEHR(0x1154)     // A blob or string was too big.

//**** IMeta* errors.
#define META_E_INVALID_TOKEN_TYPE       EMAKEHR(0x115f) // A token of the wrong type passed to a metadata function.

#define TLBX_E_INVALID_TYPEINFO         EMAKEHR(0x1160) // Typelib import: invalid type, not converted.
#define TLBX_E_INVALID_TYPEINFO_UNNAMED EMAKEHR(0x1161) // Typelib import: invalid type, not converted -- name unknown.
#define TLBX_E_CTX_NESTED               EMAKEHR(0x1162) // Typelib export: Format string for nested contexts.
#define TLBX_E_ERROR_MESSAGE            EMAKEHR(0x1163) // Typelib export: Error message wrapper.
#define TLBX_E_CANT_SAVE                EMAKEHR(0x1164) // Typelib export: cant "SaveAllChanges()"
#define TLBX_W_LIBNOTREGISTERED         EMAKEHR(0x1165) // Typelib export: type library is not registered.
#define TLBX_E_CANTLOADLIBRARY          EMAKEHR(0x1166) // Typelib export: type library cannot be loaded.
#define TLBX_E_BAD_VT_TYPE              EMAKEHR(0x1167) // Typelib import: invalid VT_*, not converted.
#define TLBX_E_NO_MSCOREE_TLB           EMAKEHR(0x1168) // Typelib export: can't load mscoree.tlb
#define TLBX_E_BAD_MSCOREE_TLB          EMAKEHR(0x1169) // Typelib export: can't get a required typeinfo from mscoree.tlb.
#define TLBX_E_TLB_EXCEPTION            EMAKEHR(0x116a) // Typelib import: fault reading a typelib.
#define TLBX_E_MULTIPLE_LCIDS           EMAKEHR(0x116b) // Typelib import: Multiple LCID's parameters on a method.
#define TLBX_I_TYPEINFO_IMPORTED        SMAKEHR(0x116c) // Typelib import: progress report.
#define TLBX_E_AMBIGUOUS_RETURN         EMAKEHR(0x116d) // Typelib import: duplicate or ambiguous return types.
#define TLBX_E_DUPLICATE_TYPE_NAME      EMAKEHR(0x116e) // Typelib import: duplicate name (due to user-defined name).
#define TLBX_I_USEIUNKNOWN              SMAKEHR(0x116f) // Typelib export: substituted IUnknown for type.

#define TLBX_I_UNCONVERTABLE_ARGS       SMAKEHR(0x1170) // Typelib import: signature can't be converted (eg, struct**)
#define TLBX_I_UNCONVERTABLE_FIELD      SMAKEHR(0x1171) // Typelib import: signature can't be converted (eg, struct**)
#define TLBX_I_NONSEQUENTIALSTRUCT      EMAKEHR(0x1172) // Typelib export: Can't convert non-sequential structs.
#define TLBX_W_WARNING_MESSAGE          SMAKEHR(0x1173) // Typelib export: Warning message wrapper.
#define TLBX_I_RESOLVEREFFAILED         EMAKEHR(0x1174) // Typelib import: The resolve ref call failed.
#define TLBX_E_ASANY                    EMAKEHR(0x1175) // Typelib export: Encounterd "AsAny" -- ignored.
#define TLBX_E_INVALIDLCIDPARAM         EMAKEHR(0x1176) // Typelib export: Encounterd an LCID attribute set to an invalid param.
#define TLBX_E_LCIDONDISPONLYITF        EMAKEHR(0x1177) // Typelib export: Encounterd an LCID attribute on a disp only interface.
#define TLBX_E_NONPUBLIC_FIELD          EMAKEHR(0x1178) // Typelib export: Non-public field in public struct.
#define TLBX_I_TYPE_EXPORTED            SMAKEHR(0x1179) // Typelib export: type exported
#define TLBX_I_DUPLICATE_DISPID         SMAKEHR(0x117A) // Typelib export: duplicate dispid -- auto corrected.
#define TLBX_E_BAD_NAMES                EMAKEHR(0x117B) // Typelib export: bad names list.
#define TLBX_I_REF_TYPE_AS_STRUCT       SMAKEHR(0x117C) // Typelib export: referenct tyep had layout, exported as struct.
#define TLBX_E_GENERICINST_SIGNATURE    EMAKEHR(0x117D) // TypeLib export: generic type instance in signature.
#define TLBX_E_GENERICPAR_SIGNATURE     EMAKEHR(0x117E) // TypeLib export: generic type parameter in signature.
#define TLBX_I_GENERIC_TYPE             SMAKEHR(0x117F) // TypeLib export: generic type definition

#define META_E_DUPLICATE                EMAKEHR(0x1180)     // Attempt to define an object that already exists.
#define META_E_GUID_REQUIRED            EMAKEHR(0x1181)     // A guid was not provided where one was required.
#define META_E_TYPEDEF_MISMATCH         EMAKEHR(0x1182)     // Merge: an import typedef matched ns.name, but not version and guid.
#define META_E_MERGE_COLLISION          EMAKEHR(0x1183)     // Merge: conflict between import and emit
#define TLBX_W_NON_INTEGRAL_CA_TYPE     SMAKEHR(0x1184) // TypeLib import: Ignoring IDL custom attribute -- does not have an integral value.
#define TLBX_W_IENUM_CA_ON_IUNK         SMAKEHR(0x1185) // TypeLib import: Ignoring IDL custom attribute -- using IEnum CA on an IUnknown derived interface.
#define TLBX_E_NO_SAFEHANDLE_ARRAYS     EMAKEHR(0x1186) // TypeLib export: detected array of SafeHandles
#define META_E_METHD_NOT_FOUND          EMAKEHR(0x1187) // Merge: Class already in emit scope, but member not found
#define META_E_FIELD_NOT_FOUND          EMAKEHR(0x1188) // Merge: Class already in emit scope, but member not found
#define META_S_PARAM_MISMATCH           SMAKEHR(0x1189) // Merge: Parameter information mismatched.
#define META_E_PARAM_MISMATCH           EMAKEHR(0x1189) // Merge: Parameter information mismatched.
#define META_E_BADMETADATA              EMAKEHR(0x118A) // Merge: Inconsistency in meta data import scope
#define META_E_INTFCEIMPL_NOT_FOUND     EMAKEHR(0x118B) // Merge: Class already in emit scope, but interfaceimpl not found
#define TLBX_E_NO_CRITICALHANDLE_ARRAYS EMAKEHR(0x118C) // TypeLib export: detected array of CriticalHandles
#define META_E_CLASS_LAYOUT_INCONSISTENT EMAKEHR(0x118D) // Merge: Class is duplicated but class layout information is not consistent
#define META_E_FIELD_MARSHAL_NOT_FOUND  EMAKEHR(0x118E) // Merge: Field is duplicated but we cannot find the matching FieldMarshal information
#define META_E_METHODSEM_NOT_FOUND      EMAKEHR(0x118F) // Merge:

#define META_E_EVENT_NOT_FOUND          EMAKEHR(0x1190) // Merge: Method is duplicated but we cannot find the matching event info.
#define META_E_PROP_NOT_FOUND           EMAKEHR(0x1191) // Merge: Method is duplicated but we cannot find the maching property info.
#define META_E_BAD_SIGNATURE            EMAKEHR(0x1192) // Bad binary signature
#define META_E_BAD_INPUT_PARAMETER      EMAKEHR(0x1193) // Bad input parameters
#define META_E_METHDIMPL_INCONSISTENT   EMAKEHR(0x1194) // Merge: duplicated methods have inconsistent ImplFlags
#define META_E_MD_INCONSISTENCY         EMAKEHR(0x1195) // Merge: Inconsistency in meta data
#define META_E_CANNOTRESOLVETYPEREF     EMAKEHR(0x1196) // Cannot resolve typeref
#define META_S_DUPLICATE                SMAKEHR(0x1197) // Attempt to define an object that already exists in valid scenerios.
#define META_E_STRINGSPACE_FULL         EMAKEHR(0x1198) // No logical space left to create more user strings.
#define META_E_UNEXPECTED_REMAP         EMAKEHR(0x1199) // A TokenRemap occurred which we weren't prepared to handle.
#define META_E_HAS_UNMARKALL            EMAKEHR(0x119A) // Unmark all has been called already
#define META_E_MUST_CALL_UNMARKALL      EMAKEHR(0x119B) // Must call UnmarkAll first before marking.
#define META_E_GENERICPARAM_INCONSISTENT EMAKEHR(0x119C) // Merge: duplicated types/methods have inconsistent GenericParams
#define META_E_EVENT_COUNTS             EMAKEHR(0x119D) // Merge: different event counts in import and emit scopes.
#define META_E_PROPERTY_COUNTS          EMAKEHR(0x119E) // Merge: different property counts in import and emit scopes.
#define META_E_TYPEDEF_MISSING          EMAKEHR(0x119F) // Merge: An input scope has a TypeRef which should but doesn't have a matching TypeDef.

#define TLBX_E_CANT_LOAD_MODULE         EMAKEHR(0x11A0) // TypeLib export: can't open the module to export.
#define TLBX_E_CANT_LOAD_CLASS          EMAKEHR(0x11A1) // TypeLib export: can't load a class.
#define TLBX_E_NULL_MODULE              EMAKEHR(0x11A2) // TypeLib export: the hMod of a loaded class is 0; can't export it.
#define TLBX_E_NO_CLSID_KEY             EMAKEHR(0x11A3) // TypeLib export: no CLSID or Interface subkey to HKCR.
#define TLBX_E_CIRCULAR_EXPORT          EMAKEHR(0x11A4) // TypeLib export: attempt to export a CLB imported from a TLB.
#define TLBX_E_CIRCULAR_EXPORT2          EMAKEHR(0x1B52) // TypeLib export: attempt to export a CLB imported from a TLB.
#define TLBX_E_CIRCULAR_IMPORT          EMAKEHR(0x11A5) // TypeLib import: attempt to import a TLB exported from a CLB.
#define TLBX_E_BAD_NATIVETYPE           EMAKEHR(0x11A6) // TypeLib export: bad Native type in method signature.
#define TLBX_E_BAD_VTABLE               EMAKEHR(0x11A7) // TypeLib import: non-increasing vtable (duplicate slots).
#define TLBX_E_CRM_NON_STATIC           EMAKEHR(0x11A8) // TypeLib export: the COM register method is non static.
#define TLBX_E_CRM_INVALID_SIG          EMAKEHR(0x11A9) // TypeLib export: the specified COM register method does not have the correct signature.
#define TLBX_E_CLASS_LOAD_EXCEPTION     EMAKEHR(0x11AA) // TypeLib export: can't load, have the class load exception.
#define TLBX_E_UNKNOWN_SIGNATURE        EMAKEHR(0x11AB) // TypeLib export: unknown element in signature.
#define TLBX_E_REFERENCED_TYPELIB       EMAKEHR(0x11AC) // TypeLib import: reference to an external typelib.
#define TLBX_S_REFERENCED_TYPELIB       SMAKEHR(0x11AC) // TypeLib import: reference to an external typelib.
#define TLBX_E_INVALID_NAMESPACE        EMAKEHR(0x11AD) // TypeLib import: an imported typelib has an invalid namespace name.
#define TLBX_E_LAYOUT_ERROR             EMAKEHR(0x11AE) // Typelib export: an error on Layout()
#define TLBX_E_NOTIUNKNOWN              EMAKEHR(0x11AF) // Typelib import: Interface not derived from IUnknown.

#define TLBX_E_NONVISIBLEVALUECLASS     EMAKEHR(0x11B0) // Typelib export: Non COM visible value type in method signature.
#define TLBX_E_LPTSTR_NOT_ALLOWED       EMAKEHR(0x11B1) // Typelib export: Types which contain the native type NATIVE_TYPE_LPTSTR are not allowed to be exported to COM.
#define TLBX_E_AUTO_CS_NOT_ALLOWED      EMAKEHR(0x11B2) // Typelib export: Types with a char set of auto are not allowed to be exported to COM.
#define TLBX_S_NOSTDINTERFACE           SMAKEHR(0x11B3) // Typelib export: Found an interface marked as IID_IDispatch or IID_IUnknown.
#define TLBX_S_DUPLICATE_DISPID         SMAKEHR(0x11B4) // Typelib export: duplicate dispid found; ignored.
#define TLBX_E_ENUM_VALUE_INVALID       EMAKEHR(0x11B5) // Typelib export: The enum value is not legal for a typelib.
#define TLBX_E_DUPLICATE_IID            EMAKEHR(0x11B6) // Typelib export: Duplicate IID
#define TLBX_E_NO_NESTED_ARRAYS         EMAKEHR(0x11B7) // Tyeplib export: detected nested arrays.
#define TLBX_E_PARAM_ERROR_NAMED        EMAKEHR(0x11B8) // Typelib import: param type couldn't be converted.
#define TLBX_E_PARAM_ERROR_UNNAMED      EMAKEHR(0x11B9) // Typelib import: param type couldn't be converted -- param name unknown.
#define TLBX_E_AGNOST_SIGNATURE         EMAKEHR(0x11BA) // TypeLib export: size agnostic element in signature.
#define TLBX_E_CONVERT_FAIL             EMAKEHR(0x11BB) // TypeLib export: exporter failed.
#define TLBX_W_DUAL_NOT_DISPATCH        EMAKEHR(0x11BC) // Typelib import: [dual] interface not derived from IDispatch.
#define TLBX_E_BAD_SIGNATURE            EMAKEHR(0x11BD) // Typelib export: unconvertable signature (use specific error for reporting!)
#define TLBX_E_ARRAY_NEEDS_NT_FIXED     EMAKEHR(0x11BE) // Typelib export: non-fixed/non-safearray array in struct
#define TLBX_E_CLASS_NEEDS_NT_INTF      EMAKEHR(0x11BF) // Typelib export: non-interface class in struct

#define META_E_CA_INVALID_TARGET        EMAKEHR(0x11C0) // Known custom attribute on invalid target.
#define META_E_CA_INVALID_VALUE         EMAKEHR(0x11C1) // Known custom attribute had invalid value.
#define META_E_CA_INVALID_BLOB          EMAKEHR(0x11C2) // Known custom attribute blob is bad format.
#define META_E_CA_REPEATED_ARG          EMAKEHR(0x11C3) // Known custom attribute blob has repeated named argument.
#define META_E_CA_UNKNOWN_ARGUMENT      EMAKEHR(0x11C4) // Known custom attrubte named arg not recognized.
#define META_E_CA_VARIANT_NYI           EMAKEHR(0x11C5) // Known attribute named argument doesn't support variant.
#define META_E_CA_ARRAY_NYI             EMAKEHR(0x11C6) // Known attribute named argument doesn't support array.
#define META_E_CA_UNEXPECTED_TYPE       EMAKEHR(0x11C7) // Known attribute parser found unexpected type.
#define META_E_CA_INVALID_ARGTYPE       EMAKEHR(0x11C8) // Known attribute parser only handles fields -- no properties.
#define META_E_CA_INVALID_ARG_FOR_TYPE  EMAKEHR(0x11C9) // Known attribute parser found an argument that is invalid for the object it is applied to.
#define META_E_CA_INVALID_UUID          EMAKEHR(0x11CA) // The format of the UUID was invalid.
#define META_E_CA_INVALID_MARSHALAS_FIELDS EMAKEHR(0x11CB) // The MarshalAs attribute has fields set that are not valid for the specified unmanaged type.
#define META_E_CA_NT_FIELDONLY          EMAKEHR(0x11CC) // The specified unmanaged type is only valid on fields.
#define META_E_CA_NEGATIVE_PARAMINDEX   EMAKEHR(0x11CD) // The parameter index cannot be negative.
#define META_E_CA_NEGATIVE_MULTIPLIER   EMAKEHR(0x11CE) // The multiplier cannot be negative.
#define META_E_CA_NEGATIVE_CONSTSIZE    EMAKEHR(0x11CF) // The constant size cannot be negative.

#define META_E_CA_FIXEDSTR_SIZE_REQUIRED EMAKEHR(0x11D0) // A fixed string requires a size.
#define META_E_CA_CUSTMARSH_TYPE_REQUIRED EMAKEHR(0x11D1) // A custom marshaler requires the custom marshaler type.
#define META_E_CA_FILENAME_REQUIRED     EMAKEHR(0x11D2) // A DllImport attribute requires a filename.
#define TLBX_W_NO_PROPS_IN_EVENTS       EMAKEHR(0x11D3) // TypeLib import: Detected properties in a source dispinterface.
#define META_E_NOT_IN_ENC_MODE          EMAKEHR(0x11D4) // SaveDelta was called without being in EnC mode
#define TLBX_W_ENUM_VALUE_TOOBIG        SMAKEHR(0x11D5) // Typelib export: The enum value is not legal for a typelib.
#define META_E_METHOD_COUNTS            EMAKEHR(0x11D6) // Merge: different method counts in import and emit scopes.
#define META_E_FIELD_COUNTS             EMAKEHR(0x11D7) // Merge: different field counts in import and emit scopes.
#define META_E_PARAM_COUNTS             EMAKEHR(0x11D8) // Merge: different param counts in import and emit scopes.
#define TLBX_W_EXPORTING_AUTO_LAYOUT    SMAKEHR(0x11D9) // TypeLib export: Exporting an auto-layout type.
#define TLBX_E_TYPED_REF                EMAKEHR(0x11DA) // TypeLib export: Exporting a TypedReference.
#define TLBX_W_DEFAULT_INTF_NOT_VISIBLE SMAKEHR(0x11DB) // TypeLib export: ComDefaultInterface is not COMVisible.
#define TLBX_W_BAD_SAFEARRAYFIELD_NO_ELEMENTVT SMAKEHR(0x11DE) // TypeLib export: System.Array SAFEARRAY field without a SafeArraySubType.
#define TLBX_W_LAYOUTCLASS_AS_INTERFACE SMAKEHR(0x11DF) // TypeLib export: Class with layout parameter of field marked with UnmanagedType.Interface
#define TLBX_I_GENERIC_BASE_TYPE        SMAKEHR(0x11E0) // TypeLib export: type deriving from a generic type.
#define TLBX_E_BITNESS_MISMATCH         EMAKEHR(0x11E1) // TypeLib export: bitness of assembly doesn't match bitness of output type library
#define TLBX_E_EVENT_WITH_NEWENUM       EMAKEHR(0x11E2) // TypeLib import: source interface with NewEnum member.
#define TLBX_E_PROPGET_WITHOUT_RETURN   EMAKEHR(0x11E3) // TypeLib import: propget without return type
#define META_E_MISMATCHED_VISIBLITY     EMAKEHR(0x11E4) // Merge - Match found for type/method/etc but differs in visiblity 
#define META_E_CA_BAD_FRIENDS_ARGS      EMAKEHR(0x11E5) // InternalsVisibileTo can't have a version, culture, or processor architecture 
#define META_E_CA_FRIENDS_SN_REQUIRED   EMAKEHR(0x11E6) // Strong-name signed assemblies can only grant friend access to strong name-signed assemblies


// Return values from validator functions.
#define VLDTR_S_WRN                     SMAKEHR(0x1200) // Warnings found in the validator.
#define VLDTR_S_ERR                     SMAKEHR(0x1201) // Errors found in the validator.
#define VLDTR_S_WRNERR                  SMAKEHR(0x1202) // Warnings and errors found in the validator.

// Validator structural errors.
#define VLDTR_E_RID_OUTOFRANGE          EMAKEHR(0x1203) // Rid is out of range.
#define VLDTR_E_CDTKN_OUTOFRANGE        EMAKEHR(0x1204) // Coded token type is out of range.
#define VLDTR_E_CDRID_OUTOFRANGE        EMAKEHR(0x1205) // Coded rid is out of range.
#define VLDTR_E_STRING_INVALID          EMAKEHR(0x1206) // String offset is invalid.
#define VLDTR_E_GUID_INVALID            EMAKEHR(0x1207) // GUID offset is invalid.
#define VLDTR_E_BLOB_INVALID            EMAKEHR(0x1208) // Blob offset if invalid.

// Validator semantic errors.
#define VLDTR_E_MOD_MULTI               EMAKEHR(0x1209) // Multiple module records found.
#define VLDTR_E_MOD_NULLMVID            EMAKEHR(0x120A) // Module has null MVID.
#define VLDTR_E_TR_NAMENULL             EMAKEHR(0x120B) // TypeRef name is NULL.
#define VLDTR_E_TR_DUP                  EMAKEHR(0x120C) // TypeRef has a dup.
#define VLDTR_E_TD_NAMENULL             EMAKEHR(0x120D) // TypeDef name is NULL.
#define VLDTR_E_TD_DUPNAME              EMAKEHR(0x120E) // TypeDef has a dup based on name+namespace.
#define VLDTR_E_TD_DUPGUID              EMAKEHR(0x120F) // TypeDef has a dup based on GUID.
#define VLDTR_E_TD_NOTIFACEOBJEXTNULL   EMAKEHR(0x1210) // TypeDef that's not an Interface and not System.Object extends nil parent.
#define VLDTR_E_TD_OBJEXTENDSNONNULL    EMAKEHR(0x1211) // System.Object extends a non-nil parent.
#define VLDTR_E_TD_EXTENDSSEALED        EMAKEHR(0x1212) // TypeDef extends sealed class.
#define VLDTR_E_TD_DLTNORTSPCL          EMAKEHR(0x1213) // TypeDef is Deleted but not marked with RTSpecialName.
#define VLDTR_E_TD_RTSPCLNOTDLT         EMAKEHR(0x1214) // TypeDef is marked RTSpecialName, but is not a Deleted record.
#define VLDTR_E_MI_DECLPRIV             EMAKEHR(0x1215) // MethodImpl's Decl is private
#define VLDTR_E_AS_BADNAME              EMAKEHR(0x1216) // Assembly [Ref] name has path and/or extension.
#define VLDTR_E_FILE_SYSNAME            EMAKEHR(0x1217) // File has a system name (con, com, aux, etc.).
#define VLDTR_E_MI_BODYSTATIC           EMAKEHR(0x1218) // MethodImpl's body is static.
#define VLDTR_E_TD_IFACENOTABS          EMAKEHR(0x1219) // TypeDef is marked Interface but not Abstract.
#define VLDTR_E_TD_IFACEPARNOTNIL       EMAKEHR(0x121A) // TypeDef is marked Interface but parent is not Nil.
#define VLDTR_E_TD_IFACEGUIDNULL        EMAKEHR(0x121B) // TypeDef is marked Interface but GUID is NULL.
#define VLDTR_E_MI_DECLFINAL            EMAKEHR(0x121C) // TMethodImpl's Decl is final.
#define VLDTR_E_TD_VTNOTSEAL            EMAKEHR(0x121D) // TypeDef is marked ValueType but not marked Sealed.
#define VLDTR_E_PD_BADFLAGS             EMAKEHR(0x121E) // Param has extra bits in flags.
#define VLDTR_E_IFACE_DUP               EMAKEHR(0x121F) // InterfaceImpl has a dup.
#define VLDTR_E_MR_NAMENULL             EMAKEHR(0x1220) // MemberRef name is NULL.
#define VLDTR_E_MR_VTBLNAME             EMAKEHR(0x1221) // MemberRef has an invalid name, _VtblGap*.
#define VLDTR_E_MR_DELNAME              EMAKEHR(0x1222) // MemberRef has an invalid name, _Deleted*.
#define VLDTR_E_MR_PARNIL               EMAKEHR(0x1223) // MemberRef parent Nil in a PE file.
#define VLDTR_E_MR_BADCALLINGCONV       EMAKEHR(0x1224) // MemberRef has invalid calling convention.
#define VLDTR_E_MR_NOTVARARG            EMAKEHR(0x1225) // MemberRef has Method parent but calling convention is not VARARG.
#define VLDTR_E_MR_NAMEDIFF             EMAKEHR(0x1226) // MemberRef name different from parent MethodDef.
#define VLDTR_E_MR_SIGDIFF              EMAKEHR(0x1227) // MemberRef signature different from parent MethodDef.
#define VLDTR_E_MR_DUP                  EMAKEHR(0x1228) // MemberRef has a dup.
#define VLDTR_E_CL_TDAUTO               EMAKEHR(0x1229) // ClassLayout parent TypeDef is marked AutoLayout.
#define VLDTR_E_CL_BADPCKSZ             EMAKEHR(0x122A) // ClassLayout has bad PackingSize.
#define VLDTR_E_CL_DUP                  EMAKEHR(0x122B) // ClassLayout has dup.
#define VLDTR_E_FL_BADOFFSET            EMAKEHR(0x122C) // FieldLayout2 has bad offset.
#define VLDTR_E_FL_TDNIL                EMAKEHR(0x122D) // FieldLayout2 has field with nil parent.
#define VLDTR_E_FL_NOCL                 EMAKEHR(0x122E) // FieldLayout2 has no ClassLayout record.
#define VLDTR_E_FL_TDNOTEXPLCT          EMAKEHR(0x122F) // FieldLayout2 parent TypeDef is not marked with ExplicitLayout.
#define VLDTR_E_FL_FLDSTATIC            EMAKEHR(0x1230) // FieldLayout2 has field marked Static.
#define VLDTR_E_FL_DUP                  EMAKEHR(0x1231) // FieldLayout2 has a dup.
#define VLDTR_E_MODREF_NAMENULL         EMAKEHR(0x1232) // ModuleRef name is NULL.
#define VLDTR_E_MODREF_DUP              EMAKEHR(0x1233) // ModuleRef has a dup.
#define VLDTR_E_TR_BADSCOPE             EMAKEHR(0x1234) // TypeRef has a bad resolution scope.
#define VLDTR_E_TD_NESTEDNOENCL         EMAKEHR(0x1235) // TypeDef marked nested has no encloser.
#define VLDTR_E_TD_EXTTRRES             EMAKEHR(0x1236) // TypeDef extends a TypeRef which resolves to a TypeDef in the same module.
#define VLDTR_E_SIGNULL                 EMAKEHR(0x1237) // Signature specified is zero-sized.
#define VLDTR_E_SIGNODATA               EMAKEHR(0x1238) // Signature does not have enough data at specified byte.
#define VLDTR_E_MD_BADCALLINGCONV       EMAKEHR(0x1239) // Method signature has invalid calling convention.
#define VLDTR_E_MD_THISSTATIC           EMAKEHR(0x123A) // Method is marked static but has HASTHIS/EXPLICITTHIS set on the calling convention.
#define VLDTR_E_MD_NOTTHISNOTSTATIC     EMAKEHR(0x123B) // Method is not marked static but is not HASTHIS/EXPLICITTHIS.
#define VLDTR_E_MD_NOARGCNT             EMAKEHR(0x123C) // Method signature is missing the argument count.
#define VLDTR_E_SIG_MISSELTYPE          EMAKEHR(0x123D) // Signature missing element type.
#define VLDTR_E_SIG_MISSTKN             EMAKEHR(0x123E) // Signature missing token.
#define VLDTR_E_SIG_TKNBAD              EMAKEHR(0x123F) // Signature has bad token.
#define VLDTR_E_SIG_MISSFPTR            EMAKEHR(0x1240) // Signature is missing function pointer.
#define VLDTR_E_SIG_MISSFPTRARGCNT      EMAKEHR(0x1241) // Signature has function pointer missing argument count.
#define VLDTR_E_SIG_MISSRANK            EMAKEHR(0x1242) // Signature is missing rank specification.
#define VLDTR_E_SIG_MISSNSIZE           EMAKEHR(0x1243) // Signature is missing count of sized dimensions.
#define VLDTR_E_SIG_MISSSIZE            EMAKEHR(0x1244) // Signature is missing size of dimension.
#define VLDTR_E_SIG_MISSNLBND           EMAKEHR(0x1245) // Signature is missing count of lower bounds.
#define VLDTR_E_SIG_MISSLBND            EMAKEHR(0x1246) // Signature is missing a lower bound.
#define VLDTR_E_SIG_BADELTYPE           EMAKEHR(0x1247) // Signature has bad element type.
#define VLDTR_E_SIG_MISSVASIZE          EMAKEHR(0x1248) // Signature has value array missing size.
#define VLDTR_E_FD_BADCALLINGCONV       EMAKEHR(0x1249) // Field signature has invalid calling convention.
#define VLDTR_E_MD_NAMENULL             EMAKEHR(0x124A) // Method name is NULL.
#define VLDTR_E_MD_PARNIL               EMAKEHR(0x124B) // Method has parent NIL.
#define VLDTR_E_MD_DUP                  EMAKEHR(0x124C) // Method has dup.
#define VLDTR_E_FD_NAMENULL             EMAKEHR(0x124D) // Field name is NULL.
#define VLDTR_E_FD_PARNIL               EMAKEHR(0x124E) // Field parent is Nil.
#define VLDTR_E_FD_DUP                  EMAKEHR(0x124F) // Field has dup.
#define VLDTR_E_AS_MULTI                EMAKEHR(0x1250) // Multiple Assembly records found.
#define VLDTR_E_AS_NAMENULL             EMAKEHR(0x1251) // Assembly name is NULL.
#define VLDTR_E_SIG_TOKTYPEMISMATCH     EMAKEHR(0x1252) // E_T_VALUETYPE<class token> or E_T_CLASS<vtype token>.
#define VLDTR_E_CL_TDINTF               EMAKEHR(0x1253) // Class layout on an Interface.
#define VLDTR_E_ASOS_OSPLTFRMIDINVAL    EMAKEHR(0x1254) // AssemblyOS platform ID invalid.
#define VLDTR_E_AR_NAMENULL             EMAKEHR(0x1255) // AssemblyRef name is NULL.
#define VLDTR_E_TD_ENCLNOTNESTED        EMAKEHR(0x1256) // TypeDef not nested has encloser.
#define VLDTR_E_AROS_OSPLTFRMIDINVAL    EMAKEHR(0x1257) // AssemblyRefOS has invalid platform ID.
#define VLDTR_E_FILE_NAMENULL           EMAKEHR(0x1258) // File name is NULL.
#define VLDTR_E_CT_NAMENULL             EMAKEHR(0x1259) // ExportedType name is NULL.
#define VLDTR_E_TD_EXTENDSCHILD         EMAKEHR(0x125A) // TypeDef extends its own child.
#define VLDTR_E_MAR_NAMENULL            EMAKEHR(0x125B) // ManifestResource name is NULL.
#define VLDTR_E_FILE_DUP                EMAKEHR(0x125C) // File has dup.
#define VLDTR_E_FILE_NAMEFULLQLFD       EMAKEHR(0x125D) // File name is fully qualified.
#define VLDTR_E_CT_DUP                  EMAKEHR(0x125E) // ExportedType has dup.
#define VLDTR_E_MAR_DUP                 EMAKEHR(0x125F) // ManifestResource has dup.
#define VLDTR_E_MAR_NOTPUBPRIV          EMAKEHR(0x1260) // ManifestResource is neither Public not Private.
#define VLDTR_E_TD_ENUMNOVALUE          EMAKEHR(0x1261) // Enum has no "value__" field.
#define VLDTR_E_TD_ENUMVALSTATIC        EMAKEHR(0x1262) // Enum's "value__" field is static.
#define VLDTR_E_TD_ENUMVALNOTSN         EMAKEHR(0x1263) // Enum's "value__" field is not SpecialName.
#define VLDTR_E_TD_ENUMFLDNOTST         EMAKEHR(0x1264) // Enum's field is not static.
#define VLDTR_E_TD_ENUMFLDNOTLIT        EMAKEHR(0x1265) // Enum's field is not literal.
#define VLDTR_E_TD_ENUMNOLITFLDS        EMAKEHR(0x1266) // Enum has no literal fields.
#define VLDTR_E_TD_ENUMFLDSIGMISMATCH   EMAKEHR(0x1267) // Enum's field sig does not match value__ sig.
#define VLDTR_E_TD_ENUMVALNOT1ST        EMAKEHR(0x1268) // Enum's "value__" field is not first.
#define VLDTR_E_FD_NOTVALUERTSN         EMAKEHR(0x1269) // Field is RTSpecialName but name is not "value__".
#define VLDTR_E_FD_VALUEPARNOTENUM      EMAKEHR(0x126A) // Field "value__" in not Enum class.
#define VLDTR_E_FD_INSTINIFACE          EMAKEHR(0x126B) // Instance field in interface.
#define VLDTR_E_FD_NOTPUBINIFACE        EMAKEHR(0x126C) // Non-public field in interface.
#define VLDTR_E_FMD_GLOBALNOTPUBPRIVSC  EMAKEHR(0x126D) // Global field/method neither Public nor PrivateScope.
#define VLDTR_E_FMD_GLOBALNOTSTATIC     EMAKEHR(0x126E) // Global field/method not static.
#define VLDTR_E_FD_GLOBALNORVA          EMAKEHR(0x126F) // Global field has no RVA.
#define VLDTR_E_MD_CTORZERORVA          EMAKEHR(0x1270) // .ctor,.cctor has zero RVA.
#define VLDTR_E_FD_MARKEDNOMARSHAL      EMAKEHR(0x1271) // Field is marked marshaled but has no marshaling rec.
#define VLDTR_E_FD_MARSHALNOTMARKED     EMAKEHR(0x1272) // Field has marshaling rec but is not marked marshaled.
#define VLDTR_E_FD_MARKEDNODEFLT        EMAKEHR(0x1273) // Field is marked HasDefault but has no const value.
#define VLDTR_E_FD_DEFLTNOTMARKED       EMAKEHR(0x1274) // Field has const value rec but is not marked HasDefault.
#define VLDTR_E_FMD_MARKEDNOSECUR       EMAKEHR(0x1275) // Field/method is marked HasSecurity but has no security rec.
#define VLDTR_E_FMD_SECURNOTMARKED      EMAKEHR(0x1276) // Field/method has security rec but is not marked HasSecurity.
#define VLDTR_E_FMD_PINVOKENOTSTATIC    EMAKEHR(0x1277) // Field/method is PInvoke but is not marked Static.
#define VLDTR_E_FMD_MARKEDNOPINVOKE     EMAKEHR(0x1278) // Field/method is marked PInvoke but has no ImplMap.
#define VLDTR_E_FMD_PINVOKENOTMARKED    EMAKEHR(0x1279) // Field/method has ImplMap but is not marked PInvoke.
#define VLDTR_E_FMD_BADIMPLMAP          EMAKEHR(0x127A) // Field/method has invalid ImplMap
#define VLDTR_E_IMAP_BADMODREF          EMAKEHR(0x127B) // ImplMap has invalid ModuleRef
#define VLDTR_E_IMAP_BADMEMBER          EMAKEHR(0x127C) // ImplMap has invalid MemberForwarded
#define VLDTR_E_IMAP_BADIMPORTNAME      EMAKEHR(0x127D) // ImplMap has invalid ImportName
#define VLDTR_E_IMAP_BADCALLCONV        EMAKEHR(0x127E) // ImplMap has invalid call conv
#define VLDTR_E_FMD_BADACCESSFLAG       EMAKEHR(0x127F) // Field/method has invalid access flag
#define VLDTR_E_FD_INITONLYANDLITERAL   EMAKEHR(0x1280) // Field is InitOnly and Literal
#define VLDTR_E_FD_LITERALNOTSTATIC     EMAKEHR(0x1281) // Field is Literal but not Static
#define VLDTR_E_FMD_RTSNNOTSN           EMAKEHR(0x1282) // Field/method is RTSpec.Name but not Spec.Name
#define VLDTR_E_MD_ABSTPARNOTABST       EMAKEHR(0x1283) // Method is abstract, parent is not
#define VLDTR_E_MD_NOTSTATABSTININTF    EMAKEHR(0x1284) // Method not static or abstract in interface
#define VLDTR_E_MD_NOTPUBININTF         EMAKEHR(0x1285) // Method not public in interface
#define VLDTR_E_MD_CTORININTF           EMAKEHR(0x1286) // ctor in interface
#define VLDTR_E_MD_GLOBALCTORCCTOR      EMAKEHR(0x1287) // global ctor or cctor
#define VLDTR_E_MD_CTORSTATIC           EMAKEHR(0x1288) // static ctor
#define VLDTR_E_MD_CTORNOTSNRTSN        EMAKEHR(0x1289) // ctor,cctor not marked SpecialName,RTSpecialName
#define VLDTR_E_MD_CTORVIRT             EMAKEHR(0x128A) // virtual ctor,cctor
#define VLDTR_E_MD_CTORABST             EMAKEHR(0x128B) // abstract ctor,cctor
#define VLDTR_E_MD_CCTORNOTSTATIC       EMAKEHR(0x128C) // instance cctor
#define VLDTR_E_MD_ZERORVA              EMAKEHR(0x128D) // RVA=0, method not abstract or pinvoke or runtime, or reverse
#define VLDTR_E_MD_FINNOTVIRT           EMAKEHR(0x128E) // Method is final and not virtual
#define VLDTR_E_MD_STATANDFINORVIRT     EMAKEHR(0x128F) // Method is static and final or virtual
#define VLDTR_E_MD_ABSTANDFINAL         EMAKEHR(0x1290) // Method is abstract and final
#define VLDTR_E_MD_ABSTANDIMPL          EMAKEHR(0x1291) // Method is abstract and implemented
#define VLDTR_E_MD_ABSTANDPINVOKE       EMAKEHR(0x1292) // Method is abstract and pinvoke
#define VLDTR_E_MD_ABSTNOTVIRT          EMAKEHR(0x1293) // Method is abstract and not virtual
#define VLDTR_E_MD_NOTABSTNOTIMPL       EMAKEHR(0x1294) // Method is not abstract and not implemented
#define VLDTR_E_MD_NOTABSTBADFLAGSRVA   EMAKEHR(0x1295) // Method is not abstract and not (RVA!=0 or pinvoke or runtime)
#define VLDTR_E_MD_PRIVSCOPENORVA       EMAKEHR(0x1296) // Method is PrivateScope and has RVA==0
#define VLDTR_E_MD_GLOBALABSTORVIRT     EMAKEHR(0x1297) // Global method is abstract or virtual
#define VLDTR_E_SIG_LONGFORM            EMAKEHR(0x1298) // Signature uses long form
#define VLDTR_E_MD_MULTIPLESEMANTICS    EMAKEHR(0x1299) // Method has multiple semantics (warning)
#define VLDTR_E_MD_INVALIDSEMANTICS     EMAKEHR(0x129A) // Method has invalid semantics (not event or prop)
#define VLDTR_E_MD_SEMANTICSNOTEXIST    EMAKEHR(0x129B) // Method has semantics assoc that does not exist
#define VLDTR_E_MI_DECLNOTVIRT          EMAKEHR(0x129C) // MethodImpl's Decl is not virtual
#define VLDTR_E_FMD_GLOBALITEM          EMAKEHR(0x129D) // Global field/method (warning,CLS)
#define VLDTR_E_MD_MULTSEMANTICFLAGS    EMAKEHR(0x129E) // Method has multiple semantic flags set
#define VLDTR_E_MD_NOSEMANTICFLAGS      EMAKEHR(0x129F) // Method has no semantic flags set
#define VLDTR_E_FD_FLDINIFACE           EMAKEHR(0x12A0) // Field in Interface (warning, CLS)
#define VLDTR_E_AS_HASHALGID            EMAKEHR(0x12A1) // Unrecognized Hash Alg ID (warning)
#define VLDTR_E_AS_PROCID               EMAKEHR(0x12A2) // Unrecognized Processor ID in Assembly(warning)
#define VLDTR_E_AR_PROCID               EMAKEHR(0x12A3) // Unrecognized Processor ID in AssemblyRef(warning)
#define VLDTR_E_CN_PARENTRANGE          EMAKEHR(0x12A4) // Constant: parent token out of range
#define VLDTR_E_AS_BADFLAGS             EMAKEHR(0x12A5) // Invalid flags in Assembly
#define VLDTR_E_TR_HASTYPEDEF           EMAKEHR(0x12A6) // There is TypeDef with same name as TypeRef (warning)
#define VLDTR_E_IFACE_BADIMPL           EMAKEHR(0x12A7) // In InterfaceImpl, the implementing token is not TypeDef
#define VLDTR_E_IFACE_BADIFACE          EMAKEHR(0x12A8) // In InterfaceImpl, the implemented token is not TypeDef or TypeRef
#define VLDTR_E_TD_SECURNOTMARKED       EMAKEHR(0x12A9) // TypeDef has security rec but not marked HasSecurity
#define VLDTR_E_TD_MARKEDNOSECUR        EMAKEHR(0x12AA) // TypeDef marked HasSecurity but has no security rec
#define VLDTR_E_MD_CCTORHASARGS         EMAKEHR(0x12AB) // .cctor has arguments
#define VLDTR_E_CT_BADIMPL              EMAKEHR(0x12AC) // ExportedType has invalid Implementation
#define VLDTR_E_MI_ALIENBODY            EMAKEHR(0x12AD) // MethodImpl has body from other class
#define VLDTR_E_MD_CCTORCALLCONV        EMAKEHR(0x12AE) // .cctor has invalid calling convention
#define VLDTR_E_MI_BADCLASS             EMAKEHR(0x12AF) // MethodImpl has invalid Class token
#define VLDTR_E_MI_CLASSISINTF          EMAKEHR(0x12B0) // MethodImpl declared in Interface
#define VLDTR_E_MI_BADDECL              EMAKEHR(0x12B1) // MethodImpl has invalid MethodDeclaration token
#define VLDTR_E_MI_BADBODY              EMAKEHR(0x12B2) // MethodImpl has invalid MethodBody token
#define VLDTR_E_MI_DUP                  EMAKEHR(0x12B3) // MethodImpl has duplicate
#define VLDTR_E_FD_BADPARENT            EMAKEHR(0x12B4) // Bad field parent
#define VLDTR_E_MD_PARAMOUTOFSEQ        EMAKEHR(0x12B5) // Param out of sequence (warning)
#define VLDTR_E_MD_PARASEQTOOBIG        EMAKEHR(0x12B6) // Param's sequence num exceeds num of args
#define VLDTR_E_MD_PARMMARKEDNOMARSHAL  EMAKEHR(0x12B7) // Param marked HasMarshal, has no marshaling info
#define VLDTR_E_MD_PARMMARSHALNOTMARKED EMAKEHR(0x12B8) // Param has marshaling info, not marked HasMarshal
#define VLDTR_E_MD_PARMMARKEDNODEFLT    EMAKEHR(0x12BA) // Param marked HasDefault, has no const value
#define VLDTR_E_MD_PARMDEFLTNOTMARKED   EMAKEHR(0x12BB) // Param has const value, not marked HasDefault
#define VLDTR_E_PR_BADSCOPE             EMAKEHR(0x12BC) // Prop has invalid scope
#define VLDTR_E_PR_NONAME               EMAKEHR(0x12BD) // Prop has no name
#define VLDTR_E_PR_NOSIG                EMAKEHR(0x12BE) // Prop has no signature
#define VLDTR_E_PR_DUP                  EMAKEHR(0x12BF) // Prop has a duplicate
#define VLDTR_E_PR_BADCALLINGCONV       EMAKEHR(0x12C0) // Prop has bad calling convention
#define VLDTR_E_PR_MARKEDNODEFLT        EMAKEHR(0x12C1) // Prop marked HasDefault, has no const value
#define VLDTR_E_PR_DEFLTNOTMARKED       EMAKEHR(0x12C2) // Prop has const value, not marked HasDefault
#define VLDTR_E_PR_BADSEMANTICS         EMAKEHR(0x12C3) // Prop has method not (Setter,Getter, or Other)
#define VLDTR_E_PR_BADMETHOD            EMAKEHR(0x12C4) // Prop has method with invalid token
#define VLDTR_E_PR_ALIENMETHOD          EMAKEHR(0x12C5) // Prop has method from another class
#define VLDTR_E_CN_BLOBNOTNULL          EMAKEHR(0x12C6) // Const has non-null blob when it should not
#define VLDTR_E_CN_BLOBNULL             EMAKEHR(0x12C7) // Const has null value blob
#define VLDTR_E_EV_BADSCOPE             EMAKEHR(0x12C8) // Event has invalid scope
#define VLDTR_E_EV_NONAME               EMAKEHR(0x12CA) // Event has no name
#define VLDTR_E_EV_DUP                  EMAKEHR(0x12CB) // Event has a duplicate
#define VLDTR_E_EV_BADEVTYPE            EMAKEHR(0x12CC) // Event has invalid EventType
#define VLDTR_E_EV_EVTYPENOTCLASS       EMAKEHR(0x12CD) // Event's EventType is not a class
#define VLDTR_E_EV_BADSEMANTICS         EMAKEHR(0x12CE) // Event has method not (AddOn,RemoveOn,Fire,Other)
#define VLDTR_E_EV_BADMETHOD            EMAKEHR(0x12CF) // Event has method with invalid token
#define VLDTR_E_EV_ALIENMETHOD          EMAKEHR(0x12D0) // Event has method from another class
#define VLDTR_E_EV_NOADDON              EMAKEHR(0x12D1) // Event has no AddOn method
#define VLDTR_E_EV_NOREMOVEON           EMAKEHR(0x12D2) // Event has no RemoveOn method
#define VLDTR_E_CT_DUPTDNAME            EMAKEHR(0x12D3) // ExportedType has same name as TypeDef
#define VLDTR_E_MAR_BADOFFSET           EMAKEHR(0x12D4) // MRes refers to non-PE file with offset !=0
#define VLDTR_E_DS_BADOWNER             EMAKEHR(0x12D5) // Decl.security has invalid owner token
#define VLDTR_E_DS_BADFLAGS             EMAKEHR(0x12D6) // Decl.security has invalid action flags
#define VLDTR_E_DS_NOBLOB               EMAKEHR(0x12D7) // Decl.security has no permission blob
#define VLDTR_E_MAR_BADIMPL             EMAKEHR(0x12D8) // Manifest resource has invalid Implementation
#define VLDTR_E_MR_VARARGCALLINGCONV    EMAKEHR(0x12DA) // MemberRef has VARARG calling conv. (CLS warning)
#define VLDTR_E_MD_CTORNOTVOID          EMAKEHR(0x12DB) // .ctor,.cctor returning not void
#define VLDTR_E_EV_FIRENOTVOID          EMAKEHR(0x12DC) // Fire method returning not void
#define VLDTR_E_AS_BADLOCALE            EMAKEHR(0x12DD) // Invalid locale
#define VLDTR_E_CN_PARENTTYPE           EMAKEHR(0x12DE) // Constant has parent of invalid type
#define VLDTR_E_SIG_SENTINMETHODDEF     EMAKEHR(0x12DF) // E_T_SENTINEL in MethodDef signature
#define VLDTR_E_SIG_SENTMUSTVARARG      EMAKEHR(0x12E0) // E_T_SENTINEL <=> VARARG
#define VLDTR_E_SIG_MULTSENTINELS       EMAKEHR(0x12E1) // Multiple E_T_SENTINELs
#define VLDTR_E_SIG_LASTSENTINEL        EMAKEHR(0x12E2) // E_T_SENTINEL not followed by type
#define VLDTR_E_SIG_MISSARG             EMAKEHR(0x12E3) // Signature missing argument
#define VLDTR_E_SIG_BYREFINFIELD        EMAKEHR(0x12E4) // Field of ByRef type
#define VLDTR_E_MD_SYNCMETHODINVTYPE    EMAKEHR(0x12E5) // Synchronized method in value class
#define VLDTR_E_TD_NAMETOOLONG          EMAKEHR(0x12E6) // TypeDef name too long
#define VLDTR_E_AS_PROCDUP              EMAKEHR(0x12E7) // Duplicate Assembly Processor
#define VLDTR_E_ASOS_DUP                EMAKEHR(0x12E8) // Duplicate Assembly OS (ID+ver.major+ver.minor)
#define VLDTR_E_MAR_BADFLAGS            EMAKEHR(0x12E9) // Manifest Resource has bad flags
#define VLDTR_E_CT_NOTYPEDEFID          EMAKEHR(0x12EA) // ExportedType has nil TypeDefId
#define VLDTR_E_FILE_BADFLAGS           EMAKEHR(0x12EB) // File has bad flags
#define VLDTR_E_FILE_NULLHASH           EMAKEHR(0x12EC) // File has no hash blob
#define VLDTR_E_MOD_NONAME              EMAKEHR(0x12ED) // Module has no name
#define VLDTR_E_MOD_NAMEFULLQLFD        EMAKEHR(0x12EE) // Module has fully-qualified name
#define VLDTR_E_TD_RTSPCLNOTSPCL        EMAKEHR(0x12EF) // TypeDef is tdRTSpecialName but not tdSpecialName
#define VLDTR_E_TD_EXTENDSIFACE         EMAKEHR(0x12F0) // TypeDef extends interface
#define VLDTR_E_MD_CTORPINVOKE          EMAKEHR(0x12F1) // .ctor,.cctor is PInvokeImpl
#define VLDTR_E_TD_SYSENUMNOTCLASS      EMAKEHR(0x12F2) // System.Enum is not a class
#define VLDTR_E_TD_SYSENUMNOTEXTVTYPE   EMAKEHR(0x12F3) // System.Enum extends not System.ValueType
#define VLDTR_E_MI_SIGMISMATCH          EMAKEHR(0x12F4) // MethodImpl's Decl and Body signatures mismatch
#define VLDTR_E_TD_ENUMHASMETHODS       EMAKEHR(0x12F5) // TypeDef extends System.Enum but has methods
#define VLDTR_E_TD_ENUMIMPLIFACE        EMAKEHR(0x12F6) // TypeDef extends System.Enum but impls interface(s)
#define VLDTR_E_TD_ENUMHASPROP          EMAKEHR(0x12F7) // TypeDef extends System.Enum but has prop(s)
#define VLDTR_E_TD_ENUMHASEVENT         EMAKEHR(0x12F8) // TypeDef extends System.Enum but has event(s)
#define VLDTR_E_TD_BADMETHODLST         EMAKEHR(0x12F9) // TypeDef has MethodList > Nmethods+1
#define VLDTR_E_TD_BADFIELDLST          EMAKEHR(0x12FA) // TypeDef has FieldList > Nfields+1
#define VLDTR_E_CN_BADTYPE              EMAKEHR(0x12FB) // Constant has wrong type
#define VLDTR_E_TD_ENUMNOINSTFLD        EMAKEHR(0x12FC) // Enum has no instance fields
#define VLDTR_E_TD_ENUMMULINSTFLD       EMAKEHR(0x12FD) // Enum has multiple instance fields


#define VLDTR_E_INTERRUPTED             EMAKEHR(0x12FE) // Validator has been interrupted by the VEHandler.
#define VLDTR_E_NOTINIT                 EMAKEHR(0x12FF) // Validator failed to initialize correctly.

#define VLDTR_E_IFACE_NOTIFACE          EMAKEHR(0x1B00) // Interface in InterfaceImpl is not marked tdInterface
#define VLDTR_E_FD_RVAHASNORVA          EMAKEHR(0x1B01) // Field marked fdHasFieldRVA but has no RVA rec
#define VLDTR_E_FD_RVAHASZERORVA        EMAKEHR(0x1B02) // Field marked fdHasFieldRVA has RVA =0
#define VLDTR_E_MD_RVAANDIMPLMAP        EMAKEHR(0x1B03) // Method has both RVA !=0 and ImplMap
#define VLDTR_E_TD_EXTRAFLAGS           EMAKEHR(0x1B04) // TypeDef has extraneous bits in flags
#define VLDTR_E_TD_EXTENDSITSELF        EMAKEHR(0x1B05) // TypeDef extends itself
#define VLDTR_E_TD_SYSVTNOTEXTOBJ       EMAKEHR(0x1B06) // System.ValueType does not extend System.Object
#define VLDTR_E_TD_EXTTYPESPEC          EMAKEHR(0x1B07) // Class extends TypeSpec (warning)
#define VLDTR_E_TD_VTNOSIZE             EMAKEHR(0x1B09) // Value Class has zero size
#define VLDTR_E_TD_IFACESEALED          EMAKEHR(0x1B0A) // Interface is sealed
#define VLDTR_E_NC_BADNESTED            EMAKEHR(0x1B0B) // Bad "nested" token in NestedClass
#define VLDTR_E_NC_BADENCLOSER          EMAKEHR(0x1B0C) // Bad "enclosing" token in NestedClass
#define VLDTR_E_NC_DUP                  EMAKEHR(0x1B0D) // Duplicate NestedClass record
#define VLDTR_E_NC_DUPENCLOSER          EMAKEHR(0x1B0E) // Duplicate NestedClass with different encloser
#define VLDTR_E_FRVA_ZERORVA            EMAKEHR(0x1B0F) // RVA=0 in FieldRVA record
#define VLDTR_E_FRVA_BADFIELD           EMAKEHR(0x1B10) // Invalid field token in FieldRVA record
#define VLDTR_E_FRVA_DUPRVA             EMAKEHR(0x1B11) // Duplicate RVA in FieldRVA record
#define VLDTR_E_FRVA_DUPFIELD           EMAKEHR(0x1B12) // Duplicate field in FieldRVA record
#define VLDTR_E_EP_BADTOKEN             EMAKEHR(0x1B13) // Bad token as entry point in CLR header
#define VLDTR_E_EP_INSTANCE             EMAKEHR(0x1B14) // Entry point in CLR header is a token of instance method
#define VLDTR_E_TD_ENUMFLDBADTYPE       EMAKEHR(0x1B15) // Enum has non-integral underlying type
#define VLDTR_E_MD_BADRVA               EMAKEHR(0x1B16) // Method has bogus RVA
#define VLDTR_E_FD_LITERALNODEFAULT     EMAKEHR(0x1B17) // Literal field has no const value
#define VLDTR_E_IFACE_METHNOTIMPL       EMAKEHR(0x1B18) // Class implementing an interface doesn't impl.one of methods
#define VLDTR_E_CA_BADPARENT            EMAKEHR(0x1B19) // CA has invalid owner
#define VLDTR_E_CA_BADTYPE              EMAKEHR(0x1B1A) // CA has invalid type
#define VLDTR_E_CA_NOTCTOR              EMAKEHR(0x1B1B) // CA type is not .ctor
#define VLDTR_E_CA_BADSIG               EMAKEHR(0x1B1C) // CA type has bad signature
#define VLDTR_E_CA_NOSIG                EMAKEHR(0x1B1D) // CA type has no signature
#define VLDTR_E_CA_BADPROLOG            EMAKEHR(0x1B1E) // CA blob has bad prolog (not 0x01 0x00)
#define VLDTR_E_MD_BADLOCALSIGTOK       EMAKEHR(0x1B1F) // Method has invalid LocalSig token
#define VLDTR_E_MD_BADHEADER            EMAKEHR(0x1B20) // Method has invalid header
#define VLDTR_E_EP_TOOMANYARGS          EMAKEHR(0x1B21) // Entry point has more than one arg
#define VLDTR_E_EP_BADRET               EMAKEHR(0x1B22) // Entry point has bad return type
#define VLDTR_E_EP_BADARG               EMAKEHR(0x1B23) // Entry point has bad argument
#define VLDTR_E_SIG_BADVOID             EMAKEHR(0x1B24) // Illegal "void" in signature
#define VLDTR_E_IFACE_METHMULTIMPL      EMAKEHR(0x1B25) // Multiple implementation of method
//@GENERICS
#define VLDTR_E_GP_NAMENULL             EMAKEHR(0x1B26) // GenericParam name is NULL
#define VLDTR_E_GP_OWNERNIL             EMAKEHR(0x1B27) // GenericParam has nil owner.
#define VLDTR_E_GP_DUPNAME              EMAKEHR(0x1B28) // GenericParam has duplicate by owner and name.
#define VLDTR_E_GP_DUPNUMBER            EMAKEHR(0x1B29) // GenericParam has duplicate by owner and number.
#define VLDTR_E_GP_NONSEQ_BY_OWNER      EMAKEHR(0x1B2A) // GenericParam is non sequential by owner
#define VLDTR_E_GP_NONSEQ_BY_NUMBER     EMAKEHR(0x1B2B) // GenericParam is non sequential by number
#define VLDTR_E_GP_UNEXPECTED_OWNER_FOR_VARIANT_VAR EMAKEHR(0x1B2C) // GenericParam has variance but its owner is not an interface or delegate
#define VLDTR_E_GP_ILLEGAL_VARIANT_MVAR  EMAKEHR(0x1B2D) // GenericParam is a method type parameter and must be non-variant
#define VLDTR_E_GP_ILLEGAL_VARIANCE_FLAGS  EMAKEHR(0x1B2E) // GenericParam has illegal value for variance flags
#define VLDTR_E_GP_REFANDVALUETYPE      EMAKEHR(0x1B2F) // GenericParam has incompatible special constraints reference type and valuetype
#define VLDTR_E_GPC_OWNERNIL            EMAKEHR(0x1B30) // GenericParamConstraint has nil owner
#define VLDTR_E_GPC_DUP                 EMAKEHR(0x1B31) // GenericParamConstraint has duplicate by owner and constraint
#define VLDTR_E_GPC_NONCONTIGUOUS       EMAKEHR(0x1B32) // GenericParamConstraint is non-contiguous with preceeding constraints for same owner
#define VLDTR_E_MS_METHODNIL            EMAKEHR(0x1B33)  // MethodSpec has nil method
#define VLDTR_E_MS_DUP                  EMAKEHR(0x1B34)  // MethodSpec has duplicate based own method and instantiation
#define VLDTR_E_MS_BADCALLINGCONV       EMAKEHR(0x1B35)  // MethodSpec signature has invalid calling convention
#define VLDTR_E_MS_MISSARITY            EMAKEHR(0x1B36)    // MethodSpec signature is missing arity specification
#define VLDTR_E_MS_MISSARG              EMAKEHR(0x1B37)    // MethodSpec signature is missing type argument
#define VLDTR_E_MS_ARITYMISMATCH        EMAKEHR(0x1B38)    // MethodSpec arity of generic method and instantiation do not match
#define VLDTR_E_MS_METHODNOTGENERIC     EMAKEHR(0x1B39)    // MethodSpec method is not generic
#define VLDTR_E_SIG_MISSARITY           EMAKEHR(0x1B3A)    // Signature missing arity of instantiated generic type
#define VLDTR_E_SIG_ARITYMISMATCH       EMAKEHR(0x1B3B)    // Signature has generic type of arity instantiated at different arity
#define VLDTR_E_MD_GENERIC_CCTOR        EMAKEHR(0x1B3C)    // Method cannot be both generic and a class constructor
#define VLDTR_E_MD_GENERIC_CTOR         EMAKEHR(0x1B3D)    // Method cannot be both generic and an instance constructor
#define VLDTR_E_MD_GENERIC_IMPORT       EMAKEHR(0x1B3E)    // Method cannot be both generic and defined on an imported type
#define VLDTR_E_MD_GENERIC_BADCALLCONV  EMAKEHR(0x1B3F)    // Method cannot be both generic and have non-default calling convention
#define VLDTR_E_EP_GENERIC_METHOD       EMAKEHR(0x1B40)    // Entry point in CLR header is the token for a generic method
#define VLDTR_E_MD_MISSARITY            EMAKEHR(0x1B41)    // Method signature is generic but is missing its arity
#define VLDTR_E_MD_ARITYZERO            EMAKEHR(0x1B42)    // Method signature is generic but its arity is zero
#define VLDTR_E_SIG_ARITYZERO           EMAKEHR(0x1B43)    // Signature has generic type instantiated at arity 0
#define VLDTR_E_MS_ARITYZERO            EMAKEHR(0x1B44)    // MethodSpec signature has arity 0
#define VLDTR_E_MD_GPMISMATCH           EMAKEHR(0x1B45)    // MethodDef signature has arity n but owns m GenericParams
#define VLDTR_E_EP_GENERIC_TYPE         EMAKEHR(0x1B46)    // Entry point in CLR header is the token for a method in a generic type
#define VLDTR_E_MI_DECLNOTGENERIC       EMAKEHR(0x1B47)    // MethodImpl overrides non-generic method with generic method
#define VLDTR_E_MI_IMPLNOTGENERIC       EMAKEHR(0x1B48)    // MethodImpl overrides non-generic method with generic method
#define VLDTR_E_MI_ARITYMISMATCH        EMAKEHR(0x1B49)    // MethodImpl overrides generic method of arity n with generic method of arity m
#define VLDTR_E_TD_EXTBADTYPESPEC       EMAKEHR(0x1B4A)    // TypeDef extends a TypeSpec that is not an instantiated type
#define VLDTR_E_SIG_BYREFINST           EMAKEHR(0x1B4B)    // Signature has type instantiated at byref at offset i
#define VLDTR_E_MS_BYREFINST            EMAKEHR(0x1B4C)    // Signature has type instantiated at byref at offset i
#define VLDTR_E_TS_EMPTY                EMAKEHR(0x1B4D)    // TypeSpec has empty signature
#define VLDTR_E_TS_HASSENTINALS         EMAKEHR(0x1B4E)    // TypeSpec has signature containing one or more sentinals
#define VLDTR_E_TD_GENERICHASEXPLAYOUT  EMAKEHR(0x1B4F)    // TypeDef is generic but has explicit layout
#define VLDTR_E_SIG_BADTOKTYPE          EMAKEHR(0x1B50)    // Signature has token following ELEMENT_TYPE_CLASS (_VALUETYPE) that is not a TypeDef or TypeRef
#define VLDTR_E_IFACE_METHNOTIMPLTHISMOD EMAKEHR(0x1B51)   // Warn:Class doesn't implement interface method in this module

//**** Common Language Runtime Debugging Services errors
#define CORDBG_E_UNRECOVERABLE_ERROR                    EMAKEHR(0x1300) // Unrecoverable API error.
#define CORDBG_E_PROCESS_TERMINATED                     EMAKEHR(0x1301) // Process was terminated.
#define CORDBG_E_PROCESS_NOT_SYNCHRONIZED               EMAKEHR(0x1302) // Process not synchronized.
#define CORDBG_E_CLASS_NOT_LOADED                       EMAKEHR(0x1303) // A class is not loaded.
#define CORDBG_E_IL_VAR_NOT_AVAILABLE                   EMAKEHR(0x1304) // An IL variable is not available at the
                                                                        // current native IP.
#define CORDBG_E_BAD_REFERENCE_VALUE                    EMAKEHR(0x1305) // A reference value was found to be bad
                                                                        // during dereferencing.
#define CORDBG_E_FIELD_NOT_AVAILABLE                    EMAKEHR(0x1306) // A field in a class is not available,
                                                                        // because the runtime optimized it away.
#define CORDBG_E_NON_NATIVE_FRAME                       EMAKEHR(0x1307) // "Native frame only" operation on
                                                                        // non-native frame
#define CORDBG_E_NONCONTINUABLE_EXCEPTION               EMAKEHR(0x1308) // Continue on non-continuable exception
#define CORDBG_E_CODE_NOT_AVAILABLE                     EMAKEHR(0x1309) // The code is currently unavailable
#define CORDBG_E_FUNCTION_NOT_IL                        EMAKEHR(0x130A) // Attempt to get a ICorDebugFunction for
                                                                        // a function that is not IL.
#define CORDBG_S_BAD_START_SEQUENCE_POINT               SMAKEHR(0x130B) // Attempt to SetIP not at a sequence point
#define CORDBG_S_BAD_END_SEQUENCE_POINT                 SMAKEHR(0x130C) // Attempt to SetIP when not going to a
                                                                        // sequence point.  If both this and
                                                                        // CORDBG_E_BAD_START_SEQUENCE_POINT are
                                                                        // true, only CORDBG_E_BAD_START_SEQUENCE_POINT
                                                                        // will be reported.
#define CORDBG_S_INSUFFICIENT_INFO_FOR_SET_IP           SMAKEHR(0x130D) // SetIP is possible, but the debugger doesn't
                                                                        // have enough info to fix variable locations,
                                                                        // GC refs, or anything else. Use at your own
                                                                        // risk.
#define CORDBG_E_CANT_SET_IP_INTO_FINALLY               EMAKEHR(0x130E) // SetIP isn't possible, because SetIP would
                                                                        // move EIP from outside of an exception
                                                                        // handling finally clause to a point inside
                                                                        // of one.
#define CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY             EMAKEHR(0x130F) // SetIP isn't possible because it would move
                                                                        // EIP from within an exception handling finally
                                                                        // clause to a point outside of one.
#define CORDBG_E_CANT_SET_IP_INTO_CATCH                 EMAKEHR(0x1310) // SetIP isn't possible, because SetIP would
                                                                        // move EIP from outside of an exception
                                                                        // handling catch clause to a point inside of
                                                                        // one.
#define CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME    EMAKEHR(0x1311) // Setip cannot be done on any frame except
                                                                        // the leaf frame.
#define CORDBG_E_SET_IP_IMPOSSIBLE                      EMAKEHR(0x1312) // SetIP isn't allowed. For example, there is
                                                                        // insufficient memory to perform SetIP.
#define CORDBG_E_FUNC_EVAL_BAD_START_POINT              EMAKEHR(0x1313) // Func eval can't work if we're, for example,
                                                                        // not stopped at a GC safe point.
#define CORDBG_E_INVALID_OBJECT                         EMAKEHR(0x1314) // This object value is no longer valid.
#define CORDBG_E_FUNC_EVAL_NOT_COMPLETE                 EMAKEHR(0x1315) // If you call CordbEval::GetResult before the
                                                                        // func eval has finished, you'll get this
                                                                        // result.
#define CORDBG_S_FUNC_EVAL_HAS_NO_RESULT                SMAKEHR(0x1316) // Some Func evals will lack a return value,
                                                                        // such as those whose return type is void.
#define CORDBG_S_VALUE_POINTS_TO_VOID                   SMAKEHR(0x1317) // The Debugging API doesn't support
                                                                        // dereferencing pointers of type void.
#define CORDBG_E_INPROC_NOT_IMPL                        EMAKEHR(0x1318) // The inproc version of the debugging API
                                                                        // doesn't implement this function,
#define CORDBG_S_FUNC_EVAL_ABORTED                      SMAKEHR(0x1319) // The func eval completed, but was aborted.
#define CORDBG_E_STATIC_VAR_NOT_AVAILABLE               EMAKEHR(0x131A) // A static variable isn't available because
                                                                        // it hasn't been initialized yet.
#define CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS     EMAKEHR(0x131B) // Can't copy a VC with object refs in it.
#define CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER       EMAKEHR(0x131C) // SetIP can't leave or enter a filter
#define CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE EMAKEHR(0x131D) // You can't change JIT settings for ZAP
                                                                        // modules.
#define CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY_ON_WIN64    EMAKEHR(0x131E) // SetIP isn't possible because it would move
                                                                        // EIP from within a finally clause to a point
                                                                        // outside of one on WIN64 platforms.
#define CORDBG_E_CANT_SET_IP_OUT_OF_CATCH_ON_WIN64      EMAKEHR(0x131F) // SetIP isn't possible because it would move
                                                                        // EIP from within a catch clause to a point
                                                                        // outside of one on WIN64 platforms.

#define CORDBG_E_REMOTE_CONNECTION_CONN_RESET           EMAKEHR(0x1320) // The remote device closed the connection.
#define CORDBG_E_REMOTE_CONNECTION_KEEP_ALIVE           EMAKEHR(0x1321) // The connection was closed due to akeep alive failure.
#define CORDBG_E_REMOTE_CONNECTION_FATAL_ERROR          EMAKEHR(0x1322) // Generic error that the device connection has been broken with no chance for recovery.

#define CORDBG_E_CANT_SET_TO_JMC                        EMAKEHR(0x1323) // Can't use JMC on this code (likely wrong jit settings).

#define CORDBG_E_BAD_THREAD_STATE                       EMAKEHR(0x132d) // The state of the thread is invalid.
#define CORDBG_E_DEBUGGER_ALREADY_ATTACHED              EMAKEHR(0x132e) // This process has already been attached to
#define CORDBG_E_SUPERFLOUS_CONTINUE                    EMAKEHR(0x132f) // Returned from a call to Continue that was
                                                                        // Not matched with a stopping event.
#define CORDBG_E_SET_VALUE_NOT_ALLOWED_ON_NONLEAF_FRAME EMAKEHR(0x1330) // Can't perfrom SetValue on non-leaf frames.
#define CORDBG_E_ENC_EH_MAX_NESTING_LEVEL_CANT_INCREASE EMAKEHR(0x1331) // When doing EnC, some JITters don't let you
                                                                        // increase the maximum level to which
                                                                        // exception handling can be nested.
#define CORDBG_E_ENC_MODULE_NOT_ENC_ENABLED             EMAKEHR(0x1332) // Tried to do EnC on a module that wasn't
                                                                        // started in EnC mode.
#define CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION        EMAKEHR(0x1333) // Setip cannot be done on any exception
#define CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL           EMAKEHR(0x1334) // The 'variable' doesn't exist because it is a
                                                                        // literal optimized away by the compiler - ask
                                                                        // Metadata for it's default value, instead.
#define CORDBG_E_PROCESS_DETACHED                       EMAKEHR(0x1335) // Process has been detached from
#define CORDBG_E_ENC_METHOD_SIG_CHANGED                 EMAKEHR(0x1336) // Not allowed to change the signature of an
                                                                        // existing method - compiler should make new method
                                                                        // instead.
#define CORDBG_E_ENC_METHOD_NO_LOCAL_SIG                EMAKEHR(0x1337) // Can't get the local signature for the method
                                                                        // we're trying to EnC.
#define CORDBG_E_ENC_CANT_ADD_FIELD_TO_VALUE_OR_LAYOUT_CLASS EMAKEHR(0x1338) // Adding a field to a value or layout class is prohibitted,
                                                                        // since we can't guarantee the new field is contiguous to
                                                                        // VC's on the stack, embedded in other objects, etc.
#define CORDBG_E_ENC_CANT_CHANGE_FIELD                  EMAKEHR(0x1339) // Once you've got a field, you're not allowed to change
                                                                        // it, since that would change the size of the type it belongs to.
#define CORDBG_E_ENC_CANT_ADD_NON_PRIVATE_MEMBER        EMAKEHR(0x133A) // Only support addition of private members.
#define CORDBG_E_FIELD_NOT_STATIC                       EMAKEHR(0x133B) // Returned if someone tries to call GetStaticFieldValue
                                                                        // on a non-static field
#define CORDBG_E_FIELD_NOT_INSTANCE                     EMAKEHR(0x133C) // Returned if someone tries to call GetStaticFieldValue
                                                                        // on a non-instance field
#define CORDBG_E_ENC_ZAPPED_WITHOUT_ENC                 EMAKEHR(0x133D) // If a zap file was created without the EnC flag set, then
                                                                        // we can't do EnC on it, no matter what.
#define CORDBG_E_ENC_BAD_METHOD_INFO                    EMAKEHR(0x133E) // Lacking information about method.
#define CORDBG_E_ENC_JIT_CANT_UPDATE                    EMAKEHR(0x133F) // The JIT is unable to update the method.
#define CORDBG_E_ENC_MISSING_CLASS                      EMAKEHR(0x1340) // An internal structure about the class is missing
#define CORDBG_E_ENC_INTERNAL_ERROR                     EMAKEHR(0x1341) // Generic message for "Something user doesn't control went wrong" message.
#define CORDBG_E_ENC_HANGING_FIELD                      EMAKEHR(0x1342) // The field was added via enc after the class was loaded, and so instead of
                                                                        // the field being contiguous with the other fields, it's 'hanging' off the
                                                                        // instance, so the right side will have to go & get (instance-specific
                                                                        // info based on the particular object.
#define CORDBG_E_MODULE_NOT_LOADED                      EMAKEHR(0x1343) // If the module isn't loaded, including if it's been unloaded.

#define CORDBG_E_ENC_CANT_CHANGE_SUPERCLASS             EMAKEHR(0x1344) // Not allowed to change which class something inherits from
#define CORDBG_E_UNABLE_TO_SET_BREAKPOINT               EMAKEHR(0x1345) // Can't set a breakpoint here.
#define CORDBG_E_DEBUGGING_NOT_POSSIBLE                 EMAKEHR(0x1346) // Debugging isn't possible due to an incompatability within the CLR implementation.
#define CORDBG_E_KERNEL_DEBUGGER_ENABLED                EMAKEHR(0x1347) // Debugging isn't possible because a kernel debugger is enabled on the system.
#define CORDBG_E_KERNEL_DEBUGGER_PRESENT                EMAKEHR(0x1348) // Debugging isn't possible because a kernel debugger is present on the system.
#define CORDBG_E_HELPER_THREAD_DEAD                     EMAKEHR(0x1349) // The debugger's internal helper thread is dead.
#define CORDBG_E_INTERFACE_INHERITANCE_CANT_CHANGE      EMAKEHR(0x134A) // Not allowed to change interface inheritance.
#define CORDBG_E_INCOMPATIBLE_PROTOCOL                  EMAKEHR(0x134B) // The debugger's protocol is incompatible with the debuggee.
#define CORDBG_E_TOO_MANY_PROCESSES                     EMAKEHR(0x134C) // The debugger can only handle a finite number of debuggees.
#define CORDBG_E_INTEROP_NOT_SUPPORTED                  EMAKEHR(0x134D) // Interop is not allowed on a win9x platform
#define CORDBG_E_NO_REMAP_BREAKPIONT                    EMAKEHR(0x134E) // Cannot call RemapFunction until have received RemapBreakpoint
#define CORDBG_E_OBJECT_NEUTERED                        EMAKEHR(0x134F) // Object has been neutered (it's in a zombie state).
// NOTE!  YOU CANNOT PUT MORE ERRORS HERE!  They run into the range for profiling errors.  All new
// new error need to be added below (search for cordbg_e_ in your editor).

//**** Common Language Runtime Profiling Services errors
#define CORPROF_E_FUNCTION_NOT_COMPILED EMAKEHR(0x1350)     // Function not yet compiled.
#define CORPROF_E_DATAINCOMPLETE        EMAKEHR(0x1351)     // The ID is not fully loaded/defined yet.
#define CORPROF_E_NOT_REJITABLE_METHODS EMAKEHR(0x1352)     // The Module is not configured for updateable methods.
#define CORPROF_E_CANNOT_UPDATE_METHOD  EMAKEHR(0x1353)     // The Method could not be updated for re-jit.
#define CORPROF_E_FUNCTION_NOT_IL       EMAKEHR(0x1354)     // The Method has no associated IL
#define CORPROF_E_NOT_MANAGED_THREAD    EMAKEHR(0x1355)     // The thread has never run managed code before
#define CORPROF_E_CALL_ONLY_FROM_INIT   EMAKEHR(0x1356)     // The function may only be called during profiler init
#define CORPROF_E_INPROC_NOT_ENABLED    EMAKEHR(0x1357)     // Inprocess debugging must be enabled during init
                                                            // Also returned when BeginInprocDebugging not called
                                                            // before using the inprocess debugging services
#define CORPROF_E_JITMAPS_NOT_ENABLED   EMAKEHR(0x1358)     // Can't get a JIT map becuase they are not enabled
#define CORPROF_E_INPROC_ALREADY_BEGUN  EMAKEHR(0x1359)     // If a profiler tries to call BeginInprocDebugging more than
                                                            // once, it will get this error.
#define CORPROF_E_INPROC_NOT_AVAILABLE  EMAKEHR(0x135A)     // States that inprocess debugging not allowed at this point
                                                            // (for example during GC callbacks or RuntimeSuspention callbacks
#define CORPROF_E_NOT_YET_AVAILABLE     EMAKEHR(0x135B)     // This is a general error used to indicated that the information
                                                            // requested is not yet available
#define CORPROF_E_TYPE_IS_PARAMETERIZED EMAKEHR(0x135C)     // The given type is a generic and cannot be used with this method.
#define CORPROF_E_FUNCTION_IS_PARAMETERIZED EMAKEHR(0x135D) // The given function is a generic and cannot be used with this method.
#define CORPROF_E_STACKSNAPSHOT_INVALID_TGT_THREAD EMAKEHR(0x135E) // A profiler tried to walk the stack of an invalid thread
#define CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX        EMAKEHR(0x135F) // A profiler can not walk a thread that is currently executing unmanaged code
#define CORPROF_E_STACKSNAPSHOT_UNSAFE  EMAKEHR(0x1360)     // A stackwalk at this point may cause dead locks or data corruption
#define CORPROF_E_STACKSNAPSHOT_ABORTED EMAKEHR(0x1361)     // Stackwalking callback requested the walk to abort
#define CORPROF_E_LITERALS_HAVE_NO_ADDRESS EMAKEHR(0x1362)  // Returned when asked for the address of a static that is a literal.
#define CORPROF_E_UNSUPPORTED_CALL_SEQUENCE EMAKEHR(0x1363) // A call was made at an unsupported time (e.g., API illegally called asynchronously)
#define CORPROF_E_ASYNCHRONOUS_UNSAFE           EMAKEHR(0x1364) // A legal asynchronous call was made at an unsafe time (e.g., CLR locks are held) 
#define CORPROF_E_CLASSID_IS_ARRAY                      EMAKEHR(0x1365) // The specified ClassID cannot be inspected by this function because it is an array
#define CORPROF_E_CLASSID_IS_COMPOSITE              EMAKEHR(0x1366) // The specified ClassID is a non-array composite type (e.g., ref) and cannot be inspected


//**** Security errors
#define SECURITY_E_XML_TO_ASN_ENCODING  EMAKEHR(0x1400)     // Failed to convert XML to ASN
#define SECURITY_E_INCOMPATIBLE_SHARE   EMAKEHR(0x1401)     // Loading this assembly would produce a different grant set from other instances
#define SECURITY_E_UNVERIFIABLE         EMAKEHR(0x1402)     // Unverifable code failed policy check
#define SECURITY_E_INCOMPATIBLE_EVIDENCE EMAKEHR(0x1403)     // Assembly already loaded without additional security evidence.

//**** Reserved.
#define CLDB_E_INTERNALERROR            EMAKEHR(0x1fff)

// ******************
// Debugger & Profiler errors
// ******************


// ******************
// Security errors
// ******************

#define CORSEC_E_DECODE_SET             EMAKEHR(0x1410)         // Failure decoding permission set
#define CORSEC_E_ENCODE_SET             EMAKEHR(0x1411)         // Failure encoding permission set
#define CORSEC_E_UNSUPPORTED_FORMAT     EMAKEHR(0x1412)         // Unrecognized encoding format
#define SN_CRYPTOAPI_CALL_FAILED        EMAKEHR(0x1413)         // StrongName APIs not supported on system
#define CORSEC_E_CRYPTOAPI_CALL_FAILED  EMAKEHR(0x1413)         // StrongName APIs not supported on system
#define SN_NO_SUITABLE_CSP              EMAKEHR(0x1414)         // StrongName APIs couldn't locate a matching CSP
#define CORSEC_E_NO_SUITABLE_CSP        EMAKEHR(0x1414)         // StrongName APIs couldn't locate a matching CSP
#define CORSEC_E_INVALID_ATTR           EMAKEHR(0x1415)         // Invalid security custom attribute
#define CORSEC_E_POLICY_EXCEPTION       EMAKEHR(0x1416)         // PolicyException thrown
#define CORSEC_E_MIN_GRANT_FAIL         EMAKEHR(0x1417)         // Failed to grant minimum permission requests
#define CORSEC_E_NO_EXEC_PERM           EMAKEHR(0x1418)         // Failed to grant permission to execute
#define CORSEC_E_XMLSYNTAX              EMAKEHR(0x1419)         // XML Syntax error
#define CORSEC_E_INVALID_STRONGNAME     EMAKEHR(0x141a)         // Strong name validation failed
#define CORSEC_E_MISSING_STRONGNAME     EMAKEHR(0x141b)         // Assembly is not strong named
#define CORSEC_E_CONTAINER_NOT_FOUND    EMAKEHR(0x141c)         // Strong name key container not found
#define CORSEC_E_INVALID_IMAGE_FORMAT   EMAKEHR(0x141d)         // Invalid assembly file format
#define CORSEC_E_INVALID_PUBLICKEY      EMAKEHR(0x141e)         // Invalid assembly public key
#define CORSEC_E_SIGNATURE_MISMATCH     EMAKEHR(0x1420)         // Signature size mismatch

//**** crypto errors 1430 -- 1439
#define CORSEC_E_CRYPTO                 EMAKEHR(0x1430)         // generic CryptographicException
#define CORSEC_E_CRYPTO_UNEX_OPER       EMAKEHR(0x1431)         // generic CryptographicUnexpectedOperationException

//**** security custom attribute errors 143a -- 144f
#define CORSECATTR_E_BAD_ATTRIBUTE              EMAKEHR(0x143a) // Generic problem with a custom attribute
#define CORSECATTR_E_MISSING_CONSTRUCTOR        EMAKEHR(0x143b) // Missing a required constructor
#define CORSECATTR_E_FAILED_TO_CREATE_PERM      EMAKEHR(0x143c) // Unable to create a permission for this attribute
#define CORSECATTR_E_BAD_ACTION_ASM             EMAKEHR(0x143d) // SecurityAction type invalid on assembly
#define CORSECATTR_E_BAD_ACTION_OTHER           EMAKEHR(0x143e) // SecurityAction type invalid on types and methods
#define CORSECATTR_E_BAD_PARENT                 EMAKEHR(0x143f) // Security custom attribute attached to invalid parent
#define CORSECATTR_E_TRUNCATED                  EMAKEHR(0x1440) // Bad custom attribute serialized blob
#define CORSECATTR_E_BAD_VERSION                EMAKEHR(0x1441) // Bad custom attribute serialized blob version
#define CORSECATTR_E_BAD_ACTION                 EMAKEHR(0x1442) // Invalid security action code
#define CORSECATTR_E_NO_SELF_REF                EMAKEHR(0x1443) // CA ref to CA def'd in same assembly
#define CORSECATTR_E_BAD_NONCAS                 EMAKEHR(0x1444) // Use of non-CAS perm with invalid action
#define CORSECATTR_E_ASSEMBLY_LOAD_FAILED       EMAKEHR(0x1445) // Failed to load assembly containing CA (or req'd CA type)
#define CORSECATTR_E_ASSEMBLY_LOAD_FAILED_EX    EMAKEHR(0x1446) // Failed to load assembly containing CA (or req'd CA type)
#define CORSECATTR_E_TYPE_LOAD_FAILED           EMAKEHR(0x1447) // Failed to load CA type (or reqd CA type)
#define CORSECATTR_E_TYPE_LOAD_FAILED_EX        EMAKEHR(0x1448) // Failed to load CA type (or reqd CA type)
#define CORSECATTR_E_ABSTRACT                   EMAKEHR(0x1449) // CA type is abstract
#define CORSECATTR_E_UNSUPPORTED_TYPE           EMAKEHR(0x144a) // Unsupported type for field/property setter
#define CORSECATTR_E_UNSUPPORTED_ENUM_TYPE      EMAKEHR(0x144b) // Unsupported base type for enum field/property
#define CORSECATTR_E_NO_FIELD                   EMAKEHR(0x144c) // Couldn't find a CA field
#define CORSECATTR_E_NO_PROPERTY                EMAKEHR(0x144d) // Couldn't find a CA property
#define CORSECATTR_E_EXCEPTION                  EMAKEHR(0x144e) // Unexpected exception
#define CORSECATTR_E_EXCEPTION_HR               EMAKEHR(0x144f) // Unexpected exception


//**** Isolated Storage Errors 1450 - 14FF
#define ISS_E_ISOSTORE                   EMAKEHR(0x1450L)

#define ISS_E_OPEN_STORE_FILE            EMAKEHR(0x1460L)
#define ISS_E_OPEN_FILE_MAPPING          EMAKEHR(0x1461L)
#define ISS_E_MAP_VIEW_OF_FILE           EMAKEHR(0x1462L)
#define ISS_E_GET_FILE_SIZE              EMAKEHR(0x1463L)
#define ISS_E_CREATE_MUTEX               EMAKEHR(0x1464L)
#define ISS_E_LOCK_FAILED                EMAKEHR(0x1465L)
#define ISS_E_FILE_WRITE                 EMAKEHR(0x1466L)
#define ISS_E_SET_FILE_POINTER           EMAKEHR(0x1467L)
#define ISS_E_CREATE_DIR                 EMAKEHR(0x1468L)
#define ISS_E_STORE_NOT_OPEN             EMAKEHR(0x1469L)

#define ISS_E_CORRUPTED_STORE_FILE       EMAKEHR(0x1480L)
#define ISS_E_STORE_VERSION              EMAKEHR(0x1481L)
#define ISS_E_FILE_NOT_MAPPED            EMAKEHR(0x1482L)
#define ISS_E_BLOCK_SIZE_TOO_SMALL       EMAKEHR(0x1483L)
#define ISS_E_ALLOC_TOO_LARGE            EMAKEHR(0x1484L)
#define ISS_E_USAGE_WILL_EXCEED_QUOTA    EMAKEHR(0x1485L)
#define ISS_E_TABLE_ROW_NOT_FOUND        EMAKEHR(0x1486L)

#define ISS_E_DEPRECATE                  EMAKEHR(0x14A0L)
#define ISS_E_CALLER                     EMAKEHR(0x14A1L)
#define ISS_E_PATH_LENGTH                EMAKEHR(0x14A2L)
#define ISS_E_MACHINE                    EMAKEHR(0x14A3L)
#define ISS_E_MACHINE_DACL               EMAKEHR(0x14A4L)

#define ISS_E_ISOSTORE_START             EMAKEHR(0x1450L)
#define ISS_E_ISOSTORE_END               EMAKEHR(0x14FFL)

// ******************
// Classlib errors
// ******************


//
// MessageId: COR_E_APPLICATION
//
// MessageText:
//
// The base class for all "less serious" exceptions.
//
#define COR_E_APPLICATION  EMAKEHR(0x1600L)


//
// MessageId: COR_E_ARGUMENT
//
// MessageText:
//
// An argument does not meet the contract of the method.
//
#define COR_E_ARGUMENT  E_INVALIDARG        // 0x80070057


//
// MessageId: COR_E_ARGUMENTOUTOFRANGE
//
// MessageText:
//
// An argument was out of its legal range.
//
#define COR_E_ARGUMENTOUTOFRANGE  EMAKEHR(0x1502L)


//
// MessageId: COR_E_ARITHMETIC
//
// MessageText:
//
// Overflow or underflow in mathematical operations.
//
#define COR_E_ARITHMETIC  HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW)     // 0x80070216


//
// MessageId: COR_E_ARRAYTYPEMISMATCH
//
// MessageText:
//
// Attempted to store an object of the wrong type in an array
//
#define COR_E_ARRAYTYPEMISMATCH  EMAKEHR(0x1503L)


//
// MessageId: COR_E_CONTEXTMARSHAL
//
// MessageText:
//
//
//
#define COR_E_CONTEXTMARSHAL  EMAKEHR(0x1504L)


//
// MessageId: COR_E_TIMEOUT
//
// MessageText:
//
//
//
#define COR_E_TIMEOUT  EMAKEHR(0x1505L)


//
// MessageId: COR_E_KEYNOTFOUND
//
// MessageText:
//
//
//
#define COR_E_KEYNOTFOUND  EMAKEHR(0x1577L)



//
// MessageId: COR_E_DEVICESNOTSUPPORTED
//
// MessageText:
//
//
//
#define COR_E_DEVICESNOTSUPPORTED  EMAKEHR(0x1540L)

//
// MessageId: COR_E_DIVIDEBYZERO
//
// MessageText:
//
// Attempted to divide a number by zero.
//
#define COR_E_DIVIDEBYZERO  _HRESULT_TYPEDEF_(0x80020012L) // DISP_E_DIVBYZERO


//
// MessageId: COR_E_EXCEPTION
//
// MessageText:
//
// Base class for all exceptions in the runtime
//
#define COR_E_EXCEPTION  EMAKEHR(0x1500L)


//
// MessageId: COR_E_EXECUTIONENGINE
//
// MessageText:
//
// An internal error happened in the Common Language Runtime's Execution Engine
//
#define COR_E_EXECUTIONENGINE  EMAKEHR(0x1506L)


//
// MessageId: COR_E_FIELDACCESS
//
// MessageText:
//
// Access to this field is denied.
//
#define COR_E_FIELDACCESS  EMAKEHR(0x1507L)


//
// MessageId: COR_E_FORMAT
//
// MessageText:
//
// The format of one arguments does not meet the contract of the method.
//
#define COR_E_FORMAT  EMAKEHR(0x1537L)


//
// MessageId: COR_E_BADIMAGEFORMAT
//
// MessageText:
//
// The format of DLL or executable being loaded is invalid.
//
#define COR_E_BADIMAGEFORMAT  _HRESULT_TYPEDEF_(0x8007000BL)


//
// MessageId: COR_E_ASSEMBLYEXPECTED
//
// MessageText:
//
// The module was expected to contain an assembly manifest.
//
#define COR_E_ASSEMBLYEXPECTED  EMAKEHR(0x1018L)

//
// MessageId: COR_E_TYPEUNLOADED
//
// MessageText:
//
// The type had been unloaded.
//
#define COR_E_TYPEUNLOADED   EMAKEHR(0x1013L)

//
// MessageId: COR_E_INDEXOUTOFRANGE
//
// MessageText:
//
// Attempted to access an element within an array by using an index that is
// not within the bound of that array.
//
#define COR_E_INDEXOUTOFRANGE  EMAKEHR(0x1508L)


//
// MessageId: COR_E_INSUFFICIENTMEMORY
//
// MessageText:
//
// Not enough memory was available for an operation.
// This may not be potentially fatal (vs. an OutOfMemoryException).
//
#define COR_E_INSUFFICIENTMEMORY  EMAKEHR(0x153DL)


//
// MessageId: COR_E_RUNTIMEWRAPPED
//
// MessageText:
//
// An object that does not derive from System.Exception has been wrapped in a RuntimeWrappedException.
//
#define COR_E_RUNTIMEWRAPPED  EMAKEHR(0x153EL)


//
// MessageId: COR_E_INVALIDCAST
//
// MessageText:
//
// Indicates a bad cast condition
//
#define COR_E_INVALIDCAST  E_NOINTERFACE        // 0x80004002


//
// MessageId: COR_E_INVALIDOPERATION
//
// MessageText:
//
// An operation is not legal in the current state.
//
#define COR_E_INVALIDOPERATION  EMAKEHR(0x1509L)


//
// MessageId: COR_E_INVALIDPROGRAM
//
// MessageText:
//
// A program contained invalid IL or bad metadata.  Usually this is a compiler bug.
//
#define COR_E_INVALIDPROGRAM  EMAKEHR(0x153AL)


//
// MessageId: COR_E_MEMBERACCESS
//
// MessageText:
//
// Access to this member is denied.
//
#define COR_E_MEMBERACCESS  EMAKEHR(0x151AL)


//
// MessageId: COR_E_METHODACCESS
//
// MessageText:
//
// Access to this method is denied.
//
#define COR_E_METHODACCESS  EMAKEHR(0x1510L)


//
// MessageId: COR_E_MISSINGFIELD
//
// MessageText:
//
// An attempt was made to dynamically access a field that does not exist.
//
#define COR_E_MISSINGFIELD  EMAKEHR(0x1511L)


//
// MessageId: COR_E_MISSINGMANIFESTRESOURCE
//
// MessageText:
//
// An expected resource in the assembly manifest was missing.
//
#define COR_E_MISSINGMANIFESTRESOURCE  EMAKEHR(0x1532L)


//
// MessageId: COR_E_MISSINGMEMBER
//
// MessageText:
//
// An attempt was made to dynamically invoke or access a field or method
// that does not exist.
//
#define COR_E_MISSINGMEMBER  EMAKEHR(0x1512L)


//
// MessageId: COR_E_MISSINGMETHOD
//
// MessageText:
//
// An attempt was made to dynamically invoke a method that does not exist
//
#define COR_E_MISSINGMETHOD  EMAKEHR(0x1513L)


//
// MessageId: COR_E_MISSINGSATELLITEASSEMBLY
//
// MessageText:
//
// An expected satellite assembly containing the ultimate fallback resources
// for a given culture was not found or couldn't be loaded.  Setup problem?
//
#define COR_E_MISSINGSATELLITEASSEMBLY  EMAKEHR(0x1536L)


//
// MessageId: COR_E_MULTICASTNOTSUPPORTED
//
// MessageText:
//
// Attempted to combine delegates that are not multicast
//
#define COR_E_MULTICASTNOTSUPPORTED  EMAKEHR(0x1514L)


//
// MessageId: COR_E_NOTFINITENUMBER
//
// MessageText:
//
//  Thrown if value (a floating point number) is either the not a number value (NaN) or +- infinity value
//  VB needs this stuff
#define COR_E_NOTFINITENUMBER     EMAKEHR(0x1528L)


//
// MessageId: COR_E_DUPLICATEWAITOBJECT
//
// MessageText:
//
// An object appears more than once in the wait objects array.
//
#define COR_E_DUPLICATEWAITOBJECT   EMAKEHR(0x1529L)


//
// MessageId: COR_E_PLATFORMNOTSUPPORTED
//
// MessageText:
//
// The method is not supported on this platform
//
#define COR_E_PLATFORMNOTSUPPORTED  EMAKEHR(0x1539L)

//
// MessageId: COR_E_NOTSUPPORTED
//
// MessageText:
//
// The operation is not supported
//
#define COR_E_NOTSUPPORTED  EMAKEHR(0x1515L)

//
// MessageId: COR_E_NULLREFERENCE
//
// MessageText:
//
// Dereferencing a null reference. In general class libraries should not throw this
//
#define COR_E_NULLREFERENCE  E_POINTER      // 0x80004003


//
// MessageId: COR_E_OUTOFMEMORY
//
// MessageText:
//
// The EE thows this exception when no more memory is avaible to continue execution
//
#define COR_E_OUTOFMEMORY  E_OUTOFMEMORY        // 0x8007000E


//
// MessageId: COR_E_OVERFLOW
//
// MessageText:
//
// An arithmetic, casting, or conversion operation overflowed or underflowed.
//
#define COR_E_OVERFLOW  EMAKEHR(0x1516L)


//
// MessageId: COR_E_RANK
//
// MessageText:
//
// An array has the wrong number of dimensions for a particular operation.
//
#define COR_E_RANK  EMAKEHR(0x1517L)


//
// MessageId: COR_E_REMOTING
//
// MessageText:
//
// An error relating to remoting occurred.
//
#define COR_E_REMOTING  EMAKEHR(0x150BL)
#define COR_E_SERVER  EMAKEHR(0x150EL)

//
// MessageId: COR_E_SERVICEDCOMPONENT
//
// MessageText:
//
// An error relating to ServicedComponent occurred.
//
#define COR_E_SERVICEDCOMPONENT  EMAKEHR(0x150FL)


//
// MessageId: COR_E_SECURITY
//
// MessageText:
//
// An error relating to security occured.
//
#define COR_E_SECURITY  EMAKEHR(0x150AL)


//
// MessageID: COR_E_SERIALIZATION
//
// MessageText:
//
// An error relating to serialization has occurred.
//
#define COR_E_SERIALIZATION EMAKEHR(0x150CL)


//
// MessageId: COR_E_STACKOVERFLOW
//
// MessageText:
//
// Is raised by the EE when the execution stack overflows as it is attempting to ex
//
#define COR_E_STACKOVERFLOW  HRESULT_FROM_WIN32(ERROR_STACK_OVERFLOW)       // 0x800703E9


//
// MessageId: COR_E_SYNCHRONIZATIONLOCK
//
// MessageText:
//
// Wait(), Notify() or NotifyAll() was called from an unsynchronized ** block of c
//
#define COR_E_SYNCHRONIZATIONLOCK  EMAKEHR(0x1518L)


//
// MessageId: COR_E_SYSTEM
//
// MessageText:
//
// The base class for the runtime's "less serious" exceptions
//
#define COR_E_SYSTEM  EMAKEHR(0x1501L)


//
// MessageId: COR_E_THREADABORTED
//
// MessageText:
//
// Thrown into a thread to cause it to abort. Not catchable.
//
#define COR_E_THREADABORTED  EMAKEHR(0x1530L)


//
// MessageId: COR_E_OPERATIONCANCELED
//
// MessageText:
//
// The operation was cancelled.
//
#define COR_E_OPERATIONCANCELED EMAKEHR(0x153BL)


//
// MessageId: COR_E_THREADINTERRUPTED
//
// MessageText:
//
// Indicates that the thread was interrupted from a waiting state
//
#define COR_E_THREADINTERRUPTED  EMAKEHR(0x1519L)


//
// MessageId: COR_E_THREADSTATE
//
// MessageText:
//
// Indicate that the Thread class is in an invalid state for the method call
//
#define COR_E_THREADSTATE  EMAKEHR(0x1520L)


//
// MessageId: COR_E_THREADSTOP
//
// MessageText:
//
// Thrown into a thread to cause it to stop. This exception is typically not caught
//
#define COR_E_THREADSTOP  EMAKEHR(0x1521L)


//
// MessageId: COR_E_THREADSTART
//
// MessageText:
//
// Indicate that a user thread fails to start.
//
#define COR_E_THREADSTART  EMAKEHR(0x1525L)


//
// MessageId: COR_E_TYPEINITIALIZATION
//
// MessageText:
//
// An exception was thrown by a type's initializer (.cctor).
//
#define COR_E_TYPEINITIALIZATION  EMAKEHR(0x1534L)


//
// MessageId: COR_E_TYPELOAD
//
// MessageText:
//
// Could not find or load a specific type (class, enum, etc).
//
#define COR_E_TYPELOAD  EMAKEHR(0x1522L)


//
// MessageId: COR_E_ENTRYPOINTNOTFOUND
//
// MessageText:
//
// Could not find the specified DllImport entry point
//
#define COR_E_ENTRYPOINTNOTFOUND  EMAKEHR(0x1523L)


//
// MessageId: COR_E_DLLNOTFOUND
//
// MessageText:
//
// Could not find the specified DllImport DLL.
//
#define COR_E_DLLNOTFOUND  EMAKEHR(0x1524L)


//
// MessageId: COR_E_UNAUTHORIZEDACCESS
//
// MessageText:
//
// Access is denied.
//
#define COR_E_UNAUTHORIZEDACCESS  E_ACCESSDENIED    // 0x80070005


//
// MessageId: COR_E_VERIFICATION
//
// MessageText:
//
// A verification failure occurred
//
#define COR_E_VERIFICATION  EMAKEHR(0x150DL)


//
// MessageId: COR_E_INVALIDCOMOBJECT
//
// MessageText:
//
// An invalid __ComObject has been used.
//
#define COR_E_INVALIDCOMOBJECT     EMAKEHR(0x1527L)


//
// MessageId: COR_E_SEMAPHOREFULL
//
// MessageText:
//
// Adding the given count to the semaphore would cause it to exceed its maximum count.
//
#define COR_E_SEMAPHOREFULL     EMAKEHR(0x152BL)


//
// MessageId: COR_E_WAITHANDLECANNOTBEOPENED
//
// MessageText:
//
// No Semaphore of the given name exists.
//
#define COR_E_WAITHANDLECANNOTBEOPENED     EMAKEHR(0x152CL)

//
// MessageId: COR_E_ABANDONEDMUTEX
//
// MessageText:
//
// The wait completed due to an abandoned mutex.
//
#define COR_E_ABANDONEDMUTEX EMAKEHR(0x152DL)

//
// MessageId: COR_E_MARSHALDIRECTIVE
//
// MessageText:
//
// The marshaling directives are invalid.
//
#define COR_E_MARSHALDIRECTIVE     EMAKEHR(0x1535L)


//
// MessageId: COR_E_INVALIDOLEVARIANTTYPE
//
// MessageText:
//
// The type of an OLE variant that was passed into the runtime is invalid.
//
#define COR_E_INVALIDOLEVARIANTTYPE    EMAKEHR(0x1531L)


//
// MessageId: COR_E_SAFEARRAYTYPEMISMATCH
//
// MessageText:
//
// A mismatch has occured between the runtime type of the array and the
// sub type recorded in the metadata.
//
#define COR_E_SAFEARRAYTYPEMISMATCH    EMAKEHR(0x1533L)


//
// MessageId: COR_E_SAFEARRAYRANKMISMATCH
//
// MessageText:
//
// A mismatch has occured between the runtime rank of the array and the
// rank recorded in the metadata.
//
#define COR_E_SAFEARRAYRANKMISMATCH    EMAKEHR(0x1538L)

//
// MessageId: COR_E_DATAMISALIGNED
//
// MessageText:
//
// A datatype misalignment was detected in a load or store instruction.
//
#define COR_E_DATAMISALIGNED    EMAKEHR(0x1541L)


//
// MessageId: COR_E_TARGETPARAMCOUNT
//
// MessageText:
//
// There was a mismatch between number of arguments provided and the number expected
//
#define COR_E_TARGETPARAMCOUNT     _HRESULT_TYPEDEF_(0x8002000EL) // DISP_E_BADPARAMCOUNT


//
// MessageId: COR_E_AMBIGUOUSMATCH
//
// MessageText:
//
// While late binding to a method via reflection, could not resolve between
// multiple overloads of a method.
//
#define COR_E_AMBIGUOUSMATCH  _HRESULT_TYPEDEF_(0x8000211DL)


//
// MessageId: COR_E_INVALIDFILTERCRITERIA
//
// MessageText:
//
// The given filter criteria does not match the filter contract.
//
#define COR_E_INVALIDFILTERCRITERIA  EMAKEHR(0x1601L)


//
// MessageId: COR_E_REFLECTIONTYPELOAD
//
// MessageText:
//
// Could not find or load a specific class that was requested through Reflection
//
#define COR_E_REFLECTIONTYPELOAD  EMAKEHR(0x1602L)


//
// MessageId: COR_E_TARGET
//
// MessageText:
//
// - If you attempt to invoke a non-static method with a null Object - If you atte
//
#define COR_E_TARGET  EMAKEHR(0x1603L)


//
// MessageId: COR_E_TARGETINVOCATION
//
// MessageText:
//
// If the method called throws an exception
//
#define COR_E_TARGETINVOCATION  EMAKEHR(0x1604L)


//
// MessageId: COR_E_CUSTOMATTRIBUTEFORMAT
//
// MessageText:
//
// If the binary format of a custom attribute is invalid.
//
#define COR_E_CUSTOMATTRIBUTEFORMAT  EMAKEHR(0x1605L)


//
// MessageId: COR_E_ENDOFSTREAM
//
// MessageText:
//
// Thrown when the End of file is reached
//
#define COR_E_ENDOFSTREAM  HRESULT_FROM_WIN32(ERROR_HANDLE_EOF)


//
// MessageId: COR_E_FILELOAD
//
// MessageText:
//
//
//
#define COR_E_FILELOAD  EMAKEHR(0x1621L)


//
// MessageId: COR_E_FILENOTFOUND
//
// MessageText:
//
//
//
#define COR_E_FILENOTFOUND  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)

//
// MessageId: ERROR_BAD_PATHNAME
//
// MessageText:
//
//  The specified path is invalid.
//
#define COR_E_BAD_PATHNAME  HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME)

//
// MessageId: COR_E_IO
//
// MessageText:
//
// Some sort of I/O error.
//
#define COR_E_IO  EMAKEHR(0x1620L)


//
// MessageId: COR_E_DIRECTORYNOTFOUND
//
// MessageText:
//
// The specified path couldn't be found.
//
#define COR_E_DIRECTORYNOTFOUND  HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)


//
// MessageId: COR_E_PATHTOOLONG
//
// MessageText:
//
// The specified path was too long.
//
#define COR_E_PATHTOOLONG  HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE)


//
// MessageId: COR_E_OBJECTDISPOSED
//
// MessageText:
//
// The object has already been disposed.
//
#define COR_E_OBJECTDISPOSED EMAKEHR(0x1622L)


//
// MessageId: COR_E_FAILFAST
//
// MessageText:
//
// Runtime operation halted by call to System.Environment.FailFast().
//
#define COR_E_FAILFAST  EMAKEHR(0x1623L)


//
// MessageId: COR_E_HOSTPROTECTION
//
// MessageText:
//
// Attempted to perform an operation that was forbidden by the host.
//
#define COR_E_HOSTPROTECTION  EMAKEHR(0x1640L)


//
// MessageId: COR_E_ILLEGAL_REENTRANCY
//
// MessageText:
//
// Attempted to call into managed code when executing inside a low level extensibility point.
//
#define COR_E_ILLEGAL_REENTRANCY  EMAKEHR(0x1641L)


//**** Shim errors 1700 - 1750
//
#define CLR_E_SHIM_RUNTIMELOAD            EMAKEHR(0x1700)     // Failed to load the runtime
#define CLR_E_SHIM_RUNTIMEEXPORT          EMAKEHR(0x1701)     // Failed to find a required export in the runtime
#define CLR_E_SHIM_INSTALLROOT            EMAKEHR(0x1702)     // Install root is not defined
#define CLR_E_SHIM_INSTALLCOMP            EMAKEHR(0x1703)     // Expected component of the runtime is not available

//**** Verifier Errors 1800 - 18FF
// See src/dlls/mscorrc/mscorrc.rc for a description of each error

#define VER_E_HRESULT           EMAKEHR(0x1801)
#define VER_E_OFFSET            EMAKEHR(0x1802)
#define VER_E_OPCODE            EMAKEHR(0x1803)
#define VER_E_OPERAND           EMAKEHR(0x1804)
#define VER_E_TOKEN             EMAKEHR(0x1805)
#define VER_E_EXCEPT            EMAKEHR(0x1806)
#define VER_E_STACK_SLOT        EMAKEHR(0x1807)
#define VER_E_LOC               EMAKEHR(0x1808)
#define VER_E_ARG               EMAKEHR(0x1809)
#define VER_E_FOUND             EMAKEHR(0x180A)
#define VER_E_EXPECTED          EMAKEHR(0x180B)
#define VER_E_LOC_BYNAME        EMAKEHR(0x180C)

#define VER_E_UNKNOWN_OPCODE    EMAKEHR(0x1810)
#define VER_E_SIG_CALLCONV      EMAKEHR(0x1811)
#define VER_E_SIG_ELEMTYPE      EMAKEHR(0x1812)

#define VER_E_RET_SIG           EMAKEHR(0x1814)
#define VER_E_FIELD_SIG         EMAKEHR(0x1815)

#define VER_E_INTERNAL          EMAKEHR(0x1818)
#define VER_E_STACK_TOO_LARGE   EMAKEHR(0x1819)
#define VER_E_ARRAY_NAME_LONG   EMAKEHR(0x181A)

#define VER_E_FALLTHRU          EMAKEHR(0x1820)
#define VER_E_TRY_GTEQ_END      EMAKEHR(0x1821)
#define VER_E_TRYEND_GT_CS      EMAKEHR(0x1822)
#define VER_E_HND_GTEQ_END      EMAKEHR(0x1823)
#define VER_E_HNDEND_GT_CS      EMAKEHR(0x1824)
#define VER_E_FLT_GTEQ_CS       EMAKEHR(0x1825)
#define VER_E_TRY_START         EMAKEHR(0x1826)
#define VER_E_HND_START         EMAKEHR(0x1827)
#define VER_E_FLT_START         EMAKEHR(0x1828)
#define VER_E_TRY_OVERLAP       EMAKEHR(0x1829)
#define VER_E_TRY_EQ_HND_FIL    EMAKEHR(0x182A)
#define VER_E_TRY_SHARE_FIN_FAL EMAKEHR(0x182B)
#define VER_E_HND_OVERLAP       EMAKEHR(0x182C)
#define VER_E_HND_EQ            EMAKEHR(0x182D)
#define VER_E_FIL_OVERLAP       EMAKEHR(0x182E)
#define VER_E_FIL_EQ            EMAKEHR(0x182F)
#define VER_E_FIL_CONT_TRY      EMAKEHR(0x1830)
#define VER_E_FIL_CONT_HND      EMAKEHR(0x1831)
#define VER_E_FIL_CONT_FIL      EMAKEHR(0x1832)
#define VER_E_FIL_GTEQ_CS       EMAKEHR(0x1833)
#define VER_E_FIL_START         EMAKEHR(0x1834)
#define VER_E_FALLTHRU_EXCEP    EMAKEHR(0x1835)
#define VER_E_FALLTHRU_INTO_HND EMAKEHR(0x1836)
#define VER_E_FALLTHRU_INTO_FIL EMAKEHR(0x1837)
#define VER_E_LEAVE             EMAKEHR(0x1838)
#define VER_E_RETHROW           EMAKEHR(0x1839)
#define VER_E_ENDFINALLY        EMAKEHR(0x183A)
#define VER_E_ENDFILTER         EMAKEHR(0x183B)
#define VER_E_ENDFILTER_MISSING EMAKEHR(0x183C)
#define VER_E_BR_INTO_TRY       EMAKEHR(0x183D)
#define VER_E_BR_INTO_HND       EMAKEHR(0x183E)
#define VER_E_BR_INTO_FIL       EMAKEHR(0x183F)
#define VER_E_BR_OUTOF_TRY      EMAKEHR(0x1840)
#define VER_E_BR_OUTOF_HND      EMAKEHR(0x1841)
#define VER_E_BR_OUTOF_FIL      EMAKEHR(0x1842)
#define VER_E_BR_OUTOF_FIN      EMAKEHR(0x1843)
#define VER_E_RET_FROM_TRY      EMAKEHR(0x1844)
#define VER_E_RET_FROM_HND      EMAKEHR(0x1845)
#define VER_E_RET_FROM_FIL      EMAKEHR(0x1846)
#define VER_E_BAD_JMP_TARGET    EMAKEHR(0x1847)
#define VER_E_PATH_LOC          EMAKEHR(0x1848)
#define VER_E_PATH_THIS         EMAKEHR(0x1849)
#define VER_E_PATH_STACK        EMAKEHR(0x184A)
#define VER_E_PATH_STACK_DEPTH  EMAKEHR(0x184B)
#define VER_E_THIS              EMAKEHR(0x184C)
#define VER_E_THIS_UNINIT_EXCEP EMAKEHR(0x184D)
#define VER_E_THIS_UNINIT_STORE EMAKEHR(0x184E)
#define VER_E_THIS_UNINIT_RET   EMAKEHR(0x184F)
#define VER_E_THIS_UNINIT_V_RET EMAKEHR(0x1850)
#define VER_E_THIS_UNINIT_BR    EMAKEHR(0x1851)
#define VER_E_LDFTN_CTOR        EMAKEHR(0x1852)
#define VER_E_STACK_NOT_EQ      EMAKEHR(0x1853)
#define VER_E_STACK_UNEXPECTED  EMAKEHR(0x1854)
#define VER_E_STACK_EXCEPTION   EMAKEHR(0x1855)
#define VER_E_STACK_OVERFLOW    EMAKEHR(0x1856)
#define VER_E_STACK_UNDERFLOW   EMAKEHR(0x1857)
#define VER_E_STACK_EMPTY       EMAKEHR(0x1858)
#define VER_E_STACK_UNINIT      EMAKEHR(0x1859)
#define VER_E_STACK_I_I4_I8     EMAKEHR(0x185A)
#define VER_E_STACK_R_R4_R8     EMAKEHR(0x185B)
#define VER_E_STACK_NO_R_I8     EMAKEHR(0x185C)
#define VER_E_STACK_NUMERIC     EMAKEHR(0x185D)
#define VER_E_STACK_OBJREF      EMAKEHR(0x185E)
#define VER_E_STACK_P_OBJREF    EMAKEHR(0x185F)
#define VER_E_STACK_BYREF       EMAKEHR(0x1860)
#define VER_E_STACK_METHOD      EMAKEHR(0x1861)
#define VER_E_STACK_ARRAY_SD    EMAKEHR(0x1862)
#define VER_E_STACK_VALCLASS    EMAKEHR(0x1863)
#define VER_E_STACK_P_VALCLASS  EMAKEHR(0x1864)
#define VER_E_STACK_NO_VALCLASS EMAKEHR(0x1865)
#define VER_E_LOC_DEAD          EMAKEHR(0x1866)
#define VER_E_LOC_NUM           EMAKEHR(0x1867)
#define VER_E_ARG_NUM           EMAKEHR(0x1868)
#define VER_E_TOKEN_RESOLVE     EMAKEHR(0x1869)
#define VER_E_TOKEN_TYPE        EMAKEHR(0x186A)
#define VER_E_TOKEN_TYPE_MEMBER EMAKEHR(0x186B)
#define VER_E_TOKEN_TYPE_FIELD  EMAKEHR(0x186C)
#define VER_E_TOKEN_TYPE_SIG    EMAKEHR(0x186D)
#define VER_E_UNVERIFIABLE      EMAKEHR(0x186E)
#define VER_E_LDSTR_OPERAND     EMAKEHR(0x186F)
#define VER_E_RET_PTR_TO_STACK  EMAKEHR(0x1870)
#define VER_E_RET_VOID          EMAKEHR(0x1871)
#define VER_E_RET_MISSING       EMAKEHR(0x1872)
#define VER_E_RET_EMPTY         EMAKEHR(0x1873)
#define VER_E_RET_UNINIT        EMAKEHR(0x1874)
#define VER_E_ARRAY_ACCESS      EMAKEHR(0x1875)
#define VER_E_ARRAY_V_STORE     EMAKEHR(0x1876)
#define VER_E_ARRAY_SD          EMAKEHR(0x1877)
#define VER_E_ARRAY_SD_PTR      EMAKEHR(0x1878)
#define VER_E_ARRAY_FIELD       EMAKEHR(0x1879)
#define VER_E_ARGLIST           EMAKEHR(0x187A)
#define VER_E_VALCLASS          EMAKEHR(0x187B)
#define VER_E_METHOD_ACCESS     EMAKEHR(0x187C)
#define VER_E_FIELD_ACCESS      EMAKEHR(0x187D)
#define VER_E_DEAD              EMAKEHR(0x187E)
#define VER_E_FIELD_STATIC      EMAKEHR(0x187F)
#define VER_E_FIELD_NO_STATIC   EMAKEHR(0x1880)
#define VER_E_ADDR              EMAKEHR(0x1881)
#define VER_E_ADDR_BYREF        EMAKEHR(0x1882)
#define VER_E_ADDR_LITERAL      EMAKEHR(0x1883)
#define VER_E_INITONLY          EMAKEHR(0x1884)
#define VER_E_THROW             EMAKEHR(0x1885)
#define VER_E_CALLVIRT_VALCLASS EMAKEHR(0x1886)
#define VER_E_CALL_SIG          EMAKEHR(0x1887)
#define VER_E_CALL_STATIC       EMAKEHR(0x1888)
#define VER_E_CTOR              EMAKEHR(0x1889)
#define VER_E_CTOR_VIRT         EMAKEHR(0x188A)
#define VER_E_CTOR_OR_SUPER     EMAKEHR(0x188B)
#define VER_E_CTOR_MUL_INIT     EMAKEHR(0x188C)
#define VER_E_SIG               EMAKEHR(0x188D)
#define VER_E_SIG_ARRAY         EMAKEHR(0x188E)
#define VER_E_SIG_ARRAY_PTR     EMAKEHR(0x188F)
#define VER_E_SIG_ARRAY_BYREF   EMAKEHR(0x1890)
#define VER_E_SIG_ELEM_PTR      EMAKEHR(0x1891)
#define VER_E_SIG_VARARG        EMAKEHR(0x1892)
#define VER_E_SIG_VOID          EMAKEHR(0x1893)
#define VER_E_SIG_BYREF_BYREF   EMAKEHR(0x1894)
#define VER_E_CODE_SIZE_ZERO    EMAKEHR(0x1896)
#define VER_E_BAD_VARARG        EMAKEHR(0x1897)
#define VER_E_TAIL_CALL         EMAKEHR(0x1898)
#define VER_E_TAIL_BYREF        EMAKEHR(0x1899)
#define VER_E_TAIL_RET          EMAKEHR(0x189A)
#define VER_E_TAIL_RET_VOID     EMAKEHR(0x189B)
#define VER_E_TAIL_RET_TYPE     EMAKEHR(0x189C)
#define VER_E_TAIL_STACK_EMPTY  EMAKEHR(0x189D)
#define VER_E_METHOD_END        EMAKEHR(0x189E)
#define VER_E_BAD_BRANCH        EMAKEHR(0x189F)
#define VER_E_FIN_OVERLAP       EMAKEHR(0x18A0)
#define VER_E_LEXICAL_NESTING   EMAKEHR(0x18A1)
#define VER_E_VOLATILE          EMAKEHR(0x18A2)
#define VER_E_UNALIGNED         EMAKEHR(0x18A3)
#define VER_E_INNERMOST_FIRST   EMAKEHR(0x18A4)
#define VER_E_CALLI_VIRTUAL     EMAKEHR(0x18A5)
#define VER_E_CALL_ABSTRACT     EMAKEHR(0x18A6)
#define VER_E_STACK_UNEXP_ARRAY EMAKEHR(0x18A7)
#define VER_E_NOT_IN_GC_HEAP    EMAKEHR(0x18A8)
#define VER_E_TRY_N_EMPTY_STACK EMAKEHR(0x18A9)
#define VER_E_DLGT_CTOR         EMAKEHR(0x18AA)
#define VER_E_DLGT_BB           EMAKEHR(0x18AB)
#define VER_E_DLGT_PATTERN      EMAKEHR(0x18AC)
#define VER_E_DLGT_LDFTN        EMAKEHR(0x18AD)
#define VER_E_FTN_ABSTRACT      EMAKEHR(0x18AE)
#define VER_E_SIG_C_VC          EMAKEHR(0x18AF)
#define VER_E_SIG_VC_C          EMAKEHR(0x18B0)
#define VER_E_BOX_PTR_TO_STACK  EMAKEHR(0x18B1)
#define VER_E_SIG_BYREF_TB_AH   EMAKEHR(0x18B2)
#define VER_E_SIG_ARRAY_TB_AH   EMAKEHR(0x18B3)
#define VER_E_ENDFILTER_STACK   EMAKEHR(0x18B4)
#define VER_E_DLGT_SIG_I        EMAKEHR(0x18B5)
#define VER_E_DLGT_SIG_O        EMAKEHR(0x18B6)
#define VER_E_RA_PTR_TO_STACK   EMAKEHR(0x18B7)
#define VER_E_CATCH_VALUE_TYPE  EMAKEHR(0x18B8)
#define VER_E_CATCH_BYREF       EMAKEHR(0x18B9)
#define VER_E_FIL_PRECEED_HND   EMAKEHR(0x18BA)
#define VER_E_LDVIRTFTN_STATIC  EMAKEHR(0x18BB)
#define VER_E_CALLVIRT_STATIC   EMAKEHR(0x18BC)
#define VER_E_INITLOCALS        EMAKEHR(0x18BD)
#define VER_E_BR_TO_EXCEPTION   EMAKEHR(0x18BE)
#define VER_E_CALL_CTOR         EMAKEHR(0x18BF)

//@GENERICSVER: new generics related error messages
#define VER_E_VALCLASS_OBJREF_VAR          EMAKEHR(0x18C0)
#define VER_E_STACK_P_VALCLASS_OBJREF_VAR  EMAKEHR(0x18C1)
#define VER_E_SIG_VAR_PARAM     EMAKEHR(0x18C2)
#define VER_E_SIG_MVAR_PARAM    EMAKEHR(0x18C3)
#define VER_E_SIG_VAR_ARG       EMAKEHR(0x18C4)
#define VER_E_SIG_MVAR_ARG      EMAKEHR(0x18C5)
#define VER_E_SIG_GENERICINST   EMAKEHR(0x18C6)
#define VER_E_SIG_METHOD_INST   EMAKEHR(0x18C7)
#define VER_E_SIG_METHOD_PARENT_INST    EMAKEHR(0x18C8)
#define VER_E_SIG_FIELD_PARENT_INST     EMAKEHR(0x18C9)
#define VER_E_CALLCONV_NOT_GENERICINST  EMAKEHR(0x18CA)
#define VER_E_TOKEN_BAD_METHOD_SPEC     EMAKEHR(0x18CB)
#define VER_E_BAD_READONLY_PREFIX       EMAKEHR(0x18CC)
#define VER_E_BAD_CONSTRAINED_PREFIX    EMAKEHR(0x18CD)
//these two are actually raised by the EE - should they appear elsewhere?
#define VER_E_CIRCULAR_VAR_CONSTRAINTS  EMAKEHR(0x18CE)
#define VER_E_CIRCULAR_MVAR_CONSTRAINTS EMAKEHR(0x18CF)
//these are used by the new peverify
#define VER_E_UNSATISFIED_METHOD_INST           EMAKEHR(0x18D0)
#define VER_E_UNSATISFIED_METHOD_PARENT_INST    EMAKEHR(0x18D1)
#define VER_E_UNSATISFIED_FIELD_PARENT_INST     EMAKEHR(0x18D2)
#define VER_E_UNSATISFIED_BOX_OPERAND           EMAKEHR(0x18D3)
#define VER_E_CONSTRAINED_CALL_WITH_NON_BYREF_THIS  EMAKEHR(0x18D4)
#define VER_E_CONSTRAINED_OF_NON_VARIABLE_TYPE EMAKEHR(0x18D5)
#define VER_E_READONLY_UNEXPECTED_CALLEE       EMAKEHR(0x18D6)
#define VER_E_READONLY_ILLEGAL_WRITE           EMAKEHR(0x18D7)
#define VER_E_READONLY_IN_MKREFANY             EMAKEHR(0x18D8)
#define VER_E_UNALIGNED_ALIGNMENT              EMAKEHR(0x18D9)
#define VER_E_TAILCALL_INSIDE_EH               EMAKEHR(0x18DA)
#define VER_E_BACKWARD_BRANCH                  EMAKEHR(0x18DB)
#define VER_E_CALL_TO_VTYPE_BASE               EMAKEHR(0x18DC)
#define VER_E_NEWOBJ_OF_ABSTRACT_CLASS         EMAKEHR(0x18DD)
#define VER_E_UNMANAGED_POINTER                EMAKEHR(0x18DE)
#define VER_E_LDFTN_NON_FINAL_VIRTUAL          EMAKEHR(0x18DF)
#define VER_E_FIELD_OVERLAP                    EMAKEHR(0x18E0)
#define VER_E_THIS_MISMATCH                    EMAKEHR(0x18E1)
#define VER_E_STACK_I_I4                       EMAKEHR(0x18E2)

#define VER_E_BAD_PE            EMAKEHR(0x18F0)
#define VER_E_BAD_MD            EMAKEHR(0x18F1)
#define VER_E_BAD_APPDOMAIN     EMAKEHR(0x18F2)
#define VER_E_TYPELOAD          EMAKEHR(0x18F3)
#define VER_E_PE_LOAD           EMAKEHR(0x18F4)
#define VER_E_WRITE_RVA_STATIC  EMAKEHR(0x18F5)


//
// ATTENTION: Range 0x1900 - 0x1AFF is reserved for Framework errors
//            Range 0x1B00 - 0x1BFF is reserved for MD Validator errors (see above VLDTR_E_...)
//

// System.Xml
#define COR_E_Xml                        EMAKEHR(0x1940)
#define COR_E_XmlSchema                  EMAKEHR(0x1941)
#define COR_E_XmlXslt                    EMAKEHR(0x1942)
#define COR_E_XmlXPath                   EMAKEHR(0x1943)
#define COR_E_XmlQuery                   EMAKEHR(0x1944)

// System.Data DataSet
#define COR_E_Data                       EMAKEHR(0x1920)
#define COR_E_DataDeletedRowInaccessible EMAKEHR(0x1921)
#define COR_E_DataDuplicateName          EMAKEHR(0x1922)
#define COR_E_DataInRowChangingEvent     EMAKEHR(0x1923)
#define COR_E_DataInvalidConstraint      EMAKEHR(0x1924)
#define COR_E_DataMissingPrimaryKey      EMAKEHR(0x1925)
#define COR_E_DataNoNullAllowed          EMAKEHR(0x1926)
#define COR_E_DataReadOnly               EMAKEHR(0x1927)
#define COR_E_DataRowNotInTable          EMAKEHR(0x1928)
#define COR_E_DataVersionNotFound        EMAKEHR(0x1929)
#define COR_E_DataConstraint             EMAKEHR(0x192A)
#define COR_E_StrongTyping               EMAKEHR(0x192B)

// System.Data Managed Providers
#define COR_E_SqlType                    EMAKEHR(0x1930)
#define COR_E_SqlNullValue               EMAKEHR(0x1931)
#define COR_E_SqlTruncate                EMAKEHR(0x1932)
#define COR_E_AdapterMapping             EMAKEHR(0x1933)
#define COR_E_DataAdapter                EMAKEHR(0x1934)
#define COR_E_DBConcurrency              EMAKEHR(0x1935)
#define COR_E_OperationAborted           EMAKEHR(0x1936)
#define COR_E_InvalidUdt                 EMAKEHR(0x1937)

#define COR_E_SqlException               EMAKEHR(0x1904)  // System.Data.SqlClient.SqlClientException
#define COR_E_OdbcException              EMAKEHR(0x1937)  // System.Data.Odbc.OdbcException
#define COR_E_OracleException            EMAKEHR(0x1938)  // System.Data.OracleClient.OracleException


//**** More debugger error 1C00 - 1CFF
//
#define CORDBG_E_THREAD_NOT_SCHEDULED                   EMAKEHR(0x1C00) // Thread is not scheduled. Thus we may not have OSThreadId, handle, or context
#define CORDBG_E_HANDLE_HAS_BEEN_DISPOSED               EMAKEHR(0x1C01) // Handle has been disposed.
#define CORDBG_E_NONINTERCEPTABLE_EXCEPTION             EMAKEHR(0x1C02) // Cant intercept this exception.
#define CORDBG_E_CANT_UNWIND_ABOVE_CALLBACK             EMAKEHR(0x1C03) // When intercepting an exception, cannot intercept above the current frame.
#define CORDBG_E_INTERCEPT_FRAME_ALREADY_SET            EMAKEHR(0x1C04) // The intercept frame for this exception has already been set.
#define CORDBG_E_NO_NATIVE_PATCH_AT_ADDR                EMAKEHR(0x1C05) // there's no native patch at the given address.
#define CORDBG_E_MUST_BE_INTEROP_DEBUGGING              EMAKEHR(0x1C06) // This API is only allowed when interop debugging.
#define CORDBG_E_NATIVE_PATCH_ALREADY_AT_ADDR           EMAKEHR(0x1C07) // There's already a native patch at the address
#define CORDBG_E_TIMEOUT                                EMAKEHR(0x1C08) // a wait timed out .. likely an indication of deadlock.
#define CORDBG_E_CANT_CALL_ON_THIS_THREAD               EMAKEHR(0x1C09) // Can't use the API on this thread.
#define CORDBG_E_ENC_INFOLESS_METHOD                    EMAKEHR(0x1C0A) // Method was not JITed in EnC mode
#define CORDBG_E_ENC_NESTED_HANLDERS                    EMAKEHR(0x1C0B) // Frame cant be updated due to change in max nesting of handlers
#define CORDBG_E_ENC_IN_FUNCLET                         EMAKEHR(0x1C0C) // Method is in a callable handler/filter. Cant grow stack
#define CORDBG_E_ENC_LOCALLOC                           EMAKEHR(0x1C0D) // Frame cant be updated due to localloc
#define CORDBG_E_ENC_EDIT_NOT_SUPPORTED                 EMAKEHR(0x1C0E) // Attempt to perform unsupported edit
#define CORDBG_E_FEABORT_DELAYED_UNTIL_THREAD_RESUMED   EMAKEHR(0x1C0F) // Attempt to func eval abort on a suspended thread.
#define CORDBG_E_NOTREADY                               EMAKEHR(0x1C10) // The LS is not in a good spot to perform the requested operation.
#define CORDBG_E_CANNOT_RESOLVE_ASSEMBLY                EMAKEHR(0x1c11) // We failed to resolve assembly given an AssemblyRef token. Assembly may be not loaded yet or not a valid token.
#define CORDBG_E_MUST_BE_IN_LOAD_MODULE                 EMAKEHR(0x1C12) // Must be in context of LoadModule callback to perform requested operation
#define CORDBG_E_CANNOT_BE_ON_ATTACH                    EMAKEHR(0x1C13) // Requested operation cannot be performed during an attach operation
#define CORDBG_S_NOT_ALL_BITS_SET                            SMAKEHR(0x1C13) // Not all bits specified were successfully applied
#define CORDBG_E_NGEN_NOT_SUPPORTED                     EMAKEHR(0x1C14) // NGEN must be supported to perform the requested operation
#define CORDBG_E_ILLEGAL_SHUTDOWN_ORDER                 EMAKEHR(0x1C15) // Trying to shutdown out of order.
#define CORDBG_E_CANNOT_DEBUG_FIBER_PROCESS             EMAKEHR(0x1C16) // For Whidbey, we don't support debugging fiber mode managed process
#define CORDBG_E_MUST_BE_IN_CREATE_PROCESS              EMAKEHR(0x1C17) // Must be in context of CreateProcess callback to perform requested operation
#define CORDBG_E_DETACH_FAILED_OUTSTANDING_EVALS        EMAKEHR(0x1C18) // All outstanding func-evals have not completed, detaching is not allowed at this time.
#define CORDBG_E_DETACH_FAILED_OUTSTANDING_STEPPERS     EMAKEHR(0x1C19) // All outstanding steppers have not been closed, detaching is not allowed at this time.
#define CORDBG_E_CANT_INTEROP_STEP_OUT                  EMAKEHR(0x1C20) // Can't have an ICorDebugStepper do a native step-out.
#define CORDBG_E_DETACH_FAILED_OUTSTANDING_BREAKPOINTS  EMAKEHR(0x1C21) // All outstanding breakpoints have not been closed, detaching is not allowed at this time.
#define CORDBG_E_ILLEGAL_IN_STACK_OVERFLOW              EMAKEHR(0x1c22) // the operation is illegal because of a stackoverflow.
#define CORDBG_E_ILLEGAL_AT_GC_UNSAFE_POINT             EMAKEHR(0x1c23) // The operation failed because it's a GC unsafe point.
#define CORDBG_E_ILLEGAL_IN_PROLOG                      EMAKEHR(0x1c24) // The operation failed because the thread is in the prolog
#define CORDBG_E_ILLEGAL_IN_NATIVE_CODE                 EMAKEHR(0x1c25) // The operation failed because the thread is in native code
#define CORDBG_E_ILLEGAL_IN_OPTIMIZED_CODE              EMAKEHR(0x1c26) // The operation failed because the thread is in optimized code.
#define CORDBG_E_MINIDUMP_UNSUPPORTED                   EMAKEHR(0x1c27) //
#define CORDBG_E_APPDOMAIN_MISMATCH                     EMAKEHR(0x1c28) // A supplied object or type belongs to the wrong AppDomain
#define CORDBG_E_CONTEXT_UNVAILABLE                     EMAKEHR(0x1c29) // The thread's context is not available.
#define CORDBG_E_UNCOMPATIBLE_PLATFORMS                 EMAKEHR(0x1c30) // The operation failed because debuggee and debugger are on incompatible platform
#define CORDBG_E_DEBUGGING_DISABLED                     EMAKEHR(0x1c31) // The operation failed because the debugging has been disabled
#define CORDBG_E_DETACH_FAILED_ON_ENC                   EMAKEHR(0x1c32) // Detach is illegal after a module has been EnCed.
#define CORDBG_E_CURRENT_EXCEPTION_IS_OUTSIDE_CURRENT_EXECUTION_SCOPE EMAKEHR(0x1c33) // Interception of the current exception is not legal
#define CORDBG_E_HELPER_MAY_DEADLOCK                    EMAKEHR(0x1c34) // Helper thread can not safely run code. The opereration may work at a later time.



//**** PE Format validation errors 1D00 - 1DFF
//
#define PEFMT_E_NO_CONTENTS                             EMAKEHR(0x1D00) // File is empty
#define PEFMT_E_NO_NTHEADERS                            EMAKEHR(0x1D01) // File has no NT headers
#define PEFMT_E_64BIT                                   EMAKEHR(0x1D02) // File is PE32+
#define PEFMT_E_NO_CORHEADER                            EMAKEHR(0x1D03) // File has no COR header
#define PEFMT_E_NOT_ILONLY                              EMAKEHR(0x1D04) // Flag IL_ONLY not set
#define PEFMT_E_IMPORT_DLLS                             EMAKEHR(0x1D05) // Bad import DLLs
#define PEFMT_E_EXE_NOENTRYPOINT                        EMAKEHR(0x1D06) // EXE file has no mgd entry point
#define PEFMT_E_BASE_RELOCS                             EMAKEHR(0x1D07) // Bad base relocations
#define PEFMT_E_ENTRYPOINT                              EMAKEHR(0x1D08) // Bad managed entry point
#define PEFMT_E_ZERO_SIZEOFCODE                         EMAKEHR(0x1D09) // OptHeader.SizeOfCode==0
#define PEFMT_E_BAD_CORHEADER                           EMAKEHR(0x1D0A) // File has invalid COR header

//**** CLR Optimization service 1E00 - 1EFF
//
#define CLR_OPTSVC_E_CONTROLLER_INTERRUPT               EMAKEHR(0x1E00) // Service controller interrupted work


//**** CLR Optimization service 1F00 - 1FFF
//
#define NGEN_FAILED_GET_DEPENDENCIES                    EMAKEHR(0x1F00)  // Service manager failed to get ICorSvcDependencies interface
#define NGEN_FAILED_NATIVE_IMAGE_DELETE                 EMAKEHR(0x1F01)  // Failed to delete native image





#endif // __COMMON_LANGUAGE_RUNTIME_HRESULTS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\cordebug.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for cordebug.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cordebug_h__
#define __cordebug_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICorDebugManagedCallback_FWD_DEFINED__
#define __ICorDebugManagedCallback_FWD_DEFINED__
typedef interface ICorDebugManagedCallback ICorDebugManagedCallback;
#endif 	/* __ICorDebugManagedCallback_FWD_DEFINED__ */


#ifndef __ICorDebugManagedCallback2_FWD_DEFINED__
#define __ICorDebugManagedCallback2_FWD_DEFINED__
typedef interface ICorDebugManagedCallback2 ICorDebugManagedCallback2;
#endif 	/* __ICorDebugManagedCallback2_FWD_DEFINED__ */


#ifndef __ICorDebugUnmanagedCallback_FWD_DEFINED__
#define __ICorDebugUnmanagedCallback_FWD_DEFINED__
typedef interface ICorDebugUnmanagedCallback ICorDebugUnmanagedCallback;
#endif 	/* __ICorDebugUnmanagedCallback_FWD_DEFINED__ */


#ifndef __ICorDebug_FWD_DEFINED__
#define __ICorDebug_FWD_DEFINED__
typedef interface ICorDebug ICorDebug;
#endif 	/* __ICorDebug_FWD_DEFINED__ */


#ifndef __ICorDebug2_FWD_DEFINED__
#define __ICorDebug2_FWD_DEFINED__
typedef interface ICorDebug2 ICorDebug2;
#endif 	/* __ICorDebug2_FWD_DEFINED__ */


#ifndef __ICorDebugController_FWD_DEFINED__
#define __ICorDebugController_FWD_DEFINED__
typedef interface ICorDebugController ICorDebugController;
#endif 	/* __ICorDebugController_FWD_DEFINED__ */


#ifndef __ICorDebugAppDomain_FWD_DEFINED__
#define __ICorDebugAppDomain_FWD_DEFINED__
typedef interface ICorDebugAppDomain ICorDebugAppDomain;
#endif 	/* __ICorDebugAppDomain_FWD_DEFINED__ */


#ifndef __ICorDebugAppDomain2_FWD_DEFINED__
#define __ICorDebugAppDomain2_FWD_DEFINED__
typedef interface ICorDebugAppDomain2 ICorDebugAppDomain2;
#endif 	/* __ICorDebugAppDomain2_FWD_DEFINED__ */


#ifndef __ICorDebugAssembly_FWD_DEFINED__
#define __ICorDebugAssembly_FWD_DEFINED__
typedef interface ICorDebugAssembly ICorDebugAssembly;
#endif 	/* __ICorDebugAssembly_FWD_DEFINED__ */


#ifndef __ICorDebugAssembly2_FWD_DEFINED__
#define __ICorDebugAssembly2_FWD_DEFINED__
typedef interface ICorDebugAssembly2 ICorDebugAssembly2;
#endif 	/* __ICorDebugAssembly2_FWD_DEFINED__ */


#ifndef __ICorDebugProcess_FWD_DEFINED__
#define __ICorDebugProcess_FWD_DEFINED__
typedef interface ICorDebugProcess ICorDebugProcess;
#endif 	/* __ICorDebugProcess_FWD_DEFINED__ */


#ifndef __ICorDebugProcess2_FWD_DEFINED__
#define __ICorDebugProcess2_FWD_DEFINED__
typedef interface ICorDebugProcess2 ICorDebugProcess2;
#endif 	/* __ICorDebugProcess2_FWD_DEFINED__ */


#ifndef __ICorDebugBreakpoint_FWD_DEFINED__
#define __ICorDebugBreakpoint_FWD_DEFINED__
typedef interface ICorDebugBreakpoint ICorDebugBreakpoint;
#endif 	/* __ICorDebugBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugFunctionBreakpoint_FWD_DEFINED__
#define __ICorDebugFunctionBreakpoint_FWD_DEFINED__
typedef interface ICorDebugFunctionBreakpoint ICorDebugFunctionBreakpoint;
#endif 	/* __ICorDebugFunctionBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugModuleBreakpoint_FWD_DEFINED__
#define __ICorDebugModuleBreakpoint_FWD_DEFINED__
typedef interface ICorDebugModuleBreakpoint ICorDebugModuleBreakpoint;
#endif 	/* __ICorDebugModuleBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugValueBreakpoint_FWD_DEFINED__
#define __ICorDebugValueBreakpoint_FWD_DEFINED__
typedef interface ICorDebugValueBreakpoint ICorDebugValueBreakpoint;
#endif 	/* __ICorDebugValueBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugStepper_FWD_DEFINED__
#define __ICorDebugStepper_FWD_DEFINED__
typedef interface ICorDebugStepper ICorDebugStepper;
#endif 	/* __ICorDebugStepper_FWD_DEFINED__ */


#ifndef __ICorDebugStepper2_FWD_DEFINED__
#define __ICorDebugStepper2_FWD_DEFINED__
typedef interface ICorDebugStepper2 ICorDebugStepper2;
#endif 	/* __ICorDebugStepper2_FWD_DEFINED__ */


#ifndef __ICorDebugRegisterSet_FWD_DEFINED__
#define __ICorDebugRegisterSet_FWD_DEFINED__
typedef interface ICorDebugRegisterSet ICorDebugRegisterSet;
#endif 	/* __ICorDebugRegisterSet_FWD_DEFINED__ */


#ifndef __ICorDebugRegisterSet2_FWD_DEFINED__
#define __ICorDebugRegisterSet2_FWD_DEFINED__
typedef interface ICorDebugRegisterSet2 ICorDebugRegisterSet2;
#endif 	/* __ICorDebugRegisterSet2_FWD_DEFINED__ */


#ifndef __ICorDebugThread_FWD_DEFINED__
#define __ICorDebugThread_FWD_DEFINED__
typedef interface ICorDebugThread ICorDebugThread;
#endif 	/* __ICorDebugThread_FWD_DEFINED__ */


#ifndef __ICorDebugThread2_FWD_DEFINED__
#define __ICorDebugThread2_FWD_DEFINED__
typedef interface ICorDebugThread2 ICorDebugThread2;
#endif 	/* __ICorDebugThread2_FWD_DEFINED__ */


#ifndef __ICorDebugChain_FWD_DEFINED__
#define __ICorDebugChain_FWD_DEFINED__
typedef interface ICorDebugChain ICorDebugChain;
#endif 	/* __ICorDebugChain_FWD_DEFINED__ */


#ifndef __ICorDebugFrame_FWD_DEFINED__
#define __ICorDebugFrame_FWD_DEFINED__
typedef interface ICorDebugFrame ICorDebugFrame;
#endif 	/* __ICorDebugFrame_FWD_DEFINED__ */


#ifndef __ICorDebugInternalFrame_FWD_DEFINED__
#define __ICorDebugInternalFrame_FWD_DEFINED__
typedef interface ICorDebugInternalFrame ICorDebugInternalFrame;
#endif 	/* __ICorDebugInternalFrame_FWD_DEFINED__ */


#ifndef __ICorDebugILFrame_FWD_DEFINED__
#define __ICorDebugILFrame_FWD_DEFINED__
typedef interface ICorDebugILFrame ICorDebugILFrame;
#endif 	/* __ICorDebugILFrame_FWD_DEFINED__ */


#ifndef __ICorDebugILFrame2_FWD_DEFINED__
#define __ICorDebugILFrame2_FWD_DEFINED__
typedef interface ICorDebugILFrame2 ICorDebugILFrame2;
#endif 	/* __ICorDebugILFrame2_FWD_DEFINED__ */


#ifndef __ICorDebugNativeFrame_FWD_DEFINED__
#define __ICorDebugNativeFrame_FWD_DEFINED__
typedef interface ICorDebugNativeFrame ICorDebugNativeFrame;
#endif 	/* __ICorDebugNativeFrame_FWD_DEFINED__ */


#ifndef __ICorDebugModule_FWD_DEFINED__
#define __ICorDebugModule_FWD_DEFINED__
typedef interface ICorDebugModule ICorDebugModule;
#endif 	/* __ICorDebugModule_FWD_DEFINED__ */


#ifndef __ICorDebugModule2_FWD_DEFINED__
#define __ICorDebugModule2_FWD_DEFINED__
typedef interface ICorDebugModule2 ICorDebugModule2;
#endif 	/* __ICorDebugModule2_FWD_DEFINED__ */


#ifndef __ICorDebugFunction_FWD_DEFINED__
#define __ICorDebugFunction_FWD_DEFINED__
typedef interface ICorDebugFunction ICorDebugFunction;
#endif 	/* __ICorDebugFunction_FWD_DEFINED__ */


#ifndef __ICorDebugFunction2_FWD_DEFINED__
#define __ICorDebugFunction2_FWD_DEFINED__
typedef interface ICorDebugFunction2 ICorDebugFunction2;
#endif 	/* __ICorDebugFunction2_FWD_DEFINED__ */


#ifndef __ICorDebugCode_FWD_DEFINED__
#define __ICorDebugCode_FWD_DEFINED__
typedef interface ICorDebugCode ICorDebugCode;
#endif 	/* __ICorDebugCode_FWD_DEFINED__ */


#ifndef __ICorDebugCode2_FWD_DEFINED__
#define __ICorDebugCode2_FWD_DEFINED__
typedef interface ICorDebugCode2 ICorDebugCode2;
#endif 	/* __ICorDebugCode2_FWD_DEFINED__ */


#ifndef __ICorDebugClass_FWD_DEFINED__
#define __ICorDebugClass_FWD_DEFINED__
typedef interface ICorDebugClass ICorDebugClass;
#endif 	/* __ICorDebugClass_FWD_DEFINED__ */


#ifndef __ICorDebugClass2_FWD_DEFINED__
#define __ICorDebugClass2_FWD_DEFINED__
typedef interface ICorDebugClass2 ICorDebugClass2;
#endif 	/* __ICorDebugClass2_FWD_DEFINED__ */


#ifndef __ICorDebugEval_FWD_DEFINED__
#define __ICorDebugEval_FWD_DEFINED__
typedef interface ICorDebugEval ICorDebugEval;
#endif 	/* __ICorDebugEval_FWD_DEFINED__ */


#ifndef __ICorDebugEval2_FWD_DEFINED__
#define __ICorDebugEval2_FWD_DEFINED__
typedef interface ICorDebugEval2 ICorDebugEval2;
#endif 	/* __ICorDebugEval2_FWD_DEFINED__ */


#ifndef __ICorDebugValue_FWD_DEFINED__
#define __ICorDebugValue_FWD_DEFINED__
typedef interface ICorDebugValue ICorDebugValue;
#endif 	/* __ICorDebugValue_FWD_DEFINED__ */


#ifndef __ICorDebugValue2_FWD_DEFINED__
#define __ICorDebugValue2_FWD_DEFINED__
typedef interface ICorDebugValue2 ICorDebugValue2;
#endif 	/* __ICorDebugValue2_FWD_DEFINED__ */


#ifndef __ICorDebugGenericValue_FWD_DEFINED__
#define __ICorDebugGenericValue_FWD_DEFINED__
typedef interface ICorDebugGenericValue ICorDebugGenericValue;
#endif 	/* __ICorDebugGenericValue_FWD_DEFINED__ */


#ifndef __ICorDebugReferenceValue_FWD_DEFINED__
#define __ICorDebugReferenceValue_FWD_DEFINED__
typedef interface ICorDebugReferenceValue ICorDebugReferenceValue;
#endif 	/* __ICorDebugReferenceValue_FWD_DEFINED__ */


#ifndef __ICorDebugHeapValue_FWD_DEFINED__
#define __ICorDebugHeapValue_FWD_DEFINED__
typedef interface ICorDebugHeapValue ICorDebugHeapValue;
#endif 	/* __ICorDebugHeapValue_FWD_DEFINED__ */


#ifndef __ICorDebugHeapValue2_FWD_DEFINED__
#define __ICorDebugHeapValue2_FWD_DEFINED__
typedef interface ICorDebugHeapValue2 ICorDebugHeapValue2;
#endif 	/* __ICorDebugHeapValue2_FWD_DEFINED__ */


#ifndef __ICorDebugObjectValue_FWD_DEFINED__
#define __ICorDebugObjectValue_FWD_DEFINED__
typedef interface ICorDebugObjectValue ICorDebugObjectValue;
#endif 	/* __ICorDebugObjectValue_FWD_DEFINED__ */


#ifndef __ICorDebugObjectValue2_FWD_DEFINED__
#define __ICorDebugObjectValue2_FWD_DEFINED__
typedef interface ICorDebugObjectValue2 ICorDebugObjectValue2;
#endif 	/* __ICorDebugObjectValue2_FWD_DEFINED__ */


#ifndef __ICorDebugBoxValue_FWD_DEFINED__
#define __ICorDebugBoxValue_FWD_DEFINED__
typedef interface ICorDebugBoxValue ICorDebugBoxValue;
#endif 	/* __ICorDebugBoxValue_FWD_DEFINED__ */


#ifndef __ICorDebugStringValue_FWD_DEFINED__
#define __ICorDebugStringValue_FWD_DEFINED__
typedef interface ICorDebugStringValue ICorDebugStringValue;
#endif 	/* __ICorDebugStringValue_FWD_DEFINED__ */


#ifndef __ICorDebugArrayValue_FWD_DEFINED__
#define __ICorDebugArrayValue_FWD_DEFINED__
typedef interface ICorDebugArrayValue ICorDebugArrayValue;
#endif 	/* __ICorDebugArrayValue_FWD_DEFINED__ */


#ifndef __ICorDebugHandleValue_FWD_DEFINED__
#define __ICorDebugHandleValue_FWD_DEFINED__
typedef interface ICorDebugHandleValue ICorDebugHandleValue;
#endif 	/* __ICorDebugHandleValue_FWD_DEFINED__ */


#ifndef __ICorDebugContext_FWD_DEFINED__
#define __ICorDebugContext_FWD_DEFINED__
typedef interface ICorDebugContext ICorDebugContext;
#endif 	/* __ICorDebugContext_FWD_DEFINED__ */


#ifndef __ICorDebugEnum_FWD_DEFINED__
#define __ICorDebugEnum_FWD_DEFINED__
typedef interface ICorDebugEnum ICorDebugEnum;
#endif 	/* __ICorDebugEnum_FWD_DEFINED__ */


#ifndef __ICorDebugObjectEnum_FWD_DEFINED__
#define __ICorDebugObjectEnum_FWD_DEFINED__
typedef interface ICorDebugObjectEnum ICorDebugObjectEnum;
#endif 	/* __ICorDebugObjectEnum_FWD_DEFINED__ */


#ifndef __ICorDebugBreakpointEnum_FWD_DEFINED__
#define __ICorDebugBreakpointEnum_FWD_DEFINED__
typedef interface ICorDebugBreakpointEnum ICorDebugBreakpointEnum;
#endif 	/* __ICorDebugBreakpointEnum_FWD_DEFINED__ */


#ifndef __ICorDebugStepperEnum_FWD_DEFINED__
#define __ICorDebugStepperEnum_FWD_DEFINED__
typedef interface ICorDebugStepperEnum ICorDebugStepperEnum;
#endif 	/* __ICorDebugStepperEnum_FWD_DEFINED__ */


#ifndef __ICorDebugProcessEnum_FWD_DEFINED__
#define __ICorDebugProcessEnum_FWD_DEFINED__
typedef interface ICorDebugProcessEnum ICorDebugProcessEnum;
#endif 	/* __ICorDebugProcessEnum_FWD_DEFINED__ */


#ifndef __ICorDebugThreadEnum_FWD_DEFINED__
#define __ICorDebugThreadEnum_FWD_DEFINED__
typedef interface ICorDebugThreadEnum ICorDebugThreadEnum;
#endif 	/* __ICorDebugThreadEnum_FWD_DEFINED__ */


#ifndef __ICorDebugFrameEnum_FWD_DEFINED__
#define __ICorDebugFrameEnum_FWD_DEFINED__
typedef interface ICorDebugFrameEnum ICorDebugFrameEnum;
#endif 	/* __ICorDebugFrameEnum_FWD_DEFINED__ */


#ifndef __ICorDebugChainEnum_FWD_DEFINED__
#define __ICorDebugChainEnum_FWD_DEFINED__
typedef interface ICorDebugChainEnum ICorDebugChainEnum;
#endif 	/* __ICorDebugChainEnum_FWD_DEFINED__ */


#ifndef __ICorDebugModuleEnum_FWD_DEFINED__
#define __ICorDebugModuleEnum_FWD_DEFINED__
typedef interface ICorDebugModuleEnum ICorDebugModuleEnum;
#endif 	/* __ICorDebugModuleEnum_FWD_DEFINED__ */


#ifndef __ICorDebugValueEnum_FWD_DEFINED__
#define __ICorDebugValueEnum_FWD_DEFINED__
typedef interface ICorDebugValueEnum ICorDebugValueEnum;
#endif 	/* __ICorDebugValueEnum_FWD_DEFINED__ */


#ifndef __ICorDebugCodeEnum_FWD_DEFINED__
#define __ICorDebugCodeEnum_FWD_DEFINED__
typedef interface ICorDebugCodeEnum ICorDebugCodeEnum;
#endif 	/* __ICorDebugCodeEnum_FWD_DEFINED__ */


#ifndef __ICorDebugTypeEnum_FWD_DEFINED__
#define __ICorDebugTypeEnum_FWD_DEFINED__
typedef interface ICorDebugTypeEnum ICorDebugTypeEnum;
#endif 	/* __ICorDebugTypeEnum_FWD_DEFINED__ */


#ifndef __ICorDebugType_FWD_DEFINED__
#define __ICorDebugType_FWD_DEFINED__
typedef interface ICorDebugType ICorDebugType;
#endif 	/* __ICorDebugType_FWD_DEFINED__ */


#ifndef __ICorDebugErrorInfoEnum_FWD_DEFINED__
#define __ICorDebugErrorInfoEnum_FWD_DEFINED__
typedef interface ICorDebugErrorInfoEnum ICorDebugErrorInfoEnum;
#endif 	/* __ICorDebugErrorInfoEnum_FWD_DEFINED__ */


#ifndef __ICorDebugAppDomainEnum_FWD_DEFINED__
#define __ICorDebugAppDomainEnum_FWD_DEFINED__
typedef interface ICorDebugAppDomainEnum ICorDebugAppDomainEnum;
#endif 	/* __ICorDebugAppDomainEnum_FWD_DEFINED__ */


#ifndef __ICorDebugAssemblyEnum_FWD_DEFINED__
#define __ICorDebugAssemblyEnum_FWD_DEFINED__
typedef interface ICorDebugAssemblyEnum ICorDebugAssemblyEnum;
#endif 	/* __ICorDebugAssemblyEnum_FWD_DEFINED__ */


#ifndef __ICorDebugMDA_FWD_DEFINED__
#define __ICorDebugMDA_FWD_DEFINED__
typedef interface ICorDebugMDA ICorDebugMDA;
#endif 	/* __ICorDebugMDA_FWD_DEFINED__ */


#ifndef __ICorDebugEditAndContinueErrorInfo_FWD_DEFINED__
#define __ICorDebugEditAndContinueErrorInfo_FWD_DEFINED__
typedef interface ICorDebugEditAndContinueErrorInfo ICorDebugEditAndContinueErrorInfo;
#endif 	/* __ICorDebugEditAndContinueErrorInfo_FWD_DEFINED__ */


#ifndef __ICorDebugEditAndContinueSnapshot_FWD_DEFINED__
#define __ICorDebugEditAndContinueSnapshot_FWD_DEFINED__
typedef interface ICorDebugEditAndContinueSnapshot ICorDebugEditAndContinueSnapshot;
#endif 	/* __ICorDebugEditAndContinueSnapshot_FWD_DEFINED__ */


#ifndef __CorDebug_FWD_DEFINED__
#define __CorDebug_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorDebug CorDebug;
#else
typedef struct CorDebug CorDebug;
#endif /* __cplusplus */

#endif 	/* __CorDebug_FWD_DEFINED__ */


#ifndef __EmbeddedCLRCorDebug_FWD_DEFINED__
#define __EmbeddedCLRCorDebug_FWD_DEFINED__

#ifdef __cplusplus
typedef class EmbeddedCLRCorDebug EmbeddedCLRCorDebug;
#else
typedef struct EmbeddedCLRCorDebug EmbeddedCLRCorDebug;
#endif /* __cplusplus */

#endif 	/* __EmbeddedCLRCorDebug_FWD_DEFINED__ */


#ifndef __ICorDebugValue_FWD_DEFINED__
#define __ICorDebugValue_FWD_DEFINED__
typedef interface ICorDebugValue ICorDebugValue;
#endif 	/* __ICorDebugValue_FWD_DEFINED__ */


#ifndef __ICorDebugReferenceValue_FWD_DEFINED__
#define __ICorDebugReferenceValue_FWD_DEFINED__
typedef interface ICorDebugReferenceValue ICorDebugReferenceValue;
#endif 	/* __ICorDebugReferenceValue_FWD_DEFINED__ */


#ifndef __ICorDebugHeapValue_FWD_DEFINED__
#define __ICorDebugHeapValue_FWD_DEFINED__
typedef interface ICorDebugHeapValue ICorDebugHeapValue;
#endif 	/* __ICorDebugHeapValue_FWD_DEFINED__ */


#ifndef __ICorDebugStringValue_FWD_DEFINED__
#define __ICorDebugStringValue_FWD_DEFINED__
typedef interface ICorDebugStringValue ICorDebugStringValue;
#endif 	/* __ICorDebugStringValue_FWD_DEFINED__ */


#ifndef __ICorDebugGenericValue_FWD_DEFINED__
#define __ICorDebugGenericValue_FWD_DEFINED__
typedef interface ICorDebugGenericValue ICorDebugGenericValue;
#endif 	/* __ICorDebugGenericValue_FWD_DEFINED__ */


#ifndef __ICorDebugBoxValue_FWD_DEFINED__
#define __ICorDebugBoxValue_FWD_DEFINED__
typedef interface ICorDebugBoxValue ICorDebugBoxValue;
#endif 	/* __ICorDebugBoxValue_FWD_DEFINED__ */


#ifndef __ICorDebugArrayValue_FWD_DEFINED__
#define __ICorDebugArrayValue_FWD_DEFINED__
typedef interface ICorDebugArrayValue ICorDebugArrayValue;
#endif 	/* __ICorDebugArrayValue_FWD_DEFINED__ */


#ifndef __ICorDebugFrame_FWD_DEFINED__
#define __ICorDebugFrame_FWD_DEFINED__
typedef interface ICorDebugFrame ICorDebugFrame;
#endif 	/* __ICorDebugFrame_FWD_DEFINED__ */


#ifndef __ICorDebugILFrame_FWD_DEFINED__
#define __ICorDebugILFrame_FWD_DEFINED__
typedef interface ICorDebugILFrame ICorDebugILFrame;
#endif 	/* __ICorDebugILFrame_FWD_DEFINED__ */


#ifndef __ICorDebugInternalFrame_FWD_DEFINED__
#define __ICorDebugInternalFrame_FWD_DEFINED__
typedef interface ICorDebugInternalFrame ICorDebugInternalFrame;
#endif 	/* __ICorDebugInternalFrame_FWD_DEFINED__ */


#ifndef __ICorDebugNativeFrame_FWD_DEFINED__
#define __ICorDebugNativeFrame_FWD_DEFINED__
typedef interface ICorDebugNativeFrame ICorDebugNativeFrame;
#endif 	/* __ICorDebugNativeFrame_FWD_DEFINED__ */


#ifndef __ICorDebugManagedCallback2_FWD_DEFINED__
#define __ICorDebugManagedCallback2_FWD_DEFINED__
typedef interface ICorDebugManagedCallback2 ICorDebugManagedCallback2;
#endif 	/* __ICorDebugManagedCallback2_FWD_DEFINED__ */


#ifndef __ICorDebugAppDomain2_FWD_DEFINED__
#define __ICorDebugAppDomain2_FWD_DEFINED__
typedef interface ICorDebugAppDomain2 ICorDebugAppDomain2;
#endif 	/* __ICorDebugAppDomain2_FWD_DEFINED__ */


#ifndef __ICorDebugAssembly2_FWD_DEFINED__
#define __ICorDebugAssembly2_FWD_DEFINED__
typedef interface ICorDebugAssembly2 ICorDebugAssembly2;
#endif 	/* __ICorDebugAssembly2_FWD_DEFINED__ */


#ifndef __ICorDebugProcess2_FWD_DEFINED__
#define __ICorDebugProcess2_FWD_DEFINED__
typedef interface ICorDebugProcess2 ICorDebugProcess2;
#endif 	/* __ICorDebugProcess2_FWD_DEFINED__ */


#ifndef __ICorDebugStepper2_FWD_DEFINED__
#define __ICorDebugStepper2_FWD_DEFINED__
typedef interface ICorDebugStepper2 ICorDebugStepper2;
#endif 	/* __ICorDebugStepper2_FWD_DEFINED__ */


#ifndef __ICorDebugThread2_FWD_DEFINED__
#define __ICorDebugThread2_FWD_DEFINED__
typedef interface ICorDebugThread2 ICorDebugThread2;
#endif 	/* __ICorDebugThread2_FWD_DEFINED__ */


#ifndef __ICorDebugILFrame2_FWD_DEFINED__
#define __ICorDebugILFrame2_FWD_DEFINED__
typedef interface ICorDebugILFrame2 ICorDebugILFrame2;
#endif 	/* __ICorDebugILFrame2_FWD_DEFINED__ */


#ifndef __ICorDebugModule2_FWD_DEFINED__
#define __ICorDebugModule2_FWD_DEFINED__
typedef interface ICorDebugModule2 ICorDebugModule2;
#endif 	/* __ICorDebugModule2_FWD_DEFINED__ */


#ifndef __ICorDebugFunction2_FWD_DEFINED__
#define __ICorDebugFunction2_FWD_DEFINED__
typedef interface ICorDebugFunction2 ICorDebugFunction2;
#endif 	/* __ICorDebugFunction2_FWD_DEFINED__ */


#ifndef __ICorDebugClass2_FWD_DEFINED__
#define __ICorDebugClass2_FWD_DEFINED__
typedef interface ICorDebugClass2 ICorDebugClass2;
#endif 	/* __ICorDebugClass2_FWD_DEFINED__ */


#ifndef __ICorDebugEval2_FWD_DEFINED__
#define __ICorDebugEval2_FWD_DEFINED__
typedef interface ICorDebugEval2 ICorDebugEval2;
#endif 	/* __ICorDebugEval2_FWD_DEFINED__ */


#ifndef __ICorDebugValue2_FWD_DEFINED__
#define __ICorDebugValue2_FWD_DEFINED__
typedef interface ICorDebugValue2 ICorDebugValue2;
#endif 	/* __ICorDebugValue2_FWD_DEFINED__ */


#ifndef __ICorDebugObjectValue2_FWD_DEFINED__
#define __ICorDebugObjectValue2_FWD_DEFINED__
typedef interface ICorDebugObjectValue2 ICorDebugObjectValue2;
#endif 	/* __ICorDebugObjectValue2_FWD_DEFINED__ */


#ifndef __ICorDebugHandleValue_FWD_DEFINED__
#define __ICorDebugHandleValue_FWD_DEFINED__
typedef interface ICorDebugHandleValue ICorDebugHandleValue;
#endif 	/* __ICorDebugHandleValue_FWD_DEFINED__ */


#ifndef __ICorDebugHeapValue2_FWD_DEFINED__
#define __ICorDebugHeapValue2_FWD_DEFINED__
typedef interface ICorDebugHeapValue2 ICorDebugHeapValue2;
#endif 	/* __ICorDebugHeapValue2_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_cordebug_0000 */
/* [local] */ 

#if 0
typedef UINT32 mdToken;

typedef mdToken mdModule;

typedef SIZE_T mdScope;

typedef mdToken mdTypeDef;

typedef mdToken mdSourceFile;

typedef mdToken mdMemberRef;

typedef mdToken mdMethodDef;

typedef mdToken mdFieldDef;

typedef mdToken mdSignature;

typedef ULONG CorElementType;

typedef SIZE_T PCCOR_SIGNATURE;

typedef SIZE_T LPDEBUG_EVENT;

typedef SIZE_T LPSTARTUPINFOW;

typedef SIZE_T LPPROCESS_INFORMATION;

#endif
typedef /* [wire_marshal] */ void *HPROCESS;

typedef /* [wire_marshal] */ void *HTHREAD;

typedef UINT64 TASKID;

typedef DWORD CONNID;

#ifndef _COR_IL_MAP
#define _COR_IL_MAP
typedef struct _COR_IL_MAP
    {
    ULONG32 oldOffset;
    ULONG32 newOffset;
    BOOL fAccurate;
    } 	COR_IL_MAP;

#endif //_COR_IL_MAP
#ifndef _COR_DEBUG_IL_TO_NATIVE_MAP_
#define _COR_DEBUG_IL_TO_NATIVE_MAP_
typedef 
enum CorDebugIlToNativeMappingTypes
    {	NO_MAPPING	= -1,
	PROLOG	= -2,
	EPILOG	= -3
    } 	CorDebugIlToNativeMappingTypes;

typedef struct COR_DEBUG_IL_TO_NATIVE_MAP
    {
    ULONG32 ilOffset;
    ULONG32 nativeStartOffset;
    ULONG32 nativeEndOffset;
    } 	COR_DEBUG_IL_TO_NATIVE_MAP;

#endif // _COR_DEBUG_IL_TO_NATIVE_MAP_
#define REMOTE_DEBUGGING_DLL_ENTRY L"Software\\Microsoft\\.NETFramework\\Debugger\\ActivateRemoteDebugging"
typedef 
enum CorDebugJITCompilerFlags
    {	CORDEBUG_JIT_DEFAULT	= 0x1,
	CORDEBUG_JIT_DISABLE_OPTIMIZATION	= 0x3,
	CORDEBUG_JIT_ENABLE_ENC	= 0x7
    } 	CorDebugJITCompilerFlags;

typedef 
enum CorDebugJITCompilerFlagsDecprecated
    {	CORDEBUG_JIT_TRACK_DEBUG_INFO	= 0x1
    } 	CorDebugJITCompilerFlagsDeprecated;
























































typedef ULONG64 CORDB_ADDRESS;

typedef ULONG64 CORDB_REGISTER;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0000_v0_0_s_ifspec;

#ifndef __ICorDebugManagedCallback_INTERFACE_DEFINED__
#define __ICorDebugManagedCallback_INTERFACE_DEFINED__

/* interface ICorDebugManagedCallback */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugStepReason
    {	STEP_NORMAL	= 0,
	STEP_RETURN	= STEP_NORMAL + 1,
	STEP_CALL	= STEP_RETURN + 1,
	STEP_EXCEPTION_FILTER	= STEP_CALL + 1,
	STEP_EXCEPTION_HANDLER	= STEP_EXCEPTION_FILTER + 1,
	STEP_INTERCEPT	= STEP_EXCEPTION_HANDLER + 1,
	STEP_EXIT	= STEP_INTERCEPT + 1
    } 	CorDebugStepReason;

typedef 
enum LoggingLevelEnum
    {	LTraceLevel0	= 0,
	LTraceLevel1	= LTraceLevel0 + 1,
	LTraceLevel2	= LTraceLevel1 + 1,
	LTraceLevel3	= LTraceLevel2 + 1,
	LTraceLevel4	= LTraceLevel3 + 1,
	LStatusLevel0	= 20,
	LStatusLevel1	= LStatusLevel0 + 1,
	LStatusLevel2	= LStatusLevel1 + 1,
	LStatusLevel3	= LStatusLevel2 + 1,
	LStatusLevel4	= LStatusLevel3 + 1,
	LWarningLevel	= 40,
	LErrorLevel	= 50,
	LPanicLevel	= 100
    } 	LoggingLevelEnum;

typedef 
enum LogSwitchCallReason
    {	SWITCH_CREATE	= 0,
	SWITCH_MODIFY	= SWITCH_CREATE + 1,
	SWITCH_DELETE	= SWITCH_MODIFY + 1
    } 	LogSwitchCallReason;


EXTERN_C const IID IID_ICorDebugManagedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f60-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugManagedCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Breakpoint( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepComplete( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugStepper *pStepper,
            /* [in] */ CorDebugStepReason reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Break( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exception( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ BOOL unhandled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EvalComplete( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EvalException( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateProcess( 
            /* [in] */ ICorDebugProcess *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitProcess( 
            /* [in] */ ICorDebugProcess *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateThread( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitThread( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadModule( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadModule( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadClass( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadClass( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebuggerError( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ HRESULT errorHR,
            /* [in] */ DWORD errorCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogMessage( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogSwitch( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ ULONG ulReason,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pParentName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAppDomain( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitAppDomain( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadAssembly( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadAssembly( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ControlCTrap( 
            /* [in] */ ICorDebugProcess *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NameChange( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateModuleSymbols( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule,
            /* [in] */ IStream *pSymbolStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EditAndContinueRemap( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ BOOL fAccurate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BreakpointSetError( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint,
            /* [in] */ DWORD dwError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugManagedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugManagedCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugManagedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugManagedCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Breakpoint )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *StepComplete )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugStepper *pStepper,
            /* [in] */ CorDebugStepReason reason);
        
        HRESULT ( STDMETHODCALLTYPE *Break )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread);
        
        HRESULT ( STDMETHODCALLTYPE *Exception )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ BOOL unhandled);
        
        HRESULT ( STDMETHODCALLTYPE *EvalComplete )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval);
        
        HRESULT ( STDMETHODCALLTYPE *EvalException )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProcess )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *ExitProcess )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *CreateThread )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread);
        
        HRESULT ( STDMETHODCALLTYPE *ExitThread )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread);
        
        HRESULT ( STDMETHODCALLTYPE *LoadModule )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadModule )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule);
        
        HRESULT ( STDMETHODCALLTYPE *LoadClass )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadClass )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c);
        
        HRESULT ( STDMETHODCALLTYPE *DebuggerError )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ HRESULT errorHR,
            /* [in] */ DWORD errorCode);
        
        HRESULT ( STDMETHODCALLTYPE *LogMessage )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pMessage);
        
        HRESULT ( STDMETHODCALLTYPE *LogSwitch )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ ULONG ulReason,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pParentName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAppDomain )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *ExitAppDomain )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *LoadAssembly )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadAssembly )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly);
        
        HRESULT ( STDMETHODCALLTYPE *ControlCTrap )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *NameChange )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateModuleSymbols )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule,
            /* [in] */ IStream *pSymbolStream);
        
        HRESULT ( STDMETHODCALLTYPE *EditAndContinueRemap )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ BOOL fAccurate);
        
        HRESULT ( STDMETHODCALLTYPE *BreakpointSetError )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint,
            /* [in] */ DWORD dwError);
        
        END_INTERFACE
    } ICorDebugManagedCallbackVtbl;

    interface ICorDebugManagedCallback
    {
        CONST_VTBL struct ICorDebugManagedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugManagedCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugManagedCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugManagedCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugManagedCallback_Breakpoint(This,pAppDomain,pThread,pBreakpoint)	\
    (This)->lpVtbl -> Breakpoint(This,pAppDomain,pThread,pBreakpoint)

#define ICorDebugManagedCallback_StepComplete(This,pAppDomain,pThread,pStepper,reason)	\
    (This)->lpVtbl -> StepComplete(This,pAppDomain,pThread,pStepper,reason)

#define ICorDebugManagedCallback_Break(This,pAppDomain,thread)	\
    (This)->lpVtbl -> Break(This,pAppDomain,thread)

#define ICorDebugManagedCallback_Exception(This,pAppDomain,pThread,unhandled)	\
    (This)->lpVtbl -> Exception(This,pAppDomain,pThread,unhandled)

#define ICorDebugManagedCallback_EvalComplete(This,pAppDomain,pThread,pEval)	\
    (This)->lpVtbl -> EvalComplete(This,pAppDomain,pThread,pEval)

#define ICorDebugManagedCallback_EvalException(This,pAppDomain,pThread,pEval)	\
    (This)->lpVtbl -> EvalException(This,pAppDomain,pThread,pEval)

#define ICorDebugManagedCallback_CreateProcess(This,pProcess)	\
    (This)->lpVtbl -> CreateProcess(This,pProcess)

#define ICorDebugManagedCallback_ExitProcess(This,pProcess)	\
    (This)->lpVtbl -> ExitProcess(This,pProcess)

#define ICorDebugManagedCallback_CreateThread(This,pAppDomain,thread)	\
    (This)->lpVtbl -> CreateThread(This,pAppDomain,thread)

#define ICorDebugManagedCallback_ExitThread(This,pAppDomain,thread)	\
    (This)->lpVtbl -> ExitThread(This,pAppDomain,thread)

#define ICorDebugManagedCallback_LoadModule(This,pAppDomain,pModule)	\
    (This)->lpVtbl -> LoadModule(This,pAppDomain,pModule)

#define ICorDebugManagedCallback_UnloadModule(This,pAppDomain,pModule)	\
    (This)->lpVtbl -> UnloadModule(This,pAppDomain,pModule)

#define ICorDebugManagedCallback_LoadClass(This,pAppDomain,c)	\
    (This)->lpVtbl -> LoadClass(This,pAppDomain,c)

#define ICorDebugManagedCallback_UnloadClass(This,pAppDomain,c)	\
    (This)->lpVtbl -> UnloadClass(This,pAppDomain,c)

#define ICorDebugManagedCallback_DebuggerError(This,pProcess,errorHR,errorCode)	\
    (This)->lpVtbl -> DebuggerError(This,pProcess,errorHR,errorCode)

#define ICorDebugManagedCallback_LogMessage(This,pAppDomain,pThread,lLevel,pLogSwitchName,pMessage)	\
    (This)->lpVtbl -> LogMessage(This,pAppDomain,pThread,lLevel,pLogSwitchName,pMessage)

#define ICorDebugManagedCallback_LogSwitch(This,pAppDomain,pThread,lLevel,ulReason,pLogSwitchName,pParentName)	\
    (This)->lpVtbl -> LogSwitch(This,pAppDomain,pThread,lLevel,ulReason,pLogSwitchName,pParentName)

#define ICorDebugManagedCallback_CreateAppDomain(This,pProcess,pAppDomain)	\
    (This)->lpVtbl -> CreateAppDomain(This,pProcess,pAppDomain)

#define ICorDebugManagedCallback_ExitAppDomain(This,pProcess,pAppDomain)	\
    (This)->lpVtbl -> ExitAppDomain(This,pProcess,pAppDomain)

#define ICorDebugManagedCallback_LoadAssembly(This,pAppDomain,pAssembly)	\
    (This)->lpVtbl -> LoadAssembly(This,pAppDomain,pAssembly)

#define ICorDebugManagedCallback_UnloadAssembly(This,pAppDomain,pAssembly)	\
    (This)->lpVtbl -> UnloadAssembly(This,pAppDomain,pAssembly)

#define ICorDebugManagedCallback_ControlCTrap(This,pProcess)	\
    (This)->lpVtbl -> ControlCTrap(This,pProcess)

#define ICorDebugManagedCallback_NameChange(This,pAppDomain,pThread)	\
    (This)->lpVtbl -> NameChange(This,pAppDomain,pThread)

#define ICorDebugManagedCallback_UpdateModuleSymbols(This,pAppDomain,pModule,pSymbolStream)	\
    (This)->lpVtbl -> UpdateModuleSymbols(This,pAppDomain,pModule,pSymbolStream)

#define ICorDebugManagedCallback_EditAndContinueRemap(This,pAppDomain,pThread,pFunction,fAccurate)	\
    (This)->lpVtbl -> EditAndContinueRemap(This,pAppDomain,pThread,pFunction,fAccurate)

#define ICorDebugManagedCallback_BreakpointSetError(This,pAppDomain,pThread,pBreakpoint,dwError)	\
    (This)->lpVtbl -> BreakpointSetError(This,pAppDomain,pThread,pBreakpoint,dwError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_Breakpoint_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugBreakpoint *pBreakpoint);


void __RPC_STUB ICorDebugManagedCallback_Breakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_StepComplete_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugStepper *pStepper,
    /* [in] */ CorDebugStepReason reason);


void __RPC_STUB ICorDebugManagedCallback_StepComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_Break_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *thread);


void __RPC_STUB ICorDebugManagedCallback_Break_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_Exception_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ BOOL unhandled);


void __RPC_STUB ICorDebugManagedCallback_Exception_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_EvalComplete_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugEval *pEval);


void __RPC_STUB ICorDebugManagedCallback_EvalComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_EvalException_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugEval *pEval);


void __RPC_STUB ICorDebugManagedCallback_EvalException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_CreateProcess_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess);


void __RPC_STUB ICorDebugManagedCallback_CreateProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ExitProcess_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess);


void __RPC_STUB ICorDebugManagedCallback_ExitProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_CreateThread_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *thread);


void __RPC_STUB ICorDebugManagedCallback_CreateThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ExitThread_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *thread);


void __RPC_STUB ICorDebugManagedCallback_ExitThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LoadModule_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugModule *pModule);


void __RPC_STUB ICorDebugManagedCallback_LoadModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UnloadModule_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugModule *pModule);


void __RPC_STUB ICorDebugManagedCallback_UnloadModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LoadClass_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugClass *c);


void __RPC_STUB ICorDebugManagedCallback_LoadClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UnloadClass_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugClass *c);


void __RPC_STUB ICorDebugManagedCallback_UnloadClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_DebuggerError_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ HRESULT errorHR,
    /* [in] */ DWORD errorCode);


void __RPC_STUB ICorDebugManagedCallback_DebuggerError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LogMessage_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ LONG lLevel,
    /* [in] */ WCHAR *pLogSwitchName,
    /* [in] */ WCHAR *pMessage);


void __RPC_STUB ICorDebugManagedCallback_LogMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LogSwitch_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ LONG lLevel,
    /* [in] */ ULONG ulReason,
    /* [in] */ WCHAR *pLogSwitchName,
    /* [in] */ WCHAR *pParentName);


void __RPC_STUB ICorDebugManagedCallback_LogSwitch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_CreateAppDomain_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ ICorDebugAppDomain *pAppDomain);


void __RPC_STUB ICorDebugManagedCallback_CreateAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ExitAppDomain_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ ICorDebugAppDomain *pAppDomain);


void __RPC_STUB ICorDebugManagedCallback_ExitAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LoadAssembly_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugAssembly *pAssembly);


void __RPC_STUB ICorDebugManagedCallback_LoadAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UnloadAssembly_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugAssembly *pAssembly);


void __RPC_STUB ICorDebugManagedCallback_UnloadAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ControlCTrap_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess);


void __RPC_STUB ICorDebugManagedCallback_ControlCTrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_NameChange_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread);


void __RPC_STUB ICorDebugManagedCallback_NameChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UpdateModuleSymbols_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugModule *pModule,
    /* [in] */ IStream *pSymbolStream);


void __RPC_STUB ICorDebugManagedCallback_UpdateModuleSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_EditAndContinueRemap_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugFunction *pFunction,
    /* [in] */ BOOL fAccurate);


void __RPC_STUB ICorDebugManagedCallback_EditAndContinueRemap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_BreakpointSetError_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugBreakpoint *pBreakpoint,
    /* [in] */ DWORD dwError);


void __RPC_STUB ICorDebugManagedCallback_BreakpointSetError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugManagedCallback_INTERFACE_DEFINED__ */


#ifndef __ICorDebugManagedCallback2_INTERFACE_DEFINED__
#define __ICorDebugManagedCallback2_INTERFACE_DEFINED__

/* interface ICorDebugManagedCallback2 */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugExceptionCallbackType
    {	DEBUG_EXCEPTION_FIRST_CHANCE	= 1,
	DEBUG_EXCEPTION_USER_FIRST_CHANCE	= 2,
	DEBUG_EXCEPTION_CATCH_HANDLER_FOUND	= 3,
	DEBUG_EXCEPTION_UNHANDLED	= 4
    } 	CorDebugExceptionCallbackType;

typedef 
enum CorDebugExceptionFlags
    {	DEBUG_EXCEPTION_CAN_BE_INTERCEPTED	= 0x1
    } 	CorDebugExceptionFlags;

typedef 
enum CorDebugExceptionUnwindCallbackType
    {	DEBUG_EXCEPTION_UNWIND_BEGIN	= 1,
	DEBUG_EXCEPTION_INTERCEPTED	= 2
    } 	CorDebugExceptionUnwindCallbackType;


EXTERN_C const IID IID_ICorDebugManagedCallback2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("250E5EEA-DB5C-4C76-B6F3-8C46F12E3203")
    ICorDebugManagedCallback2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FunctionRemapOpportunity( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pOldFunction,
            /* [in] */ ICorDebugFunction *pNewFunction,
            /* [in] */ ULONG32 oldILOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateConnection( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId,
            /* [in] */ WCHAR *pConnName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeConnection( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyConnection( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exception( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [in] */ ULONG32 nOffset,
            /* [in] */ CorDebugExceptionCallbackType dwEventType,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwind( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ CorDebugExceptionUnwindCallbackType dwEventType,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FunctionRemapComplete( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MDANotification( 
            /* [in] */ ICorDebugController *pController,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugMDA *pMDA) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugManagedCallback2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugManagedCallback2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugManagedCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *FunctionRemapOpportunity )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pOldFunction,
            /* [in] */ ICorDebugFunction *pNewFunction,
            /* [in] */ ULONG32 oldILOffset);
        
        HRESULT ( STDMETHODCALLTYPE *CreateConnection )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId,
            /* [in] */ WCHAR *pConnName);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeConnection )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyConnection )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId);
        
        HRESULT ( STDMETHODCALLTYPE *Exception )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [in] */ ULONG32 nOffset,
            /* [in] */ CorDebugExceptionCallbackType dwEventType,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwind )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ CorDebugExceptionUnwindCallbackType dwEventType,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *FunctionRemapComplete )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pFunction);
        
        HRESULT ( STDMETHODCALLTYPE *MDANotification )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugController *pController,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugMDA *pMDA);
        
        END_INTERFACE
    } ICorDebugManagedCallback2Vtbl;

    interface ICorDebugManagedCallback2
    {
        CONST_VTBL struct ICorDebugManagedCallback2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugManagedCallback2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugManagedCallback2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugManagedCallback2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugManagedCallback2_FunctionRemapOpportunity(This,pAppDomain,pThread,pOldFunction,pNewFunction,oldILOffset)	\
    (This)->lpVtbl -> FunctionRemapOpportunity(This,pAppDomain,pThread,pOldFunction,pNewFunction,oldILOffset)

#define ICorDebugManagedCallback2_CreateConnection(This,pProcess,dwConnectionId,pConnName)	\
    (This)->lpVtbl -> CreateConnection(This,pProcess,dwConnectionId,pConnName)

#define ICorDebugManagedCallback2_ChangeConnection(This,pProcess,dwConnectionId)	\
    (This)->lpVtbl -> ChangeConnection(This,pProcess,dwConnectionId)

#define ICorDebugManagedCallback2_DestroyConnection(This,pProcess,dwConnectionId)	\
    (This)->lpVtbl -> DestroyConnection(This,pProcess,dwConnectionId)

#define ICorDebugManagedCallback2_Exception(This,pAppDomain,pThread,pFrame,nOffset,dwEventType,dwFlags)	\
    (This)->lpVtbl -> Exception(This,pAppDomain,pThread,pFrame,nOffset,dwEventType,dwFlags)

#define ICorDebugManagedCallback2_ExceptionUnwind(This,pAppDomain,pThread,dwEventType,dwFlags)	\
    (This)->lpVtbl -> ExceptionUnwind(This,pAppDomain,pThread,dwEventType,dwFlags)

#define ICorDebugManagedCallback2_FunctionRemapComplete(This,pAppDomain,pThread,pFunction)	\
    (This)->lpVtbl -> FunctionRemapComplete(This,pAppDomain,pThread,pFunction)

#define ICorDebugManagedCallback2_MDANotification(This,pController,pThread,pMDA)	\
    (This)->lpVtbl -> MDANotification(This,pController,pThread,pMDA)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_FunctionRemapOpportunity_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugFunction *pOldFunction,
    /* [in] */ ICorDebugFunction *pNewFunction,
    /* [in] */ ULONG32 oldILOffset);


void __RPC_STUB ICorDebugManagedCallback2_FunctionRemapOpportunity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_CreateConnection_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ CONNID dwConnectionId,
    /* [in] */ WCHAR *pConnName);


void __RPC_STUB ICorDebugManagedCallback2_CreateConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_ChangeConnection_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ CONNID dwConnectionId);


void __RPC_STUB ICorDebugManagedCallback2_ChangeConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_DestroyConnection_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ CONNID dwConnectionId);


void __RPC_STUB ICorDebugManagedCallback2_DestroyConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_Exception_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugFrame *pFrame,
    /* [in] */ ULONG32 nOffset,
    /* [in] */ CorDebugExceptionCallbackType dwEventType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICorDebugManagedCallback2_Exception_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_ExceptionUnwind_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ CorDebugExceptionUnwindCallbackType dwEventType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICorDebugManagedCallback2_ExceptionUnwind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_FunctionRemapComplete_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugFunction *pFunction);


void __RPC_STUB ICorDebugManagedCallback2_FunctionRemapComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_MDANotification_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugController *pController,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugMDA *pMDA);


void __RPC_STUB ICorDebugManagedCallback2_MDANotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugManagedCallback2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugUnmanagedCallback_INTERFACE_DEFINED__
#define __ICorDebugUnmanagedCallback_INTERFACE_DEFINED__

/* interface ICorDebugUnmanagedCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugUnmanagedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5263E909-8CB5-11d3-BD2F-0000F80849BD")
    ICorDebugUnmanagedCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DebugEvent( 
            /* [in] */ LPDEBUG_EVENT pDebugEvent,
            /* [in] */ BOOL fOutOfBand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugUnmanagedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugUnmanagedCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugUnmanagedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugUnmanagedCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *DebugEvent )( 
            ICorDebugUnmanagedCallback * This,
            /* [in] */ LPDEBUG_EVENT pDebugEvent,
            /* [in] */ BOOL fOutOfBand);
        
        END_INTERFACE
    } ICorDebugUnmanagedCallbackVtbl;

    interface ICorDebugUnmanagedCallback
    {
        CONST_VTBL struct ICorDebugUnmanagedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugUnmanagedCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugUnmanagedCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugUnmanagedCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugUnmanagedCallback_DebugEvent(This,pDebugEvent,fOutOfBand)	\
    (This)->lpVtbl -> DebugEvent(This,pDebugEvent,fOutOfBand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugUnmanagedCallback_DebugEvent_Proxy( 
    ICorDebugUnmanagedCallback * This,
    /* [in] */ LPDEBUG_EVENT pDebugEvent,
    /* [in] */ BOOL fOutOfBand);


void __RPC_STUB ICorDebugUnmanagedCallback_DebugEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugUnmanagedCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cordebug_0096 */
/* [local] */ 

typedef 
enum CorDebugCreateProcessFlags
    {	DEBUG_NO_SPECIAL_OPTIONS	= 0
    } 	CorDebugCreateProcessFlags;

typedef 
enum CorDebugHandleType
    {	HANDLE_STRONG	= 1,
	HANDLE_WEAK_TRACK_RESURRECTION	= 2
    } 	CorDebugHandleType;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0096_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0096_v0_0_s_ifspec;

#ifndef __ICorDebug_INTERFACE_DEFINED__
#define __ICorDebug_INTERFACE_DEFINED__

/* interface ICorDebug */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICorDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f61-7538-11d3-8d5b-00104b35e7ef")
    ICorDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetManagedHandler( 
            /* [in] */ ICorDebugManagedCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnmanagedHandler( 
            /* [in] */ ICorDebugUnmanagedCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateProcess( 
            /* [in] */ LPCWSTR lpApplicationName,
            /* [in] */ LPWSTR lpCommandLine,
            /* [in] */ LPSECURITY_ATTRIBUTES lpProcessAttributes,
            /* [in] */ LPSECURITY_ATTRIBUTES lpThreadAttributes,
            /* [in] */ BOOL bInheritHandles,
            /* [in] */ DWORD dwCreationFlags,
            /* [in] */ PVOID lpEnvironment,
            /* [in] */ LPCWSTR lpCurrentDirectory,
            /* [in] */ LPSTARTUPINFOW lpStartupInfo,
            /* [in] */ LPPROCESS_INFORMATION lpProcessInformation,
            /* [in] */ CorDebugCreateProcessFlags debuggingFlags,
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebugActiveProcess( 
            /* [in] */ DWORD id,
            /* [in] */ BOOL win32Attach,
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateProcesses( 
            /* [out] */ ICorDebugProcessEnum **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [in] */ DWORD dwProcessId,
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanLaunchOrAttach( 
            /* [in] */ DWORD dwProcessId,
            /* [in] */ BOOL win32DebuggingEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebug * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICorDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetManagedHandler )( 
            ICorDebug * This,
            /* [in] */ ICorDebugManagedCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnmanagedHandler )( 
            ICorDebug * This,
            /* [in] */ ICorDebugUnmanagedCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProcess )( 
            ICorDebug * This,
            /* [in] */ LPCWSTR lpApplicationName,
            /* [in] */ LPWSTR lpCommandLine,
            /* [in] */ LPSECURITY_ATTRIBUTES lpProcessAttributes,
            /* [in] */ LPSECURITY_ATTRIBUTES lpThreadAttributes,
            /* [in] */ BOOL bInheritHandles,
            /* [in] */ DWORD dwCreationFlags,
            /* [in] */ PVOID lpEnvironment,
            /* [in] */ LPCWSTR lpCurrentDirectory,
            /* [in] */ LPSTARTUPINFOW lpStartupInfo,
            /* [in] */ LPPROCESS_INFORMATION lpProcessInformation,
            /* [in] */ CorDebugCreateProcessFlags debuggingFlags,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *DebugActiveProcess )( 
            ICorDebug * This,
            /* [in] */ DWORD id,
            /* [in] */ BOOL win32Attach,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateProcesses )( 
            ICorDebug * This,
            /* [out] */ ICorDebugProcessEnum **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebug * This,
            /* [in] */ DWORD dwProcessId,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *CanLaunchOrAttach )( 
            ICorDebug * This,
            /* [in] */ DWORD dwProcessId,
            /* [in] */ BOOL win32DebuggingEnabled);
        
        END_INTERFACE
    } ICorDebugVtbl;

    interface ICorDebug
    {
        CONST_VTBL struct ICorDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebug_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define ICorDebug_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#define ICorDebug_SetManagedHandler(This,pCallback)	\
    (This)->lpVtbl -> SetManagedHandler(This,pCallback)

#define ICorDebug_SetUnmanagedHandler(This,pCallback)	\
    (This)->lpVtbl -> SetUnmanagedHandler(This,pCallback)

#define ICorDebug_CreateProcess(This,lpApplicationName,lpCommandLine,lpProcessAttributes,lpThreadAttributes,bInheritHandles,dwCreationFlags,lpEnvironment,lpCurrentDirectory,lpStartupInfo,lpProcessInformation,debuggingFlags,ppProcess)	\
    (This)->lpVtbl -> CreateProcess(This,lpApplicationName,lpCommandLine,lpProcessAttributes,lpThreadAttributes,bInheritHandles,dwCreationFlags,lpEnvironment,lpCurrentDirectory,lpStartupInfo,lpProcessInformation,debuggingFlags,ppProcess)

#define ICorDebug_DebugActiveProcess(This,id,win32Attach,ppProcess)	\
    (This)->lpVtbl -> DebugActiveProcess(This,id,win32Attach,ppProcess)

#define ICorDebug_EnumerateProcesses(This,ppProcess)	\
    (This)->lpVtbl -> EnumerateProcesses(This,ppProcess)

#define ICorDebug_GetProcess(This,dwProcessId,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,dwProcessId,ppProcess)

#define ICorDebug_CanLaunchOrAttach(This,dwProcessId,win32DebuggingEnabled)	\
    (This)->lpVtbl -> CanLaunchOrAttach(This,dwProcessId,win32DebuggingEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebug_Initialize_Proxy( 
    ICorDebug * This);


void __RPC_STUB ICorDebug_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_Terminate_Proxy( 
    ICorDebug * This);


void __RPC_STUB ICorDebug_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_SetManagedHandler_Proxy( 
    ICorDebug * This,
    /* [in] */ ICorDebugManagedCallback *pCallback);


void __RPC_STUB ICorDebug_SetManagedHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_SetUnmanagedHandler_Proxy( 
    ICorDebug * This,
    /* [in] */ ICorDebugUnmanagedCallback *pCallback);


void __RPC_STUB ICorDebug_SetUnmanagedHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_CreateProcess_Proxy( 
    ICorDebug * This,
    /* [in] */ LPCWSTR lpApplicationName,
    /* [in] */ LPWSTR lpCommandLine,
    /* [in] */ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    /* [in] */ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    /* [in] */ BOOL bInheritHandles,
    /* [in] */ DWORD dwCreationFlags,
    /* [in] */ PVOID lpEnvironment,
    /* [in] */ LPCWSTR lpCurrentDirectory,
    /* [in] */ LPSTARTUPINFOW lpStartupInfo,
    /* [in] */ LPPROCESS_INFORMATION lpProcessInformation,
    /* [in] */ CorDebugCreateProcessFlags debuggingFlags,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebug_CreateProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_DebugActiveProcess_Proxy( 
    ICorDebug * This,
    /* [in] */ DWORD id,
    /* [in] */ BOOL win32Attach,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebug_DebugActiveProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_EnumerateProcesses_Proxy( 
    ICorDebug * This,
    /* [out] */ ICorDebugProcessEnum **ppProcess);


void __RPC_STUB ICorDebug_EnumerateProcesses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_GetProcess_Proxy( 
    ICorDebug * This,
    /* [in] */ DWORD dwProcessId,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebug_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_CanLaunchOrAttach_Proxy( 
    ICorDebug * This,
    /* [in] */ DWORD dwProcessId,
    /* [in] */ BOOL win32DebuggingEnabled);


void __RPC_STUB ICorDebug_CanLaunchOrAttach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebug_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cordebug_0097 */
/* [local] */ 

typedef struct _COR_VERSION
    {
    DWORD dwMajor;
    DWORD dwMinor;
    DWORD dwBuild;
    DWORD dwSubBuild;
    } 	COR_VERSION;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0097_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0097_v0_0_s_ifspec;

#ifndef __ICorDebug2_INTERFACE_DEFINED__
#define __ICorDebug2_INTERFACE_DEFINED__

/* interface ICorDebug2 */
/* [unique][uuid][local][object] */ 

typedef 
enum CorDebugInterfaceVersion
    {	CorDebugInvalidVersion	= 0,
	CorDebugVersion_1_0	= CorDebugInvalidVersion + 1,
	ver_ICorDebugManagedCallback	= CorDebugVersion_1_0,
	ver_ICorDebugUnmanagedCallback	= CorDebugVersion_1_0,
	ver_ICorDebug	= CorDebugVersion_1_0,
	ver_ICorDebugController	= CorDebugVersion_1_0,
	ver_ICorDebugAppDomain	= CorDebugVersion_1_0,
	ver_ICorDebugAssembly	= CorDebugVersion_1_0,
	ver_ICorDebugProcess	= CorDebugVersion_1_0,
	ver_ICorDebugBreakpoint	= CorDebugVersion_1_0,
	ver_ICorDebugFunctionBreakpoint	= CorDebugVersion_1_0,
	ver_ICorDebugModuleBreakpoint	= CorDebugVersion_1_0,
	ver_ICorDebugValueBreakpoint	= CorDebugVersion_1_0,
	ver_ICorDebugStepper	= CorDebugVersion_1_0,
	ver_ICorDebugRegisterSet	= CorDebugVersion_1_0,
	ver_ICorDebugThread	= CorDebugVersion_1_0,
	ver_ICorDebugChain	= CorDebugVersion_1_0,
	ver_ICorDebugFrame	= CorDebugVersion_1_0,
	ver_ICorDebugILFrame	= CorDebugVersion_1_0,
	ver_ICorDebugNativeFrame	= CorDebugVersion_1_0,
	ver_ICorDebugModule	= CorDebugVersion_1_0,
	ver_ICorDebugFunction	= CorDebugVersion_1_0,
	ver_ICorDebugCode	= CorDebugVersion_1_0,
	ver_ICorDebugClass	= CorDebugVersion_1_0,
	ver_ICorDebugEval	= CorDebugVersion_1_0,
	ver_ICorDebugValue	= CorDebugVersion_1_0,
	ver_ICorDebugGenericValue	= CorDebugVersion_1_0,
	ver_ICorDebugReferenceValue	= CorDebugVersion_1_0,
	ver_ICorDebugHeapValue	= CorDebugVersion_1_0,
	ver_ICorDebugObjectValue	= CorDebugVersion_1_0,
	ver_ICorDebugBoxValue	= CorDebugVersion_1_0,
	ver_ICorDebugStringValue	= CorDebugVersion_1_0,
	ver_ICorDebugArrayValue	= CorDebugVersion_1_0,
	ver_ICorDebugContext	= CorDebugVersion_1_0,
	ver_ICorDebugEnum	= CorDebugVersion_1_0,
	ver_ICorDebugObjectEnum	= CorDebugVersion_1_0,
	ver_ICorDebugBreakpointEnum	= CorDebugVersion_1_0,
	ver_ICorDebugStepperEnum	= CorDebugVersion_1_0,
	ver_ICorDebugProcessEnum	= CorDebugVersion_1_0,
	ver_ICorDebugThreadEnum	= CorDebugVersion_1_0,
	ver_ICorDebugFrameEnum	= CorDebugVersion_1_0,
	ver_ICorDebugChainEnum	= CorDebugVersion_1_0,
	ver_ICorDebugModuleEnum	= CorDebugVersion_1_0,
	ver_ICorDebugValueEnum	= CorDebugVersion_1_0,
	ver_ICorDebugCodeEnum	= CorDebugVersion_1_0,
	ver_ICorDebugTypeEnum	= CorDebugVersion_1_0,
	ver_ICorDebugErrorInfoEnum	= CorDebugVersion_1_0,
	ver_ICorDebugAppDomainEnum	= CorDebugVersion_1_0,
	ver_ICorDebugAssemblyEnum	= CorDebugVersion_1_0,
	ver_ICorDebugEditAndContinueErrorInfo	= CorDebugVersion_1_0,
	ver_ICorDebugEditAndContinueSnapshot	= CorDebugVersion_1_0,
	CorDebugVersion_1_1	= CorDebugVersion_1_0 + 1,
	CorDebugVersion_2_0	= CorDebugVersion_1_1 + 1,
	ver_ICorDebugManagedCallback2	= CorDebugVersion_2_0,
	ver_ICorDebugAppDomain2	= CorDebugVersion_2_0,
	ver_ICorDebugAssembly2	= CorDebugVersion_2_0,
	ver_ICorDebugProcess2	= CorDebugVersion_2_0,
	ver_ICorDebugStepper2	= CorDebugVersion_2_0,
	ver_ICorDebugRegisterSet2	= CorDebugVersion_2_0,
	ver_ICorDebugThread2	= CorDebugVersion_2_0,
	ver_ICorDebugILFrame2	= CorDebugVersion_2_0,
	ver_ICorDebugModule2	= CorDebugVersion_2_0,
	ver_ICorDebugFunction2	= CorDebugVersion_2_0,
	ver_ICorDebugCode2	= CorDebugVersion_2_0,
	ver_ICorDebugClass2	= CorDebugVersion_2_0,
	ver_ICorDebugValue2	= CorDebugVersion_2_0,
	ver_ICorDebugEval2	= CorDebugVersion_2_0,
	ver_ICorDebugObjectValue2	= CorDebugVersion_2_0,
	CorDebugLatestVersion	= CorDebugVersion_2_0
    } 	CorDebugInterfaceVersion;


EXTERN_C const IID IID_ICorDebug2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ECCCCF2E-B286-4b3e-A983-860A8793D105")
    ICorDebug2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICorDebug2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebug2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebug2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebug2 * This);
        
        END_INTERFACE
    } ICorDebug2Vtbl;

    interface ICorDebug2
    {
        CONST_VTBL struct ICorDebug2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebug2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebug2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebug2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICorDebug2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cordebug_0098 */
/* [local] */ 

typedef 
enum CorDebugThreadState
    {	THREAD_RUN	= 0,
	THREAD_SUSPEND	= THREAD_RUN + 1
    } 	CorDebugThreadState;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0098_v0_0_s_ifspec;

#ifndef __ICorDebugController_INTERFACE_DEFINED__
#define __ICorDebugController_INTERFACE_DEFINED__

/* interface ICorDebugController */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f62-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugController : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ DWORD dwTimeoutIgnored) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( 
            /* [in] */ BOOL fIsOutOfBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRunning( 
            /* [out] */ BOOL *pbRunning) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasQueuedCallbacks( 
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateThreads( 
            /* [out] */ ICorDebugThreadEnum **ppThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllThreadsDebugState( 
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ UINT exitCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanCommitChanges( 
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitChanges( 
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugController * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugController * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorDebugController * This,
            /* [in] */ DWORD dwTimeoutIgnored);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            ICorDebugController * This,
            /* [in] */ BOOL fIsOutOfBand);
        
        HRESULT ( STDMETHODCALLTYPE *IsRunning )( 
            ICorDebugController * This,
            /* [out] */ BOOL *pbRunning);
        
        HRESULT ( STDMETHODCALLTYPE *HasQueuedCallbacks )( 
            ICorDebugController * This,
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateThreads )( 
            ICorDebugController * This,
            /* [out] */ ICorDebugThreadEnum **ppThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllThreadsDebugState )( 
            ICorDebugController * This,
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            ICorDebugController * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebugController * This,
            /* [in] */ UINT exitCode);
        
        HRESULT ( STDMETHODCALLTYPE *CanCommitChanges )( 
            ICorDebugController * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            ICorDebugController * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        END_INTERFACE
    } ICorDebugControllerVtbl;

    interface ICorDebugController
    {
        CONST_VTBL struct ICorDebugControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugController_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugController_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugController_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugController_Stop(This,dwTimeoutIgnored)	\
    (This)->lpVtbl -> Stop(This,dwTimeoutIgnored)

#define ICorDebugController_Continue(This,fIsOutOfBand)	\
    (This)->lpVtbl -> Continue(This,fIsOutOfBand)

#define ICorDebugController_IsRunning(This,pbRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbRunning)

#define ICorDebugController_HasQueuedCallbacks(This,pThread,pbQueued)	\
    (This)->lpVtbl -> HasQueuedCallbacks(This,pThread,pbQueued)

#define ICorDebugController_EnumerateThreads(This,ppThreads)	\
    (This)->lpVtbl -> EnumerateThreads(This,ppThreads)

#define ICorDebugController_SetAllThreadsDebugState(This,state,pExceptThisThread)	\
    (This)->lpVtbl -> SetAllThreadsDebugState(This,state,pExceptThisThread)

#define ICorDebugController_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define ICorDebugController_Terminate(This,exitCode)	\
    (This)->lpVtbl -> Terminate(This,exitCode)

#define ICorDebugController_CanCommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CanCommitChanges(This,cSnapshots,pSnapshots,pError)

#define ICorDebugController_CommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CommitChanges(This,cSnapshots,pSnapshots,pError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugController_Stop_Proxy( 
    ICorDebugController * This,
    /* [in] */ DWORD dwTimeoutIgnored);


void __RPC_STUB ICorDebugController_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_Continue_Proxy( 
    ICorDebugController * This,
    /* [in] */ BOOL fIsOutOfBand);


void __RPC_STUB ICorDebugController_Continue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_IsRunning_Proxy( 
    ICorDebugController * This,
    /* [out] */ BOOL *pbRunning);


void __RPC_STUB ICorDebugController_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_HasQueuedCallbacks_Proxy( 
    ICorDebugController * This,
    /* [in] */ ICorDebugThread *pThread,
    /* [out] */ BOOL *pbQueued);


void __RPC_STUB ICorDebugController_HasQueuedCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_EnumerateThreads_Proxy( 
    ICorDebugController * This,
    /* [out] */ ICorDebugThreadEnum **ppThreads);


void __RPC_STUB ICorDebugController_EnumerateThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_SetAllThreadsDebugState_Proxy( 
    ICorDebugController * This,
    /* [in] */ CorDebugThreadState state,
    /* [in] */ ICorDebugThread *pExceptThisThread);


void __RPC_STUB ICorDebugController_SetAllThreadsDebugState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_Detach_Proxy( 
    ICorDebugController * This);


void __RPC_STUB ICorDebugController_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_Terminate_Proxy( 
    ICorDebugController * This,
    /* [in] */ UINT exitCode);


void __RPC_STUB ICorDebugController_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_CanCommitChanges_Proxy( 
    ICorDebugController * This,
    /* [in] */ ULONG cSnapshots,
    /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
    /* [out] */ ICorDebugErrorInfoEnum **pError);


void __RPC_STUB ICorDebugController_CanCommitChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_CommitChanges_Proxy( 
    ICorDebugController * This,
    /* [in] */ ULONG cSnapshots,
    /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
    /* [out] */ ICorDebugErrorInfoEnum **pError);


void __RPC_STUB ICorDebugController_CommitChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugController_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAppDomain_INTERFACE_DEFINED__
#define __ICorDebugAppDomain_INTERFACE_DEFINED__

/* interface ICorDebugAppDomain */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAppDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f63-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugAppDomain : public ICorDebugController
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAssemblies( 
            /* [out] */ ICorDebugAssemblyEnum **ppAssemblies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleFromMetaDataInterface( 
            /* [in] */ IUnknown *pIMetaData,
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateBreakpoints( 
            /* [out] */ ICorDebugBreakpointEnum **ppBreakpoints) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateSteppers( 
            /* [out] */ ICorDebugStepperEnum **ppSteppers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAttached( 
            /* [out] */ BOOL *pbAttached) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugValue **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ ULONG32 *pId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAppDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAppDomain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAppDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorDebugAppDomain * This,
            /* [in] */ DWORD dwTimeoutIgnored);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            ICorDebugAppDomain * This,
            /* [in] */ BOOL fIsOutOfBand);
        
        HRESULT ( STDMETHODCALLTYPE *IsRunning )( 
            ICorDebugAppDomain * This,
            /* [out] */ BOOL *pbRunning);
        
        HRESULT ( STDMETHODCALLTYPE *HasQueuedCallbacks )( 
            ICorDebugAppDomain * This,
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateThreads )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugThreadEnum **ppThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllThreadsDebugState )( 
            ICorDebugAppDomain * This,
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            ICorDebugAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebugAppDomain * This,
            /* [in] */ UINT exitCode);
        
        HRESULT ( STDMETHODCALLTYPE *CanCommitChanges )( 
            ICorDebugAppDomain * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            ICorDebugAppDomain * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAssemblies )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugAssemblyEnum **ppAssemblies);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleFromMetaDataInterface )( 
            ICorDebugAppDomain * This,
            /* [in] */ IUnknown *pIMetaData,
            /* [out] */ ICorDebugModule **ppModule);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateBreakpoints )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugBreakpointEnum **ppBreakpoints);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateSteppers )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugStepperEnum **ppSteppers);
        
        HRESULT ( STDMETHODCALLTYPE *IsAttached )( 
            ICorDebugAppDomain * This,
            /* [out] */ BOOL *pbAttached);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugAppDomain * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugValue **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            ICorDebugAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorDebugAppDomain * This,
            /* [out] */ ULONG32 *pId);
        
        END_INTERFACE
    } ICorDebugAppDomainVtbl;

    interface ICorDebugAppDomain
    {
        CONST_VTBL struct ICorDebugAppDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAppDomain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAppDomain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAppDomain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAppDomain_Stop(This,dwTimeoutIgnored)	\
    (This)->lpVtbl -> Stop(This,dwTimeoutIgnored)

#define ICorDebugAppDomain_Continue(This,fIsOutOfBand)	\
    (This)->lpVtbl -> Continue(This,fIsOutOfBand)

#define ICorDebugAppDomain_IsRunning(This,pbRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbRunning)

#define ICorDebugAppDomain_HasQueuedCallbacks(This,pThread,pbQueued)	\
    (This)->lpVtbl -> HasQueuedCallbacks(This,pThread,pbQueued)

#define ICorDebugAppDomain_EnumerateThreads(This,ppThreads)	\
    (This)->lpVtbl -> EnumerateThreads(This,ppThreads)

#define ICorDebugAppDomain_SetAllThreadsDebugState(This,state,pExceptThisThread)	\
    (This)->lpVtbl -> SetAllThreadsDebugState(This,state,pExceptThisThread)

#define ICorDebugAppDomain_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define ICorDebugAppDomain_Terminate(This,exitCode)	\
    (This)->lpVtbl -> Terminate(This,exitCode)

#define ICorDebugAppDomain_CanCommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CanCommitChanges(This,cSnapshots,pSnapshots,pError)

#define ICorDebugAppDomain_CommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CommitChanges(This,cSnapshots,pSnapshots,pError)


#define ICorDebugAppDomain_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugAppDomain_EnumerateAssemblies(This,ppAssemblies)	\
    (This)->lpVtbl -> EnumerateAssemblies(This,ppAssemblies)

#define ICorDebugAppDomain_GetModuleFromMetaDataInterface(This,pIMetaData,ppModule)	\
    (This)->lpVtbl -> GetModuleFromMetaDataInterface(This,pIMetaData,ppModule)

#define ICorDebugAppDomain_EnumerateBreakpoints(This,ppBreakpoints)	\
    (This)->lpVtbl -> EnumerateBreakpoints(This,ppBreakpoints)

#define ICorDebugAppDomain_EnumerateSteppers(This,ppSteppers)	\
    (This)->lpVtbl -> EnumerateSteppers(This,ppSteppers)

#define ICorDebugAppDomain_IsAttached(This,pbAttached)	\
    (This)->lpVtbl -> IsAttached(This,pbAttached)

#define ICorDebugAppDomain_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ICorDebugAppDomain_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#define ICorDebugAppDomain_Attach(This)	\
    (This)->lpVtbl -> Attach(This)

#define ICorDebugAppDomain_GetID(This,pId)	\
    (This)->lpVtbl -> GetID(This,pId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetProcess_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugAppDomain_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_EnumerateAssemblies_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugAssemblyEnum **ppAssemblies);


void __RPC_STUB ICorDebugAppDomain_EnumerateAssemblies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetModuleFromMetaDataInterface_Proxy( 
    ICorDebugAppDomain * This,
    /* [in] */ IUnknown *pIMetaData,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugAppDomain_GetModuleFromMetaDataInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_EnumerateBreakpoints_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugBreakpointEnum **ppBreakpoints);


void __RPC_STUB ICorDebugAppDomain_EnumerateBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_EnumerateSteppers_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugStepperEnum **ppSteppers);


void __RPC_STUB ICorDebugAppDomain_EnumerateSteppers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_IsAttached_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ BOOL *pbAttached);


void __RPC_STUB ICorDebugAppDomain_IsAttached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetName_Proxy( 
    ICorDebugAppDomain * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugAppDomain_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetObject_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugValue **ppObject);


void __RPC_STUB ICorDebugAppDomain_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_Attach_Proxy( 
    ICorDebugAppDomain * This);


void __RPC_STUB ICorDebugAppDomain_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetID_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ULONG32 *pId);


void __RPC_STUB ICorDebugAppDomain_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAppDomain_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAppDomain2_INTERFACE_DEFINED__
#define __ICorDebugAppDomain2_INTERFACE_DEFINED__

/* interface ICorDebugAppDomain2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAppDomain2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("096E81D5-ECDA-4202-83F5-C65980A9EF75")
    ICorDebugAppDomain2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetArrayOrPointerType( 
            /* [in] */ CorElementType elementType,
            /* [in] */ ULONG32 nRank,
            /* [in] */ ICorDebugType *pTypeArg,
            /* [out] */ ICorDebugType **ppType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionPointerType( 
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [out] */ ICorDebugType **ppType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAppDomain2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAppDomain2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAppDomain2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAppDomain2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetArrayOrPointerType )( 
            ICorDebugAppDomain2 * This,
            /* [in] */ CorElementType elementType,
            /* [in] */ ULONG32 nRank,
            /* [in] */ ICorDebugType *pTypeArg,
            /* [out] */ ICorDebugType **ppType);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionPointerType )( 
            ICorDebugAppDomain2 * This,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [out] */ ICorDebugType **ppType);
        
        END_INTERFACE
    } ICorDebugAppDomain2Vtbl;

    interface ICorDebugAppDomain2
    {
        CONST_VTBL struct ICorDebugAppDomain2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAppDomain2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAppDomain2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAppDomain2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAppDomain2_GetArrayOrPointerType(This,elementType,nRank,pTypeArg,ppType)	\
    (This)->lpVtbl -> GetArrayOrPointerType(This,elementType,nRank,pTypeArg,ppType)

#define ICorDebugAppDomain2_GetFunctionPointerType(This,nTypeArgs,ppTypeArgs,ppType)	\
    (This)->lpVtbl -> GetFunctionPointerType(This,nTypeArgs,ppTypeArgs,ppType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAppDomain2_GetArrayOrPointerType_Proxy( 
    ICorDebugAppDomain2 * This,
    /* [in] */ CorElementType elementType,
    /* [in] */ ULONG32 nRank,
    /* [in] */ ICorDebugType *pTypeArg,
    /* [out] */ ICorDebugType **ppType);


void __RPC_STUB ICorDebugAppDomain2_GetArrayOrPointerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain2_GetFunctionPointerType_Proxy( 
    ICorDebugAppDomain2 * This,
    /* [in] */ ULONG32 nTypeArgs,
    /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
    /* [out] */ ICorDebugType **ppType);


void __RPC_STUB ICorDebugAppDomain2_GetFunctionPointerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAppDomain2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAssembly_INTERFACE_DEFINED__
#define __ICorDebugAssembly_INTERFACE_DEFINED__

/* interface ICorDebugAssembly */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAssembly;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("df59507c-d47a-459e-bce2-6427eac8fd06")
    ICorDebugAssembly : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomain( 
            /* [out] */ ICorDebugAppDomain **ppAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateModules( 
            /* [out] */ ICorDebugModuleEnum **ppModules) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeBase( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAssemblyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAssembly * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAssembly * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAssembly * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugAssembly * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomain )( 
            ICorDebugAssembly * This,
            /* [out] */ ICorDebugAppDomain **ppAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateModules )( 
            ICorDebugAssembly * This,
            /* [out] */ ICorDebugModuleEnum **ppModules);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeBase )( 
            ICorDebugAssembly * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugAssembly * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        END_INTERFACE
    } ICorDebugAssemblyVtbl;

    interface ICorDebugAssembly
    {
        CONST_VTBL struct ICorDebugAssemblyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAssembly_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAssembly_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAssembly_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAssembly_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugAssembly_GetAppDomain(This,ppAppDomain)	\
    (This)->lpVtbl -> GetAppDomain(This,ppAppDomain)

#define ICorDebugAssembly_EnumerateModules(This,ppModules)	\
    (This)->lpVtbl -> EnumerateModules(This,ppModules)

#define ICorDebugAssembly_GetCodeBase(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetCodeBase(This,cchName,pcchName,szName)

#define ICorDebugAssembly_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetProcess_Proxy( 
    ICorDebugAssembly * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugAssembly_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetAppDomain_Proxy( 
    ICorDebugAssembly * This,
    /* [out] */ ICorDebugAppDomain **ppAppDomain);


void __RPC_STUB ICorDebugAssembly_GetAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_EnumerateModules_Proxy( 
    ICorDebugAssembly * This,
    /* [out] */ ICorDebugModuleEnum **ppModules);


void __RPC_STUB ICorDebugAssembly_EnumerateModules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetCodeBase_Proxy( 
    ICorDebugAssembly * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugAssembly_GetCodeBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetName_Proxy( 
    ICorDebugAssembly * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugAssembly_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAssembly_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAssembly2_INTERFACE_DEFINED__
#define __ICorDebugAssembly2_INTERFACE_DEFINED__

/* interface ICorDebugAssembly2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAssembly2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("426d1f9e-6dd4-44c8-aec7-26cdbaf4e398")
    ICorDebugAssembly2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsFullyTrusted( 
            /* [out] */ BOOL *pbFullyTrusted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAssembly2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAssembly2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAssembly2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAssembly2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsFullyTrusted )( 
            ICorDebugAssembly2 * This,
            /* [out] */ BOOL *pbFullyTrusted);
        
        END_INTERFACE
    } ICorDebugAssembly2Vtbl;

    interface ICorDebugAssembly2
    {
        CONST_VTBL struct ICorDebugAssembly2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAssembly2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAssembly2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAssembly2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAssembly2_IsFullyTrusted(This,pbFullyTrusted)	\
    (This)->lpVtbl -> IsFullyTrusted(This,pbFullyTrusted)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAssembly2_IsFullyTrusted_Proxy( 
    ICorDebugAssembly2 * This,
    /* [out] */ BOOL *pbFullyTrusted);


void __RPC_STUB ICorDebugAssembly2_IsFullyTrusted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAssembly2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugProcess_INTERFACE_DEFINED__
#define __ICorDebugProcess_INTERFACE_DEFINED__

/* interface ICorDebugProcess */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f64-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugProcess : public ICorDebugController
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ DWORD *pdwProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandle( 
            /* [out] */ HPROCESS *phProcessHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateObjects( 
            /* [out] */ ICorDebugObjectEnum **ppObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTransitionStub( 
            /* [in] */ CORDB_ADDRESS address,
            /* [out] */ BOOL *pbTransitionStub) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsOSSuspended( 
            /* [in] */ DWORD threadID,
            /* [out] */ BOOL *pbSuspended) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out][in] */ BYTE context[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadMemory( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ SIZE_T *read) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteMemory( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [size_is][in] */ BYTE buffer[  ],
            /* [out] */ SIZE_T *written) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearCurrentException( 
            /* [in] */ DWORD threadID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableLogMessages( 
            /* [in] */ BOOL fOnOff) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModifyLogSwitch( 
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ LONG lLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAppDomains( 
            /* [out] */ ICorDebugAppDomainEnum **ppAppDomains) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugValue **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadForFiberCookie( 
            /* [in] */ DWORD fiberCookie,
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelperThreadID( 
            /* [out] */ DWORD *pThreadID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugProcess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugProcess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD dwTimeoutIgnored);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            ICorDebugProcess * This,
            /* [in] */ BOOL fIsOutOfBand);
        
        HRESULT ( STDMETHODCALLTYPE *IsRunning )( 
            ICorDebugProcess * This,
            /* [out] */ BOOL *pbRunning);
        
        HRESULT ( STDMETHODCALLTYPE *HasQueuedCallbacks )( 
            ICorDebugProcess * This,
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateThreads )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugThreadEnum **ppThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllThreadsDebugState )( 
            ICorDebugProcess * This,
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            ICorDebugProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebugProcess * This,
            /* [in] */ UINT exitCode);
        
        HRESULT ( STDMETHODCALLTYPE *CanCommitChanges )( 
            ICorDebugProcess * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            ICorDebugProcess * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorDebugProcess * This,
            /* [out] */ DWORD *pdwProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandle )( 
            ICorDebugProcess * This,
            /* [out] */ HPROCESS *phProcessHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateObjects )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugObjectEnum **ppObjects);
        
        HRESULT ( STDMETHODCALLTYPE *IsTransitionStub )( 
            ICorDebugProcess * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [out] */ BOOL *pbTransitionStub);
        
        HRESULT ( STDMETHODCALLTYPE *IsOSSuspended )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID,
            /* [out] */ BOOL *pbSuspended);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out][in] */ BYTE context[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMemory )( 
            ICorDebugProcess * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ SIZE_T *read);
        
        HRESULT ( STDMETHODCALLTYPE *WriteMemory )( 
            ICorDebugProcess * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [size_is][in] */ BYTE buffer[  ],
            /* [out] */ SIZE_T *written);
        
        HRESULT ( STDMETHODCALLTYPE *ClearCurrentException )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID);
        
        HRESULT ( STDMETHODCALLTYPE *EnableLogMessages )( 
            ICorDebugProcess * This,
            /* [in] */ BOOL fOnOff);
        
        HRESULT ( STDMETHODCALLTYPE *ModifyLogSwitch )( 
            ICorDebugProcess * This,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ LONG lLevel);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAppDomains )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugAppDomainEnum **ppAppDomains);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugValue **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadForFiberCookie )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD fiberCookie,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetHelperThreadID )( 
            ICorDebugProcess * This,
            /* [out] */ DWORD *pThreadID);
        
        END_INTERFACE
    } ICorDebugProcessVtbl;

    interface ICorDebugProcess
    {
        CONST_VTBL struct ICorDebugProcessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugProcess_Stop(This,dwTimeoutIgnored)	\
    (This)->lpVtbl -> Stop(This,dwTimeoutIgnored)

#define ICorDebugProcess_Continue(This,fIsOutOfBand)	\
    (This)->lpVtbl -> Continue(This,fIsOutOfBand)

#define ICorDebugProcess_IsRunning(This,pbRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbRunning)

#define ICorDebugProcess_HasQueuedCallbacks(This,pThread,pbQueued)	\
    (This)->lpVtbl -> HasQueuedCallbacks(This,pThread,pbQueued)

#define ICorDebugProcess_EnumerateThreads(This,ppThreads)	\
    (This)->lpVtbl -> EnumerateThreads(This,ppThreads)

#define ICorDebugProcess_SetAllThreadsDebugState(This,state,pExceptThisThread)	\
    (This)->lpVtbl -> SetAllThreadsDebugState(This,state,pExceptThisThread)

#define ICorDebugProcess_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define ICorDebugProcess_Terminate(This,exitCode)	\
    (This)->lpVtbl -> Terminate(This,exitCode)

#define ICorDebugProcess_CanCommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CanCommitChanges(This,cSnapshots,pSnapshots,pError)

#define ICorDebugProcess_CommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CommitChanges(This,cSnapshots,pSnapshots,pError)


#define ICorDebugProcess_GetID(This,pdwProcessId)	\
    (This)->lpVtbl -> GetID(This,pdwProcessId)

#define ICorDebugProcess_GetHandle(This,phProcessHandle)	\
    (This)->lpVtbl -> GetHandle(This,phProcessHandle)

#define ICorDebugProcess_GetThread(This,dwThreadId,ppThread)	\
    (This)->lpVtbl -> GetThread(This,dwThreadId,ppThread)

#define ICorDebugProcess_EnumerateObjects(This,ppObjects)	\
    (This)->lpVtbl -> EnumerateObjects(This,ppObjects)

#define ICorDebugProcess_IsTransitionStub(This,address,pbTransitionStub)	\
    (This)->lpVtbl -> IsTransitionStub(This,address,pbTransitionStub)

#define ICorDebugProcess_IsOSSuspended(This,threadID,pbSuspended)	\
    (This)->lpVtbl -> IsOSSuspended(This,threadID,pbSuspended)

#define ICorDebugProcess_GetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextSize,context)

#define ICorDebugProcess_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICorDebugProcess_ReadMemory(This,address,size,buffer,read)	\
    (This)->lpVtbl -> ReadMemory(This,address,size,buffer,read)

#define ICorDebugProcess_WriteMemory(This,address,size,buffer,written)	\
    (This)->lpVtbl -> WriteMemory(This,address,size,buffer,written)

#define ICorDebugProcess_ClearCurrentException(This,threadID)	\
    (This)->lpVtbl -> ClearCurrentException(This,threadID)

#define ICorDebugProcess_EnableLogMessages(This,fOnOff)	\
    (This)->lpVtbl -> EnableLogMessages(This,fOnOff)

#define ICorDebugProcess_ModifyLogSwitch(This,pLogSwitchName,lLevel)	\
    (This)->lpVtbl -> ModifyLogSwitch(This,pLogSwitchName,lLevel)

#define ICorDebugProcess_EnumerateAppDomains(This,ppAppDomains)	\
    (This)->lpVtbl -> EnumerateAppDomains(This,ppAppDomains)

#define ICorDebugProcess_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#define ICorDebugProcess_ThreadForFiberCookie(This,fiberCookie,ppThread)	\
    (This)->lpVtbl -> ThreadForFiberCookie(This,fiberCookie,ppThread)

#define ICorDebugProcess_GetHelperThreadID(This,pThreadID)	\
    (This)->lpVtbl -> GetHelperThreadID(This,pThreadID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetID_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ DWORD *pdwProcessId);


void __RPC_STUB ICorDebugProcess_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetHandle_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ HPROCESS *phProcessHandle);


void __RPC_STUB ICorDebugProcess_GetHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetThread_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD dwThreadId,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugProcess_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_EnumerateObjects_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ ICorDebugObjectEnum **ppObjects);


void __RPC_STUB ICorDebugProcess_EnumerateObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_IsTransitionStub_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [out] */ BOOL *pbTransitionStub);


void __RPC_STUB ICorDebugProcess_IsTransitionStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_IsOSSuspended_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID,
    /* [out] */ BOOL *pbSuspended);


void __RPC_STUB ICorDebugProcess_IsOSSuspended_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetThreadContext_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][out][in] */ BYTE context[  ]);


void __RPC_STUB ICorDebugProcess_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_SetThreadContext_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][in] */ BYTE context[  ]);


void __RPC_STUB ICorDebugProcess_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ReadMemory_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ DWORD size,
    /* [length_is][size_is][out] */ BYTE buffer[  ],
    /* [out] */ SIZE_T *read);


void __RPC_STUB ICorDebugProcess_ReadMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_WriteMemory_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ DWORD size,
    /* [size_is][in] */ BYTE buffer[  ],
    /* [out] */ SIZE_T *written);


void __RPC_STUB ICorDebugProcess_WriteMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ClearCurrentException_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID);


void __RPC_STUB ICorDebugProcess_ClearCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_EnableLogMessages_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ BOOL fOnOff);


void __RPC_STUB ICorDebugProcess_EnableLogMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ModifyLogSwitch_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ WCHAR *pLogSwitchName,
    /* [in] */ LONG lLevel);


void __RPC_STUB ICorDebugProcess_ModifyLogSwitch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_EnumerateAppDomains_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ ICorDebugAppDomainEnum **ppAppDomains);


void __RPC_STUB ICorDebugProcess_EnumerateAppDomains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetObject_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ ICorDebugValue **ppObject);


void __RPC_STUB ICorDebugProcess_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ThreadForFiberCookie_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD fiberCookie,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugProcess_ThreadForFiberCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetHelperThreadID_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ DWORD *pThreadID);


void __RPC_STUB ICorDebugProcess_GetHelperThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugProcess_INTERFACE_DEFINED__ */


#ifndef __ICorDebugProcess2_INTERFACE_DEFINED__
#define __ICorDebugProcess2_INTERFACE_DEFINED__

/* interface ICorDebugProcess2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugProcess2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD1B3588-0EF0-4744-A496-AA09A9F80371")
    ICorDebugProcess2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThreadForTaskID( 
            /* [in] */ TASKID taskid,
            /* [out] */ ICorDebugThread2 **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ COR_VERSION *version) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnmanagedBreakpoint( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ ULONG32 bufsize,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ ULONG32 *bufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearUnmanagedBreakpoint( 
            /* [in] */ CORDB_ADDRESS address) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDesiredNGENCompilerFlags( 
            /* [in] */ DWORD pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDesiredNGENCompilerFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReferenceValueFromGCHandle( 
            /* [in] */ UINT_PTR handle,
            /* [out] */ ICorDebugReferenceValue **pOutValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugProcess2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugProcess2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugProcess2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugProcess2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadForTaskID )( 
            ICorDebugProcess2 * This,
            /* [in] */ TASKID taskid,
            /* [out] */ ICorDebugThread2 **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            ICorDebugProcess2 * This,
            /* [out] */ COR_VERSION *version);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnmanagedBreakpoint )( 
            ICorDebugProcess2 * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ ULONG32 bufsize,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ ULONG32 *bufLen);
        
        HRESULT ( STDMETHODCALLTYPE *ClearUnmanagedBreakpoint )( 
            ICorDebugProcess2 * This,
            /* [in] */ CORDB_ADDRESS address);
        
        HRESULT ( STDMETHODCALLTYPE *SetDesiredNGENCompilerFlags )( 
            ICorDebugProcess2 * This,
            /* [in] */ DWORD pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesiredNGENCompilerFlags )( 
            ICorDebugProcess2 * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetReferenceValueFromGCHandle )( 
            ICorDebugProcess2 * This,
            /* [in] */ UINT_PTR handle,
            /* [out] */ ICorDebugReferenceValue **pOutValue);
        
        END_INTERFACE
    } ICorDebugProcess2Vtbl;

    interface ICorDebugProcess2
    {
        CONST_VTBL struct ICorDebugProcess2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugProcess2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugProcess2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugProcess2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugProcess2_GetThreadForTaskID(This,taskid,ppThread)	\
    (This)->lpVtbl -> GetThreadForTaskID(This,taskid,ppThread)

#define ICorDebugProcess2_GetVersion(This,version)	\
    (This)->lpVtbl -> GetVersion(This,version)

#define ICorDebugProcess2_SetUnmanagedBreakpoint(This,address,bufsize,buffer,bufLen)	\
    (This)->lpVtbl -> SetUnmanagedBreakpoint(This,address,bufsize,buffer,bufLen)

#define ICorDebugProcess2_ClearUnmanagedBreakpoint(This,address)	\
    (This)->lpVtbl -> ClearUnmanagedBreakpoint(This,address)

#define ICorDebugProcess2_SetDesiredNGENCompilerFlags(This,pdwFlags)	\
    (This)->lpVtbl -> SetDesiredNGENCompilerFlags(This,pdwFlags)

#define ICorDebugProcess2_GetDesiredNGENCompilerFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetDesiredNGENCompilerFlags(This,pdwFlags)

#define ICorDebugProcess2_GetReferenceValueFromGCHandle(This,handle,pOutValue)	\
    (This)->lpVtbl -> GetReferenceValueFromGCHandle(This,handle,pOutValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugProcess2_GetThreadForTaskID_Proxy( 
    ICorDebugProcess2 * This,
    /* [in] */ TASKID taskid,
    /* [out] */ ICorDebugThread2 **ppThread);


void __RPC_STUB ICorDebugProcess2_GetThreadForTaskID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_GetVersion_Proxy( 
    ICorDebugProcess2 * This,
    /* [out] */ COR_VERSION *version);


void __RPC_STUB ICorDebugProcess2_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_SetUnmanagedBreakpoint_Proxy( 
    ICorDebugProcess2 * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ ULONG32 bufsize,
    /* [length_is][size_is][out] */ BYTE buffer[  ],
    /* [out] */ ULONG32 *bufLen);


void __RPC_STUB ICorDebugProcess2_SetUnmanagedBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_ClearUnmanagedBreakpoint_Proxy( 
    ICorDebugProcess2 * This,
    /* [in] */ CORDB_ADDRESS address);


void __RPC_STUB ICorDebugProcess2_ClearUnmanagedBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_SetDesiredNGENCompilerFlags_Proxy( 
    ICorDebugProcess2 * This,
    /* [in] */ DWORD pdwFlags);


void __RPC_STUB ICorDebugProcess2_SetDesiredNGENCompilerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_GetDesiredNGENCompilerFlags_Proxy( 
    ICorDebugProcess2 * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ICorDebugProcess2_GetDesiredNGENCompilerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_GetReferenceValueFromGCHandle_Proxy( 
    ICorDebugProcess2 * This,
    /* [in] */ UINT_PTR handle,
    /* [out] */ ICorDebugReferenceValue **pOutValue);


void __RPC_STUB ICorDebugProcess2_GetReferenceValueFromGCHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugProcess2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAE8-8A68-11d2-983C-0000F808342D")
    ICorDebugBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL bActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( 
            /* [out] */ BOOL *pbActive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        END_INTERFACE
    } ICorDebugBreakpointVtbl;

    interface ICorDebugBreakpoint
    {
        CONST_VTBL struct ICorDebugBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugBreakpoint_Activate_Proxy( 
    ICorDebugBreakpoint * This,
    /* [in] */ BOOL bActive);


void __RPC_STUB ICorDebugBreakpoint_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugBreakpoint_IsActive_Proxy( 
    ICorDebugBreakpoint * This,
    /* [out] */ BOOL *pbActive);


void __RPC_STUB ICorDebugBreakpoint_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFunctionBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugFunctionBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugFunctionBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFunctionBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAE9-8A68-11d2-983C-0000F808342D")
    ICorDebugFunctionBreakpoint : public ICorDebugBreakpoint
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOffset( 
            /* [out] */ ULONG32 *pnOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFunctionBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFunctionBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFunctionBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFunctionBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugFunctionBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugFunctionBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugFunctionBreakpoint * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetOffset )( 
            ICorDebugFunctionBreakpoint * This,
            /* [out] */ ULONG32 *pnOffset);
        
        END_INTERFACE
    } ICorDebugFunctionBreakpointVtbl;

    interface ICorDebugFunctionBreakpoint
    {
        CONST_VTBL struct ICorDebugFunctionBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFunctionBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFunctionBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFunctionBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFunctionBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugFunctionBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)


#define ICorDebugFunctionBreakpoint_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugFunctionBreakpoint_GetOffset(This,pnOffset)	\
    (This)->lpVtbl -> GetOffset(This,pnOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFunctionBreakpoint_GetFunction_Proxy( 
    ICorDebugFunctionBreakpoint * This,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugFunctionBreakpoint_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunctionBreakpoint_GetOffset_Proxy( 
    ICorDebugFunctionBreakpoint * This,
    /* [out] */ ULONG32 *pnOffset);


void __RPC_STUB ICorDebugFunctionBreakpoint_GetOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFunctionBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModuleBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugModuleBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugModuleBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModuleBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEA-8A68-11d2-983C-0000F808342D")
    ICorDebugModuleBreakpoint : public ICorDebugBreakpoint
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModuleBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModuleBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModuleBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModuleBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugModuleBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugModuleBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugModuleBreakpoint * This,
            /* [out] */ ICorDebugModule **ppModule);
        
        END_INTERFACE
    } ICorDebugModuleBreakpointVtbl;

    interface ICorDebugModuleBreakpoint
    {
        CONST_VTBL struct ICorDebugModuleBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModuleBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModuleBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModuleBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModuleBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugModuleBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)


#define ICorDebugModuleBreakpoint_GetModule(This,ppModule)	\
    (This)->lpVtbl -> GetModule(This,ppModule)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModuleBreakpoint_GetModule_Proxy( 
    ICorDebugModuleBreakpoint * This,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugModuleBreakpoint_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModuleBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValueBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugValueBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugValueBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValueBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEB-8A68-11d2-983C-0000F808342D")
    ICorDebugValueBreakpoint : public ICorDebugBreakpoint
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValueBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValueBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValueBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValueBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugValueBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugValueBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugValueBreakpoint * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugValueBreakpointVtbl;

    interface ICorDebugValueBreakpoint
    {
        CONST_VTBL struct ICorDebugValueBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValueBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValueBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValueBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValueBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugValueBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)


#define ICorDebugValueBreakpoint_GetValue(This,ppValue)	\
    (This)->lpVtbl -> GetValue(This,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValueBreakpoint_GetValue_Proxy( 
    ICorDebugValueBreakpoint * This,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugValueBreakpoint_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValueBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStepper_INTERFACE_DEFINED__
#define __ICorDebugStepper_INTERFACE_DEFINED__

/* interface ICorDebugStepper */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugIntercept
    {	INTERCEPT_NONE	= 0,
	INTERCEPT_CLASS_INIT	= 0x1,
	INTERCEPT_EXCEPTION_FILTER	= 0x2,
	INTERCEPT_SECURITY	= 0x4,
	INTERCEPT_CONTEXT_POLICY	= 0x8,
	INTERCEPT_INTERCEPTION	= 0x10,
	INTERCEPT_ALL	= 0xffff
    } 	CorDebugIntercept;

typedef 
enum CorDebugUnmappedStop
    {	STOP_NONE	= 0,
	STOP_PROLOG	= 0x1,
	STOP_EPILOG	= 0x2,
	STOP_NO_MAPPING_INFO	= 0x4,
	STOP_OTHER_UNMAPPED	= 0x8,
	STOP_UNMANAGED	= 0x10,
	STOP_ALL	= 0xffff
    } 	CorDebugUnmappedStop;

typedef struct COR_DEBUG_STEP_RANGE
    {
    ULONG32 startOffset;
    ULONG32 endOffset;
    } 	COR_DEBUG_STEP_RANGE;


EXTERN_C const IID IID_ICorDebugStepper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEC-8A68-11d2-983C-0000F808342D")
    ICorDebugStepper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsActive( 
            /* [out] */ BOOL *pbActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInterceptMask( 
            /* [in] */ CorDebugIntercept mask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnmappedStopMask( 
            /* [in] */ CorDebugUnmappedStop mask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Step( 
            /* [in] */ BOOL bStepIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepRange( 
            /* [in] */ BOOL bStepIn,
            /* [size_is][in] */ COR_DEBUG_STEP_RANGE ranges[  ],
            /* [in] */ ULONG32 cRangeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRangeIL( 
            /* [in] */ BOOL bIL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStepperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStepper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStepper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStepper * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugStepper * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ICorDebugStepper * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterceptMask )( 
            ICorDebugStepper * This,
            /* [in] */ CorDebugIntercept mask);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnmappedStopMask )( 
            ICorDebugStepper * This,
            /* [in] */ CorDebugUnmappedStop mask);
        
        HRESULT ( STDMETHODCALLTYPE *Step )( 
            ICorDebugStepper * This,
            /* [in] */ BOOL bStepIn);
        
        HRESULT ( STDMETHODCALLTYPE *StepRange )( 
            ICorDebugStepper * This,
            /* [in] */ BOOL bStepIn,
            /* [size_is][in] */ COR_DEBUG_STEP_RANGE ranges[  ],
            /* [in] */ ULONG32 cRangeCount);
        
        HRESULT ( STDMETHODCALLTYPE *StepOut )( 
            ICorDebugStepper * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRangeIL )( 
            ICorDebugStepper * This,
            /* [in] */ BOOL bIL);
        
        END_INTERFACE
    } ICorDebugStepperVtbl;

    interface ICorDebugStepper
    {
        CONST_VTBL struct ICorDebugStepperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStepper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStepper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStepper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStepper_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)

#define ICorDebugStepper_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ICorDebugStepper_SetInterceptMask(This,mask)	\
    (This)->lpVtbl -> SetInterceptMask(This,mask)

#define ICorDebugStepper_SetUnmappedStopMask(This,mask)	\
    (This)->lpVtbl -> SetUnmappedStopMask(This,mask)

#define ICorDebugStepper_Step(This,bStepIn)	\
    (This)->lpVtbl -> Step(This,bStepIn)

#define ICorDebugStepper_StepRange(This,bStepIn,ranges,cRangeCount)	\
    (This)->lpVtbl -> StepRange(This,bStepIn,ranges,cRangeCount)

#define ICorDebugStepper_StepOut(This)	\
    (This)->lpVtbl -> StepOut(This)

#define ICorDebugStepper_SetRangeIL(This,bIL)	\
    (This)->lpVtbl -> SetRangeIL(This,bIL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStepper_IsActive_Proxy( 
    ICorDebugStepper * This,
    /* [out] */ BOOL *pbActive);


void __RPC_STUB ICorDebugStepper_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_Deactivate_Proxy( 
    ICorDebugStepper * This);


void __RPC_STUB ICorDebugStepper_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_SetInterceptMask_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ CorDebugIntercept mask);


void __RPC_STUB ICorDebugStepper_SetInterceptMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_SetUnmappedStopMask_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ CorDebugUnmappedStop mask);


void __RPC_STUB ICorDebugStepper_SetUnmappedStopMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_Step_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ BOOL bStepIn);


void __RPC_STUB ICorDebugStepper_Step_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_StepRange_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ BOOL bStepIn,
    /* [size_is][in] */ COR_DEBUG_STEP_RANGE ranges[  ],
    /* [in] */ ULONG32 cRangeCount);


void __RPC_STUB ICorDebugStepper_StepRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_StepOut_Proxy( 
    ICorDebugStepper * This);


void __RPC_STUB ICorDebugStepper_StepOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_SetRangeIL_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ BOOL bIL);


void __RPC_STUB ICorDebugStepper_SetRangeIL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStepper_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStepper2_INTERFACE_DEFINED__
#define __ICorDebugStepper2_INTERFACE_DEFINED__

/* interface ICorDebugStepper2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugStepper2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5B6E9C3-E7D1-4a8e-873B-7F047F0706F7")
    ICorDebugStepper2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetJMC( 
            /* [in] */ BOOL fIsJMCStepper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStepper2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStepper2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStepper2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStepper2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetJMC )( 
            ICorDebugStepper2 * This,
            /* [in] */ BOOL fIsJMCStepper);
        
        END_INTERFACE
    } ICorDebugStepper2Vtbl;

    interface ICorDebugStepper2
    {
        CONST_VTBL struct ICorDebugStepper2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStepper2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStepper2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStepper2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStepper2_SetJMC(This,fIsJMCStepper)	\
    (This)->lpVtbl -> SetJMC(This,fIsJMCStepper)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStepper2_SetJMC_Proxy( 
    ICorDebugStepper2 * This,
    /* [in] */ BOOL fIsJMCStepper);


void __RPC_STUB ICorDebugStepper2_SetJMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStepper2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugRegisterSet_INTERFACE_DEFINED__
#define __ICorDebugRegisterSet_INTERFACE_DEFINED__

/* interface ICorDebugRegisterSet */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugRegister
    {	REGISTER_INSTRUCTION_POINTER	= 0,
	REGISTER_STACK_POINTER	= REGISTER_INSTRUCTION_POINTER + 1,
	REGISTER_FRAME_POINTER	= REGISTER_STACK_POINTER + 1,
	REGISTER_X86_EIP	= 0,
	REGISTER_X86_ESP	= REGISTER_X86_EIP + 1,
	REGISTER_X86_EBP	= REGISTER_X86_ESP + 1,
	REGISTER_X86_EAX	= REGISTER_X86_EBP + 1,
	REGISTER_X86_ECX	= REGISTER_X86_EAX + 1,
	REGISTER_X86_EDX	= REGISTER_X86_ECX + 1,
	REGISTER_X86_EBX	= REGISTER_X86_EDX + 1,
	REGISTER_X86_ESI	= REGISTER_X86_EBX + 1,
	REGISTER_X86_EDI	= REGISTER_X86_ESI + 1,
	REGISTER_X86_FPSTACK_0	= REGISTER_X86_EDI + 1,
	REGISTER_X86_FPSTACK_1	= REGISTER_X86_FPSTACK_0 + 1,
	REGISTER_X86_FPSTACK_2	= REGISTER_X86_FPSTACK_1 + 1,
	REGISTER_X86_FPSTACK_3	= REGISTER_X86_FPSTACK_2 + 1,
	REGISTER_X86_FPSTACK_4	= REGISTER_X86_FPSTACK_3 + 1,
	REGISTER_X86_FPSTACK_5	= REGISTER_X86_FPSTACK_4 + 1,
	REGISTER_X86_FPSTACK_6	= REGISTER_X86_FPSTACK_5 + 1,
	REGISTER_X86_FPSTACK_7	= REGISTER_X86_FPSTACK_6 + 1,
	REGISTER_AMD64_RIP	= 0,
	REGISTER_AMD64_RSP	= REGISTER_AMD64_RIP + 1,
	REGISTER_AMD64_RBP	= REGISTER_AMD64_RSP + 1,
	REGISTER_AMD64_RAX	= REGISTER_AMD64_RBP + 1,
	REGISTER_AMD64_RCX	= REGISTER_AMD64_RAX + 1,
	REGISTER_AMD64_RDX	= REGISTER_AMD64_RCX + 1,
	REGISTER_AMD64_RBX	= REGISTER_AMD64_RDX + 1,
	REGISTER_AMD64_RSI	= REGISTER_AMD64_RBX + 1,
	REGISTER_AMD64_RDI	= REGISTER_AMD64_RSI + 1,
	REGISTER_AMD64_R8	= REGISTER_AMD64_RDI + 1,
	REGISTER_AMD64_R9	= REGISTER_AMD64_R8 + 1,
	REGISTER_AMD64_R10	= REGISTER_AMD64_R9 + 1,
	REGISTER_AMD64_R11	= REGISTER_AMD64_R10 + 1,
	REGISTER_AMD64_R12	= REGISTER_AMD64_R11 + 1,
	REGISTER_AMD64_R13	= REGISTER_AMD64_R12 + 1,
	REGISTER_AMD64_R14	= REGISTER_AMD64_R13 + 1,
	REGISTER_AMD64_R15	= REGISTER_AMD64_R14 + 1,
	REGISTER_AMD64_XMM0	= REGISTER_AMD64_R15 + 1,
	REGISTER_AMD64_XMM1	= REGISTER_AMD64_XMM0 + 1,
	REGISTER_AMD64_XMM2	= REGISTER_AMD64_XMM1 + 1,
	REGISTER_AMD64_XMM3	= REGISTER_AMD64_XMM2 + 1,
	REGISTER_AMD64_XMM4	= REGISTER_AMD64_XMM3 + 1,
	REGISTER_AMD64_XMM5	= REGISTER_AMD64_XMM4 + 1,
	REGISTER_AMD64_XMM6	= REGISTER_AMD64_XMM5 + 1,
	REGISTER_AMD64_XMM7	= REGISTER_AMD64_XMM6 + 1,
	REGISTER_AMD64_XMM8	= REGISTER_AMD64_XMM7 + 1,
	REGISTER_AMD64_XMM9	= REGISTER_AMD64_XMM8 + 1,
	REGISTER_AMD64_XMM10	= REGISTER_AMD64_XMM9 + 1,
	REGISTER_AMD64_XMM11	= REGISTER_AMD64_XMM10 + 1,
	REGISTER_AMD64_XMM12	= REGISTER_AMD64_XMM11 + 1,
	REGISTER_AMD64_XMM13	= REGISTER_AMD64_XMM12 + 1,
	REGISTER_AMD64_XMM14	= REGISTER_AMD64_XMM13 + 1,
	REGISTER_AMD64_XMM15	= REGISTER_AMD64_XMM14 + 1,
	REGISTER_IA64_BSP	= REGISTER_FRAME_POINTER,
	REGISTER_IA64_R0	= REGISTER_IA64_BSP + 1,
	REGISTER_IA64_F0	= REGISTER_IA64_R0 + 128
    } 	CorDebugRegister;


EXTERN_C const IID IID_ICorDebugRegisterSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB0B-8A68-11d2-983C-0000F808342D")
    ICorDebugRegisterSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRegistersAvailable( 
            /* [out] */ ULONG64 *pAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisters( 
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [length_is][size_is][out] */ CORDB_REGISTER regBuffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRegisters( 
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out][in] */ BYTE context[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugRegisterSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugRegisterSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugRegisterSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugRegisterSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegistersAvailable )( 
            ICorDebugRegisterSet * This,
            /* [out] */ ULONG64 *pAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisters )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [length_is][size_is][out] */ CORDB_REGISTER regBuffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetRegisters )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out][in] */ BYTE context[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]);
        
        END_INTERFACE
    } ICorDebugRegisterSetVtbl;

    interface ICorDebugRegisterSet
    {
        CONST_VTBL struct ICorDebugRegisterSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugRegisterSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugRegisterSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugRegisterSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugRegisterSet_GetRegistersAvailable(This,pAvailable)	\
    (This)->lpVtbl -> GetRegistersAvailable(This,pAvailable)

#define ICorDebugRegisterSet_GetRegisters(This,mask,regCount,regBuffer)	\
    (This)->lpVtbl -> GetRegisters(This,mask,regCount,regBuffer)

#define ICorDebugRegisterSet_SetRegisters(This,mask,regCount,regBuffer)	\
    (This)->lpVtbl -> SetRegisters(This,mask,regCount,regBuffer)

#define ICorDebugRegisterSet_GetThreadContext(This,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,contextSize,context)

#define ICorDebugRegisterSet_SetThreadContext(This,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,contextSize,context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_GetRegistersAvailable_Proxy( 
    ICorDebugRegisterSet * This,
    /* [out] */ ULONG64 *pAvailable);


void __RPC_STUB ICorDebugRegisterSet_GetRegistersAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_GetRegisters_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG64 mask,
    /* [in] */ ULONG32 regCount,
    /* [length_is][size_is][out] */ CORDB_REGISTER regBuffer[  ]);


void __RPC_STUB ICorDebugRegisterSet_GetRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_SetRegisters_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG64 mask,
    /* [in] */ ULONG32 regCount,
    /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]);


void __RPC_STUB ICorDebugRegisterSet_SetRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_GetThreadContext_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][out][in] */ BYTE context[  ]);


void __RPC_STUB ICorDebugRegisterSet_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_SetThreadContext_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][in] */ BYTE context[  ]);


void __RPC_STUB ICorDebugRegisterSet_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugRegisterSet_INTERFACE_DEFINED__ */


#ifndef __ICorDebugRegisterSet2_INTERFACE_DEFINED__
#define __ICorDebugRegisterSet2_INTERFACE_DEFINED__

/* interface ICorDebugRegisterSet2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugRegisterSet2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DC7BA3F-89BA-4459-9EC1-9D60937B468D")
    ICorDebugRegisterSet2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRegistersAvailable( 
            /* [in] */ ULONG32 numChunks,
            /* [size_is][out] */ BYTE availableRegChunks[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisters( 
            /* [in] */ ULONG32 maskCount,
            /* [size_is][in] */ BYTE mask[  ],
            /* [in] */ ULONG32 regCount,
            /* [size_is][out] */ CORDB_REGISTER regBuffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRegisters( 
            /* [in] */ ULONG32 maskCount,
            /* [size_is][in] */ BYTE mask[  ],
            /* [in] */ ULONG32 regCount,
            /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugRegisterSet2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugRegisterSet2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugRegisterSet2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugRegisterSet2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegistersAvailable )( 
            ICorDebugRegisterSet2 * This,
            /* [in] */ ULONG32 numChunks,
            /* [size_is][out] */ BYTE availableRegChunks[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisters )( 
            ICorDebugRegisterSet2 * This,
            /* [in] */ ULONG32 maskCount,
            /* [size_is][in] */ BYTE mask[  ],
            /* [in] */ ULONG32 regCount,
            /* [size_is][out] */ CORDB_REGISTER regBuffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetRegisters )( 
            ICorDebugRegisterSet2 * This,
            /* [in] */ ULONG32 maskCount,
            /* [size_is][in] */ BYTE mask[  ],
            /* [in] */ ULONG32 regCount,
            /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]);
        
        END_INTERFACE
    } ICorDebugRegisterSet2Vtbl;

    interface ICorDebugRegisterSet2
    {
        CONST_VTBL struct ICorDebugRegisterSet2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugRegisterSet2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugRegisterSet2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugRegisterSet2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugRegisterSet2_GetRegistersAvailable(This,numChunks,availableRegChunks)	\
    (This)->lpVtbl -> GetRegistersAvailable(This,numChunks,availableRegChunks)

#define ICorDebugRegisterSet2_GetRegisters(This,maskCount,mask,regCount,regBuffer)	\
    (This)->lpVtbl -> GetRegisters(This,maskCount,mask,regCount,regBuffer)

#define ICorDebugRegisterSet2_SetRegisters(This,maskCount,mask,regCount,regBuffer)	\
    (This)->lpVtbl -> SetRegisters(This,maskCount,mask,regCount,regBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet2_GetRegistersAvailable_Proxy( 
    ICorDebugRegisterSet2 * This,
    /* [in] */ ULONG32 numChunks,
    /* [size_is][out] */ BYTE availableRegChunks[  ]);


void __RPC_STUB ICorDebugRegisterSet2_GetRegistersAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet2_GetRegisters_Proxy( 
    ICorDebugRegisterSet2 * This,
    /* [in] */ ULONG32 maskCount,
    /* [size_is][in] */ BYTE mask[  ],
    /* [in] */ ULONG32 regCount,
    /* [size_is][out] */ CORDB_REGISTER regBuffer[  ]);


void __RPC_STUB ICorDebugRegisterSet2_GetRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet2_SetRegisters_Proxy( 
    ICorDebugRegisterSet2 * This,
    /* [in] */ ULONG32 maskCount,
    /* [size_is][in] */ BYTE mask[  ],
    /* [in] */ ULONG32 regCount,
    /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]);


void __RPC_STUB ICorDebugRegisterSet2_SetRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugRegisterSet2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugThread_INTERFACE_DEFINED__
#define __ICorDebugThread_INTERFACE_DEFINED__

/* interface ICorDebugThread */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugUserState
    {	USER_STOP_REQUESTED	= 0x1,
	USER_SUSPEND_REQUESTED	= 0x2,
	USER_BACKGROUND	= 0x4,
	USER_UNSTARTED	= 0x8,
	USER_STOPPED	= 0x10,
	USER_WAIT_SLEEP_JOIN	= 0x20,
	USER_SUSPENDED	= 0x40,
	USER_UNSAFE_POINT	= 0x80
    } 	CorDebugUserState;


EXTERN_C const IID IID_ICorDebugThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("938c6d66-7fb6-4f69-b389-425b8987329b")
    ICorDebugThread : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ DWORD *pdwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandle( 
            /* [out] */ HTHREAD *phThreadHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomain( 
            /* [out] */ ICorDebugAppDomain **ppAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugState( 
            /* [in] */ CorDebugThreadState state) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugState( 
            /* [out] */ CorDebugThreadState *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserState( 
            /* [out] */ CorDebugUserState *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentException( 
            /* [out] */ ICorDebugValue **ppExceptionObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearCurrentException( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStepper( 
            /* [out] */ ICorDebugStepper **ppStepper) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateChains( 
            /* [out] */ ICorDebugChainEnum **ppChains) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveChain( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveFrame( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterSet( 
            /* [out] */ ICorDebugRegisterSet **ppRegisters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEval( 
            /* [out] */ ICorDebugEval **ppEval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugValue **ppObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugThread * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugThread * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugThread * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorDebugThread * This,
            /* [out] */ DWORD *pdwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandle )( 
            ICorDebugThread * This,
            /* [out] */ HTHREAD *phThreadHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomain )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugAppDomain **ppAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebugState )( 
            ICorDebugThread * This,
            /* [in] */ CorDebugThreadState state);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugState )( 
            ICorDebugThread * This,
            /* [out] */ CorDebugThreadState *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserState )( 
            ICorDebugThread * This,
            /* [out] */ CorDebugUserState *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentException )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugValue **ppExceptionObject);
        
        HRESULT ( STDMETHODCALLTYPE *ClearCurrentException )( 
            ICorDebugThread * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateChains )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugChainEnum **ppChains);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveChain )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveFrame )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterSet )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugRegisterSet **ppRegisters);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEval )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugEval **ppEval);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugValue **ppObject);
        
        END_INTERFACE
    } ICorDebugThreadVtbl;

    interface ICorDebugThread
    {
        CONST_VTBL struct ICorDebugThreadVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugThread_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugThread_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugThread_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugThread_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugThread_GetID(This,pdwThreadId)	\
    (This)->lpVtbl -> GetID(This,pdwThreadId)

#define ICorDebugThread_GetHandle(This,phThreadHandle)	\
    (This)->lpVtbl -> GetHandle(This,phThreadHandle)

#define ICorDebugThread_GetAppDomain(This,ppAppDomain)	\
    (This)->lpVtbl -> GetAppDomain(This,ppAppDomain)

#define ICorDebugThread_SetDebugState(This,state)	\
    (This)->lpVtbl -> SetDebugState(This,state)

#define ICorDebugThread_GetDebugState(This,pState)	\
    (This)->lpVtbl -> GetDebugState(This,pState)

#define ICorDebugThread_GetUserState(This,pState)	\
    (This)->lpVtbl -> GetUserState(This,pState)

#define ICorDebugThread_GetCurrentException(This,ppExceptionObject)	\
    (This)->lpVtbl -> GetCurrentException(This,ppExceptionObject)

#define ICorDebugThread_ClearCurrentException(This)	\
    (This)->lpVtbl -> ClearCurrentException(This)

#define ICorDebugThread_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)

#define ICorDebugThread_EnumerateChains(This,ppChains)	\
    (This)->lpVtbl -> EnumerateChains(This,ppChains)

#define ICorDebugThread_GetActiveChain(This,ppChain)	\
    (This)->lpVtbl -> GetActiveChain(This,ppChain)

#define ICorDebugThread_GetActiveFrame(This,ppFrame)	\
    (This)->lpVtbl -> GetActiveFrame(This,ppFrame)

#define ICorDebugThread_GetRegisterSet(This,ppRegisters)	\
    (This)->lpVtbl -> GetRegisterSet(This,ppRegisters)

#define ICorDebugThread_CreateEval(This,ppEval)	\
    (This)->lpVtbl -> CreateEval(This,ppEval)

#define ICorDebugThread_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugThread_GetProcess_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugThread_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetID_Proxy( 
    ICorDebugThread * This,
    /* [out] */ DWORD *pdwThreadId);


void __RPC_STUB ICorDebugThread_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetHandle_Proxy( 
    ICorDebugThread * This,
    /* [out] */ HTHREAD *phThreadHandle);


void __RPC_STUB ICorDebugThread_GetHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetAppDomain_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugAppDomain **ppAppDomain);


void __RPC_STUB ICorDebugThread_GetAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_SetDebugState_Proxy( 
    ICorDebugThread * This,
    /* [in] */ CorDebugThreadState state);


void __RPC_STUB ICorDebugThread_SetDebugState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetDebugState_Proxy( 
    ICorDebugThread * This,
    /* [out] */ CorDebugThreadState *pState);


void __RPC_STUB ICorDebugThread_GetDebugState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetUserState_Proxy( 
    ICorDebugThread * This,
    /* [out] */ CorDebugUserState *pState);


void __RPC_STUB ICorDebugThread_GetUserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetCurrentException_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugValue **ppExceptionObject);


void __RPC_STUB ICorDebugThread_GetCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_ClearCurrentException_Proxy( 
    ICorDebugThread * This);


void __RPC_STUB ICorDebugThread_ClearCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_CreateStepper_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugStepper **ppStepper);


void __RPC_STUB ICorDebugThread_CreateStepper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_EnumerateChains_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugChainEnum **ppChains);


void __RPC_STUB ICorDebugThread_EnumerateChains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetActiveChain_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugThread_GetActiveChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetActiveFrame_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugThread_GetActiveFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetRegisterSet_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugRegisterSet **ppRegisters);


void __RPC_STUB ICorDebugThread_GetRegisterSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_CreateEval_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugEval **ppEval);


void __RPC_STUB ICorDebugThread_CreateEval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetObject_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugValue **ppObject);


void __RPC_STUB ICorDebugThread_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugThread_INTERFACE_DEFINED__ */


#ifndef __ICorDebugThread2_INTERFACE_DEFINED__
#define __ICorDebugThread2_INTERFACE_DEFINED__

/* interface ICorDebugThread2 */
/* [unique][uuid][object] */ 

typedef struct _COR_ACTIVE_FUNCTION
    {
    ICorDebugAppDomain *pAppDomain;
    ICorDebugModule *pModule;
    ICorDebugFunction2 *pFunction;
    ULONG32 ilOffset;
    ULONG32 flags;
    } 	COR_ACTIVE_FUNCTION;


EXTERN_C const IID IID_ICorDebugThread2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2BD956D9-7B07-4bef-8A98-12AA862417C5")
    ICorDebugThread2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetActiveFunctions( 
            /* [in] */ ULONG32 cFunctions,
            /* [out] */ ULONG32 *pcFunctions,
            /* [length_is][size_is][out][in] */ COR_ACTIVE_FUNCTION pFunctions[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionID( 
            /* [out] */ CONNID *pdwConnectionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTaskID( 
            /* [out] */ TASKID *pTaskId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVolatileOSThreadID( 
            /* [out] */ DWORD *pdwTid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InterceptCurrentException( 
            /* [in] */ ICorDebugFrame *pFrame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugThread2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugThread2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugThread2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugThread2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveFunctions )( 
            ICorDebugThread2 * This,
            /* [in] */ ULONG32 cFunctions,
            /* [out] */ ULONG32 *pcFunctions,
            /* [length_is][size_is][out][in] */ COR_ACTIVE_FUNCTION pFunctions[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionID )( 
            ICorDebugThread2 * This,
            /* [out] */ CONNID *pdwConnectionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetTaskID )( 
            ICorDebugThread2 * This,
            /* [out] */ TASKID *pTaskId);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolatileOSThreadID )( 
            ICorDebugThread2 * This,
            /* [out] */ DWORD *pdwTid);
        
        HRESULT ( STDMETHODCALLTYPE *InterceptCurrentException )( 
            ICorDebugThread2 * This,
            /* [in] */ ICorDebugFrame *pFrame);
        
        END_INTERFACE
    } ICorDebugThread2Vtbl;

    interface ICorDebugThread2
    {
        CONST_VTBL struct ICorDebugThread2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugThread2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugThread2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugThread2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugThread2_GetActiveFunctions(This,cFunctions,pcFunctions,pFunctions)	\
    (This)->lpVtbl -> GetActiveFunctions(This,cFunctions,pcFunctions,pFunctions)

#define ICorDebugThread2_GetConnectionID(This,pdwConnectionId)	\
    (This)->lpVtbl -> GetConnectionID(This,pdwConnectionId)

#define ICorDebugThread2_GetTaskID(This,pTaskId)	\
    (This)->lpVtbl -> GetTaskID(This,pTaskId)

#define ICorDebugThread2_GetVolatileOSThreadID(This,pdwTid)	\
    (This)->lpVtbl -> GetVolatileOSThreadID(This,pdwTid)

#define ICorDebugThread2_InterceptCurrentException(This,pFrame)	\
    (This)->lpVtbl -> InterceptCurrentException(This,pFrame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugThread2_GetActiveFunctions_Proxy( 
    ICorDebugThread2 * This,
    /* [in] */ ULONG32 cFunctions,
    /* [out] */ ULONG32 *pcFunctions,
    /* [length_is][size_is][out][in] */ COR_ACTIVE_FUNCTION pFunctions[  ]);


void __RPC_STUB ICorDebugThread2_GetActiveFunctions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread2_GetConnectionID_Proxy( 
    ICorDebugThread2 * This,
    /* [out] */ CONNID *pdwConnectionId);


void __RPC_STUB ICorDebugThread2_GetConnectionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread2_GetTaskID_Proxy( 
    ICorDebugThread2 * This,
    /* [out] */ TASKID *pTaskId);


void __RPC_STUB ICorDebugThread2_GetTaskID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread2_GetVolatileOSThreadID_Proxy( 
    ICorDebugThread2 * This,
    /* [out] */ DWORD *pdwTid);


void __RPC_STUB ICorDebugThread2_GetVolatileOSThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread2_InterceptCurrentException_Proxy( 
    ICorDebugThread2 * This,
    /* [in] */ ICorDebugFrame *pFrame);


void __RPC_STUB ICorDebugThread2_InterceptCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugThread2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugChain_INTERFACE_DEFINED__
#define __ICorDebugChain_INTERFACE_DEFINED__

/* interface ICorDebugChain */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugChainReason
    {	CHAIN_NONE	= 0,
	CHAIN_CLASS_INIT	= 0x1,
	CHAIN_EXCEPTION_FILTER	= 0x2,
	CHAIN_SECURITY	= 0x4,
	CHAIN_CONTEXT_POLICY	= 0x8,
	CHAIN_INTERCEPTION	= 0x10,
	CHAIN_PROCESS_START	= 0x20,
	CHAIN_THREAD_START	= 0x40,
	CHAIN_ENTER_MANAGED	= 0x80,
	CHAIN_ENTER_UNMANAGED	= 0x100,
	CHAIN_DEBUGGER_EVAL	= 0x200,
	CHAIN_CONTEXT_SWITCH	= 0x400,
	CHAIN_FUNC_EVAL	= 0x800
    } 	CorDebugChainReason;


EXTERN_C const IID IID_ICorDebugChain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEE-8A68-11d2-983C-0000F808342D")
    ICorDebugChain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackRange( 
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ ICorDebugContext **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCaller( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallee( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrevious( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsManaged( 
            /* [out] */ BOOL *pManaged) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateFrames( 
            /* [out] */ ICorDebugFrameEnum **ppFrames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveFrame( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterSet( 
            /* [out] */ ICorDebugRegisterSet **ppRegisters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReason( 
            /* [out] */ CorDebugChainReason *pReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugChainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugChain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugChain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugChain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugChain * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrevious )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetNext )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *IsManaged )( 
            ICorDebugChain * This,
            /* [out] */ BOOL *pManaged);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateFrames )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugFrameEnum **ppFrames);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveFrame )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterSet )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugRegisterSet **ppRegisters);
        
        HRESULT ( STDMETHODCALLTYPE *GetReason )( 
            ICorDebugChain * This,
            /* [out] */ CorDebugChainReason *pReason);
        
        END_INTERFACE
    } ICorDebugChainVtbl;

    interface ICorDebugChain
    {
        CONST_VTBL struct ICorDebugChainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugChain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugChain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugChain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugChain_GetThread(This,ppThread)	\
    (This)->lpVtbl -> GetThread(This,ppThread)

#define ICorDebugChain_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugChain_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#define ICorDebugChain_GetCaller(This,ppChain)	\
    (This)->lpVtbl -> GetCaller(This,ppChain)

#define ICorDebugChain_GetCallee(This,ppChain)	\
    (This)->lpVtbl -> GetCallee(This,ppChain)

#define ICorDebugChain_GetPrevious(This,ppChain)	\
    (This)->lpVtbl -> GetPrevious(This,ppChain)

#define ICorDebugChain_GetNext(This,ppChain)	\
    (This)->lpVtbl -> GetNext(This,ppChain)

#define ICorDebugChain_IsManaged(This,pManaged)	\
    (This)->lpVtbl -> IsManaged(This,pManaged)

#define ICorDebugChain_EnumerateFrames(This,ppFrames)	\
    (This)->lpVtbl -> EnumerateFrames(This,ppFrames)

#define ICorDebugChain_GetActiveFrame(This,ppFrame)	\
    (This)->lpVtbl -> GetActiveFrame(This,ppFrame)

#define ICorDebugChain_GetRegisterSet(This,ppRegisters)	\
    (This)->lpVtbl -> GetRegisterSet(This,ppRegisters)

#define ICorDebugChain_GetReason(This,pReason)	\
    (This)->lpVtbl -> GetReason(This,pReason)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugChain_GetThread_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugChain_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetStackRange_Proxy( 
    ICorDebugChain * This,
    /* [out] */ CORDB_ADDRESS *pStart,
    /* [out] */ CORDB_ADDRESS *pEnd);


void __RPC_STUB ICorDebugChain_GetStackRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetContext_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugContext **ppContext);


void __RPC_STUB ICorDebugChain_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetCaller_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetCaller_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetCallee_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetCallee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetPrevious_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetPrevious_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetNext_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_IsManaged_Proxy( 
    ICorDebugChain * This,
    /* [out] */ BOOL *pManaged);


void __RPC_STUB ICorDebugChain_IsManaged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_EnumerateFrames_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugFrameEnum **ppFrames);


void __RPC_STUB ICorDebugChain_EnumerateFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetActiveFrame_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugChain_GetActiveFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetRegisterSet_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugRegisterSet **ppRegisters);


void __RPC_STUB ICorDebugChain_GetRegisterSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetReason_Proxy( 
    ICorDebugChain * This,
    /* [out] */ CorDebugChainReason *pReason);


void __RPC_STUB ICorDebugChain_GetReason_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugChain_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFrame_INTERFACE_DEFINED__
#define __ICorDebugFrame_INTERFACE_DEFINED__

/* interface ICorDebugFrame */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEF-8A68-11d2-983C-0000F808342D")
    ICorDebugFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetChain( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCode( 
            /* [out] */ ICorDebugCode **ppCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionToken( 
            /* [out] */ mdMethodDef *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackRange( 
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCaller( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallee( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStepper( 
            /* [out] */ ICorDebugStepper **ppStepper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        END_INTERFACE
    } ICorDebugFrameVtbl;

    interface ICorDebugFrame
    {
        CONST_VTBL struct ICorDebugFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetChain_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugFrame_GetChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetCode_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugCode **ppCode);


void __RPC_STUB ICorDebugFrame_GetCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetFunction_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugFrame_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetFunctionToken_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ mdMethodDef *pToken);


void __RPC_STUB ICorDebugFrame_GetFunctionToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetStackRange_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ CORDB_ADDRESS *pStart,
    /* [out] */ CORDB_ADDRESS *pEnd);


void __RPC_STUB ICorDebugFrame_GetStackRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetCaller_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugFrame_GetCaller_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetCallee_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugFrame_GetCallee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_CreateStepper_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugStepper **ppStepper);


void __RPC_STUB ICorDebugFrame_CreateStepper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugInternalFrame_INTERFACE_DEFINED__
#define __ICorDebugInternalFrame_INTERFACE_DEFINED__

/* interface ICorDebugInternalFrame */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugInternalFrameType
    {	STUBFRAME_NONE	= 0,
	STUBFRAME_M2U	= 0x1,
	STUBFRAME_U2M	= 0x2,
	STUBFRAME_APPDOMAIN_TRANSITION	= 0x3,
	STUBFRAME_LIGHTWEIGHT_FUNCTION	= 0x4,
	STUBFRAME_FUNC_EVAL	= 0x5,
	STUBFRAME_INTERNALCALL	= 0x6
    } 	CorDebugInternalFrameType;


EXTERN_C const IID IID_ICorDebugInternalFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B92CC7F7-9D2D-45c4-BC2B-621FCC9DFBF4")
    ICorDebugInternalFrame : public ICorDebugFrame
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameType( 
            /* [out] */ CorDebugInternalFrameType *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugInternalFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugInternalFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugInternalFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugInternalFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugInternalFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugInternalFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameType )( 
            ICorDebugInternalFrame * This,
            /* [out] */ CorDebugInternalFrameType *pType);
        
        END_INTERFACE
    } ICorDebugInternalFrameVtbl;

    interface ICorDebugInternalFrame
    {
        CONST_VTBL struct ICorDebugInternalFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugInternalFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugInternalFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugInternalFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugInternalFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugInternalFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugInternalFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugInternalFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugInternalFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugInternalFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugInternalFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugInternalFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)


#define ICorDebugInternalFrame_GetFrameType(This,pType)	\
    (This)->lpVtbl -> GetFrameType(This,pType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugInternalFrame_GetFrameType_Proxy( 
    ICorDebugInternalFrame * This,
    /* [out] */ CorDebugInternalFrameType *pType);


void __RPC_STUB ICorDebugInternalFrame_GetFrameType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugInternalFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugILFrame_INTERFACE_DEFINED__
#define __ICorDebugILFrame_INTERFACE_DEFINED__

/* interface ICorDebugILFrame */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugMappingResult
    {	MAPPING_PROLOG	= 0x1,
	MAPPING_EPILOG	= 0x2,
	MAPPING_NO_INFO	= 0x4,
	MAPPING_UNMAPPED_ADDRESS	= 0x8,
	MAPPING_EXACT	= 0x10,
	MAPPING_APPROXIMATE	= 0x20
    } 	CorDebugMappingResult;


EXTERN_C const IID IID_ICorDebugILFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03E26311-4F76-11d3-88C6-006097945418")
    ICorDebugILFrame : public ICorDebugFrame
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIP( 
            /* [out] */ ULONG32 *pnOffset,
            /* [out] */ CorDebugMappingResult *pMappingResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateLocalVariables( 
            /* [out] */ ICorDebugValueEnum **ppValueEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalVariable( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateArguments( 
            /* [out] */ ICorDebugValueEnum **ppValueEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArgument( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackDepth( 
            /* [out] */ ULONG32 *pDepth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackValue( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugILFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugILFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugILFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugILFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugILFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugILFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *GetIP )( 
            ICorDebugILFrame * This,
            /* [out] */ ULONG32 *pnOffset,
            /* [out] */ CorDebugMappingResult *pMappingResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetIP )( 
            ICorDebugILFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateLocalVariables )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugValueEnum **ppValueEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalVariable )( 
            ICorDebugILFrame * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateArguments )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugValueEnum **ppValueEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetArgument )( 
            ICorDebugILFrame * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackDepth )( 
            ICorDebugILFrame * This,
            /* [out] */ ULONG32 *pDepth);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackValue )( 
            ICorDebugILFrame * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *CanSetIP )( 
            ICorDebugILFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        END_INTERFACE
    } ICorDebugILFrameVtbl;

    interface ICorDebugILFrame
    {
        CONST_VTBL struct ICorDebugILFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugILFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugILFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugILFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugILFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugILFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugILFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugILFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugILFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugILFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugILFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugILFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)


#define ICorDebugILFrame_GetIP(This,pnOffset,pMappingResult)	\
    (This)->lpVtbl -> GetIP(This,pnOffset,pMappingResult)

#define ICorDebugILFrame_SetIP(This,nOffset)	\
    (This)->lpVtbl -> SetIP(This,nOffset)

#define ICorDebugILFrame_EnumerateLocalVariables(This,ppValueEnum)	\
    (This)->lpVtbl -> EnumerateLocalVariables(This,ppValueEnum)

#define ICorDebugILFrame_GetLocalVariable(This,dwIndex,ppValue)	\
    (This)->lpVtbl -> GetLocalVariable(This,dwIndex,ppValue)

#define ICorDebugILFrame_EnumerateArguments(This,ppValueEnum)	\
    (This)->lpVtbl -> EnumerateArguments(This,ppValueEnum)

#define ICorDebugILFrame_GetArgument(This,dwIndex,ppValue)	\
    (This)->lpVtbl -> GetArgument(This,dwIndex,ppValue)

#define ICorDebugILFrame_GetStackDepth(This,pDepth)	\
    (This)->lpVtbl -> GetStackDepth(This,pDepth)

#define ICorDebugILFrame_GetStackValue(This,dwIndex,ppValue)	\
    (This)->lpVtbl -> GetStackValue(This,dwIndex,ppValue)

#define ICorDebugILFrame_CanSetIP(This,nOffset)	\
    (This)->lpVtbl -> CanSetIP(This,nOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetIP_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ULONG32 *pnOffset,
    /* [out] */ CorDebugMappingResult *pMappingResult);


void __RPC_STUB ICorDebugILFrame_GetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_SetIP_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugILFrame_SetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_EnumerateLocalVariables_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ICorDebugValueEnum **ppValueEnum);


void __RPC_STUB ICorDebugILFrame_EnumerateLocalVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetLocalVariable_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugILFrame_GetLocalVariable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_EnumerateArguments_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ICorDebugValueEnum **ppValueEnum);


void __RPC_STUB ICorDebugILFrame_EnumerateArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetArgument_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugILFrame_GetArgument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetStackDepth_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ULONG32 *pDepth);


void __RPC_STUB ICorDebugILFrame_GetStackDepth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetStackValue_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugILFrame_GetStackValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_CanSetIP_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugILFrame_CanSetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugILFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugILFrame2_INTERFACE_DEFINED__
#define __ICorDebugILFrame2_INTERFACE_DEFINED__

/* interface ICorDebugILFrame2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugILFrame2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5D88A994-6C30-479b-890F-BCEF88B129A5")
    ICorDebugILFrame2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RemapFunction( 
            /* [in] */ ULONG32 newILOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateTypeParameters( 
            /* [out] */ ICorDebugTypeEnum **ppTyParEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugILFrame2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugILFrame2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugILFrame2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugILFrame2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemapFunction )( 
            ICorDebugILFrame2 * This,
            /* [in] */ ULONG32 newILOffset);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateTypeParameters )( 
            ICorDebugILFrame2 * This,
            /* [out] */ ICorDebugTypeEnum **ppTyParEnum);
        
        END_INTERFACE
    } ICorDebugILFrame2Vtbl;

    interface ICorDebugILFrame2
    {
        CONST_VTBL struct ICorDebugILFrame2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugILFrame2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugILFrame2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugILFrame2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugILFrame2_RemapFunction(This,newILOffset)	\
    (This)->lpVtbl -> RemapFunction(This,newILOffset)

#define ICorDebugILFrame2_EnumerateTypeParameters(This,ppTyParEnum)	\
    (This)->lpVtbl -> EnumerateTypeParameters(This,ppTyParEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugILFrame2_RemapFunction_Proxy( 
    ICorDebugILFrame2 * This,
    /* [in] */ ULONG32 newILOffset);


void __RPC_STUB ICorDebugILFrame2_RemapFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame2_EnumerateTypeParameters_Proxy( 
    ICorDebugILFrame2 * This,
    /* [out] */ ICorDebugTypeEnum **ppTyParEnum);


void __RPC_STUB ICorDebugILFrame2_EnumerateTypeParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugILFrame2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugNativeFrame_INTERFACE_DEFINED__
#define __ICorDebugNativeFrame_INTERFACE_DEFINED__

/* interface ICorDebugNativeFrame */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugNativeFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03E26314-4F76-11d3-88C6-006097945418")
    ICorDebugNativeFrame : public ICorDebugFrame
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIP( 
            /* [out] */ ULONG32 *pnOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterSet( 
            /* [out] */ ICorDebugRegisterSet **ppRegisters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalRegisterValue( 
            /* [in] */ CorDebugRegister reg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalDoubleRegisterValue( 
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CorDebugRegister lowWordReg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalMemoryValue( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalRegisterMemoryValue( 
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CORDB_ADDRESS lowWordAddress,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalMemoryRegisterValue( 
            /* [in] */ CORDB_ADDRESS highWordAddress,
            /* [in] */ CorDebugRegister lowWordRegister,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugNativeFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugNativeFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugNativeFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugNativeFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugNativeFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugNativeFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *GetIP )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ULONG32 *pnOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetIP )( 
            ICorDebugNativeFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterSet )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugRegisterSet **ppRegisters);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalRegisterValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CorDebugRegister reg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalDoubleRegisterValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CorDebugRegister lowWordReg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalMemoryValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalRegisterMemoryValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CORDB_ADDRESS lowWordAddress,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalMemoryRegisterValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CORDB_ADDRESS highWordAddress,
            /* [in] */ CorDebugRegister lowWordRegister,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *CanSetIP )( 
            ICorDebugNativeFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        END_INTERFACE
    } ICorDebugNativeFrameVtbl;

    interface ICorDebugNativeFrame
    {
        CONST_VTBL struct ICorDebugNativeFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugNativeFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugNativeFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugNativeFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugNativeFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugNativeFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugNativeFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugNativeFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugNativeFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugNativeFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugNativeFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugNativeFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)


#define ICorDebugNativeFrame_GetIP(This,pnOffset)	\
    (This)->lpVtbl -> GetIP(This,pnOffset)

#define ICorDebugNativeFrame_SetIP(This,nOffset)	\
    (This)->lpVtbl -> SetIP(This,nOffset)

#define ICorDebugNativeFrame_GetRegisterSet(This,ppRegisters)	\
    (This)->lpVtbl -> GetRegisterSet(This,ppRegisters)

#define ICorDebugNativeFrame_GetLocalRegisterValue(This,reg,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalRegisterValue(This,reg,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalDoubleRegisterValue(This,highWordReg,lowWordReg,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalDoubleRegisterValue(This,highWordReg,lowWordReg,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalMemoryValue(This,address,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalMemoryValue(This,address,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalRegisterMemoryValue(This,highWordReg,lowWordAddress,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalRegisterMemoryValue(This,highWordReg,lowWordAddress,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalMemoryRegisterValue(This,highWordAddress,lowWordRegister,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalMemoryRegisterValue(This,highWordAddress,lowWordRegister,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_CanSetIP(This,nOffset)	\
    (This)->lpVtbl -> CanSetIP(This,nOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetIP_Proxy( 
    ICorDebugNativeFrame * This,
    /* [out] */ ULONG32 *pnOffset);


void __RPC_STUB ICorDebugNativeFrame_GetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_SetIP_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugNativeFrame_SetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetRegisterSet_Proxy( 
    ICorDebugNativeFrame * This,
    /* [out] */ ICorDebugRegisterSet **ppRegisters);


void __RPC_STUB ICorDebugNativeFrame_GetRegisterSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalRegisterValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CorDebugRegister reg,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalRegisterValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalDoubleRegisterValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CorDebugRegister highWordReg,
    /* [in] */ CorDebugRegister lowWordReg,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalDoubleRegisterValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalMemoryValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalMemoryValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalRegisterMemoryValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CorDebugRegister highWordReg,
    /* [in] */ CORDB_ADDRESS lowWordAddress,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalRegisterMemoryValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalMemoryRegisterValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CORDB_ADDRESS highWordAddress,
    /* [in] */ CorDebugRegister lowWordRegister,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalMemoryRegisterValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_CanSetIP_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugNativeFrame_CanSetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugNativeFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModule_INTERFACE_DEFINED__
#define __ICorDebugModule_INTERFACE_DEFINED__

/* interface ICorDebugModule */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dba2d8c1-e5c5-4069-8c13-10a7c6abf43d")
    ICorDebugModule : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaseAddress( 
            /* [out] */ CORDB_ADDRESS *pAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssembly( 
            /* [out] */ ICorDebugAssembly **ppAssembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableJITDebugging( 
            /* [in] */ BOOL bTrackJITInfo,
            /* [in] */ BOOL bAllowJitOpts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableClassLoadCallbacks( 
            /* [in] */ BOOL bClassLoadCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromToken( 
            /* [in] */ mdMethodDef methodDef,
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromRVA( 
            /* [in] */ CORDB_ADDRESS rva,
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassFromToken( 
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [out] */ ICorDebugModuleBreakpoint **ppBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditAndContinueSnapshot( 
            /* [out] */ ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataInterface( 
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdModule *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDynamic( 
            /* [out] */ BOOL *pDynamic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlobalVariableValue( 
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG32 *pcBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsInMemory( 
            /* [out] */ BOOL *pInMemory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModule * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaseAddress )( 
            ICorDebugModule * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssembly )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugAssembly **ppAssembly);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugModule * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *EnableJITDebugging )( 
            ICorDebugModule * This,
            /* [in] */ BOOL bTrackJITInfo,
            /* [in] */ BOOL bAllowJitOpts);
        
        HRESULT ( STDMETHODCALLTYPE *EnableClassLoadCallbacks )( 
            ICorDebugModule * This,
            /* [in] */ BOOL bClassLoadCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromToken )( 
            ICorDebugModule * This,
            /* [in] */ mdMethodDef methodDef,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromRVA )( 
            ICorDebugModule * This,
            /* [in] */ CORDB_ADDRESS rva,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromToken )( 
            ICorDebugModule * This,
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugModuleBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditAndContinueSnapshot )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetaDataInterface )( 
            ICorDebugModule * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppObj);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugModule * This,
            /* [out] */ mdModule *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *IsDynamic )( 
            ICorDebugModule * This,
            /* [out] */ BOOL *pDynamic);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalVariableValue )( 
            ICorDebugModule * This,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugModule * This,
            /* [out] */ ULONG32 *pcBytes);
        
        HRESULT ( STDMETHODCALLTYPE *IsInMemory )( 
            ICorDebugModule * This,
            /* [out] */ BOOL *pInMemory);
        
        END_INTERFACE
    } ICorDebugModuleVtbl;

    interface ICorDebugModule
    {
        CONST_VTBL struct ICorDebugModuleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModule_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModule_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModule_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModule_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugModule_GetBaseAddress(This,pAddress)	\
    (This)->lpVtbl -> GetBaseAddress(This,pAddress)

#define ICorDebugModule_GetAssembly(This,ppAssembly)	\
    (This)->lpVtbl -> GetAssembly(This,ppAssembly)

#define ICorDebugModule_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ICorDebugModule_EnableJITDebugging(This,bTrackJITInfo,bAllowJitOpts)	\
    (This)->lpVtbl -> EnableJITDebugging(This,bTrackJITInfo,bAllowJitOpts)

#define ICorDebugModule_EnableClassLoadCallbacks(This,bClassLoadCallbacks)	\
    (This)->lpVtbl -> EnableClassLoadCallbacks(This,bClassLoadCallbacks)

#define ICorDebugModule_GetFunctionFromToken(This,methodDef,ppFunction)	\
    (This)->lpVtbl -> GetFunctionFromToken(This,methodDef,ppFunction)

#define ICorDebugModule_GetFunctionFromRVA(This,rva,ppFunction)	\
    (This)->lpVtbl -> GetFunctionFromRVA(This,rva,ppFunction)

#define ICorDebugModule_GetClassFromToken(This,typeDef,ppClass)	\
    (This)->lpVtbl -> GetClassFromToken(This,typeDef,ppClass)

#define ICorDebugModule_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)

#define ICorDebugModule_GetEditAndContinueSnapshot(This,ppEditAndContinueSnapshot)	\
    (This)->lpVtbl -> GetEditAndContinueSnapshot(This,ppEditAndContinueSnapshot)

#define ICorDebugModule_GetMetaDataInterface(This,riid,ppObj)	\
    (This)->lpVtbl -> GetMetaDataInterface(This,riid,ppObj)

#define ICorDebugModule_GetToken(This,pToken)	\
    (This)->lpVtbl -> GetToken(This,pToken)

#define ICorDebugModule_IsDynamic(This,pDynamic)	\
    (This)->lpVtbl -> IsDynamic(This,pDynamic)

#define ICorDebugModule_GetGlobalVariableValue(This,fieldDef,ppValue)	\
    (This)->lpVtbl -> GetGlobalVariableValue(This,fieldDef,ppValue)

#define ICorDebugModule_GetSize(This,pcBytes)	\
    (This)->lpVtbl -> GetSize(This,pcBytes)

#define ICorDebugModule_IsInMemory(This,pInMemory)	\
    (This)->lpVtbl -> IsInMemory(This,pInMemory)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModule_GetProcess_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugModule_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetBaseAddress_Proxy( 
    ICorDebugModule * This,
    /* [out] */ CORDB_ADDRESS *pAddress);


void __RPC_STUB ICorDebugModule_GetBaseAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetAssembly_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugAssembly **ppAssembly);


void __RPC_STUB ICorDebugModule_GetAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetName_Proxy( 
    ICorDebugModule * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugModule_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_EnableJITDebugging_Proxy( 
    ICorDebugModule * This,
    /* [in] */ BOOL bTrackJITInfo,
    /* [in] */ BOOL bAllowJitOpts);


void __RPC_STUB ICorDebugModule_EnableJITDebugging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_EnableClassLoadCallbacks_Proxy( 
    ICorDebugModule * This,
    /* [in] */ BOOL bClassLoadCallbacks);


void __RPC_STUB ICorDebugModule_EnableClassLoadCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetFunctionFromToken_Proxy( 
    ICorDebugModule * This,
    /* [in] */ mdMethodDef methodDef,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugModule_GetFunctionFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetFunctionFromRVA_Proxy( 
    ICorDebugModule * This,
    /* [in] */ CORDB_ADDRESS rva,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugModule_GetFunctionFromRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetClassFromToken_Proxy( 
    ICorDebugModule * This,
    /* [in] */ mdTypeDef typeDef,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugModule_GetClassFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_CreateBreakpoint_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugModuleBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugModule_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetEditAndContinueSnapshot_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot);


void __RPC_STUB ICorDebugModule_GetEditAndContinueSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetMetaDataInterface_Proxy( 
    ICorDebugModule * This,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppObj);


void __RPC_STUB ICorDebugModule_GetMetaDataInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetToken_Proxy( 
    ICorDebugModule * This,
    /* [out] */ mdModule *pToken);


void __RPC_STUB ICorDebugModule_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_IsDynamic_Proxy( 
    ICorDebugModule * This,
    /* [out] */ BOOL *pDynamic);


void __RPC_STUB ICorDebugModule_IsDynamic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetGlobalVariableValue_Proxy( 
    ICorDebugModule * This,
    /* [in] */ mdFieldDef fieldDef,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugModule_GetGlobalVariableValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetSize_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ULONG32 *pcBytes);


void __RPC_STUB ICorDebugModule_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_IsInMemory_Proxy( 
    ICorDebugModule * This,
    /* [out] */ BOOL *pInMemory);


void __RPC_STUB ICorDebugModule_IsInMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModule_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModule2_INTERFACE_DEFINED__
#define __ICorDebugModule2_INTERFACE_DEFINED__

/* interface ICorDebugModule2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModule2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FCC5FB5-49C0-41de-9938-3B88B5B9ADD7")
    ICorDebugModule2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetJMCStatus( 
            /* [in] */ BOOL bIsJustMyCode,
            /* [in] */ ULONG32 cTokens,
            /* [size_is][in] */ mdToken pTokens[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyChanges( 
            /* [in] */ ULONG cbMetadata,
            /* [size_is][in] */ BYTE pbMetadata[  ],
            /* [in] */ ULONG cbIL,
            /* [size_is][in] */ BYTE pbIL[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetJITCompilerFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJITCompilerFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResolveAssembly( 
            /* [in] */ mdToken tkAssemblyRef,
            /* [out] */ ICorDebugAssembly **ppAssembly) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModule2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModule2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModule2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModule2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetJMCStatus )( 
            ICorDebugModule2 * This,
            /* [in] */ BOOL bIsJustMyCode,
            /* [in] */ ULONG32 cTokens,
            /* [size_is][in] */ mdToken pTokens[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyChanges )( 
            ICorDebugModule2 * This,
            /* [in] */ ULONG cbMetadata,
            /* [size_is][in] */ BYTE pbMetadata[  ],
            /* [in] */ ULONG cbIL,
            /* [size_is][in] */ BYTE pbIL[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetJITCompilerFlags )( 
            ICorDebugModule2 * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetJITCompilerFlags )( 
            ICorDebugModule2 * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveAssembly )( 
            ICorDebugModule2 * This,
            /* [in] */ mdToken tkAssemblyRef,
            /* [out] */ ICorDebugAssembly **ppAssembly);
        
        END_INTERFACE
    } ICorDebugModule2Vtbl;

    interface ICorDebugModule2
    {
        CONST_VTBL struct ICorDebugModule2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModule2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModule2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModule2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModule2_SetJMCStatus(This,bIsJustMyCode,cTokens,pTokens)	\
    (This)->lpVtbl -> SetJMCStatus(This,bIsJustMyCode,cTokens,pTokens)

#define ICorDebugModule2_ApplyChanges(This,cbMetadata,pbMetadata,cbIL,pbIL)	\
    (This)->lpVtbl -> ApplyChanges(This,cbMetadata,pbMetadata,cbIL,pbIL)

#define ICorDebugModule2_SetJITCompilerFlags(This,dwFlags)	\
    (This)->lpVtbl -> SetJITCompilerFlags(This,dwFlags)

#define ICorDebugModule2_GetJITCompilerFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetJITCompilerFlags(This,pdwFlags)

#define ICorDebugModule2_ResolveAssembly(This,tkAssemblyRef,ppAssembly)	\
    (This)->lpVtbl -> ResolveAssembly(This,tkAssemblyRef,ppAssembly)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModule2_SetJMCStatus_Proxy( 
    ICorDebugModule2 * This,
    /* [in] */ BOOL bIsJustMyCode,
    /* [in] */ ULONG32 cTokens,
    /* [size_is][in] */ mdToken pTokens[  ]);


void __RPC_STUB ICorDebugModule2_SetJMCStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule2_ApplyChanges_Proxy( 
    ICorDebugModule2 * This,
    /* [in] */ ULONG cbMetadata,
    /* [size_is][in] */ BYTE pbMetadata[  ],
    /* [in] */ ULONG cbIL,
    /* [size_is][in] */ BYTE pbIL[  ]);


void __RPC_STUB ICorDebugModule2_ApplyChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule2_SetJITCompilerFlags_Proxy( 
    ICorDebugModule2 * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICorDebugModule2_SetJITCompilerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule2_GetJITCompilerFlags_Proxy( 
    ICorDebugModule2 * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ICorDebugModule2_GetJITCompilerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule2_ResolveAssembly_Proxy( 
    ICorDebugModule2 * This,
    /* [in] */ mdToken tkAssemblyRef,
    /* [out] */ ICorDebugAssembly **ppAssembly);


void __RPC_STUB ICorDebugModule2_ResolveAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModule2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFunction_INTERFACE_DEFINED__
#define __ICorDebugFunction_INTERFACE_DEFINED__

/* interface ICorDebugFunction */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFunction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF3-8A68-11d2-983C-0000F808342D")
    ICorDebugFunction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClass( 
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdMethodDef *pMethodDef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILCode( 
            /* [out] */ ICorDebugCode **ppCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNativeCode( 
            /* [out] */ ICorDebugCode **ppCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalVarSigToken( 
            /* [out] */ mdSignature *pmdSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVersionNumber( 
            /* [out] */ ULONG32 *pnCurrentVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFunctionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFunction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFunction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFunction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugModule **ppModule);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugFunction * This,
            /* [out] */ mdMethodDef *pMethodDef);
        
        HRESULT ( STDMETHODCALLTYPE *GetILCode )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeCode )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalVarSigToken )( 
            ICorDebugFunction * This,
            /* [out] */ mdSignature *pmdSig);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVersionNumber )( 
            ICorDebugFunction * This,
            /* [out] */ ULONG32 *pnCurrentVersion);
        
        END_INTERFACE
    } ICorDebugFunctionVtbl;

    interface ICorDebugFunction
    {
        CONST_VTBL struct ICorDebugFunctionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFunction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFunction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFunction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFunction_GetModule(This,ppModule)	\
    (This)->lpVtbl -> GetModule(This,ppModule)

#define ICorDebugFunction_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugFunction_GetToken(This,pMethodDef)	\
    (This)->lpVtbl -> GetToken(This,pMethodDef)

#define ICorDebugFunction_GetILCode(This,ppCode)	\
    (This)->lpVtbl -> GetILCode(This,ppCode)

#define ICorDebugFunction_GetNativeCode(This,ppCode)	\
    (This)->lpVtbl -> GetNativeCode(This,ppCode)

#define ICorDebugFunction_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)

#define ICorDebugFunction_GetLocalVarSigToken(This,pmdSig)	\
    (This)->lpVtbl -> GetLocalVarSigToken(This,pmdSig)

#define ICorDebugFunction_GetCurrentVersionNumber(This,pnCurrentVersion)	\
    (This)->lpVtbl -> GetCurrentVersionNumber(This,pnCurrentVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetModule_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugFunction_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetClass_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugFunction_GetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetToken_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ mdMethodDef *pMethodDef);


void __RPC_STUB ICorDebugFunction_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetILCode_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugCode **ppCode);


void __RPC_STUB ICorDebugFunction_GetILCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetNativeCode_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugCode **ppCode);


void __RPC_STUB ICorDebugFunction_GetNativeCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_CreateBreakpoint_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugFunction_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetLocalVarSigToken_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ mdSignature *pmdSig);


void __RPC_STUB ICorDebugFunction_GetLocalVarSigToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetCurrentVersionNumber_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ULONG32 *pnCurrentVersion);


void __RPC_STUB ICorDebugFunction_GetCurrentVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFunction_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFunction2_INTERFACE_DEFINED__
#define __ICorDebugFunction2_INTERFACE_DEFINED__

/* interface ICorDebugFunction2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFunction2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF0C490B-94C3-4e4d-B629-DDC134C532D8")
    ICorDebugFunction2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetJMCStatus( 
            /* [in] */ BOOL bIsJustMyCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJMCStatus( 
            /* [out] */ BOOL *pbIsJustMyCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateNativeCode( 
            /* [out] */ ICorDebugCodeEnum **ppCodeEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ ULONG32 *pnVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFunction2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFunction2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFunction2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFunction2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetJMCStatus )( 
            ICorDebugFunction2 * This,
            /* [in] */ BOOL bIsJustMyCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetJMCStatus )( 
            ICorDebugFunction2 * This,
            /* [out] */ BOOL *pbIsJustMyCode);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateNativeCode )( 
            ICorDebugFunction2 * This,
            /* [out] */ ICorDebugCodeEnum **ppCodeEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            ICorDebugFunction2 * This,
            /* [out] */ ULONG32 *pnVersion);
        
        END_INTERFACE
    } ICorDebugFunction2Vtbl;

    interface ICorDebugFunction2
    {
        CONST_VTBL struct ICorDebugFunction2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFunction2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFunction2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFunction2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFunction2_SetJMCStatus(This,bIsJustMyCode)	\
    (This)->lpVtbl -> SetJMCStatus(This,bIsJustMyCode)

#define ICorDebugFunction2_GetJMCStatus(This,pbIsJustMyCode)	\
    (This)->lpVtbl -> GetJMCStatus(This,pbIsJustMyCode)

#define ICorDebugFunction2_EnumerateNativeCode(This,ppCodeEnum)	\
    (This)->lpVtbl -> EnumerateNativeCode(This,ppCodeEnum)

#define ICorDebugFunction2_GetVersionNumber(This,pnVersion)	\
    (This)->lpVtbl -> GetVersionNumber(This,pnVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFunction2_SetJMCStatus_Proxy( 
    ICorDebugFunction2 * This,
    /* [in] */ BOOL bIsJustMyCode);


void __RPC_STUB ICorDebugFunction2_SetJMCStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction2_GetJMCStatus_Proxy( 
    ICorDebugFunction2 * This,
    /* [out] */ BOOL *pbIsJustMyCode);


void __RPC_STUB ICorDebugFunction2_GetJMCStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction2_EnumerateNativeCode_Proxy( 
    ICorDebugFunction2 * This,
    /* [out] */ ICorDebugCodeEnum **ppCodeEnum);


void __RPC_STUB ICorDebugFunction2_EnumerateNativeCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction2_GetVersionNumber_Proxy( 
    ICorDebugFunction2 * This,
    /* [out] */ ULONG32 *pnVersion);


void __RPC_STUB ICorDebugFunction2_GetVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFunction2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugCode_INTERFACE_DEFINED__
#define __ICorDebugCode_INTERFACE_DEFINED__

/* interface ICorDebugCode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugCode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF4-8A68-11d2-983C-0000F808342D")
    ICorDebugCode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsIL( 
            /* [out] */ BOOL *pbIL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddress( 
            /* [out] */ CORDB_ADDRESS *pStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG32 *pcBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [in] */ ULONG32 offset,
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCode( 
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset,
            /* [in] */ ULONG32 cBufferAlloc,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ ULONG32 *pcBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ ULONG32 *nVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILToNativeMapping( 
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnCRemapSequencePoints( 
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ ULONG32 offsets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugCodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugCode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugCode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugCode * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsIL )( 
            ICorDebugCode * This,
            /* [out] */ BOOL *pbIL);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugCode * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugCode * This,
            /* [out] */ CORDB_ADDRESS *pStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugCode * This,
            /* [out] */ ULONG32 *pcBytes);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 offset,
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset,
            /* [in] */ ULONG32 cBufferAlloc,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ ULONG32 *pcBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            ICorDebugCode * This,
            /* [out] */ ULONG32 *nVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetILToNativeMapping )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnCRemapSequencePoints )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ ULONG32 offsets[  ]);
        
        END_INTERFACE
    } ICorDebugCodeVtbl;

    interface ICorDebugCode
    {
        CONST_VTBL struct ICorDebugCodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugCode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugCode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugCode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugCode_IsIL(This,pbIL)	\
    (This)->lpVtbl -> IsIL(This,pbIL)

#define ICorDebugCode_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugCode_GetAddress(This,pStart)	\
    (This)->lpVtbl -> GetAddress(This,pStart)

#define ICorDebugCode_GetSize(This,pcBytes)	\
    (This)->lpVtbl -> GetSize(This,pcBytes)

#define ICorDebugCode_CreateBreakpoint(This,offset,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,offset,ppBreakpoint)

#define ICorDebugCode_GetCode(This,startOffset,endOffset,cBufferAlloc,buffer,pcBufferSize)	\
    (This)->lpVtbl -> GetCode(This,startOffset,endOffset,cBufferAlloc,buffer,pcBufferSize)

#define ICorDebugCode_GetVersionNumber(This,nVersion)	\
    (This)->lpVtbl -> GetVersionNumber(This,nVersion)

#define ICorDebugCode_GetILToNativeMapping(This,cMap,pcMap,map)	\
    (This)->lpVtbl -> GetILToNativeMapping(This,cMap,pcMap,map)

#define ICorDebugCode_GetEnCRemapSequencePoints(This,cMap,pcMap,offsets)	\
    (This)->lpVtbl -> GetEnCRemapSequencePoints(This,cMap,pcMap,offsets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugCode_IsIL_Proxy( 
    ICorDebugCode * This,
    /* [out] */ BOOL *pbIL);


void __RPC_STUB ICorDebugCode_IsIL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetFunction_Proxy( 
    ICorDebugCode * This,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugCode_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetAddress_Proxy( 
    ICorDebugCode * This,
    /* [out] */ CORDB_ADDRESS *pStart);


void __RPC_STUB ICorDebugCode_GetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetSize_Proxy( 
    ICorDebugCode * This,
    /* [out] */ ULONG32 *pcBytes);


void __RPC_STUB ICorDebugCode_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_CreateBreakpoint_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 offset,
    /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugCode_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetCode_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 startOffset,
    /* [in] */ ULONG32 endOffset,
    /* [in] */ ULONG32 cBufferAlloc,
    /* [length_is][size_is][out] */ BYTE buffer[  ],
    /* [out] */ ULONG32 *pcBufferSize);


void __RPC_STUB ICorDebugCode_GetCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetVersionNumber_Proxy( 
    ICorDebugCode * This,
    /* [out] */ ULONG32 *nVersion);


void __RPC_STUB ICorDebugCode_GetVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetILToNativeMapping_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 cMap,
    /* [out] */ ULONG32 *pcMap,
    /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);


void __RPC_STUB ICorDebugCode_GetILToNativeMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetEnCRemapSequencePoints_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 cMap,
    /* [out] */ ULONG32 *pcMap,
    /* [length_is][size_is][out] */ ULONG32 offsets[  ]);


void __RPC_STUB ICorDebugCode_GetEnCRemapSequencePoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugCode_INTERFACE_DEFINED__ */


#ifndef __ICorDebugCode2_INTERFACE_DEFINED__
#define __ICorDebugCode2_INTERFACE_DEFINED__

/* interface ICorDebugCode2 */
/* [unique][uuid][object] */ 

typedef struct _CodeChunkInfo
    {
    CORDB_ADDRESS startAddr;
    ULONG32 length;
    } 	CodeChunkInfo;


EXTERN_C const IID IID_ICorDebugCode2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F696509-452F-4436-A3FE-4D11FE7E2347")
    ICorDebugCode2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodeChunks( 
            /* [in] */ ULONG32 cbufSize,
            /* [out] */ ULONG32 *pcnumChunks,
            /* [length_is][size_is][out] */ CodeChunkInfo chunks[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompilerFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugCode2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugCode2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugCode2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugCode2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeChunks )( 
            ICorDebugCode2 * This,
            /* [in] */ ULONG32 cbufSize,
            /* [out] */ ULONG32 *pcnumChunks,
            /* [length_is][size_is][out] */ CodeChunkInfo chunks[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompilerFlags )( 
            ICorDebugCode2 * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } ICorDebugCode2Vtbl;

    interface ICorDebugCode2
    {
        CONST_VTBL struct ICorDebugCode2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugCode2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugCode2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugCode2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugCode2_GetCodeChunks(This,cbufSize,pcnumChunks,chunks)	\
    (This)->lpVtbl -> GetCodeChunks(This,cbufSize,pcnumChunks,chunks)

#define ICorDebugCode2_GetCompilerFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetCompilerFlags(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugCode2_GetCodeChunks_Proxy( 
    ICorDebugCode2 * This,
    /* [in] */ ULONG32 cbufSize,
    /* [out] */ ULONG32 *pcnumChunks,
    /* [length_is][size_is][out] */ CodeChunkInfo chunks[  ]);


void __RPC_STUB ICorDebugCode2_GetCodeChunks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode2_GetCompilerFlags_Proxy( 
    ICorDebugCode2 * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ICorDebugCode2_GetCompilerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugCode2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugClass_INTERFACE_DEFINED__
#define __ICorDebugClass_INTERFACE_DEFINED__

/* interface ICorDebugClass */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugClass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF5-8A68-11d2-983C-0000F808342D")
    ICorDebugClass : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **pModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdTypeDef *pTypeDef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStaticFieldValue( 
            /* [in] */ mdFieldDef fieldDef,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugClassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugClass * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugClass * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugClass * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugClass * This,
            /* [out] */ ICorDebugModule **pModule);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugClass * This,
            /* [out] */ mdTypeDef *pTypeDef);
        
        HRESULT ( STDMETHODCALLTYPE *GetStaticFieldValue )( 
            ICorDebugClass * This,
            /* [in] */ mdFieldDef fieldDef,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugClassVtbl;

    interface ICorDebugClass
    {
        CONST_VTBL struct ICorDebugClassVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugClass_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugClass_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugClass_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugClass_GetModule(This,pModule)	\
    (This)->lpVtbl -> GetModule(This,pModule)

#define ICorDebugClass_GetToken(This,pTypeDef)	\
    (This)->lpVtbl -> GetToken(This,pTypeDef)

#define ICorDebugClass_GetStaticFieldValue(This,fieldDef,pFrame,ppValue)	\
    (This)->lpVtbl -> GetStaticFieldValue(This,fieldDef,pFrame,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugClass_GetModule_Proxy( 
    ICorDebugClass * This,
    /* [out] */ ICorDebugModule **pModule);


void __RPC_STUB ICorDebugClass_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugClass_GetToken_Proxy( 
    ICorDebugClass * This,
    /* [out] */ mdTypeDef *pTypeDef);


void __RPC_STUB ICorDebugClass_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugClass_GetStaticFieldValue_Proxy( 
    ICorDebugClass * This,
    /* [in] */ mdFieldDef fieldDef,
    /* [in] */ ICorDebugFrame *pFrame,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugClass_GetStaticFieldValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugClass_INTERFACE_DEFINED__ */


#ifndef __ICorDebugClass2_INTERFACE_DEFINED__
#define __ICorDebugClass2_INTERFACE_DEFINED__

/* interface ICorDebugClass2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugClass2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B008EA8D-7AB1-43f7-BB20-FBB5A04038AE")
    ICorDebugClass2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParameterizedType( 
            /* [in] */ CorElementType elementType,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [out] */ ICorDebugType **ppType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetJMCStatus( 
            /* [in] */ BOOL bIsJustMyCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugClass2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugClass2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugClass2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugClass2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterizedType )( 
            ICorDebugClass2 * This,
            /* [in] */ CorElementType elementType,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [out] */ ICorDebugType **ppType);
        
        HRESULT ( STDMETHODCALLTYPE *SetJMCStatus )( 
            ICorDebugClass2 * This,
            /* [in] */ BOOL bIsJustMyCode);
        
        END_INTERFACE
    } ICorDebugClass2Vtbl;

    interface ICorDebugClass2
    {
        CONST_VTBL struct ICorDebugClass2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugClass2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugClass2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugClass2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugClass2_GetParameterizedType(This,elementType,nTypeArgs,ppTypeArgs,ppType)	\
    (This)->lpVtbl -> GetParameterizedType(This,elementType,nTypeArgs,ppTypeArgs,ppType)

#define ICorDebugClass2_SetJMCStatus(This,bIsJustMyCode)	\
    (This)->lpVtbl -> SetJMCStatus(This,bIsJustMyCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugClass2_GetParameterizedType_Proxy( 
    ICorDebugClass2 * This,
    /* [in] */ CorElementType elementType,
    /* [in] */ ULONG32 nTypeArgs,
    /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
    /* [out] */ ICorDebugType **ppType);


void __RPC_STUB ICorDebugClass2_GetParameterizedType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugClass2_SetJMCStatus_Proxy( 
    ICorDebugClass2 * This,
    /* [in] */ BOOL bIsJustMyCode);


void __RPC_STUB ICorDebugClass2_SetJMCStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugClass2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEval_INTERFACE_DEFINED__
#define __ICorDebugEval_INTERFACE_DEFINED__

/* interface ICorDebugEval */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEval;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF6-8A68-11d2-983C-0000F808342D")
    ICorDebugEval : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallFunction( 
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewObject( 
            /* [in] */ ICorDebugFunction *pConstructor,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewObjectNoConstructor( 
            /* [in] */ ICorDebugClass *pClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewString( 
            /* [in] */ LPCWSTR string) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewArray( 
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [in] */ ULONG32 rank,
            /* [size_is][in] */ ULONG32 dims[  ],
            /* [size_is][in] */ ULONG32 lowBounds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( 
            /* [out] */ BOOL *pbActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResult( 
            /* [out] */ ICorDebugValue **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateValue( 
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEvalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEval * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEval * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEval * This);
        
        HRESULT ( STDMETHODCALLTYPE *CallFunction )( 
            ICorDebugEval * This,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewObject )( 
            ICorDebugEval * This,
            /* [in] */ ICorDebugFunction *pConstructor,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewObjectNoConstructor )( 
            ICorDebugEval * This,
            /* [in] */ ICorDebugClass *pClass);
        
        HRESULT ( STDMETHODCALLTYPE *NewString )( 
            ICorDebugEval * This,
            /* [in] */ LPCWSTR string);
        
        HRESULT ( STDMETHODCALLTYPE *NewArray )( 
            ICorDebugEval * This,
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [in] */ ULONG32 rank,
            /* [size_is][in] */ ULONG32 dims[  ],
            /* [size_is][in] */ ULONG32 lowBounds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugEval * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ICorDebugEval * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            ICorDebugEval * This,
            /* [out] */ ICorDebugValue **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            ICorDebugEval * This,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *CreateValue )( 
            ICorDebugEval * This,
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugEvalVtbl;

    interface ICorDebugEval
    {
        CONST_VTBL struct ICorDebugEvalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEval_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEval_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEval_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEval_CallFunction(This,pFunction,nArgs,ppArgs)	\
    (This)->lpVtbl -> CallFunction(This,pFunction,nArgs,ppArgs)

#define ICorDebugEval_NewObject(This,pConstructor,nArgs,ppArgs)	\
    (This)->lpVtbl -> NewObject(This,pConstructor,nArgs,ppArgs)

#define ICorDebugEval_NewObjectNoConstructor(This,pClass)	\
    (This)->lpVtbl -> NewObjectNoConstructor(This,pClass)

#define ICorDebugEval_NewString(This,string)	\
    (This)->lpVtbl -> NewString(This,string)

#define ICorDebugEval_NewArray(This,elementType,pElementClass,rank,dims,lowBounds)	\
    (This)->lpVtbl -> NewArray(This,elementType,pElementClass,rank,dims,lowBounds)

#define ICorDebugEval_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)

#define ICorDebugEval_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define ICorDebugEval_GetResult(This,ppResult)	\
    (This)->lpVtbl -> GetResult(This,ppResult)

#define ICorDebugEval_GetThread(This,ppThread)	\
    (This)->lpVtbl -> GetThread(This,ppThread)

#define ICorDebugEval_CreateValue(This,elementType,pElementClass,ppValue)	\
    (This)->lpVtbl -> CreateValue(This,elementType,pElementClass,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEval_CallFunction_Proxy( 
    ICorDebugEval * This,
    /* [in] */ ICorDebugFunction *pFunction,
    /* [in] */ ULONG32 nArgs,
    /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);


void __RPC_STUB ICorDebugEval_CallFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewObject_Proxy( 
    ICorDebugEval * This,
    /* [in] */ ICorDebugFunction *pConstructor,
    /* [in] */ ULONG32 nArgs,
    /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);


void __RPC_STUB ICorDebugEval_NewObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewObjectNoConstructor_Proxy( 
    ICorDebugEval * This,
    /* [in] */ ICorDebugClass *pClass);


void __RPC_STUB ICorDebugEval_NewObjectNoConstructor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewString_Proxy( 
    ICorDebugEval * This,
    /* [in] */ LPCWSTR string);


void __RPC_STUB ICorDebugEval_NewString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewArray_Proxy( 
    ICorDebugEval * This,
    /* [in] */ CorElementType elementType,
    /* [in] */ ICorDebugClass *pElementClass,
    /* [in] */ ULONG32 rank,
    /* [size_is][in] */ ULONG32 dims[  ],
    /* [size_is][in] */ ULONG32 lowBounds[  ]);


void __RPC_STUB ICorDebugEval_NewArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_IsActive_Proxy( 
    ICorDebugEval * This,
    /* [out] */ BOOL *pbActive);


void __RPC_STUB ICorDebugEval_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_Abort_Proxy( 
    ICorDebugEval * This);


void __RPC_STUB ICorDebugEval_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_GetResult_Proxy( 
    ICorDebugEval * This,
    /* [out] */ ICorDebugValue **ppResult);


void __RPC_STUB ICorDebugEval_GetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_GetThread_Proxy( 
    ICorDebugEval * This,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugEval_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_CreateValue_Proxy( 
    ICorDebugEval * This,
    /* [in] */ CorElementType elementType,
    /* [in] */ ICorDebugClass *pElementClass,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugEval_CreateValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEval_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEval2_INTERFACE_DEFINED__
#define __ICorDebugEval2_INTERFACE_DEFINED__

/* interface ICorDebugEval2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEval2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FB0D9CE7-BE66-4683-9D32-A42A04E2FD91")
    ICorDebugEval2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallParameterizedFunction( 
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateValueForType( 
            /* [in] */ ICorDebugType *pType,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewParameterizedObject( 
            /* [in] */ ICorDebugFunction *pConstructor,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewParameterizedObjectNoConstructor( 
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewParameterizedArray( 
            /* [in] */ ICorDebugType *pElementType,
            /* [in] */ ULONG32 rank,
            /* [size_is][in] */ ULONG32 dims[  ],
            /* [size_is][in] */ ULONG32 lowBounds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewStringWithLength( 
            /* [in] */ LPCWSTR string,
            /* [in] */ UINT uiLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RudeAbort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEval2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEval2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEval2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEval2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CallParameterizedFunction )( 
            ICorDebugEval2 * This,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *CreateValueForType )( 
            ICorDebugEval2 * This,
            /* [in] */ ICorDebugType *pType,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *NewParameterizedObject )( 
            ICorDebugEval2 * This,
            /* [in] */ ICorDebugFunction *pConstructor,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewParameterizedObjectNoConstructor )( 
            ICorDebugEval2 * This,
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewParameterizedArray )( 
            ICorDebugEval2 * This,
            /* [in] */ ICorDebugType *pElementType,
            /* [in] */ ULONG32 rank,
            /* [size_is][in] */ ULONG32 dims[  ],
            /* [size_is][in] */ ULONG32 lowBounds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewStringWithLength )( 
            ICorDebugEval2 * This,
            /* [in] */ LPCWSTR string,
            /* [in] */ UINT uiLength);
        
        HRESULT ( STDMETHODCALLTYPE *RudeAbort )( 
            ICorDebugEval2 * This);
        
        END_INTERFACE
    } ICorDebugEval2Vtbl;

    interface ICorDebugEval2
    {
        CONST_VTBL struct ICorDebugEval2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEval2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEval2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEval2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEval2_CallParameterizedFunction(This,pFunction,nTypeArgs,ppTypeArgs,nArgs,ppArgs)	\
    (This)->lpVtbl -> CallParameterizedFunction(This,pFunction,nTypeArgs,ppTypeArgs,nArgs,ppArgs)

#define ICorDebugEval2_CreateValueForType(This,pType,ppValue)	\
    (This)->lpVtbl -> CreateValueForType(This,pType,ppValue)

#define ICorDebugEval2_NewParameterizedObject(This,pConstructor,nTypeArgs,ppTypeArgs,nArgs,ppArgs)	\
    (This)->lpVtbl -> NewParameterizedObject(This,pConstructor,nTypeArgs,ppTypeArgs,nArgs,ppArgs)

#define ICorDebugEval2_NewParameterizedObjectNoConstructor(This,pClass,nTypeArgs,ppTypeArgs)	\
    (This)->lpVtbl -> NewParameterizedObjectNoConstructor(This,pClass,nTypeArgs,ppTypeArgs)

#define ICorDebugEval2_NewParameterizedArray(This,pElementType,rank,dims,lowBounds)	\
    (This)->lpVtbl -> NewParameterizedArray(This,pElementType,rank,dims,lowBounds)

#define ICorDebugEval2_NewStringWithLength(This,string,uiLength)	\
    (This)->lpVtbl -> NewStringWithLength(This,string,uiLength)

#define ICorDebugEval2_RudeAbort(This)	\
    (This)->lpVtbl -> RudeAbort(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEval2_CallParameterizedFunction_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ ICorDebugFunction *pFunction,
    /* [in] */ ULONG32 nTypeArgs,
    /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
    /* [in] */ ULONG32 nArgs,
    /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);


void __RPC_STUB ICorDebugEval2_CallParameterizedFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_CreateValueForType_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ ICorDebugType *pType,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugEval2_CreateValueForType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_NewParameterizedObject_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ ICorDebugFunction *pConstructor,
    /* [in] */ ULONG32 nTypeArgs,
    /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
    /* [in] */ ULONG32 nArgs,
    /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);


void __RPC_STUB ICorDebugEval2_NewParameterizedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_NewParameterizedObjectNoConstructor_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ ICorDebugClass *pClass,
    /* [in] */ ULONG32 nTypeArgs,
    /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ]);


void __RPC_STUB ICorDebugEval2_NewParameterizedObjectNoConstructor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_NewParameterizedArray_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ ICorDebugType *pElementType,
    /* [in] */ ULONG32 rank,
    /* [size_is][in] */ ULONG32 dims[  ],
    /* [size_is][in] */ ULONG32 lowBounds[  ]);


void __RPC_STUB ICorDebugEval2_NewParameterizedArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_NewStringWithLength_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ LPCWSTR string,
    /* [in] */ UINT uiLength);


void __RPC_STUB ICorDebugEval2_NewStringWithLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_RudeAbort_Proxy( 
    ICorDebugEval2 * This);


void __RPC_STUB ICorDebugEval2_RudeAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEval2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValue_INTERFACE_DEFINED__
#define __ICorDebugValue_INTERFACE_DEFINED__

/* interface ICorDebugValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF7-8A68-11d2-983C-0000F808342D")
    ICorDebugValue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ CorElementType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG32 *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddress( 
            /* [out] */ CORDB_ADDRESS *pAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        END_INTERFACE
    } ICorDebugValueVtbl;

    interface ICorDebugValue
    {
        CONST_VTBL struct ICorDebugValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValue_GetType_Proxy( 
    ICorDebugValue * This,
    /* [out] */ CorElementType *pType);


void __RPC_STUB ICorDebugValue_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugValue_GetSize_Proxy( 
    ICorDebugValue * This,
    /* [out] */ ULONG32 *pSize);


void __RPC_STUB ICorDebugValue_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugValue_GetAddress_Proxy( 
    ICorDebugValue * This,
    /* [out] */ CORDB_ADDRESS *pAddress);


void __RPC_STUB ICorDebugValue_GetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugValue_CreateBreakpoint_Proxy( 
    ICorDebugValue * This,
    /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugValue_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValue2_INTERFACE_DEFINED__
#define __ICorDebugValue2_INTERFACE_DEFINED__

/* interface ICorDebugValue2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValue2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5E0B54E7-D88A-4626-9420-A691E0A78B49")
    ICorDebugValue2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExactType( 
            /* [out] */ ICorDebugType **ppType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValue2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValue2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValue2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValue2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetExactType )( 
            ICorDebugValue2 * This,
            /* [out] */ ICorDebugType **ppType);
        
        END_INTERFACE
    } ICorDebugValue2Vtbl;

    interface ICorDebugValue2
    {
        CONST_VTBL struct ICorDebugValue2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValue2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValue2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValue2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValue2_GetExactType(This,ppType)	\
    (This)->lpVtbl -> GetExactType(This,ppType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValue2_GetExactType_Proxy( 
    ICorDebugValue2 * This,
    /* [out] */ ICorDebugType **ppType);


void __RPC_STUB ICorDebugValue2_GetExactType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValue2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugGenericValue_INTERFACE_DEFINED__
#define __ICorDebugGenericValue_INTERFACE_DEFINED__

/* interface ICorDebugGenericValue */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICorDebugGenericValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF8-8A68-11d2-983C-0000F808342D")
    ICorDebugGenericValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ void *pTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ void *pFrom) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugGenericValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugGenericValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugGenericValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugGenericValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugGenericValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugGenericValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugGenericValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugGenericValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugGenericValue * This,
            /* [out] */ void *pTo);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICorDebugGenericValue * This,
            /* [in] */ void *pFrom);
        
        END_INTERFACE
    } ICorDebugGenericValueVtbl;

    interface ICorDebugGenericValue
    {
        CONST_VTBL struct ICorDebugGenericValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugGenericValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugGenericValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugGenericValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugGenericValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugGenericValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugGenericValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugGenericValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugGenericValue_GetValue(This,pTo)	\
    (This)->lpVtbl -> GetValue(This,pTo)

#define ICorDebugGenericValue_SetValue(This,pFrom)	\
    (This)->lpVtbl -> SetValue(This,pFrom)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugGenericValue_GetValue_Proxy( 
    ICorDebugGenericValue * This,
    /* [out] */ void *pTo);


void __RPC_STUB ICorDebugGenericValue_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugGenericValue_SetValue_Proxy( 
    ICorDebugGenericValue * This,
    /* [in] */ void *pFrom);


void __RPC_STUB ICorDebugGenericValue_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugGenericValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugReferenceValue_INTERFACE_DEFINED__
#define __ICorDebugReferenceValue_INTERFACE_DEFINED__

/* interface ICorDebugReferenceValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugReferenceValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF9-8A68-11d2-983C-0000F808342D")
    ICorDebugReferenceValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsNull( 
            /* [out] */ BOOL *pbNull) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ CORDB_ADDRESS *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ CORDB_ADDRESS value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Dereference( 
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DereferenceStrong( 
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugReferenceValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugReferenceValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugReferenceValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugReferenceValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugReferenceValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugReferenceValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsNull )( 
            ICorDebugReferenceValue * This,
            /* [out] */ BOOL *pbNull);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugReferenceValue * This,
            /* [out] */ CORDB_ADDRESS *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICorDebugReferenceValue * This,
            /* [in] */ CORDB_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *Dereference )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *DereferenceStrong )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugReferenceValueVtbl;

    interface ICorDebugReferenceValue
    {
        CONST_VTBL struct ICorDebugReferenceValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugReferenceValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugReferenceValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugReferenceValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugReferenceValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugReferenceValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugReferenceValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugReferenceValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugReferenceValue_IsNull(This,pbNull)	\
    (This)->lpVtbl -> IsNull(This,pbNull)

#define ICorDebugReferenceValue_GetValue(This,pValue)	\
    (This)->lpVtbl -> GetValue(This,pValue)

#define ICorDebugReferenceValue_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#define ICorDebugReferenceValue_Dereference(This,ppValue)	\
    (This)->lpVtbl -> Dereference(This,ppValue)

#define ICorDebugReferenceValue_DereferenceStrong(This,ppValue)	\
    (This)->lpVtbl -> DereferenceStrong(This,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_IsNull_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ BOOL *pbNull);


void __RPC_STUB ICorDebugReferenceValue_IsNull_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_GetValue_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ CORDB_ADDRESS *pValue);


void __RPC_STUB ICorDebugReferenceValue_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_SetValue_Proxy( 
    ICorDebugReferenceValue * This,
    /* [in] */ CORDB_ADDRESS value);


void __RPC_STUB ICorDebugReferenceValue_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_Dereference_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugReferenceValue_Dereference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_DereferenceStrong_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugReferenceValue_DereferenceStrong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugReferenceValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugHeapValue_INTERFACE_DEFINED__
#define __ICorDebugHeapValue_INTERFACE_DEFINED__

/* interface ICorDebugHeapValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugHeapValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAFA-8A68-11d2-983C-0000F808342D")
    ICorDebugHeapValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsValid( 
            /* [out] */ BOOL *pbValid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRelocBreakpoint( 
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugHeapValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugHeapValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugHeapValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugHeapValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugHeapValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugHeapValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugHeapValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugHeapValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugHeapValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugHeapValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        END_INTERFACE
    } ICorDebugHeapValueVtbl;

    interface ICorDebugHeapValue
    {
        CONST_VTBL struct ICorDebugHeapValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugHeapValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugHeapValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugHeapValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugHeapValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugHeapValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugHeapValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugHeapValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugHeapValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugHeapValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugHeapValue_IsValid_Proxy( 
    ICorDebugHeapValue * This,
    /* [out] */ BOOL *pbValid);


void __RPC_STUB ICorDebugHeapValue_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugHeapValue_CreateRelocBreakpoint_Proxy( 
    ICorDebugHeapValue * This,
    /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugHeapValue_CreateRelocBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugHeapValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugHeapValue2_INTERFACE_DEFINED__
#define __ICorDebugHeapValue2_INTERFACE_DEFINED__

/* interface ICorDebugHeapValue2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugHeapValue2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E3AC4D6C-9CB7-43e6-96CC-B21540E5083C")
    ICorDebugHeapValue2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateHandle( 
            /* [in] */ CorDebugHandleType type,
            /* [out] */ ICorDebugHandleValue **ppHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugHeapValue2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugHeapValue2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugHeapValue2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugHeapValue2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateHandle )( 
            ICorDebugHeapValue2 * This,
            /* [in] */ CorDebugHandleType type,
            /* [out] */ ICorDebugHandleValue **ppHandle);
        
        END_INTERFACE
    } ICorDebugHeapValue2Vtbl;

    interface ICorDebugHeapValue2
    {
        CONST_VTBL struct ICorDebugHeapValue2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugHeapValue2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugHeapValue2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugHeapValue2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugHeapValue2_CreateHandle(This,type,ppHandle)	\
    (This)->lpVtbl -> CreateHandle(This,type,ppHandle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugHeapValue2_CreateHandle_Proxy( 
    ICorDebugHeapValue2 * This,
    /* [in] */ CorDebugHandleType type,
    /* [out] */ ICorDebugHandleValue **ppHandle);


void __RPC_STUB ICorDebugHeapValue2_CreateHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugHeapValue2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugObjectValue_INTERFACE_DEFINED__
#define __ICorDebugObjectValue_INTERFACE_DEFINED__

/* interface ICorDebugObjectValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugObjectValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18AD3D6E-B7D2-11d2-BD04-0000F80849BD")
    ICorDebugObjectValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClass( 
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFieldValue( 
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualMethod( 
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ ICorDebugContext **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsValueClass( 
            /* [out] */ BOOL *pbIsValueClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManagedCopy( 
            /* [out] */ IUnknown **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFromManagedCopy( 
            /* [in] */ IUnknown *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugObjectValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugObjectValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugObjectValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugObjectValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugObjectValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugObjectValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugObjectValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugObjectValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugObjectValue * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetFieldValue )( 
            ICorDebugObjectValue * This,
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualMethod )( 
            ICorDebugObjectValue * This,
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ICorDebugObjectValue * This,
            /* [out] */ ICorDebugContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueClass )( 
            ICorDebugObjectValue * This,
            /* [out] */ BOOL *pbIsValueClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetManagedCopy )( 
            ICorDebugObjectValue * This,
            /* [out] */ IUnknown **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetFromManagedCopy )( 
            ICorDebugObjectValue * This,
            /* [in] */ IUnknown *pObject);
        
        END_INTERFACE
    } ICorDebugObjectValueVtbl;

    interface ICorDebugObjectValue
    {
        CONST_VTBL struct ICorDebugObjectValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugObjectValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugObjectValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugObjectValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugObjectValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugObjectValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugObjectValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugObjectValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugObjectValue_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugObjectValue_GetFieldValue(This,pClass,fieldDef,ppValue)	\
    (This)->lpVtbl -> GetFieldValue(This,pClass,fieldDef,ppValue)

#define ICorDebugObjectValue_GetVirtualMethod(This,memberRef,ppFunction)	\
    (This)->lpVtbl -> GetVirtualMethod(This,memberRef,ppFunction)

#define ICorDebugObjectValue_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#define ICorDebugObjectValue_IsValueClass(This,pbIsValueClass)	\
    (This)->lpVtbl -> IsValueClass(This,pbIsValueClass)

#define ICorDebugObjectValue_GetManagedCopy(This,ppObject)	\
    (This)->lpVtbl -> GetManagedCopy(This,ppObject)

#define ICorDebugObjectValue_SetFromManagedCopy(This,pObject)	\
    (This)->lpVtbl -> SetFromManagedCopy(This,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetClass_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugObjectValue_GetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetFieldValue_Proxy( 
    ICorDebugObjectValue * This,
    /* [in] */ ICorDebugClass *pClass,
    /* [in] */ mdFieldDef fieldDef,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugObjectValue_GetFieldValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetVirtualMethod_Proxy( 
    ICorDebugObjectValue * This,
    /* [in] */ mdMemberRef memberRef,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugObjectValue_GetVirtualMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetContext_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ ICorDebugContext **ppContext);


void __RPC_STUB ICorDebugObjectValue_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_IsValueClass_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ BOOL *pbIsValueClass);


void __RPC_STUB ICorDebugObjectValue_IsValueClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetManagedCopy_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ IUnknown **ppObject);


void __RPC_STUB ICorDebugObjectValue_GetManagedCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_SetFromManagedCopy_Proxy( 
    ICorDebugObjectValue * This,
    /* [in] */ IUnknown *pObject);


void __RPC_STUB ICorDebugObjectValue_SetFromManagedCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugObjectValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugObjectValue2_INTERFACE_DEFINED__
#define __ICorDebugObjectValue2_INTERFACE_DEFINED__

/* interface ICorDebugObjectValue2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugObjectValue2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49E4A320-4A9B-4eca-B105-229FB7D5009F")
    ICorDebugObjectValue2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVirtualMethodAndType( 
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction,
            /* [out] */ ICorDebugType **ppType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugObjectValue2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugObjectValue2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugObjectValue2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugObjectValue2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualMethodAndType )( 
            ICorDebugObjectValue2 * This,
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction,
            /* [out] */ ICorDebugType **ppType);
        
        END_INTERFACE
    } ICorDebugObjectValue2Vtbl;

    interface ICorDebugObjectValue2
    {
        CONST_VTBL struct ICorDebugObjectValue2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugObjectValue2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugObjectValue2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugObjectValue2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugObjectValue2_GetVirtualMethodAndType(This,memberRef,ppFunction,ppType)	\
    (This)->lpVtbl -> GetVirtualMethodAndType(This,memberRef,ppFunction,ppType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugObjectValue2_GetVirtualMethodAndType_Proxy( 
    ICorDebugObjectValue2 * This,
    /* [in] */ mdMemberRef memberRef,
    /* [out] */ ICorDebugFunction **ppFunction,
    /* [out] */ ICorDebugType **ppType);


void __RPC_STUB ICorDebugObjectValue2_GetVirtualMethodAndType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugObjectValue2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugBoxValue_INTERFACE_DEFINED__
#define __ICorDebugBoxValue_INTERFACE_DEFINED__

/* interface ICorDebugBoxValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugBoxValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAFC-8A68-11d2-983C-0000F808342D")
    ICorDebugBoxValue : public ICorDebugHeapValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugObjectValue **ppObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugBoxValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugBoxValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugBoxValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugBoxValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugBoxValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugBoxValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugBoxValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugBoxValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugBoxValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugBoxValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugBoxValue * This,
            /* [out] */ ICorDebugObjectValue **ppObject);
        
        END_INTERFACE
    } ICorDebugBoxValueVtbl;

    interface ICorDebugBoxValue
    {
        CONST_VTBL struct ICorDebugBoxValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugBoxValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugBoxValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugBoxValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugBoxValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugBoxValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugBoxValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugBoxValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugBoxValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugBoxValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)


#define ICorDebugBoxValue_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugBoxValue_GetObject_Proxy( 
    ICorDebugBoxValue * This,
    /* [out] */ ICorDebugObjectValue **ppObject);


void __RPC_STUB ICorDebugBoxValue_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugBoxValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStringValue_INTERFACE_DEFINED__
#define __ICorDebugStringValue_INTERFACE_DEFINED__

/* interface ICorDebugStringValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugStringValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAFD-8A68-11d2-983C-0000F808342D")
    ICorDebugStringValue : public ICorDebugHeapValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ ULONG32 *pcchString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStringValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStringValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStringValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStringValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugStringValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugStringValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugStringValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugStringValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugStringValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugStringValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            ICorDebugStringValue * This,
            /* [out] */ ULONG32 *pcchString);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            ICorDebugStringValue * This,
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]);
        
        END_INTERFACE
    } ICorDebugStringValueVtbl;

    interface ICorDebugStringValue
    {
        CONST_VTBL struct ICorDebugStringValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStringValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStringValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStringValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStringValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugStringValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugStringValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugStringValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugStringValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugStringValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)


#define ICorDebugStringValue_GetLength(This,pcchString)	\
    (This)->lpVtbl -> GetLength(This,pcchString)

#define ICorDebugStringValue_GetString(This,cchString,pcchString,szString)	\
    (This)->lpVtbl -> GetString(This,cchString,pcchString,szString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStringValue_GetLength_Proxy( 
    ICorDebugStringValue * This,
    /* [out] */ ULONG32 *pcchString);


void __RPC_STUB ICorDebugStringValue_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStringValue_GetString_Proxy( 
    ICorDebugStringValue * This,
    /* [in] */ ULONG32 cchString,
    /* [out] */ ULONG32 *pcchString,
    /* [length_is][size_is][out] */ WCHAR szString[  ]);


void __RPC_STUB ICorDebugStringValue_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStringValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugArrayValue_INTERFACE_DEFINED__
#define __ICorDebugArrayValue_INTERFACE_DEFINED__

/* interface ICorDebugArrayValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugArrayValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0405B0DF-A660-11d2-BD02-0000F80849BD")
    ICorDebugArrayValue : public ICorDebugHeapValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetElementType( 
            /* [out] */ CorElementType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRank( 
            /* [out] */ ULONG32 *pnRank) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG32 *pnCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDimensions( 
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 dims[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasBaseIndicies( 
            /* [out] */ BOOL *pbHasBaseIndicies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaseIndicies( 
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 indicies[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElement( 
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][in] */ ULONG32 indices[  ],
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElementAtPosition( 
            /* [in] */ ULONG32 nPosition,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugArrayValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugArrayValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugArrayValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugArrayValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugArrayValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugArrayValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugArrayValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugArrayValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugArrayValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugArrayValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementType )( 
            ICorDebugArrayValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetRank )( 
            ICorDebugArrayValue * This,
            /* [out] */ ULONG32 *pnRank);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugArrayValue * This,
            /* [out] */ ULONG32 *pnCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDimensions )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 dims[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *HasBaseIndicies )( 
            ICorDebugArrayValue * This,
            /* [out] */ BOOL *pbHasBaseIndicies);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaseIndicies )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 indicies[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetElement )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][in] */ ULONG32 indices[  ],
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementAtPosition )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 nPosition,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugArrayValueVtbl;

    interface ICorDebugArrayValue
    {
        CONST_VTBL struct ICorDebugArrayValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugArrayValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugArrayValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugArrayValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugArrayValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugArrayValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugArrayValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugArrayValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugArrayValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugArrayValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)


#define ICorDebugArrayValue_GetElementType(This,pType)	\
    (This)->lpVtbl -> GetElementType(This,pType)

#define ICorDebugArrayValue_GetRank(This,pnRank)	\
    (This)->lpVtbl -> GetRank(This,pnRank)

#define ICorDebugArrayValue_GetCount(This,pnCount)	\
    (This)->lpVtbl -> GetCount(This,pnCount)

#define ICorDebugArrayValue_GetDimensions(This,cdim,dims)	\
    (This)->lpVtbl -> GetDimensions(This,cdim,dims)

#define ICorDebugArrayValue_HasBaseIndicies(This,pbHasBaseIndicies)	\
    (This)->lpVtbl -> HasBaseIndicies(This,pbHasBaseIndicies)

#define ICorDebugArrayValue_GetBaseIndicies(This,cdim,indicies)	\
    (This)->lpVtbl -> GetBaseIndicies(This,cdim,indicies)

#define ICorDebugArrayValue_GetElement(This,cdim,indices,ppValue)	\
    (This)->lpVtbl -> GetElement(This,cdim,indices,ppValue)

#define ICorDebugArrayValue_GetElementAtPosition(This,nPosition,ppValue)	\
    (This)->lpVtbl -> GetElementAtPosition(This,nPosition,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetElementType_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ CorElementType *pType);


void __RPC_STUB ICorDebugArrayValue_GetElementType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetRank_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ ULONG32 *pnRank);


void __RPC_STUB ICorDebugArrayValue_GetRank_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetCount_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ ULONG32 *pnCount);


void __RPC_STUB ICorDebugArrayValue_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetDimensions_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 cdim,
    /* [length_is][size_is][out] */ ULONG32 dims[  ]);


void __RPC_STUB ICorDebugArrayValue_GetDimensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_HasBaseIndicies_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ BOOL *pbHasBaseIndicies);


void __RPC_STUB ICorDebugArrayValue_HasBaseIndicies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetBaseIndicies_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 cdim,
    /* [length_is][size_is][out] */ ULONG32 indicies[  ]);


void __RPC_STUB ICorDebugArrayValue_GetBaseIndicies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetElement_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 cdim,
    /* [length_is][size_is][in] */ ULONG32 indices[  ],
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugArrayValue_GetElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetElementAtPosition_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 nPosition,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugArrayValue_GetElementAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugArrayValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugHandleValue_INTERFACE_DEFINED__
#define __ICorDebugHandleValue_INTERFACE_DEFINED__

/* interface ICorDebugHandleValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugHandleValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("029596E8-276B-46a1-9821-732E96BBB00B")
    ICorDebugHandleValue : public ICorDebugReferenceValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHandleType( 
            /* [out] */ CorDebugHandleType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Dispose( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugHandleValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugHandleValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugHandleValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugHandleValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugHandleValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugHandleValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugHandleValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugHandleValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsNull )( 
            ICorDebugHandleValue * This,
            /* [out] */ BOOL *pbNull);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugHandleValue * This,
            /* [out] */ CORDB_ADDRESS *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICorDebugHandleValue * This,
            /* [in] */ CORDB_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *Dereference )( 
            ICorDebugHandleValue * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *DereferenceStrong )( 
            ICorDebugHandleValue * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandleType )( 
            ICorDebugHandleValue * This,
            /* [out] */ CorDebugHandleType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *Dispose )( 
            ICorDebugHandleValue * This);
        
        END_INTERFACE
    } ICorDebugHandleValueVtbl;

    interface ICorDebugHandleValue
    {
        CONST_VTBL struct ICorDebugHandleValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugHandleValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugHandleValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugHandleValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugHandleValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugHandleValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugHandleValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugHandleValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugHandleValue_IsNull(This,pbNull)	\
    (This)->lpVtbl -> IsNull(This,pbNull)

#define ICorDebugHandleValue_GetValue(This,pValue)	\
    (This)->lpVtbl -> GetValue(This,pValue)

#define ICorDebugHandleValue_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#define ICorDebugHandleValue_Dereference(This,ppValue)	\
    (This)->lpVtbl -> Dereference(This,ppValue)

#define ICorDebugHandleValue_DereferenceStrong(This,ppValue)	\
    (This)->lpVtbl -> DereferenceStrong(This,ppValue)


#define ICorDebugHandleValue_GetHandleType(This,pType)	\
    (This)->lpVtbl -> GetHandleType(This,pType)

#define ICorDebugHandleValue_Dispose(This)	\
    (This)->lpVtbl -> Dispose(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugHandleValue_GetHandleType_Proxy( 
    ICorDebugHandleValue * This,
    /* [out] */ CorDebugHandleType *pType);


void __RPC_STUB ICorDebugHandleValue_GetHandleType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugHandleValue_Dispose_Proxy( 
    ICorDebugHandleValue * This);


void __RPC_STUB ICorDebugHandleValue_Dispose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugHandleValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugContext_INTERFACE_DEFINED__
#define __ICorDebugContext_INTERFACE_DEFINED__

/* interface ICorDebugContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB00-8A68-11d2-983C-0000F808342D")
    ICorDebugContext : public ICorDebugObjectValue
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugContext * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugContext * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugContext * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugContext * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugContext * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetFieldValue )( 
            ICorDebugContext * This,
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualMethod )( 
            ICorDebugContext * This,
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ICorDebugContext * This,
            /* [out] */ ICorDebugContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueClass )( 
            ICorDebugContext * This,
            /* [out] */ BOOL *pbIsValueClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetManagedCopy )( 
            ICorDebugContext * This,
            /* [out] */ IUnknown **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetFromManagedCopy )( 
            ICorDebugContext * This,
            /* [in] */ IUnknown *pObject);
        
        END_INTERFACE
    } ICorDebugContextVtbl;

    interface ICorDebugContext
    {
        CONST_VTBL struct ICorDebugContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugContext_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugContext_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugContext_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugContext_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugContext_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugContext_GetFieldValue(This,pClass,fieldDef,ppValue)	\
    (This)->lpVtbl -> GetFieldValue(This,pClass,fieldDef,ppValue)

#define ICorDebugContext_GetVirtualMethod(This,memberRef,ppFunction)	\
    (This)->lpVtbl -> GetVirtualMethod(This,memberRef,ppFunction)

#define ICorDebugContext_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#define ICorDebugContext_IsValueClass(This,pbIsValueClass)	\
    (This)->lpVtbl -> IsValueClass(This,pbIsValueClass)

#define ICorDebugContext_GetManagedCopy(This,ppObject)	\
    (This)->lpVtbl -> GetManagedCopy(This,ppObject)

#define ICorDebugContext_SetFromManagedCopy(This,pObject)	\
    (This)->lpVtbl -> SetFromManagedCopy(This,pObject)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICorDebugContext_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEnum_INTERFACE_DEFINED__
#define __ICorDebugEnum_INTERFACE_DEFINED__

/* interface ICorDebugEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB01-8A68-11d2-983C-0000F808342D")
    ICorDebugEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ICorDebugEnum **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugEnum * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } ICorDebugEnumVtbl;

    interface ICorDebugEnum
    {
        CONST_VTBL struct ICorDebugEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEnum_Skip_Proxy( 
    ICorDebugEnum * This,
    /* [in] */ ULONG celt);


void __RPC_STUB ICorDebugEnum_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEnum_Reset_Proxy( 
    ICorDebugEnum * This);


void __RPC_STUB ICorDebugEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEnum_Clone_Proxy( 
    ICorDebugEnum * This,
    /* [out] */ ICorDebugEnum **ppEnum);


void __RPC_STUB ICorDebugEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEnum_GetCount_Proxy( 
    ICorDebugEnum * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB ICorDebugEnum_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugObjectEnum_INTERFACE_DEFINED__
#define __ICorDebugObjectEnum_INTERFACE_DEFINED__

/* interface ICorDebugObjectEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugObjectEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB02-8A68-11d2-983C-0000F808342D")
    ICorDebugObjectEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CORDB_ADDRESS objects[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugObjectEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugObjectEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugObjectEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugObjectEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugObjectEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugObjectEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugObjectEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugObjectEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugObjectEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CORDB_ADDRESS objects[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugObjectEnumVtbl;

    interface ICorDebugObjectEnum
    {
        CONST_VTBL struct ICorDebugObjectEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugObjectEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugObjectEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugObjectEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugObjectEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugObjectEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugObjectEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugObjectEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugObjectEnum_Next(This,celt,objects,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,objects,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugObjectEnum_Next_Proxy( 
    ICorDebugObjectEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CORDB_ADDRESS objects[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugObjectEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugObjectEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugBreakpointEnum_INTERFACE_DEFINED__
#define __ICorDebugBreakpointEnum_INTERFACE_DEFINED__

/* interface ICorDebugBreakpointEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugBreakpointEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB03-8A68-11d2-983C-0000F808342D")
    ICorDebugBreakpointEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugBreakpoint *breakpoints[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugBreakpointEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugBreakpointEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugBreakpointEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugBreakpointEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugBreakpointEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugBreakpointEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugBreakpointEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugBreakpointEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugBreakpointEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugBreakpoint *breakpoints[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugBreakpointEnumVtbl;

    interface ICorDebugBreakpointEnum
    {
        CONST_VTBL struct ICorDebugBreakpointEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugBreakpointEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugBreakpointEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugBreakpointEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugBreakpointEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugBreakpointEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugBreakpointEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugBreakpointEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugBreakpointEnum_Next(This,celt,breakpoints,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,breakpoints,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugBreakpointEnum_Next_Proxy( 
    ICorDebugBreakpointEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugBreakpoint *breakpoints[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugBreakpointEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugBreakpointEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStepperEnum_INTERFACE_DEFINED__
#define __ICorDebugStepperEnum_INTERFACE_DEFINED__

/* interface ICorDebugStepperEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugStepperEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB04-8A68-11d2-983C-0000F808342D")
    ICorDebugStepperEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugStepper *steppers[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStepperEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStepperEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStepperEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStepperEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugStepperEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugStepperEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugStepperEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugStepperEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugStepperEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugStepper *steppers[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugStepperEnumVtbl;

    interface ICorDebugStepperEnum
    {
        CONST_VTBL struct ICorDebugStepperEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStepperEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStepperEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStepperEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStepperEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugStepperEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugStepperEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugStepperEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugStepperEnum_Next(This,celt,steppers,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,steppers,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStepperEnum_Next_Proxy( 
    ICorDebugStepperEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugStepper *steppers[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugStepperEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStepperEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugProcessEnum_INTERFACE_DEFINED__
#define __ICorDebugProcessEnum_INTERFACE_DEFINED__

/* interface ICorDebugProcessEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugProcessEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB05-8A68-11d2-983C-0000F808342D")
    ICorDebugProcessEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugProcess *processes[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugProcessEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugProcessEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugProcessEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugProcessEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugProcessEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugProcessEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugProcessEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugProcessEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugProcessEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugProcess *processes[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugProcessEnumVtbl;

    interface ICorDebugProcessEnum
    {
        CONST_VTBL struct ICorDebugProcessEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugProcessEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugProcessEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugProcessEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugProcessEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugProcessEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugProcessEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugProcessEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugProcessEnum_Next(This,celt,processes,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,processes,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugProcessEnum_Next_Proxy( 
    ICorDebugProcessEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugProcess *processes[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugProcessEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugProcessEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugThreadEnum_INTERFACE_DEFINED__
#define __ICorDebugThreadEnum_INTERFACE_DEFINED__

/* interface ICorDebugThreadEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugThreadEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB06-8A68-11d2-983C-0000F808342D")
    ICorDebugThreadEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugThread *threads[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugThreadEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugThreadEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugThreadEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugThreadEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugThreadEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugThreadEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugThreadEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugThreadEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugThreadEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugThread *threads[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugThreadEnumVtbl;

    interface ICorDebugThreadEnum
    {
        CONST_VTBL struct ICorDebugThreadEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugThreadEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugThreadEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugThreadEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugThreadEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugThreadEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugThreadEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugThreadEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugThreadEnum_Next(This,celt,threads,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,threads,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugThreadEnum_Next_Proxy( 
    ICorDebugThreadEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugThread *threads[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugThreadEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugThreadEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFrameEnum_INTERFACE_DEFINED__
#define __ICorDebugFrameEnum_INTERFACE_DEFINED__

/* interface ICorDebugFrameEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFrameEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB07-8A68-11d2-983C-0000F808342D")
    ICorDebugFrameEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugFrame *frames[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFrameEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFrameEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFrameEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFrameEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugFrameEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugFrameEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugFrameEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugFrameEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugFrameEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugFrame *frames[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugFrameEnumVtbl;

    interface ICorDebugFrameEnum
    {
        CONST_VTBL struct ICorDebugFrameEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFrameEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFrameEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFrameEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFrameEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugFrameEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugFrameEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugFrameEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugFrameEnum_Next(This,celt,frames,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,frames,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFrameEnum_Next_Proxy( 
    ICorDebugFrameEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugFrame *frames[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugFrameEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFrameEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugChainEnum_INTERFACE_DEFINED__
#define __ICorDebugChainEnum_INTERFACE_DEFINED__

/* interface ICorDebugChainEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugChainEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB08-8A68-11d2-983C-0000F808342D")
    ICorDebugChainEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugChain *chains[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugChainEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugChainEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugChainEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugChainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugChainEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugChainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugChainEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugChainEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugChainEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugChain *chains[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugChainEnumVtbl;

    interface ICorDebugChainEnum
    {
        CONST_VTBL struct ICorDebugChainEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugChainEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugChainEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugChainEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugChainEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugChainEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugChainEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugChainEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugChainEnum_Next(This,celt,chains,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,chains,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugChainEnum_Next_Proxy( 
    ICorDebugChainEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugChain *chains[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugChainEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugChainEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModuleEnum_INTERFACE_DEFINED__
#define __ICorDebugModuleEnum_INTERFACE_DEFINED__

/* interface ICorDebugModuleEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModuleEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB09-8A68-11d2-983C-0000F808342D")
    ICorDebugModuleEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugModule *modules[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModuleEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModuleEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModuleEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModuleEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugModuleEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugModuleEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugModuleEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugModuleEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugModuleEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugModule *modules[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugModuleEnumVtbl;

    interface ICorDebugModuleEnum
    {
        CONST_VTBL struct ICorDebugModuleEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModuleEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModuleEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModuleEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModuleEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugModuleEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugModuleEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugModuleEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugModuleEnum_Next(This,celt,modules,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,modules,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModuleEnum_Next_Proxy( 
    ICorDebugModuleEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugModule *modules[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugModuleEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModuleEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValueEnum_INTERFACE_DEFINED__
#define __ICorDebugValueEnum_INTERFACE_DEFINED__

/* interface ICorDebugValueEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValueEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB0A-8A68-11d2-983C-0000F808342D")
    ICorDebugValueEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugValue *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValueEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValueEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValueEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValueEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugValueEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugValueEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugValueEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugValueEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugValueEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugValue *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugValueEnumVtbl;

    interface ICorDebugValueEnum
    {
        CONST_VTBL struct ICorDebugValueEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValueEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValueEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValueEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValueEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugValueEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugValueEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugValueEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugValueEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValueEnum_Next_Proxy( 
    ICorDebugValueEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugValue *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugValueEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValueEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugCodeEnum_INTERFACE_DEFINED__
#define __ICorDebugCodeEnum_INTERFACE_DEFINED__

/* interface ICorDebugCodeEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugCodeEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55E96461-9645-45e4-A2FF-0367877ABCDE")
    ICorDebugCodeEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugCode *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugCodeEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugCodeEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugCodeEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugCodeEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugCodeEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugCodeEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugCodeEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugCodeEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugCodeEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugCode *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugCodeEnumVtbl;

    interface ICorDebugCodeEnum
    {
        CONST_VTBL struct ICorDebugCodeEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugCodeEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugCodeEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugCodeEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugCodeEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugCodeEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugCodeEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugCodeEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugCodeEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugCodeEnum_Next_Proxy( 
    ICorDebugCodeEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugCode *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugCodeEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugCodeEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugTypeEnum_INTERFACE_DEFINED__
#define __ICorDebugTypeEnum_INTERFACE_DEFINED__

/* interface ICorDebugTypeEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugTypeEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10F27499-9DF2-43ce-8333-A321D7C99CB4")
    ICorDebugTypeEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugType *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugTypeEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugTypeEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugTypeEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugTypeEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugTypeEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugTypeEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugTypeEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugTypeEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugTypeEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugType *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugTypeEnumVtbl;

    interface ICorDebugTypeEnum
    {
        CONST_VTBL struct ICorDebugTypeEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugTypeEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugTypeEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugTypeEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugTypeEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugTypeEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugTypeEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugTypeEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugTypeEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugTypeEnum_Next_Proxy( 
    ICorDebugTypeEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugType *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugTypeEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugTypeEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugType_INTERFACE_DEFINED__
#define __ICorDebugType_INTERFACE_DEFINED__

/* interface ICorDebugType */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D613F0BB-ACE1-4c19-BD72-E4C08D5DA7F5")
    ICorDebugType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ CorElementType *ty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClass( 
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateTypeParameters( 
            /* [out] */ ICorDebugTypeEnum **ppTyParEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstTypeParameter( 
            /* [out] */ ICorDebugType **value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBase( 
            /* [out] */ ICorDebugType **pBase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStaticFieldValue( 
            /* [in] */ mdFieldDef fieldDef,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRank( 
            /* [out] */ ULONG32 *pnRank) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugType * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugType * This,
            /* [out] */ CorElementType *ty);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugType * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateTypeParameters )( 
            ICorDebugType * This,
            /* [out] */ ICorDebugTypeEnum **ppTyParEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstTypeParameter )( 
            ICorDebugType * This,
            /* [out] */ ICorDebugType **value);
        
        HRESULT ( STDMETHODCALLTYPE *GetBase )( 
            ICorDebugType * This,
            /* [out] */ ICorDebugType **pBase);
        
        HRESULT ( STDMETHODCALLTYPE *GetStaticFieldValue )( 
            ICorDebugType * This,
            /* [in] */ mdFieldDef fieldDef,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetRank )( 
            ICorDebugType * This,
            /* [out] */ ULONG32 *pnRank);
        
        END_INTERFACE
    } ICorDebugTypeVtbl;

    interface ICorDebugType
    {
        CONST_VTBL struct ICorDebugTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugType_GetType(This,ty)	\
    (This)->lpVtbl -> GetType(This,ty)

#define ICorDebugType_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugType_EnumerateTypeParameters(This,ppTyParEnum)	\
    (This)->lpVtbl -> EnumerateTypeParameters(This,ppTyParEnum)

#define ICorDebugType_GetFirstTypeParameter(This,value)	\
    (This)->lpVtbl -> GetFirstTypeParameter(This,value)

#define ICorDebugType_GetBase(This,pBase)	\
    (This)->lpVtbl -> GetBase(This,pBase)

#define ICorDebugType_GetStaticFieldValue(This,fieldDef,pFrame,ppValue)	\
    (This)->lpVtbl -> GetStaticFieldValue(This,fieldDef,pFrame,ppValue)

#define ICorDebugType_GetRank(This,pnRank)	\
    (This)->lpVtbl -> GetRank(This,pnRank)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugType_GetType_Proxy( 
    ICorDebugType * This,
    /* [out] */ CorElementType *ty);


void __RPC_STUB ICorDebugType_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_GetClass_Proxy( 
    ICorDebugType * This,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugType_GetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_EnumerateTypeParameters_Proxy( 
    ICorDebugType * This,
    /* [out] */ ICorDebugTypeEnum **ppTyParEnum);


void __RPC_STUB ICorDebugType_EnumerateTypeParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_GetFirstTypeParameter_Proxy( 
    ICorDebugType * This,
    /* [out] */ ICorDebugType **value);


void __RPC_STUB ICorDebugType_GetFirstTypeParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_GetBase_Proxy( 
    ICorDebugType * This,
    /* [out] */ ICorDebugType **pBase);


void __RPC_STUB ICorDebugType_GetBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_GetStaticFieldValue_Proxy( 
    ICorDebugType * This,
    /* [in] */ mdFieldDef fieldDef,
    /* [in] */ ICorDebugFrame *pFrame,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugType_GetStaticFieldValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_GetRank_Proxy( 
    ICorDebugType * This,
    /* [out] */ ULONG32 *pnRank);


void __RPC_STUB ICorDebugType_GetRank_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugType_INTERFACE_DEFINED__ */


#ifndef __ICorDebugErrorInfoEnum_INTERFACE_DEFINED__
#define __ICorDebugErrorInfoEnum_INTERFACE_DEFINED__

/* interface ICorDebugErrorInfoEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugErrorInfoEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0E18809-72B5-11d2-976F-00A0C9B4D50C")
    ICorDebugErrorInfoEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugEditAndContinueErrorInfo *errors[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugErrorInfoEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugErrorInfoEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugErrorInfoEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugErrorInfoEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugErrorInfoEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugErrorInfoEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugErrorInfoEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugErrorInfoEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugErrorInfoEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugEditAndContinueErrorInfo *errors[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugErrorInfoEnumVtbl;

    interface ICorDebugErrorInfoEnum
    {
        CONST_VTBL struct ICorDebugErrorInfoEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugErrorInfoEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugErrorInfoEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugErrorInfoEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugErrorInfoEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugErrorInfoEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugErrorInfoEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugErrorInfoEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugErrorInfoEnum_Next(This,celt,errors,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,errors,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugErrorInfoEnum_Next_Proxy( 
    ICorDebugErrorInfoEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugEditAndContinueErrorInfo *errors[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugErrorInfoEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugErrorInfoEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAppDomainEnum_INTERFACE_DEFINED__
#define __ICorDebugAppDomainEnum_INTERFACE_DEFINED__

/* interface ICorDebugAppDomainEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAppDomainEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63ca1b24-4359-4883-bd57-13f815f58744")
    ICorDebugAppDomainEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAppDomain *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAppDomainEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAppDomainEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAppDomainEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAppDomainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugAppDomainEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugAppDomainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugAppDomainEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugAppDomainEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugAppDomainEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAppDomain *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugAppDomainEnumVtbl;

    interface ICorDebugAppDomainEnum
    {
        CONST_VTBL struct ICorDebugAppDomainEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAppDomainEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAppDomainEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAppDomainEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAppDomainEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugAppDomainEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugAppDomainEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugAppDomainEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugAppDomainEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAppDomainEnum_Next_Proxy( 
    ICorDebugAppDomainEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugAppDomain *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugAppDomainEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAppDomainEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAssemblyEnum_INTERFACE_DEFINED__
#define __ICorDebugAssemblyEnum_INTERFACE_DEFINED__

/* interface ICorDebugAssemblyEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a2a1ec9-85ec-4bfb-9f15-a89fdfe0fe83")
    ICorDebugAssemblyEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAssembly *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugAssemblyEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugAssemblyEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugAssemblyEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugAssemblyEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAssembly *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugAssemblyEnumVtbl;

    interface ICorDebugAssemblyEnum
    {
        CONST_VTBL struct ICorDebugAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAssemblyEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugAssemblyEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugAssemblyEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugAssemblyEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugAssemblyEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAssemblyEnum_Next_Proxy( 
    ICorDebugAssemblyEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugAssembly *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugAssemblyEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugMDA_INTERFACE_DEFINED__
#define __ICorDebugMDA_INTERFACE_DEFINED__

/* interface ICorDebugMDA */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugMDAFlags
    {	MDA_FLAG_SLIP	= 0x2
    } 	CorDebugMDAFlags;


EXTERN_C const IID IID_ICorDebugMDA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC726F2F-1DB7-459b-B0EC-05F01D841B42")
    ICorDebugMDA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXML( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [in] */ CorDebugMDAFlags *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOSThreadId( 
            /* [out] */ DWORD *pOsTid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugMDAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugMDA * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugMDA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugMDA * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugMDA * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ICorDebugMDA * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetXML )( 
            ICorDebugMDA * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            ICorDebugMDA * This,
            /* [in] */ CorDebugMDAFlags *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetOSThreadId )( 
            ICorDebugMDA * This,
            /* [out] */ DWORD *pOsTid);
        
        END_INTERFACE
    } ICorDebugMDAVtbl;

    interface ICorDebugMDA
    {
        CONST_VTBL struct ICorDebugMDAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugMDA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugMDA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugMDA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugMDA_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ICorDebugMDA_GetDescription(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetDescription(This,cchName,pcchName,szName)

#define ICorDebugMDA_GetXML(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetXML(This,cchName,pcchName,szName)

#define ICorDebugMDA_GetFlags(This,pFlags)	\
    (This)->lpVtbl -> GetFlags(This,pFlags)

#define ICorDebugMDA_GetOSThreadId(This,pOsTid)	\
    (This)->lpVtbl -> GetOSThreadId(This,pOsTid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugMDA_GetName_Proxy( 
    ICorDebugMDA * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugMDA_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugMDA_GetDescription_Proxy( 
    ICorDebugMDA * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugMDA_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugMDA_GetXML_Proxy( 
    ICorDebugMDA * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugMDA_GetXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugMDA_GetFlags_Proxy( 
    ICorDebugMDA * This,
    /* [in] */ CorDebugMDAFlags *pFlags);


void __RPC_STUB ICorDebugMDA_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugMDA_GetOSThreadId_Proxy( 
    ICorDebugMDA * This,
    /* [out] */ DWORD *pOsTid);


void __RPC_STUB ICorDebugMDA_GetOSThreadId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugMDA_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEditAndContinueErrorInfo_INTERFACE_DEFINED__
#define __ICorDebugEditAndContinueErrorInfo_INTERFACE_DEFINED__

/* interface ICorDebugEditAndContinueErrorInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEditAndContinueErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8D600D41-F4F6-4cb3-B7EC-7BD164944036")
    ICorDebugEditAndContinueErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorCode( 
            /* [out] */ HRESULT *pHr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEditAndContinueErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEditAndContinueErrorInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEditAndContinueErrorInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [out] */ ICorDebugModule **ppModule);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorCode )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [out] */ HRESULT *pHr);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]);
        
        END_INTERFACE
    } ICorDebugEditAndContinueErrorInfoVtbl;

    interface ICorDebugEditAndContinueErrorInfo
    {
        CONST_VTBL struct ICorDebugEditAndContinueErrorInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEditAndContinueErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEditAndContinueErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEditAndContinueErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEditAndContinueErrorInfo_GetModule(This,ppModule)	\
    (This)->lpVtbl -> GetModule(This,ppModule)

#define ICorDebugEditAndContinueErrorInfo_GetToken(This,pToken)	\
    (This)->lpVtbl -> GetToken(This,pToken)

#define ICorDebugEditAndContinueErrorInfo_GetErrorCode(This,pHr)	\
    (This)->lpVtbl -> GetErrorCode(This,pHr)

#define ICorDebugEditAndContinueErrorInfo_GetString(This,cchString,pcchString,szString)	\
    (This)->lpVtbl -> GetString(This,cchString,pcchString,szString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetModule_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetToken_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [out] */ mdToken *pToken);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetErrorCode_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [out] */ HRESULT *pHr);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetString_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [in] */ ULONG32 cchString,
    /* [out] */ ULONG32 *pcchString,
    /* [length_is][size_is][out] */ WCHAR szString[  ]);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEditAndContinueErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEditAndContinueSnapshot_INTERFACE_DEFINED__
#define __ICorDebugEditAndContinueSnapshot_INTERFACE_DEFINED__

/* interface ICorDebugEditAndContinueSnapshot */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEditAndContinueSnapshot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DC3FA01-D7CB-11d2-8A95-0080C792E5D8")
    ICorDebugEditAndContinueSnapshot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CopyMetaData( 
            /* [in] */ IStream *pIStream,
            /* [out] */ GUID *pMvid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMvid( 
            /* [out] */ GUID *pMvid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoDataRVA( 
            /* [out] */ ULONG32 *pRoDataRVA) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRwDataRVA( 
            /* [out] */ ULONG32 *pRwDataRVA) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPEBytes( 
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetILMap( 
            /* [in] */ mdToken mdFunction,
            /* [in] */ ULONG cMapSize,
            /* [size_is][in] */ COR_IL_MAP map[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPESymbolBytes( 
            /* [in] */ IStream *pIStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEditAndContinueSnapshotVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEditAndContinueSnapshot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEditAndContinueSnapshot * This);
        
        HRESULT ( STDMETHODCALLTYPE *CopyMetaData )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ IStream *pIStream,
            /* [out] */ GUID *pMvid);
        
        HRESULT ( STDMETHODCALLTYPE *GetMvid )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [out] */ GUID *pMvid);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoDataRVA )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [out] */ ULONG32 *pRoDataRVA);
        
        HRESULT ( STDMETHODCALLTYPE *GetRwDataRVA )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [out] */ ULONG32 *pRwDataRVA);
        
        HRESULT ( STDMETHODCALLTYPE *SetPEBytes )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetILMap )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ mdToken mdFunction,
            /* [in] */ ULONG cMapSize,
            /* [size_is][in] */ COR_IL_MAP map[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetPESymbolBytes )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ IStream *pIStream);
        
        END_INTERFACE
    } ICorDebugEditAndContinueSnapshotVtbl;

    interface ICorDebugEditAndContinueSnapshot
    {
        CONST_VTBL struct ICorDebugEditAndContinueSnapshotVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEditAndContinueSnapshot_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEditAndContinueSnapshot_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEditAndContinueSnapshot_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEditAndContinueSnapshot_CopyMetaData(This,pIStream,pMvid)	\
    (This)->lpVtbl -> CopyMetaData(This,pIStream,pMvid)

#define ICorDebugEditAndContinueSnapshot_GetMvid(This,pMvid)	\
    (This)->lpVtbl -> GetMvid(This,pMvid)

#define ICorDebugEditAndContinueSnapshot_GetRoDataRVA(This,pRoDataRVA)	\
    (This)->lpVtbl -> GetRoDataRVA(This,pRoDataRVA)

#define ICorDebugEditAndContinueSnapshot_GetRwDataRVA(This,pRwDataRVA)	\
    (This)->lpVtbl -> GetRwDataRVA(This,pRwDataRVA)

#define ICorDebugEditAndContinueSnapshot_SetPEBytes(This,pIStream)	\
    (This)->lpVtbl -> SetPEBytes(This,pIStream)

#define ICorDebugEditAndContinueSnapshot_SetILMap(This,mdFunction,cMapSize,map)	\
    (This)->lpVtbl -> SetILMap(This,mdFunction,cMapSize,map)

#define ICorDebugEditAndContinueSnapshot_SetPESymbolBytes(This,pIStream)	\
    (This)->lpVtbl -> SetPESymbolBytes(This,pIStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_CopyMetaData_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ IStream *pIStream,
    /* [out] */ GUID *pMvid);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_CopyMetaData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_GetMvid_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [out] */ GUID *pMvid);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_GetMvid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_GetRoDataRVA_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [out] */ ULONG32 *pRoDataRVA);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_GetRoDataRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_GetRwDataRVA_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [out] */ ULONG32 *pRwDataRVA);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_GetRwDataRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_SetPEBytes_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_SetPEBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_SetILMap_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ mdToken mdFunction,
    /* [in] */ ULONG cMapSize,
    /* [size_is][in] */ COR_IL_MAP map[  ]);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_SetILMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_SetPESymbolBytes_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_SetPESymbolBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEditAndContinueSnapshot_INTERFACE_DEFINED__ */



#ifndef __CORDBLib_LIBRARY_DEFINED__
#define __CORDBLib_LIBRARY_DEFINED__

/* library CORDBLib */
/* [helpstring][version][uuid] */ 

























EXTERN_C const IID LIBID_CORDBLib;

EXTERN_C const CLSID CLSID_CorDebug;

#ifdef __cplusplus

class DECLSPEC_UUID("6fef44d0-39e7-4c77-be8e-c9f8cf988630")
CorDebug;
#endif

EXTERN_C const CLSID CLSID_EmbeddedCLRCorDebug;

#ifdef __cplusplus

class DECLSPEC_UUID("211f1254-bc7e-4af5-b9aa-067308d83dd1")
EmbeddedCLRCorDebug;
#endif
#endif /* __CORDBLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HPROCESS_UserSize(     unsigned long *, unsigned long            , HPROCESS * ); 
unsigned char * __RPC_USER  HPROCESS_UserMarshal(  unsigned long *, unsigned char *, HPROCESS * ); 
unsigned char * __RPC_USER  HPROCESS_UserUnmarshal(unsigned long *, unsigned char *, HPROCESS * ); 
void                      __RPC_USER  HPROCESS_UserFree(     unsigned long *, HPROCESS * ); 

unsigned long             __RPC_USER  HTHREAD_UserSize(     unsigned long *, unsigned long            , HTHREAD * ); 
unsigned char * __RPC_USER  HTHREAD_UserMarshal(  unsigned long *, unsigned char *, HTHREAD * ); 
unsigned char * __RPC_USER  HTHREAD_UserUnmarshal(unsigned long *, unsigned char *, HTHREAD * ); 
void                      __RPC_USER  HTHREAD_UserFree(     unsigned long *, HTHREAD * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ComSvcs.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for autosvcs.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __autosvcs_h__
#define __autosvcs_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISecurityIdentityColl_FWD_DEFINED__
#define __ISecurityIdentityColl_FWD_DEFINED__
typedef interface ISecurityIdentityColl ISecurityIdentityColl;
#endif 	/* __ISecurityIdentityColl_FWD_DEFINED__ */


#ifndef __ISecurityCallersColl_FWD_DEFINED__
#define __ISecurityCallersColl_FWD_DEFINED__
typedef interface ISecurityCallersColl ISecurityCallersColl;
#endif 	/* __ISecurityCallersColl_FWD_DEFINED__ */


#ifndef __ISecurityCallContext_FWD_DEFINED__
#define __ISecurityCallContext_FWD_DEFINED__
typedef interface ISecurityCallContext ISecurityCallContext;
#endif 	/* __ISecurityCallContext_FWD_DEFINED__ */


#ifndef __IGetSecurityCallContext_FWD_DEFINED__
#define __IGetSecurityCallContext_FWD_DEFINED__
typedef interface IGetSecurityCallContext IGetSecurityCallContext;
#endif 	/* __IGetSecurityCallContext_FWD_DEFINED__ */


#ifndef __SecurityProperty_FWD_DEFINED__
#define __SecurityProperty_FWD_DEFINED__
typedef interface SecurityProperty SecurityProperty;
#endif 	/* __SecurityProperty_FWD_DEFINED__ */


#ifndef __ContextInfo_FWD_DEFINED__
#define __ContextInfo_FWD_DEFINED__
typedef interface ContextInfo ContextInfo;
#endif 	/* __ContextInfo_FWD_DEFINED__ */


#ifndef __ContextInfo2_FWD_DEFINED__
#define __ContextInfo2_FWD_DEFINED__
typedef interface ContextInfo2 ContextInfo2;
#endif 	/* __ContextInfo2_FWD_DEFINED__ */


#ifndef __ObjectContext_FWD_DEFINED__
#define __ObjectContext_FWD_DEFINED__
typedef interface ObjectContext ObjectContext;
#endif 	/* __ObjectContext_FWD_DEFINED__ */


#ifndef __ITransactionContextEx_FWD_DEFINED__
#define __ITransactionContextEx_FWD_DEFINED__
typedef interface ITransactionContextEx ITransactionContextEx;
#endif 	/* __ITransactionContextEx_FWD_DEFINED__ */


#ifndef __ITransactionContext_FWD_DEFINED__
#define __ITransactionContext_FWD_DEFINED__
typedef interface ITransactionContext ITransactionContext;
#endif 	/* __ITransactionContext_FWD_DEFINED__ */


#ifndef __ICreateWithTransactionEx_FWD_DEFINED__
#define __ICreateWithTransactionEx_FWD_DEFINED__
typedef interface ICreateWithTransactionEx ICreateWithTransactionEx;
#endif 	/* __ICreateWithTransactionEx_FWD_DEFINED__ */


#ifndef __ICreateWithLocalTransaction_FWD_DEFINED__
#define __ICreateWithLocalTransaction_FWD_DEFINED__
typedef interface ICreateWithLocalTransaction ICreateWithLocalTransaction;
#endif 	/* __ICreateWithLocalTransaction_FWD_DEFINED__ */


#ifndef __ICreateWithTipTransactionEx_FWD_DEFINED__
#define __ICreateWithTipTransactionEx_FWD_DEFINED__
typedef interface ICreateWithTipTransactionEx ICreateWithTipTransactionEx;
#endif 	/* __ICreateWithTipTransactionEx_FWD_DEFINED__ */


#ifndef __IComLTxEvents_FWD_DEFINED__
#define __IComLTxEvents_FWD_DEFINED__
typedef interface IComLTxEvents IComLTxEvents;
#endif 	/* __IComLTxEvents_FWD_DEFINED__ */


#ifndef __IComUserEvent_FWD_DEFINED__
#define __IComUserEvent_FWD_DEFINED__
typedef interface IComUserEvent IComUserEvent;
#endif 	/* __IComUserEvent_FWD_DEFINED__ */


#ifndef __IComThreadEvents_FWD_DEFINED__
#define __IComThreadEvents_FWD_DEFINED__
typedef interface IComThreadEvents IComThreadEvents;
#endif 	/* __IComThreadEvents_FWD_DEFINED__ */


#ifndef __IComAppEvents_FWD_DEFINED__
#define __IComAppEvents_FWD_DEFINED__
typedef interface IComAppEvents IComAppEvents;
#endif 	/* __IComAppEvents_FWD_DEFINED__ */


#ifndef __IComInstanceEvents_FWD_DEFINED__
#define __IComInstanceEvents_FWD_DEFINED__
typedef interface IComInstanceEvents IComInstanceEvents;
#endif 	/* __IComInstanceEvents_FWD_DEFINED__ */


#ifndef __IComTransactionEvents_FWD_DEFINED__
#define __IComTransactionEvents_FWD_DEFINED__
typedef interface IComTransactionEvents IComTransactionEvents;
#endif 	/* __IComTransactionEvents_FWD_DEFINED__ */


#ifndef __IComMethodEvents_FWD_DEFINED__
#define __IComMethodEvents_FWD_DEFINED__
typedef interface IComMethodEvents IComMethodEvents;
#endif 	/* __IComMethodEvents_FWD_DEFINED__ */


#ifndef __IComObjectEvents_FWD_DEFINED__
#define __IComObjectEvents_FWD_DEFINED__
typedef interface IComObjectEvents IComObjectEvents;
#endif 	/* __IComObjectEvents_FWD_DEFINED__ */


#ifndef __IComResourceEvents_FWD_DEFINED__
#define __IComResourceEvents_FWD_DEFINED__
typedef interface IComResourceEvents IComResourceEvents;
#endif 	/* __IComResourceEvents_FWD_DEFINED__ */


#ifndef __IComSecurityEvents_FWD_DEFINED__
#define __IComSecurityEvents_FWD_DEFINED__
typedef interface IComSecurityEvents IComSecurityEvents;
#endif 	/* __IComSecurityEvents_FWD_DEFINED__ */


#ifndef __IComObjectPoolEvents_FWD_DEFINED__
#define __IComObjectPoolEvents_FWD_DEFINED__
typedef interface IComObjectPoolEvents IComObjectPoolEvents;
#endif 	/* __IComObjectPoolEvents_FWD_DEFINED__ */


#ifndef __IComObjectPoolEvents2_FWD_DEFINED__
#define __IComObjectPoolEvents2_FWD_DEFINED__
typedef interface IComObjectPoolEvents2 IComObjectPoolEvents2;
#endif 	/* __IComObjectPoolEvents2_FWD_DEFINED__ */


#ifndef __IComObjectConstructionEvents_FWD_DEFINED__
#define __IComObjectConstructionEvents_FWD_DEFINED__
typedef interface IComObjectConstructionEvents IComObjectConstructionEvents;
#endif 	/* __IComObjectConstructionEvents_FWD_DEFINED__ */


#ifndef __IComActivityEvents_FWD_DEFINED__
#define __IComActivityEvents_FWD_DEFINED__
typedef interface IComActivityEvents IComActivityEvents;
#endif 	/* __IComActivityEvents_FWD_DEFINED__ */


#ifndef __IComIdentityEvents_FWD_DEFINED__
#define __IComIdentityEvents_FWD_DEFINED__
typedef interface IComIdentityEvents IComIdentityEvents;
#endif 	/* __IComIdentityEvents_FWD_DEFINED__ */


#ifndef __IComQCEvents_FWD_DEFINED__
#define __IComQCEvents_FWD_DEFINED__
typedef interface IComQCEvents IComQCEvents;
#endif 	/* __IComQCEvents_FWD_DEFINED__ */


#ifndef __IComExceptionEvents_FWD_DEFINED__
#define __IComExceptionEvents_FWD_DEFINED__
typedef interface IComExceptionEvents IComExceptionEvents;
#endif 	/* __IComExceptionEvents_FWD_DEFINED__ */


#ifndef __IComCRMEvents_FWD_DEFINED__
#define __IComCRMEvents_FWD_DEFINED__
typedef interface IComCRMEvents IComCRMEvents;
#endif 	/* __IComCRMEvents_FWD_DEFINED__ */


#ifndef __IComMethod2Events_FWD_DEFINED__
#define __IComMethod2Events_FWD_DEFINED__
typedef interface IComMethod2Events IComMethod2Events;
#endif 	/* __IComMethod2Events_FWD_DEFINED__ */


#ifndef __IComTrackingInfoEvents_FWD_DEFINED__
#define __IComTrackingInfoEvents_FWD_DEFINED__
typedef interface IComTrackingInfoEvents IComTrackingInfoEvents;
#endif 	/* __IComTrackingInfoEvents_FWD_DEFINED__ */


#ifndef __IComTrackingInfoCollection_FWD_DEFINED__
#define __IComTrackingInfoCollection_FWD_DEFINED__
typedef interface IComTrackingInfoCollection IComTrackingInfoCollection;
#endif 	/* __IComTrackingInfoCollection_FWD_DEFINED__ */


#ifndef __IComTrackingInfoObject_FWD_DEFINED__
#define __IComTrackingInfoObject_FWD_DEFINED__
typedef interface IComTrackingInfoObject IComTrackingInfoObject;
#endif 	/* __IComTrackingInfoObject_FWD_DEFINED__ */


#ifndef __IComTrackingInfoProperties_FWD_DEFINED__
#define __IComTrackingInfoProperties_FWD_DEFINED__
typedef interface IComTrackingInfoProperties IComTrackingInfoProperties;
#endif 	/* __IComTrackingInfoProperties_FWD_DEFINED__ */


#ifndef __IComApp2Events_FWD_DEFINED__
#define __IComApp2Events_FWD_DEFINED__
typedef interface IComApp2Events IComApp2Events;
#endif 	/* __IComApp2Events_FWD_DEFINED__ */


#ifndef __IComTransaction2Events_FWD_DEFINED__
#define __IComTransaction2Events_FWD_DEFINED__
typedef interface IComTransaction2Events IComTransaction2Events;
#endif 	/* __IComTransaction2Events_FWD_DEFINED__ */


#ifndef __IComInstance2Events_FWD_DEFINED__
#define __IComInstance2Events_FWD_DEFINED__
typedef interface IComInstance2Events IComInstance2Events;
#endif 	/* __IComInstance2Events_FWD_DEFINED__ */


#ifndef __IComObjectPool2Events_FWD_DEFINED__
#define __IComObjectPool2Events_FWD_DEFINED__
typedef interface IComObjectPool2Events IComObjectPool2Events;
#endif 	/* __IComObjectPool2Events_FWD_DEFINED__ */


#ifndef __IComObjectConstruction2Events_FWD_DEFINED__
#define __IComObjectConstruction2Events_FWD_DEFINED__
typedef interface IComObjectConstruction2Events IComObjectConstruction2Events;
#endif 	/* __IComObjectConstruction2Events_FWD_DEFINED__ */


#ifndef __ISystemAppEventData_FWD_DEFINED__
#define __ISystemAppEventData_FWD_DEFINED__
typedef interface ISystemAppEventData ISystemAppEventData;
#endif 	/* __ISystemAppEventData_FWD_DEFINED__ */


#ifndef __IMtsEvents_FWD_DEFINED__
#define __IMtsEvents_FWD_DEFINED__
typedef interface IMtsEvents IMtsEvents;
#endif 	/* __IMtsEvents_FWD_DEFINED__ */


#ifndef __IMtsEventInfo_FWD_DEFINED__
#define __IMtsEventInfo_FWD_DEFINED__
typedef interface IMtsEventInfo IMtsEventInfo;
#endif 	/* __IMtsEventInfo_FWD_DEFINED__ */


#ifndef __IMTSLocator_FWD_DEFINED__
#define __IMTSLocator_FWD_DEFINED__
typedef interface IMTSLocator IMTSLocator;
#endif 	/* __IMTSLocator_FWD_DEFINED__ */


#ifndef __IMtsGrp_FWD_DEFINED__
#define __IMtsGrp_FWD_DEFINED__
typedef interface IMtsGrp IMtsGrp;
#endif 	/* __IMtsGrp_FWD_DEFINED__ */


#ifndef __IMessageMover_FWD_DEFINED__
#define __IMessageMover_FWD_DEFINED__
typedef interface IMessageMover IMessageMover;
#endif 	/* __IMessageMover_FWD_DEFINED__ */


#ifndef __IEventServerTrace_FWD_DEFINED__
#define __IEventServerTrace_FWD_DEFINED__
typedef interface IEventServerTrace IEventServerTrace;
#endif 	/* __IEventServerTrace_FWD_DEFINED__ */


#ifndef __IDispenserManager_FWD_DEFINED__
#define __IDispenserManager_FWD_DEFINED__
typedef interface IDispenserManager IDispenserManager;
#endif 	/* __IDispenserManager_FWD_DEFINED__ */


#ifndef __IHolder_FWD_DEFINED__
#define __IHolder_FWD_DEFINED__
typedef interface IHolder IHolder;
#endif 	/* __IHolder_FWD_DEFINED__ */


#ifndef __IDispenserDriver_FWD_DEFINED__
#define __IDispenserDriver_FWD_DEFINED__
typedef interface IDispenserDriver IDispenserDriver;
#endif 	/* __IDispenserDriver_FWD_DEFINED__ */


#ifndef __ITransactionProxy_FWD_DEFINED__
#define __ITransactionProxy_FWD_DEFINED__
typedef interface ITransactionProxy ITransactionProxy;
#endif 	/* __ITransactionProxy_FWD_DEFINED__ */


#ifndef __IContextSecurityPerimeter_FWD_DEFINED__
#define __IContextSecurityPerimeter_FWD_DEFINED__
typedef interface IContextSecurityPerimeter IContextSecurityPerimeter;
#endif 	/* __IContextSecurityPerimeter_FWD_DEFINED__ */


#ifndef __ITxProxyHolder_FWD_DEFINED__
#define __ITxProxyHolder_FWD_DEFINED__
typedef interface ITxProxyHolder ITxProxyHolder;
#endif 	/* __ITxProxyHolder_FWD_DEFINED__ */


#ifndef __IObjectContext_FWD_DEFINED__
#define __IObjectContext_FWD_DEFINED__
typedef interface IObjectContext IObjectContext;
#endif 	/* __IObjectContext_FWD_DEFINED__ */


#ifndef __IObjectControl_FWD_DEFINED__
#define __IObjectControl_FWD_DEFINED__
typedef interface IObjectControl IObjectControl;
#endif 	/* __IObjectControl_FWD_DEFINED__ */


#ifndef __IEnumNames_FWD_DEFINED__
#define __IEnumNames_FWD_DEFINED__
typedef interface IEnumNames IEnumNames;
#endif 	/* __IEnumNames_FWD_DEFINED__ */


#ifndef __ISecurityProperty_FWD_DEFINED__
#define __ISecurityProperty_FWD_DEFINED__
typedef interface ISecurityProperty ISecurityProperty;
#endif 	/* __ISecurityProperty_FWD_DEFINED__ */


#ifndef __ObjectControl_FWD_DEFINED__
#define __ObjectControl_FWD_DEFINED__
typedef interface ObjectControl ObjectControl;
#endif 	/* __ObjectControl_FWD_DEFINED__ */


#ifndef __ISharedProperty_FWD_DEFINED__
#define __ISharedProperty_FWD_DEFINED__
typedef interface ISharedProperty ISharedProperty;
#endif 	/* __ISharedProperty_FWD_DEFINED__ */


#ifndef __ISharedPropertyGroup_FWD_DEFINED__
#define __ISharedPropertyGroup_FWD_DEFINED__
typedef interface ISharedPropertyGroup ISharedPropertyGroup;
#endif 	/* __ISharedPropertyGroup_FWD_DEFINED__ */


#ifndef __ISharedPropertyGroupManager_FWD_DEFINED__
#define __ISharedPropertyGroupManager_FWD_DEFINED__
typedef interface ISharedPropertyGroupManager ISharedPropertyGroupManager;
#endif 	/* __ISharedPropertyGroupManager_FWD_DEFINED__ */


#ifndef __IObjectConstruct_FWD_DEFINED__
#define __IObjectConstruct_FWD_DEFINED__
typedef interface IObjectConstruct IObjectConstruct;
#endif 	/* __IObjectConstruct_FWD_DEFINED__ */


#ifndef __IObjectConstructString_FWD_DEFINED__
#define __IObjectConstructString_FWD_DEFINED__
typedef interface IObjectConstructString IObjectConstructString;
#endif 	/* __IObjectConstructString_FWD_DEFINED__ */


#ifndef __IObjectContextActivity_FWD_DEFINED__
#define __IObjectContextActivity_FWD_DEFINED__
typedef interface IObjectContextActivity IObjectContextActivity;
#endif 	/* __IObjectContextActivity_FWD_DEFINED__ */


#ifndef __IObjectContextInfo_FWD_DEFINED__
#define __IObjectContextInfo_FWD_DEFINED__
typedef interface IObjectContextInfo IObjectContextInfo;
#endif 	/* __IObjectContextInfo_FWD_DEFINED__ */


#ifndef __IObjectContextInfo2_FWD_DEFINED__
#define __IObjectContextInfo2_FWD_DEFINED__
typedef interface IObjectContextInfo2 IObjectContextInfo2;
#endif 	/* __IObjectContextInfo2_FWD_DEFINED__ */


#ifndef __ITransactionStatus_FWD_DEFINED__
#define __ITransactionStatus_FWD_DEFINED__
typedef interface ITransactionStatus ITransactionStatus;
#endif 	/* __ITransactionStatus_FWD_DEFINED__ */


#ifndef __IObjectContextTip_FWD_DEFINED__
#define __IObjectContextTip_FWD_DEFINED__
typedef interface IObjectContextTip IObjectContextTip;
#endif 	/* __IObjectContextTip_FWD_DEFINED__ */


#ifndef __IPlaybackControl_FWD_DEFINED__
#define __IPlaybackControl_FWD_DEFINED__
typedef interface IPlaybackControl IPlaybackControl;
#endif 	/* __IPlaybackControl_FWD_DEFINED__ */


#ifndef __IGetContextProperties_FWD_DEFINED__
#define __IGetContextProperties_FWD_DEFINED__
typedef interface IGetContextProperties IGetContextProperties;
#endif 	/* __IGetContextProperties_FWD_DEFINED__ */


#ifndef __IContextState_FWD_DEFINED__
#define __IContextState_FWD_DEFINED__
typedef interface IContextState IContextState;
#endif 	/* __IContextState_FWD_DEFINED__ */


#ifndef __IPoolManager_FWD_DEFINED__
#define __IPoolManager_FWD_DEFINED__
typedef interface IPoolManager IPoolManager;
#endif 	/* __IPoolManager_FWD_DEFINED__ */


#ifndef __ISelectCOMLBServer_FWD_DEFINED__
#define __ISelectCOMLBServer_FWD_DEFINED__
typedef interface ISelectCOMLBServer ISelectCOMLBServer;
#endif 	/* __ISelectCOMLBServer_FWD_DEFINED__ */


#ifndef __ICOMLBArguments_FWD_DEFINED__
#define __ICOMLBArguments_FWD_DEFINED__
typedef interface ICOMLBArguments ICOMLBArguments;
#endif 	/* __ICOMLBArguments_FWD_DEFINED__ */


#ifndef __ICrmLogControl_FWD_DEFINED__
#define __ICrmLogControl_FWD_DEFINED__
typedef interface ICrmLogControl ICrmLogControl;
#endif 	/* __ICrmLogControl_FWD_DEFINED__ */


#ifndef __ICrmCompensatorVariants_FWD_DEFINED__
#define __ICrmCompensatorVariants_FWD_DEFINED__
typedef interface ICrmCompensatorVariants ICrmCompensatorVariants;
#endif 	/* __ICrmCompensatorVariants_FWD_DEFINED__ */


#ifndef __ICrmCompensator_FWD_DEFINED__
#define __ICrmCompensator_FWD_DEFINED__
typedef interface ICrmCompensator ICrmCompensator;
#endif 	/* __ICrmCompensator_FWD_DEFINED__ */


#ifndef __ICrmMonitorLogRecords_FWD_DEFINED__
#define __ICrmMonitorLogRecords_FWD_DEFINED__
typedef interface ICrmMonitorLogRecords ICrmMonitorLogRecords;
#endif 	/* __ICrmMonitorLogRecords_FWD_DEFINED__ */


#ifndef __ICrmMonitorClerks_FWD_DEFINED__
#define __ICrmMonitorClerks_FWD_DEFINED__
typedef interface ICrmMonitorClerks ICrmMonitorClerks;
#endif 	/* __ICrmMonitorClerks_FWD_DEFINED__ */


#ifndef __ICrmMonitor_FWD_DEFINED__
#define __ICrmMonitor_FWD_DEFINED__
typedef interface ICrmMonitor ICrmMonitor;
#endif 	/* __ICrmMonitor_FWD_DEFINED__ */


#ifndef __ICrmFormatLogRecords_FWD_DEFINED__
#define __ICrmFormatLogRecords_FWD_DEFINED__
typedef interface ICrmFormatLogRecords ICrmFormatLogRecords;
#endif 	/* __ICrmFormatLogRecords_FWD_DEFINED__ */


#ifndef __IServiceIISIntrinsicsConfig_FWD_DEFINED__
#define __IServiceIISIntrinsicsConfig_FWD_DEFINED__
typedef interface IServiceIISIntrinsicsConfig IServiceIISIntrinsicsConfig;
#endif 	/* __IServiceIISIntrinsicsConfig_FWD_DEFINED__ */


#ifndef __IServiceComTIIntrinsicsConfig_FWD_DEFINED__
#define __IServiceComTIIntrinsicsConfig_FWD_DEFINED__
typedef interface IServiceComTIIntrinsicsConfig IServiceComTIIntrinsicsConfig;
#endif 	/* __IServiceComTIIntrinsicsConfig_FWD_DEFINED__ */


#ifndef __IServiceSxsConfig_FWD_DEFINED__
#define __IServiceSxsConfig_FWD_DEFINED__
typedef interface IServiceSxsConfig IServiceSxsConfig;
#endif 	/* __IServiceSxsConfig_FWD_DEFINED__ */


#ifndef __ICheckSxsConfig_FWD_DEFINED__
#define __ICheckSxsConfig_FWD_DEFINED__
typedef interface ICheckSxsConfig ICheckSxsConfig;
#endif 	/* __ICheckSxsConfig_FWD_DEFINED__ */


#ifndef __IServiceInheritanceConfig_FWD_DEFINED__
#define __IServiceInheritanceConfig_FWD_DEFINED__
typedef interface IServiceInheritanceConfig IServiceInheritanceConfig;
#endif 	/* __IServiceInheritanceConfig_FWD_DEFINED__ */


#ifndef __IServiceThreadPoolConfig_FWD_DEFINED__
#define __IServiceThreadPoolConfig_FWD_DEFINED__
typedef interface IServiceThreadPoolConfig IServiceThreadPoolConfig;
#endif 	/* __IServiceThreadPoolConfig_FWD_DEFINED__ */


#ifndef __IServiceTransactionConfigBase_FWD_DEFINED__
#define __IServiceTransactionConfigBase_FWD_DEFINED__
typedef interface IServiceTransactionConfigBase IServiceTransactionConfigBase;
#endif 	/* __IServiceTransactionConfigBase_FWD_DEFINED__ */


#ifndef __IServiceTransactionConfig_FWD_DEFINED__
#define __IServiceTransactionConfig_FWD_DEFINED__
typedef interface IServiceTransactionConfig IServiceTransactionConfig;
#endif 	/* __IServiceTransactionConfig_FWD_DEFINED__ */


#ifndef __IServiceSysTxnConfig_FWD_DEFINED__
#define __IServiceSysTxnConfig_FWD_DEFINED__
typedef interface IServiceSysTxnConfig IServiceSysTxnConfig;
#endif 	/* __IServiceSysTxnConfig_FWD_DEFINED__ */


#ifndef __IServiceSynchronizationConfig_FWD_DEFINED__
#define __IServiceSynchronizationConfig_FWD_DEFINED__
typedef interface IServiceSynchronizationConfig IServiceSynchronizationConfig;
#endif 	/* __IServiceSynchronizationConfig_FWD_DEFINED__ */


#ifndef __IServiceTrackerConfig_FWD_DEFINED__
#define __IServiceTrackerConfig_FWD_DEFINED__
typedef interface IServiceTrackerConfig IServiceTrackerConfig;
#endif 	/* __IServiceTrackerConfig_FWD_DEFINED__ */


#ifndef __IServicePartitionConfig_FWD_DEFINED__
#define __IServicePartitionConfig_FWD_DEFINED__
typedef interface IServicePartitionConfig IServicePartitionConfig;
#endif 	/* __IServicePartitionConfig_FWD_DEFINED__ */


#ifndef __IServiceCall_FWD_DEFINED__
#define __IServiceCall_FWD_DEFINED__
typedef interface IServiceCall IServiceCall;
#endif 	/* __IServiceCall_FWD_DEFINED__ */


#ifndef __IAsyncErrorNotify_FWD_DEFINED__
#define __IAsyncErrorNotify_FWD_DEFINED__
typedef interface IAsyncErrorNotify IAsyncErrorNotify;
#endif 	/* __IAsyncErrorNotify_FWD_DEFINED__ */


#ifndef __IServiceActivity_FWD_DEFINED__
#define __IServiceActivity_FWD_DEFINED__
typedef interface IServiceActivity IServiceActivity;
#endif 	/* __IServiceActivity_FWD_DEFINED__ */


#ifndef __IThreadPoolKnobs_FWD_DEFINED__
#define __IThreadPoolKnobs_FWD_DEFINED__
typedef interface IThreadPoolKnobs IThreadPoolKnobs;
#endif 	/* __IThreadPoolKnobs_FWD_DEFINED__ */


#ifndef __IComStaThreadPoolKnobs_FWD_DEFINED__
#define __IComStaThreadPoolKnobs_FWD_DEFINED__
typedef interface IComStaThreadPoolKnobs IComStaThreadPoolKnobs;
#endif 	/* __IComStaThreadPoolKnobs_FWD_DEFINED__ */


#ifndef __IComMtaThreadPoolKnobs_FWD_DEFINED__
#define __IComMtaThreadPoolKnobs_FWD_DEFINED__
typedef interface IComMtaThreadPoolKnobs IComMtaThreadPoolKnobs;
#endif 	/* __IComMtaThreadPoolKnobs_FWD_DEFINED__ */


#ifndef __IComStaThreadPoolKnobs2_FWD_DEFINED__
#define __IComStaThreadPoolKnobs2_FWD_DEFINED__
typedef interface IComStaThreadPoolKnobs2 IComStaThreadPoolKnobs2;
#endif 	/* __IComStaThreadPoolKnobs2_FWD_DEFINED__ */


#ifndef __IProcessInitializer_FWD_DEFINED__
#define __IProcessInitializer_FWD_DEFINED__
typedef interface IProcessInitializer IProcessInitializer;
#endif 	/* __IProcessInitializer_FWD_DEFINED__ */


#ifndef __IServicePoolConfig_FWD_DEFINED__
#define __IServicePoolConfig_FWD_DEFINED__
typedef interface IServicePoolConfig IServicePoolConfig;
#endif 	/* __IServicePoolConfig_FWD_DEFINED__ */


#ifndef __IServicePool_FWD_DEFINED__
#define __IServicePool_FWD_DEFINED__
typedef interface IServicePool IServicePool;
#endif 	/* __IServicePool_FWD_DEFINED__ */


#ifndef __IManagedPooledObj_FWD_DEFINED__
#define __IManagedPooledObj_FWD_DEFINED__
typedef interface IManagedPooledObj IManagedPooledObj;
#endif 	/* __IManagedPooledObj_FWD_DEFINED__ */


#ifndef __IManagedPoolAction_FWD_DEFINED__
#define __IManagedPoolAction_FWD_DEFINED__
typedef interface IManagedPoolAction IManagedPoolAction;
#endif 	/* __IManagedPoolAction_FWD_DEFINED__ */


#ifndef __IManagedObjectInfo_FWD_DEFINED__
#define __IManagedObjectInfo_FWD_DEFINED__
typedef interface IManagedObjectInfo IManagedObjectInfo;
#endif 	/* __IManagedObjectInfo_FWD_DEFINED__ */


#ifndef __IAppDomainHelper_FWD_DEFINED__
#define __IAppDomainHelper_FWD_DEFINED__
typedef interface IAppDomainHelper IAppDomainHelper;
#endif 	/* __IAppDomainHelper_FWD_DEFINED__ */


#ifndef __IAssemblyLocator_FWD_DEFINED__
#define __IAssemblyLocator_FWD_DEFINED__
typedef interface IAssemblyLocator IAssemblyLocator;
#endif 	/* __IAssemblyLocator_FWD_DEFINED__ */


#ifndef __IManagedActivationEvents_FWD_DEFINED__
#define __IManagedActivationEvents_FWD_DEFINED__
typedef interface IManagedActivationEvents IManagedActivationEvents;
#endif 	/* __IManagedActivationEvents_FWD_DEFINED__ */


#ifndef __ISendMethodEvents_FWD_DEFINED__
#define __ISendMethodEvents_FWD_DEFINED__
typedef interface ISendMethodEvents ISendMethodEvents;
#endif 	/* __ISendMethodEvents_FWD_DEFINED__ */


#ifndef __ITransactionResourcePool_FWD_DEFINED__
#define __ITransactionResourcePool_FWD_DEFINED__
typedef interface ITransactionResourcePool ITransactionResourcePool;
#endif 	/* __ITransactionResourcePool_FWD_DEFINED__ */


#ifndef __IMTSCall_FWD_DEFINED__
#define __IMTSCall_FWD_DEFINED__
typedef interface IMTSCall IMTSCall;
#endif 	/* __IMTSCall_FWD_DEFINED__ */


#ifndef __IContextProperties_FWD_DEFINED__
#define __IContextProperties_FWD_DEFINED__
typedef interface IContextProperties IContextProperties;
#endif 	/* __IContextProperties_FWD_DEFINED__ */


#ifndef __IObjPool_FWD_DEFINED__
#define __IObjPool_FWD_DEFINED__
typedef interface IObjPool IObjPool;
#endif 	/* __IObjPool_FWD_DEFINED__ */


#ifndef __ITransactionProperty_FWD_DEFINED__
#define __ITransactionProperty_FWD_DEFINED__
typedef interface ITransactionProperty ITransactionProperty;
#endif 	/* __ITransactionProperty_FWD_DEFINED__ */


#ifndef __IMTSActivity_FWD_DEFINED__
#define __IMTSActivity_FWD_DEFINED__
typedef interface IMTSActivity IMTSActivity;
#endif 	/* __IMTSActivity_FWD_DEFINED__ */


#ifndef __SecurityIdentity_FWD_DEFINED__
#define __SecurityIdentity_FWD_DEFINED__

#ifdef __cplusplus
typedef class SecurityIdentity SecurityIdentity;
#else
typedef struct SecurityIdentity SecurityIdentity;
#endif /* __cplusplus */

#endif 	/* __SecurityIdentity_FWD_DEFINED__ */


#ifndef __SecurityCallers_FWD_DEFINED__
#define __SecurityCallers_FWD_DEFINED__

#ifdef __cplusplus
typedef class SecurityCallers SecurityCallers;
#else
typedef struct SecurityCallers SecurityCallers;
#endif /* __cplusplus */

#endif 	/* __SecurityCallers_FWD_DEFINED__ */


#ifndef __SecurityCallContext_FWD_DEFINED__
#define __SecurityCallContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class SecurityCallContext SecurityCallContext;
#else
typedef struct SecurityCallContext SecurityCallContext;
#endif /* __cplusplus */

#endif 	/* __SecurityCallContext_FWD_DEFINED__ */


#ifndef __GetSecurityCallContextAppObject_FWD_DEFINED__
#define __GetSecurityCallContextAppObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class GetSecurityCallContextAppObject GetSecurityCallContextAppObject;
#else
typedef struct GetSecurityCallContextAppObject GetSecurityCallContextAppObject;
#endif /* __cplusplus */

#endif 	/* __GetSecurityCallContextAppObject_FWD_DEFINED__ */


#ifndef __IContextState_FWD_DEFINED__
#define __IContextState_FWD_DEFINED__
typedef interface IContextState IContextState;
#endif 	/* __IContextState_FWD_DEFINED__ */


#ifndef __Dummy30040732_FWD_DEFINED__
#define __Dummy30040732_FWD_DEFINED__

#ifdef __cplusplus
typedef class Dummy30040732 Dummy30040732;
#else
typedef struct Dummy30040732 Dummy30040732;
#endif /* __cplusplus */

#endif 	/* __Dummy30040732_FWD_DEFINED__ */


#ifndef __ContextInfo_FWD_DEFINED__
#define __ContextInfo_FWD_DEFINED__
typedef interface ContextInfo ContextInfo;
#endif 	/* __ContextInfo_FWD_DEFINED__ */


#ifndef __ContextInfo2_FWD_DEFINED__
#define __ContextInfo2_FWD_DEFINED__
typedef interface ContextInfo2 ContextInfo2;
#endif 	/* __ContextInfo2_FWD_DEFINED__ */


#ifndef __ObjectControl_FWD_DEFINED__
#define __ObjectControl_FWD_DEFINED__
typedef interface ObjectControl ObjectControl;
#endif 	/* __ObjectControl_FWD_DEFINED__ */


#ifndef __TransactionContext_FWD_DEFINED__
#define __TransactionContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransactionContext TransactionContext;
#else
typedef struct TransactionContext TransactionContext;
#endif /* __cplusplus */

#endif 	/* __TransactionContext_FWD_DEFINED__ */


#ifndef __TransactionContextEx_FWD_DEFINED__
#define __TransactionContextEx_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransactionContextEx TransactionContextEx;
#else
typedef struct TransactionContextEx TransactionContextEx;
#endif /* __cplusplus */

#endif 	/* __TransactionContextEx_FWD_DEFINED__ */


#ifndef __ByotServerEx_FWD_DEFINED__
#define __ByotServerEx_FWD_DEFINED__

#ifdef __cplusplus
typedef class ByotServerEx ByotServerEx;
#else
typedef struct ByotServerEx ByotServerEx;
#endif /* __cplusplus */

#endif 	/* __ByotServerEx_FWD_DEFINED__ */


#ifndef __CServiceConfig_FWD_DEFINED__
#define __CServiceConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class CServiceConfig CServiceConfig;
#else
typedef struct CServiceConfig CServiceConfig;
#endif /* __cplusplus */

#endif 	/* __CServiceConfig_FWD_DEFINED__ */


#ifndef __ServicePool_FWD_DEFINED__
#define __ServicePool_FWD_DEFINED__

#ifdef __cplusplus
typedef class ServicePool ServicePool;
#else
typedef struct ServicePool ServicePool;
#endif /* __cplusplus */

#endif 	/* __ServicePool_FWD_DEFINED__ */


#ifndef __ServicePoolConfig_FWD_DEFINED__
#define __ServicePoolConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class ServicePoolConfig ServicePoolConfig;
#else
typedef struct ServicePoolConfig ServicePoolConfig;
#endif /* __cplusplus */

#endif 	/* __ServicePoolConfig_FWD_DEFINED__ */


#ifndef __SharedProperty_FWD_DEFINED__
#define __SharedProperty_FWD_DEFINED__

#ifdef __cplusplus
typedef class SharedProperty SharedProperty;
#else
typedef struct SharedProperty SharedProperty;
#endif /* __cplusplus */

#endif 	/* __SharedProperty_FWD_DEFINED__ */


#ifndef __SharedPropertyGroup_FWD_DEFINED__
#define __SharedPropertyGroup_FWD_DEFINED__

#ifdef __cplusplus
typedef class SharedPropertyGroup SharedPropertyGroup;
#else
typedef struct SharedPropertyGroup SharedPropertyGroup;
#endif /* __cplusplus */

#endif 	/* __SharedPropertyGroup_FWD_DEFINED__ */


#ifndef __SharedPropertyGroupManager_FWD_DEFINED__
#define __SharedPropertyGroupManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class SharedPropertyGroupManager SharedPropertyGroupManager;
#else
typedef struct SharedPropertyGroupManager SharedPropertyGroupManager;
#endif /* __cplusplus */

#endif 	/* __SharedPropertyGroupManager_FWD_DEFINED__ */


#ifndef __COMEvents_FWD_DEFINED__
#define __COMEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class COMEvents COMEvents;
#else
typedef struct COMEvents COMEvents;
#endif /* __cplusplus */

#endif 	/* __COMEvents_FWD_DEFINED__ */


#ifndef __CoMTSLocator_FWD_DEFINED__
#define __CoMTSLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoMTSLocator CoMTSLocator;
#else
typedef struct CoMTSLocator CoMTSLocator;
#endif /* __cplusplus */

#endif 	/* __CoMTSLocator_FWD_DEFINED__ */


#ifndef __MtsGrp_FWD_DEFINED__
#define __MtsGrp_FWD_DEFINED__

#ifdef __cplusplus
typedef class MtsGrp MtsGrp;
#else
typedef struct MtsGrp MtsGrp;
#endif /* __cplusplus */

#endif 	/* __MtsGrp_FWD_DEFINED__ */


#ifndef __ComServiceEvents_FWD_DEFINED__
#define __ComServiceEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComServiceEvents ComServiceEvents;
#else
typedef struct ComServiceEvents ComServiceEvents;
#endif /* __cplusplus */

#endif 	/* __ComServiceEvents_FWD_DEFINED__ */


#ifndef __ComSystemAppEventData_FWD_DEFINED__
#define __ComSystemAppEventData_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComSystemAppEventData ComSystemAppEventData;
#else
typedef struct ComSystemAppEventData ComSystemAppEventData;
#endif /* __cplusplus */

#endif 	/* __ComSystemAppEventData_FWD_DEFINED__ */


#ifndef __CRMClerk_FWD_DEFINED__
#define __CRMClerk_FWD_DEFINED__

#ifdef __cplusplus
typedef class CRMClerk CRMClerk;
#else
typedef struct CRMClerk CRMClerk;
#endif /* __cplusplus */

#endif 	/* __CRMClerk_FWD_DEFINED__ */


#ifndef __CRMRecoveryClerk_FWD_DEFINED__
#define __CRMRecoveryClerk_FWD_DEFINED__

#ifdef __cplusplus
typedef class CRMRecoveryClerk CRMRecoveryClerk;
#else
typedef struct CRMRecoveryClerk CRMRecoveryClerk;
#endif /* __cplusplus */

#endif 	/* __CRMRecoveryClerk_FWD_DEFINED__ */


#ifndef __MessageMover_FWD_DEFINED__
#define __MessageMover_FWD_DEFINED__

#ifdef __cplusplus
typedef class MessageMover MessageMover;
#else
typedef struct MessageMover MessageMover;
#endif /* __cplusplus */

#endif 	/* __MessageMover_FWD_DEFINED__ */


#ifndef __DispenserManager_FWD_DEFINED__
#define __DispenserManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class DispenserManager DispenserManager;
#else
typedef struct DispenserManager DispenserManager;
#endif /* __cplusplus */

#endif 	/* __DispenserManager_FWD_DEFINED__ */


#ifndef __PoolMgr_FWD_DEFINED__
#define __PoolMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class PoolMgr PoolMgr;
#else
typedef struct PoolMgr PoolMgr;
#endif /* __cplusplus */

#endif 	/* __PoolMgr_FWD_DEFINED__ */


#ifndef __EventServer_FWD_DEFINED__
#define __EventServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class EventServer EventServer;
#else
typedef struct EventServer EventServer;
#endif /* __cplusplus */

#endif 	/* __EventServer_FWD_DEFINED__ */


#ifndef __AppDomainHelper_FWD_DEFINED__
#define __AppDomainHelper_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppDomainHelper AppDomainHelper;
#else
typedef struct AppDomainHelper AppDomainHelper;
#endif /* __cplusplus */

#endif 	/* __AppDomainHelper_FWD_DEFINED__ */


#ifndef __ClrAssemblyLocator_FWD_DEFINED__
#define __ClrAssemblyLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class ClrAssemblyLocator ClrAssemblyLocator;
#else
typedef struct ClrAssemblyLocator ClrAssemblyLocator;
#endif /* __cplusplus */

#endif 	/* __ClrAssemblyLocator_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "ocidl.h"
#include "comadmin.h"
#include "transact.h"
#include "txdtc.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_autosvcs_0000_0000 */
/* [local] */ 

// -----------------------------------------------------------------------
// svcintfs.h -- Microsoft COM+ Services 1.0 Programming Interfaces       
//                                                                        
// This file provides the prototypes for the APIs and COM interfaces      
// for applications using COM+ Services.                                  
//                                                                        
// COM+ Services 1.0                                                      
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// -----------------------------------------------------------------------
#include <objbase.h>
#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif



extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0000_v0_0_s_ifspec;

#ifndef __ISecurityIdentityColl_INTERFACE_DEFINED__
#define __ISecurityIdentityColl_INTERFACE_DEFINED__

/* interface ISecurityIdentityColl */
/* [unique][helpcontext][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_ISecurityIdentityColl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CAFC823C-B441-11d1-B82B-0000F8757E2A")
    ISecurityIdentityColl : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][helpcontext][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pItem) = 0;
        
        virtual /* [helpstring][helpcontext][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISecurityIdentityCollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISecurityIdentityColl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISecurityIdentityColl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISecurityIdentityColl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISecurityIdentityColl * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISecurityIdentityColl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISecurityIdentityColl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISecurityIdentityColl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ISecurityIdentityColl * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ISecurityIdentityColl * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pItem);
        
        /* [helpstring][helpcontext][restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ISecurityIdentityColl * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnum);
        
        END_INTERFACE
    } ISecurityIdentityCollVtbl;

    interface ISecurityIdentityColl
    {
        CONST_VTBL struct ISecurityIdentityCollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISecurityIdentityColl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISecurityIdentityColl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISecurityIdentityColl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISecurityIdentityColl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISecurityIdentityColl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISecurityIdentityColl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISecurityIdentityColl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISecurityIdentityColl_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISecurityIdentityColl_get_Item(This,name,pItem)	\
    ( (This)->lpVtbl -> get_Item(This,name,pItem) ) 

#define ISecurityIdentityColl_get__NewEnum(This,ppEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISecurityIdentityColl_INTERFACE_DEFINED__ */


#ifndef __ISecurityCallersColl_INTERFACE_DEFINED__
#define __ISecurityCallersColl_INTERFACE_DEFINED__

/* interface ISecurityCallersColl */
/* [unique][helpcontext][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISecurityCallersColl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CAFC823D-B441-11d1-B82B-0000F8757E2A")
    ISecurityCallersColl : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][helpcontext][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ __RPC__deref_out_opt ISecurityIdentityColl **pObj) = 0;
        
        virtual /* [helpstring][helpcontext][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISecurityCallersCollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISecurityCallersColl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISecurityCallersColl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISecurityCallersColl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISecurityCallersColl * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISecurityCallersColl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISecurityCallersColl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISecurityCallersColl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ISecurityCallersColl * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ISecurityCallersColl * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ __RPC__deref_out_opt ISecurityIdentityColl **pObj);
        
        /* [helpstring][helpcontext][restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ISecurityCallersColl * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnum);
        
        END_INTERFACE
    } ISecurityCallersCollVtbl;

    interface ISecurityCallersColl
    {
        CONST_VTBL struct ISecurityCallersCollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISecurityCallersColl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISecurityCallersColl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISecurityCallersColl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISecurityCallersColl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISecurityCallersColl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISecurityCallersColl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISecurityCallersColl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISecurityCallersColl_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISecurityCallersColl_get_Item(This,lIndex,pObj)	\
    ( (This)->lpVtbl -> get_Item(This,lIndex,pObj) ) 

#define ISecurityCallersColl_get__NewEnum(This,ppEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISecurityCallersColl_INTERFACE_DEFINED__ */


#ifndef __ISecurityCallContext_INTERFACE_DEFINED__
#define __ISecurityCallContext_INTERFACE_DEFINED__

/* interface ISecurityCallContext */
/* [unique][helpcontext][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_ISecurityCallContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CAFC823E-B441-11d1-B82B-0000F8757E2A")
    ISecurityCallContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][helpcontext][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pItem) = 0;
        
        virtual /* [helpstring][helpcontext][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnum) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE IsCallerInRole( 
            __RPC__in BSTR bstrRole,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfInRole) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE IsSecurityEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfIsEnabled) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE IsUserInRole( 
            /* [in] */ __RPC__in VARIANT *pUser,
            /* [in] */ __RPC__in BSTR bstrRole,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfInRole) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISecurityCallContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISecurityCallContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISecurityCallContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISecurityCallContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISecurityCallContext * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISecurityCallContext * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISecurityCallContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISecurityCallContext * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ISecurityCallContext * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ISecurityCallContext * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pItem);
        
        /* [helpstring][helpcontext][restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ISecurityCallContext * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnum);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *IsCallerInRole )( 
            ISecurityCallContext * This,
            __RPC__in BSTR bstrRole,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfInRole);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *IsSecurityEnabled )( 
            ISecurityCallContext * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfIsEnabled);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *IsUserInRole )( 
            ISecurityCallContext * This,
            /* [in] */ __RPC__in VARIANT *pUser,
            /* [in] */ __RPC__in BSTR bstrRole,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfInRole);
        
        END_INTERFACE
    } ISecurityCallContextVtbl;

    interface ISecurityCallContext
    {
        CONST_VTBL struct ISecurityCallContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISecurityCallContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISecurityCallContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISecurityCallContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISecurityCallContext_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISecurityCallContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISecurityCallContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISecurityCallContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISecurityCallContext_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISecurityCallContext_get_Item(This,name,pItem)	\
    ( (This)->lpVtbl -> get_Item(This,name,pItem) ) 

#define ISecurityCallContext_get__NewEnum(This,ppEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppEnum) ) 

#define ISecurityCallContext_IsCallerInRole(This,bstrRole,pfInRole)	\
    ( (This)->lpVtbl -> IsCallerInRole(This,bstrRole,pfInRole) ) 

#define ISecurityCallContext_IsSecurityEnabled(This,pfIsEnabled)	\
    ( (This)->lpVtbl -> IsSecurityEnabled(This,pfIsEnabled) ) 

#define ISecurityCallContext_IsUserInRole(This,pUser,bstrRole,pfInRole)	\
    ( (This)->lpVtbl -> IsUserInRole(This,pUser,bstrRole,pfInRole) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISecurityCallContext_INTERFACE_DEFINED__ */


#ifndef __IGetSecurityCallContext_INTERFACE_DEFINED__
#define __IGetSecurityCallContext_INTERFACE_DEFINED__

/* interface IGetSecurityCallContext */
/* [unique][helpcontext][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IGetSecurityCallContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CAFC823F-B441-11d1-B82B-0000F8757E2A")
    IGetSecurityCallContext : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE GetSecurityCallContext( 
            /* [retval][out] */ __RPC__deref_out_opt ISecurityCallContext **ppObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetSecurityCallContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetSecurityCallContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetSecurityCallContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetSecurityCallContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGetSecurityCallContext * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGetSecurityCallContext * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGetSecurityCallContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGetSecurityCallContext * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecurityCallContext )( 
            IGetSecurityCallContext * This,
            /* [retval][out] */ __RPC__deref_out_opt ISecurityCallContext **ppObject);
        
        END_INTERFACE
    } IGetSecurityCallContextVtbl;

    interface IGetSecurityCallContext
    {
        CONST_VTBL struct IGetSecurityCallContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetSecurityCallContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetSecurityCallContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetSecurityCallContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetSecurityCallContext_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IGetSecurityCallContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IGetSecurityCallContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IGetSecurityCallContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IGetSecurityCallContext_GetSecurityCallContext(This,ppObject)	\
    ( (This)->lpVtbl -> GetSecurityCallContext(This,ppObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetSecurityCallContext_INTERFACE_DEFINED__ */


#ifndef __SecurityProperty_INTERFACE_DEFINED__
#define __SecurityProperty_INTERFACE_DEFINED__

/* interface SecurityProperty */
/* [unique][helpcontext][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_SecurityProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E74A7215-014D-11d1-A63C-00A0C911B4E0")
    SecurityProperty : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE GetDirectCallerName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE GetDirectCreatorName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE GetOriginalCallerName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE GetOriginalCreatorName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct SecurityPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SecurityProperty * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SecurityProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SecurityProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            SecurityProperty * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            SecurityProperty * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            SecurityProperty * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            SecurityProperty * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *GetDirectCallerName )( 
            SecurityProperty * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *GetDirectCreatorName )( 
            SecurityProperty * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *GetOriginalCallerName )( 
            SecurityProperty * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *GetOriginalCreatorName )( 
            SecurityProperty * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName);
        
        END_INTERFACE
    } SecurityPropertyVtbl;

    interface SecurityProperty
    {
        CONST_VTBL struct SecurityPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SecurityProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define SecurityProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define SecurityProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define SecurityProperty_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define SecurityProperty_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define SecurityProperty_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define SecurityProperty_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define SecurityProperty_GetDirectCallerName(This,bstrUserName)	\
    ( (This)->lpVtbl -> GetDirectCallerName(This,bstrUserName) ) 

#define SecurityProperty_GetDirectCreatorName(This,bstrUserName)	\
    ( (This)->lpVtbl -> GetDirectCreatorName(This,bstrUserName) ) 

#define SecurityProperty_GetOriginalCallerName(This,bstrUserName)	\
    ( (This)->lpVtbl -> GetOriginalCallerName(This,bstrUserName) ) 

#define SecurityProperty_GetOriginalCreatorName(This,bstrUserName)	\
    ( (This)->lpVtbl -> GetOriginalCreatorName(This,bstrUserName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __SecurityProperty_INTERFACE_DEFINED__ */


#ifndef __ContextInfo_INTERFACE_DEFINED__
#define __ContextInfo_INTERFACE_DEFINED__

/* interface ContextInfo */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ContextInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19A5A02C-0AC8-11d2-B286-00C04F8EF934")
    ContextInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsInTransaction( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsInTx) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTransaction( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppTx) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTransactionId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTxId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetActivityId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrActivityId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetContextId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCtxId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ContextInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ContextInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ContextInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ContextInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ContextInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ContextInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ContextInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ContextInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsInTransaction )( 
            ContextInfo * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsInTx);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTransaction )( 
            ContextInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppTx);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTransactionId )( 
            ContextInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTxId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetActivityId )( 
            ContextInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrActivityId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetContextId )( 
            ContextInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCtxId);
        
        END_INTERFACE
    } ContextInfoVtbl;

    interface ContextInfo
    {
        CONST_VTBL struct ContextInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ContextInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ContextInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ContextInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ContextInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ContextInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ContextInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ContextInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ContextInfo_IsInTransaction(This,pbIsInTx)	\
    ( (This)->lpVtbl -> IsInTransaction(This,pbIsInTx) ) 

#define ContextInfo_GetTransaction(This,ppTx)	\
    ( (This)->lpVtbl -> GetTransaction(This,ppTx) ) 

#define ContextInfo_GetTransactionId(This,pbstrTxId)	\
    ( (This)->lpVtbl -> GetTransactionId(This,pbstrTxId) ) 

#define ContextInfo_GetActivityId(This,pbstrActivityId)	\
    ( (This)->lpVtbl -> GetActivityId(This,pbstrActivityId) ) 

#define ContextInfo_GetContextId(This,pbstrCtxId)	\
    ( (This)->lpVtbl -> GetContextId(This,pbstrCtxId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ContextInfo_INTERFACE_DEFINED__ */


#ifndef __ContextInfo2_INTERFACE_DEFINED__
#define __ContextInfo2_INTERFACE_DEFINED__

/* interface ContextInfo2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ContextInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c99d6e75-2375-11d4-8331-00c04f605588")
    ContextInfo2 : public ContextInfo
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *__MIDL__ContextInfo20000) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetApplicationId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *__MIDL__ContextInfo20001) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetApplicationInstanceId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *__MIDL__ContextInfo20002) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ContextInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ContextInfo2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ContextInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ContextInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ContextInfo2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ContextInfo2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ContextInfo2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ContextInfo2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsInTransaction )( 
            ContextInfo2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsInTx);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTransaction )( 
            ContextInfo2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppTx);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTransactionId )( 
            ContextInfo2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTxId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetActivityId )( 
            ContextInfo2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrActivityId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetContextId )( 
            ContextInfo2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCtxId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionId )( 
            ContextInfo2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *__MIDL__ContextInfo20000);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetApplicationId )( 
            ContextInfo2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *__MIDL__ContextInfo20001);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetApplicationInstanceId )( 
            ContextInfo2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *__MIDL__ContextInfo20002);
        
        END_INTERFACE
    } ContextInfo2Vtbl;

    interface ContextInfo2
    {
        CONST_VTBL struct ContextInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ContextInfo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ContextInfo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ContextInfo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ContextInfo2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ContextInfo2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ContextInfo2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ContextInfo2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ContextInfo2_IsInTransaction(This,pbIsInTx)	\
    ( (This)->lpVtbl -> IsInTransaction(This,pbIsInTx) ) 

#define ContextInfo2_GetTransaction(This,ppTx)	\
    ( (This)->lpVtbl -> GetTransaction(This,ppTx) ) 

#define ContextInfo2_GetTransactionId(This,pbstrTxId)	\
    ( (This)->lpVtbl -> GetTransactionId(This,pbstrTxId) ) 

#define ContextInfo2_GetActivityId(This,pbstrActivityId)	\
    ( (This)->lpVtbl -> GetActivityId(This,pbstrActivityId) ) 

#define ContextInfo2_GetContextId(This,pbstrCtxId)	\
    ( (This)->lpVtbl -> GetContextId(This,pbstrCtxId) ) 


#define ContextInfo2_GetPartitionId(This,__MIDL__ContextInfo20000)	\
    ( (This)->lpVtbl -> GetPartitionId(This,__MIDL__ContextInfo20000) ) 

#define ContextInfo2_GetApplicationId(This,__MIDL__ContextInfo20001)	\
    ( (This)->lpVtbl -> GetApplicationId(This,__MIDL__ContextInfo20001) ) 

#define ContextInfo2_GetApplicationInstanceId(This,__MIDL__ContextInfo20002)	\
    ( (This)->lpVtbl -> GetApplicationInstanceId(This,__MIDL__ContextInfo20002) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ContextInfo2_INTERFACE_DEFINED__ */


#ifndef __ObjectContext_INTERFACE_DEFINED__
#define __ObjectContext_INTERFACE_DEFINED__

/* interface ObjectContext */
/* [unique][helpcontext][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ObjectContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74C08646-CEDB-11CF-8B49-00AA00B8A790")
    ObjectContext : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ __RPC__in BSTR bstrProgID,
            /* [retval][out] */ __RPC__out VARIANT *pObject) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE SetComplete( void) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE SetAbort( void) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE EnableCommit( void) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE DisableCommit( void) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE IsInTransaction( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsInTx) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE IsSecurityEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsEnabled) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE IsCallerInRole( 
            __RPC__in BSTR bstrRole,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbInRole) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pItem) = 0;
        
        virtual /* [helpstring][helpcontext][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnum) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Security( 
            /* [retval][out] */ __RPC__deref_out_opt SecurityProperty **ppSecurityProperty) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContextInfo( 
            /* [retval][out] */ __RPC__deref_out_opt ContextInfo **ppContextInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ObjectContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ObjectContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ObjectContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ObjectContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ObjectContext * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ObjectContext * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ObjectContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ObjectContext * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            ObjectContext * This,
            /* [in] */ __RPC__in BSTR bstrProgID,
            /* [retval][out] */ __RPC__out VARIANT *pObject);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *SetComplete )( 
            ObjectContext * This);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *SetAbort )( 
            ObjectContext * This);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *EnableCommit )( 
            ObjectContext * This);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *DisableCommit )( 
            ObjectContext * This);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *IsInTransaction )( 
            ObjectContext * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsInTx);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *IsSecurityEnabled )( 
            ObjectContext * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsEnabled);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *IsCallerInRole )( 
            ObjectContext * This,
            __RPC__in BSTR bstrRole,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbInRole);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ObjectContext * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ObjectContext * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__out VARIANT *pItem);
        
        /* [helpstring][helpcontext][restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ObjectContext * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnum);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Security )( 
            ObjectContext * This,
            /* [retval][out] */ __RPC__deref_out_opt SecurityProperty **ppSecurityProperty);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContextInfo )( 
            ObjectContext * This,
            /* [retval][out] */ __RPC__deref_out_opt ContextInfo **ppContextInfo);
        
        END_INTERFACE
    } ObjectContextVtbl;

    interface ObjectContext
    {
        CONST_VTBL struct ObjectContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ObjectContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ObjectContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ObjectContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ObjectContext_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ObjectContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ObjectContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ObjectContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ObjectContext_CreateInstance(This,bstrProgID,pObject)	\
    ( (This)->lpVtbl -> CreateInstance(This,bstrProgID,pObject) ) 

#define ObjectContext_SetComplete(This)	\
    ( (This)->lpVtbl -> SetComplete(This) ) 

#define ObjectContext_SetAbort(This)	\
    ( (This)->lpVtbl -> SetAbort(This) ) 

#define ObjectContext_EnableCommit(This)	\
    ( (This)->lpVtbl -> EnableCommit(This) ) 

#define ObjectContext_DisableCommit(This)	\
    ( (This)->lpVtbl -> DisableCommit(This) ) 

#define ObjectContext_IsInTransaction(This,pbIsInTx)	\
    ( (This)->lpVtbl -> IsInTransaction(This,pbIsInTx) ) 

#define ObjectContext_IsSecurityEnabled(This,pbIsEnabled)	\
    ( (This)->lpVtbl -> IsSecurityEnabled(This,pbIsEnabled) ) 

#define ObjectContext_IsCallerInRole(This,bstrRole,pbInRole)	\
    ( (This)->lpVtbl -> IsCallerInRole(This,bstrRole,pbInRole) ) 

#define ObjectContext_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ObjectContext_get_Item(This,name,pItem)	\
    ( (This)->lpVtbl -> get_Item(This,name,pItem) ) 

#define ObjectContext_get__NewEnum(This,ppEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppEnum) ) 

#define ObjectContext_get_Security(This,ppSecurityProperty)	\
    ( (This)->lpVtbl -> get_Security(This,ppSecurityProperty) ) 

#define ObjectContext_get_ContextInfo(This,ppContextInfo)	\
    ( (This)->lpVtbl -> get_ContextInfo(This,ppContextInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ObjectContext_INTERFACE_DEFINED__ */


#ifndef __ITransactionContextEx_INTERFACE_DEFINED__
#define __ITransactionContextEx_INTERFACE_DEFINED__

/* interface ITransactionContextEx */
/* [unique][helpcontext][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITransactionContextEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7999FC22-D3C6-11CF-ACAB-00A024A55AEF")
    ITransactionContextEx : public IUnknown
    {
    public:
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pObject) = 0;
        
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionContextExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionContextEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionContextEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionContextEx * This);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            ITransactionContextEx * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pObject);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ITransactionContextEx * This);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ITransactionContextEx * This);
        
        END_INTERFACE
    } ITransactionContextExVtbl;

    interface ITransactionContextEx
    {
        CONST_VTBL struct ITransactionContextExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionContextEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionContextEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionContextEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionContextEx_CreateInstance(This,rclsid,riid,pObject)	\
    ( (This)->lpVtbl -> CreateInstance(This,rclsid,riid,pObject) ) 

#define ITransactionContextEx_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define ITransactionContextEx_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionContextEx_INTERFACE_DEFINED__ */


#ifndef __ITransactionContext_INTERFACE_DEFINED__
#define __ITransactionContext_INTERFACE_DEFINED__

/* interface ITransactionContext */
/* [unique][helpcontext][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITransactionContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7999FC21-D3C6-11CF-ACAB-00A024A55AEF")
    ITransactionContext : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ __RPC__in BSTR pszProgId,
            /* [retval][out] */ __RPC__out VARIANT *pObject) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITransactionContext * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITransactionContext * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITransactionContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITransactionContext * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            ITransactionContext * This,
            /* [in] */ __RPC__in BSTR pszProgId,
            /* [retval][out] */ __RPC__out VARIANT *pObject);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ITransactionContext * This);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ITransactionContext * This);
        
        END_INTERFACE
    } ITransactionContextVtbl;

    interface ITransactionContext
    {
        CONST_VTBL struct ITransactionContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionContext_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITransactionContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITransactionContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITransactionContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITransactionContext_CreateInstance(This,pszProgId,pObject)	\
    ( (This)->lpVtbl -> CreateInstance(This,pszProgId,pObject) ) 

#define ITransactionContext_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define ITransactionContext_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionContext_INTERFACE_DEFINED__ */


#ifndef __ICreateWithTransactionEx_INTERFACE_DEFINED__
#define __ICreateWithTransactionEx_INTERFACE_DEFINED__

/* interface ICreateWithTransactionEx */
/* [unique][helpcontext][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICreateWithTransactionEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("455ACF57-5345-11d2-99CF-00C04F797BC9")
    ICreateWithTransactionEx : public IUnknown
    {
    public:
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateWithTransactionExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICreateWithTransactionEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICreateWithTransactionEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICreateWithTransactionEx * This);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            ICreateWithTransactionEx * This,
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pObject);
        
        END_INTERFACE
    } ICreateWithTransactionExVtbl;

    interface ICreateWithTransactionEx
    {
        CONST_VTBL struct ICreateWithTransactionExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateWithTransactionEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICreateWithTransactionEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICreateWithTransactionEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICreateWithTransactionEx_CreateInstance(This,pTransaction,rclsid,riid,pObject)	\
    ( (This)->lpVtbl -> CreateInstance(This,pTransaction,rclsid,riid,pObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICreateWithTransactionEx_INTERFACE_DEFINED__ */


#ifndef __ICreateWithLocalTransaction_INTERFACE_DEFINED__
#define __ICreateWithLocalTransaction_INTERFACE_DEFINED__

/* interface ICreateWithLocalTransaction */
/* [unique][helpcontext][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_ICreateWithLocalTransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("227AC7A8-8423-42ce-B7CF-03061EC9AAA3")
    ICreateWithLocalTransaction : public IUnknown
    {
    public:
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE CreateInstanceWithSysTx( 
            /* [in] */ IUnknown *pTransaction,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void **pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateWithLocalTransactionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICreateWithLocalTransaction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICreateWithLocalTransaction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICreateWithLocalTransaction * This);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE *CreateInstanceWithSysTx )( 
            ICreateWithLocalTransaction * This,
            /* [in] */ IUnknown *pTransaction,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void **pObject);
        
        END_INTERFACE
    } ICreateWithLocalTransactionVtbl;

    interface ICreateWithLocalTransaction
    {
        CONST_VTBL struct ICreateWithLocalTransactionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateWithLocalTransaction_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICreateWithLocalTransaction_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICreateWithLocalTransaction_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICreateWithLocalTransaction_CreateInstanceWithSysTx(This,pTransaction,rclsid,riid,pObject)	\
    ( (This)->lpVtbl -> CreateInstanceWithSysTx(This,pTransaction,rclsid,riid,pObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICreateWithLocalTransaction_INTERFACE_DEFINED__ */


#ifndef __ICreateWithTipTransactionEx_INTERFACE_DEFINED__
#define __ICreateWithTipTransactionEx_INTERFACE_DEFINED__

/* interface ICreateWithTipTransactionEx */
/* [unique][helpcontext][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICreateWithTipTransactionEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("455ACF59-5345-11d2-99CF-00C04F797BC9")
    ICreateWithTipTransactionEx : public IUnknown
    {
    public:
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ __RPC__in BSTR bstrTipUrl,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateWithTipTransactionExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICreateWithTipTransactionEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICreateWithTipTransactionEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICreateWithTipTransactionEx * This);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            ICreateWithTipTransactionEx * This,
            /* [in] */ __RPC__in BSTR bstrTipUrl,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pObject);
        
        END_INTERFACE
    } ICreateWithTipTransactionExVtbl;

    interface ICreateWithTipTransactionEx
    {
        CONST_VTBL struct ICreateWithTipTransactionExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateWithTipTransactionEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICreateWithTipTransactionEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICreateWithTipTransactionEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICreateWithTipTransactionEx_CreateInstance(This,bstrTipUrl,rclsid,riid,pObject)	\
    ( (This)->lpVtbl -> CreateInstance(This,bstrTipUrl,rclsid,riid,pObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICreateWithTipTransactionEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0013 */
/* [local] */ 

typedef unsigned __int64 MTS_OBJID;

typedef unsigned __int64 MTS_RESID;

typedef unsigned __int64 ULONG64;

#ifndef _COMSVCSEVENTINFO_
#define _COMSVCSEVENTINFO_
typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][hidden] */ struct __MIDL___MIDL_itf_autosvcs_0000_0013_0001
    {
    DWORD cbSize;
    DWORD dwPid;
    LONGLONG lTime;
    LONG lMicroTime;
    LONGLONG perfCount;
    GUID guidApp;
    LPOLESTR sMachineName;
    } 	COMSVCSEVENTINFO;

#endif _COMSVCSEVENTINFO_


extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0013_v0_0_s_ifspec;

#ifndef __IComLTxEvents_INTERFACE_DEFINED__
#define __IComLTxEvents_INTERFACE_DEFINED__

/* interface IComLTxEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComLTxEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("605CF82C-578E-4298-975D-82BABCD9E053")
    IComLTxEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLtxTransactionStart( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            GUID guidLtx,
            GUID tsid,
            BOOL fRoot,
            int nIsolationLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLtxTransactionPrepare( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            GUID guidLtx,
            BOOL fVote) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLtxTransactionAbort( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            GUID guidLtx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLtxTransactionCommit( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            GUID guidLtx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLtxTransactionPromote( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            GUID guidLtx,
            GUID txnId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComLTxEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComLTxEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComLTxEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComLTxEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLtxTransactionStart )( 
            IComLTxEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            GUID guidLtx,
            GUID tsid,
            BOOL fRoot,
            int nIsolationLevel);
        
        HRESULT ( STDMETHODCALLTYPE *OnLtxTransactionPrepare )( 
            IComLTxEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            GUID guidLtx,
            BOOL fVote);
        
        HRESULT ( STDMETHODCALLTYPE *OnLtxTransactionAbort )( 
            IComLTxEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            GUID guidLtx);
        
        HRESULT ( STDMETHODCALLTYPE *OnLtxTransactionCommit )( 
            IComLTxEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            GUID guidLtx);
        
        HRESULT ( STDMETHODCALLTYPE *OnLtxTransactionPromote )( 
            IComLTxEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            GUID guidLtx,
            GUID txnId);
        
        END_INTERFACE
    } IComLTxEventsVtbl;

    interface IComLTxEvents
    {
        CONST_VTBL struct IComLTxEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComLTxEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComLTxEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComLTxEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComLTxEvents_OnLtxTransactionStart(This,pInfo,guidLtx,tsid,fRoot,nIsolationLevel)	\
    ( (This)->lpVtbl -> OnLtxTransactionStart(This,pInfo,guidLtx,tsid,fRoot,nIsolationLevel) ) 

#define IComLTxEvents_OnLtxTransactionPrepare(This,pInfo,guidLtx,fVote)	\
    ( (This)->lpVtbl -> OnLtxTransactionPrepare(This,pInfo,guidLtx,fVote) ) 

#define IComLTxEvents_OnLtxTransactionAbort(This,pInfo,guidLtx)	\
    ( (This)->lpVtbl -> OnLtxTransactionAbort(This,pInfo,guidLtx) ) 

#define IComLTxEvents_OnLtxTransactionCommit(This,pInfo,guidLtx)	\
    ( (This)->lpVtbl -> OnLtxTransactionCommit(This,pInfo,guidLtx) ) 

#define IComLTxEvents_OnLtxTransactionPromote(This,pInfo,guidLtx,txnId)	\
    ( (This)->lpVtbl -> OnLtxTransactionPromote(This,pInfo,guidLtx,txnId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComLTxEvents_INTERFACE_DEFINED__ */


#ifndef __IComUserEvent_INTERFACE_DEFINED__
#define __IComUserEvent_INTERFACE_DEFINED__

/* interface IComUserEvent */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComUserEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130A4-2E50-11d2-98A5-00C04F8EE1C4")
    IComUserEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUserEvent( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in VARIANT *pvarEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComUserEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComUserEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComUserEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComUserEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUserEvent )( 
            IComUserEvent * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in VARIANT *pvarEvent);
        
        END_INTERFACE
    } IComUserEventVtbl;

    interface IComUserEvent
    {
        CONST_VTBL struct IComUserEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComUserEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComUserEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComUserEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComUserEvent_OnUserEvent(This,pInfo,pvarEvent)	\
    ( (This)->lpVtbl -> OnUserEvent(This,pInfo,pvarEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComUserEvent_INTERFACE_DEFINED__ */


#ifndef __IComThreadEvents_INTERFACE_DEFINED__
#define __IComThreadEvents_INTERFACE_DEFINED__

/* interface IComThreadEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComThreadEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130A5-2E50-11d2-98A5-00C04F8EE1C4")
    IComThreadEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnThreadStart( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ DWORD dwThread,
            /* [in] */ DWORD dwTheadCnt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadTerminate( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ DWORD dwThread,
            /* [in] */ DWORD dwTheadCnt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadBindToApartment( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 AptID,
            /* [in] */ DWORD dwActCnt,
            /* [in] */ DWORD dwLowCnt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadUnBind( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 AptID,
            /* [in] */ DWORD dwActCnt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadWorkEnque( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 MsgWorkID,
            /* [in] */ DWORD QueueLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadWorkPrivate( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 MsgWorkID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadWorkPublic( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 MsgWorkID,
            /* [in] */ DWORD QueueLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadWorkRedirect( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 MsgWorkID,
            /* [in] */ DWORD QueueLen,
            /* [in] */ ULONG64 ThreadNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadWorkReject( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 MsgWorkID,
            /* [in] */ DWORD QueueLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadAssignApartment( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ ULONG64 AptID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadUnassignApartment( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 AptID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComThreadEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComThreadEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComThreadEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadStart )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ DWORD dwThread,
            /* [in] */ DWORD dwTheadCnt);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadTerminate )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ DWORD dwThread,
            /* [in] */ DWORD dwTheadCnt);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadBindToApartment )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 AptID,
            /* [in] */ DWORD dwActCnt,
            /* [in] */ DWORD dwLowCnt);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadUnBind )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 AptID,
            /* [in] */ DWORD dwActCnt);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadWorkEnque )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 MsgWorkID,
            /* [in] */ DWORD QueueLen);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadWorkPrivate )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 MsgWorkID);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadWorkPublic )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 MsgWorkID,
            /* [in] */ DWORD QueueLen);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadWorkRedirect )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 MsgWorkID,
            /* [in] */ DWORD QueueLen,
            /* [in] */ ULONG64 ThreadNum);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadWorkReject )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ThreadID,
            /* [in] */ ULONG64 MsgWorkID,
            /* [in] */ DWORD QueueLen);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadAssignApartment )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ ULONG64 AptID);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadUnassignApartment )( 
            IComThreadEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 AptID);
        
        END_INTERFACE
    } IComThreadEventsVtbl;

    interface IComThreadEvents
    {
        CONST_VTBL struct IComThreadEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComThreadEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComThreadEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComThreadEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComThreadEvents_OnThreadStart(This,pInfo,ThreadID,dwThread,dwTheadCnt)	\
    ( (This)->lpVtbl -> OnThreadStart(This,pInfo,ThreadID,dwThread,dwTheadCnt) ) 

#define IComThreadEvents_OnThreadTerminate(This,pInfo,ThreadID,dwThread,dwTheadCnt)	\
    ( (This)->lpVtbl -> OnThreadTerminate(This,pInfo,ThreadID,dwThread,dwTheadCnt) ) 

#define IComThreadEvents_OnThreadBindToApartment(This,pInfo,ThreadID,AptID,dwActCnt,dwLowCnt)	\
    ( (This)->lpVtbl -> OnThreadBindToApartment(This,pInfo,ThreadID,AptID,dwActCnt,dwLowCnt) ) 

#define IComThreadEvents_OnThreadUnBind(This,pInfo,ThreadID,AptID,dwActCnt)	\
    ( (This)->lpVtbl -> OnThreadUnBind(This,pInfo,ThreadID,AptID,dwActCnt) ) 

#define IComThreadEvents_OnThreadWorkEnque(This,pInfo,ThreadID,MsgWorkID,QueueLen)	\
    ( (This)->lpVtbl -> OnThreadWorkEnque(This,pInfo,ThreadID,MsgWorkID,QueueLen) ) 

#define IComThreadEvents_OnThreadWorkPrivate(This,pInfo,ThreadID,MsgWorkID)	\
    ( (This)->lpVtbl -> OnThreadWorkPrivate(This,pInfo,ThreadID,MsgWorkID) ) 

#define IComThreadEvents_OnThreadWorkPublic(This,pInfo,ThreadID,MsgWorkID,QueueLen)	\
    ( (This)->lpVtbl -> OnThreadWorkPublic(This,pInfo,ThreadID,MsgWorkID,QueueLen) ) 

#define IComThreadEvents_OnThreadWorkRedirect(This,pInfo,ThreadID,MsgWorkID,QueueLen,ThreadNum)	\
    ( (This)->lpVtbl -> OnThreadWorkRedirect(This,pInfo,ThreadID,MsgWorkID,QueueLen,ThreadNum) ) 

#define IComThreadEvents_OnThreadWorkReject(This,pInfo,ThreadID,MsgWorkID,QueueLen)	\
    ( (This)->lpVtbl -> OnThreadWorkReject(This,pInfo,ThreadID,MsgWorkID,QueueLen) ) 

#define IComThreadEvents_OnThreadAssignApartment(This,pInfo,guidActivity,AptID)	\
    ( (This)->lpVtbl -> OnThreadAssignApartment(This,pInfo,guidActivity,AptID) ) 

#define IComThreadEvents_OnThreadUnassignApartment(This,pInfo,AptID)	\
    ( (This)->lpVtbl -> OnThreadUnassignApartment(This,pInfo,AptID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComThreadEvents_INTERFACE_DEFINED__ */


#ifndef __IComAppEvents_INTERFACE_DEFINED__
#define __IComAppEvents_INTERFACE_DEFINED__

/* interface IComAppEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComAppEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130A6-2E50-11d2-98A5-00C04F8EE1C4")
    IComAppEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnAppActivation( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAppShutdown( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAppForceShutdown( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComAppEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComAppEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComAppEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComAppEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnAppActivation )( 
            IComAppEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp);
        
        HRESULT ( STDMETHODCALLTYPE *OnAppShutdown )( 
            IComAppEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp);
        
        HRESULT ( STDMETHODCALLTYPE *OnAppForceShutdown )( 
            IComAppEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp);
        
        END_INTERFACE
    } IComAppEventsVtbl;

    interface IComAppEvents
    {
        CONST_VTBL struct IComAppEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComAppEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComAppEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComAppEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComAppEvents_OnAppActivation(This,pInfo,guidApp)	\
    ( (This)->lpVtbl -> OnAppActivation(This,pInfo,guidApp) ) 

#define IComAppEvents_OnAppShutdown(This,pInfo,guidApp)	\
    ( (This)->lpVtbl -> OnAppShutdown(This,pInfo,guidApp) ) 

#define IComAppEvents_OnAppForceShutdown(This,pInfo,guidApp)	\
    ( (This)->lpVtbl -> OnAppForceShutdown(This,pInfo,guidApp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComAppEvents_INTERFACE_DEFINED__ */


#ifndef __IComInstanceEvents_INTERFACE_DEFINED__
#define __IComInstanceEvents_INTERFACE_DEFINED__

/* interface IComInstanceEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComInstanceEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130A7-2E50-11d2-98A5-00C04F8EE1C4")
    IComInstanceEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjectCreate( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ __RPC__in REFCLSID clsid,
            /* [in] */ __RPC__in REFGUID tsid,
            /* [in] */ ULONG64 CtxtID,
            /* [in] */ ULONG64 ObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjectDestroy( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComInstanceEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComInstanceEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComInstanceEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComInstanceEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectCreate )( 
            IComInstanceEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ __RPC__in REFCLSID clsid,
            /* [in] */ __RPC__in REFGUID tsid,
            /* [in] */ ULONG64 CtxtID,
            /* [in] */ ULONG64 ObjectID);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectDestroy )( 
            IComInstanceEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID);
        
        END_INTERFACE
    } IComInstanceEventsVtbl;

    interface IComInstanceEvents
    {
        CONST_VTBL struct IComInstanceEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComInstanceEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComInstanceEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComInstanceEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComInstanceEvents_OnObjectCreate(This,pInfo,guidActivity,clsid,tsid,CtxtID,ObjectID)	\
    ( (This)->lpVtbl -> OnObjectCreate(This,pInfo,guidActivity,clsid,tsid,CtxtID,ObjectID) ) 

#define IComInstanceEvents_OnObjectDestroy(This,pInfo,CtxtID)	\
    ( (This)->lpVtbl -> OnObjectDestroy(This,pInfo,CtxtID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComInstanceEvents_INTERFACE_DEFINED__ */


#ifndef __IComTransactionEvents_INTERFACE_DEFINED__
#define __IComTransactionEvents_INTERFACE_DEFINED__

/* interface IComTransactionEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComTransactionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130A8-2E50-11d2-98A5-00C04F8EE1C4")
    IComTransactionEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnTransactionStart( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ __RPC__in REFGUID tsid,
            /* [in] */ BOOL fRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTransactionPrepare( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ BOOL fVoteYes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTransactionAbort( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTransactionCommit( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComTransactionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComTransactionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComTransactionEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComTransactionEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTransactionStart )( 
            IComTransactionEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ __RPC__in REFGUID tsid,
            /* [in] */ BOOL fRoot);
        
        HRESULT ( STDMETHODCALLTYPE *OnTransactionPrepare )( 
            IComTransactionEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ BOOL fVoteYes);
        
        HRESULT ( STDMETHODCALLTYPE *OnTransactionAbort )( 
            IComTransactionEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx);
        
        HRESULT ( STDMETHODCALLTYPE *OnTransactionCommit )( 
            IComTransactionEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx);
        
        END_INTERFACE
    } IComTransactionEventsVtbl;

    interface IComTransactionEvents
    {
        CONST_VTBL struct IComTransactionEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComTransactionEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComTransactionEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComTransactionEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComTransactionEvents_OnTransactionStart(This,pInfo,guidTx,tsid,fRoot)	\
    ( (This)->lpVtbl -> OnTransactionStart(This,pInfo,guidTx,tsid,fRoot) ) 

#define IComTransactionEvents_OnTransactionPrepare(This,pInfo,guidTx,fVoteYes)	\
    ( (This)->lpVtbl -> OnTransactionPrepare(This,pInfo,guidTx,fVoteYes) ) 

#define IComTransactionEvents_OnTransactionAbort(This,pInfo,guidTx)	\
    ( (This)->lpVtbl -> OnTransactionAbort(This,pInfo,guidTx) ) 

#define IComTransactionEvents_OnTransactionCommit(This,pInfo,guidTx)	\
    ( (This)->lpVtbl -> OnTransactionCommit(This,pInfo,guidTx) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComTransactionEvents_INTERFACE_DEFINED__ */


#ifndef __IComMethodEvents_INTERFACE_DEFINED__
#define __IComMethodEvents_INTERFACE_DEFINED__

/* interface IComMethodEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComMethodEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130A9-2E50-11d2-98A5-00C04F8EE1C4")
    IComMethodEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnMethodCall( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ ULONG iMeth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMethodReturn( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ ULONG iMeth,
            /* [in] */ HRESULT hresult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMethodException( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ ULONG iMeth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComMethodEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComMethodEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComMethodEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComMethodEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnMethodCall )( 
            IComMethodEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ ULONG iMeth);
        
        HRESULT ( STDMETHODCALLTYPE *OnMethodReturn )( 
            IComMethodEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ ULONG iMeth,
            /* [in] */ HRESULT hresult);
        
        HRESULT ( STDMETHODCALLTYPE *OnMethodException )( 
            IComMethodEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ ULONG iMeth);
        
        END_INTERFACE
    } IComMethodEventsVtbl;

    interface IComMethodEvents
    {
        CONST_VTBL struct IComMethodEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComMethodEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComMethodEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComMethodEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComMethodEvents_OnMethodCall(This,pInfo,oid,guidCid,guidRid,iMeth)	\
    ( (This)->lpVtbl -> OnMethodCall(This,pInfo,oid,guidCid,guidRid,iMeth) ) 

#define IComMethodEvents_OnMethodReturn(This,pInfo,oid,guidCid,guidRid,iMeth,hresult)	\
    ( (This)->lpVtbl -> OnMethodReturn(This,pInfo,oid,guidCid,guidRid,iMeth,hresult) ) 

#define IComMethodEvents_OnMethodException(This,pInfo,oid,guidCid,guidRid,iMeth)	\
    ( (This)->lpVtbl -> OnMethodException(This,pInfo,oid,guidCid,guidRid,iMeth) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComMethodEvents_INTERFACE_DEFINED__ */


#ifndef __IComObjectEvents_INTERFACE_DEFINED__
#define __IComObjectEvents_INTERFACE_DEFINED__

/* interface IComObjectEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComObjectEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130AA-2E50-11d2-98A5-00C04F8EE1C4")
    IComObjectEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjectActivate( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID,
            /* [in] */ ULONG64 ObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjectDeactivate( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID,
            /* [in] */ ULONG64 ObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDisableCommit( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEnableCommit( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetComplete( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetAbort( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComObjectEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComObjectEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComObjectEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComObjectEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectActivate )( 
            IComObjectEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID,
            /* [in] */ ULONG64 ObjectID);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectDeactivate )( 
            IComObjectEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID,
            /* [in] */ ULONG64 ObjectID);
        
        HRESULT ( STDMETHODCALLTYPE *OnDisableCommit )( 
            IComObjectEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID);
        
        HRESULT ( STDMETHODCALLTYPE *OnEnableCommit )( 
            IComObjectEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetComplete )( 
            IComObjectEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetAbort )( 
            IComObjectEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID);
        
        END_INTERFACE
    } IComObjectEventsVtbl;

    interface IComObjectEvents
    {
        CONST_VTBL struct IComObjectEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComObjectEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComObjectEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComObjectEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComObjectEvents_OnObjectActivate(This,pInfo,CtxtID,ObjectID)	\
    ( (This)->lpVtbl -> OnObjectActivate(This,pInfo,CtxtID,ObjectID) ) 

#define IComObjectEvents_OnObjectDeactivate(This,pInfo,CtxtID,ObjectID)	\
    ( (This)->lpVtbl -> OnObjectDeactivate(This,pInfo,CtxtID,ObjectID) ) 

#define IComObjectEvents_OnDisableCommit(This,pInfo,CtxtID)	\
    ( (This)->lpVtbl -> OnDisableCommit(This,pInfo,CtxtID) ) 

#define IComObjectEvents_OnEnableCommit(This,pInfo,CtxtID)	\
    ( (This)->lpVtbl -> OnEnableCommit(This,pInfo,CtxtID) ) 

#define IComObjectEvents_OnSetComplete(This,pInfo,CtxtID)	\
    ( (This)->lpVtbl -> OnSetComplete(This,pInfo,CtxtID) ) 

#define IComObjectEvents_OnSetAbort(This,pInfo,CtxtID)	\
    ( (This)->lpVtbl -> OnSetAbort(This,pInfo,CtxtID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComObjectEvents_INTERFACE_DEFINED__ */


#ifndef __IComResourceEvents_INTERFACE_DEFINED__
#define __IComResourceEvents_INTERFACE_DEFINED__

/* interface IComResourceEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComResourceEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130AB-2E50-11d2-98A5-00C04F8EE1C4")
    IComResourceEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnResourceCreate( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ __RPC__in LPCOLESTR pszType,
            /* [in] */ ULONG64 resId,
            /* [in] */ BOOL enlisted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResourceAllocate( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ __RPC__in LPCOLESTR pszType,
            /* [in] */ ULONG64 resId,
            /* [in] */ BOOL enlisted,
            /* [in] */ DWORD NumRated,
            /* [in] */ DWORD Rating) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResourceRecycle( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ __RPC__in LPCOLESTR pszType,
            /* [in] */ ULONG64 resId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResourceDestroy( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in LPCOLESTR pszType,
            /* [in] */ ULONG64 resId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResourceTrack( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ __RPC__in LPCOLESTR pszType,
            /* [in] */ ULONG64 resId,
            /* [in] */ BOOL enlisted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComResourceEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComResourceEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComResourceEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComResourceEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnResourceCreate )( 
            IComResourceEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ __RPC__in LPCOLESTR pszType,
            /* [in] */ ULONG64 resId,
            /* [in] */ BOOL enlisted);
        
        HRESULT ( STDMETHODCALLTYPE *OnResourceAllocate )( 
            IComResourceEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ __RPC__in LPCOLESTR pszType,
            /* [in] */ ULONG64 resId,
            /* [in] */ BOOL enlisted,
            /* [in] */ DWORD NumRated,
            /* [in] */ DWORD Rating);
        
        HRESULT ( STDMETHODCALLTYPE *OnResourceRecycle )( 
            IComResourceEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ __RPC__in LPCOLESTR pszType,
            /* [in] */ ULONG64 resId);
        
        HRESULT ( STDMETHODCALLTYPE *OnResourceDestroy )( 
            IComResourceEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in LPCOLESTR pszType,
            /* [in] */ ULONG64 resId);
        
        HRESULT ( STDMETHODCALLTYPE *OnResourceTrack )( 
            IComResourceEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ __RPC__in LPCOLESTR pszType,
            /* [in] */ ULONG64 resId,
            /* [in] */ BOOL enlisted);
        
        END_INTERFACE
    } IComResourceEventsVtbl;

    interface IComResourceEvents
    {
        CONST_VTBL struct IComResourceEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComResourceEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComResourceEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComResourceEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComResourceEvents_OnResourceCreate(This,pInfo,ObjectID,pszType,resId,enlisted)	\
    ( (This)->lpVtbl -> OnResourceCreate(This,pInfo,ObjectID,pszType,resId,enlisted) ) 

#define IComResourceEvents_OnResourceAllocate(This,pInfo,ObjectID,pszType,resId,enlisted,NumRated,Rating)	\
    ( (This)->lpVtbl -> OnResourceAllocate(This,pInfo,ObjectID,pszType,resId,enlisted,NumRated,Rating) ) 

#define IComResourceEvents_OnResourceRecycle(This,pInfo,ObjectID,pszType,resId)	\
    ( (This)->lpVtbl -> OnResourceRecycle(This,pInfo,ObjectID,pszType,resId) ) 

#define IComResourceEvents_OnResourceDestroy(This,pInfo,ObjectID,hr,pszType,resId)	\
    ( (This)->lpVtbl -> OnResourceDestroy(This,pInfo,ObjectID,hr,pszType,resId) ) 

#define IComResourceEvents_OnResourceTrack(This,pInfo,ObjectID,pszType,resId,enlisted)	\
    ( (This)->lpVtbl -> OnResourceTrack(This,pInfo,ObjectID,pszType,resId,enlisted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComResourceEvents_INTERFACE_DEFINED__ */


#ifndef __IComSecurityEvents_INTERFACE_DEFINED__
#define __IComSecurityEvents_INTERFACE_DEFINED__

/* interface IComSecurityEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComSecurityEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130AC-2E50-11d2-98A5-00C04F8EE1C4")
    IComSecurityEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnAuthenticate( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidActivity,
            ULONG64 ObjectID,
            __RPC__in REFGUID guidIID,
            ULONG iMeth,
            ULONG cbByteOrig,
            /* [size_is][in] */ __RPC__in_ecount_full(cbByteOrig) BYTE *pSidOriginalUser,
            ULONG cbByteCur,
            /* [size_is][in] */ __RPC__in_ecount_full(cbByteCur) BYTE *pSidCurrentUser,
            BOOL bCurrentUserInpersonatingInProc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAuthenticateFail( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidActivity,
            ULONG64 ObjectID,
            __RPC__in REFGUID guidIID,
            ULONG iMeth,
            ULONG cbByteOrig,
            /* [size_is][in] */ __RPC__in_ecount_full(cbByteOrig) BYTE *pSidOriginalUser,
            ULONG cbByteCur,
            /* [size_is][in] */ __RPC__in_ecount_full(cbByteCur) BYTE *pSidCurrentUser,
            BOOL bCurrentUserInpersonatingInProc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComSecurityEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComSecurityEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComSecurityEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComSecurityEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnAuthenticate )( 
            IComSecurityEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidActivity,
            ULONG64 ObjectID,
            __RPC__in REFGUID guidIID,
            ULONG iMeth,
            ULONG cbByteOrig,
            /* [size_is][in] */ __RPC__in_ecount_full(cbByteOrig) BYTE *pSidOriginalUser,
            ULONG cbByteCur,
            /* [size_is][in] */ __RPC__in_ecount_full(cbByteCur) BYTE *pSidCurrentUser,
            BOOL bCurrentUserInpersonatingInProc);
        
        HRESULT ( STDMETHODCALLTYPE *OnAuthenticateFail )( 
            IComSecurityEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidActivity,
            ULONG64 ObjectID,
            __RPC__in REFGUID guidIID,
            ULONG iMeth,
            ULONG cbByteOrig,
            /* [size_is][in] */ __RPC__in_ecount_full(cbByteOrig) BYTE *pSidOriginalUser,
            ULONG cbByteCur,
            /* [size_is][in] */ __RPC__in_ecount_full(cbByteCur) BYTE *pSidCurrentUser,
            BOOL bCurrentUserInpersonatingInProc);
        
        END_INTERFACE
    } IComSecurityEventsVtbl;

    interface IComSecurityEvents
    {
        CONST_VTBL struct IComSecurityEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComSecurityEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComSecurityEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComSecurityEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComSecurityEvents_OnAuthenticate(This,pInfo,guidActivity,ObjectID,guidIID,iMeth,cbByteOrig,pSidOriginalUser,cbByteCur,pSidCurrentUser,bCurrentUserInpersonatingInProc)	\
    ( (This)->lpVtbl -> OnAuthenticate(This,pInfo,guidActivity,ObjectID,guidIID,iMeth,cbByteOrig,pSidOriginalUser,cbByteCur,pSidCurrentUser,bCurrentUserInpersonatingInProc) ) 

#define IComSecurityEvents_OnAuthenticateFail(This,pInfo,guidActivity,ObjectID,guidIID,iMeth,cbByteOrig,pSidOriginalUser,cbByteCur,pSidCurrentUser,bCurrentUserInpersonatingInProc)	\
    ( (This)->lpVtbl -> OnAuthenticateFail(This,pInfo,guidActivity,ObjectID,guidIID,iMeth,cbByteOrig,pSidOriginalUser,cbByteCur,pSidCurrentUser,bCurrentUserInpersonatingInProc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComSecurityEvents_INTERFACE_DEFINED__ */


#ifndef __IComObjectPoolEvents_INTERFACE_DEFINED__
#define __IComObjectPoolEvents_INTERFACE_DEFINED__

/* interface IComObjectPoolEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComObjectPoolEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130AD-2E50-11d2-98A5-00C04F8EE1C4")
    IComObjectPoolEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolPutObject( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidObject,
            int nReason,
            DWORD dwAvailable,
            ULONG64 oid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolGetObject( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidActivity,
            __RPC__in REFGUID guidObject,
            DWORD dwAvailable,
            ULONG64 oid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolRecycleToTx( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidActivity,
            __RPC__in REFGUID guidObject,
            __RPC__in REFGUID guidTx,
            ULONG64 objid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolGetFromTx( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidActivity,
            __RPC__in REFGUID guidObject,
            __RPC__in REFGUID guidTx,
            ULONG64 objid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComObjectPoolEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComObjectPoolEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComObjectPoolEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComObjectPoolEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolPutObject )( 
            IComObjectPoolEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidObject,
            int nReason,
            DWORD dwAvailable,
            ULONG64 oid);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolGetObject )( 
            IComObjectPoolEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidActivity,
            __RPC__in REFGUID guidObject,
            DWORD dwAvailable,
            ULONG64 oid);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolRecycleToTx )( 
            IComObjectPoolEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidActivity,
            __RPC__in REFGUID guidObject,
            __RPC__in REFGUID guidTx,
            ULONG64 objid);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolGetFromTx )( 
            IComObjectPoolEvents * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidActivity,
            __RPC__in REFGUID guidObject,
            __RPC__in REFGUID guidTx,
            ULONG64 objid);
        
        END_INTERFACE
    } IComObjectPoolEventsVtbl;

    interface IComObjectPoolEvents
    {
        CONST_VTBL struct IComObjectPoolEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComObjectPoolEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComObjectPoolEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComObjectPoolEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComObjectPoolEvents_OnObjPoolPutObject(This,pInfo,guidObject,nReason,dwAvailable,oid)	\
    ( (This)->lpVtbl -> OnObjPoolPutObject(This,pInfo,guidObject,nReason,dwAvailable,oid) ) 

#define IComObjectPoolEvents_OnObjPoolGetObject(This,pInfo,guidActivity,guidObject,dwAvailable,oid)	\
    ( (This)->lpVtbl -> OnObjPoolGetObject(This,pInfo,guidActivity,guidObject,dwAvailable,oid) ) 

#define IComObjectPoolEvents_OnObjPoolRecycleToTx(This,pInfo,guidActivity,guidObject,guidTx,objid)	\
    ( (This)->lpVtbl -> OnObjPoolRecycleToTx(This,pInfo,guidActivity,guidObject,guidTx,objid) ) 

#define IComObjectPoolEvents_OnObjPoolGetFromTx(This,pInfo,guidActivity,guidObject,guidTx,objid)	\
    ( (This)->lpVtbl -> OnObjPoolGetFromTx(This,pInfo,guidActivity,guidObject,guidTx,objid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComObjectPoolEvents_INTERFACE_DEFINED__ */


#ifndef __IComObjectPoolEvents2_INTERFACE_DEFINED__
#define __IComObjectPoolEvents2_INTERFACE_DEFINED__

/* interface IComObjectPoolEvents2 */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComObjectPoolEvents2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130AE-2E50-11d2-98A5-00C04F8EE1C4")
    IComObjectPoolEvents2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolCreateObject( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidObject,
            DWORD dwObjsCreated,
            ULONG64 oid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolDestroyObject( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidObject,
            DWORD dwObjsCreated,
            ULONG64 oid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolCreateDecision( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            DWORD dwThreadsWaiting,
            DWORD dwAvail,
            DWORD dwCreated,
            DWORD dwMin,
            DWORD dwMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolTimeout( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidObject,
            __RPC__in REFGUID guidActivity,
            DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolCreatePool( 
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidObject,
            DWORD dwMin,
            DWORD dwMax,
            DWORD dwTimeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComObjectPoolEvents2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComObjectPoolEvents2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComObjectPoolEvents2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComObjectPoolEvents2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolCreateObject )( 
            IComObjectPoolEvents2 * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidObject,
            DWORD dwObjsCreated,
            ULONG64 oid);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolDestroyObject )( 
            IComObjectPoolEvents2 * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidObject,
            DWORD dwObjsCreated,
            ULONG64 oid);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolCreateDecision )( 
            IComObjectPoolEvents2 * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            DWORD dwThreadsWaiting,
            DWORD dwAvail,
            DWORD dwCreated,
            DWORD dwMin,
            DWORD dwMax);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolTimeout )( 
            IComObjectPoolEvents2 * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidObject,
            __RPC__in REFGUID guidActivity,
            DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolCreatePool )( 
            IComObjectPoolEvents2 * This,
            __RPC__in COMSVCSEVENTINFO *pInfo,
            __RPC__in REFGUID guidObject,
            DWORD dwMin,
            DWORD dwMax,
            DWORD dwTimeout);
        
        END_INTERFACE
    } IComObjectPoolEvents2Vtbl;

    interface IComObjectPoolEvents2
    {
        CONST_VTBL struct IComObjectPoolEvents2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComObjectPoolEvents2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComObjectPoolEvents2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComObjectPoolEvents2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComObjectPoolEvents2_OnObjPoolCreateObject(This,pInfo,guidObject,dwObjsCreated,oid)	\
    ( (This)->lpVtbl -> OnObjPoolCreateObject(This,pInfo,guidObject,dwObjsCreated,oid) ) 

#define IComObjectPoolEvents2_OnObjPoolDestroyObject(This,pInfo,guidObject,dwObjsCreated,oid)	\
    ( (This)->lpVtbl -> OnObjPoolDestroyObject(This,pInfo,guidObject,dwObjsCreated,oid) ) 

#define IComObjectPoolEvents2_OnObjPoolCreateDecision(This,pInfo,dwThreadsWaiting,dwAvail,dwCreated,dwMin,dwMax)	\
    ( (This)->lpVtbl -> OnObjPoolCreateDecision(This,pInfo,dwThreadsWaiting,dwAvail,dwCreated,dwMin,dwMax) ) 

#define IComObjectPoolEvents2_OnObjPoolTimeout(This,pInfo,guidObject,guidActivity,dwTimeout)	\
    ( (This)->lpVtbl -> OnObjPoolTimeout(This,pInfo,guidObject,guidActivity,dwTimeout) ) 

#define IComObjectPoolEvents2_OnObjPoolCreatePool(This,pInfo,guidObject,dwMin,dwMax,dwTimeout)	\
    ( (This)->lpVtbl -> OnObjPoolCreatePool(This,pInfo,guidObject,dwMin,dwMax,dwTimeout) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComObjectPoolEvents2_INTERFACE_DEFINED__ */


#ifndef __IComObjectConstructionEvents_INTERFACE_DEFINED__
#define __IComObjectConstructionEvents_INTERFACE_DEFINED__

/* interface IComObjectConstructionEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComObjectConstructionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130AF-2E50-11d2-98A5-00C04F8EE1C4")
    IComObjectConstructionEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjectConstruct( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in LPCOLESTR sConstructString,
            /* [in] */ ULONG64 oid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComObjectConstructionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComObjectConstructionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComObjectConstructionEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComObjectConstructionEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectConstruct )( 
            IComObjectConstructionEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in LPCOLESTR sConstructString,
            /* [in] */ ULONG64 oid);
        
        END_INTERFACE
    } IComObjectConstructionEventsVtbl;

    interface IComObjectConstructionEvents
    {
        CONST_VTBL struct IComObjectConstructionEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComObjectConstructionEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComObjectConstructionEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComObjectConstructionEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComObjectConstructionEvents_OnObjectConstruct(This,pInfo,guidObject,sConstructString,oid)	\
    ( (This)->lpVtbl -> OnObjectConstruct(This,pInfo,guidObject,sConstructString,oid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComObjectConstructionEvents_INTERFACE_DEFINED__ */


#ifndef __IComActivityEvents_INTERFACE_DEFINED__
#define __IComActivityEvents_INTERFACE_DEFINED__

/* interface IComActivityEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComActivityEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130B0-2E50-11d2-98A5-00C04F8EE1C4")
    IComActivityEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnActivityCreate( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnActivityDestroy( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnActivityEnter( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidCurrent,
            /* [in] */ __RPC__in REFGUID guidEntered,
            /* [in] */ DWORD dwThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnActivityTimeout( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidCurrent,
            /* [in] */ __RPC__in REFGUID guidEntered,
            /* [in] */ DWORD dwThread,
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnActivityReenter( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidCurrent,
            /* [in] */ DWORD dwThread,
            /* [in] */ DWORD dwCallDepth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnActivityLeave( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidCurrent,
            /* [in] */ __RPC__in REFGUID guidLeft) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnActivityLeaveSame( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidCurrent,
            /* [in] */ DWORD dwCallDepth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComActivityEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComActivityEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComActivityEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComActivityEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnActivityCreate )( 
            IComActivityEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity);
        
        HRESULT ( STDMETHODCALLTYPE *OnActivityDestroy )( 
            IComActivityEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity);
        
        HRESULT ( STDMETHODCALLTYPE *OnActivityEnter )( 
            IComActivityEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidCurrent,
            /* [in] */ __RPC__in REFGUID guidEntered,
            /* [in] */ DWORD dwThread);
        
        HRESULT ( STDMETHODCALLTYPE *OnActivityTimeout )( 
            IComActivityEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidCurrent,
            /* [in] */ __RPC__in REFGUID guidEntered,
            /* [in] */ DWORD dwThread,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *OnActivityReenter )( 
            IComActivityEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidCurrent,
            /* [in] */ DWORD dwThread,
            /* [in] */ DWORD dwCallDepth);
        
        HRESULT ( STDMETHODCALLTYPE *OnActivityLeave )( 
            IComActivityEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidCurrent,
            /* [in] */ __RPC__in REFGUID guidLeft);
        
        HRESULT ( STDMETHODCALLTYPE *OnActivityLeaveSame )( 
            IComActivityEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidCurrent,
            /* [in] */ DWORD dwCallDepth);
        
        END_INTERFACE
    } IComActivityEventsVtbl;

    interface IComActivityEvents
    {
        CONST_VTBL struct IComActivityEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComActivityEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComActivityEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComActivityEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComActivityEvents_OnActivityCreate(This,pInfo,guidActivity)	\
    ( (This)->lpVtbl -> OnActivityCreate(This,pInfo,guidActivity) ) 

#define IComActivityEvents_OnActivityDestroy(This,pInfo,guidActivity)	\
    ( (This)->lpVtbl -> OnActivityDestroy(This,pInfo,guidActivity) ) 

#define IComActivityEvents_OnActivityEnter(This,pInfo,guidCurrent,guidEntered,dwThread)	\
    ( (This)->lpVtbl -> OnActivityEnter(This,pInfo,guidCurrent,guidEntered,dwThread) ) 

#define IComActivityEvents_OnActivityTimeout(This,pInfo,guidCurrent,guidEntered,dwThread,dwTimeout)	\
    ( (This)->lpVtbl -> OnActivityTimeout(This,pInfo,guidCurrent,guidEntered,dwThread,dwTimeout) ) 

#define IComActivityEvents_OnActivityReenter(This,pInfo,guidCurrent,dwThread,dwCallDepth)	\
    ( (This)->lpVtbl -> OnActivityReenter(This,pInfo,guidCurrent,dwThread,dwCallDepth) ) 

#define IComActivityEvents_OnActivityLeave(This,pInfo,guidCurrent,guidLeft)	\
    ( (This)->lpVtbl -> OnActivityLeave(This,pInfo,guidCurrent,guidLeft) ) 

#define IComActivityEvents_OnActivityLeaveSame(This,pInfo,guidCurrent,dwCallDepth)	\
    ( (This)->lpVtbl -> OnActivityLeaveSame(This,pInfo,guidCurrent,dwCallDepth) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComActivityEvents_INTERFACE_DEFINED__ */


#ifndef __IComIdentityEvents_INTERFACE_DEFINED__
#define __IComIdentityEvents_INTERFACE_DEFINED__

/* interface IComIdentityEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComIdentityEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130B1-2E50-11d2-98A5-00C04F8EE1C4")
    IComIdentityEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnIISRequestInfo( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjId,
            /* [in] */ __RPC__in LPCOLESTR pszClientIP,
            /* [in] */ __RPC__in LPCOLESTR pszServerIP,
            /* [in] */ __RPC__in LPCOLESTR pszURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComIdentityEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComIdentityEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComIdentityEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComIdentityEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnIISRequestInfo )( 
            IComIdentityEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 ObjId,
            /* [in] */ __RPC__in LPCOLESTR pszClientIP,
            /* [in] */ __RPC__in LPCOLESTR pszServerIP,
            /* [in] */ __RPC__in LPCOLESTR pszURL);
        
        END_INTERFACE
    } IComIdentityEventsVtbl;

    interface IComIdentityEvents
    {
        CONST_VTBL struct IComIdentityEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComIdentityEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComIdentityEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComIdentityEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComIdentityEvents_OnIISRequestInfo(This,pInfo,ObjId,pszClientIP,pszServerIP,pszURL)	\
    ( (This)->lpVtbl -> OnIISRequestInfo(This,pInfo,ObjId,pszClientIP,pszServerIP,pszURL) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComIdentityEvents_INTERFACE_DEFINED__ */


#ifndef __IComQCEvents_INTERFACE_DEFINED__
#define __IComQCEvents_INTERFACE_DEFINED__

/* interface IComQCEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComQCEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130B2-2E50-11d2-98A5-00C04F8EE1C4")
    IComQCEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnQCRecord( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 objid,
            /* [in] */ __RPC__in_ecount_full(60) WCHAR szQueue[ 60 ],
            /* [in] */ __RPC__in REFGUID guidMsgId,
            /* [in] */ __RPC__in REFGUID guidWorkFlowId,
            /* [in] */ HRESULT msmqhr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnQCQueueOpen( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in_ecount_full(60) WCHAR szQueue[ 60 ],
            /* [in] */ ULONG64 QueueID,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnQCReceive( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 QueueID,
            /* [in] */ __RPC__in REFGUID guidMsgId,
            /* [in] */ __RPC__in REFGUID guidWorkFlowId,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnQCReceiveFail( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 QueueID,
            /* [in] */ HRESULT msmqhr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnQCMoveToReTryQueue( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidMsgId,
            /* [in] */ __RPC__in REFGUID guidWorkFlowId,
            /* [in] */ ULONG RetryIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnQCMoveToDeadQueue( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidMsgId,
            /* [in] */ __RPC__in REFGUID guidWorkFlowId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnQCPlayback( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 objid,
            /* [in] */ __RPC__in REFGUID guidMsgId,
            /* [in] */ __RPC__in REFGUID guidWorkFlowId,
            /* [in] */ HRESULT hr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComQCEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComQCEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComQCEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComQCEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnQCRecord )( 
            IComQCEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 objid,
            /* [in] */ __RPC__in_ecount_full(60) WCHAR szQueue[ 60 ],
            /* [in] */ __RPC__in REFGUID guidMsgId,
            /* [in] */ __RPC__in REFGUID guidWorkFlowId,
            /* [in] */ HRESULT msmqhr);
        
        HRESULT ( STDMETHODCALLTYPE *OnQCQueueOpen )( 
            IComQCEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in_ecount_full(60) WCHAR szQueue[ 60 ],
            /* [in] */ ULONG64 QueueID,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *OnQCReceive )( 
            IComQCEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 QueueID,
            /* [in] */ __RPC__in REFGUID guidMsgId,
            /* [in] */ __RPC__in REFGUID guidWorkFlowId,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *OnQCReceiveFail )( 
            IComQCEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 QueueID,
            /* [in] */ HRESULT msmqhr);
        
        HRESULT ( STDMETHODCALLTYPE *OnQCMoveToReTryQueue )( 
            IComQCEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidMsgId,
            /* [in] */ __RPC__in REFGUID guidWorkFlowId,
            /* [in] */ ULONG RetryIndex);
        
        HRESULT ( STDMETHODCALLTYPE *OnQCMoveToDeadQueue )( 
            IComQCEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidMsgId,
            /* [in] */ __RPC__in REFGUID guidWorkFlowId);
        
        HRESULT ( STDMETHODCALLTYPE *OnQCPlayback )( 
            IComQCEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 objid,
            /* [in] */ __RPC__in REFGUID guidMsgId,
            /* [in] */ __RPC__in REFGUID guidWorkFlowId,
            /* [in] */ HRESULT hr);
        
        END_INTERFACE
    } IComQCEventsVtbl;

    interface IComQCEvents
    {
        CONST_VTBL struct IComQCEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComQCEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComQCEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComQCEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComQCEvents_OnQCRecord(This,pInfo,objid,szQueue,guidMsgId,guidWorkFlowId,msmqhr)	\
    ( (This)->lpVtbl -> OnQCRecord(This,pInfo,objid,szQueue,guidMsgId,guidWorkFlowId,msmqhr) ) 

#define IComQCEvents_OnQCQueueOpen(This,pInfo,szQueue,QueueID,hr)	\
    ( (This)->lpVtbl -> OnQCQueueOpen(This,pInfo,szQueue,QueueID,hr) ) 

#define IComQCEvents_OnQCReceive(This,pInfo,QueueID,guidMsgId,guidWorkFlowId,hr)	\
    ( (This)->lpVtbl -> OnQCReceive(This,pInfo,QueueID,guidMsgId,guidWorkFlowId,hr) ) 

#define IComQCEvents_OnQCReceiveFail(This,pInfo,QueueID,msmqhr)	\
    ( (This)->lpVtbl -> OnQCReceiveFail(This,pInfo,QueueID,msmqhr) ) 

#define IComQCEvents_OnQCMoveToReTryQueue(This,pInfo,guidMsgId,guidWorkFlowId,RetryIndex)	\
    ( (This)->lpVtbl -> OnQCMoveToReTryQueue(This,pInfo,guidMsgId,guidWorkFlowId,RetryIndex) ) 

#define IComQCEvents_OnQCMoveToDeadQueue(This,pInfo,guidMsgId,guidWorkFlowId)	\
    ( (This)->lpVtbl -> OnQCMoveToDeadQueue(This,pInfo,guidMsgId,guidWorkFlowId) ) 

#define IComQCEvents_OnQCPlayback(This,pInfo,objid,guidMsgId,guidWorkFlowId,hr)	\
    ( (This)->lpVtbl -> OnQCPlayback(This,pInfo,objid,guidMsgId,guidWorkFlowId,hr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComQCEvents_INTERFACE_DEFINED__ */


#ifndef __IComExceptionEvents_INTERFACE_DEFINED__
#define __IComExceptionEvents_INTERFACE_DEFINED__

/* interface IComExceptionEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComExceptionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130B3-2E50-11d2-98A5-00C04F8EE1C4")
    IComExceptionEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnExceptionUser( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG code,
            /* [in] */ ULONG64 address,
            /* [in] */ __RPC__in LPCOLESTR pszStackTrace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComExceptionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComExceptionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComExceptionEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComExceptionEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnExceptionUser )( 
            IComExceptionEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG code,
            /* [in] */ ULONG64 address,
            /* [in] */ __RPC__in LPCOLESTR pszStackTrace);
        
        END_INTERFACE
    } IComExceptionEventsVtbl;

    interface IComExceptionEvents
    {
        CONST_VTBL struct IComExceptionEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComExceptionEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComExceptionEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComExceptionEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComExceptionEvents_OnExceptionUser(This,pInfo,code,address,pszStackTrace)	\
    ( (This)->lpVtbl -> OnExceptionUser(This,pInfo,code,address,pszStackTrace) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComExceptionEvents_INTERFACE_DEFINED__ */


#ifndef __IComCRMEvents_INTERFACE_DEFINED__
#define __IComCRMEvents_INTERFACE_DEFINED__

/* interface IComCRMEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComCRMEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("683130B5-2E50-11d2-98A5-00C04F8EE1C4")
    IComCRMEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCRMRecoveryStart( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMRecoveryDone( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMCheckpoint( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMBegin( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID,
            /* [in] */ GUID guidActivity,
            /* [in] */ GUID guidTx,
            /* [in] */ __RPC__in_ecount_full(64) WCHAR szProgIdCompensator[ 64 ],
            /* [in] */ __RPC__in_ecount_full(64) WCHAR szDescription[ 64 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMPrepare( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMCommit( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMAbort( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMIndoubt( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMDone( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMRelease( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMAnalyze( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID,
            /* [in] */ DWORD dwCrmRecordType,
            /* [in] */ DWORD dwRecordSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMWrite( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID,
            /* [in] */ BOOL fVariants,
            /* [in] */ DWORD dwRecordSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMForget( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMForce( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCRMDeliver( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID,
            /* [in] */ BOOL fVariants,
            /* [in] */ DWORD dwRecordSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCRMEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCRMEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCRMEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMRecoveryStart )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMRecoveryDone )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMCheckpoint )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMBegin )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID,
            /* [in] */ GUID guidActivity,
            /* [in] */ GUID guidTx,
            /* [in] */ __RPC__in_ecount_full(64) WCHAR szProgIdCompensator[ 64 ],
            /* [in] */ __RPC__in_ecount_full(64) WCHAR szDescription[ 64 ]);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMPrepare )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMCommit )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMAbort )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMIndoubt )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMDone )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMRelease )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMAnalyze )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID,
            /* [in] */ DWORD dwCrmRecordType,
            /* [in] */ DWORD dwRecordSize);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMWrite )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID,
            /* [in] */ BOOL fVariants,
            /* [in] */ DWORD dwRecordSize);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMForget )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMForce )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID);
        
        HRESULT ( STDMETHODCALLTYPE *OnCRMDeliver )( 
            IComCRMEvents * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidClerkCLSID,
            /* [in] */ BOOL fVariants,
            /* [in] */ DWORD dwRecordSize);
        
        END_INTERFACE
    } IComCRMEventsVtbl;

    interface IComCRMEvents
    {
        CONST_VTBL struct IComCRMEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCRMEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComCRMEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComCRMEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComCRMEvents_OnCRMRecoveryStart(This,pInfo,guidApp)	\
    ( (This)->lpVtbl -> OnCRMRecoveryStart(This,pInfo,guidApp) ) 

#define IComCRMEvents_OnCRMRecoveryDone(This,pInfo,guidApp)	\
    ( (This)->lpVtbl -> OnCRMRecoveryDone(This,pInfo,guidApp) ) 

#define IComCRMEvents_OnCRMCheckpoint(This,pInfo,guidApp)	\
    ( (This)->lpVtbl -> OnCRMCheckpoint(This,pInfo,guidApp) ) 

#define IComCRMEvents_OnCRMBegin(This,pInfo,guidClerkCLSID,guidActivity,guidTx,szProgIdCompensator,szDescription)	\
    ( (This)->lpVtbl -> OnCRMBegin(This,pInfo,guidClerkCLSID,guidActivity,guidTx,szProgIdCompensator,szDescription) ) 

#define IComCRMEvents_OnCRMPrepare(This,pInfo,guidClerkCLSID)	\
    ( (This)->lpVtbl -> OnCRMPrepare(This,pInfo,guidClerkCLSID) ) 

#define IComCRMEvents_OnCRMCommit(This,pInfo,guidClerkCLSID)	\
    ( (This)->lpVtbl -> OnCRMCommit(This,pInfo,guidClerkCLSID) ) 

#define IComCRMEvents_OnCRMAbort(This,pInfo,guidClerkCLSID)	\
    ( (This)->lpVtbl -> OnCRMAbort(This,pInfo,guidClerkCLSID) ) 

#define IComCRMEvents_OnCRMIndoubt(This,pInfo,guidClerkCLSID)	\
    ( (This)->lpVtbl -> OnCRMIndoubt(This,pInfo,guidClerkCLSID) ) 

#define IComCRMEvents_OnCRMDone(This,pInfo,guidClerkCLSID)	\
    ( (This)->lpVtbl -> OnCRMDone(This,pInfo,guidClerkCLSID) ) 

#define IComCRMEvents_OnCRMRelease(This,pInfo,guidClerkCLSID)	\
    ( (This)->lpVtbl -> OnCRMRelease(This,pInfo,guidClerkCLSID) ) 

#define IComCRMEvents_OnCRMAnalyze(This,pInfo,guidClerkCLSID,dwCrmRecordType,dwRecordSize)	\
    ( (This)->lpVtbl -> OnCRMAnalyze(This,pInfo,guidClerkCLSID,dwCrmRecordType,dwRecordSize) ) 

#define IComCRMEvents_OnCRMWrite(This,pInfo,guidClerkCLSID,fVariants,dwRecordSize)	\
    ( (This)->lpVtbl -> OnCRMWrite(This,pInfo,guidClerkCLSID,fVariants,dwRecordSize) ) 

#define IComCRMEvents_OnCRMForget(This,pInfo,guidClerkCLSID)	\
    ( (This)->lpVtbl -> OnCRMForget(This,pInfo,guidClerkCLSID) ) 

#define IComCRMEvents_OnCRMForce(This,pInfo,guidClerkCLSID)	\
    ( (This)->lpVtbl -> OnCRMForce(This,pInfo,guidClerkCLSID) ) 

#define IComCRMEvents_OnCRMDeliver(This,pInfo,guidClerkCLSID,fVariants,dwRecordSize)	\
    ( (This)->lpVtbl -> OnCRMDeliver(This,pInfo,guidClerkCLSID,fVariants,dwRecordSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComCRMEvents_INTERFACE_DEFINED__ */


#ifndef __IComMethod2Events_INTERFACE_DEFINED__
#define __IComMethod2Events_INTERFACE_DEFINED__

/* interface IComMethod2Events */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComMethod2Events;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FB388AAA-567D-4024-AF8E-6E93EE748573")
    IComMethod2Events : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnMethodCall2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ DWORD dwThread,
            /* [in] */ ULONG iMeth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMethodReturn2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ DWORD dwThread,
            /* [in] */ ULONG iMeth,
            /* [in] */ HRESULT hresult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMethodException2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ DWORD dwThread,
            /* [in] */ ULONG iMeth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComMethod2EventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComMethod2Events * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComMethod2Events * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComMethod2Events * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnMethodCall2 )( 
            IComMethod2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ DWORD dwThread,
            /* [in] */ ULONG iMeth);
        
        HRESULT ( STDMETHODCALLTYPE *OnMethodReturn2 )( 
            IComMethod2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ DWORD dwThread,
            /* [in] */ ULONG iMeth,
            /* [in] */ HRESULT hresult);
        
        HRESULT ( STDMETHODCALLTYPE *OnMethodException2 )( 
            IComMethod2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFCLSID guidCid,
            /* [in] */ __RPC__in REFIID guidRid,
            /* [in] */ DWORD dwThread,
            /* [in] */ ULONG iMeth);
        
        END_INTERFACE
    } IComMethod2EventsVtbl;

    interface IComMethod2Events
    {
        CONST_VTBL struct IComMethod2EventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComMethod2Events_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComMethod2Events_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComMethod2Events_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComMethod2Events_OnMethodCall2(This,pInfo,oid,guidCid,guidRid,dwThread,iMeth)	\
    ( (This)->lpVtbl -> OnMethodCall2(This,pInfo,oid,guidCid,guidRid,dwThread,iMeth) ) 

#define IComMethod2Events_OnMethodReturn2(This,pInfo,oid,guidCid,guidRid,dwThread,iMeth,hresult)	\
    ( (This)->lpVtbl -> OnMethodReturn2(This,pInfo,oid,guidCid,guidRid,dwThread,iMeth,hresult) ) 

#define IComMethod2Events_OnMethodException2(This,pInfo,oid,guidCid,guidRid,dwThread,iMeth)	\
    ( (This)->lpVtbl -> OnMethodException2(This,pInfo,oid,guidCid,guidRid,dwThread,iMeth) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComMethod2Events_INTERFACE_DEFINED__ */


#ifndef __IComTrackingInfoEvents_INTERFACE_DEFINED__
#define __IComTrackingInfoEvents_INTERFACE_DEFINED__

/* interface IComTrackingInfoEvents */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComTrackingInfoEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4e6cdcc9-fb25-4fd5-9cc5-c9f4b6559cec")
    IComTrackingInfoEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnNewTrackingInfo( 
            /* [in] */ __RPC__in_opt IUnknown *pToplevelCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComTrackingInfoEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComTrackingInfoEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComTrackingInfoEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComTrackingInfoEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnNewTrackingInfo )( 
            IComTrackingInfoEvents * This,
            /* [in] */ __RPC__in_opt IUnknown *pToplevelCollection);
        
        END_INTERFACE
    } IComTrackingInfoEventsVtbl;

    interface IComTrackingInfoEvents
    {
        CONST_VTBL struct IComTrackingInfoEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComTrackingInfoEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComTrackingInfoEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComTrackingInfoEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComTrackingInfoEvents_OnNewTrackingInfo(This,pToplevelCollection)	\
    ( (This)->lpVtbl -> OnNewTrackingInfo(This,pToplevelCollection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComTrackingInfoEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0033 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_autosvcs_0000_0033_0001
    {	TRKCOLL_PROCESSES	= 0,
	TRKCOLL_APPLICATIONS	= ( TRKCOLL_PROCESSES + 1 ) ,
	TRKCOLL_COMPONENTS	= ( TRKCOLL_APPLICATIONS + 1 ) 
    } 	TRACKING_COLL_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0033_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0033_v0_0_s_ifspec;

#ifndef __IComTrackingInfoCollection_INTERFACE_DEFINED__
#define __IComTrackingInfoCollection_INTERFACE_DEFINED__

/* interface IComTrackingInfoCollection */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComTrackingInfoCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c266c677-c9ad-49ab-9fd9-d9661078588a")
    IComTrackingInfoCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Type( 
            /* [out] */ __RPC__out TRACKING_COLL_TYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ __RPC__out ULONG *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComTrackingInfoCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComTrackingInfoCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComTrackingInfoCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComTrackingInfoCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Type )( 
            IComTrackingInfoCollection * This,
            /* [out] */ __RPC__out TRACKING_COLL_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IComTrackingInfoCollection * This,
            /* [out] */ __RPC__out ULONG *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IComTrackingInfoCollection * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IComTrackingInfoCollectionVtbl;

    interface IComTrackingInfoCollection
    {
        CONST_VTBL struct IComTrackingInfoCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComTrackingInfoCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComTrackingInfoCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComTrackingInfoCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComTrackingInfoCollection_Type(This,pType)	\
    ( (This)->lpVtbl -> Type(This,pType) ) 

#define IComTrackingInfoCollection_Count(This,pCount)	\
    ( (This)->lpVtbl -> Count(This,pCount) ) 

#define IComTrackingInfoCollection_Item(This,ulIndex,riid,ppv)	\
    ( (This)->lpVtbl -> Item(This,ulIndex,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComTrackingInfoCollection_INTERFACE_DEFINED__ */


#ifndef __IComTrackingInfoObject_INTERFACE_DEFINED__
#define __IComTrackingInfoObject_INTERFACE_DEFINED__

/* interface IComTrackingInfoObject */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComTrackingInfoObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("116e42c5-d8b1-47bf-ab1e-c895ed3e2372")
    IComTrackingInfoObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ __RPC__in LPOLESTR szPropertyName,
            /* [out] */ __RPC__out VARIANT *pvarOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComTrackingInfoObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComTrackingInfoObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComTrackingInfoObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComTrackingInfoObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IComTrackingInfoObject * This,
            /* [in] */ __RPC__in LPOLESTR szPropertyName,
            /* [out] */ __RPC__out VARIANT *pvarOut);
        
        END_INTERFACE
    } IComTrackingInfoObjectVtbl;

    interface IComTrackingInfoObject
    {
        CONST_VTBL struct IComTrackingInfoObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComTrackingInfoObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComTrackingInfoObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComTrackingInfoObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComTrackingInfoObject_GetValue(This,szPropertyName,pvarOut)	\
    ( (This)->lpVtbl -> GetValue(This,szPropertyName,pvarOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComTrackingInfoObject_INTERFACE_DEFINED__ */


#ifndef __IComTrackingInfoProperties_INTERFACE_DEFINED__
#define __IComTrackingInfoProperties_INTERFACE_DEFINED__

/* interface IComTrackingInfoProperties */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComTrackingInfoProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("789b42be-6f6b-443a-898e-67abf390aa14")
    IComTrackingInfoProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PropCount( 
            /* [out] */ __RPC__out ULONG *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropName( 
            /* [in] */ ULONG ulIndex,
            /* [string][out] */ __RPC__deref_out_opt_string LPOLESTR *ppszPropName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComTrackingInfoPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComTrackingInfoProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComTrackingInfoProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComTrackingInfoProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *PropCount )( 
            IComTrackingInfoProperties * This,
            /* [out] */ __RPC__out ULONG *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropName )( 
            IComTrackingInfoProperties * This,
            /* [in] */ ULONG ulIndex,
            /* [string][out] */ __RPC__deref_out_opt_string LPOLESTR *ppszPropName);
        
        END_INTERFACE
    } IComTrackingInfoPropertiesVtbl;

    interface IComTrackingInfoProperties
    {
        CONST_VTBL struct IComTrackingInfoPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComTrackingInfoProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComTrackingInfoProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComTrackingInfoProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComTrackingInfoProperties_PropCount(This,pCount)	\
    ( (This)->lpVtbl -> PropCount(This,pCount) ) 

#define IComTrackingInfoProperties_GetPropName(This,ulIndex,ppszPropName)	\
    ( (This)->lpVtbl -> GetPropName(This,ulIndex,ppszPropName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComTrackingInfoProperties_INTERFACE_DEFINED__ */


#ifndef __IComApp2Events_INTERFACE_DEFINED__
#define __IComApp2Events_INTERFACE_DEFINED__

/* interface IComApp2Events */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComApp2Events;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1290BC1A-B219-418d-B078-5934DED08242")
    IComApp2Events : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnAppActivation2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp,
            /* [in] */ GUID guidProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAppShutdown2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAppForceShutdown2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAppPaused2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp,
            /* [in] */ BOOL bPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAppRecycle2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp,
            /* [in] */ GUID guidProcess,
            /* [in] */ long lReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComApp2EventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComApp2Events * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComApp2Events * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComApp2Events * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnAppActivation2 )( 
            IComApp2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp,
            /* [in] */ GUID guidProcess);
        
        HRESULT ( STDMETHODCALLTYPE *OnAppShutdown2 )( 
            IComApp2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp);
        
        HRESULT ( STDMETHODCALLTYPE *OnAppForceShutdown2 )( 
            IComApp2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp);
        
        HRESULT ( STDMETHODCALLTYPE *OnAppPaused2 )( 
            IComApp2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp,
            /* [in] */ BOOL bPaused);
        
        HRESULT ( STDMETHODCALLTYPE *OnAppRecycle2 )( 
            IComApp2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ GUID guidApp,
            /* [in] */ GUID guidProcess,
            /* [in] */ long lReason);
        
        END_INTERFACE
    } IComApp2EventsVtbl;

    interface IComApp2Events
    {
        CONST_VTBL struct IComApp2EventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComApp2Events_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComApp2Events_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComApp2Events_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComApp2Events_OnAppActivation2(This,pInfo,guidApp,guidProcess)	\
    ( (This)->lpVtbl -> OnAppActivation2(This,pInfo,guidApp,guidProcess) ) 

#define IComApp2Events_OnAppShutdown2(This,pInfo,guidApp)	\
    ( (This)->lpVtbl -> OnAppShutdown2(This,pInfo,guidApp) ) 

#define IComApp2Events_OnAppForceShutdown2(This,pInfo,guidApp)	\
    ( (This)->lpVtbl -> OnAppForceShutdown2(This,pInfo,guidApp) ) 

#define IComApp2Events_OnAppPaused2(This,pInfo,guidApp,bPaused)	\
    ( (This)->lpVtbl -> OnAppPaused2(This,pInfo,guidApp,bPaused) ) 

#define IComApp2Events_OnAppRecycle2(This,pInfo,guidApp,guidProcess,lReason)	\
    ( (This)->lpVtbl -> OnAppRecycle2(This,pInfo,guidApp,guidProcess,lReason) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComApp2Events_INTERFACE_DEFINED__ */


#ifndef __IComTransaction2Events_INTERFACE_DEFINED__
#define __IComTransaction2Events_INTERFACE_DEFINED__

/* interface IComTransaction2Events */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComTransaction2Events;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A136F62A-2F94-4288-86E0-D8A1FA4C0299")
    IComTransaction2Events : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnTransactionStart2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ __RPC__in REFGUID tsid,
            /* [in] */ BOOL fRoot,
            /* [in] */ int nIsolationLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTransactionPrepare2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ BOOL fVoteYes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTransactionAbort2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTransactionCommit2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComTransaction2EventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComTransaction2Events * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComTransaction2Events * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComTransaction2Events * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTransactionStart2 )( 
            IComTransaction2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ __RPC__in REFGUID tsid,
            /* [in] */ BOOL fRoot,
            /* [in] */ int nIsolationLevel);
        
        HRESULT ( STDMETHODCALLTYPE *OnTransactionPrepare2 )( 
            IComTransaction2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ BOOL fVoteYes);
        
        HRESULT ( STDMETHODCALLTYPE *OnTransactionAbort2 )( 
            IComTransaction2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx);
        
        HRESULT ( STDMETHODCALLTYPE *OnTransactionCommit2 )( 
            IComTransaction2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidTx);
        
        END_INTERFACE
    } IComTransaction2EventsVtbl;

    interface IComTransaction2Events
    {
        CONST_VTBL struct IComTransaction2EventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComTransaction2Events_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComTransaction2Events_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComTransaction2Events_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComTransaction2Events_OnTransactionStart2(This,pInfo,guidTx,tsid,fRoot,nIsolationLevel)	\
    ( (This)->lpVtbl -> OnTransactionStart2(This,pInfo,guidTx,tsid,fRoot,nIsolationLevel) ) 

#define IComTransaction2Events_OnTransactionPrepare2(This,pInfo,guidTx,fVoteYes)	\
    ( (This)->lpVtbl -> OnTransactionPrepare2(This,pInfo,guidTx,fVoteYes) ) 

#define IComTransaction2Events_OnTransactionAbort2(This,pInfo,guidTx)	\
    ( (This)->lpVtbl -> OnTransactionAbort2(This,pInfo,guidTx) ) 

#define IComTransaction2Events_OnTransactionCommit2(This,pInfo,guidTx)	\
    ( (This)->lpVtbl -> OnTransactionCommit2(This,pInfo,guidTx) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComTransaction2Events_INTERFACE_DEFINED__ */


#ifndef __IComInstance2Events_INTERFACE_DEFINED__
#define __IComInstance2Events_INTERFACE_DEFINED__

/* interface IComInstance2Events */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComInstance2Events;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20E3BF07-B506-4ad5-A50C-D2CA5B9C158E")
    IComInstance2Events : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjectCreate2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ __RPC__in REFCLSID clsid,
            /* [in] */ __RPC__in REFGUID tsid,
            /* [in] */ ULONG64 CtxtID,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ __RPC__in REFGUID guidPartition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjectDestroy2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComInstance2EventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComInstance2Events * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComInstance2Events * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComInstance2Events * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectCreate2 )( 
            IComInstance2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ __RPC__in REFCLSID clsid,
            /* [in] */ __RPC__in REFGUID tsid,
            /* [in] */ ULONG64 CtxtID,
            /* [in] */ ULONG64 ObjectID,
            /* [in] */ __RPC__in REFGUID guidPartition);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectDestroy2 )( 
            IComInstance2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ ULONG64 CtxtID);
        
        END_INTERFACE
    } IComInstance2EventsVtbl;

    interface IComInstance2Events
    {
        CONST_VTBL struct IComInstance2EventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComInstance2Events_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComInstance2Events_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComInstance2Events_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComInstance2Events_OnObjectCreate2(This,pInfo,guidActivity,clsid,tsid,CtxtID,ObjectID,guidPartition)	\
    ( (This)->lpVtbl -> OnObjectCreate2(This,pInfo,guidActivity,clsid,tsid,CtxtID,ObjectID,guidPartition) ) 

#define IComInstance2Events_OnObjectDestroy2(This,pInfo,CtxtID)	\
    ( (This)->lpVtbl -> OnObjectDestroy2(This,pInfo,CtxtID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComInstance2Events_INTERFACE_DEFINED__ */


#ifndef __IComObjectPool2Events_INTERFACE_DEFINED__
#define __IComObjectPool2Events_INTERFACE_DEFINED__

/* interface IComObjectPool2Events */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComObjectPool2Events;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65BF6534-85EA-4f64-8CF4-3D974B2AB1CF")
    IComObjectPool2Events : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolPutObject2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ int nReason,
            /* [in] */ DWORD dwAvailable,
            /* [in] */ ULONG64 oid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolGetObject2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ DWORD dwAvailable,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFGUID guidPartition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolRecycleToTx2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ ULONG64 objid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjPoolGetFromTx2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ ULONG64 objid,
            /* [in] */ __RPC__in REFGUID guidPartition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComObjectPool2EventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComObjectPool2Events * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComObjectPool2Events * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComObjectPool2Events * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolPutObject2 )( 
            IComObjectPool2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ int nReason,
            /* [in] */ DWORD dwAvailable,
            /* [in] */ ULONG64 oid);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolGetObject2 )( 
            IComObjectPool2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ DWORD dwAvailable,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFGUID guidPartition);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolRecycleToTx2 )( 
            IComObjectPool2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ ULONG64 objid);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjPoolGetFromTx2 )( 
            IComObjectPool2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidActivity,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in REFGUID guidTx,
            /* [in] */ ULONG64 objid,
            /* [in] */ __RPC__in REFGUID guidPartition);
        
        END_INTERFACE
    } IComObjectPool2EventsVtbl;

    interface IComObjectPool2Events
    {
        CONST_VTBL struct IComObjectPool2EventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComObjectPool2Events_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComObjectPool2Events_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComObjectPool2Events_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComObjectPool2Events_OnObjPoolPutObject2(This,pInfo,guidObject,nReason,dwAvailable,oid)	\
    ( (This)->lpVtbl -> OnObjPoolPutObject2(This,pInfo,guidObject,nReason,dwAvailable,oid) ) 

#define IComObjectPool2Events_OnObjPoolGetObject2(This,pInfo,guidActivity,guidObject,dwAvailable,oid,guidPartition)	\
    ( (This)->lpVtbl -> OnObjPoolGetObject2(This,pInfo,guidActivity,guidObject,dwAvailable,oid,guidPartition) ) 

#define IComObjectPool2Events_OnObjPoolRecycleToTx2(This,pInfo,guidActivity,guidObject,guidTx,objid)	\
    ( (This)->lpVtbl -> OnObjPoolRecycleToTx2(This,pInfo,guidActivity,guidObject,guidTx,objid) ) 

#define IComObjectPool2Events_OnObjPoolGetFromTx2(This,pInfo,guidActivity,guidObject,guidTx,objid,guidPartition)	\
    ( (This)->lpVtbl -> OnObjPoolGetFromTx2(This,pInfo,guidActivity,guidObject,guidTx,objid,guidPartition) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComObjectPool2Events_INTERFACE_DEFINED__ */


#ifndef __IComObjectConstruction2Events_INTERFACE_DEFINED__
#define __IComObjectConstruction2Events_INTERFACE_DEFINED__

/* interface IComObjectConstruction2Events */
/* [uuid][hidden][object] */ 


EXTERN_C const IID IID_IComObjectConstruction2Events;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4B5A7827-8DF2-45c0-8F6F-57EA1F856A9F")
    IComObjectConstruction2Events : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjectConstruct2( 
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in LPCOLESTR sConstructString,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFGUID guidPartition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComObjectConstruction2EventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComObjectConstruction2Events * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComObjectConstruction2Events * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComObjectConstruction2Events * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectConstruct2 )( 
            IComObjectConstruction2Events * This,
            /* [in] */ __RPC__in COMSVCSEVENTINFO *pInfo,
            /* [in] */ __RPC__in REFGUID guidObject,
            /* [in] */ __RPC__in LPCOLESTR sConstructString,
            /* [in] */ ULONG64 oid,
            /* [in] */ __RPC__in REFGUID guidPartition);
        
        END_INTERFACE
    } IComObjectConstruction2EventsVtbl;

    interface IComObjectConstruction2Events
    {
        CONST_VTBL struct IComObjectConstruction2EventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComObjectConstruction2Events_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComObjectConstruction2Events_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComObjectConstruction2Events_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComObjectConstruction2Events_OnObjectConstruct2(This,pInfo,guidObject,sConstructString,oid,guidPartition)	\
    ( (This)->lpVtbl -> OnObjectConstruct2(This,pInfo,guidObject,sConstructString,oid,guidPartition) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComObjectConstruction2Events_INTERFACE_DEFINED__ */


#ifndef __ISystemAppEventData_INTERFACE_DEFINED__
#define __ISystemAppEventData_INTERFACE_DEFINED__

/* interface ISystemAppEventData */
/* [unique][uuid][hidden][object] */ 


EXTERN_C const IID IID_ISystemAppEventData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6D48A3C-D5C5-49E7-8C74-99E4889ED52F")
    ISystemAppEventData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Startup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataChanged( 
            /* [in] */ DWORD dwPID,
            /* [in] */ DWORD dwMask,
            /* [in] */ DWORD dwNumberSinks,
            /* [in] */ __RPC__in BSTR bstrDwMethodMask,
            /* [in] */ DWORD dwReason,
            /* [in] */ ULONG64 u64TraceHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemAppEventDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISystemAppEventData * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISystemAppEventData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISystemAppEventData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Startup )( 
            ISystemAppEventData * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataChanged )( 
            ISystemAppEventData * This,
            /* [in] */ DWORD dwPID,
            /* [in] */ DWORD dwMask,
            /* [in] */ DWORD dwNumberSinks,
            /* [in] */ __RPC__in BSTR bstrDwMethodMask,
            /* [in] */ DWORD dwReason,
            /* [in] */ ULONG64 u64TraceHandle);
        
        END_INTERFACE
    } ISystemAppEventDataVtbl;

    interface ISystemAppEventData
    {
        CONST_VTBL struct ISystemAppEventDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemAppEventData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISystemAppEventData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISystemAppEventData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISystemAppEventData_Startup(This)	\
    ( (This)->lpVtbl -> Startup(This) ) 

#define ISystemAppEventData_OnDataChanged(This,dwPID,dwMask,dwNumberSinks,bstrDwMethodMask,dwReason,u64TraceHandle)	\
    ( (This)->lpVtbl -> OnDataChanged(This,dwPID,dwMask,dwNumberSinks,bstrDwMethodMask,dwReason,u64TraceHandle) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISystemAppEventData_INTERFACE_DEFINED__ */


#ifndef __IMtsEvents_INTERFACE_DEFINED__
#define __IMtsEvents_INTERFACE_DEFINED__

/* interface IMtsEvents */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMtsEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BACEDF4D-74AB-11D0-B162-00AA00BA3258")
    IMtsEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PackageName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PackageGuid( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PostEvent( 
            /* [in] */ __RPC__in VARIANT *vEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FireEvents( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProcessID( 
            /* [retval][out] */ __RPC__out long *id) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMtsEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMtsEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMtsEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMtsEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMtsEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMtsEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMtsEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PackageName )( 
            IMtsEvents * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PackageGuid )( 
            IMtsEvents * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PostEvent )( 
            IMtsEvents * This,
            /* [in] */ __RPC__in VARIANT *vEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FireEvents )( 
            IMtsEvents * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProcessID )( 
            IMtsEvents * This,
            /* [retval][out] */ __RPC__out long *id);
        
        END_INTERFACE
    } IMtsEventsVtbl;

    interface IMtsEvents
    {
        CONST_VTBL struct IMtsEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMtsEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMtsEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMtsEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMtsEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMtsEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMtsEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMtsEvents_get_PackageName(This,pVal)	\
    ( (This)->lpVtbl -> get_PackageName(This,pVal) ) 

#define IMtsEvents_get_PackageGuid(This,pVal)	\
    ( (This)->lpVtbl -> get_PackageGuid(This,pVal) ) 

#define IMtsEvents_PostEvent(This,vEvent)	\
    ( (This)->lpVtbl -> PostEvent(This,vEvent) ) 

#define IMtsEvents_get_FireEvents(This,pVal)	\
    ( (This)->lpVtbl -> get_FireEvents(This,pVal) ) 

#define IMtsEvents_GetProcessID(This,id)	\
    ( (This)->lpVtbl -> GetProcessID(This,id) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMtsEvents_INTERFACE_DEFINED__ */


#ifndef __IMtsEventInfo_INTERFACE_DEFINED__
#define __IMtsEventInfo_INTERFACE_DEFINED__

/* interface IMtsEventInfo */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMtsEventInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D56C3DC1-8482-11d0-B170-00AA00BA3258")
    IMtsEventInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Names( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pUnk) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *sDisplayName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EventID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *sGuidEventID) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *lCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ __RPC__in BSTR sKey,
            /* [retval][out] */ __RPC__out VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsEventInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMtsEventInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMtsEventInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMtsEventInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMtsEventInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMtsEventInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMtsEventInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMtsEventInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Names )( 
            IMtsEventInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pUnk);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IMtsEventInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *sDisplayName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventID )( 
            IMtsEventInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *sGuidEventID);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IMtsEventInfo * This,
            /* [retval][out] */ __RPC__out long *lCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IMtsEventInfo * This,
            /* [in] */ __RPC__in BSTR sKey,
            /* [retval][out] */ __RPC__out VARIANT *pVal);
        
        END_INTERFACE
    } IMtsEventInfoVtbl;

    interface IMtsEventInfo
    {
        CONST_VTBL struct IMtsEventInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsEventInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMtsEventInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMtsEventInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMtsEventInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMtsEventInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMtsEventInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMtsEventInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMtsEventInfo_get_Names(This,pUnk)	\
    ( (This)->lpVtbl -> get_Names(This,pUnk) ) 

#define IMtsEventInfo_get_DisplayName(This,sDisplayName)	\
    ( (This)->lpVtbl -> get_DisplayName(This,sDisplayName) ) 

#define IMtsEventInfo_get_EventID(This,sGuidEventID)	\
    ( (This)->lpVtbl -> get_EventID(This,sGuidEventID) ) 

#define IMtsEventInfo_get_Count(This,lCount)	\
    ( (This)->lpVtbl -> get_Count(This,lCount) ) 

#define IMtsEventInfo_get_Value(This,sKey,pVal)	\
    ( (This)->lpVtbl -> get_Value(This,sKey,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMtsEventInfo_INTERFACE_DEFINED__ */


#ifndef __IMTSLocator_INTERFACE_DEFINED__
#define __IMTSLocator_INTERFACE_DEFINED__

/* interface IMTSLocator */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMTSLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D19B8BFD-7F88-11D0-B16E-00AA00BA3258")
    IMTSLocator : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEventDispatcher( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMTSLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMTSLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMTSLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMTSLocator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMTSLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMTSLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMTSLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEventDispatcher )( 
            IMTSLocator * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pUnk);
        
        END_INTERFACE
    } IMTSLocatorVtbl;

    interface IMTSLocator
    {
        CONST_VTBL struct IMTSLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSLocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMTSLocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMTSLocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMTSLocator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMTSLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMTSLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMTSLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMTSLocator_GetEventDispatcher(This,pUnk)	\
    ( (This)->lpVtbl -> GetEventDispatcher(This,pUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMTSLocator_INTERFACE_DEFINED__ */


#ifndef __IMtsGrp_INTERFACE_DEFINED__
#define __IMtsGrp_INTERFACE_DEFINED__

/* interface IMtsGrp */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMtsGrp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4B2E958C-0393-11D1-B1AB-00AA00BA3258")
    IMtsGrp : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long lIndex,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnkDispatcher) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsGrpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMtsGrp * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMtsGrp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMtsGrp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMtsGrp * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMtsGrp * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMtsGrp * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMtsGrp * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IMtsGrp * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IMtsGrp * This,
            /* [in] */ long lIndex,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnkDispatcher);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IMtsGrp * This);
        
        END_INTERFACE
    } IMtsGrpVtbl;

    interface IMtsGrp
    {
        CONST_VTBL struct IMtsGrpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsGrp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMtsGrp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMtsGrp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMtsGrp_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMtsGrp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMtsGrp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMtsGrp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMtsGrp_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define IMtsGrp_Item(This,lIndex,ppUnkDispatcher)	\
    ( (This)->lpVtbl -> Item(This,lIndex,ppUnkDispatcher) ) 

#define IMtsGrp_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMtsGrp_INTERFACE_DEFINED__ */


#ifndef __IMessageMover_INTERFACE_DEFINED__
#define __IMessageMover_INTERFACE_DEFINED__

/* interface IMessageMover */
/* [unique][dual][nonextensible][oleautomation][hidden][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IMessageMover;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("588A085A-B795-11D1-8054-00C04FC340EE")
    IMessageMover : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SourcePath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SourcePath( 
            /* [in] */ __RPC__in BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DestPath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DestPath( 
            /* [in] */ __RPC__in BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CommitBatchSize( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_CommitBatchSize( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveMessages( 
            /* [retval][out] */ __RPC__out long *plMessagesMoved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessageMoverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMessageMover * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMessageMover * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMessageMover * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMessageMover * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMessageMover * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMessageMover * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMessageMover * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourcePath )( 
            IMessageMover * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourcePath )( 
            IMessageMover * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestPath )( 
            IMessageMover * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestPath )( 
            IMessageMover * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CommitBatchSize )( 
            IMessageMover * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CommitBatchSize )( 
            IMessageMover * This,
            /* [in] */ long newVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *MoveMessages )( 
            IMessageMover * This,
            /* [retval][out] */ __RPC__out long *plMessagesMoved);
        
        END_INTERFACE
    } IMessageMoverVtbl;

    interface IMessageMover
    {
        CONST_VTBL struct IMessageMoverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessageMover_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMessageMover_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMessageMover_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMessageMover_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMessageMover_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMessageMover_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMessageMover_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMessageMover_get_SourcePath(This,pVal)	\
    ( (This)->lpVtbl -> get_SourcePath(This,pVal) ) 

#define IMessageMover_put_SourcePath(This,newVal)	\
    ( (This)->lpVtbl -> put_SourcePath(This,newVal) ) 

#define IMessageMover_get_DestPath(This,pVal)	\
    ( (This)->lpVtbl -> get_DestPath(This,pVal) ) 

#define IMessageMover_put_DestPath(This,newVal)	\
    ( (This)->lpVtbl -> put_DestPath(This,newVal) ) 

#define IMessageMover_get_CommitBatchSize(This,pVal)	\
    ( (This)->lpVtbl -> get_CommitBatchSize(This,pVal) ) 

#define IMessageMover_put_CommitBatchSize(This,newVal)	\
    ( (This)->lpVtbl -> put_CommitBatchSize(This,newVal) ) 

#define IMessageMover_MoveMessages(This,plMessagesMoved)	\
    ( (This)->lpVtbl -> MoveMessages(This,plMessagesMoved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMessageMover_INTERFACE_DEFINED__ */


#ifndef __IEventServerTrace_INTERFACE_DEFINED__
#define __IEventServerTrace_INTERFACE_DEFINED__

/* interface IEventServerTrace */
/* [object][unique][helpstring][dual][uuid] */ 


EXTERN_C const IID IID_IEventServerTrace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A9F12B8-80AF-47ab-A579-35EA57725370")
    IEventServerTrace : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartTraceGuid( 
            /* [in] */ __RPC__in BSTR bstrguidEvent,
            /* [in] */ __RPC__in BSTR bstrguidFilter,
            /* [in] */ LONG lPidFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopTraceGuid( 
            /* [in] */ __RPC__in BSTR bstrguidEvent,
            /* [in] */ __RPC__in BSTR bstrguidFilter,
            /* [in] */ LONG lPidFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumTraceGuid( 
            /* [out] */ __RPC__out LONG *plCntGuids,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrGuidList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventServerTraceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEventServerTrace * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEventServerTrace * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEventServerTrace * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEventServerTrace * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEventServerTrace * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEventServerTrace * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEventServerTrace * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartTraceGuid )( 
            IEventServerTrace * This,
            /* [in] */ __RPC__in BSTR bstrguidEvent,
            /* [in] */ __RPC__in BSTR bstrguidFilter,
            /* [in] */ LONG lPidFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopTraceGuid )( 
            IEventServerTrace * This,
            /* [in] */ __RPC__in BSTR bstrguidEvent,
            /* [in] */ __RPC__in BSTR bstrguidFilter,
            /* [in] */ LONG lPidFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumTraceGuid )( 
            IEventServerTrace * This,
            /* [out] */ __RPC__out LONG *plCntGuids,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrGuidList);
        
        END_INTERFACE
    } IEventServerTraceVtbl;

    interface IEventServerTrace
    {
        CONST_VTBL struct IEventServerTraceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventServerTrace_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEventServerTrace_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEventServerTrace_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEventServerTrace_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IEventServerTrace_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IEventServerTrace_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IEventServerTrace_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IEventServerTrace_StartTraceGuid(This,bstrguidEvent,bstrguidFilter,lPidFilter)	\
    ( (This)->lpVtbl -> StartTraceGuid(This,bstrguidEvent,bstrguidFilter,lPidFilter) ) 

#define IEventServerTrace_StopTraceGuid(This,bstrguidEvent,bstrguidFilter,lPidFilter)	\
    ( (This)->lpVtbl -> StopTraceGuid(This,bstrguidEvent,bstrguidFilter,lPidFilter) ) 

#define IEventServerTrace_EnumTraceGuid(This,plCntGuids,pbstrGuidList)	\
    ( (This)->lpVtbl -> EnumTraceGuid(This,plCntGuids,pbstrGuidList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEventServerTrace_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0048 */
/* [local] */ 

typedef /* [hidden] */ struct _RECYCLE_INFO
    {
    GUID guidCombaseProcessIdentifier;
    LONGLONG ProcessStartTime;
    DWORD dwRecycleLifetimeLimit;
    DWORD dwRecycleMemoryLimit;
    DWORD dwRecycleExpirationTimeout;
    } 	RECYCLE_INFO;

typedef /* [hidden] */ 
enum tagDUMPTYPE
    {	DUMPTYPE_FULL	= 0,
	DUMPTYPE_MINI	= ( DUMPTYPE_FULL + 1 ) ,
	DUMPTYPE_NONE	= ( DUMPTYPE_MINI + 1 ) 
    } 	DUMPTYPE;

typedef /* [hidden] */ struct _HANG_INFO
    {
    BOOL fAppHangMonitorEnabled;
    BOOL fTerminateOnHang;
    DUMPTYPE DumpType;
    DWORD dwHangTimeout;
    DWORD dwDumpCount;
    DWORD dwInfoMsgCount;
    } 	HANG_INFO;

typedef 
enum tagCOMPLUS_APPTYPE
    {	APPTYPE_UNKNOWN	= 0xffffffff,
	APPTYPE_SERVER	= 1,
	APPTYPE_LIBRARY	= 0,
	APPTYPE_SWC	= 2
    } 	COMPLUS_APPTYPE;



//
// Definition of global named event used to control starting and 
// stopping of tracker push data.
//
#define TRACKER_STARTSTOP_EVENT L"Global\\COM+ Tracker Push Event"


//
// Definition of global named event used to signal when the 
// system application has been restarted
//
#define TRACKER_INIT_EVENT L"Global\\COM+ Tracker Init Event"


#ifndef GUID_STRING_SIZE
#define GUID_STRING_SIZE				40	    // a couple over.
#endif
typedef /* [hidden] */ struct CAppStatistics
    {
    DWORD m_cTotalCalls;
    DWORD m_cTotalInstances;
    DWORD m_cTotalClasses;
    DWORD m_cCallsPerSecond;
    } 	APPSTATISTICS;

typedef /* [hidden] */ struct CAppData
    {
    DWORD m_idApp;
    WCHAR m_szAppGuid[ 40 ];
    DWORD m_dwAppProcessId;
    APPSTATISTICS m_AppStatistics;
    } 	APPDATA;

typedef /* [hidden] */ struct CCLSIDData
    {
    CLSID m_clsid;
    DWORD m_cReferences;
    DWORD m_cBound;
    DWORD m_cPooled;
    DWORD m_cInCall;
    DWORD m_dwRespTime;
    DWORD m_cCallsCompleted;
    DWORD m_cCallsFailed;
    } 	CLSIDDATA;

typedef /* [hidden] */ struct CCLSIDData2
    {
    CLSID m_clsid;
    GUID m_appid;
    GUID m_partid;
    WCHAR *m_pwszAppName;
    WCHAR *m_pwszCtxName;
    COMPLUS_APPTYPE m_eAppType;
    DWORD m_cReferences;
    DWORD m_cBound;
    DWORD m_cPooled;
    DWORD m_cInCall;
    DWORD m_dwRespTime;
    DWORD m_cCallsCompleted;
    DWORD m_cCallsFailed;
    } 	CLSIDDATA2;

//
// Dispenser Manager interfaces
//
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 
#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
typedef DWORD_PTR RESTYPID;

typedef DWORD_PTR RESID;

typedef LPOLESTR SRESID;

typedef LPCOLESTR constSRESID;

typedef DWORD RESOURCERATING;

typedef long TIMEINSECS;

typedef DWORD_PTR INSTID;

typedef DWORD_PTR TRANSID;



//
// Error Codes
//
#define MTXDM_E_ENLISTRESOURCEFAILED 0x8004E100 // return from EnlistResource, is then returned by AllocResource
 
//
// IDispenserManager
// Implemented by Dispenser Manager, called by all Dispensers.
//


extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0048_v0_0_s_ifspec;

#ifndef __IDispenserManager_INTERFACE_DEFINED__
#define __IDispenserManager_INTERFACE_DEFINED__

/* interface IDispenserManager */
/* [unique][hidden][local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDispenserManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5cb31e10-2b5f-11cf-be10-00aa00a2fa25")
    IDispenserManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterDispenser( 
            /* [in] */ IDispenserDriver *__MIDL__IDispenserManager0000,
            /* [in] */ LPCOLESTR szDispenserName,
            /* [out] */ IHolder **__MIDL__IDispenserManager0001) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ INSTID *__MIDL__IDispenserManager0002,
            /* [out] */ TRANSID *__MIDL__IDispenserManager0003) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispenserManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDispenserManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDispenserManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDispenserManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterDispenser )( 
            IDispenserManager * This,
            /* [in] */ IDispenserDriver *__MIDL__IDispenserManager0000,
            /* [in] */ LPCOLESTR szDispenserName,
            /* [out] */ IHolder **__MIDL__IDispenserManager0001);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IDispenserManager * This,
            /* [out] */ INSTID *__MIDL__IDispenserManager0002,
            /* [out] */ TRANSID *__MIDL__IDispenserManager0003);
        
        END_INTERFACE
    } IDispenserManagerVtbl;

    interface IDispenserManager
    {
        CONST_VTBL struct IDispenserManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispenserManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDispenserManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDispenserManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDispenserManager_RegisterDispenser(This,__MIDL__IDispenserManager0000,szDispenserName,__MIDL__IDispenserManager0001)	\
    ( (This)->lpVtbl -> RegisterDispenser(This,__MIDL__IDispenserManager0000,szDispenserName,__MIDL__IDispenserManager0001) ) 

#define IDispenserManager_GetContext(This,__MIDL__IDispenserManager0002,__MIDL__IDispenserManager0003)	\
    ( (This)->lpVtbl -> GetContext(This,__MIDL__IDispenserManager0002,__MIDL__IDispenserManager0003) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDispenserManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0049 */
/* [local] */ 

//
// IHolder
// Implemented by Dispenser Manager, called by one Dispenser.
//


extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0049_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0049_v0_0_s_ifspec;

#ifndef __IHolder_INTERFACE_DEFINED__
#define __IHolder_INTERFACE_DEFINED__

/* interface IHolder */
/* [unique][hidden][local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bf6a1850-2b45-11cf-be10-00aa00a2fa25")
    IHolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocResource( 
            /* [in] */ const RESTYPID __MIDL__IHolder0000,
            /* [out] */ RESID *__MIDL__IHolder0001) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeResource( 
            /* [in] */ const RESID __MIDL__IHolder0002) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TrackResource( 
            /* [in] */ const RESID __MIDL__IHolder0003) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TrackResourceS( 
            /* [in] */ constSRESID __MIDL__IHolder0004) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UntrackResource( 
            /* [in] */ const RESID __MIDL__IHolder0005,
            /* [in] */ const BOOL __MIDL__IHolder0006) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UntrackResourceS( 
            /* [in] */ constSRESID __MIDL__IHolder0007,
            /* [in] */ const BOOL __MIDL__IHolder0008) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestDestroyResource( 
            /* [in] */ const RESID __MIDL__IHolder0009) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHolder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllocResource )( 
            IHolder * This,
            /* [in] */ const RESTYPID __MIDL__IHolder0000,
            /* [out] */ RESID *__MIDL__IHolder0001);
        
        HRESULT ( STDMETHODCALLTYPE *FreeResource )( 
            IHolder * This,
            /* [in] */ const RESID __MIDL__IHolder0002);
        
        HRESULT ( STDMETHODCALLTYPE *TrackResource )( 
            IHolder * This,
            /* [in] */ const RESID __MIDL__IHolder0003);
        
        HRESULT ( STDMETHODCALLTYPE *TrackResourceS )( 
            IHolder * This,
            /* [in] */ constSRESID __MIDL__IHolder0004);
        
        HRESULT ( STDMETHODCALLTYPE *UntrackResource )( 
            IHolder * This,
            /* [in] */ const RESID __MIDL__IHolder0005,
            /* [in] */ const BOOL __MIDL__IHolder0006);
        
        HRESULT ( STDMETHODCALLTYPE *UntrackResourceS )( 
            IHolder * This,
            /* [in] */ constSRESID __MIDL__IHolder0007,
            /* [in] */ const BOOL __MIDL__IHolder0008);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IHolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestDestroyResource )( 
            IHolder * This,
            /* [in] */ const RESID __MIDL__IHolder0009);
        
        END_INTERFACE
    } IHolderVtbl;

    interface IHolder
    {
        CONST_VTBL struct IHolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHolder_AllocResource(This,__MIDL__IHolder0000,__MIDL__IHolder0001)	\
    ( (This)->lpVtbl -> AllocResource(This,__MIDL__IHolder0000,__MIDL__IHolder0001) ) 

#define IHolder_FreeResource(This,__MIDL__IHolder0002)	\
    ( (This)->lpVtbl -> FreeResource(This,__MIDL__IHolder0002) ) 

#define IHolder_TrackResource(This,__MIDL__IHolder0003)	\
    ( (This)->lpVtbl -> TrackResource(This,__MIDL__IHolder0003) ) 

#define IHolder_TrackResourceS(This,__MIDL__IHolder0004)	\
    ( (This)->lpVtbl -> TrackResourceS(This,__MIDL__IHolder0004) ) 

#define IHolder_UntrackResource(This,__MIDL__IHolder0005,__MIDL__IHolder0006)	\
    ( (This)->lpVtbl -> UntrackResource(This,__MIDL__IHolder0005,__MIDL__IHolder0006) ) 

#define IHolder_UntrackResourceS(This,__MIDL__IHolder0007,__MIDL__IHolder0008)	\
    ( (This)->lpVtbl -> UntrackResourceS(This,__MIDL__IHolder0007,__MIDL__IHolder0008) ) 

#define IHolder_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IHolder_RequestDestroyResource(This,__MIDL__IHolder0009)	\
    ( (This)->lpVtbl -> RequestDestroyResource(This,__MIDL__IHolder0009) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0050 */
/* [local] */ 

//
// IDispenserDriver
// Implemented by a Dispenser, called by Dispenser Manager.
//


extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0050_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0050_v0_0_s_ifspec;

#ifndef __IDispenserDriver_INTERFACE_DEFINED__
#define __IDispenserDriver_INTERFACE_DEFINED__

/* interface IDispenserDriver */
/* [unique][hidden][local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDispenserDriver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("208b3651-2b48-11cf-be10-00aa00a2fa25")
    IDispenserDriver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateResource( 
            /* [in] */ const RESTYPID ResTypId,
            /* [out] */ RESID *pResId,
            /* [out] */ TIMEINSECS *pSecsFreeBeforeDestroy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RateResource( 
            /* [in] */ const RESTYPID ResTypId,
            /* [in] */ const RESID ResId,
            /* [in] */ const BOOL fRequiresTransactionEnlistment,
            /* [out] */ RESOURCERATING *pRating) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnlistResource( 
            /* [in] */ const RESID ResId,
            /* [in] */ const TRANSID TransId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetResource( 
            /* [in] */ const RESID ResId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyResource( 
            /* [in] */ const RESID ResId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyResourceS( 
            /* [in] */ constSRESID ResId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispenserDriverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDispenserDriver * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDispenserDriver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDispenserDriver * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateResource )( 
            IDispenserDriver * This,
            /* [in] */ const RESTYPID ResTypId,
            /* [out] */ RESID *pResId,
            /* [out] */ TIMEINSECS *pSecsFreeBeforeDestroy);
        
        HRESULT ( STDMETHODCALLTYPE *RateResource )( 
            IDispenserDriver * This,
            /* [in] */ const RESTYPID ResTypId,
            /* [in] */ const RESID ResId,
            /* [in] */ const BOOL fRequiresTransactionEnlistment,
            /* [out] */ RESOURCERATING *pRating);
        
        HRESULT ( STDMETHODCALLTYPE *EnlistResource )( 
            IDispenserDriver * This,
            /* [in] */ const RESID ResId,
            /* [in] */ const TRANSID TransId);
        
        HRESULT ( STDMETHODCALLTYPE *ResetResource )( 
            IDispenserDriver * This,
            /* [in] */ const RESID ResId);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyResource )( 
            IDispenserDriver * This,
            /* [in] */ const RESID ResId);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyResourceS )( 
            IDispenserDriver * This,
            /* [in] */ constSRESID ResId);
        
        END_INTERFACE
    } IDispenserDriverVtbl;

    interface IDispenserDriver
    {
        CONST_VTBL struct IDispenserDriverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispenserDriver_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDispenserDriver_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDispenserDriver_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDispenserDriver_CreateResource(This,ResTypId,pResId,pSecsFreeBeforeDestroy)	\
    ( (This)->lpVtbl -> CreateResource(This,ResTypId,pResId,pSecsFreeBeforeDestroy) ) 

#define IDispenserDriver_RateResource(This,ResTypId,ResId,fRequiresTransactionEnlistment,pRating)	\
    ( (This)->lpVtbl -> RateResource(This,ResTypId,ResId,fRequiresTransactionEnlistment,pRating) ) 

#define IDispenserDriver_EnlistResource(This,ResId,TransId)	\
    ( (This)->lpVtbl -> EnlistResource(This,ResId,TransId) ) 

#define IDispenserDriver_ResetResource(This,ResId)	\
    ( (This)->lpVtbl -> ResetResource(This,ResId) ) 

#define IDispenserDriver_DestroyResource(This,ResId)	\
    ( (This)->lpVtbl -> DestroyResource(This,ResId) ) 

#define IDispenserDriver_DestroyResourceS(This,ResId)	\
    ( (This)->lpVtbl -> DestroyResourceS(This,ResId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDispenserDriver_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0051 */
/* [local] */ 

#ifdef USE_UUIDOF_FOR_IID_
#define  IID_IHolder             __uuidof(IIHolder)
#define  IID_IDispenserManager   __uuidof(IDispenserManager)
#define  IID_IDispenserDriver    __uuidof(IDispenserDriver)
#endif


////////////////////////////////////////////////////////////
// This is the list of Microsoft-allocated process recycling
// reason codes.   These are typed as a long; all values with the
// high bit set are reserved by Microsoft.    Users who have no
// special information to add may use the CRR_NO_REASON_SUPPLIED
// code for that purpose.   The value zero is reserved for the
// CRR_NO_REASON_SUPPLIED code.


#define CRR_NO_REASON_SUPPLIED  0x00000000
#define CRR_LIFETIME_LIMIT      0xFFFFFFFF
#define CRR_ACTIVATION_LIMIT    0xFFFFFFFE
#define CRR_CALL_LIMIT          0xFFFFFFFD
#define CRR_MEMORY_LIMIT        0xFFFFFFFC
#define CRR_RECYCLED_FROM_UI    0xFFFFFFFB


////////////////////////////////////////////////////////////


EXTERN_C const CLSID CLSID_MTSPackage;
EXTERN_C const GUID  GUID_DefaultAppPartition;
EXTERN_C const GUID  GUID_FinalizerCID;
EXTERN_C const GUID  IID_IEnterActivityWithNoLock;


extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0051_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0051_v0_0_s_ifspec;

#ifndef __ITransactionProxy_INTERFACE_DEFINED__
#define __ITransactionProxy_INTERFACE_DEFINED__

/* interface ITransactionProxy */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ITransactionProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02558374-DF2E-4dae-BD6B-1D5C994F9BDC")
    ITransactionProxy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ GUID guid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Promote( 
            /* [out] */ ITransaction **pTransaction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateVoter( 
            /* [in] */ ITransactionVoterNotifyAsync2 *pTxAsync,
            /* [out] */ ITransactionVoterBallotAsync2 **ppBallot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsolationLevel( 
            /* [retval][out] */ ISOLEVEL *__MIDL__ITransactionProxy0000) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdentifier( 
            /* [retval][out] */ GUID *pbstrIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsReusable( 
            /* [out] */ BOOL *pfIsReusable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionProxyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionProxy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionProxy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionProxy * This);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ITransactionProxy * This,
            /* [in] */ GUID guid);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ITransactionProxy * This);
        
        HRESULT ( STDMETHODCALLTYPE *Promote )( 
            ITransactionProxy * This,
            /* [out] */ ITransaction **pTransaction);
        
        HRESULT ( STDMETHODCALLTYPE *CreateVoter )( 
            ITransactionProxy * This,
            /* [in] */ ITransactionVoterNotifyAsync2 *pTxAsync,
            /* [out] */ ITransactionVoterBallotAsync2 **ppBallot);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsolationLevel )( 
            ITransactionProxy * This,
            /* [retval][out] */ ISOLEVEL *__MIDL__ITransactionProxy0000);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentifier )( 
            ITransactionProxy * This,
            /* [retval][out] */ GUID *pbstrIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE *IsReusable )( 
            ITransactionProxy * This,
            /* [out] */ BOOL *pfIsReusable);
        
        END_INTERFACE
    } ITransactionProxyVtbl;

    interface ITransactionProxy
    {
        CONST_VTBL struct ITransactionProxyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionProxy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionProxy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionProxy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionProxy_Commit(This,guid)	\
    ( (This)->lpVtbl -> Commit(This,guid) ) 

#define ITransactionProxy_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define ITransactionProxy_Promote(This,pTransaction)	\
    ( (This)->lpVtbl -> Promote(This,pTransaction) ) 

#define ITransactionProxy_CreateVoter(This,pTxAsync,ppBallot)	\
    ( (This)->lpVtbl -> CreateVoter(This,pTxAsync,ppBallot) ) 

#define ITransactionProxy_GetIsolationLevel(This,__MIDL__ITransactionProxy0000)	\
    ( (This)->lpVtbl -> GetIsolationLevel(This,__MIDL__ITransactionProxy0000) ) 

#define ITransactionProxy_GetIdentifier(This,pbstrIdentifier)	\
    ( (This)->lpVtbl -> GetIdentifier(This,pbstrIdentifier) ) 

#define ITransactionProxy_IsReusable(This,pfIsReusable)	\
    ( (This)->lpVtbl -> IsReusable(This,pfIsReusable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionProxy_INTERFACE_DEFINED__ */


#ifndef __IContextSecurityPerimeter_INTERFACE_DEFINED__
#define __IContextSecurityPerimeter_INTERFACE_DEFINED__

/* interface IContextSecurityPerimeter */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IContextSecurityPerimeter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A7549A29-A7C4-42e1-8DC1-7E3D748DC24A")
    IContextSecurityPerimeter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPerimeterFlag( 
            /* [out] */ BOOL *pFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPerimeterFlag( 
            /* [in] */ BOOL fFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextSecurityPerimeterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextSecurityPerimeter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextSecurityPerimeter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextSecurityPerimeter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPerimeterFlag )( 
            IContextSecurityPerimeter * This,
            /* [out] */ BOOL *pFlag);
        
        HRESULT ( STDMETHODCALLTYPE *SetPerimeterFlag )( 
            IContextSecurityPerimeter * This,
            /* [in] */ BOOL fFlag);
        
        END_INTERFACE
    } IContextSecurityPerimeterVtbl;

    interface IContextSecurityPerimeter
    {
        CONST_VTBL struct IContextSecurityPerimeterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextSecurityPerimeter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContextSecurityPerimeter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContextSecurityPerimeter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContextSecurityPerimeter_GetPerimeterFlag(This,pFlag)	\
    ( (This)->lpVtbl -> GetPerimeterFlag(This,pFlag) ) 

#define IContextSecurityPerimeter_SetPerimeterFlag(This,fFlag)	\
    ( (This)->lpVtbl -> SetPerimeterFlag(This,fFlag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContextSecurityPerimeter_INTERFACE_DEFINED__ */


#ifndef __ITxProxyHolder_INTERFACE_DEFINED__
#define __ITxProxyHolder_INTERFACE_DEFINED__

/* interface ITxProxyHolder */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ITxProxyHolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13D86F31-0139-41af-BCAD-C7D50435FE9F")
    ITxProxyHolder : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE GetIdentifier( 
            /* [out] */ GUID *pGuidLtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITxProxyHolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITxProxyHolder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITxProxyHolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITxProxyHolder * This);
        
        void ( STDMETHODCALLTYPE *GetIdentifier )( 
            ITxProxyHolder * This,
            /* [out] */ GUID *pGuidLtx);
        
        END_INTERFACE
    } ITxProxyHolderVtbl;

    interface ITxProxyHolder
    {
        CONST_VTBL struct ITxProxyHolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITxProxyHolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITxProxyHolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITxProxyHolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITxProxyHolder_GetIdentifier(This,pGuidLtx)	\
    ( (This)->lpVtbl -> GetIdentifier(This,pGuidLtx) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITxProxyHolder_INTERFACE_DEFINED__ */


#ifndef __IObjectContext_INTERFACE_DEFINED__
#define __IObjectContext_INTERFACE_DEFINED__

/* interface IObjectContext */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_IObjectContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51372ae0-cae7-11cf-be81-00aa00a2fa25")
    IObjectContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableCommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableCommit( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsInTransaction( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsSecurityEnabled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCallerInRole( 
            /* [in] */ BSTR bstrRole,
            /* [retval][out] */ BOOL *pfIsInRole) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            IObjectContext * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetComplete )( 
            IObjectContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAbort )( 
            IObjectContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableCommit )( 
            IObjectContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *DisableCommit )( 
            IObjectContext * This);
        
        BOOL ( STDMETHODCALLTYPE *IsInTransaction )( 
            IObjectContext * This);
        
        BOOL ( STDMETHODCALLTYPE *IsSecurityEnabled )( 
            IObjectContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsCallerInRole )( 
            IObjectContext * This,
            /* [in] */ BSTR bstrRole,
            /* [retval][out] */ BOOL *pfIsInRole);
        
        END_INTERFACE
    } IObjectContextVtbl;

    interface IObjectContext
    {
        CONST_VTBL struct IObjectContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectContext_CreateInstance(This,rclsid,riid,ppv)	\
    ( (This)->lpVtbl -> CreateInstance(This,rclsid,riid,ppv) ) 

#define IObjectContext_SetComplete(This)	\
    ( (This)->lpVtbl -> SetComplete(This) ) 

#define IObjectContext_SetAbort(This)	\
    ( (This)->lpVtbl -> SetAbort(This) ) 

#define IObjectContext_EnableCommit(This)	\
    ( (This)->lpVtbl -> EnableCommit(This) ) 

#define IObjectContext_DisableCommit(This)	\
    ( (This)->lpVtbl -> DisableCommit(This) ) 

#define IObjectContext_IsInTransaction(This)	\
    ( (This)->lpVtbl -> IsInTransaction(This) ) 

#define IObjectContext_IsSecurityEnabled(This)	\
    ( (This)->lpVtbl -> IsSecurityEnabled(This) ) 

#define IObjectContext_IsCallerInRole(This,bstrRole,pfIsInRole)	\
    ( (This)->lpVtbl -> IsCallerInRole(This,bstrRole,pfIsInRole) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectContext_INTERFACE_DEFINED__ */


#ifndef __IObjectControl_INTERFACE_DEFINED__
#define __IObjectControl_INTERFACE_DEFINED__

/* interface IObjectControl */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_IObjectControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51372aec-cae7-11cf-be81-00aa00a2fa25")
    IObjectControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( void) = 0;
        
        virtual void STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE CanBePooled( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IObjectControl * This);
        
        void ( STDMETHODCALLTYPE *Deactivate )( 
            IObjectControl * This);
        
        BOOL ( STDMETHODCALLTYPE *CanBePooled )( 
            IObjectControl * This);
        
        END_INTERFACE
    } IObjectControlVtbl;

    interface IObjectControl
    {
        CONST_VTBL struct IObjectControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectControl_Activate(This)	\
    ( (This)->lpVtbl -> Activate(This) ) 

#define IObjectControl_Deactivate(This)	\
    ( (This)->lpVtbl -> Deactivate(This) ) 

#define IObjectControl_CanBePooled(This)	\
    ( (This)->lpVtbl -> CanBePooled(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectControl_INTERFACE_DEFINED__ */


#ifndef __IEnumNames_INTERFACE_DEFINED__
#define __IEnumNames_INTERFACE_DEFINED__

/* interface IEnumNames */
/* [object][unique][uuid][hidden][local] */ 


EXTERN_C const IID IID_IEnumNames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51372af2-cae7-11cf-be81-00aa00a2fa25")
    IEnumNames : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long celt,
            /* [size_is][out] */ BSTR *rgname,
            /* [retval][out] */ unsigned long *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumNames **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNamesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumNames * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumNames * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumNames * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumNames * This,
            /* [in] */ unsigned long celt,
            /* [size_is][out] */ BSTR *rgname,
            /* [retval][out] */ unsigned long *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumNames * This,
            /* [in] */ unsigned long celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumNames * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumNames * This,
            /* [retval][out] */ IEnumNames **ppenum);
        
        END_INTERFACE
    } IEnumNamesVtbl;

    interface IEnumNames
    {
        CONST_VTBL struct IEnumNamesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNames_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumNames_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumNames_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumNames_Next(This,celt,rgname,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgname,pceltFetched) ) 

#define IEnumNames_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumNames_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumNames_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumNames_INTERFACE_DEFINED__ */


#ifndef __ISecurityProperty_INTERFACE_DEFINED__
#define __ISecurityProperty_INTERFACE_DEFINED__

/* interface ISecurityProperty */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_ISecurityProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51372aea-cae7-11cf-be81-00aa00a2fa25")
    ISecurityProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDirectCreatorSID( 
            PSID *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalCreatorSID( 
            PSID *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectCallerSID( 
            PSID *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalCallerSID( 
            PSID *pSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSID( 
            PSID pSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISecurityPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISecurityProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISecurityProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISecurityProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectCreatorSID )( 
            ISecurityProperty * This,
            PSID *pSID);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalCreatorSID )( 
            ISecurityProperty * This,
            PSID *pSID);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectCallerSID )( 
            ISecurityProperty * This,
            PSID *pSID);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalCallerSID )( 
            ISecurityProperty * This,
            PSID *pSID);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseSID )( 
            ISecurityProperty * This,
            PSID pSID);
        
        END_INTERFACE
    } ISecurityPropertyVtbl;

    interface ISecurityProperty
    {
        CONST_VTBL struct ISecurityPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISecurityProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISecurityProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISecurityProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISecurityProperty_GetDirectCreatorSID(This,pSID)	\
    ( (This)->lpVtbl -> GetDirectCreatorSID(This,pSID) ) 

#define ISecurityProperty_GetOriginalCreatorSID(This,pSID)	\
    ( (This)->lpVtbl -> GetOriginalCreatorSID(This,pSID) ) 

#define ISecurityProperty_GetDirectCallerSID(This,pSID)	\
    ( (This)->lpVtbl -> GetDirectCallerSID(This,pSID) ) 

#define ISecurityProperty_GetOriginalCallerSID(This,pSID)	\
    ( (This)->lpVtbl -> GetOriginalCallerSID(This,pSID) ) 

#define ISecurityProperty_ReleaseSID(This,pSID)	\
    ( (This)->lpVtbl -> ReleaseSID(This,pSID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISecurityProperty_INTERFACE_DEFINED__ */


#ifndef __ObjectControl_INTERFACE_DEFINED__
#define __ObjectControl_INTERFACE_DEFINED__

/* interface ObjectControl */
/* [version][helpcontext][helpstring][oleautomation][uuid][local][object] */ 


EXTERN_C const IID IID_ObjectControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7DC41850-0C31-11d0-8B79-00AA00B8A790")
    ObjectControl : public IUnknown
    {
    public:
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE Activate( void) = 0;
        
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE CanBePooled( 
            /* [retval][out] */ VARIANT_BOOL *pbPoolable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ObjectControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ObjectControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ObjectControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ObjectControl * This);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ObjectControl * This);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ObjectControl * This);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE *CanBePooled )( 
            ObjectControl * This,
            /* [retval][out] */ VARIANT_BOOL *pbPoolable);
        
        END_INTERFACE
    } ObjectControlVtbl;

    interface ObjectControl
    {
        CONST_VTBL struct ObjectControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ObjectControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ObjectControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ObjectControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ObjectControl_Activate(This)	\
    ( (This)->lpVtbl -> Activate(This) ) 

#define ObjectControl_Deactivate(This)	\
    ( (This)->lpVtbl -> Deactivate(This) ) 

#define ObjectControl_CanBePooled(This,pbPoolable)	\
    ( (This)->lpVtbl -> CanBePooled(This,pbPoolable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ObjectControl_INTERFACE_DEFINED__ */


#ifndef __ISharedProperty_INTERFACE_DEFINED__
#define __ISharedProperty_INTERFACE_DEFINED__

/* interface ISharedProperty */
/* [object][unique][helpcontext][helpstring][dual][uuid] */ 


EXTERN_C const IID IID_ISharedProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A005C01-A5DE-11CF-9E66-00AA00A3F464")
    ISharedProperty : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out VARIANT *pVal) = 0;
        
        virtual /* [helpstring][helpcontext][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT val) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISharedProperty * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISharedProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISharedProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISharedProperty * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISharedProperty * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISharedProperty * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISharedProperty * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            ISharedProperty * This,
            /* [retval][out] */ __RPC__out VARIANT *pVal);
        
        /* [helpstring][helpcontext][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            ISharedProperty * This,
            /* [in] */ VARIANT val);
        
        END_INTERFACE
    } ISharedPropertyVtbl;

    interface ISharedProperty
    {
        CONST_VTBL struct ISharedPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISharedProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISharedProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISharedProperty_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISharedProperty_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISharedProperty_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISharedProperty_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISharedProperty_get_Value(This,pVal)	\
    ( (This)->lpVtbl -> get_Value(This,pVal) ) 

#define ISharedProperty_put_Value(This,val)	\
    ( (This)->lpVtbl -> put_Value(This,val) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISharedProperty_INTERFACE_DEFINED__ */


#ifndef __ISharedPropertyGroup_INTERFACE_DEFINED__
#define __ISharedPropertyGroup_INTERFACE_DEFINED__

/* interface ISharedPropertyGroup */
/* [object][unique][helpcontext][helpstring][dual][uuid] */ 


EXTERN_C const IID IID_ISharedPropertyGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A005C07-A5DE-11CF-9E66-00AA00A3F464")
    ISharedPropertyGroup : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CreatePropertyByPosition( 
            /* [in] */ int Index,
            /* [out] */ __RPC__out VARIANT_BOOL *fExists,
            /* [retval][out] */ __RPC__deref_out_opt ISharedProperty **ppProp) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_PropertyByPosition( 
            /* [in] */ int Index,
            /* [retval][out] */ __RPC__deref_out_opt ISharedProperty **ppProperty) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CreateProperty( 
            /* [in] */ __RPC__in BSTR Name,
            /* [out] */ __RPC__out VARIANT_BOOL *fExists,
            /* [retval][out] */ __RPC__deref_out_opt ISharedProperty **ppProp) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Property( 
            /* [in] */ __RPC__in BSTR Name,
            /* [retval][out] */ __RPC__deref_out_opt ISharedProperty **ppProperty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedPropertyGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISharedPropertyGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISharedPropertyGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISharedPropertyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISharedPropertyGroup * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISharedPropertyGroup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISharedPropertyGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISharedPropertyGroup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *CreatePropertyByPosition )( 
            ISharedPropertyGroup * This,
            /* [in] */ int Index,
            /* [out] */ __RPC__out VARIANT_BOOL *fExists,
            /* [retval][out] */ __RPC__deref_out_opt ISharedProperty **ppProp);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyByPosition )( 
            ISharedPropertyGroup * This,
            /* [in] */ int Index,
            /* [retval][out] */ __RPC__deref_out_opt ISharedProperty **ppProperty);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *CreateProperty )( 
            ISharedPropertyGroup * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [out] */ __RPC__out VARIANT_BOOL *fExists,
            /* [retval][out] */ __RPC__deref_out_opt ISharedProperty **ppProp);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Property )( 
            ISharedPropertyGroup * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [retval][out] */ __RPC__deref_out_opt ISharedProperty **ppProperty);
        
        END_INTERFACE
    } ISharedPropertyGroupVtbl;

    interface ISharedPropertyGroup
    {
        CONST_VTBL struct ISharedPropertyGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedPropertyGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISharedPropertyGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISharedPropertyGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISharedPropertyGroup_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISharedPropertyGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISharedPropertyGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISharedPropertyGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISharedPropertyGroup_CreatePropertyByPosition(This,Index,fExists,ppProp)	\
    ( (This)->lpVtbl -> CreatePropertyByPosition(This,Index,fExists,ppProp) ) 

#define ISharedPropertyGroup_get_PropertyByPosition(This,Index,ppProperty)	\
    ( (This)->lpVtbl -> get_PropertyByPosition(This,Index,ppProperty) ) 

#define ISharedPropertyGroup_CreateProperty(This,Name,fExists,ppProp)	\
    ( (This)->lpVtbl -> CreateProperty(This,Name,fExists,ppProp) ) 

#define ISharedPropertyGroup_get_Property(This,Name,ppProperty)	\
    ( (This)->lpVtbl -> get_Property(This,Name,ppProperty) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISharedPropertyGroup_INTERFACE_DEFINED__ */


#ifndef __ISharedPropertyGroupManager_INTERFACE_DEFINED__
#define __ISharedPropertyGroupManager_INTERFACE_DEFINED__

/* interface ISharedPropertyGroupManager */
/* [object][unique][helpcontext][helpstring][dual][uuid] */ 


EXTERN_C const IID IID_ISharedPropertyGroupManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A005C0D-A5DE-11CF-9E66-00AA00A3F464")
    ISharedPropertyGroupManager : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CreatePropertyGroup( 
            /* [in] */ __RPC__in BSTR Name,
            /* [out][in] */ __RPC__inout LONG *dwIsoMode,
            /* [out][in] */ __RPC__inout LONG *dwRelMode,
            /* [out] */ __RPC__out VARIANT_BOOL *fExists,
            /* [retval][out] */ __RPC__deref_out_opt ISharedPropertyGroup **ppGroup) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Group( 
            /* [in] */ __RPC__in BSTR Name,
            /* [retval][out] */ __RPC__deref_out_opt ISharedPropertyGroup **ppGroup) = 0;
        
        virtual /* [helpstring][helpcontext][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedPropertyGroupManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISharedPropertyGroupManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISharedPropertyGroupManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISharedPropertyGroupManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISharedPropertyGroupManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISharedPropertyGroupManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISharedPropertyGroupManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISharedPropertyGroupManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *CreatePropertyGroup )( 
            ISharedPropertyGroupManager * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [out][in] */ __RPC__inout LONG *dwIsoMode,
            /* [out][in] */ __RPC__inout LONG *dwRelMode,
            /* [out] */ __RPC__out VARIANT_BOOL *fExists,
            /* [retval][out] */ __RPC__deref_out_opt ISharedPropertyGroup **ppGroup);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Group )( 
            ISharedPropertyGroupManager * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [retval][out] */ __RPC__deref_out_opt ISharedPropertyGroup **ppGroup);
        
        /* [helpstring][helpcontext][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ISharedPropertyGroupManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        END_INTERFACE
    } ISharedPropertyGroupManagerVtbl;

    interface ISharedPropertyGroupManager
    {
        CONST_VTBL struct ISharedPropertyGroupManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedPropertyGroupManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISharedPropertyGroupManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISharedPropertyGroupManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISharedPropertyGroupManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISharedPropertyGroupManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISharedPropertyGroupManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISharedPropertyGroupManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISharedPropertyGroupManager_CreatePropertyGroup(This,Name,dwIsoMode,dwRelMode,fExists,ppGroup)	\
    ( (This)->lpVtbl -> CreatePropertyGroup(This,Name,dwIsoMode,dwRelMode,fExists,ppGroup) ) 

#define ISharedPropertyGroupManager_get_Group(This,Name,ppGroup)	\
    ( (This)->lpVtbl -> get_Group(This,Name,ppGroup) ) 

#define ISharedPropertyGroupManager_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISharedPropertyGroupManager_INTERFACE_DEFINED__ */


#ifndef __IObjectConstruct_INTERFACE_DEFINED__
#define __IObjectConstruct_INTERFACE_DEFINED__

/* interface IObjectConstruct */
/* [uuid][helpstring][unique][object][local] */ 


EXTERN_C const IID IID_IObjectConstruct;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41C4F8B3-7439-11D2-98CB-00C04F8EE1C4")
    IObjectConstruct : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Construct( 
            /* [in] */ IDispatch *pCtorObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectConstructVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectConstruct * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectConstruct * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectConstruct * This);
        
        HRESULT ( STDMETHODCALLTYPE *Construct )( 
            IObjectConstruct * This,
            /* [in] */ IDispatch *pCtorObj);
        
        END_INTERFACE
    } IObjectConstructVtbl;

    interface IObjectConstruct
    {
        CONST_VTBL struct IObjectConstructVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectConstruct_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectConstruct_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectConstruct_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectConstruct_Construct(This,pCtorObj)	\
    ( (This)->lpVtbl -> Construct(This,pCtorObj) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectConstruct_INTERFACE_DEFINED__ */


#ifndef __IObjectConstructString_INTERFACE_DEFINED__
#define __IObjectConstructString_INTERFACE_DEFINED__

/* interface IObjectConstructString */
/* [uuid][helpstring][dual][unique][object][local] */ 


EXTERN_C const IID IID_IObjectConstructString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41C4F8B2-7439-11D2-98CB-00C04F8EE1C4")
    IObjectConstructString : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConstructString( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectConstructStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectConstructString * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectConstructString * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectConstructString * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IObjectConstructString * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IObjectConstructString * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IObjectConstructString * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IObjectConstructString * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConstructString )( 
            IObjectConstructString * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IObjectConstructStringVtbl;

    interface IObjectConstructString
    {
        CONST_VTBL struct IObjectConstructStringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectConstructString_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectConstructString_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectConstructString_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectConstructString_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IObjectConstructString_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IObjectConstructString_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IObjectConstructString_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IObjectConstructString_get_ConstructString(This,pVal)	\
    ( (This)->lpVtbl -> get_ConstructString(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectConstructString_INTERFACE_DEFINED__ */


#ifndef __IObjectContextActivity_INTERFACE_DEFINED__
#define __IObjectContextActivity_INTERFACE_DEFINED__

/* interface IObjectContextActivity */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_IObjectContextActivity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51372afc-cae7-11cf-be81-00aa00a2fa25")
    IObjectContextActivity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetActivityId( 
            /* [out] */ GUID *pGUID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContextActivityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectContextActivity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectContextActivity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectContextActivity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivityId )( 
            IObjectContextActivity * This,
            /* [out] */ GUID *pGUID);
        
        END_INTERFACE
    } IObjectContextActivityVtbl;

    interface IObjectContextActivity
    {
        CONST_VTBL struct IObjectContextActivityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContextActivity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectContextActivity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectContextActivity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectContextActivity_GetActivityId(This,pGUID)	\
    ( (This)->lpVtbl -> GetActivityId(This,pGUID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectContextActivity_INTERFACE_DEFINED__ */


#ifndef __IObjectContextInfo_INTERFACE_DEFINED__
#define __IObjectContextInfo_INTERFACE_DEFINED__

/* interface IObjectContextInfo */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IObjectContextInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75B52DDB-E8ED-11d1-93AD-00AA00BA3258")
    IObjectContextInfo : public IUnknown
    {
    public:
        virtual BOOL STDMETHODCALLTYPE IsInTransaction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransaction( 
            IUnknown **pptrans) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransactionId( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivityId( 
            /* [out] */ GUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextId( 
            /* [out] */ GUID *pGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContextInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectContextInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectContextInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectContextInfo * This);
        
        BOOL ( STDMETHODCALLTYPE *IsInTransaction )( 
            IObjectContextInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransaction )( 
            IObjectContextInfo * This,
            IUnknown **pptrans);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransactionId )( 
            IObjectContextInfo * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivityId )( 
            IObjectContextInfo * This,
            /* [out] */ GUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextId )( 
            IObjectContextInfo * This,
            /* [out] */ GUID *pGuid);
        
        END_INTERFACE
    } IObjectContextInfoVtbl;

    interface IObjectContextInfo
    {
        CONST_VTBL struct IObjectContextInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContextInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectContextInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectContextInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectContextInfo_IsInTransaction(This)	\
    ( (This)->lpVtbl -> IsInTransaction(This) ) 

#define IObjectContextInfo_GetTransaction(This,pptrans)	\
    ( (This)->lpVtbl -> GetTransaction(This,pptrans) ) 

#define IObjectContextInfo_GetTransactionId(This,pGuid)	\
    ( (This)->lpVtbl -> GetTransactionId(This,pGuid) ) 

#define IObjectContextInfo_GetActivityId(This,pGUID)	\
    ( (This)->lpVtbl -> GetActivityId(This,pGUID) ) 

#define IObjectContextInfo_GetContextId(This,pGuid)	\
    ( (This)->lpVtbl -> GetContextId(This,pGuid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectContextInfo_INTERFACE_DEFINED__ */


#ifndef __IObjectContextInfo2_INTERFACE_DEFINED__
#define __IObjectContextInfo2_INTERFACE_DEFINED__

/* interface IObjectContextInfo2 */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IObjectContextInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("594BE71A-4BC4-438b-9197-CFD176248B09")
    IObjectContextInfo2 : public IObjectContextInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPartitionId( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationId( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInstanceId( 
            /* [out] */ GUID *pGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContextInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectContextInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectContextInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectContextInfo2 * This);
        
        BOOL ( STDMETHODCALLTYPE *IsInTransaction )( 
            IObjectContextInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransaction )( 
            IObjectContextInfo2 * This,
            IUnknown **pptrans);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransactionId )( 
            IObjectContextInfo2 * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivityId )( 
            IObjectContextInfo2 * This,
            /* [out] */ GUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextId )( 
            IObjectContextInfo2 * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartitionId )( 
            IObjectContextInfo2 * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationId )( 
            IObjectContextInfo2 * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInstanceId )( 
            IObjectContextInfo2 * This,
            /* [out] */ GUID *pGuid);
        
        END_INTERFACE
    } IObjectContextInfo2Vtbl;

    interface IObjectContextInfo2
    {
        CONST_VTBL struct IObjectContextInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContextInfo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectContextInfo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectContextInfo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectContextInfo2_IsInTransaction(This)	\
    ( (This)->lpVtbl -> IsInTransaction(This) ) 

#define IObjectContextInfo2_GetTransaction(This,pptrans)	\
    ( (This)->lpVtbl -> GetTransaction(This,pptrans) ) 

#define IObjectContextInfo2_GetTransactionId(This,pGuid)	\
    ( (This)->lpVtbl -> GetTransactionId(This,pGuid) ) 

#define IObjectContextInfo2_GetActivityId(This,pGUID)	\
    ( (This)->lpVtbl -> GetActivityId(This,pGUID) ) 

#define IObjectContextInfo2_GetContextId(This,pGuid)	\
    ( (This)->lpVtbl -> GetContextId(This,pGuid) ) 


#define IObjectContextInfo2_GetPartitionId(This,pGuid)	\
    ( (This)->lpVtbl -> GetPartitionId(This,pGuid) ) 

#define IObjectContextInfo2_GetApplicationId(This,pGuid)	\
    ( (This)->lpVtbl -> GetApplicationId(This,pGuid) ) 

#define IObjectContextInfo2_GetApplicationInstanceId(This,pGuid)	\
    ( (This)->lpVtbl -> GetApplicationInstanceId(This,pGuid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectContextInfo2_INTERFACE_DEFINED__ */


#ifndef __ITransactionStatus_INTERFACE_DEFINED__
#define __ITransactionStatus_INTERFACE_DEFINED__

/* interface ITransactionStatus */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_ITransactionStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61F589E8-3724-4898-A0A4-664AE9E1D1B4")
    ITransactionStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTransactionStatus( 
            HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransactionStatus( 
            HRESULT *pHrStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransactionStatus )( 
            ITransactionStatus * This,
            HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransactionStatus )( 
            ITransactionStatus * This,
            HRESULT *pHrStatus);
        
        END_INTERFACE
    } ITransactionStatusVtbl;

    interface ITransactionStatus
    {
        CONST_VTBL struct ITransactionStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionStatus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionStatus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionStatus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionStatus_SetTransactionStatus(This,hrStatus)	\
    ( (This)->lpVtbl -> SetTransactionStatus(This,hrStatus) ) 

#define ITransactionStatus_GetTransactionStatus(This,pHrStatus)	\
    ( (This)->lpVtbl -> GetTransactionStatus(This,pHrStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionStatus_INTERFACE_DEFINED__ */


#ifndef __IObjectContextTip_INTERFACE_DEFINED__
#define __IObjectContextTip_INTERFACE_DEFINED__

/* interface IObjectContextTip */
/* [object][uuid][unique][local] */ 


EXTERN_C const IID IID_IObjectContextTip;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92FD41CA-BAD9-11d2-9A2D-00C04F797BC9")
    IObjectContextTip : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTipUrl( 
            /* [retval][out] */ BSTR *pTipUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContextTipVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectContextTip * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectContextTip * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectContextTip * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTipUrl )( 
            IObjectContextTip * This,
            /* [retval][out] */ BSTR *pTipUrl);
        
        END_INTERFACE
    } IObjectContextTipVtbl;

    interface IObjectContextTip
    {
        CONST_VTBL struct IObjectContextTipVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContextTip_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectContextTip_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectContextTip_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectContextTip_GetTipUrl(This,pTipUrl)	\
    ( (This)->lpVtbl -> GetTipUrl(This,pTipUrl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectContextTip_INTERFACE_DEFINED__ */


#ifndef __IPlaybackControl_INTERFACE_DEFINED__
#define __IPlaybackControl_INTERFACE_DEFINED__

/* interface IPlaybackControl */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IPlaybackControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51372afd-cae7-11cf-be81-00aa00a2fa25")
    IPlaybackControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FinalClientRetry( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinalServerRetry( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPlaybackControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPlaybackControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPlaybackControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPlaybackControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *FinalClientRetry )( 
            IPlaybackControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *FinalServerRetry )( 
            IPlaybackControl * This);
        
        END_INTERFACE
    } IPlaybackControlVtbl;

    interface IPlaybackControl
    {
        CONST_VTBL struct IPlaybackControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPlaybackControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPlaybackControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPlaybackControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPlaybackControl_FinalClientRetry(This)	\
    ( (This)->lpVtbl -> FinalClientRetry(This) ) 

#define IPlaybackControl_FinalServerRetry(This)	\
    ( (This)->lpVtbl -> FinalServerRetry(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPlaybackControl_INTERFACE_DEFINED__ */


#ifndef __IGetContextProperties_INTERFACE_DEFINED__
#define __IGetContextProperties_INTERFACE_DEFINED__

/* interface IGetContextProperties */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_IGetContextProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51372af4-cae7-11cf-be81-00aa00a2fa25")
    IGetContextProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNames( 
            /* [retval][out] */ IEnumNames **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetContextPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetContextProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetContextProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetContextProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IGetContextProperties * This,
            /* [retval][out] */ long *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IGetContextProperties * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pProperty);
        
        HRESULT ( STDMETHODCALLTYPE *EnumNames )( 
            IGetContextProperties * This,
            /* [retval][out] */ IEnumNames **ppenum);
        
        END_INTERFACE
    } IGetContextPropertiesVtbl;

    interface IGetContextProperties
    {
        CONST_VTBL struct IGetContextPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetContextProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetContextProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetContextProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetContextProperties_Count(This,plCount)	\
    ( (This)->lpVtbl -> Count(This,plCount) ) 

#define IGetContextProperties_GetProperty(This,name,pProperty)	\
    ( (This)->lpVtbl -> GetProperty(This,name,pProperty) ) 

#define IGetContextProperties_EnumNames(This,ppenum)	\
    ( (This)->lpVtbl -> EnumNames(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetContextProperties_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0071 */
/* [local] */ 

typedef 
enum tagTransactionVote
    {	TxCommit	= 0,
	TxAbort	= ( TxCommit + 1 ) 
    } 	TransactionVote;



extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0071_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0071_v0_0_s_ifspec;

#ifndef __IContextState_INTERFACE_DEFINED__
#define __IContextState_INTERFACE_DEFINED__

/* interface IContextState */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IContextState;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C05E54B-A42A-11d2-AFC4-00C04F8EE1C4")
    IContextState : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDeactivateOnReturn( 
            VARIANT_BOOL bDeactivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeactivateOnReturn( 
            /* [out] */ VARIANT_BOOL *pbDeactivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMyTransactionVote( 
            TransactionVote txVote) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMyTransactionVote( 
            /* [out] */ TransactionVote *ptxVote) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextStateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextState * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextState * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextState * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeactivateOnReturn )( 
            IContextState * This,
            VARIANT_BOOL bDeactivate);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeactivateOnReturn )( 
            IContextState * This,
            /* [out] */ VARIANT_BOOL *pbDeactivate);
        
        HRESULT ( STDMETHODCALLTYPE *SetMyTransactionVote )( 
            IContextState * This,
            TransactionVote txVote);
        
        HRESULT ( STDMETHODCALLTYPE *GetMyTransactionVote )( 
            IContextState * This,
            /* [out] */ TransactionVote *ptxVote);
        
        END_INTERFACE
    } IContextStateVtbl;

    interface IContextState
    {
        CONST_VTBL struct IContextStateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextState_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContextState_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContextState_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContextState_SetDeactivateOnReturn(This,bDeactivate)	\
    ( (This)->lpVtbl -> SetDeactivateOnReturn(This,bDeactivate) ) 

#define IContextState_GetDeactivateOnReturn(This,pbDeactivate)	\
    ( (This)->lpVtbl -> GetDeactivateOnReturn(This,pbDeactivate) ) 

#define IContextState_SetMyTransactionVote(This,txVote)	\
    ( (This)->lpVtbl -> SetMyTransactionVote(This,txVote) ) 

#define IContextState_GetMyTransactionVote(This,ptxVote)	\
    ( (This)->lpVtbl -> GetMyTransactionVote(This,ptxVote) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContextState_INTERFACE_DEFINED__ */


#ifndef __IPoolManager_INTERFACE_DEFINED__
#define __IPoolManager_INTERFACE_DEFINED__

/* interface IPoolManager */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IPoolManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0a469861-5a91-43a0-99b6-d5e179bb0631")
    IPoolManager : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ShutdownPool( 
            /* [in] */ BSTR CLSIDOrProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPoolManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPoolManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPoolManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPoolManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPoolManager * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPoolManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPoolManager * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPoolManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ShutdownPool )( 
            IPoolManager * This,
            /* [in] */ BSTR CLSIDOrProgID);
        
        END_INTERFACE
    } IPoolManagerVtbl;

    interface IPoolManager
    {
        CONST_VTBL struct IPoolManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPoolManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPoolManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPoolManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPoolManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IPoolManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IPoolManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IPoolManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IPoolManager_ShutdownPool(This,CLSIDOrProgID)	\
    ( (This)->lpVtbl -> ShutdownPool(This,CLSIDOrProgID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPoolManager_INTERFACE_DEFINED__ */


#ifndef __ISelectCOMLBServer_INTERFACE_DEFINED__
#define __ISelectCOMLBServer_INTERFACE_DEFINED__

/* interface ISelectCOMLBServer */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_ISelectCOMLBServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dcf443f4-3f8a-4872-b9f0-369a796d12d6")
    ISelectCOMLBServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLBServer( 
            /* [in] */ IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectCOMLBServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISelectCOMLBServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISelectCOMLBServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISelectCOMLBServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ISelectCOMLBServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLBServer )( 
            ISelectCOMLBServer * This,
            /* [in] */ IUnknown *pUnk);
        
        END_INTERFACE
    } ISelectCOMLBServerVtbl;

    interface ISelectCOMLBServer
    {
        CONST_VTBL struct ISelectCOMLBServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectCOMLBServer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISelectCOMLBServer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISelectCOMLBServer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISelectCOMLBServer_Init(This)	\
    ( (This)->lpVtbl -> Init(This) ) 

#define ISelectCOMLBServer_GetLBServer(This,pUnk)	\
    ( (This)->lpVtbl -> GetLBServer(This,pUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISelectCOMLBServer_INTERFACE_DEFINED__ */


#ifndef __ICOMLBArguments_INTERFACE_DEFINED__
#define __ICOMLBArguments_INTERFACE_DEFINED__

/* interface ICOMLBArguments */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_ICOMLBArguments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3a0f150f-8ee5-4b94-b40e-aef2f9e42ed2")
    ICOMLBArguments : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCLSID( 
            /* [out] */ CLSID *pCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCLSID( 
            /* [in] */ CLSID *pCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMachineName( 
            /* [in] */ ULONG cchSvr,
            /* [max_is][out] */ 
            __out_ecount(cchSvr)  WCHAR szServerName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMachineName( 
            /* [in] */ ULONG cchSvr,
            /* [size_is][in] */ 
            __in_ecount(cchSvr)  WCHAR szServerName[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOMLBArgumentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICOMLBArguments * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICOMLBArguments * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICOMLBArguments * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            ICOMLBArguments * This,
            /* [out] */ CLSID *pCLSID);
        
        HRESULT ( STDMETHODCALLTYPE *SetCLSID )( 
            ICOMLBArguments * This,
            /* [in] */ CLSID *pCLSID);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineName )( 
            ICOMLBArguments * This,
            /* [in] */ ULONG cchSvr,
            /* [max_is][out] */ 
            __out_ecount(cchSvr)  WCHAR szServerName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetMachineName )( 
            ICOMLBArguments * This,
            /* [in] */ ULONG cchSvr,
            /* [size_is][in] */ 
            __in_ecount(cchSvr)  WCHAR szServerName[  ]);
        
        END_INTERFACE
    } ICOMLBArgumentsVtbl;

    interface ICOMLBArguments
    {
        CONST_VTBL struct ICOMLBArgumentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOMLBArguments_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICOMLBArguments_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICOMLBArguments_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICOMLBArguments_GetCLSID(This,pCLSID)	\
    ( (This)->lpVtbl -> GetCLSID(This,pCLSID) ) 

#define ICOMLBArguments_SetCLSID(This,pCLSID)	\
    ( (This)->lpVtbl -> SetCLSID(This,pCLSID) ) 

#define ICOMLBArguments_GetMachineName(This,cchSvr,szServerName)	\
    ( (This)->lpVtbl -> GetMachineName(This,cchSvr,szServerName) ) 

#define ICOMLBArguments_SetMachineName(This,cchSvr,szServerName)	\
    ( (This)->lpVtbl -> SetMachineName(This,cchSvr,szServerName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICOMLBArguments_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0075 */
/* [local] */ 

#if (_WIN32_WINNT >= 0x0500)
#define GetObjectContext(ppIOC) (CoGetObjectContext(IID_IObjectContext, (void **) (ppIOC)) == S_OK ? S_OK : CONTEXT_E_NOCONTEXT)
#else
extern HRESULT __cdecl GetObjectContext (IObjectContext** ppInstanceContext);
#endif
EXTERN_C HRESULT __stdcall CoCreateActivity(IUnknown* pIUnknown, REFIID riid, void** ppObj );
EXTERN_C HRESULT __stdcall CoEnterServiceDomain(IUnknown* pConfigObject);
EXTERN_C void __stdcall CoLeaveServiceDomain(IUnknown *pUnkStatus);
EXTERN_C HRESULT __stdcall GetManagedExtensions(DWORD* dwExts);
extern void* __cdecl SafeRef(REFIID rid, IUnknown* pUnk);
extern HRESULT __cdecl RecycleSurrogate(long lReasonCode);



extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0075_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0075_v0_0_s_ifspec;

#ifndef __ICrmLogControl_INTERFACE_DEFINED__
#define __ICrmLogControl_INTERFACE_DEFINED__

/* interface ICrmLogControl */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICrmLogControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A0E174B3-D26E-11d2-8F84-00805FC7BCD9")
    ICrmLogControl : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransactionUOW( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterCompensator( 
            /* [in] */ __RPC__in LPCWSTR lpcwstrProgIdCompensator,
            /* [in] */ __RPC__in LPCWSTR lpcwstrDescription,
            /* [in] */ LONG lCrmRegFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteLogRecordVariants( 
            /* [in] */ __RPC__in VARIANT *pLogRecord) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ForceLog( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ForgetLogRecord( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ForceTransactionToAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteLogRecord( 
            /* [size_is][in] */ __RPC__in_ecount_full(cBlob) BLOB rgBlob[  ],
            /* [in] */ ULONG cBlob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmLogControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrmLogControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrmLogControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrmLogControl * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionUOW )( 
            ICrmLogControl * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterCompensator )( 
            ICrmLogControl * This,
            /* [in] */ __RPC__in LPCWSTR lpcwstrProgIdCompensator,
            /* [in] */ __RPC__in LPCWSTR lpcwstrDescription,
            /* [in] */ LONG lCrmRegFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteLogRecordVariants )( 
            ICrmLogControl * This,
            /* [in] */ __RPC__in VARIANT *pLogRecord);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ForceLog )( 
            ICrmLogControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ForgetLogRecord )( 
            ICrmLogControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ForceTransactionToAbort )( 
            ICrmLogControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteLogRecord )( 
            ICrmLogControl * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cBlob) BLOB rgBlob[  ],
            /* [in] */ ULONG cBlob);
        
        END_INTERFACE
    } ICrmLogControlVtbl;

    interface ICrmLogControl
    {
        CONST_VTBL struct ICrmLogControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmLogControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICrmLogControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICrmLogControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICrmLogControl_get_TransactionUOW(This,pVal)	\
    ( (This)->lpVtbl -> get_TransactionUOW(This,pVal) ) 

#define ICrmLogControl_RegisterCompensator(This,lpcwstrProgIdCompensator,lpcwstrDescription,lCrmRegFlags)	\
    ( (This)->lpVtbl -> RegisterCompensator(This,lpcwstrProgIdCompensator,lpcwstrDescription,lCrmRegFlags) ) 

#define ICrmLogControl_WriteLogRecordVariants(This,pLogRecord)	\
    ( (This)->lpVtbl -> WriteLogRecordVariants(This,pLogRecord) ) 

#define ICrmLogControl_ForceLog(This)	\
    ( (This)->lpVtbl -> ForceLog(This) ) 

#define ICrmLogControl_ForgetLogRecord(This)	\
    ( (This)->lpVtbl -> ForgetLogRecord(This) ) 

#define ICrmLogControl_ForceTransactionToAbort(This)	\
    ( (This)->lpVtbl -> ForceTransactionToAbort(This) ) 

#define ICrmLogControl_WriteLogRecord(This,rgBlob,cBlob)	\
    ( (This)->lpVtbl -> WriteLogRecord(This,rgBlob,cBlob) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrmLogControl_INTERFACE_DEFINED__ */


#ifndef __ICrmCompensatorVariants_INTERFACE_DEFINED__
#define __ICrmCompensatorVariants_INTERFACE_DEFINED__

/* interface ICrmCompensatorVariants */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICrmCompensatorVariants;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0BAF8E4-7804-11d1-82E9-00A0C91EEDE9")
    ICrmCompensatorVariants : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLogControlVariants( 
            /* [in] */ __RPC__in_opt ICrmLogControl *pLogControl) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BeginPrepareVariants( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PrepareRecordVariants( 
            /* [in] */ __RPC__in VARIANT *pLogRecord,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbForget) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EndPrepareVariants( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbOkToPrepare) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BeginCommitVariants( 
            /* [in] */ VARIANT_BOOL bRecovery) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CommitRecordVariants( 
            /* [in] */ __RPC__in VARIANT *pLogRecord,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbForget) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EndCommitVariants( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BeginAbortVariants( 
            /* [in] */ VARIANT_BOOL bRecovery) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AbortRecordVariants( 
            /* [in] */ __RPC__in VARIANT *pLogRecord,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbForget) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EndAbortVariants( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmCompensatorVariantsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrmCompensatorVariants * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrmCompensatorVariants * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrmCompensatorVariants * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLogControlVariants )( 
            ICrmCompensatorVariants * This,
            /* [in] */ __RPC__in_opt ICrmLogControl *pLogControl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginPrepareVariants )( 
            ICrmCompensatorVariants * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PrepareRecordVariants )( 
            ICrmCompensatorVariants * This,
            /* [in] */ __RPC__in VARIANT *pLogRecord,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbForget);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndPrepareVariants )( 
            ICrmCompensatorVariants * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbOkToPrepare);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginCommitVariants )( 
            ICrmCompensatorVariants * This,
            /* [in] */ VARIANT_BOOL bRecovery);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CommitRecordVariants )( 
            ICrmCompensatorVariants * This,
            /* [in] */ __RPC__in VARIANT *pLogRecord,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbForget);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndCommitVariants )( 
            ICrmCompensatorVariants * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginAbortVariants )( 
            ICrmCompensatorVariants * This,
            /* [in] */ VARIANT_BOOL bRecovery);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AbortRecordVariants )( 
            ICrmCompensatorVariants * This,
            /* [in] */ __RPC__in VARIANT *pLogRecord,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbForget);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndAbortVariants )( 
            ICrmCompensatorVariants * This);
        
        END_INTERFACE
    } ICrmCompensatorVariantsVtbl;

    interface ICrmCompensatorVariants
    {
        CONST_VTBL struct ICrmCompensatorVariantsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmCompensatorVariants_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICrmCompensatorVariants_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICrmCompensatorVariants_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICrmCompensatorVariants_SetLogControlVariants(This,pLogControl)	\
    ( (This)->lpVtbl -> SetLogControlVariants(This,pLogControl) ) 

#define ICrmCompensatorVariants_BeginPrepareVariants(This)	\
    ( (This)->lpVtbl -> BeginPrepareVariants(This) ) 

#define ICrmCompensatorVariants_PrepareRecordVariants(This,pLogRecord,pbForget)	\
    ( (This)->lpVtbl -> PrepareRecordVariants(This,pLogRecord,pbForget) ) 

#define ICrmCompensatorVariants_EndPrepareVariants(This,pbOkToPrepare)	\
    ( (This)->lpVtbl -> EndPrepareVariants(This,pbOkToPrepare) ) 

#define ICrmCompensatorVariants_BeginCommitVariants(This,bRecovery)	\
    ( (This)->lpVtbl -> BeginCommitVariants(This,bRecovery) ) 

#define ICrmCompensatorVariants_CommitRecordVariants(This,pLogRecord,pbForget)	\
    ( (This)->lpVtbl -> CommitRecordVariants(This,pLogRecord,pbForget) ) 

#define ICrmCompensatorVariants_EndCommitVariants(This)	\
    ( (This)->lpVtbl -> EndCommitVariants(This) ) 

#define ICrmCompensatorVariants_BeginAbortVariants(This,bRecovery)	\
    ( (This)->lpVtbl -> BeginAbortVariants(This,bRecovery) ) 

#define ICrmCompensatorVariants_AbortRecordVariants(This,pLogRecord,pbForget)	\
    ( (This)->lpVtbl -> AbortRecordVariants(This,pLogRecord,pbForget) ) 

#define ICrmCompensatorVariants_EndAbortVariants(This)	\
    ( (This)->lpVtbl -> EndAbortVariants(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrmCompensatorVariants_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0077 */
/* [local] */ 

#ifndef _tagCrmLogRecordRead_
#define _tagCrmLogRecordRead_
typedef struct tagCrmLogRecordRead
    {
    DWORD dwCrmFlags;
    DWORD dwSequenceNumber;
    BLOB blobUserData;
    } 	CrmLogRecordRead;

#endif _tagCrmLogRecordRead_


extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0077_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0077_v0_0_s_ifspec;

#ifndef __ICrmCompensator_INTERFACE_DEFINED__
#define __ICrmCompensator_INTERFACE_DEFINED__

/* interface ICrmCompensator */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICrmCompensator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BBC01830-8D3B-11d1-82EC-00A0C91EEDE9")
    ICrmCompensator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetLogControl( 
            /* [in] */ __RPC__in_opt ICrmLogControl *pLogControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginPrepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrepareRecord( 
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ __RPC__out BOOL *pfForget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndPrepare( 
            /* [retval][out] */ __RPC__out BOOL *pfOkToPrepare) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCommit( 
            /* [in] */ BOOL fRecovery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitRecord( 
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ __RPC__out BOOL *pfForget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndCommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginAbort( 
            /* [in] */ BOOL fRecovery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortRecord( 
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ __RPC__out BOOL *pfForget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndAbort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmCompensatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrmCompensator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrmCompensator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrmCompensator * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogControl )( 
            ICrmCompensator * This,
            /* [in] */ __RPC__in_opt ICrmLogControl *pLogControl);
        
        HRESULT ( STDMETHODCALLTYPE *BeginPrepare )( 
            ICrmCompensator * This);
        
        HRESULT ( STDMETHODCALLTYPE *PrepareRecord )( 
            ICrmCompensator * This,
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ __RPC__out BOOL *pfForget);
        
        HRESULT ( STDMETHODCALLTYPE *EndPrepare )( 
            ICrmCompensator * This,
            /* [retval][out] */ __RPC__out BOOL *pfOkToPrepare);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCommit )( 
            ICrmCompensator * This,
            /* [in] */ BOOL fRecovery);
        
        HRESULT ( STDMETHODCALLTYPE *CommitRecord )( 
            ICrmCompensator * This,
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ __RPC__out BOOL *pfForget);
        
        HRESULT ( STDMETHODCALLTYPE *EndCommit )( 
            ICrmCompensator * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginAbort )( 
            ICrmCompensator * This,
            /* [in] */ BOOL fRecovery);
        
        HRESULT ( STDMETHODCALLTYPE *AbortRecord )( 
            ICrmCompensator * This,
            /* [in] */ CrmLogRecordRead crmLogRec,
            /* [retval][out] */ __RPC__out BOOL *pfForget);
        
        HRESULT ( STDMETHODCALLTYPE *EndAbort )( 
            ICrmCompensator * This);
        
        END_INTERFACE
    } ICrmCompensatorVtbl;

    interface ICrmCompensator
    {
        CONST_VTBL struct ICrmCompensatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmCompensator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICrmCompensator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICrmCompensator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICrmCompensator_SetLogControl(This,pLogControl)	\
    ( (This)->lpVtbl -> SetLogControl(This,pLogControl) ) 

#define ICrmCompensator_BeginPrepare(This)	\
    ( (This)->lpVtbl -> BeginPrepare(This) ) 

#define ICrmCompensator_PrepareRecord(This,crmLogRec,pfForget)	\
    ( (This)->lpVtbl -> PrepareRecord(This,crmLogRec,pfForget) ) 

#define ICrmCompensator_EndPrepare(This,pfOkToPrepare)	\
    ( (This)->lpVtbl -> EndPrepare(This,pfOkToPrepare) ) 

#define ICrmCompensator_BeginCommit(This,fRecovery)	\
    ( (This)->lpVtbl -> BeginCommit(This,fRecovery) ) 

#define ICrmCompensator_CommitRecord(This,crmLogRec,pfForget)	\
    ( (This)->lpVtbl -> CommitRecord(This,crmLogRec,pfForget) ) 

#define ICrmCompensator_EndCommit(This)	\
    ( (This)->lpVtbl -> EndCommit(This) ) 

#define ICrmCompensator_BeginAbort(This,fRecovery)	\
    ( (This)->lpVtbl -> BeginAbort(This,fRecovery) ) 

#define ICrmCompensator_AbortRecord(This,crmLogRec,pfForget)	\
    ( (This)->lpVtbl -> AbortRecord(This,crmLogRec,pfForget) ) 

#define ICrmCompensator_EndAbort(This)	\
    ( (This)->lpVtbl -> EndAbort(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrmCompensator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0078 */
/* [local] */ 

#ifndef _tagCrmTransactionState_
#define _tagCrmTransactionState_
typedef 
enum tagCrmTransactionState
    {	TxState_Active	= 0,
	TxState_Committed	= ( TxState_Active + 1 ) ,
	TxState_Aborted	= ( TxState_Committed + 1 ) ,
	TxState_Indoubt	= ( TxState_Aborted + 1 ) 
    } 	CrmTransactionState;

#endif _tagCrmTransactionState_


extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0078_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0078_v0_0_s_ifspec;

#ifndef __ICrmMonitorLogRecords_INTERFACE_DEFINED__
#define __ICrmMonitorLogRecords_INTERFACE_DEFINED__

/* interface ICrmMonitorLogRecords */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICrmMonitorLogRecords;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70C8E441-C7ED-11d1-82FB-00A0C91EEDE9")
    ICrmMonitorLogRecords : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransactionState( 
            /* [retval][out] */ __RPC__out CrmTransactionState *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StructuredRecords( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLogRecord( 
            /* [in] */ DWORD dwIndex,
            /* [out][in] */ __RPC__inout CrmLogRecordRead *pCrmLogRec) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLogRecordVariants( 
            /* [in] */ VARIANT IndexNumber,
            /* [retval][out] */ __RPC__out LPVARIANT pLogRecord) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmMonitorLogRecordsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrmMonitorLogRecords * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrmMonitorLogRecords * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrmMonitorLogRecords * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ICrmMonitorLogRecords * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionState )( 
            ICrmMonitorLogRecords * This,
            /* [retval][out] */ __RPC__out CrmTransactionState *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StructuredRecords )( 
            ICrmMonitorLogRecords * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLogRecord )( 
            ICrmMonitorLogRecords * This,
            /* [in] */ DWORD dwIndex,
            /* [out][in] */ __RPC__inout CrmLogRecordRead *pCrmLogRec);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLogRecordVariants )( 
            ICrmMonitorLogRecords * This,
            /* [in] */ VARIANT IndexNumber,
            /* [retval][out] */ __RPC__out LPVARIANT pLogRecord);
        
        END_INTERFACE
    } ICrmMonitorLogRecordsVtbl;

    interface ICrmMonitorLogRecords
    {
        CONST_VTBL struct ICrmMonitorLogRecordsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmMonitorLogRecords_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICrmMonitorLogRecords_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICrmMonitorLogRecords_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICrmMonitorLogRecords_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define ICrmMonitorLogRecords_get_TransactionState(This,pVal)	\
    ( (This)->lpVtbl -> get_TransactionState(This,pVal) ) 

#define ICrmMonitorLogRecords_get_StructuredRecords(This,pVal)	\
    ( (This)->lpVtbl -> get_StructuredRecords(This,pVal) ) 

#define ICrmMonitorLogRecords_GetLogRecord(This,dwIndex,pCrmLogRec)	\
    ( (This)->lpVtbl -> GetLogRecord(This,dwIndex,pCrmLogRec) ) 

#define ICrmMonitorLogRecords_GetLogRecordVariants(This,IndexNumber,pLogRecord)	\
    ( (This)->lpVtbl -> GetLogRecordVariants(This,IndexNumber,pLogRecord) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrmMonitorLogRecords_INTERFACE_DEFINED__ */


#ifndef __ICrmMonitorClerks_INTERFACE_DEFINED__
#define __ICrmMonitorClerks_INTERFACE_DEFINED__

/* interface ICrmMonitorClerks */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrmMonitorClerks;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70C8E442-C7ED-11d1-82FB-00A0C91EEDE9")
    ICrmMonitorClerks : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem) = 0;
        
        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProgIdCompensator( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Description( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TransactionUOW( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ActivityId( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmMonitorClerksVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrmMonitorClerks * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrmMonitorClerks * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrmMonitorClerks * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrmMonitorClerks * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrmMonitorClerks * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrmMonitorClerks * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrmMonitorClerks * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            ICrmMonitorClerks * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem);
        
        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ICrmMonitorClerks * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ICrmMonitorClerks * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ProgIdCompensator )( 
            ICrmMonitorClerks * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Description )( 
            ICrmMonitorClerks * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *TransactionUOW )( 
            ICrmMonitorClerks * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ActivityId )( 
            ICrmMonitorClerks * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem);
        
        END_INTERFACE
    } ICrmMonitorClerksVtbl;

    interface ICrmMonitorClerks
    {
        CONST_VTBL struct ICrmMonitorClerksVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmMonitorClerks_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICrmMonitorClerks_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICrmMonitorClerks_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICrmMonitorClerks_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICrmMonitorClerks_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICrmMonitorClerks_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICrmMonitorClerks_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICrmMonitorClerks_Item(This,Index,pItem)	\
    ( (This)->lpVtbl -> Item(This,Index,pItem) ) 

#define ICrmMonitorClerks_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define ICrmMonitorClerks_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define ICrmMonitorClerks_ProgIdCompensator(This,Index,pItem)	\
    ( (This)->lpVtbl -> ProgIdCompensator(This,Index,pItem) ) 

#define ICrmMonitorClerks_Description(This,Index,pItem)	\
    ( (This)->lpVtbl -> Description(This,Index,pItem) ) 

#define ICrmMonitorClerks_TransactionUOW(This,Index,pItem)	\
    ( (This)->lpVtbl -> TransactionUOW(This,Index,pItem) ) 

#define ICrmMonitorClerks_ActivityId(This,Index,pItem)	\
    ( (This)->lpVtbl -> ActivityId(This,Index,pItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrmMonitorClerks_INTERFACE_DEFINED__ */


#ifndef __ICrmMonitor_INTERFACE_DEFINED__
#define __ICrmMonitor_INTERFACE_DEFINED__

/* interface ICrmMonitor */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICrmMonitor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70C8E443-C7ED-11d1-82FB-00A0C91EEDE9")
    ICrmMonitor : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetClerks( 
            /* [retval][out] */ __RPC__deref_out_opt ICrmMonitorClerks **pClerks) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HoldClerk( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmMonitorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrmMonitor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrmMonitor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrmMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetClerks )( 
            ICrmMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt ICrmMonitorClerks **pClerks);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HoldClerk )( 
            ICrmMonitor * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__out LPVARIANT pItem);
        
        END_INTERFACE
    } ICrmMonitorVtbl;

    interface ICrmMonitor
    {
        CONST_VTBL struct ICrmMonitorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmMonitor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICrmMonitor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICrmMonitor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICrmMonitor_GetClerks(This,pClerks)	\
    ( (This)->lpVtbl -> GetClerks(This,pClerks) ) 

#define ICrmMonitor_HoldClerk(This,Index,pItem)	\
    ( (This)->lpVtbl -> HoldClerk(This,Index,pItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrmMonitor_INTERFACE_DEFINED__ */


#ifndef __ICrmFormatLogRecords_INTERFACE_DEFINED__
#define __ICrmFormatLogRecords_INTERFACE_DEFINED__

/* interface ICrmFormatLogRecords */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICrmFormatLogRecords;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C51D821-C98B-11d1-82FB-00A0C91EEDE9")
    ICrmFormatLogRecords : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetColumnCount( 
            /* [out] */ __RPC__out long *plColumnCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetColumnHeaders( 
            /* [out] */ __RPC__out LPVARIANT pHeaders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetColumn( 
            /* [in] */ CrmLogRecordRead CrmLogRec,
            /* [out] */ __RPC__out LPVARIANT pFormattedLogRecord) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetColumnVariants( 
            /* [in] */ VARIANT LogRecord,
            /* [out] */ __RPC__out LPVARIANT pFormattedLogRecord) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrmFormatLogRecordsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrmFormatLogRecords * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrmFormatLogRecords * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrmFormatLogRecords * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetColumnCount )( 
            ICrmFormatLogRecords * This,
            /* [out] */ __RPC__out long *plColumnCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetColumnHeaders )( 
            ICrmFormatLogRecords * This,
            /* [out] */ __RPC__out LPVARIANT pHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetColumn )( 
            ICrmFormatLogRecords * This,
            /* [in] */ CrmLogRecordRead CrmLogRec,
            /* [out] */ __RPC__out LPVARIANT pFormattedLogRecord);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetColumnVariants )( 
            ICrmFormatLogRecords * This,
            /* [in] */ VARIANT LogRecord,
            /* [out] */ __RPC__out LPVARIANT pFormattedLogRecord);
        
        END_INTERFACE
    } ICrmFormatLogRecordsVtbl;

    interface ICrmFormatLogRecords
    {
        CONST_VTBL struct ICrmFormatLogRecordsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrmFormatLogRecords_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICrmFormatLogRecords_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICrmFormatLogRecords_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICrmFormatLogRecords_GetColumnCount(This,plColumnCount)	\
    ( (This)->lpVtbl -> GetColumnCount(This,plColumnCount) ) 

#define ICrmFormatLogRecords_GetColumnHeaders(This,pHeaders)	\
    ( (This)->lpVtbl -> GetColumnHeaders(This,pHeaders) ) 

#define ICrmFormatLogRecords_GetColumn(This,CrmLogRec,pFormattedLogRecord)	\
    ( (This)->lpVtbl -> GetColumn(This,CrmLogRec,pFormattedLogRecord) ) 

#define ICrmFormatLogRecords_GetColumnVariants(This,LogRecord,pFormattedLogRecord)	\
    ( (This)->lpVtbl -> GetColumnVariants(This,LogRecord,pFormattedLogRecord) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrmFormatLogRecords_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0082 */
/* [local] */ 

typedef 
enum tagCSC_InheritanceConfig
    {	CSC_Inherit	= 0,
	CSC_Ignore	= ( CSC_Inherit + 1 ) 
    } 	CSC_InheritanceConfig;

typedef 
enum tagCSC_ThreadPool
    {	CSC_ThreadPoolNone	= 0,
	CSC_ThreadPoolInherit	= ( CSC_ThreadPoolNone + 1 ) ,
	CSC_STAThreadPool	= ( CSC_ThreadPoolInherit + 1 ) ,
	CSC_MTAThreadPool	= ( CSC_STAThreadPool + 1 ) 
    } 	CSC_ThreadPool;

typedef 
enum tagCSC_Binding
    {	CSC_NoBinding	= 0,
	CSC_BindToPoolThread	= ( CSC_NoBinding + 1 ) 
    } 	CSC_Binding;

typedef 
enum tagCSC_TransactionConfig
    {	CSC_NoTransaction	= 0,
	CSC_IfContainerIsTransactional	= ( CSC_NoTransaction + 1 ) ,
	CSC_CreateTransactionIfNecessary	= ( CSC_IfContainerIsTransactional + 1 ) ,
	CSC_NewTransaction	= ( CSC_CreateTransactionIfNecessary + 1 ) 
    } 	CSC_TransactionConfig;

typedef 
enum tagCSC_SynchronizationConfig
    {	CSC_NoSynchronization	= 0,
	CSC_IfContainerIsSynchronized	= ( CSC_NoSynchronization + 1 ) ,
	CSC_NewSynchronizationIfNecessary	= ( CSC_IfContainerIsSynchronized + 1 ) ,
	CSC_NewSynchronization	= ( CSC_NewSynchronizationIfNecessary + 1 ) 
    } 	CSC_SynchronizationConfig;

typedef 
enum tagCSC_TrackerConfig
    {	CSC_DontUseTracker	= 0,
	CSC_UseTracker	= ( CSC_DontUseTracker + 1 ) 
    } 	CSC_TrackerConfig;

typedef 
enum tagCSC_PartitionConfig
    {	CSC_NoPartition	= 0,
	CSC_InheritPartition	= ( CSC_NoPartition + 1 ) ,
	CSC_NewPartition	= ( CSC_InheritPartition + 1 ) 
    } 	CSC_PartitionConfig;

typedef 
enum tagCSC_IISIntrinsicsConfig
    {	CSC_NoIISIntrinsics	= 0,
	CSC_InheritIISIntrinsics	= ( CSC_NoIISIntrinsics + 1 ) 
    } 	CSC_IISIntrinsicsConfig;

typedef 
enum tagCSC_COMTIIntrinsicsConfig
    {	CSC_NoCOMTIIntrinsics	= 0,
	CSC_InheritCOMTIIntrinsics	= ( CSC_NoCOMTIIntrinsics + 1 ) 
    } 	CSC_COMTIIntrinsicsConfig;

typedef 
enum tagCSC_SxsConfig
    {	CSC_NoSxs	= 0,
	CSC_InheritSxs	= ( CSC_NoSxs + 1 ) ,
	CSC_NewSxs	= ( CSC_InheritSxs + 1 ) 
    } 	CSC_SxsConfig;



extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0082_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0082_v0_0_s_ifspec;

#ifndef __IServiceIISIntrinsicsConfig_INTERFACE_DEFINED__
#define __IServiceIISIntrinsicsConfig_INTERFACE_DEFINED__

/* interface IServiceIISIntrinsicsConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceIISIntrinsicsConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1a0cf920-d452-46f4-bc36-48118d54ea52")
    IServiceIISIntrinsicsConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IISIntrinsicsConfig( 
            /* [in] */ CSC_IISIntrinsicsConfig iisIntrinsicsConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceIISIntrinsicsConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceIISIntrinsicsConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceIISIntrinsicsConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceIISIntrinsicsConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *IISIntrinsicsConfig )( 
            IServiceIISIntrinsicsConfig * This,
            /* [in] */ CSC_IISIntrinsicsConfig iisIntrinsicsConfig);
        
        END_INTERFACE
    } IServiceIISIntrinsicsConfigVtbl;

    interface IServiceIISIntrinsicsConfig
    {
        CONST_VTBL struct IServiceIISIntrinsicsConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceIISIntrinsicsConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceIISIntrinsicsConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceIISIntrinsicsConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceIISIntrinsicsConfig_IISIntrinsicsConfig(This,iisIntrinsicsConfig)	\
    ( (This)->lpVtbl -> IISIntrinsicsConfig(This,iisIntrinsicsConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceIISIntrinsicsConfig_INTERFACE_DEFINED__ */


#ifndef __IServiceComTIIntrinsicsConfig_INTERFACE_DEFINED__
#define __IServiceComTIIntrinsicsConfig_INTERFACE_DEFINED__

/* interface IServiceComTIIntrinsicsConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceComTIIntrinsicsConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09e6831e-04e1-4ed4-9d0f-e8b168bafeaf")
    IServiceComTIIntrinsicsConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComTIIntrinsicsConfig( 
            /* [in] */ CSC_COMTIIntrinsicsConfig comtiIntrinsicsConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceComTIIntrinsicsConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceComTIIntrinsicsConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceComTIIntrinsicsConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceComTIIntrinsicsConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *ComTIIntrinsicsConfig )( 
            IServiceComTIIntrinsicsConfig * This,
            /* [in] */ CSC_COMTIIntrinsicsConfig comtiIntrinsicsConfig);
        
        END_INTERFACE
    } IServiceComTIIntrinsicsConfigVtbl;

    interface IServiceComTIIntrinsicsConfig
    {
        CONST_VTBL struct IServiceComTIIntrinsicsConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceComTIIntrinsicsConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceComTIIntrinsicsConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceComTIIntrinsicsConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceComTIIntrinsicsConfig_ComTIIntrinsicsConfig(This,comtiIntrinsicsConfig)	\
    ( (This)->lpVtbl -> ComTIIntrinsicsConfig(This,comtiIntrinsicsConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceComTIIntrinsicsConfig_INTERFACE_DEFINED__ */


#ifndef __IServiceSxsConfig_INTERFACE_DEFINED__
#define __IServiceSxsConfig_INTERFACE_DEFINED__

/* interface IServiceSxsConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceSxsConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c7cd7379-f3f2-4634-811b-703281d73e08")
    IServiceSxsConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SxsConfig( 
            /* [in] */ CSC_SxsConfig scsConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SxsName( 
            /* [string][in] */ __RPC__in LPCWSTR szSxsName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SxsDirectory( 
            /* [string][in] */ __RPC__in LPCWSTR szSxsDirectory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceSxsConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceSxsConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceSxsConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceSxsConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SxsConfig )( 
            IServiceSxsConfig * This,
            /* [in] */ CSC_SxsConfig scsConfig);
        
        HRESULT ( STDMETHODCALLTYPE *SxsName )( 
            IServiceSxsConfig * This,
            /* [string][in] */ __RPC__in LPCWSTR szSxsName);
        
        HRESULT ( STDMETHODCALLTYPE *SxsDirectory )( 
            IServiceSxsConfig * This,
            /* [string][in] */ __RPC__in LPCWSTR szSxsDirectory);
        
        END_INTERFACE
    } IServiceSxsConfigVtbl;

    interface IServiceSxsConfig
    {
        CONST_VTBL struct IServiceSxsConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceSxsConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceSxsConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceSxsConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceSxsConfig_SxsConfig(This,scsConfig)	\
    ( (This)->lpVtbl -> SxsConfig(This,scsConfig) ) 

#define IServiceSxsConfig_SxsName(This,szSxsName)	\
    ( (This)->lpVtbl -> SxsName(This,szSxsName) ) 

#define IServiceSxsConfig_SxsDirectory(This,szSxsDirectory)	\
    ( (This)->lpVtbl -> SxsDirectory(This,szSxsDirectory) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceSxsConfig_INTERFACE_DEFINED__ */


#ifndef __ICheckSxsConfig_INTERFACE_DEFINED__
#define __ICheckSxsConfig_INTERFACE_DEFINED__

/* interface ICheckSxsConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICheckSxsConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0FF5A96F-11FC-47d1-BAA6-25DD347E7242")
    ICheckSxsConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSameSxsConfig( 
            /* [string][in] */ LPCWSTR wszSxsName,
            /* [string][in] */ LPCWSTR wszSxsDirectory,
            /* [string][in] */ LPCWSTR wszSxsAppName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICheckSxsConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICheckSxsConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICheckSxsConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICheckSxsConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSameSxsConfig )( 
            ICheckSxsConfig * This,
            /* [string][in] */ LPCWSTR wszSxsName,
            /* [string][in] */ LPCWSTR wszSxsDirectory,
            /* [string][in] */ LPCWSTR wszSxsAppName);
        
        END_INTERFACE
    } ICheckSxsConfigVtbl;

    interface ICheckSxsConfig
    {
        CONST_VTBL struct ICheckSxsConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICheckSxsConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICheckSxsConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICheckSxsConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICheckSxsConfig_IsSameSxsConfig(This,wszSxsName,wszSxsDirectory,wszSxsAppName)	\
    ( (This)->lpVtbl -> IsSameSxsConfig(This,wszSxsName,wszSxsDirectory,wszSxsAppName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICheckSxsConfig_INTERFACE_DEFINED__ */


#ifndef __IServiceInheritanceConfig_INTERFACE_DEFINED__
#define __IServiceInheritanceConfig_INTERFACE_DEFINED__

/* interface IServiceInheritanceConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceInheritanceConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92186771-d3b4-4d77-a8ea-ee842d586f35")
    IServiceInheritanceConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ContainingContextTreatment( 
            /* [in] */ CSC_InheritanceConfig inheritanceConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceInheritanceConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceInheritanceConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceInheritanceConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceInheritanceConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *ContainingContextTreatment )( 
            IServiceInheritanceConfig * This,
            /* [in] */ CSC_InheritanceConfig inheritanceConfig);
        
        END_INTERFACE
    } IServiceInheritanceConfigVtbl;

    interface IServiceInheritanceConfig
    {
        CONST_VTBL struct IServiceInheritanceConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceInheritanceConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceInheritanceConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceInheritanceConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceInheritanceConfig_ContainingContextTreatment(This,inheritanceConfig)	\
    ( (This)->lpVtbl -> ContainingContextTreatment(This,inheritanceConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceInheritanceConfig_INTERFACE_DEFINED__ */


#ifndef __IServiceThreadPoolConfig_INTERFACE_DEFINED__
#define __IServiceThreadPoolConfig_INTERFACE_DEFINED__

/* interface IServiceThreadPoolConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceThreadPoolConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("186d89bc-f277-4bcc-80d5-4df7b836ef4a")
    IServiceThreadPoolConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SelectThreadPool( 
            /* [in] */ CSC_ThreadPool threadPool) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBindingInfo( 
            /* [in] */ CSC_Binding binding) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceThreadPoolConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceThreadPoolConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceThreadPoolConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceThreadPoolConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectThreadPool )( 
            IServiceThreadPoolConfig * This,
            /* [in] */ CSC_ThreadPool threadPool);
        
        HRESULT ( STDMETHODCALLTYPE *SetBindingInfo )( 
            IServiceThreadPoolConfig * This,
            /* [in] */ CSC_Binding binding);
        
        END_INTERFACE
    } IServiceThreadPoolConfigVtbl;

    interface IServiceThreadPoolConfig
    {
        CONST_VTBL struct IServiceThreadPoolConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceThreadPoolConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceThreadPoolConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceThreadPoolConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceThreadPoolConfig_SelectThreadPool(This,threadPool)	\
    ( (This)->lpVtbl -> SelectThreadPool(This,threadPool) ) 

#define IServiceThreadPoolConfig_SetBindingInfo(This,binding)	\
    ( (This)->lpVtbl -> SetBindingInfo(This,binding) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceThreadPoolConfig_INTERFACE_DEFINED__ */


#ifndef __IServiceTransactionConfigBase_INTERFACE_DEFINED__
#define __IServiceTransactionConfigBase_INTERFACE_DEFINED__

/* interface IServiceTransactionConfigBase */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceTransactionConfigBase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("772b3fbe-6ffd-42fb-b5f8-8f9b260f3810")
    IServiceTransactionConfigBase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConfigureTransaction( 
            /* [in] */ CSC_TransactionConfig transactionConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsolationLevel( 
            /* [in] */ COMAdminTxIsolationLevelOptions option) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TransactionTimeout( 
            /* [in] */ ULONG ulTimeoutSec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringYourOwnTransaction( 
            /* [string][in] */ __RPC__in LPCWSTR szTipURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewTransactionDescription( 
            /* [string][in] */ __RPC__in LPCWSTR szTxDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceTransactionConfigBaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceTransactionConfigBase * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceTransactionConfigBase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceTransactionConfigBase * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureTransaction )( 
            IServiceTransactionConfigBase * This,
            /* [in] */ CSC_TransactionConfig transactionConfig);
        
        HRESULT ( STDMETHODCALLTYPE *IsolationLevel )( 
            IServiceTransactionConfigBase * This,
            /* [in] */ COMAdminTxIsolationLevelOptions option);
        
        HRESULT ( STDMETHODCALLTYPE *TransactionTimeout )( 
            IServiceTransactionConfigBase * This,
            /* [in] */ ULONG ulTimeoutSec);
        
        HRESULT ( STDMETHODCALLTYPE *BringYourOwnTransaction )( 
            IServiceTransactionConfigBase * This,
            /* [string][in] */ __RPC__in LPCWSTR szTipURL);
        
        HRESULT ( STDMETHODCALLTYPE *NewTransactionDescription )( 
            IServiceTransactionConfigBase * This,
            /* [string][in] */ __RPC__in LPCWSTR szTxDesc);
        
        END_INTERFACE
    } IServiceTransactionConfigBaseVtbl;

    interface IServiceTransactionConfigBase
    {
        CONST_VTBL struct IServiceTransactionConfigBaseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceTransactionConfigBase_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceTransactionConfigBase_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceTransactionConfigBase_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceTransactionConfigBase_ConfigureTransaction(This,transactionConfig)	\
    ( (This)->lpVtbl -> ConfigureTransaction(This,transactionConfig) ) 

#define IServiceTransactionConfigBase_IsolationLevel(This,option)	\
    ( (This)->lpVtbl -> IsolationLevel(This,option) ) 

#define IServiceTransactionConfigBase_TransactionTimeout(This,ulTimeoutSec)	\
    ( (This)->lpVtbl -> TransactionTimeout(This,ulTimeoutSec) ) 

#define IServiceTransactionConfigBase_BringYourOwnTransaction(This,szTipURL)	\
    ( (This)->lpVtbl -> BringYourOwnTransaction(This,szTipURL) ) 

#define IServiceTransactionConfigBase_NewTransactionDescription(This,szTxDesc)	\
    ( (This)->lpVtbl -> NewTransactionDescription(This,szTxDesc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceTransactionConfigBase_INTERFACE_DEFINED__ */


#ifndef __IServiceTransactionConfig_INTERFACE_DEFINED__
#define __IServiceTransactionConfig_INTERFACE_DEFINED__

/* interface IServiceTransactionConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceTransactionConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59f4c2a3-d3d7-4a31-b6e4-6ab3177c50b9")
    IServiceTransactionConfig : public IServiceTransactionConfigBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConfigureBYOT( 
            /* [in] */ __RPC__in_opt ITransaction *pITxByot) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceTransactionConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceTransactionConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceTransactionConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceTransactionConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureTransaction )( 
            IServiceTransactionConfig * This,
            /* [in] */ CSC_TransactionConfig transactionConfig);
        
        HRESULT ( STDMETHODCALLTYPE *IsolationLevel )( 
            IServiceTransactionConfig * This,
            /* [in] */ COMAdminTxIsolationLevelOptions option);
        
        HRESULT ( STDMETHODCALLTYPE *TransactionTimeout )( 
            IServiceTransactionConfig * This,
            /* [in] */ ULONG ulTimeoutSec);
        
        HRESULT ( STDMETHODCALLTYPE *BringYourOwnTransaction )( 
            IServiceTransactionConfig * This,
            /* [string][in] */ __RPC__in LPCWSTR szTipURL);
        
        HRESULT ( STDMETHODCALLTYPE *NewTransactionDescription )( 
            IServiceTransactionConfig * This,
            /* [string][in] */ __RPC__in LPCWSTR szTxDesc);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureBYOT )( 
            IServiceTransactionConfig * This,
            /* [in] */ __RPC__in_opt ITransaction *pITxByot);
        
        END_INTERFACE
    } IServiceTransactionConfigVtbl;

    interface IServiceTransactionConfig
    {
        CONST_VTBL struct IServiceTransactionConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceTransactionConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceTransactionConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceTransactionConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceTransactionConfig_ConfigureTransaction(This,transactionConfig)	\
    ( (This)->lpVtbl -> ConfigureTransaction(This,transactionConfig) ) 

#define IServiceTransactionConfig_IsolationLevel(This,option)	\
    ( (This)->lpVtbl -> IsolationLevel(This,option) ) 

#define IServiceTransactionConfig_TransactionTimeout(This,ulTimeoutSec)	\
    ( (This)->lpVtbl -> TransactionTimeout(This,ulTimeoutSec) ) 

#define IServiceTransactionConfig_BringYourOwnTransaction(This,szTipURL)	\
    ( (This)->lpVtbl -> BringYourOwnTransaction(This,szTipURL) ) 

#define IServiceTransactionConfig_NewTransactionDescription(This,szTxDesc)	\
    ( (This)->lpVtbl -> NewTransactionDescription(This,szTxDesc) ) 


#define IServiceTransactionConfig_ConfigureBYOT(This,pITxByot)	\
    ( (This)->lpVtbl -> ConfigureBYOT(This,pITxByot) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceTransactionConfig_INTERFACE_DEFINED__ */


#ifndef __IServiceSysTxnConfig_INTERFACE_DEFINED__
#define __IServiceSysTxnConfig_INTERFACE_DEFINED__

/* interface IServiceSysTxnConfig */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IServiceSysTxnConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33CAF1A1-FCB8-472b-B45E-967448DED6D8")
    IServiceSysTxnConfig : public IServiceTransactionConfig
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConfigureBYOTSysTxn( 
            /* [in] */ ITransactionProxy *pTxProxy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceSysTxnConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceSysTxnConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceSysTxnConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceSysTxnConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureTransaction )( 
            IServiceSysTxnConfig * This,
            /* [in] */ CSC_TransactionConfig transactionConfig);
        
        HRESULT ( STDMETHODCALLTYPE *IsolationLevel )( 
            IServiceSysTxnConfig * This,
            /* [in] */ COMAdminTxIsolationLevelOptions option);
        
        HRESULT ( STDMETHODCALLTYPE *TransactionTimeout )( 
            IServiceSysTxnConfig * This,
            /* [in] */ ULONG ulTimeoutSec);
        
        HRESULT ( STDMETHODCALLTYPE *BringYourOwnTransaction )( 
            IServiceSysTxnConfig * This,
            /* [string][in] */ LPCWSTR szTipURL);
        
        HRESULT ( STDMETHODCALLTYPE *NewTransactionDescription )( 
            IServiceSysTxnConfig * This,
            /* [string][in] */ LPCWSTR szTxDesc);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureBYOT )( 
            IServiceSysTxnConfig * This,
            /* [in] */ ITransaction *pITxByot);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureBYOTSysTxn )( 
            IServiceSysTxnConfig * This,
            /* [in] */ ITransactionProxy *pTxProxy);
        
        END_INTERFACE
    } IServiceSysTxnConfigVtbl;

    interface IServiceSysTxnConfig
    {
        CONST_VTBL struct IServiceSysTxnConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceSysTxnConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceSysTxnConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceSysTxnConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceSysTxnConfig_ConfigureTransaction(This,transactionConfig)	\
    ( (This)->lpVtbl -> ConfigureTransaction(This,transactionConfig) ) 

#define IServiceSysTxnConfig_IsolationLevel(This,option)	\
    ( (This)->lpVtbl -> IsolationLevel(This,option) ) 

#define IServiceSysTxnConfig_TransactionTimeout(This,ulTimeoutSec)	\
    ( (This)->lpVtbl -> TransactionTimeout(This,ulTimeoutSec) ) 

#define IServiceSysTxnConfig_BringYourOwnTransaction(This,szTipURL)	\
    ( (This)->lpVtbl -> BringYourOwnTransaction(This,szTipURL) ) 

#define IServiceSysTxnConfig_NewTransactionDescription(This,szTxDesc)	\
    ( (This)->lpVtbl -> NewTransactionDescription(This,szTxDesc) ) 


#define IServiceSysTxnConfig_ConfigureBYOT(This,pITxByot)	\
    ( (This)->lpVtbl -> ConfigureBYOT(This,pITxByot) ) 


#define IServiceSysTxnConfig_ConfigureBYOTSysTxn(This,pTxProxy)	\
    ( (This)->lpVtbl -> ConfigureBYOTSysTxn(This,pTxProxy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceSysTxnConfig_INTERFACE_DEFINED__ */


#ifndef __IServiceSynchronizationConfig_INTERFACE_DEFINED__
#define __IServiceSynchronizationConfig_INTERFACE_DEFINED__

/* interface IServiceSynchronizationConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceSynchronizationConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fd880e81-6dce-4c58-af83-a208846c0030")
    IServiceSynchronizationConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConfigureSynchronization( 
            /* [in] */ CSC_SynchronizationConfig synchConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceSynchronizationConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceSynchronizationConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceSynchronizationConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceSynchronizationConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureSynchronization )( 
            IServiceSynchronizationConfig * This,
            /* [in] */ CSC_SynchronizationConfig synchConfig);
        
        END_INTERFACE
    } IServiceSynchronizationConfigVtbl;

    interface IServiceSynchronizationConfig
    {
        CONST_VTBL struct IServiceSynchronizationConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceSynchronizationConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceSynchronizationConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceSynchronizationConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceSynchronizationConfig_ConfigureSynchronization(This,synchConfig)	\
    ( (This)->lpVtbl -> ConfigureSynchronization(This,synchConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceSynchronizationConfig_INTERFACE_DEFINED__ */


#ifndef __IServiceTrackerConfig_INTERFACE_DEFINED__
#define __IServiceTrackerConfig_INTERFACE_DEFINED__

/* interface IServiceTrackerConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceTrackerConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6c3a3e1d-0ba6-4036-b76f-d0404db816c9")
    IServiceTrackerConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TrackerConfig( 
            /* [in] */ CSC_TrackerConfig trackerConfig,
            /* [string][in] */ __RPC__in LPCWSTR szTrackerAppName,
            /* [string][in] */ __RPC__in LPCWSTR szTrackerCtxName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceTrackerConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceTrackerConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceTrackerConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceTrackerConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *TrackerConfig )( 
            IServiceTrackerConfig * This,
            /* [in] */ CSC_TrackerConfig trackerConfig,
            /* [string][in] */ __RPC__in LPCWSTR szTrackerAppName,
            /* [string][in] */ __RPC__in LPCWSTR szTrackerCtxName);
        
        END_INTERFACE
    } IServiceTrackerConfigVtbl;

    interface IServiceTrackerConfig
    {
        CONST_VTBL struct IServiceTrackerConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceTrackerConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceTrackerConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceTrackerConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceTrackerConfig_TrackerConfig(This,trackerConfig,szTrackerAppName,szTrackerCtxName)	\
    ( (This)->lpVtbl -> TrackerConfig(This,trackerConfig,szTrackerAppName,szTrackerCtxName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceTrackerConfig_INTERFACE_DEFINED__ */


#ifndef __IServicePartitionConfig_INTERFACE_DEFINED__
#define __IServicePartitionConfig_INTERFACE_DEFINED__

/* interface IServicePartitionConfig */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServicePartitionConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80182d03-5ea4-4831-ae97-55beffc2e590")
    IServicePartitionConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PartitionConfig( 
            /* [in] */ CSC_PartitionConfig partitionConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PartitionID( 
            /* [in] */ __RPC__in REFGUID guidPartitionID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServicePartitionConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServicePartitionConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServicePartitionConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServicePartitionConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *PartitionConfig )( 
            IServicePartitionConfig * This,
            /* [in] */ CSC_PartitionConfig partitionConfig);
        
        HRESULT ( STDMETHODCALLTYPE *PartitionID )( 
            IServicePartitionConfig * This,
            /* [in] */ __RPC__in REFGUID guidPartitionID);
        
        END_INTERFACE
    } IServicePartitionConfigVtbl;

    interface IServicePartitionConfig
    {
        CONST_VTBL struct IServicePartitionConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServicePartitionConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServicePartitionConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServicePartitionConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServicePartitionConfig_PartitionConfig(This,partitionConfig)	\
    ( (This)->lpVtbl -> PartitionConfig(This,partitionConfig) ) 

#define IServicePartitionConfig_PartitionID(This,guidPartitionID)	\
    ( (This)->lpVtbl -> PartitionID(This,guidPartitionID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServicePartitionConfig_INTERFACE_DEFINED__ */


#ifndef __IServiceCall_INTERFACE_DEFINED__
#define __IServiceCall_INTERFACE_DEFINED__

/* interface IServiceCall */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BD3E2E12-42DD-40f4-A09A-95A50C58304B")
    IServiceCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCall( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceCall * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceCall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceCall * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCall )( 
            IServiceCall * This);
        
        END_INTERFACE
    } IServiceCallVtbl;

    interface IServiceCall
    {
        CONST_VTBL struct IServiceCallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceCall_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceCall_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceCall_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceCall_OnCall(This)	\
    ( (This)->lpVtbl -> OnCall(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceCall_INTERFACE_DEFINED__ */


#ifndef __IAsyncErrorNotify_INTERFACE_DEFINED__
#define __IAsyncErrorNotify_INTERFACE_DEFINED__

/* interface IAsyncErrorNotify */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAsyncErrorNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE6777FB-A674-4177-8F32-6D707E113484")
    IAsyncErrorNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnError( 
            HRESULT hr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAsyncErrorNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAsyncErrorNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAsyncErrorNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAsyncErrorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnError )( 
            IAsyncErrorNotify * This,
            HRESULT hr);
        
        END_INTERFACE
    } IAsyncErrorNotifyVtbl;

    interface IAsyncErrorNotify
    {
        CONST_VTBL struct IAsyncErrorNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncErrorNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAsyncErrorNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAsyncErrorNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAsyncErrorNotify_OnError(This,hr)	\
    ( (This)->lpVtbl -> OnError(This,hr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAsyncErrorNotify_INTERFACE_DEFINED__ */


#ifndef __IServiceActivity_INTERFACE_DEFINED__
#define __IServiceActivity_INTERFACE_DEFINED__

/* interface IServiceActivity */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IServiceActivity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67532E0C-9E2F-4450-A354-035633944E17")
    IServiceActivity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SynchronousCall( 
            /* [in] */ __RPC__in_opt IServiceCall *pIServiceCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsynchronousCall( 
            /* [in] */ __RPC__in_opt IServiceCall *pIServiceCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToCurrentThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnbindFromThread( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceActivityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServiceActivity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServiceActivity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServiceActivity * This);
        
        HRESULT ( STDMETHODCALLTYPE *SynchronousCall )( 
            IServiceActivity * This,
            /* [in] */ __RPC__in_opt IServiceCall *pIServiceCall);
        
        HRESULT ( STDMETHODCALLTYPE *AsynchronousCall )( 
            IServiceActivity * This,
            /* [in] */ __RPC__in_opt IServiceCall *pIServiceCall);
        
        HRESULT ( STDMETHODCALLTYPE *BindToCurrentThread )( 
            IServiceActivity * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnbindFromThread )( 
            IServiceActivity * This);
        
        END_INTERFACE
    } IServiceActivityVtbl;

    interface IServiceActivity
    {
        CONST_VTBL struct IServiceActivityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceActivity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServiceActivity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServiceActivity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServiceActivity_SynchronousCall(This,pIServiceCall)	\
    ( (This)->lpVtbl -> SynchronousCall(This,pIServiceCall) ) 

#define IServiceActivity_AsynchronousCall(This,pIServiceCall)	\
    ( (This)->lpVtbl -> AsynchronousCall(This,pIServiceCall) ) 

#define IServiceActivity_BindToCurrentThread(This)	\
    ( (This)->lpVtbl -> BindToCurrentThread(This) ) 

#define IServiceActivity_UnbindFromThread(This)	\
    ( (This)->lpVtbl -> UnbindFromThread(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServiceActivity_INTERFACE_DEFINED__ */


#ifndef __IThreadPoolKnobs_INTERFACE_DEFINED__
#define __IThreadPoolKnobs_INTERFACE_DEFINED__

/* interface IThreadPoolKnobs */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IThreadPoolKnobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51372af7-cae7-11cf-be81-00aa00a2fa25")
    IThreadPoolKnobs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxThreads( 
            long *plcMaxThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreads( 
            long *plcCurrentThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxThreads( 
            long lcMaxThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeleteDelay( 
            long *pmsecDeleteDelay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeleteDelay( 
            long msecDeleteDelay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxQueuedRequests( 
            long *plcMaxQueuedRequests) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentQueuedRequests( 
            long *plcCurrentQueuedRequests) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxQueuedRequests( 
            long lcMaxQueuedRequests) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMinThreads( 
            long lcMinThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQueueDepth( 
            long lcQueueDepth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IThreadPoolKnobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IThreadPoolKnobs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IThreadPoolKnobs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IThreadPoolKnobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxThreads )( 
            IThreadPoolKnobs * This,
            long *plcMaxThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreads )( 
            IThreadPoolKnobs * This,
            long *plcCurrentThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxThreads )( 
            IThreadPoolKnobs * This,
            long lcMaxThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeleteDelay )( 
            IThreadPoolKnobs * This,
            long *pmsecDeleteDelay);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeleteDelay )( 
            IThreadPoolKnobs * This,
            long msecDeleteDelay);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxQueuedRequests )( 
            IThreadPoolKnobs * This,
            long *plcMaxQueuedRequests);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentQueuedRequests )( 
            IThreadPoolKnobs * This,
            long *plcCurrentQueuedRequests);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxQueuedRequests )( 
            IThreadPoolKnobs * This,
            long lcMaxQueuedRequests);
        
        HRESULT ( STDMETHODCALLTYPE *SetMinThreads )( 
            IThreadPoolKnobs * This,
            long lcMinThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetQueueDepth )( 
            IThreadPoolKnobs * This,
            long lcQueueDepth);
        
        END_INTERFACE
    } IThreadPoolKnobsVtbl;

    interface IThreadPoolKnobs
    {
        CONST_VTBL struct IThreadPoolKnobsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IThreadPoolKnobs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IThreadPoolKnobs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IThreadPoolKnobs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IThreadPoolKnobs_GetMaxThreads(This,plcMaxThreads)	\
    ( (This)->lpVtbl -> GetMaxThreads(This,plcMaxThreads) ) 

#define IThreadPoolKnobs_GetCurrentThreads(This,plcCurrentThreads)	\
    ( (This)->lpVtbl -> GetCurrentThreads(This,plcCurrentThreads) ) 

#define IThreadPoolKnobs_SetMaxThreads(This,lcMaxThreads)	\
    ( (This)->lpVtbl -> SetMaxThreads(This,lcMaxThreads) ) 

#define IThreadPoolKnobs_GetDeleteDelay(This,pmsecDeleteDelay)	\
    ( (This)->lpVtbl -> GetDeleteDelay(This,pmsecDeleteDelay) ) 

#define IThreadPoolKnobs_SetDeleteDelay(This,msecDeleteDelay)	\
    ( (This)->lpVtbl -> SetDeleteDelay(This,msecDeleteDelay) ) 

#define IThreadPoolKnobs_GetMaxQueuedRequests(This,plcMaxQueuedRequests)	\
    ( (This)->lpVtbl -> GetMaxQueuedRequests(This,plcMaxQueuedRequests) ) 

#define IThreadPoolKnobs_GetCurrentQueuedRequests(This,plcCurrentQueuedRequests)	\
    ( (This)->lpVtbl -> GetCurrentQueuedRequests(This,plcCurrentQueuedRequests) ) 

#define IThreadPoolKnobs_SetMaxQueuedRequests(This,lcMaxQueuedRequests)	\
    ( (This)->lpVtbl -> SetMaxQueuedRequests(This,lcMaxQueuedRequests) ) 

#define IThreadPoolKnobs_SetMinThreads(This,lcMinThreads)	\
    ( (This)->lpVtbl -> SetMinThreads(This,lcMinThreads) ) 

#define IThreadPoolKnobs_SetQueueDepth(This,lcQueueDepth)	\
    ( (This)->lpVtbl -> SetQueueDepth(This,lcQueueDepth) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IThreadPoolKnobs_INTERFACE_DEFINED__ */


#ifndef __IComStaThreadPoolKnobs_INTERFACE_DEFINED__
#define __IComStaThreadPoolKnobs_INTERFACE_DEFINED__

/* interface IComStaThreadPoolKnobs */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IComStaThreadPoolKnobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("324B64FA-33B6-11d2-98B7-00C04F8EE1C4")
    IComStaThreadPoolKnobs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMinThreadCount( 
            DWORD minThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinThreadCount( 
            /* [out] */ __RPC__out DWORD *minThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxThreadCount( 
            DWORD maxThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxThreadCount( 
            /* [out] */ __RPC__out DWORD *maxThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActivityPerThread( 
            DWORD activitiesPerThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivityPerThread( 
            /* [out] */ __RPC__out DWORD *activitiesPerThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActivityRatio( 
            DOUBLE activityRatio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivityRatio( 
            /* [out] */ __RPC__out DOUBLE *activityRatio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadCount( 
            /* [out] */ __RPC__out DWORD *pdwThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQueueDepth( 
            /* [out] */ __RPC__out DWORD *pdwQDepth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQueueDepth( 
            /* [in] */ long dwQDepth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComStaThreadPoolKnobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComStaThreadPoolKnobs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComStaThreadPoolKnobs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComStaThreadPoolKnobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMinThreadCount )( 
            IComStaThreadPoolKnobs * This,
            DWORD minThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinThreadCount )( 
            IComStaThreadPoolKnobs * This,
            /* [out] */ __RPC__out DWORD *minThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxThreadCount )( 
            IComStaThreadPoolKnobs * This,
            DWORD maxThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxThreadCount )( 
            IComStaThreadPoolKnobs * This,
            /* [out] */ __RPC__out DWORD *maxThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetActivityPerThread )( 
            IComStaThreadPoolKnobs * This,
            DWORD activitiesPerThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivityPerThread )( 
            IComStaThreadPoolKnobs * This,
            /* [out] */ __RPC__out DWORD *activitiesPerThread);
        
        HRESULT ( STDMETHODCALLTYPE *SetActivityRatio )( 
            IComStaThreadPoolKnobs * This,
            DOUBLE activityRatio);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivityRatio )( 
            IComStaThreadPoolKnobs * This,
            /* [out] */ __RPC__out DOUBLE *activityRatio);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadCount )( 
            IComStaThreadPoolKnobs * This,
            /* [out] */ __RPC__out DWORD *pdwThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetQueueDepth )( 
            IComStaThreadPoolKnobs * This,
            /* [out] */ __RPC__out DWORD *pdwQDepth);
        
        HRESULT ( STDMETHODCALLTYPE *SetQueueDepth )( 
            IComStaThreadPoolKnobs * This,
            /* [in] */ long dwQDepth);
        
        END_INTERFACE
    } IComStaThreadPoolKnobsVtbl;

    interface IComStaThreadPoolKnobs
    {
        CONST_VTBL struct IComStaThreadPoolKnobsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComStaThreadPoolKnobs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComStaThreadPoolKnobs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComStaThreadPoolKnobs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComStaThreadPoolKnobs_SetMinThreadCount(This,minThreads)	\
    ( (This)->lpVtbl -> SetMinThreadCount(This,minThreads) ) 

#define IComStaThreadPoolKnobs_GetMinThreadCount(This,minThreads)	\
    ( (This)->lpVtbl -> GetMinThreadCount(This,minThreads) ) 

#define IComStaThreadPoolKnobs_SetMaxThreadCount(This,maxThreads)	\
    ( (This)->lpVtbl -> SetMaxThreadCount(This,maxThreads) ) 

#define IComStaThreadPoolKnobs_GetMaxThreadCount(This,maxThreads)	\
    ( (This)->lpVtbl -> GetMaxThreadCount(This,maxThreads) ) 

#define IComStaThreadPoolKnobs_SetActivityPerThread(This,activitiesPerThread)	\
    ( (This)->lpVtbl -> SetActivityPerThread(This,activitiesPerThread) ) 

#define IComStaThreadPoolKnobs_GetActivityPerThread(This,activitiesPerThread)	\
    ( (This)->lpVtbl -> GetActivityPerThread(This,activitiesPerThread) ) 

#define IComStaThreadPoolKnobs_SetActivityRatio(This,activityRatio)	\
    ( (This)->lpVtbl -> SetActivityRatio(This,activityRatio) ) 

#define IComStaThreadPoolKnobs_GetActivityRatio(This,activityRatio)	\
    ( (This)->lpVtbl -> GetActivityRatio(This,activityRatio) ) 

#define IComStaThreadPoolKnobs_GetThreadCount(This,pdwThreads)	\
    ( (This)->lpVtbl -> GetThreadCount(This,pdwThreads) ) 

#define IComStaThreadPoolKnobs_GetQueueDepth(This,pdwQDepth)	\
    ( (This)->lpVtbl -> GetQueueDepth(This,pdwQDepth) ) 

#define IComStaThreadPoolKnobs_SetQueueDepth(This,dwQDepth)	\
    ( (This)->lpVtbl -> SetQueueDepth(This,dwQDepth) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComStaThreadPoolKnobs_INTERFACE_DEFINED__ */


#ifndef __IComMtaThreadPoolKnobs_INTERFACE_DEFINED__
#define __IComMtaThreadPoolKnobs_INTERFACE_DEFINED__

/* interface IComMtaThreadPoolKnobs */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IComMtaThreadPoolKnobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9A76D2E-76A5-43eb-A0C4-49BEC8E48480")
    IComMtaThreadPoolKnobs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MTASetMaxThreadCount( 
            DWORD dwMaxThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MTAGetMaxThreadCount( 
            /* [out] */ __RPC__out DWORD *pdwMaxThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MTASetThrottleValue( 
            DWORD dwThrottle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MTAGetThrottleValue( 
            /* [out] */ __RPC__out DWORD *pdwThrottle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComMtaThreadPoolKnobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComMtaThreadPoolKnobs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComMtaThreadPoolKnobs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComMtaThreadPoolKnobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *MTASetMaxThreadCount )( 
            IComMtaThreadPoolKnobs * This,
            DWORD dwMaxThreads);
        
        HRESULT ( STDMETHODCALLTYPE *MTAGetMaxThreadCount )( 
            IComMtaThreadPoolKnobs * This,
            /* [out] */ __RPC__out DWORD *pdwMaxThreads);
        
        HRESULT ( STDMETHODCALLTYPE *MTASetThrottleValue )( 
            IComMtaThreadPoolKnobs * This,
            DWORD dwThrottle);
        
        HRESULT ( STDMETHODCALLTYPE *MTAGetThrottleValue )( 
            IComMtaThreadPoolKnobs * This,
            /* [out] */ __RPC__out DWORD *pdwThrottle);
        
        END_INTERFACE
    } IComMtaThreadPoolKnobsVtbl;

    interface IComMtaThreadPoolKnobs
    {
        CONST_VTBL struct IComMtaThreadPoolKnobsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComMtaThreadPoolKnobs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComMtaThreadPoolKnobs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComMtaThreadPoolKnobs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComMtaThreadPoolKnobs_MTASetMaxThreadCount(This,dwMaxThreads)	\
    ( (This)->lpVtbl -> MTASetMaxThreadCount(This,dwMaxThreads) ) 

#define IComMtaThreadPoolKnobs_MTAGetMaxThreadCount(This,pdwMaxThreads)	\
    ( (This)->lpVtbl -> MTAGetMaxThreadCount(This,pdwMaxThreads) ) 

#define IComMtaThreadPoolKnobs_MTASetThrottleValue(This,dwThrottle)	\
    ( (This)->lpVtbl -> MTASetThrottleValue(This,dwThrottle) ) 

#define IComMtaThreadPoolKnobs_MTAGetThrottleValue(This,pdwThrottle)	\
    ( (This)->lpVtbl -> MTAGetThrottleValue(This,pdwThrottle) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComMtaThreadPoolKnobs_INTERFACE_DEFINED__ */


#ifndef __IComStaThreadPoolKnobs2_INTERFACE_DEFINED__
#define __IComStaThreadPoolKnobs2_INTERFACE_DEFINED__

/* interface IComStaThreadPoolKnobs2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IComStaThreadPoolKnobs2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73707523-FF9A-4974-BF84-2108DC213740")
    IComStaThreadPoolKnobs2 : public IComStaThreadPoolKnobs
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxCPULoad( 
            /* [out] */ __RPC__out DWORD *pdwLoad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxCPULoad( 
            long pdwLoad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCPUMetricEnabled( 
            /* [out] */ __RPC__out BOOL *pbMetricEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCPUMetricEnabled( 
            BOOL bMetricEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreateThreadsAggressively( 
            /* [out] */ __RPC__out BOOL *pbMetricEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCreateThreadsAggressively( 
            BOOL bMetricEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxCSR( 
            /* [out] */ __RPC__out DWORD *pdwCSR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxCSR( 
            long dwCSR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWaitTimeForThreadCleanup( 
            /* [out] */ __RPC__out DWORD *pdwThreadCleanupWaitTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWaitTimeForThreadCleanup( 
            long dwThreadCleanupWaitTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComStaThreadPoolKnobs2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComStaThreadPoolKnobs2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComStaThreadPoolKnobs2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComStaThreadPoolKnobs2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMinThreadCount )( 
            IComStaThreadPoolKnobs2 * This,
            DWORD minThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinThreadCount )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out DWORD *minThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxThreadCount )( 
            IComStaThreadPoolKnobs2 * This,
            DWORD maxThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxThreadCount )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out DWORD *maxThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetActivityPerThread )( 
            IComStaThreadPoolKnobs2 * This,
            DWORD activitiesPerThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivityPerThread )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out DWORD *activitiesPerThread);
        
        HRESULT ( STDMETHODCALLTYPE *SetActivityRatio )( 
            IComStaThreadPoolKnobs2 * This,
            DOUBLE activityRatio);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivityRatio )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out DOUBLE *activityRatio);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadCount )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out DWORD *pdwThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetQueueDepth )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out DWORD *pdwQDepth);
        
        HRESULT ( STDMETHODCALLTYPE *SetQueueDepth )( 
            IComStaThreadPoolKnobs2 * This,
            /* [in] */ long dwQDepth);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxCPULoad )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out DWORD *pdwLoad);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxCPULoad )( 
            IComStaThreadPoolKnobs2 * This,
            long pdwLoad);
        
        HRESULT ( STDMETHODCALLTYPE *GetCPUMetricEnabled )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out BOOL *pbMetricEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetCPUMetricEnabled )( 
            IComStaThreadPoolKnobs2 * This,
            BOOL bMetricEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreateThreadsAggressively )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out BOOL *pbMetricEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetCreateThreadsAggressively )( 
            IComStaThreadPoolKnobs2 * This,
            BOOL bMetricEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxCSR )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out DWORD *pdwCSR);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxCSR )( 
            IComStaThreadPoolKnobs2 * This,
            long dwCSR);
        
        HRESULT ( STDMETHODCALLTYPE *GetWaitTimeForThreadCleanup )( 
            IComStaThreadPoolKnobs2 * This,
            /* [out] */ __RPC__out DWORD *pdwThreadCleanupWaitTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetWaitTimeForThreadCleanup )( 
            IComStaThreadPoolKnobs2 * This,
            long dwThreadCleanupWaitTime);
        
        END_INTERFACE
    } IComStaThreadPoolKnobs2Vtbl;

    interface IComStaThreadPoolKnobs2
    {
        CONST_VTBL struct IComStaThreadPoolKnobs2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComStaThreadPoolKnobs2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComStaThreadPoolKnobs2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComStaThreadPoolKnobs2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComStaThreadPoolKnobs2_SetMinThreadCount(This,minThreads)	\
    ( (This)->lpVtbl -> SetMinThreadCount(This,minThreads) ) 

#define IComStaThreadPoolKnobs2_GetMinThreadCount(This,minThreads)	\
    ( (This)->lpVtbl -> GetMinThreadCount(This,minThreads) ) 

#define IComStaThreadPoolKnobs2_SetMaxThreadCount(This,maxThreads)	\
    ( (This)->lpVtbl -> SetMaxThreadCount(This,maxThreads) ) 

#define IComStaThreadPoolKnobs2_GetMaxThreadCount(This,maxThreads)	\
    ( (This)->lpVtbl -> GetMaxThreadCount(This,maxThreads) ) 

#define IComStaThreadPoolKnobs2_SetActivityPerThread(This,activitiesPerThread)	\
    ( (This)->lpVtbl -> SetActivityPerThread(This,activitiesPerThread) ) 

#define IComStaThreadPoolKnobs2_GetActivityPerThread(This,activitiesPerThread)	\
    ( (This)->lpVtbl -> GetActivityPerThread(This,activitiesPerThread) ) 

#define IComStaThreadPoolKnobs2_SetActivityRatio(This,activityRatio)	\
    ( (This)->lpVtbl -> SetActivityRatio(This,activityRatio) ) 

#define IComStaThreadPoolKnobs2_GetActivityRatio(This,activityRatio)	\
    ( (This)->lpVtbl -> GetActivityRatio(This,activityRatio) ) 

#define IComStaThreadPoolKnobs2_GetThreadCount(This,pdwThreads)	\
    ( (This)->lpVtbl -> GetThreadCount(This,pdwThreads) ) 

#define IComStaThreadPoolKnobs2_GetQueueDepth(This,pdwQDepth)	\
    ( (This)->lpVtbl -> GetQueueDepth(This,pdwQDepth) ) 

#define IComStaThreadPoolKnobs2_SetQueueDepth(This,dwQDepth)	\
    ( (This)->lpVtbl -> SetQueueDepth(This,dwQDepth) ) 


#define IComStaThreadPoolKnobs2_GetMaxCPULoad(This,pdwLoad)	\
    ( (This)->lpVtbl -> GetMaxCPULoad(This,pdwLoad) ) 

#define IComStaThreadPoolKnobs2_SetMaxCPULoad(This,pdwLoad)	\
    ( (This)->lpVtbl -> SetMaxCPULoad(This,pdwLoad) ) 

#define IComStaThreadPoolKnobs2_GetCPUMetricEnabled(This,pbMetricEnabled)	\
    ( (This)->lpVtbl -> GetCPUMetricEnabled(This,pbMetricEnabled) ) 

#define IComStaThreadPoolKnobs2_SetCPUMetricEnabled(This,bMetricEnabled)	\
    ( (This)->lpVtbl -> SetCPUMetricEnabled(This,bMetricEnabled) ) 

#define IComStaThreadPoolKnobs2_GetCreateThreadsAggressively(This,pbMetricEnabled)	\
    ( (This)->lpVtbl -> GetCreateThreadsAggressively(This,pbMetricEnabled) ) 

#define IComStaThreadPoolKnobs2_SetCreateThreadsAggressively(This,bMetricEnabled)	\
    ( (This)->lpVtbl -> SetCreateThreadsAggressively(This,bMetricEnabled) ) 

#define IComStaThreadPoolKnobs2_GetMaxCSR(This,pdwCSR)	\
    ( (This)->lpVtbl -> GetMaxCSR(This,pdwCSR) ) 

#define IComStaThreadPoolKnobs2_SetMaxCSR(This,dwCSR)	\
    ( (This)->lpVtbl -> SetMaxCSR(This,dwCSR) ) 

#define IComStaThreadPoolKnobs2_GetWaitTimeForThreadCleanup(This,pdwThreadCleanupWaitTime)	\
    ( (This)->lpVtbl -> GetWaitTimeForThreadCleanup(This,pdwThreadCleanupWaitTime) ) 

#define IComStaThreadPoolKnobs2_SetWaitTimeForThreadCleanup(This,dwThreadCleanupWaitTime)	\
    ( (This)->lpVtbl -> SetWaitTimeForThreadCleanup(This,dwThreadCleanupWaitTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComStaThreadPoolKnobs2_INTERFACE_DEFINED__ */


#ifndef __IProcessInitializer_INTERFACE_DEFINED__
#define __IProcessInitializer_INTERFACE_DEFINED__

/* interface IProcessInitializer */
/* [oleautomation][uuid][unique][object] */ 


EXTERN_C const IID IID_IProcessInitializer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1113f52d-dc7f-4943-aed6-88d04027e32a")
    IProcessInitializer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Startup( 
            /* [in] */ __RPC__in_opt IUnknown *punkProcessControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProcessInitializerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProcessInitializer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProcessInitializer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProcessInitializer * This);
        
        HRESULT ( STDMETHODCALLTYPE *Startup )( 
            IProcessInitializer * This,
            /* [in] */ __RPC__in_opt IUnknown *punkProcessControl);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IProcessInitializer * This);
        
        END_INTERFACE
    } IProcessInitializerVtbl;

    interface IProcessInitializer
    {
        CONST_VTBL struct IProcessInitializerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProcessInitializer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProcessInitializer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProcessInitializer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProcessInitializer_Startup(This,punkProcessControl)	\
    ( (This)->lpVtbl -> Startup(This,punkProcessControl) ) 

#define IProcessInitializer_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProcessInitializer_INTERFACE_DEFINED__ */


#ifndef __IServicePoolConfig_INTERFACE_DEFINED__
#define __IServicePoolConfig_INTERFACE_DEFINED__

/* interface IServicePoolConfig */
/* [object][uuid][unique][local] */ 


EXTERN_C const IID IID_IServicePoolConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a9690656-5bca-470c-8451-250c1f43a33e")
    IServicePoolConfig : public IUnknown
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MaxPoolSize( 
            /* [in] */ DWORD dwMaxPool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MaxPoolSize( 
            /* [retval][out] */ DWORD *pdwMaxPool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MinPoolSize( 
            /* [in] */ DWORD dwMinPool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MinPoolSize( 
            /* [retval][out] */ DWORD *pdwMinPool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CreationTimeout( 
            /* [in] */ DWORD dwCreationTimeout) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CreationTimeout( 
            /* [retval][out] */ DWORD *pdwCreationTimeout) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TransactionAffinity( 
            /* [in] */ BOOL fTxAffinity) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TransactionAffinity( 
            /* [retval][out] */ BOOL *pfTxAffinity) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClassFactory( 
            /* [in] */ IClassFactory *pFactory) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClassFactory( 
            /* [retval][out] */ IClassFactory **pFactory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServicePoolConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServicePoolConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServicePoolConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServicePoolConfig * This);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxPoolSize )( 
            IServicePoolConfig * This,
            /* [in] */ DWORD dwMaxPool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxPoolSize )( 
            IServicePoolConfig * This,
            /* [retval][out] */ DWORD *pdwMaxPool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinPoolSize )( 
            IServicePoolConfig * This,
            /* [in] */ DWORD dwMinPool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinPoolSize )( 
            IServicePoolConfig * This,
            /* [retval][out] */ DWORD *pdwMinPool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CreationTimeout )( 
            IServicePoolConfig * This,
            /* [in] */ DWORD dwCreationTimeout);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationTimeout )( 
            IServicePoolConfig * This,
            /* [retval][out] */ DWORD *pdwCreationTimeout);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TransactionAffinity )( 
            IServicePoolConfig * This,
            /* [in] */ BOOL fTxAffinity);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionAffinity )( 
            IServicePoolConfig * This,
            /* [retval][out] */ BOOL *pfTxAffinity);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClassFactory )( 
            IServicePoolConfig * This,
            /* [in] */ IClassFactory *pFactory);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassFactory )( 
            IServicePoolConfig * This,
            /* [retval][out] */ IClassFactory **pFactory);
        
        END_INTERFACE
    } IServicePoolConfigVtbl;

    interface IServicePoolConfig
    {
        CONST_VTBL struct IServicePoolConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServicePoolConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServicePoolConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServicePoolConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServicePoolConfig_put_MaxPoolSize(This,dwMaxPool)	\
    ( (This)->lpVtbl -> put_MaxPoolSize(This,dwMaxPool) ) 

#define IServicePoolConfig_get_MaxPoolSize(This,pdwMaxPool)	\
    ( (This)->lpVtbl -> get_MaxPoolSize(This,pdwMaxPool) ) 

#define IServicePoolConfig_put_MinPoolSize(This,dwMinPool)	\
    ( (This)->lpVtbl -> put_MinPoolSize(This,dwMinPool) ) 

#define IServicePoolConfig_get_MinPoolSize(This,pdwMinPool)	\
    ( (This)->lpVtbl -> get_MinPoolSize(This,pdwMinPool) ) 

#define IServicePoolConfig_put_CreationTimeout(This,dwCreationTimeout)	\
    ( (This)->lpVtbl -> put_CreationTimeout(This,dwCreationTimeout) ) 

#define IServicePoolConfig_get_CreationTimeout(This,pdwCreationTimeout)	\
    ( (This)->lpVtbl -> get_CreationTimeout(This,pdwCreationTimeout) ) 

#define IServicePoolConfig_put_TransactionAffinity(This,fTxAffinity)	\
    ( (This)->lpVtbl -> put_TransactionAffinity(This,fTxAffinity) ) 

#define IServicePoolConfig_get_TransactionAffinity(This,pfTxAffinity)	\
    ( (This)->lpVtbl -> get_TransactionAffinity(This,pfTxAffinity) ) 

#define IServicePoolConfig_put_ClassFactory(This,pFactory)	\
    ( (This)->lpVtbl -> put_ClassFactory(This,pFactory) ) 

#define IServicePoolConfig_get_ClassFactory(This,pFactory)	\
    ( (This)->lpVtbl -> get_ClassFactory(This,pFactory) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServicePoolConfig_INTERFACE_DEFINED__ */


#ifndef __IServicePool_INTERFACE_DEFINED__
#define __IServicePool_INTERFACE_DEFINED__

/* interface IServicePool */
/* [object][uuid][unique][local] */ 


EXTERN_C const IID IID_IServicePool;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b302df81-ea45-451e-99a2-09f9fd1b1e13")
    IServicePool : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *pPoolConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServicePoolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServicePool * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServicePool * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServicePool * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IServicePool * This,
            /* [in] */ IUnknown *pPoolConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IServicePool * This,
            REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IServicePool * This);
        
        END_INTERFACE
    } IServicePoolVtbl;

    interface IServicePool
    {
        CONST_VTBL struct IServicePoolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServicePool_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServicePool_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServicePool_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServicePool_Initialize(This,pPoolConfig)	\
    ( (This)->lpVtbl -> Initialize(This,pPoolConfig) ) 

#define IServicePool_GetObject(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetObject(This,riid,ppv) ) 

#define IServicePool_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServicePool_INTERFACE_DEFINED__ */


#ifndef __IManagedPooledObj_INTERFACE_DEFINED__
#define __IManagedPooledObj_INTERFACE_DEFINED__

/* interface IManagedPooledObj */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IManagedPooledObj;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c5da4bea-1b42-4437-8926-b6a38860a770")
    IManagedPooledObj : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHeld( 
            /* [in] */ BOOL m_bHeld) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManagedPooledObjVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IManagedPooledObj * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IManagedPooledObj * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IManagedPooledObj * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHeld )( 
            IManagedPooledObj * This,
            /* [in] */ BOOL m_bHeld);
        
        END_INTERFACE
    } IManagedPooledObjVtbl;

    interface IManagedPooledObj
    {
        CONST_VTBL struct IManagedPooledObjVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManagedPooledObj_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IManagedPooledObj_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IManagedPooledObj_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IManagedPooledObj_SetHeld(This,m_bHeld)	\
    ( (This)->lpVtbl -> SetHeld(This,m_bHeld) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IManagedPooledObj_INTERFACE_DEFINED__ */


#ifndef __IManagedPoolAction_INTERFACE_DEFINED__
#define __IManagedPoolAction_INTERFACE_DEFINED__

/* interface IManagedPoolAction */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IManagedPoolAction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da91b74e-5388-4783-949d-c1cd5fb00506")
    IManagedPoolAction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LastRelease( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManagedPoolActionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IManagedPoolAction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IManagedPoolAction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IManagedPoolAction * This);
        
        HRESULT ( STDMETHODCALLTYPE *LastRelease )( 
            IManagedPoolAction * This);
        
        END_INTERFACE
    } IManagedPoolActionVtbl;

    interface IManagedPoolAction
    {
        CONST_VTBL struct IManagedPoolActionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManagedPoolAction_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IManagedPoolAction_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IManagedPoolAction_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IManagedPoolAction_LastRelease(This)	\
    ( (This)->lpVtbl -> LastRelease(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IManagedPoolAction_INTERFACE_DEFINED__ */


#ifndef __IManagedObjectInfo_INTERFACE_DEFINED__
#define __IManagedObjectInfo_INTERFACE_DEFINED__

/* interface IManagedObjectInfo */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IManagedObjectInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1427c51a-4584-49d8-90a0-c50d8086cbe9")
    IManagedObjectInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIUnknown( 
            /* [out] */ IUnknown **pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIObjectControl( 
            /* [out] */ IObjectControl **pCtrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInPool( 
            /* [in] */ BOOL bInPool,
            /* [in] */ IManagedPooledObj *pPooledObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWrapperStrength( 
            /* [in] */ BOOL bStrong) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManagedObjectInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IManagedObjectInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IManagedObjectInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IManagedObjectInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIUnknown )( 
            IManagedObjectInfo * This,
            /* [out] */ IUnknown **pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetIObjectControl )( 
            IManagedObjectInfo * This,
            /* [out] */ IObjectControl **pCtrl);
        
        HRESULT ( STDMETHODCALLTYPE *SetInPool )( 
            IManagedObjectInfo * This,
            /* [in] */ BOOL bInPool,
            /* [in] */ IManagedPooledObj *pPooledObj);
        
        HRESULT ( STDMETHODCALLTYPE *SetWrapperStrength )( 
            IManagedObjectInfo * This,
            /* [in] */ BOOL bStrong);
        
        END_INTERFACE
    } IManagedObjectInfoVtbl;

    interface IManagedObjectInfo
    {
        CONST_VTBL struct IManagedObjectInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManagedObjectInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IManagedObjectInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IManagedObjectInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IManagedObjectInfo_GetIUnknown(This,pUnk)	\
    ( (This)->lpVtbl -> GetIUnknown(This,pUnk) ) 

#define IManagedObjectInfo_GetIObjectControl(This,pCtrl)	\
    ( (This)->lpVtbl -> GetIObjectControl(This,pCtrl) ) 

#define IManagedObjectInfo_SetInPool(This,bInPool,pPooledObj)	\
    ( (This)->lpVtbl -> SetInPool(This,bInPool,pPooledObj) ) 

#define IManagedObjectInfo_SetWrapperStrength(This,bStrong)	\
    ( (This)->lpVtbl -> SetWrapperStrength(This,bStrong) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IManagedObjectInfo_INTERFACE_DEFINED__ */


#ifndef __IAppDomainHelper_INTERFACE_DEFINED__
#define __IAppDomainHelper_INTERFACE_DEFINED__

/* interface IAppDomainHelper */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IAppDomainHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c7b67079-8255-42c6-9ec0-6994a3548780")
    IAppDomainHelper : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *pUnkAD,
            /* [in] */ HRESULT ( STDMETHODCALLTYPE __MIDL__IAppDomainHelper0000 )( 
                void *pv),
            /* [in] */ void *pPool) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoCallback( 
            /* [in] */ IUnknown *pUnkAD,
            /* [in] */ HRESULT ( STDMETHODCALLTYPE __MIDL__IAppDomainHelper0001 )( 
                void *pv),
            /* [in] */ void *pPool) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppDomainHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppDomainHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppDomainHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppDomainHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAppDomainHelper * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAppDomainHelper * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAppDomainHelper * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAppDomainHelper * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IAppDomainHelper * This,
            /* [in] */ IUnknown *pUnkAD,
            /* [in] */ HRESULT ( STDMETHODCALLTYPE __MIDL__IAppDomainHelper0000 )( 
                void *pv),
            /* [in] */ void *pPool);
        
        HRESULT ( STDMETHODCALLTYPE *DoCallback )( 
            IAppDomainHelper * This,
            /* [in] */ IUnknown *pUnkAD,
            /* [in] */ HRESULT ( STDMETHODCALLTYPE __MIDL__IAppDomainHelper0001 )( 
                void *pv),
            /* [in] */ void *pPool);
        
        END_INTERFACE
    } IAppDomainHelperVtbl;

    interface IAppDomainHelper
    {
        CONST_VTBL struct IAppDomainHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppDomainHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAppDomainHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAppDomainHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAppDomainHelper_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAppDomainHelper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAppDomainHelper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAppDomainHelper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAppDomainHelper_Initialize(This,pUnkAD,__MIDL__IAppDomainHelper0000,pPool)	\
    ( (This)->lpVtbl -> Initialize(This,pUnkAD,__MIDL__IAppDomainHelper0000,pPool) ) 

#define IAppDomainHelper_DoCallback(This,pUnkAD,__MIDL__IAppDomainHelper0001,pPool)	\
    ( (This)->lpVtbl -> DoCallback(This,pUnkAD,__MIDL__IAppDomainHelper0001,pPool) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAppDomainHelper_INTERFACE_DEFINED__ */


#ifndef __IAssemblyLocator_INTERFACE_DEFINED__
#define __IAssemblyLocator_INTERFACE_DEFINED__

/* interface IAssemblyLocator */
/* [object][oleautomation][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAssemblyLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("391ffbb9-a8ee-432a-abc8-baa238dab90f")
    IAssemblyLocator : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModules( 
            /* [in] */ __RPC__in BSTR applicationDir,
            /* [in] */ __RPC__in BSTR applicationName,
            /* [in] */ __RPC__in BSTR assemblyName,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pModules) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAssemblyLocator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAssemblyLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAssemblyLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAssemblyLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetModules )( 
            IAssemblyLocator * This,
            /* [in] */ __RPC__in BSTR applicationDir,
            /* [in] */ __RPC__in BSTR applicationName,
            /* [in] */ __RPC__in BSTR assemblyName,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pModules);
        
        END_INTERFACE
    } IAssemblyLocatorVtbl;

    interface IAssemblyLocator
    {
        CONST_VTBL struct IAssemblyLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyLocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAssemblyLocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAssemblyLocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAssemblyLocator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAssemblyLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAssemblyLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAssemblyLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAssemblyLocator_GetModules(This,applicationDir,applicationName,assemblyName,pModules)	\
    ( (This)->lpVtbl -> GetModules(This,applicationDir,applicationName,assemblyName,pModules) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAssemblyLocator_INTERFACE_DEFINED__ */


#ifndef __IManagedActivationEvents_INTERFACE_DEFINED__
#define __IManagedActivationEvents_INTERFACE_DEFINED__

/* interface IManagedActivationEvents */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IManagedActivationEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a5f325af-572f-46da-b8ab-827c3d95d99e")
    IManagedActivationEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateManagedStub( 
            /* [in] */ IManagedObjectInfo *pInfo,
            /* [in] */ BOOL fDist) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyManagedStub( 
            /* [in] */ IManagedObjectInfo *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManagedActivationEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IManagedActivationEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IManagedActivationEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IManagedActivationEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateManagedStub )( 
            IManagedActivationEvents * This,
            /* [in] */ IManagedObjectInfo *pInfo,
            /* [in] */ BOOL fDist);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyManagedStub )( 
            IManagedActivationEvents * This,
            /* [in] */ IManagedObjectInfo *pInfo);
        
        END_INTERFACE
    } IManagedActivationEventsVtbl;

    interface IManagedActivationEvents
    {
        CONST_VTBL struct IManagedActivationEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManagedActivationEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IManagedActivationEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IManagedActivationEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IManagedActivationEvents_CreateManagedStub(This,pInfo,fDist)	\
    ( (This)->lpVtbl -> CreateManagedStub(This,pInfo,fDist) ) 

#define IManagedActivationEvents_DestroyManagedStub(This,pInfo)	\
    ( (This)->lpVtbl -> DestroyManagedStub(This,pInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IManagedActivationEvents_INTERFACE_DEFINED__ */


#ifndef __ISendMethodEvents_INTERFACE_DEFINED__
#define __ISendMethodEvents_INTERFACE_DEFINED__

/* interface ISendMethodEvents */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_ISendMethodEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2732fd59-b2b4-4d44-878c-8b8f09626008")
    ISendMethodEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendMethodCall( 
            /* [in] */ const void *pIdentity,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwMeth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendMethodReturn( 
            /* [in] */ const void *pIdentity,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwMeth,
            /* [in] */ HRESULT hrCall,
            /* [in] */ HRESULT hrServer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISendMethodEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISendMethodEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISendMethodEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISendMethodEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *SendMethodCall )( 
            ISendMethodEvents * This,
            /* [in] */ const void *pIdentity,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwMeth);
        
        HRESULT ( STDMETHODCALLTYPE *SendMethodReturn )( 
            ISendMethodEvents * This,
            /* [in] */ const void *pIdentity,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwMeth,
            /* [in] */ HRESULT hrCall,
            /* [in] */ HRESULT hrServer);
        
        END_INTERFACE
    } ISendMethodEventsVtbl;

    interface ISendMethodEvents
    {
        CONST_VTBL struct ISendMethodEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISendMethodEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISendMethodEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISendMethodEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISendMethodEvents_SendMethodCall(This,pIdentity,riid,dwMeth)	\
    ( (This)->lpVtbl -> SendMethodCall(This,pIdentity,riid,dwMeth) ) 

#define ISendMethodEvents_SendMethodReturn(This,pIdentity,riid,dwMeth,hrCall,hrServer)	\
    ( (This)->lpVtbl -> SendMethodReturn(This,pIdentity,riid,dwMeth,hrCall,hrServer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISendMethodEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0111 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0111_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0111_v0_0_s_ifspec;

#ifndef __ITransactionResourcePool_INTERFACE_DEFINED__
#define __ITransactionResourcePool_INTERFACE_DEFINED__

/* interface ITransactionResourcePool */
/* [object][unique][local][helpstring][uuid] */ 


EXTERN_C const IID IID_ITransactionResourcePool;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5FEB7C1-346A-11D1-B1CC-00AA00BA3258")
    ITransactionResourcePool : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutResource( 
            /* [in] */ IObjPool *pPool,
            /* [in] */ IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResource( 
            /* [in] */ IObjPool *pPool,
            /* [out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionResourcePoolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionResourcePool * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionResourcePool * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionResourcePool * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutResource )( 
            ITransactionResourcePool * This,
            /* [in] */ IObjPool *pPool,
            /* [in] */ IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetResource )( 
            ITransactionResourcePool * This,
            /* [in] */ IObjPool *pPool,
            /* [out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } ITransactionResourcePoolVtbl;

    interface ITransactionResourcePool
    {
        CONST_VTBL struct ITransactionResourcePoolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionResourcePool_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionResourcePool_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionResourcePool_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionResourcePool_PutResource(This,pPool,pUnk)	\
    ( (This)->lpVtbl -> PutResource(This,pPool,pUnk) ) 

#define ITransactionResourcePool_GetResource(This,pPool,ppUnk)	\
    ( (This)->lpVtbl -> GetResource(This,pPool,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionResourcePool_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_autosvcs_0000_0112 */
/* [local] */ 

EXTERN_C HRESULT __stdcall MTSCreateActivity ( REFIID riid, void** ppobj );


extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0112_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_autosvcs_0000_0112_v0_0_s_ifspec;

#ifndef __IMTSCall_INTERFACE_DEFINED__
#define __IMTSCall_INTERFACE_DEFINED__

/* interface IMTSCall */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_IMTSCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51372AEF-CAE7-11CF-BE81-00AA00A2FA25")
    IMTSCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCall( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMTSCall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMTSCall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMTSCall * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCall )( 
            IMTSCall * This);
        
        END_INTERFACE
    } IMTSCallVtbl;

    interface IMTSCall
    {
        CONST_VTBL struct IMTSCallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSCall_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMTSCall_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMTSCall_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMTSCall_OnCall(This)	\
    ( (This)->lpVtbl -> OnCall(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMTSCall_INTERFACE_DEFINED__ */


#ifndef __IContextProperties_INTERFACE_DEFINED__
#define __IContextProperties_INTERFACE_DEFINED__

/* interface IContextProperties */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_IContextProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D396DA85-BF8F-11d1-BBAE-00C04FC2FA5F")
    IContextProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNames( 
            /* [retval][out] */ IEnumNames **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT property) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProperty( 
            /* [in] */ BSTR name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IContextProperties * This,
            /* [retval][out] */ long *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IContextProperties * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pProperty);
        
        HRESULT ( STDMETHODCALLTYPE *EnumNames )( 
            IContextProperties * This,
            /* [retval][out] */ IEnumNames **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IContextProperties * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT property);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveProperty )( 
            IContextProperties * This,
            /* [in] */ BSTR name);
        
        END_INTERFACE
    } IContextPropertiesVtbl;

    interface IContextProperties
    {
        CONST_VTBL struct IContextPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContextProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContextProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContextProperties_Count(This,plCount)	\
    ( (This)->lpVtbl -> Count(This,plCount) ) 

#define IContextProperties_GetProperty(This,name,pProperty)	\
    ( (This)->lpVtbl -> GetProperty(This,name,pProperty) ) 

#define IContextProperties_EnumNames(This,ppenum)	\
    ( (This)->lpVtbl -> EnumNames(This,ppenum) ) 

#define IContextProperties_SetProperty(This,name,property)	\
    ( (This)->lpVtbl -> SetProperty(This,name,property) ) 

#define IContextProperties_RemoveProperty(This,name)	\
    ( (This)->lpVtbl -> RemoveProperty(This,name) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContextProperties_INTERFACE_DEFINED__ */


#ifndef __IObjPool_INTERFACE_DEFINED__
#define __IObjPool_INTERFACE_DEFINED__

/* interface IObjPool */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IObjPool;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7D8805A0-2EA7-11D1-B1CC-00AA00BA3258")
    IObjPool : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual void STDMETHODCALLTYPE PutEndTx( 
            IUnknown *pObj) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved6( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjPoolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjPool * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjPool * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjPool * This);
        
        void ( STDMETHODCALLTYPE *Reserved1 )( 
            IObjPool * This);
        
        void ( STDMETHODCALLTYPE *Reserved2 )( 
            IObjPool * This);
        
        void ( STDMETHODCALLTYPE *Reserved3 )( 
            IObjPool * This);
        
        void ( STDMETHODCALLTYPE *Reserved4 )( 
            IObjPool * This);
        
        void ( STDMETHODCALLTYPE *PutEndTx )( 
            IObjPool * This,
            IUnknown *pObj);
        
        void ( STDMETHODCALLTYPE *Reserved5 )( 
            IObjPool * This);
        
        void ( STDMETHODCALLTYPE *Reserved6 )( 
            IObjPool * This);
        
        END_INTERFACE
    } IObjPoolVtbl;

    interface IObjPool
    {
        CONST_VTBL struct IObjPoolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjPool_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjPool_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjPool_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjPool_Reserved1(This)	\
    ( (This)->lpVtbl -> Reserved1(This) ) 

#define IObjPool_Reserved2(This)	\
    ( (This)->lpVtbl -> Reserved2(This) ) 

#define IObjPool_Reserved3(This)	\
    ( (This)->lpVtbl -> Reserved3(This) ) 

#define IObjPool_Reserved4(This)	\
    ( (This)->lpVtbl -> Reserved4(This) ) 

#define IObjPool_PutEndTx(This,pObj)	\
    ( (This)->lpVtbl -> PutEndTx(This,pObj) ) 

#define IObjPool_Reserved5(This)	\
    ( (This)->lpVtbl -> Reserved5(This) ) 

#define IObjPool_Reserved6(This)	\
    ( (This)->lpVtbl -> Reserved6(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjPool_INTERFACE_DEFINED__ */


#ifndef __ITransactionProperty_INTERFACE_DEFINED__
#define __ITransactionProperty_INTERFACE_DEFINED__

/* interface ITransactionProperty */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_ITransactionProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("788ea814-87b1-11d1-bba6-00c04fc2fa5f")
    ITransactionProperty : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransactionResourcePool( 
            /* [out] */ ITransactionResourcePool **ppTxPool) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved10( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved11( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved12( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved13( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved14( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved15( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved16( void) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved17( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransactionProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransactionProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved1 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved2 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved3 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved4 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved5 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved6 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved7 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved8 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved9 )( 
            ITransactionProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransactionResourcePool )( 
            ITransactionProperty * This,
            /* [out] */ ITransactionResourcePool **ppTxPool);
        
        void ( STDMETHODCALLTYPE *Reserved10 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved11 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved12 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved13 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved14 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved15 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved16 )( 
            ITransactionProperty * This);
        
        void ( STDMETHODCALLTYPE *Reserved17 )( 
            ITransactionProperty * This);
        
        END_INTERFACE
    } ITransactionPropertyVtbl;

    interface ITransactionProperty
    {
        CONST_VTBL struct ITransactionPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionProperty_Reserved1(This)	\
    ( (This)->lpVtbl -> Reserved1(This) ) 

#define ITransactionProperty_Reserved2(This)	\
    ( (This)->lpVtbl -> Reserved2(This) ) 

#define ITransactionProperty_Reserved3(This)	\
    ( (This)->lpVtbl -> Reserved3(This) ) 

#define ITransactionProperty_Reserved4(This)	\
    ( (This)->lpVtbl -> Reserved4(This) ) 

#define ITransactionProperty_Reserved5(This)	\
    ( (This)->lpVtbl -> Reserved5(This) ) 

#define ITransactionProperty_Reserved6(This)	\
    ( (This)->lpVtbl -> Reserved6(This) ) 

#define ITransactionProperty_Reserved7(This)	\
    ( (This)->lpVtbl -> Reserved7(This) ) 

#define ITransactionProperty_Reserved8(This)	\
    ( (This)->lpVtbl -> Reserved8(This) ) 

#define ITransactionProperty_Reserved9(This)	\
    ( (This)->lpVtbl -> Reserved9(This) ) 

#define ITransactionProperty_GetTransactionResourcePool(This,ppTxPool)	\
    ( (This)->lpVtbl -> GetTransactionResourcePool(This,ppTxPool) ) 

#define ITransactionProperty_Reserved10(This)	\
    ( (This)->lpVtbl -> Reserved10(This) ) 

#define ITransactionProperty_Reserved11(This)	\
    ( (This)->lpVtbl -> Reserved11(This) ) 

#define ITransactionProperty_Reserved12(This)	\
    ( (This)->lpVtbl -> Reserved12(This) ) 

#define ITransactionProperty_Reserved13(This)	\
    ( (This)->lpVtbl -> Reserved13(This) ) 

#define ITransactionProperty_Reserved14(This)	\
    ( (This)->lpVtbl -> Reserved14(This) ) 

#define ITransactionProperty_Reserved15(This)	\
    ( (This)->lpVtbl -> Reserved15(This) ) 

#define ITransactionProperty_Reserved16(This)	\
    ( (This)->lpVtbl -> Reserved16(This) ) 

#define ITransactionProperty_Reserved17(This)	\
    ( (This)->lpVtbl -> Reserved17(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionProperty_INTERFACE_DEFINED__ */


#ifndef __IMTSActivity_INTERFACE_DEFINED__
#define __IMTSActivity_INTERFACE_DEFINED__

/* interface IMTSActivity */
/* [object][unique][uuid][local] */ 


EXTERN_C const IID IID_IMTSActivity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51372AF0-CAE7-11CF-BE81-00AA00A2FA25")
    IMTSActivity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SynchronousCall( 
            /* [in] */ IMTSCall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncCall( 
            /* [in] */ IMTSCall *pCall) = 0;
        
        virtual void STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToCurrentThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnbindFromThread( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSActivityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMTSActivity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMTSActivity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMTSActivity * This);
        
        HRESULT ( STDMETHODCALLTYPE *SynchronousCall )( 
            IMTSActivity * This,
            /* [in] */ IMTSCall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *AsyncCall )( 
            IMTSActivity * This,
            /* [in] */ IMTSCall *pCall);
        
        void ( STDMETHODCALLTYPE *Reserved1 )( 
            IMTSActivity * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToCurrentThread )( 
            IMTSActivity * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnbindFromThread )( 
            IMTSActivity * This);
        
        END_INTERFACE
    } IMTSActivityVtbl;

    interface IMTSActivity
    {
        CONST_VTBL struct IMTSActivityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSActivity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMTSActivity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMTSActivity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMTSActivity_SynchronousCall(This,pCall)	\
    ( (This)->lpVtbl -> SynchronousCall(This,pCall) ) 

#define IMTSActivity_AsyncCall(This,pCall)	\
    ( (This)->lpVtbl -> AsyncCall(This,pCall) ) 

#define IMTSActivity_Reserved1(This)	\
    ( (This)->lpVtbl -> Reserved1(This) ) 

#define IMTSActivity_BindToCurrentThread(This)	\
    ( (This)->lpVtbl -> BindToCurrentThread(This) ) 

#define IMTSActivity_UnbindFromThread(This)	\
    ( (This)->lpVtbl -> UnbindFromThread(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMTSActivity_INTERFACE_DEFINED__ */



#ifndef __COMSVCSLib_LIBRARY_DEFINED__
#define __COMSVCSLib_LIBRARY_DEFINED__

/* library COMSVCSLib */
/* [helpfile][helpstring][version][uuid] */ 



typedef /* [public][helpcontext][helpstring] */ 
enum __MIDL___MIDL_itf_autosvcs_0000_0117_0001
    {	mtsErrCtxAborted	= 0x8004e002,
	mtsErrCtxAborting	= 0x8004e003,
	mtsErrCtxNoContext	= 0x8004e004,
	mtsErrCtxNotRegistered	= 0x8004e005,
	mtsErrCtxSynchTimeout	= 0x8004e006,
	mtsErrCtxOldReference	= 0x8004e007,
	mtsErrCtxRoleNotFound	= 0x8004e00c,
	mtsErrCtxNoSecurity	= 0x8004e00d,
	mtsErrCtxWrongThread	= 0x8004e00e,
	mtsErrCtxTMNotAvailable	= 0x8004e00f,
	comQCErrApplicationNotQueued	= 0x80110600,
	comQCErrNoQueueableInterfaces	= 0x80110601,
	comQCErrQueuingServiceNotAvailable	= 0x80110602,
	comQCErrQueueTransactMismatch	= 0x80110603,
	comqcErrRecorderMarshalled	= 0x80110604,
	comqcErrOutParam	= 0x80110605,
	comqcErrRecorderNotTrusted	= 0x80110606,
	comqcErrPSLoad	= 0x80110607,
	comqcErrMarshaledObjSameTxn	= 0x80110608,
	comqcErrInvalidMessage	= 0x80110650,
	comqcErrMsmqSidUnavailable	= 0x80110651,
	comqcErrWrongMsgExtension	= 0x80110652,
	comqcErrMsmqServiceUnavailable	= 0x80110653,
	comqcErrMsgNotAuthenticated	= 0x80110654,
	comqcErrMsmqConnectorUsed	= 0x80110655,
	comqcErrBadMarshaledObject	= 0x80110656
    } 	Error_Constants;


typedef /* [public] */ 
enum __MIDL___MIDL_itf_autosvcs_0000_0117_0002
    {	LockSetGet	= 0,
	LockMethod	= ( LockSetGet + 1 ) 
    } 	LockModes;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_autosvcs_0000_0117_0003
    {	Standard	= 0,
	Process	= ( Standard + 1 ) 
    } 	ReleaseModes;

#ifndef _tagCrmFlags_
#define _tagCrmFlags_
typedef 
enum tagCRMFLAGS
    {	CRMFLAG_FORGETTARGET	= 0x1,
	CRMFLAG_WRITTENDURINGPREPARE	= 0x2,
	CRMFLAG_WRITTENDURINGCOMMIT	= 0x4,
	CRMFLAG_WRITTENDURINGABORT	= 0x8,
	CRMFLAG_WRITTENDURINGRECOVERY	= 0x10,
	CRMFLAG_WRITTENDURINGREPLAY	= 0x20,
	CRMFLAG_REPLAYINPROGRESS	= 0x40
    } 	CRMFLAGS;

#endif _tagCrmFlags_
#ifndef _tagCrmRegFlags_
#define _tagCrmRegFlags_
typedef 
enum tagCRMREGFLAGS
    {	CRMREGFLAG_PREPAREPHASE	= 0x1,
	CRMREGFLAG_COMMITPHASE	= 0x2,
	CRMREGFLAG_ABORTPHASE	= 0x4,
	CRMREGFLAG_ALLPHASES	= 0x7,
	CRMREGFLAG_FAILIFINDOUBTSREMAIN	= 0x10
    } 	CRMREGFLAGS;

#endif _tagCrmRegFlags_

EXTERN_C const IID LIBID_COMSVCSLib;

EXTERN_C const CLSID CLSID_SecurityIdentity;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0a5-7f19-11d2-978e-0000f8757e2a")
SecurityIdentity;
#endif

EXTERN_C const CLSID CLSID_SecurityCallers;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0a6-7f19-11d2-978e-0000f8757e2a")
SecurityCallers;
#endif

EXTERN_C const CLSID CLSID_SecurityCallContext;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0a7-7f19-11d2-978e-0000f8757e2a")
SecurityCallContext;
#endif

EXTERN_C const CLSID CLSID_GetSecurityCallContextAppObject;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0a8-7f19-11d2-978e-0000f8757e2a")
GetSecurityCallContextAppObject;
#endif

EXTERN_C const CLSID CLSID_Dummy30040732;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0a9-7f19-11d2-978e-0000f8757e2a")
Dummy30040732;
#endif

EXTERN_C const CLSID CLSID_TransactionContext;

#ifdef __cplusplus

class DECLSPEC_UUID("7999FC25-D3C6-11CF-ACAB-00A024A55AEF")
TransactionContext;
#endif

EXTERN_C const CLSID CLSID_TransactionContextEx;

#ifdef __cplusplus

class DECLSPEC_UUID("5cb66670-d3d4-11cf-acab-00a024a55aef")
TransactionContextEx;
#endif

EXTERN_C const CLSID CLSID_ByotServerEx;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0aa-7f19-11d2-978e-0000f8757e2a")
ByotServerEx;
#endif

EXTERN_C const CLSID CLSID_CServiceConfig;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0c8-7f19-11d2-978e-0000f8757e2a")
CServiceConfig;
#endif

EXTERN_C const CLSID CLSID_ServicePool;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0c9-7f19-11d2-978e-0000f8757e2a")
ServicePool;
#endif

EXTERN_C const CLSID CLSID_ServicePoolConfig;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0ca-7f19-11d2-978e-0000f8757e2a")
ServicePoolConfig;
#endif

EXTERN_C const CLSID CLSID_SharedProperty;

#ifdef __cplusplus

class DECLSPEC_UUID("2A005C05-A5DE-11CF-9E66-00AA00A3F464")
SharedProperty;
#endif

EXTERN_C const CLSID CLSID_SharedPropertyGroup;

#ifdef __cplusplus

class DECLSPEC_UUID("2A005C0B-A5DE-11CF-9E66-00AA00A3F464")
SharedPropertyGroup;
#endif

EXTERN_C const CLSID CLSID_SharedPropertyGroupManager;

#ifdef __cplusplus

class DECLSPEC_UUID("2A005C11-A5DE-11CF-9E66-00AA00A3F464")
SharedPropertyGroupManager;
#endif

EXTERN_C const CLSID CLSID_COMEvents;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0ab-7f19-11d2-978e-0000f8757e2a")
COMEvents;
#endif

EXTERN_C const CLSID CLSID_CoMTSLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0ac-7f19-11d2-978e-0000f8757e2a")
CoMTSLocator;
#endif

EXTERN_C const CLSID CLSID_MtsGrp;

#ifdef __cplusplus

class DECLSPEC_UUID("4B2E958D-0393-11D1-B1AB-00AA00BA3258")
MtsGrp;
#endif

EXTERN_C const CLSID CLSID_ComServiceEvents;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0c3-7f19-11d2-978e-0000f8757e2a")
ComServiceEvents;
#endif

EXTERN_C const CLSID CLSID_ComSystemAppEventData;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0c6-7f19-11d2-978e-0000f8757e2a")
ComSystemAppEventData;
#endif

EXTERN_C const CLSID CLSID_CRMClerk;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0bd-7f19-11d2-978e-0000f8757e2a")
CRMClerk;
#endif

EXTERN_C const CLSID CLSID_CRMRecoveryClerk;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0be-7f19-11d2-978e-0000f8757e2a")
CRMRecoveryClerk;
#endif

EXTERN_C const CLSID CLSID_MessageMover;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0bf-7f19-11d2-978e-0000f8757e2a")
MessageMover;
#endif

EXTERN_C const CLSID CLSID_DispenserManager;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabb0c0-7f19-11d2-978e-0000f8757e2a")
DispenserManager;
#endif

EXTERN_C const CLSID CLSID_PoolMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabafb5-7f19-11d2-978e-0000f8757e2a")
PoolMgr;
#endif

EXTERN_C const CLSID CLSID_EventServer;

#ifdef __cplusplus

class DECLSPEC_UUID("ecabafbc-7f19-11d2-978e-0000f8757e2a")
EventServer;
#endif

EXTERN_C const CLSID CLSID_AppDomainHelper;

#ifdef __cplusplus

class DECLSPEC_UUID("ef24f689-14f8-4d92-b4af-d7b1f0e70fd4")
AppDomainHelper;
#endif

EXTERN_C const CLSID CLSID_ClrAssemblyLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("458aa3b5-265a-4b75-bc05-9bea4630cf18")
ClrAssemblyLocator;
#endif
#endif /* __COMSVCSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\corhlpr.cpp ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
/****************************************************************************
 **                                                                        **
 ** Corhlpr.h - signature helpers.                                         **
 **                                                                        **
 ****************************************************************************/
#ifndef SOS_INCLUDE

#ifdef _BLD_CLR
#include "utilcode.h"
#endif
#include "corhlpr.h"
#include <stdlib.h>

/*************************************************************************************
*
* implementation of CQuickMemoryBase
*
*************************************************************************************/

template <DWORD SIZE, DWORD INCREMENT>
HRESULT CQuickMemoryBase <SIZE, INCREMENT>::ReSizeNoThrow(SIZE_T iItems)
{
#ifdef _BLD_CLR
#ifdef _DEBUG
    // Exercise heap for OOM-fault injection purposes
    // But we can't do this if current thread suspends EE
    if (!IsSuspendEEThread ())
    {
        BYTE *pTmp = NEW_NOTHROW(iItems);
        if (!pTmp)
        {
            return E_OUTOFMEMORY;
        }
        delete [] pTmp;
    }
#endif
#endif
    BYTE *pbBuffNew;
    if (iItems <= cbTotal)
    {
        iSize = iItems;
        return NOERROR;
    }
    
#ifdef _BLD_CLR
    // not allowed to do allocation if current thread suspends EE
    if (IsSuspendEEThread ())
        return E_OUTOFMEMORY;
#endif
    pbBuffNew = NEW_NOTHROW(iItems + INCREMENT);
    if (!pbBuffNew)
        return E_OUTOFMEMORY;
    if (pbBuff)
    {
        memcpy(pbBuffNew, pbBuff, cbTotal);
        delete [] pbBuff;
    }
    else
    {
        _ASSERTE(cbTotal == SIZE);
        memcpy(pbBuffNew, rgData, cbTotal);
    }
    cbTotal = iItems + INCREMENT;
    iSize = iItems;
    pbBuff = pbBuffNew;
    return NOERROR;
}


/*************************************************************************************
*
* get number of bytes consumed by one argument/return type
*
*************************************************************************************/
#define CHECK_REMAINDER  if(cbTotal >= cbTotalMax){hr=E_FAIL; goto ErrExit;}
HRESULT _CountBytesOfOneArg(
    PCCOR_SIGNATURE pbSig,
    ULONG       *pcbTotal)  // Initially, *pcbTotal contains the remaining size of the sig blob
{
    ULONG       cb;
    ULONG       cbTotal=0;
    ULONG       cbTotalMax;
    CorElementType ulElementType;
    ULONG       ulData;
    ULONG       ulTemp;
    int         iData;
    mdToken     tk;
    ULONG       cArg;
    ULONG       callingconv;
    ULONG       cArgsIndex;
    HRESULT     hr = NOERROR;

    if(pcbTotal==NULL) return E_FAIL;
    cbTotalMax = *pcbTotal;

    CHECK_REMAINDER;
    cbTotal = CorSigUncompressElementType(pbSig, &ulElementType);
    while (CorIsModifierElementType((CorElementType) ulElementType))
    {
        CHECK_REMAINDER;
        cbTotal += CorSigUncompressElementType(&pbSig[cbTotal], &ulElementType);
    }
    switch (ulElementType)
    {
        case ELEMENT_TYPE_SZARRAY:
        case 0x1e /* obsolete */:
            // skip over base type
            CHECK_REMAINDER;
            cb = cbTotalMax - cbTotal;
            IfFailGo( _CountBytesOfOneArg(&pbSig[cbTotal], &cb) );
            cbTotal += cb;
            break;

        case ELEMENT_TYPE_FNPTR:
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressData (&pbSig[cbTotal], &callingconv);

            // remember number of bytes to represent the arg counts
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressData (&pbSig[cbTotal], &cArg);

            // how many bytes to represent the return type
            CHECK_REMAINDER;
            cb = cbTotalMax - cbTotal;
            IfFailGo( _CountBytesOfOneArg( &pbSig[cbTotal], &cb) );
            cbTotal += cb;

            // loop through argument
            for (cArgsIndex = 0; cArgsIndex < cArg; cArgsIndex++)
            {
                CHECK_REMAINDER;
                cb = cbTotalMax - cbTotal;
                IfFailGo( _CountBytesOfOneArg( &pbSig[cbTotal], &cb) );
                cbTotal += cb;
            }

            break;

        case ELEMENT_TYPE_ARRAY:
            // syntax : ARRAY BaseType <rank> [i size_1... size_i] [j lowerbound_1 ... lowerbound_j]

            // skip over base type
            CHECK_REMAINDER;
            cb = cbTotalMax - cbTotal;
            IfFailGo( _CountBytesOfOneArg(&pbSig[cbTotal], &cb) );
            cbTotal += cb;

            // Parse for the rank
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);

            // if rank == 0, we are done
            if (ulData == 0)
                break;

            // any size of dimension specified?
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);
            while (ulData--)
            {
                CHECK_REMAINDER;
                cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulTemp);
            }

            // any lower bound specified?
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);

            while (ulData--)
            {
                CHECK_REMAINDER;
                cbTotal += CorSigUncompressSignedInt(&pbSig[cbTotal], &iData);
            }

            break;
        case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_CMOD_REQD:
        case ELEMENT_TYPE_CMOD_OPT:
            // count the bytes for the token compression
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressToken(&pbSig[cbTotal], &tk);
            if ( ulElementType == ELEMENT_TYPE_CMOD_REQD ||
                 ulElementType == ELEMENT_TYPE_CMOD_OPT)
            {
                // skip over base type
                CHECK_REMAINDER;
                cb = cbTotalMax - cbTotal;
                IfFailGo( _CountBytesOfOneArg(&pbSig[cbTotal], &cb) );
                cbTotal += cb;
            }
            break;
        default:
            break;
    }

    *pcbTotal = cbTotal;
ErrExit:
    return hr;
}
#undef CHECK_REMAINDER

//*****************************************************************************
// copy fixed part of VarArg signature to a buffer
//*****************************************************************************
HRESULT _GetFixedSigOfVarArg(           // S_OK or error.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob of COM+ method signature
    ULONG   cbSigBlob,                  // [IN] size of signature
    CQuickBytes *pqbSig,                // [OUT] output buffer for fixed part of VarArg Signature
    ULONG   *pcbSigBlob)                // [OUT] number of bytes written to the above output buffer
{
    HRESULT     hr = NOERROR;
    ULONG       cbCalling;
    ULONG       cbTyArgsNumber = 0;     // number of bytes to store the type arg count (generics only)
    ULONG       cbArgsNumber;           // number of bytes to store the original arg count
    ULONG       cbArgsNumberTemp;       // number of bytes to store the fixed arg count
    ULONG       cbTotal = 0;            // total of number bytes for return type + all fixed arguments
    ULONG       cbCur = 0;              // index through the pvSigBlob
    ULONG       cb;
    ULONG       cArg;
    ULONG       cTyArg;
    ULONG       callingconv;
    ULONG       cArgsIndex;
    CorElementType ulElementType;
    BYTE        *pbSig;

    _ASSERTE (pvSigBlob && pcbSigBlob);

    // remember the number of bytes to represent the calling convention
    cbCalling = CorSigUncompressData (pvSigBlob, &callingconv);
    if (cbCalling == ((ULONG)(-1)))
    {
        return E_INVALIDARG;
    }
    _ASSERTE (isCallConv(callingconv, IMAGE_CEE_CS_CALLCONV_VARARG));
    cbCur += cbCalling;

    if (callingconv & IMAGE_CEE_CS_CALLCONV_GENERIC)
    {
        cbTyArgsNumber = CorSigUncompressData(&pvSigBlob[cbCur], &cTyArg);
        if (cbTyArgsNumber == ((ULONG)(-1)))
        {
            return E_INVALIDARG;
        }
        cbCur += cbTyArgsNumber;
    }

    // remember number of bytes to represent the arg counts
    cbArgsNumber= CorSigUncompressData (&pvSigBlob[cbCur], &cArg);
    if (cbArgsNumber == ((ULONG)(-1)))
    {
        return E_INVALIDARG;
    }
    
    cbCur += cbArgsNumber;

    // how many bytes to represent the return type
    cb = cbSigBlob-cbCur;
    IfFailGo( _CountBytesOfOneArg( &pvSigBlob[cbCur], &cb) );
    cbCur += cb;
    cbTotal += cb;

    // loop through argument until we found ELEMENT_TYPE_SENTINEL or run
    // out of arguments
    for (cArgsIndex = 0; cArgsIndex < cArg; cArgsIndex++)
    {
        _ASSERTE(cbCur < cbSigBlob);

        // peak the outter most ELEMENT_TYPE_*
        CorSigUncompressElementType (&pvSigBlob[cbCur], &ulElementType);
        if (ulElementType == ELEMENT_TYPE_SENTINEL)
            break;
        cb = cbSigBlob-cbCur;
        IfFailGo( _CountBytesOfOneArg( &pvSigBlob[cbCur], &cb) );
        cbTotal += cb;
        cbCur += cb;
    }

    cbArgsNumberTemp = CorSigCompressData(cArgsIndex, &cArg);

    // now cbCalling : the number of bytes needed to store the calling convention
    // cbArgNumberTemp : number of bytes to store the fixed arg count
    // cbTotal : the number of bytes to store the ret and fixed arguments

    *pcbSigBlob = cbCalling + cbArgsNumberTemp + cbTotal;

    // resize the buffer
    IfFailGo( pqbSig->ReSizeNoThrow(*pcbSigBlob) );
    pbSig = (BYTE *)pqbSig->Ptr();

    // copy over the calling convention
    cb = CorSigCompressData(callingconv, pbSig);

    // copy over the fixed arg count
    cbArgsNumberTemp = CorSigCompressData(cArgsIndex, &pbSig[cb]);

    // copy over the fixed args + ret type
    memcpy(&pbSig[cb + cbArgsNumberTemp], &pvSigBlob[cbCalling + cbArgsNumber], cbTotal);

ErrExit:
    return hr;
}


#endif // !SOS_INCLUDE


//*****************************************************************************
//
//***** File format helper classes
//
//*****************************************************************************

extern "C" {

/***************************************************************************/
/* Note that this construtor does not set the LocalSig, but has the
   advantage that it does not have any dependancy on EE structures.
   inside the EE use the FunctionDesc constructor */

void __stdcall DecoderInit(void * pThis, COR_ILMETHOD* header)
{
    COR_ILMETHOD_DECODER* decoder = (COR_ILMETHOD_DECODER*)pThis;

    memset(decoder, 0, sizeof(COR_ILMETHOD_DECODER));
    if (header->Tiny.IsTiny()) {
        decoder->SetMaxStack(header->Tiny.GetMaxStack());
        decoder->Code = header->Tiny.GetCode();
        decoder->SetCodeSize(header->Tiny.GetCodeSize());
        decoder->SetFlags(CorILMethod_TinyFormat);
        return;
    }
    if (header->Fat.IsFat()) {
#ifdef _WIN64
        if((((size_t) header) & 3) == 0)        // header is aligned
#else
        _ASSERTE((((size_t) header) & 3) == 0);        // header is aligned
#endif
        {
            *((COR_ILMETHOD_FAT*) decoder) = header->Fat;
            decoder->Code = header->Fat.GetCode();
            if(header->Fat.GetSize() >= 3)        // Size if valid
            {
                decoder->Sect = header->Fat.GetSect();
                if (decoder->Sect != 0 && decoder->Sect->Kind() == CorILMethod_Sect_EHTable) {
                    decoder->EH = (COR_ILMETHOD_SECT_EH*) decoder->Sect;
                    decoder->Sect = decoder->Sect->Next();
                }
            }
        }
        return;
    }
    // so we don't asert on trash  _ASSERTE(!"Unknown format");
}

// Calculate the total method size. First get address of end of code. If there are no sections, then
// the end of code addr marks end of COR_ILMETHOD. Otherwise find addr of end of last section and use it
// to mark end of COR_ILMETHD. Assumes that the code is directly followed
// by each section in the on-disk format
int __stdcall DecoderGetOnDiskSize(void * pThis, COR_ILMETHOD* header)
{
    COR_ILMETHOD_DECODER* decoder = (COR_ILMETHOD_DECODER*)pThis;

    if (!decoder->Code)
        return 0;
    
    BYTE *lastAddr = (BYTE*)decoder->Code + decoder->GetCodeSize();    // addr of end of code
    const COR_ILMETHOD_SECT *sect = decoder->EH;
    if (sect != 0 && sect->Next() == 0)
        lastAddr = (BYTE *)sect + sect->DataSize();
    else
    {
        const COR_ILMETHOD_SECT *nextSect;
        for (sect = decoder->Sect; sect; sect = nextSect) {
            nextSect = sect->Next();
            if (nextSect == 0) {
                // sect points to the last section, so set lastAddr
                lastAddr = (BYTE *)sect + sect->DataSize();
                break;
            }
        }
    }
    return (int)(lastAddr - (BYTE*)header);
}

/*********************************************************************/
/* APIs for emitting sections etc */

unsigned __stdcall IlmethodSize(COR_ILMETHOD_FAT* header, BOOL moreSections)
{
    if (header->GetMaxStack() <= 8 && (header->GetFlags() & ~CorILMethod_FormatMask) == 0
        && header->GetLocalVarSigTok() == 0 && header->GetCodeSize() < 64 && !moreSections)
        return(sizeof(COR_ILMETHOD_TINY));

    return(sizeof(COR_ILMETHOD_FAT));
}

/*********************************************************************/
        // emit the header (bestFormat) return amount emitted
unsigned __stdcall IlmethodEmit(unsigned size, COR_ILMETHOD_FAT* header,
                  BOOL moreSections, BYTE* outBuff)
{
#ifndef SOS_INCLUDE    
#ifdef _DEBUG
    BYTE* origBuff = outBuff;
#endif
#endif // !SOS_INCLUDE
    if (size == 1) {
            // Tiny format
        *outBuff++ = (BYTE) (CorILMethod_TinyFormat | (header->GetCodeSize() << 2));
    }
    else {
            // Fat format
        _ASSERTE((((size_t) outBuff) & 3) == 0);               // header is dword aligned
        COR_ILMETHOD_FAT* fatHeader = (COR_ILMETHOD_FAT*) outBuff;
        outBuff += sizeof(COR_ILMETHOD_FAT);
        *fatHeader = *header;
        fatHeader->SetFlags(fatHeader->GetFlags() | CorILMethod_FatFormat);
        _ASSERTE((fatHeader->GetFlags() & CorILMethod_FormatMask) == CorILMethod_FatFormat);
        if (moreSections)
            fatHeader->SetFlags(fatHeader->GetFlags() | CorILMethod_MoreSects);
        fatHeader->SetSize(sizeof(COR_ILMETHOD_FAT) / 4);
    }
#ifndef SOS_INCLUDE        
    _ASSERTE(&origBuff[size] == outBuff);
#endif // !SOS_INCLUDE
    return(size);
}

/*********************************************************************/
/* static */
IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* __stdcall SectEH_EHClause(void *pSectEH, unsigned idx, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff)
{
    if (((COR_ILMETHOD_SECT_EH *)pSectEH)->IsFat())
        return(&(((COR_ILMETHOD_SECT_EH *)pSectEH)->Fat.Clauses[idx]));

    COR_ILMETHOD_SECT_EH_CLAUSE_FAT* fatClause = (COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)buff;
    COR_ILMETHOD_SECT_EH_CLAUSE_SMALL* smallClause = (COR_ILMETHOD_SECT_EH_CLAUSE_SMALL*)&((COR_ILMETHOD_SECT_EH *)pSectEH)->Small.Clauses[idx];

    // mask to remove sign extension - cast just wouldn't work
    fatClause->SetFlags((CorExceptionFlag)(smallClause->GetFlags()&0x0000ffff));
    fatClause->SetClassToken(smallClause->GetClassToken());
    fatClause->SetTryOffset(smallClause->GetTryOffset());
    fatClause->SetTryLength(smallClause->GetTryLength());
    fatClause->SetHandlerLength(smallClause->GetHandlerLength());
    fatClause->SetHandlerOffset(smallClause->GetHandlerOffset());
    return(buff);
}
/*********************************************************************/
        // compute the size of the section (best format)
        // codeSize is the size of the method
    // deprecated
unsigned __stdcall SectEH_SizeWithCode(unsigned ehCount, unsigned codeSize)
{
    return((ehCount)? SectEH_SizeWorst(ehCount) : 0);
}

    // will return worse-case size and then Emit will return actual size
unsigned __stdcall SectEH_SizeWorst(unsigned ehCount)
{
    return((ehCount)? (COR_ILMETHOD_SECT_EH_FAT::Size(ehCount)) : 0);
}

    // will return exact size which will match the size returned by Emit
unsigned __stdcall SectEH_SizeExact(unsigned ehCount, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses)
{
    if (ehCount == 0)
        return(0);

    unsigned smallSize = COR_ILMETHOD_SECT_EH_SMALL::Size(ehCount);
    if (smallSize > COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE)
            return(COR_ILMETHOD_SECT_EH_FAT::Size(ehCount));
    for (unsigned i = 0; i < ehCount; i++) {
        COR_ILMETHOD_SECT_EH_CLAUSE_FAT* fatClause = (COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)&clauses[i];
        if (fatClause->GetTryOffset() > 0xFFFF ||
                fatClause->GetTryLength() > 0xFF ||
                fatClause->GetHandlerOffset() > 0xFFFF ||
                fatClause->GetHandlerLength() > 0xFF) {
            return(COR_ILMETHOD_SECT_EH_FAT::Size(ehCount));
        }
    }
    return smallSize;
}

/*********************************************************************/

        // emit the section (best format);
unsigned __stdcall SectEH_Emit(unsigned size, unsigned ehCount,
                  IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,
                  BOOL moreSections, BYTE* outBuff,
                  ULONG* ehTypeOffsets)
{
    if (size == 0)
       return(0);

    _ASSERTE((((size_t) outBuff) & 3) == 0);               // header is dword aligned
    BYTE* origBuff = outBuff;
    if (ehCount <= 0)
        return 0;

    // Initialize the ehTypeOffsets array.
    if (ehTypeOffsets)
    {
        for (unsigned int i = 0; i < ehCount; i++)
            ehTypeOffsets[i] = (ULONG) -1;
    }

    if (COR_ILMETHOD_SECT_EH_SMALL::Size(ehCount) < COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE) {
        COR_ILMETHOD_SECT_EH_SMALL* EHSect = (COR_ILMETHOD_SECT_EH_SMALL*) outBuff;
        unsigned i;
        for (i = 0; i < ehCount; i++) {
            COR_ILMETHOD_SECT_EH_CLAUSE_FAT* fatClause = (COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)&clauses[i];
            if (fatClause->GetTryOffset() > 0xFFFF ||
                    fatClause->GetTryLength() > 0xFF ||
                    fatClause->GetHandlerOffset() > 0xFFFF ||
                    fatClause->GetHandlerLength() > 0xFF) {
                break;  // fall through and generate as FAT
            }
            _ASSERTE((fatClause->GetFlags() & ~0xFFFF) == 0);
            _ASSERTE((fatClause->GetTryOffset() & ~0xFFFF) == 0);
            _ASSERTE((fatClause->GetTryLength() & ~0xFF) == 0);
            _ASSERTE((fatClause->GetHandlerOffset() & ~0xFFFF) == 0);
            _ASSERTE((fatClause->GetHandlerLength() & ~0xFF) == 0);

            COR_ILMETHOD_SECT_EH_CLAUSE_SMALL* smallClause = (COR_ILMETHOD_SECT_EH_CLAUSE_SMALL*)&EHSect->Clauses[i];
            smallClause->SetFlags((CorExceptionFlag) fatClause->GetFlags());
            smallClause->SetTryOffset(fatClause->GetTryOffset());
            smallClause->SetTryLength(fatClause->GetTryLength());
            smallClause->SetHandlerOffset(fatClause->GetHandlerOffset());
            smallClause->SetHandlerLength(fatClause->GetHandlerLength());
            smallClause->SetClassToken(fatClause->GetClassToken());
        }
        if (i >= ehCount) {
            // if actually got through all the clauses and they are small enough
            EHSect->Kind = CorILMethod_Sect_EHTable;
            if (moreSections)
                EHSect->Kind |= CorILMethod_Sect_MoreSects;
#ifndef SOS_INCLUDE            
            EHSect->DataSize = EHSect->Size(ehCount);
#else
            EHSect->DataSize = (BYTE) EHSect->Size(ehCount);
#endif // !SOS_INCLUDE
            EHSect->Reserved = 0;
            _ASSERTE(EHSect->DataSize == EHSect->Size(ehCount)); // make sure didn't overflow
            outBuff = (BYTE*) &EHSect->Clauses[ehCount];
            // Set the offsets for the exception type tokens.
            if (ehTypeOffsets)
            {
                for (i = 0; i < ehCount; i++) {
                    COR_ILMETHOD_SECT_EH_CLAUSE_SMALL* smallClause = (COR_ILMETHOD_SECT_EH_CLAUSE_SMALL*)&EHSect->Clauses[i];
                    if (smallClause->GetFlags() == COR_ILEXCEPTION_CLAUSE_NONE)
                    {
                        _ASSERTE(! IsNilToken(smallClause->GetClassToken()));
                        ehTypeOffsets[i] = (ULONG)((BYTE *)&smallClause->ClassToken - origBuff);
                    }
                }
            }
            return(size);
        }
    }
    // either total size too big or one of constituent elements too big (eg. offset or length)
    COR_ILMETHOD_SECT_EH_FAT* EHSect = (COR_ILMETHOD_SECT_EH_FAT*) outBuff;
    EHSect->SetKind(CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat);
    if (moreSections)
        EHSect->SetKind(EHSect->GetKind() | CorILMethod_Sect_MoreSects);

    EHSect->SetDataSize(EHSect->Size(ehCount));
    memcpy(EHSect->Clauses, clauses, ehCount * sizeof(COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
    outBuff = (BYTE*) &EHSect->Clauses[ehCount];
    _ASSERTE(&origBuff[size] == outBuff);
    // Set the offsets for the exception type tokens.
    if (ehTypeOffsets)
    {
        for (unsigned int i = 0; i < ehCount; i++) {
            COR_ILMETHOD_SECT_EH_CLAUSE_FAT* fatClause = (COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)&EHSect->Clauses[i];
            if (fatClause->GetFlags() == COR_ILEXCEPTION_CLAUSE_NONE)
            {
                _ASSERTE(! IsNilToken(fatClause->GetClassToken()));
                ehTypeOffsets[i] = (ULONG)((BYTE *)&fatClause->ClassToken - origBuff);
            }
        }
    }
    return(size);
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\corhlpr.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
/*****************************************************************************
 **                                                                         **
 ** Corhlpr.h - <STRIP>this file contains a set of "as is" code that may be **
 **             used by developers writing compilers and tools against      **
 **             the Common Language Runtime. The code is not officially     **
 **             supported, but is code being used by the Runtime itself.    **
 ** </STRIP>                                                                **
 **                                                                         **
 *****************************************************************************/


#ifndef __CORHLPR_H__
#define __CORHLPR_H__

#if defined(_MSC_VER) && defined(_X86_) && !defined(FPO_ON)
#pragma optimize("y", on)		// Small critical routines, don't put in EBP frame 
#define FPO_ON 1
#define CORHLPR_TURNED_FPO_ON 1
#endif

#include "cor.h"
#include "corhdr.h"
#include "corerror.h"

// This header is consumed both within the runtime and externally. In the former
// case we need to wrap memory allocations, in the latter there is no
// infrastructure to support this. Detect which way we're building and provide a
// very simple abstraction layer (handles allocating bytes only).
#ifdef _BLD_CLR
#include "new.hpp"


#define NEW_NOTHROW(_bytes) new (nothrow) BYTE[_bytes]
#define NEW_THROWS(_bytes) new BYTE[_bytes]
#else
#define NEW_NOTHROW(_bytes) new BYTE[_bytes]
#define NEW_THROWS(_bytes) __CorHlprNewThrows(_bytes)
static inline BYTE *__CorHlprNewThrows(size_t bytes)
{
    BYTE *pbMemory = new BYTE[bytes];
    if (pbMemory == NULL)
        RaiseException(STATUS_NO_MEMORY, 0, 0, NULL);
    return pbMemory;
}
#endif


//*****************************************************************************
// There are a set of macros commonly used in the helpers which you will want
// to override to get richer behavior.  The following defines what is needed
// if you chose not to do the extra work.
//*****************************************************************************
#ifndef IfFailGoto
#define IfFailGoto(EXPR, LABEL) \
do { hr = (EXPR); if(FAILED(hr)) { goto LABEL; } } while (0)
#endif

#ifndef IfFailGo
#define IfFailGo(EXPR) IfFailGoto(EXPR, ErrExit)
#endif

#ifndef IfFailRet
#define IfFailRet(EXPR) do { hr = (EXPR); if(FAILED(hr)) { return (hr); } } while (0)
#endif

#ifndef IfNullRet
#define IfNullRet(EXPR) do { if ((EXPR) == NULL){ return (E_OUTOFMEMORY); } } while (0)
#endif


#ifndef _ASSERTE
#define _ASSERTE(expr)
#endif

#ifndef COUNTOF
#define COUNTOF(a) (sizeof(a) / sizeof(*a))
#endif

#if !BIGENDIAN
#define VAL16(x) x
#define VAL32(x) x
#endif


//*****************************************************************************
//
//***** Macro to assist with cleaning up local static variables
//
//*****************************************************************************

#define CHECK_LOCAL_STATIC_VAR(x)   \
    x                                \

//*****************************************************************************
//
//***** Utility helpers
//
//*****************************************************************************


#define MAX_CLASSNAME_LENGTH 1024

#ifndef SOS_INCLUDE

//*****************************************************************************
//
// **** CQuickBytes
// This helper class is useful for cases where 90% of the time you allocate 512
// or less bytes for a data structure.  This class contains a 512 byte buffer.
// Alloc() will return a pointer to this buffer if your allocation is small
// enough, otherwise it asks the heap for a larger buffer which is freed for
// you.  No mutex locking is required for the small allocation case, making the
// code run faster, less heap fragmentation, etc...  Each instance will allocate
// 520 bytes, so use accordinly.
//
//*****************************************************************************
template <DWORD SIZE, DWORD INCREMENT>
class CQuickMemoryBase
{
public:
    void Init()
    {
        pbBuff = 0;
        iSize = 0;
        cbTotal = SIZE;
    }

    void Destroy()
    {
        if (pbBuff)
        {
            delete [] pbBuff;
            pbBuff = 0;
        }
    }

    void *AllocThrows(SIZE_T iItems)
    {
#ifdef _BLD_CLR
#ifdef _DEBUG
        delete [] NEW_THROWS(iItems);    // Exercise heap for OOM-fault injection purposes
#endif
#endif
        if (iItems <= SIZE)
        {
            iSize = iItems;
            cbTotal = SIZE;
            return (&rgData[0]);
        }
        else
        {
            BYTE *pTmp = NEW_THROWS(iItems);

            if (pbBuff) delete [] pbBuff;
            // We need the following line to make data structure consistant if
            // new throws.
            iSize = iItems;
            cbTotal = 0;
            pbBuff = pTmp;
            cbTotal = iItems;
            return (pbBuff);
        }
    }

    void *AllocNoThrow(SIZE_T iItems)
    {
#ifdef _BLD_CLR
#ifdef _DEBUG
        {
            // Exercise heap for OOM-fault injection purposes
            BYTE *pTmp = NEW_NOTHROW(iItems);
            if (!pTmp)
            {
                return NULL;
            }
            delete [] pTmp;
        }
#endif
#endif
        if (iItems <= SIZE)
        {
            cbTotal = SIZE;
            iSize = iItems;
            return (&rgData[0]);
        }
        else
        {
            if (pbBuff) delete [] pbBuff;
            pbBuff = NEW_NOTHROW(iItems);
            if (pbBuff)
            {
                cbTotal = iItems;
                iSize   = iItems;
            }
            else
            {
                cbTotal = 0;
                iSize   = 0;
            }
            return (pbBuff);
        }
    }

    void ReSizeThrows(SIZE_T iItems)
    {
#ifdef _BLD_CLR
#ifdef _DEBUG
        // Exercise heap for OOM-fault injection purposes
        delete [] NEW_THROWS(iItems);
#endif
#endif
        BYTE *pbBuffNew;
        if (iItems <= cbTotal)
        {
            iSize = iItems;
            return;
        }

        pbBuffNew = NEW_THROWS(iItems + INCREMENT);

        if (pbBuff)
        {
            memcpy(pbBuffNew, pbBuff, cbTotal);
            delete [] pbBuff;
        }
        else
        {
            _ASSERTE(cbTotal == SIZE);
            memcpy(pbBuffNew, rgData, cbTotal);
        }
        cbTotal = iItems + INCREMENT;
        iSize = iItems;
        pbBuff = pbBuffNew;
    }

    HRESULT ReSizeNoThrow(SIZE_T iItems);

    void Shrink(SIZE_T iItems)
    {
        _ASSERTE(iItems <= cbTotal);
        iSize = iItems;
    }

    operator PVOID()
    {
        return ((pbBuff) ? pbBuff : (PVOID)&rgData[0]);
    }

    void *Ptr()
    {
        return ((pbBuff) ? pbBuff : (PVOID)&rgData[0]);
    }

    const void *Ptr() const
    {
        return ((pbBuff) ? pbBuff : (PVOID)&rgData[0]);
    }

    SIZE_T Size() const
    {
        return (iSize);
    }

    SIZE_T MaxSize() const
    {
        return (cbTotal);
    }

    void Maximize()
    {
        iSize = cbTotal;
    }

    BYTE       *pbBuff;
    SIZE_T      iSize;              // number of bytes used
    SIZE_T      cbTotal;            // total bytes allocated in the buffer
    // use UINT64 to enforce the alignment of the memory
    UINT64 rgData[(SIZE+sizeof(UINT64)-1)/sizeof(UINT64)];
};

// These should be multiples of 8 so that data can be naturally aligned.
#define     CQUICKBYTES_BASE_SIZE           512
#define     CQUICKBYTES_INCREMENTAL_SIZE    128

class CQuickBytesBase : public CQuickMemoryBase<CQUICKBYTES_BASE_SIZE, CQUICKBYTES_INCREMENTAL_SIZE>
{
};

class CQuickBytes : public CQuickBytesBase
{
public:
    CQuickBytes()
    {
        Init();
    }

    ~CQuickBytes()
    {
        Destroy();
    }
};

/* to be used as static variable - no constructor/destructor, assumes zero
   initialized memory */
class CQuickBytesStatic : public CQuickBytesBase
{
};

template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE>
class CQuickBytesSpecifySizeBase : public CQuickMemoryBase<CQUICKBYTES_BASE_SPECIFY_SIZE, CQUICKBYTES_INCREMENTAL_SIZE>
{
};

template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE>
class CQuickBytesSpecifySize : public CQuickBytesSpecifySizeBase<CQUICKBYTES_BASE_SPECIFY_SIZE>
{
public:
    CQuickBytesSpecifySize()
    {
        Init();
    }

    ~CQuickBytesSpecifySize()
    {
        Destroy();
    }
};

/* to be used as static variable - no constructor/destructor, assumes zero
   initialized memory */
template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE>
class CQuickBytesSpecifySizeStatic : public CQuickBytesSpecifySizeBase<CQUICKBYTES_BASE_SPECIFY_SIZE>
{
};

template <class T> class CQuickArrayBase : public CQuickBytesBase
{
public:
    T* AllocThrows(int iItems)
    {   
        return (T*)CQuickBytesBase::AllocThrows(iItems * sizeof(T)); 
    }

    void ReSizeThrows(SIZE_T iItems)
    { 
        CQuickBytesBase::ReSizeThrows(iItems * sizeof(T));
    }

    T* AllocNoThrow(int iItems)
    { 
        return (T*)CQuickBytesBase::AllocNoThrow(iItems * sizeof(T)); 
    }

    HRESULT ReSizeNoThrow(SIZE_T iItems)
    { 
        return CQuickBytesBase::ReSizeNoThrow(iItems * sizeof(T)); 
    }
    
    void Shrink(SIZE_T iItems)    
    { 
        CQuickBytesBase::Shrink(iItems * sizeof(T)); 
    }

    T* Ptr()
    { 
        return (T*) CQuickBytesBase::Ptr(); 
    }

    const T* Ptr() const
    { 
        return (T*) CQuickBytesBase::Ptr(); 
    }

    SIZE_T Size() const
    { 
        return CQuickBytesBase::Size() / sizeof(T); 
    }

    SIZE_T MaxSize() const
    { 
        return CQuickBytesBase::cbTotal / sizeof(T); 
    }

    T& operator[] (SIZE_T ix)
    { 
        _ASSERTE(ix < Size());
        return *(Ptr() + ix);
    }

    const T& operator[] (SIZE_T ix) const
    { 
        _ASSERTE(ix < Size());
        return *(Ptr() + ix);
    }
};

template <class T> class CQuickArray : public CQuickArrayBase<T>
{
public:
    CQuickArray<T>()
    {
        Init();
    }

    ~CQuickArray<T>()
    {
        Destroy();
    }
};

/* to be used as static variable - no constructor/destructor, assumes zero
   initialized memory */
template <class T> class CQuickArrayStatic : public CQuickArrayBase<T>
{
};

typedef CQuickArrayBase<WCHAR> CQuickWSTRBase;
typedef CQuickArray<WCHAR> CQuickWSTR;
typedef CQuickArrayStatic<WCHAR> CQuickWSTRStatic;

typedef CQuickArrayBase<CHAR> CQuickSTRBase;
typedef CQuickArray<CHAR> CQuickSTR;
typedef CQuickArrayStatic<CHAR> CQuickSTRStatic;

class RidBitmap
{
public:
    HRESULT InsertToken(mdToken token)
    {
        mdToken rid   = RidFromToken(token);
        SIZE_T  index = rid / 8;
        BYTE    bit   = (1 << (rid % 8));

        if (index >= buffer.Size())
        {
            HRESULT hr;
            SIZE_T oldSize = buffer.Size();
            SIZE_T newSize = index+1+oldSize/8;
            IfFailRet(buffer.ReSizeNoThrow(newSize));
            memset(&buffer[oldSize], 0, newSize-oldSize);
        }

        buffer[index] |= bit;
        return S_OK;
    }

    bool IsTokenInBitmap(mdToken token)
    {
        mdToken rid   = RidFromToken(token);
        SIZE_T  index = rid / 8;
        BYTE    bit   = (1 << (rid % 8));

        return ((index < buffer.Size()) && (buffer[index] & bit));
    }

    void Reset()
    {
        if (buffer.Size()) 
        {
            memset(&buffer[0], 0, buffer.Size());
        }
    }

private:
    CQuickArray<BYTE> buffer;
};

#endif // SOS_INCLUDE
//*****************************************************************************
//
//***** Signature helpers
//
//*****************************************************************************

inline bool isCallConv(unsigned sigByte, CorCallingConvention conv)
{
    return ((sigByte & IMAGE_CEE_CS_CALLCONV_MASK) == (unsigned) conv);
}

HRESULT _CountBytesOfOneArg(
    PCCOR_SIGNATURE pbSig,
    ULONG       *pcbTotal);

HRESULT _GetFixedSigOfVarArg(           // S_OK or error.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob of CLR signature
    ULONG   cbSigBlob,                  // [IN] size of signature
    CQuickBytes *pqbSig,                // [OUT] output buffer for fixed part of VarArg Signature
    ULONG   *pcbSigBlob);               // [OUT] number of bytes written to the above output buffer




//*****************************************************************************
//
//***** File format helper classes
//
//*****************************************************************************



//*****************************************************************************
typedef struct tagCOR_ILMETHOD_SECT_SMALL : IMAGE_COR_ILMETHOD_SECT_SMALL {
        //Data follows
    const BYTE* Data() const 
    { 
        return(((const BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_SECT_SMALL)); 
    }
} COR_ILMETHOD_SECT_SMALL;


/************************************/
/* NOTE this structure must be DWORD aligned!! */
typedef struct tagCOR_ILMETHOD_SECT_FAT : IMAGE_COR_ILMETHOD_SECT_FAT {
        //Data follows
    const BYTE* Data() const 
    { 
        return(((const BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_SECT_FAT)); 
    }

        //Endian-safe wrappers
    unsigned GetKind() const {
        /* return Kind; */
        return *(BYTE*)this;
    }
    void SetKind(unsigned kind) {
        /* Kind = kind; */
        *(BYTE*)this = (BYTE)kind;
    }

    unsigned GetDataSize() const {
        /* return DataSize; */
        BYTE* p = (BYTE*)this;
        return ((unsigned)*(p+1)) |
            (((unsigned)*(p+2)) << 8) |
            (((unsigned)*(p+3)) << 16);
    }
    void SetDataSize(unsigned datasize) {
        /* DataSize = dataSize; */
        BYTE* p = (BYTE*)this;
        *(p+1) = (BYTE)(datasize);
        *(p+2) = (BYTE)(datasize >> 8);
        *(p+3) = (BYTE)(datasize >> 16);
    }
} COR_ILMETHOD_SECT_FAT;

typedef struct tagCOR_ILMETHOD_SECT_EH_CLAUSE_FAT : public IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT {
    //Endian-safe wrappers
    CorExceptionFlag GetFlags() const {
        return (CorExceptionFlag)VAL32((unsigned)Flags);
    }
    void SetFlags(CorExceptionFlag flags) {
        Flags = (CorExceptionFlag)VAL32((unsigned)flags);
    }

    DWORD GetTryOffset() const {
        return VAL32(TryOffset);
    }
    void SetTryOffset(DWORD Offset) {
        TryOffset = VAL32(Offset);
    }

    DWORD GetTryLength() const {
        return VAL32(TryLength);
    }
    void SetTryLength(DWORD Length) {
        TryLength = VAL32(Length);
    }

    DWORD GetHandlerOffset() const {
        return VAL32(HandlerOffset);
    }
    void SetHandlerOffset(DWORD Offset) {
        HandlerOffset = VAL32(Offset);
    }

    DWORD GetHandlerLength() const {
        return VAL32(HandlerLength);
    }
    void SetHandlerLength(DWORD Length) {
        HandlerLength = VAL32(Length);
    }

    DWORD GetClassToken() const {
        return VAL32(ClassToken);
    }
    void SetClassToken(DWORD tok) {
        ClassToken = VAL32(tok);
    }

    DWORD GetFilterOffset() const {
        return VAL32(FilterOffset);
    }
    void SetFilterOffset(DWORD offset) {
        FilterOffset = VAL32(offset);
    }

} COR_ILMETHOD_SECT_EH_CLAUSE_FAT;

//*****************************************************************************
struct COR_ILMETHOD_SECT_EH_FAT : public COR_ILMETHOD_SECT_FAT {
    static unsigned Size(unsigned ehCount) {
        return (sizeof(COR_ILMETHOD_SECT_EH_FAT) +
                sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT) * (ehCount-1));
        }

    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size
};

typedef struct tagCOR_ILMETHOD_SECT_EH_CLAUSE_SMALL : public IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL {
    //Endian-safe wrappers
    CorExceptionFlag GetFlags() const {
        return (CorExceptionFlag)VAL16((SHORT)Flags);
    }
    void SetFlags(CorExceptionFlag flags) {
        Flags = (CorExceptionFlag)VAL16((SHORT)flags);
    }

    DWORD GetTryOffset() const {
        return VAL16(TryOffset);
    }
    void SetTryOffset(DWORD Offset) {
        TryOffset = VAL16(Offset);
    }

    DWORD GetTryLength() const {
        return TryLength;
    }
    void SetTryLength(DWORD Length) {
        TryLength = Length;
    }

    DWORD GetHandlerOffset() const {
        return VAL16(HandlerOffset);
    }
    void SetHandlerOffset(DWORD Offset) {
        HandlerOffset = VAL16(Offset);
    }

    DWORD GetHandlerLength() const {
        return HandlerLength;
    }
    void SetHandlerLength(DWORD Length) {
        HandlerLength = Length;
    }

    DWORD GetClassToken() const {
        return VAL32(ClassToken);
    }
    void SetClassToken(DWORD tok) {
        ClassToken = VAL32(tok);
    }

    DWORD GetFilterOffset() const {
        return VAL32(FilterOffset);
    }
    void SetFilterOffset(DWORD offset) {
        FilterOffset = VAL32(offset);
    }
} COR_ILMETHOD_SECT_EH_CLAUSE_SMALL;

//*****************************************************************************
struct COR_ILMETHOD_SECT_EH_SMALL : public COR_ILMETHOD_SECT_SMALL {
    static unsigned Size(unsigned ehCount) {
        return (sizeof(COR_ILMETHOD_SECT_EH_SMALL) +
                sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL) * (ehCount-1));
        }

    WORD Reserved;                                  // alignment padding
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size
};


/************************************/
/* NOTE this structure must be DWORD aligned!! */
struct COR_ILMETHOD_SECT
{
    bool More() const           
    { 
        return((AsSmall()->Kind & CorILMethod_Sect_MoreSects) != 0); 
    }

    CorILMethodSect Kind() const
    { 
        return((CorILMethodSect) (AsSmall()->Kind & CorILMethod_Sect_KindMask)); 
    }

    const COR_ILMETHOD_SECT* Next() const   
    {
        if (!More()) return(0);
        if (IsFat()) return(((COR_ILMETHOD_SECT*) &AsFat()->Data()[AsFat()->GetDataSize()])->Align());
        return(((COR_ILMETHOD_SECT*) &AsSmall()->Data()[AsSmall()->DataSize])->Align());
    }

    const COR_ILMETHOD_SECT* NextLoc() const   
    {
        if (IsFat()) return(((COR_ILMETHOD_SECT*) &AsFat()->Data()[AsFat()->GetDataSize()])->Align());
        return(((COR_ILMETHOD_SECT*) &AsSmall()->Data()[AsSmall()->DataSize])->Align());
    }

    const BYTE* Data() const 
    {
        if (IsFat()) return(AsFat()->Data());
        return(AsSmall()->Data());
    }

    unsigned EHSize() const
    {
        // Work around a bug where VB doesn't specify the size correctly for EH sections

        if (Kind() == CorILMethod_Sect_EHTable) 
        {
            if (IsFat())
                return Fat.Size(Fat.GetDataSize() / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
            else
                return Small.Size(Small.DataSize / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL));
        }

        return 0;
    }

    unsigned DataSizeHelper() const 
    {
        if (IsFat()) return(AsFat()->GetDataSize());
        return(AsSmall()->DataSize);
    }

    unsigned DataSize() const
    {
        // When VB fixes bug #26859 (where they don't specify DataSize correctly), we can
        // remove this code and just use the code in DataSizeHelper.
        unsigned ehSize = EHSize();
        unsigned dataSizeHelper = DataSizeHelper();
        return (dataSizeHelper > ehSize) ? dataSizeHelper : ehSize;
    }

    friend struct COR_ILMETHOD;
    friend struct tagCOR_ILMETHOD_FAT;
    friend struct tagCOR_ILMETHOD_TINY;
    bool IsFat() const                            
    { 
        return((AsSmall()->Kind & CorILMethod_Sect_FatFormat) != 0); 
    }

    const COR_ILMETHOD_SECT* Align() const        
    { 
        return((COR_ILMETHOD_SECT*) ((((UINT_PTR) this) + 3) & ~3));  
    }

protected:
    const COR_ILMETHOD_SECT_FAT*   AsFat() const  
    { 
        return((COR_ILMETHOD_SECT_FAT*) this); 
    }

    const COR_ILMETHOD_SECT_SMALL* AsSmall() const
    { 
        return((COR_ILMETHOD_SECT_SMALL*) this); 
    }

public:
    // The body is either a COR_ILMETHOD_SECT_SMALL or COR_ILMETHOD_SECT_FAT
    // (as indicated by the CorILMethod_Sect_FatFormat bit
    union {
        COR_ILMETHOD_SECT_EH_SMALL Small;
        COR_ILMETHOD_SECT_EH_FAT Fat;
        };
};


/***********************************/
// exported functions (implementation in Format\Format.cpp:
extern "C" {
IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* __stdcall SectEH_EHClause(void *pSectEH, unsigned idx, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff);
        // compute the size of the section (best format)
        // codeSize is the size of the method
    // deprecated
unsigned __stdcall SectEH_SizeWithCode(unsigned ehCount, unsigned codeSize);

    // will return worse-case size and then Emit will return actual size
unsigned __stdcall SectEH_SizeWorst(unsigned ehCount);

    // will return exact size which will match the size returned by Emit
unsigned __stdcall SectEH_SizeExact(unsigned ehCount, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses);

        // emit the section (best format);
unsigned __stdcall SectEH_Emit(unsigned size, unsigned ehCount,
                  IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,
                  BOOL moreSections, BYTE* outBuff,
                  ULONG* ehTypeOffsets = 0);
} // extern "C"


struct COR_ILMETHOD_SECT_EH : public COR_ILMETHOD_SECT
{
    unsigned EHCount() const 
    {
        return (unsigned)(IsFat() ? (Fat.GetDataSize() / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT)) :
                        (Small.DataSize / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL)));
    }

        // return one clause in its fat form.  Use 'buff' if needed
    const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* EHClause(unsigned idx, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff) const
    { 
        return SectEH_EHClause((void *)this, idx, buff); 
    };
        // compute the size of the section (best format)
        // codeSize is the size of the method
    // deprecated
    unsigned static Size(unsigned ehCount, unsigned codeSize)
    { 
        return SectEH_SizeWithCode(ehCount, codeSize); 
    };

    // will return worse-case size and then Emit will return actual size
    unsigned static Size(unsigned ehCount)
    { 
        return SectEH_SizeWorst(ehCount); 
    };

    // will return exact size which will match the size returned by Emit
    unsigned static Size(unsigned ehCount, const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses)
    { 
        return SectEH_SizeExact(ehCount, (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)clauses);  
    };

        // emit the section (best format);
    unsigned static Emit(unsigned size, unsigned ehCount,
                  const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,
                  bool moreSections, BYTE* outBuff,
                  ULONG* ehTypeOffsets = 0)
    { 
        return SectEH_Emit(size, ehCount,
                           (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)clauses,
                           moreSections, outBuff, ehTypeOffsets); 
    };
};


/***************************************************************************/
/* Used when the method is tiny (< 64 bytes), and there are no local vars */
typedef struct tagCOR_ILMETHOD_TINY : IMAGE_COR_ILMETHOD_TINY
{
    bool     IsTiny() const         
    { 
        return((Flags_CodeSize & (CorILMethod_FormatMask >> 1)) == CorILMethod_TinyFormat); 
    }

    unsigned GetCodeSize() const    
    { 
        return(((unsigned) Flags_CodeSize) >> (CorILMethod_FormatShift-1)); 
    }

    unsigned GetMaxStack() const    
    { 
        return(8); 
    }

    BYTE*    GetCode() const        
    { 
        return(((BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_TINY)); 
    }

    DWORD    GetLocalVarSigTok() const  
    { 
        return(0); 
    }

    COR_ILMETHOD_SECT* GetSect() const 
    { 
        return(0); 
    }
} COR_ILMETHOD_TINY;


/************************************/
// This strucuture is the 'fat' layout, where no compression is attempted.
// Note that this structure can be added on at the end, thus making it extensible
typedef struct tagCOR_ILMETHOD_FAT : IMAGE_COR_ILMETHOD_FAT
{
        //Endian-safe wrappers
    unsigned GetSize() const {
        /* return Size; */
        BYTE* p = (BYTE*)this;
        return *(p+1) >> 4;
    }
    void SetSize(unsigned size) {
        /* Size = size; */
        BYTE* p = (BYTE*)this;
        *(p+1) = (BYTE)((*(p+1) & 0x0F) | (size << 4));
    }

    unsigned GetFlags() const {
        /* return Flags; */
        BYTE* p = (BYTE*)this;
        return ((unsigned)*(p+0)) | (( ((unsigned)*(p+1)) << 8) & 0x0F);
    }
    void SetFlags(unsigned flags) {
        /* flags = Flags; */
        BYTE* p = (BYTE*)this;
        *p = (BYTE)flags;
        *(p+1) = (BYTE)((*(p+1) & 0xF0) | ((flags >> 8) & 0x0F));
    }

    bool IsFat() const {
        /* return((IMAGE_COR_ILMETHOD_FAT::GetFlags() & CorILMethod_FormatMask) == CorILMethod_FatFormat); */
        return (*(BYTE*)this & CorILMethod_FormatMask) == CorILMethod_FatFormat;
    }

    unsigned GetMaxStack() const {
        /* return MaxStack; */
        return VAL16(*(USHORT*)((BYTE*)this+2));
    }
    void SetMaxStack(unsigned maxStack) {
        /* MaxStack = maxStack; */
        *(USHORT*)((BYTE*)this+2) = VAL16((USHORT)maxStack);
    }

    unsigned GetCodeSize() const        
    { 
        return VAL32(CodeSize); 
    }

    void SetCodeSize(DWORD Size)        
    { 
        CodeSize = VAL32(Size); 
    }

    mdToken  GetLocalVarSigTok() const      
    { 
        return VAL32(LocalVarSigTok); 
    }

    void SetLocalVarSigTok(mdSignature tok) 
    { 
        LocalVarSigTok = VAL32(tok); 
    }

    BYTE* GetCode() const {
        return(((BYTE*) this) + 4*GetSize());
    }

    const COR_ILMETHOD_SECT* GetSect() const {
        /* if (!(GetFlags() & CorILMethod_MoreSects)) return(0); */
        if (!(*(BYTE*)this & CorILMethod_MoreSects)) return (0);
        return(((COR_ILMETHOD_SECT*) (GetCode() + GetCodeSize()))->Align());
    }
} COR_ILMETHOD_FAT;


extern "C" {
/************************************/
// exported functions (impl. Format\Format.cpp)
unsigned __stdcall IlmethodSize(COR_ILMETHOD_FAT* header, BOOL MoreSections);
        // emit the header (bestFormat) return amount emitted
unsigned __stdcall IlmethodEmit(unsigned size, COR_ILMETHOD_FAT* header,
                  BOOL moreSections, BYTE* outBuff);
}

struct COR_ILMETHOD
{
        // a COR_ILMETHOD header should not be decoded by hand.  Instead us
        // COR_ILMETHOD_DECODER to decode it.
    friend class COR_ILMETHOD_DECODER;

        // compute the size of the header (best format)
    unsigned static Size(const COR_ILMETHOD_FAT* header, bool MoreSections)
    { 
        return IlmethodSize((COR_ILMETHOD_FAT*)header,MoreSections); 
    };
        // emit the header (bestFormat) return amount emitted
    unsigned static Emit(unsigned size, const COR_ILMETHOD_FAT* header,
                  bool moreSections, BYTE* outBuff)
    { 
        return IlmethodEmit(size, (COR_ILMETHOD_FAT*)header, moreSections, outBuff); 
    };

//private:
    union
    {
        COR_ILMETHOD_TINY       Tiny;
        COR_ILMETHOD_FAT        Fat;
    };
        // Code follows the Header, then immedately after the code comes
        // any sections (COR_ILMETHOD_SECT).
};

extern "C" {
/***************************************************************************/
/* COR_ILMETHOD_DECODER is the only way functions internal to the EE should
   fetch data from a COR_ILMETHOD.  This way any dependancy on the file format
   (and the multiple ways of encoding the header) is centralized to the
   COR_ILMETHOD_DECODER constructor) */
    void __stdcall DecoderInit(void * pThis, COR_ILMETHOD* header);
    int  __stdcall DecoderGetOnDiskSize(void * pThis, COR_ILMETHOD* header);
} // extern "C"

class COR_ILMETHOD_DECODER : public COR_ILMETHOD_FAT
{
public:
    // Typically the ONLY way you should access COR_ILMETHOD is through
    // this constructor so format changes are easier.
    COR_ILMETHOD_DECODER(const COR_ILMETHOD* header) 
    { 
        DecoderInit(this,(COR_ILMETHOD*)header); 
    };

    // The above variant of the constructor can not do a 'complete' job, because
    // it can not look up the local variable signature meta-data token.
    // This method should be used when you have access to the Meta data API
    // If the construction fails, the 'Code' field is set to 0

    enum DecoderStatus {SUCCESS, FORMAT_ERROR, VERIFICATION_ERROR};

    // If we want the decoder to verify the that local signature is OK we
    // will pass a non-NULL value for wbStatus
    //
    // When using LazyInit we want ask that the local signature be verified
    // But if we fail verification we still need access to the 'Code' field
    // Because we may be able to demand SkipVerification and thus it was OK
    // to have had a verification error.

    COR_ILMETHOD_DECODER(COR_ILMETHOD* header, 
                         void *pInternalImport,
                         DecoderStatus* wbStatus);

    unsigned EHCount() const 
    {
        return (EH != 0) ? EH->EHCount() : 0;
    }

    unsigned GetHeaderSize() const
    {
        return GetCodeSize() + ((EH != 0) ? EH->DataSize() : 0);
    }

    // returns total size of method for use in copying
    int GetOnDiskSize(const COR_ILMETHOD* header) 
    { 
        return DecoderGetOnDiskSize(this,(COR_ILMETHOD*)header); 
    }

    // Flags        these are available because we inherit COR_ILMETHOD_FAT
    // MaxStack
    // CodeSize
    const BYTE* Code;
    PCCOR_SIGNATURE LocalVarSig;        // pointer to signature blob, or 0 if none
    const COR_ILMETHOD_SECT_EH* EH;     // eh table if any  0 if none
    const COR_ILMETHOD_SECT* Sect;      // additional sections  0 if none
};

#if defined(CORHLPR_TURNED_FPO_ON)
#pragma optimize("", on)		// Go back to command line default optimizations
#undef CORHLPR_TURNED_FPO_ON
#undef FPO_ON
#endif

#endif // __CORHLPR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Cplext.h ===
///////////////////////////////////////////////////////////////////////////////
//
// CPLEXT.H  --  defines for property sheet extensions to system control panels
//
// Version 4.00
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _INC_CPLEXT
#define _INC_CPLEXT


///////////////////////////////////////////////////////////////////////////////
//  Below are constants for pages which can be replaced in the standard control
// panel applets.  To extend an applet, you must define an object which
// supports the IShellPropSheetExt interface and register it's in-process
// server in a subkey under the applet's registry key.  Registry paths for the
// applets are defined in the header file REGSTR.H
//  Generally, when an IShellPropSheetExt is loaded, it's AddPages method
// will be called once, while it's ReplacePage method may be called zero or
// more times.  ReplacePage is only called in context.
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Mouse Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Mouse" )
//-----------------------------------------------------------------------------

#define CPLPAGE_MOUSE_BUTTONS       1
#define CPLPAGE_MOUSE_PTRMOTION     2
#define CPLPAGE_MOUSE_WHEEL         3


//-----------------------------------------------------------------------------
// Keyboard Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Keyboard" )
//-----------------------------------------------------------------------------

#define CPLPAGE_KEYBOARD_SPEED      1


//-----------------------------------------------------------------------------
// Display Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Display" )
//-----------------------------------------------------------------------------

#define CPLPAGE_DISPLAY_BACKGROUND  1


///////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\CorHdr.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
/*****************************************************************************
 **                                                                         **
 ** CorHdr.h - contains definitions for the Runtime structures,             **
 **            needed to work with metadata.                                **
 **                                                                         **
 *****************************************************************************/


#ifndef __CORHDR_H__
#define __CORHDR_H__

#define FRAMEWORK_REGISTRY_KEY          "Software\\Microsoft\\.NETFramework"
#define FRAMEWORK_REGISTRY_KEY_W        L"Software\\Microsoft\\.NETFramework"

#ifdef _MSC_VER
#pragma warning(disable:4200) // nonstandard extension used : zero-sized array in struct/union.
#endif
typedef LPVOID  mdScope;                // Obsolete; not used in the runtime.
typedef ULONG32 mdToken;                // Generic token


// Token  definitions


typedef mdToken mdModule;               // Module token (roughly, a scope)
typedef mdToken mdTypeRef;              // TypeRef reference (this or other scope)
typedef mdToken mdTypeDef;              // TypeDef in this scope
typedef mdToken mdFieldDef;             // Field in this scope
typedef mdToken mdMethodDef;            // Method in this scope
typedef mdToken mdParamDef;             // param token
typedef mdToken mdInterfaceImpl;        // interface implementation token

typedef mdToken mdMemberRef;            // MemberRef (this or other scope)
typedef mdToken mdCustomAttribute;      // attribute token
typedef mdToken mdPermission;           // DeclSecurity

typedef mdToken mdSignature;            // Signature object
typedef mdToken mdEvent;                // event token
typedef mdToken mdProperty;             // property token

typedef mdToken mdModuleRef;            // Module reference (for the imported modules)

// Assembly tokens.
typedef mdToken mdAssembly;             // Assembly token.
typedef mdToken mdAssemblyRef;          // AssemblyRef token.
typedef mdToken mdFile;                 // File token.
typedef mdToken mdExportedType;         // ExportedType token.
typedef mdToken mdManifestResource;     // ManifestResource token.

typedef mdToken mdTypeSpec;             // TypeSpec object

typedef mdToken mdGenericParam;         // formal parameter to generic type or method
typedef mdToken mdMethodSpec;           // instantiation of a generic method
typedef mdToken mdGenericParamConstraint; // constraint on a formal generic parameter

// Application string.
typedef mdToken mdString;               // User literal string token.

typedef mdToken mdCPToken;              // constantpool token

#ifndef MACROS_NOT_SUPPORTED
typedef ULONG RID;
#else
typedef unsigned RID;
#endif // MACROS_NOT_SUPPORTED

typedef enum ReplacesGeneralNumericDefines
{
// Directory entry macro for CLR data.
#ifndef IMAGE_DIRECTORY_ENTRY_COMHEADER
    IMAGE_DIRECTORY_ENTRY_COMHEADER     =14,
#endif // IMAGE_DIRECTORY_ENTRY_COMHEADER

    _NEW_FLAGS_IMPLEMENTED              =1,
    __NEW_FLAGS_IMPLEMENTED             =1,
} ReplacesGeneralNumericDefines;


#ifndef __IMAGE_COR20_HEADER_DEFINED__
#define __IMAGE_COR20_HEADER_DEFINED__

typedef enum ReplacesCorHdrNumericDefines
{
// COM+ Header entry point flags.
    COMIMAGE_FLAGS_ILONLY               =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED     =0x00000008,
// DDBLD - Added Next Line - Still verifying general usage
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT    =0x00000010,
// DDBLD - End of Add
    COMIMAGE_FLAGS_TRACKDEBUGDATA       =0x00010000,

// Version flags for image.
    COR_VERSION_MAJOR_V2                =2,
    COR_VERSION_MAJOR                   =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   =5,
    COR_DELETED_NAME_LENGTH             =8,
    COR_VTABLEGAP_NAME_LENGTH           =8,

// Maximum size of a NativeType descriptor.
    NATIVE_TYPE_MAX_CB                  =1,   
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,

// #defines for the MIH FLAGS
    IMAGE_COR_MIH_METHODRVA             =0x01,
    IMAGE_COR_MIH_EHRVA                 =0x02,    
    IMAGE_COR_MIH_BASICBLOCK            =0x08,

// V-table constants
    COR_VTABLE_32BIT                    =0x01,          // V-table slots are 32-bits in size.   
    COR_VTABLE_64BIT                    =0x02,          // V-table slots are 64-bits in size.   
    COR_VTABLE_FROM_UNMANAGED           =0x04,          // If set, transition from unmanaged.
    COR_VTABLE_CALL_MOST_DERIVED        =0x10,          // Call most derived method described by

// EATJ constants
    IMAGE_COR_EATJ_THUNK_SIZE           =32,            // Size of a jump thunk reserved range.

// Max name lengths    
    //@todo: Change to unlimited name lengths.
    MAX_CLASS_NAME                      =1024,
    MAX_PACKAGE_NAME                    =1024,
} ReplacesCorHdrNumericDefines;

// COM+ 2.0 header structure.
typedef struct IMAGE_COR20_HEADER
{
    // Header versioning
    DWORD                   cb;              
    WORD                    MajorRuntimeVersion;
    WORD                    MinorRuntimeVersion;
    
    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;        
    DWORD                   Flags;           
// DDBLD - Added next section to replace following lin
// DDBLD - Still verifying, since not in NT SDK
//    DWORD                   EntryPointToken;
  
    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is not set, EntryPointToken represents a managed entrypoint.
    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is set, EntryPointRVA represents an RVA to a native entrypoint.
    union {
        DWORD               EntryPointToken;
        DWORD               EntryPointRVA;
    };
// DDBLD - End of Added Area
    
    // Binding information
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    // Regular fixup and binding information
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;

    // Precompiled image info (internal use only - set to zero)
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;
    
} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;

#else // !__IMAGE_COR20_HEADER_DEFINED__

// <TODO>@TODO: This hack is required because we pull in the COM+ 2.0 PE header
// definition from winnt.h, and the constant below hasn't propogated yet.</TODO>
#define COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN 0x08

#endif // __IMAGE_COR20_HEADER_DEFINED__

// The most recent version.

#define COR_CTOR_METHOD_NAME        ".ctor"
#define COR_CTOR_METHOD_NAME_W      L".ctor"
#define COR_CCTOR_METHOD_NAME       ".cctor"
#define COR_CCTOR_METHOD_NAME_W     L".cctor"

#define COR_ENUM_FIELD_NAME         "value__"
#define COR_ENUM_FIELD_NAME_W       L"value__"

// The predefined name for deleting a typeDef,MethodDef, FieldDef, Property and Event
#define COR_DELETED_NAME_A          "_Deleted"
#define COR_DELETED_NAME_W          L"_Deleted"
#define COR_VTABLEGAP_NAME_A        "_VtblGap"
#define COR_VTABLEGAP_NAME_W        L"_VtblGap"

// We intentionally use strncmp so that we will ignore any suffix
#define IsDeletedName(strName)      (strncmp(strName, COR_DELETED_NAME_A, COR_DELETED_NAME_LENGTH) == 0)
#define IsVtblGapName(strName)      (strncmp(strName, COR_VTABLEGAP_NAME_A, COR_VTABLEGAP_NAME_LENGTH) == 0)

// TypeDef/ExportedType attr bits, used by DefineTypeDef.
typedef enum CorTypeAttr
{
    // Use this mask to retrieve the type visibility information.
    tdVisibilityMask        =   0x00000007,
    tdNotPublic             =   0x00000000,     // Class is not public scope.
    tdPublic                =   0x00000001,     // Class is public scope.
    tdNestedPublic          =   0x00000002,     // Class is nested with public visibility.
    tdNestedPrivate         =   0x00000003,     // Class is nested with private visibility.
    tdNestedFamily          =   0x00000004,     // Class is nested with family visibility.
    tdNestedAssembly        =   0x00000005,     // Class is nested with assembly visibility.
    tdNestedFamANDAssem     =   0x00000006,     // Class is nested with family and assembly visibility.
    tdNestedFamORAssem      =   0x00000007,     // Class is nested with family or assembly visibility.

    // Use this mask to retrieve class layout information
    tdLayoutMask            =   0x00000018,
    tdAutoLayout            =   0x00000000,     // Class fields are auto-laid out
    tdSequentialLayout      =   0x00000008,     // Class fields are laid out sequentially
    tdExplicitLayout        =   0x00000010,     // Layout is supplied explicitly
    // end layout mask

    // Use this mask to retrieve class semantics information.
    tdClassSemanticsMask    =   0x00000060,
    tdClass                 =   0x00000000,     // Type is a class.
    tdInterface             =   0x00000020,     // Type is an interface.
    // end semantics mask

    // Special semantics in addition to class semantics.
    tdAbstract              =   0x00000080,     // Class is abstract
    tdSealed                =   0x00000100,     // Class is concrete and may not be extended
    tdSpecialName           =   0x00000400,     // Class name is special.  Name describes how.

    // Implementation attributes.
    tdImport                =   0x00001000,     // Class / interface is imported
    tdSerializable          =   0x00002000,     // The class is Serializable.

    // Use tdStringFormatMask to retrieve string information for native interop
    tdStringFormatMask      =   0x00030000,
    tdAnsiClass             =   0x00000000,     // LPTSTR is interpreted as ANSI in this class
    tdUnicodeClass          =   0x00010000,     // LPTSTR is interpreted as UNICODE
    tdAutoClass             =   0x00020000,     // LPTSTR is interpreted automatically
    tdCustomFormatClass     =   0x00030000,     // A non-standard encoding specified by CustomFormatMask
    tdCustomFormatMask      =   0x00C00000,     // Use this mask to retrieve non-standard encoding information for native interop. The meaning of the values of these 2 bits is unspecified.

    // end string format mask

    tdBeforeFieldInit       =   0x00100000,     // Initialize the class any time before first static field access.
    tdForwarder             =   0x00200000,     // This ExportedType is a type forwarder.

    // Flags reserved for runtime use.
    tdReservedMask          =   0x00040800,
    tdRTSpecialName         =   0x00000800,     // Runtime should check name encoding.
    tdHasSecurity           =   0x00040000,     // Class has security associate with it.
} CorTypeAttr;


// Macros for accessing the members of the CorTypeAttr.
#define IsTdNotPublic(x)                    (((x) & tdVisibilityMask) == tdNotPublic)
#define IsTdPublic(x)                       (((x) & tdVisibilityMask) == tdPublic)
#define IsTdNestedPublic(x)                 (((x) & tdVisibilityMask) == tdNestedPublic)
#define IsTdNestedPrivate(x)                (((x) & tdVisibilityMask) == tdNestedPrivate)
#define IsTdNestedFamily(x)                 (((x) & tdVisibilityMask) == tdNestedFamily)
#define IsTdNestedAssembly(x)               (((x) & tdVisibilityMask) == tdNestedAssembly)
#define IsTdNestedFamANDAssem(x)            (((x) & tdVisibilityMask) == tdNestedFamANDAssem)
#define IsTdNestedFamORAssem(x)             (((x) & tdVisibilityMask) == tdNestedFamORAssem)
#define IsTdNested(x)                       (((x) & tdVisibilityMask) >= tdNestedPublic)

#define IsTdAutoLayout(x)                   (((x) & tdLayoutMask) == tdAutoLayout)
#define IsTdSequentialLayout(x)             (((x) & tdLayoutMask) == tdSequentialLayout)
#define IsTdExplicitLayout(x)               (((x) & tdLayoutMask) == tdExplicitLayout)

#define IsTdClass(x)                        (((x) & tdClassSemanticsMask) == tdClass)
#define IsTdInterface(x)                    (((x) & tdClassSemanticsMask) == tdInterface)

#define IsTdAbstract(x)                     ((x) & tdAbstract)
#define IsTdSealed(x)                       ((x) & tdSealed)
#define IsTdSpecialName(x)                  ((x) & tdSpecialName)

#define IsTdImport(x)                       ((x) & tdImport)
#define IsTdSerializable(x)                 ((x) & tdSerializable)

#define IsTdAnsiClass(x)                    (((x) & tdStringFormatMask) == tdAnsiClass)
#define IsTdUnicodeClass(x)                 (((x) & tdStringFormatMask) == tdUnicodeClass)
#define IsTdAutoClass(x)                    (((x) & tdStringFormatMask) == tdAutoClass)
#define IsTdCustomFormatClass(x)            (((x) & tdStringFormatMask) == tdCustomFormatClass)
#define IsTdBeforeFieldInit(x)              ((x) & tdBeforeFieldInit)
#define IsTdForwarder(x)                    ((x) & tdForwarder)

#define IsTdRTSpecialName(x)                ((x) & tdRTSpecialName)
#define IsTdHasSecurity(x)                  ((x) & tdHasSecurity)

// MethodDef attr bits, Used by DefineMethod.
typedef enum CorMethodAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    mdMemberAccessMask          =   0x0007,
    mdPrivateScope              =   0x0000,     // Member not referenceable.
    mdPrivate                   =   0x0001,     // Accessible only by the parent type.
    mdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    mdAssem                     =   0x0003,     // Accessibly by anyone in the Assembly.
    mdFamily                    =   0x0004,     // Accessible only by type and sub-types.
    mdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    mdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.
    // end member access mask

    // method contract attributes.
    mdStatic                    =   0x0010,     // Defined on type, else per instance.
    mdFinal                     =   0x0020,     // Method may not be overridden.
    mdVirtual                   =   0x0040,     // Method virtual.
    mdHideBySig                 =   0x0080,     // Method hides by name+sig, else just by name.

    // vtable layout mask - Use this mask to retrieve vtable attributes.
    mdVtableLayoutMask          =   0x0100,
    mdReuseSlot                 =   0x0000,     // The default.
    mdNewSlot                   =   0x0100,     // Method always gets a new slot in the vtable.
    // end vtable layout mask

    // method implementation attributes.
    mdCheckAccessOnOverride     =   0x0200,     // Overridability is the same as the visibility.
    mdAbstract                  =   0x0400,     // Method does not provide an implementation.
    mdSpecialName               =   0x0800,     // Method is special.  Name describes how.

    // interop attributes
    mdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.
    mdUnmanagedExport           =   0x0008,     // Managed method exported via thunk to unmanaged code.

    // Reserved flags for runtime use only.
    mdReservedMask              =   0xd000,
    mdRTSpecialName             =   0x1000,     // Runtime should check name encoding.
    mdHasSecurity               =   0x4000,     // Method has security associate with it.
    mdRequireSecObject          =   0x8000,     // Method calls another method containing security code.

} CorMethodAttr;

// Macros for accessing the members of CorMethodAttr.
#define IsMdPrivateScope(x)                 (((x) & mdMemberAccessMask) == mdPrivateScope)
#define IsMdPrivate(x)                      (((x) & mdMemberAccessMask) == mdPrivate)
#define IsMdFamANDAssem(x)                  (((x) & mdMemberAccessMask) == mdFamANDAssem)
#define IsMdAssem(x)                        (((x) & mdMemberAccessMask) == mdAssem)
#define IsMdFamily(x)                       (((x) & mdMemberAccessMask) == mdFamily)
#define IsMdFamORAssem(x)                   (((x) & mdMemberAccessMask) == mdFamORAssem)
#define IsMdPublic(x)                       (((x) & mdMemberAccessMask) == mdPublic)

#define IsMdStatic(x)                       ((x) & mdStatic)
#define IsMdFinal(x)                        ((x) & mdFinal)
#define IsMdVirtual(x)                      ((x) & mdVirtual)
#define IsMdHideBySig(x)                    ((x) & mdHideBySig)

#define IsMdReuseSlot(x)                    (((x) & mdVtableLayoutMask) == mdReuseSlot)
#define IsMdNewSlot(x)                      (((x) & mdVtableLayoutMask) == mdNewSlot)

#define IsMdCheckAccessOnOverride(x)        ((x) & mdCheckAccessOnOverride)
#define IsMdAbstract(x)                     ((x) & mdAbstract)
#define IsMdSpecialName(x)                  ((x) & mdSpecialName)

#define IsMdPinvokeImpl(x)                  ((x) & mdPinvokeImpl)
#define IsMdUnmanagedExport(x)              ((x) & mdUnmanagedExport)

#define IsMdRTSpecialName(x)                ((x) & mdRTSpecialName)
#define IsMdInstanceInitializer(x, str)     (((x) & mdRTSpecialName) && !strcmp((str), COR_CTOR_METHOD_NAME))
#define IsMdInstanceInitializerW(x, str)    (((x) & mdRTSpecialName) && !wcscmp((str), COR_CTOR_METHOD_NAME_W))
#define IsMdClassConstructor(x, str)        (((x) & mdRTSpecialName) && !strcmp((str), COR_CCTOR_METHOD_NAME))
#define IsMdClassConstructorW(x, str)       (((x) & mdRTSpecialName) && !wcscmp((str), COR_CCTOR_METHOD_NAME_W))
#define IsMdHasSecurity(x)                  ((x) & mdHasSecurity)
#define IsMdRequireSecObject(x)             ((x) & mdRequireSecObject)

// FieldDef attr bits, used by DefineField.
typedef enum CorFieldAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    fdFieldAccessMask           =   0x0007,
    fdPrivateScope              =   0x0000,     // Member not referenceable.
    fdPrivate                   =   0x0001,     // Accessible only by the parent type.
    fdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    fdAssembly                  =   0x0003,     // Accessibly by anyone in the Assembly.
    fdFamily                    =   0x0004,     // Accessible only by type and sub-types.
    fdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    fdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.
    // end member access mask

    // field contract attributes.
    fdStatic                    =   0x0010,     // Defined on type, else per instance.
    fdInitOnly                  =   0x0020,     // Field may only be initialized, not written to after init.
    fdLiteral                   =   0x0040,     // Value is compile time constant.
    fdNotSerialized             =   0x0080,     // Field does not have to be serialized when type is remoted.

    fdSpecialName               =   0x0200,     // field is special.  Name describes how.

    // interop attributes
    fdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.

    // Reserved flags for runtime use only.
    fdReservedMask              =   0x9500,
    fdRTSpecialName             =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    fdHasFieldMarshal           =   0x1000,     // Field has marshalling information.
    fdHasDefault                =   0x8000,     // Field has default.
    fdHasFieldRVA               =   0x0100,     // Field has RVA.
} CorFieldAttr;

// Macros for accessing the members of CorFieldAttr.
#define IsFdPrivateScope(x)                 (((x) & fdFieldAccessMask) == fdPrivateScope)
#define IsFdPrivate(x)                      (((x) & fdFieldAccessMask) == fdPrivate)
#define IsFdFamANDAssem(x)                  (((x) & fdFieldAccessMask) == fdFamANDAssem)
#define IsFdAssembly(x)                     (((x) & fdFieldAccessMask) == fdAssembly)
#define IsFdFamily(x)                       (((x) & fdFieldAccessMask) == fdFamily)
#define IsFdFamORAssem(x)                   (((x) & fdFieldAccessMask) == fdFamORAssem)
#define IsFdPublic(x)                       (((x) & fdFieldAccessMask) == fdPublic)

#define IsFdStatic(x)                       ((x) & fdStatic)
#define IsFdInitOnly(x)                     ((x) & fdInitOnly)
#define IsFdLiteral(x)                      ((x) & fdLiteral)
#define IsFdNotSerialized(x)                ((x) & fdNotSerialized)

#define IsFdPinvokeImpl(x)                  ((x) & fdPinvokeImpl)
#define IsFdSpecialName(x)                  ((x) & fdSpecialName)
#define IsFdHasFieldRVA(x)                  ((x) & fdHasFieldRVA)

#define IsFdRTSpecialName(x)                ((x) & fdRTSpecialName)
#define IsFdHasFieldMarshal(x)              ((x) & fdHasFieldMarshal)
#define IsFdHasDefault(x)                   ((x) & fdHasDefault)

// Param attr bits, used by DefineParam.
typedef enum CorParamAttr
{
    pdIn                        =   0x0001,     // Param is [In]
    pdOut                       =   0x0002,     // Param is [out]
    pdOptional                  =   0x0010,     // Param is optional

    // Reserved flags for Runtime use only.
    pdReservedMask              =   0xf000,
    pdHasDefault                =   0x1000,     // Param has default value.
    pdHasFieldMarshal           =   0x2000,     // Param has FieldMarshal.

    pdUnused                    =   0xcfe0,
} CorParamAttr;

// Macros for accessing the members of CorParamAttr.
#define IsPdIn(x)                           ((x) & pdIn)
#define IsPdOut(x)                          ((x) & pdOut)
#define IsPdOptional(x)                     ((x) & pdOptional)

#define IsPdHasDefault(x)                   ((x) & pdHasDefault)
#define IsPdHasFieldMarshal(x)              ((x) & pdHasFieldMarshal)


// Property attr bits, used by DefineProperty.
typedef enum CorPropertyAttr
{
    prSpecialName           =   0x0200,     // property is special.  Name describes how.

    // Reserved flags for Runtime use only.
    prReservedMask          =   0xf400,
    prRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    prHasDefault            =   0x1000,     // Property has default

    prUnused                =   0xe9ff,
} CorPropertyAttr;

// Macros for accessing the members of CorPropertyAttr.
#define IsPrSpecialName(x)                  ((x) & prSpecialName)

#define IsPrRTSpecialName(x)                ((x) & prRTSpecialName)
#define IsPrHasDefault(x)                   ((x) & prHasDefault)

// Event attr bits, used by DefineEvent.
typedef enum CorEventAttr
{
    evSpecialName           =   0x0200,     // event is special.  Name describes how.

    // Reserved flags for Runtime use only.
    evReservedMask          =   0x0400,
    evRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
} CorEventAttr;

// Macros for accessing the members of CorEventAttr.
#define IsEvSpecialName(x)                  ((x) & evSpecialName)

#define IsEvRTSpecialName(x)                ((x) & evRTSpecialName)


// MethodSemantic attr bits, used by DefineProperty, DefineEvent.
typedef enum CorMethodSemanticsAttr
{
    msSetter    =   0x0001,     // Setter for property
    msGetter    =   0x0002,     // Getter for property
    msOther     =   0x0004,     // other method for property or event
    msAddOn     =   0x0008,     // AddOn method for event
    msRemoveOn  =   0x0010,     // RemoveOn method for event
    msFire      =   0x0020,     // Fire method for event
} CorMethodSemanticsAttr;

// Macros for accessing the members of CorMethodSemanticsAttr.
#define IsMsSetter(x)                       ((x) & msSetter)
#define IsMsGetter(x)                       ((x) & msGetter)
#define IsMsOther(x)                        ((x) & msOther)
#define IsMsAddOn(x)                        ((x) & msAddOn)
#define IsMsRemoveOn(x)                     ((x) & msRemoveOn)
#define IsMsFire(x)                         ((x) & msFire)


// DeclSecurity attr bits, used by DefinePermissionSet.
typedef enum CorDeclSecurity
{
    dclActionMask               =   0x001f,     // Mask allows growth of enum.
    dclActionNil                =   0x0000,     //
    dclRequest                  =   0x0001,     //
    dclDemand                   =   0x0002,     //
    dclAssert                   =   0x0003,     //
    dclDeny                     =   0x0004,     //
    dclPermitOnly               =   0x0005,     //
    dclLinktimeCheck            =   0x0006,     //
    dclInheritanceCheck         =   0x0007,     //
    dclRequestMinimum           =   0x0008,     //
    dclRequestOptional          =   0x0009,     //
    dclRequestRefuse            =   0x000a,     //
    dclPrejitGrant              =   0x000b,     // Persisted grant set at prejit time
    dclPrejitDenied             =   0x000c,     // Persisted denied set at prejit time
    dclNonCasDemand             =   0x000d,     //
    dclNonCasLinkDemand         =   0x000e,     //
    dclNonCasInheritance        =   0x000f,     //
    dclMaximumValue             =   0x000f,     // Maximum legal value
} CorDeclSecurity;

// Macros for accessing the members of CorDeclSecurity.
#define IsDclActionNil(x)                   (((x) & dclActionMask) == dclActionNil)
// Is this a demand that can trigger a stackwalk?
#define IsDclActionAnyStackModifier(x)              ((((x) & dclActionMask) == dclAssert) || \
                                                    (((x) & dclActionMask) == dclDeny)  || \
                                                    (((x) & dclActionMask) == dclPermitOnly))

// MethodImpl attr bits, used by DefineMethodImpl.
typedef enum CorMethodImpl
{
    // code impl mask
    miCodeTypeMask      =   0x0003,   // Flags about code type.
    miIL                =   0x0000,   // Method impl is IL.
    miNative            =   0x0001,   // Method impl is native.
    miOPTIL             =   0x0002,   // Method impl is OPTIL
    miRuntime           =   0x0003,   // Method impl is provided by the runtime.
    // end code impl mask

    // managed mask
    miManagedMask       =   0x0004,   // Flags specifying whether the code is managed or unmanaged.
    miUnmanaged         =   0x0004,   // Method impl is unmanaged, otherwise managed.
    miManaged           =   0x0000,   // Method impl is managed.
    // end managed mask

    // implementation info and interop
    miForwardRef        =   0x0010,   // Indicates method is defined; used primarily in merge scenarios.
    miPreserveSig       =   0x0080,   // Indicates method sig is not to be mangled to do HRESULT conversion.

    miInternalCall      =   0x1000,   // Reserved for internal use.

    miSynchronized      =   0x0020,   // Method is single threaded through the body.
    miNoInlining        =   0x0008,   // Method may not be inlined.
    miMaxMethodImplVal  =   0xffff,   // Range check value
} CorMethodImpl;

// Macros for accesing the members of CorMethodImpl.
#define IsMiIL(x)                           (((x) & miCodeTypeMask) == miIL)
#define IsMiNative(x)                       (((x) & miCodeTypeMask) == miNative)
#define IsMiOPTIL(x)                        (((x) & miCodeTypeMask) == miOPTIL)
#define IsMiRuntime(x)                      (((x) & miCodeTypeMask) == miRuntime)

#define IsMiUnmanaged(x)                    (((x) & miManagedMask) == miUnmanaged)
#define IsMiManaged(x)                      (((x) & miManagedMask) == miManaged)

#define IsMiForwardRef(x)                   ((x) & miForwardRef)
#define IsMiPreserveSig(x)                  ((x) & miPreserveSig)

#define IsMiInternalCall(x)                 ((x) & miInternalCall)

#define IsMiSynchronized(x)                 ((x) & miSynchronized)
#define IsMiNoInlining(x)                   ((x) & miNoInlining)


// PinvokeMap attr bits, used by DefinePinvokeMap.
typedef enum  CorPinvokeMap
{
    pmNoMangle          = 0x0001,   // Pinvoke is to use the member name as specified.

    // Use this mask to retrieve the CharSet information.
    pmCharSetMask       = 0x0006,
    pmCharSetNotSpec    = 0x0000,
    pmCharSetAnsi       = 0x0002,
    pmCharSetUnicode    = 0x0004,
    pmCharSetAuto       = 0x0006,


    pmBestFitUseAssem   = 0x0000,
    pmBestFitEnabled    = 0x0010,
    pmBestFitDisabled   = 0x0020,
    pmBestFitMask       = 0x0030,

    pmThrowOnUnmappableCharUseAssem   = 0x0000,
    pmThrowOnUnmappableCharEnabled    = 0x1000,
    pmThrowOnUnmappableCharDisabled   = 0x2000,
    pmThrowOnUnmappableCharMask       = 0x3000,

    pmSupportsLastError = 0x0040,   // Information about target function. Not relevant for fields.

    // None of the calling convention flags is relevant for fields.
    pmCallConvMask      = 0x0700,
    pmCallConvWinapi    = 0x0100,   // Pinvoke will use native callconv appropriate to target windows platform.
    pmCallConvCdecl     = 0x0200,
    pmCallConvStdcall   = 0x0300,
    pmCallConvThiscall  = 0x0400,   // In M9, pinvoke will raise exception.
    pmCallConvFastcall  = 0x0500,

    pmMaxValue          = 0xFFFF,
} CorPinvokeMap;

// Macros for accessing the members of CorPinvokeMap
#define IsPmNoMangle(x)                     ((x) & pmNoMangle)

#define IsPmCharSetNotSpec(x)               (((x) & pmCharSetMask) == pmCharSetNotSpec)
#define IsPmCharSetAnsi(x)                  (((x) & pmCharSetMask) == pmCharSetAnsi)
#define IsPmCharSetUnicode(x)               (((x) & pmCharSetMask) == pmCharSetUnicode)
#define IsPmCharSetAuto(x)                  (((x) & pmCharSetMask) == pmCharSetAuto)

#define IsPmSupportsLastError(x)            ((x) & pmSupportsLastError)

#define IsPmCallConvWinapi(x)               (((x) & pmCallConvMask) == pmCallConvWinapi)
#define IsPmCallConvCdecl(x)                (((x) & pmCallConvMask) == pmCallConvCdecl)
#define IsPmCallConvStdcall(x)              (((x) & pmCallConvMask) == pmCallConvStdcall)
#define IsPmCallConvThiscall(x)             (((x) & pmCallConvMask) == pmCallConvThiscall)
#define IsPmCallConvFastcall(x)             (((x) & pmCallConvMask) == pmCallConvFastcall)

#define IsPmBestFitEnabled(x)                 (((x) & pmBestFitMask) == pmBestFitEnabled)
#define IsPmBestFitDisabled(x)                (((x) & pmBestFitMask) == pmBestFitDisabled)
#define IsPmBestFitUseAssem(x)                (((x) & pmBestFitMask) == pmBestFitUseAssem)

#define IsPmThrowOnUnmappableCharEnabled(x)   (((x) & pmThrowOnUnmappableCharMask) == pmThrowOnUnmappableCharEnabled)
#define IsPmThrowOnUnmappableCharDisabled(x)  (((x) & pmThrowOnUnmappableCharMask) == pmThrowOnUnmappableCharDisabled)
#define IsPmThrowOnUnmappableCharUseAssem(x)  (((x) & pmThrowOnUnmappableCharMask) == pmThrowOnUnmappableCharUseAssem)

// Assembly attr bits, used by DefineAssembly.
typedef enum CorAssemblyFlags
{
    afPublicKey             =   0x0001,     // The assembly ref holds the full (unhashed) public key.
    
    afPA_None               =   0x0000,     // Processor Architecture unspecified
    afPA_MSIL               =   0x0010,     // Processor Architecture: neutral (PE32)
    afPA_x86                =   0x0020,     // Processor Architecture: x86 (PE32)
    afPA_IA64               =   0x0030,     // Processor Architecture: Itanium (PE32+)
    afPA_AMD64              =   0x0040,     // Processor Architecture: AMD X64 (PE32+)
    afPA_Specified          =   0x0080,     // Propagate PA flags to AssemblyRef record
    afPA_Mask               =   0x0070,     // Bits describing the processor architecture
    afPA_FullMask           =   0x00F0,     // Bits describing the PA incl. Specified
    afPA_Shift              =   0x0004,     // NOT A FLAG, shift count in PA flags <--> index conversion

    afEnableJITcompileTracking  =   0x8000, // From "DebuggableAttribute".
    afDisableJITcompileOptimizer=   0x4000, // From "DebuggableAttribute".

    afRetargetable          =   0x0100,     // The assembly can be retargeted (at runtime) to an
                                            //  assembly from a different publisher.
} CorAssemblyFlags;

// Macros for accessing the members of CorAssemblyFlags.
#define IsAfRetargetable(x)                 ((x) & afRetargetable)

// Macros for accessing the Processor Architecture flags of CorAssemblyFlags.
#define IsAfPA_MSIL(x) (((x) & afPA_Mask) == afPA_MSIL)
#define IsAfPA_x86(x) (((x) & afPA_Mask) == afPA_x86)
#define IsAfPA_IA64(x) (((x) & afPA_Mask) == afPA_IA64)
#define IsAfPA_AMD64(x) (((x) & afPA_Mask) == afPA_AMD64)
#define IsAfPA_Specified(x) ((x) & afPA_Specified)
#define PAIndex(x) (((x) & afPA_Mask) >> afPA_Shift)
#define PAFlag(x)  (((x) << afPA_Shift) & afPA_Mask)
#define PrepareForSaving(x) ((x) & (((x) & afPA_Specified) ? ~afPA_Specified : ~afPA_FullMask))

#define IsAfEnableJITcompileTracking(x)     ((x) & afEnableJITcompileTracking)
#define IsAfDisableJITcompileOptimizer(x)   ((x) & afDisableJITcompileOptimizer)

// Macros for accessing the public key flags of CorAssemblyFlags.
#define IsAfPublicKey(x)                    ((x) & afPublicKey)
#define IsAfPublicKeyToken(x)               (((x) & afPublicKey) == 0)


// ManifestResource attr bits, used by DefineManifestResource.
typedef enum CorManifestResourceFlags
{
    mrVisibilityMask        =   0x0007,
    mrPublic                =   0x0001,     // The Resource is exported from the Assembly.
    mrPrivate               =   0x0002,     // The Resource is private to the Assembly.
} CorManifestResourceFlags;

// Macros for accessing the members of CorManifestResourceFlags.
#define IsMrPublic(x)                       (((x) & mrVisibilityMask) == mrPublic)
#define IsMrPrivate(x)                      (((x) & mrVisibilityMask) == mrPrivate)


// File attr bits, used by DefineFile.
typedef enum CorFileFlags
{
    ffContainsMetaData      =   0x0000,     // This is not a resource file
    ffContainsNoMetaData    =   0x0001,     // This is a resource file or other non-metadata-containing file
} CorFileFlags;

// Macros for accessing the members of CorFileFlags.
#define IsFfContainsMetaData(x)             (!((x) & ffContainsNoMetaData))
#define IsFfContainsNoMetaData(x)           ((x) & ffContainsNoMetaData)

// PE file kind bits, returned by IMetaDataImport2::GetPEKind()
typedef enum CorPEKind
{
    peNot       = 0x00000000,   // not a PE file
    peILonly    = 0x00000001,   // flag IL_ONLY is set in COR header
    pe32BitRequired=0x00000002,  // flag 32BIT_REQUIRED is set in COR header
    pe32Plus    = 0x00000004,   // PE32+ file (64 bit)
    pe32Unmanaged=0x00000008    // PE32 without COR header
} CorPEKind;


// GenericParam bits, used by DefineGenericParam.
typedef enum CorGenericParamAttr
{
    // Variance of type parameters, only applicable to generic parameters 
    // for generic interfaces and delegates
    gpVarianceMask          =   0x0003,
    gpNonVariant            =   0x0000, 
    gpCovariant             =   0x0001,
    gpContravariant         =   0x0002,

    // Special constraints, applicable to any type parameters
    gpSpecialConstraintMask =  0x001C,
    gpNoSpecialConstraint   =   0x0000,      
    gpReferenceTypeConstraint = 0x0004,      // type argument must be a reference type
    gpNotNullableValueTypeConstraint   =   0x0008,      // type argument must be a value type but not Nullable
    gpDefaultConstructorConstraint = 0x0010, // type argument must have a public default constructor
} CorGenericParamAttr;

// structures and enums moved from COR.H
typedef unsigned __int8 COR_SIGNATURE;

typedef COR_SIGNATURE* PCOR_SIGNATURE;      // pointer to a cor sig.  Not void* so that
                                            // the bytes can be incremented easily
typedef const COR_SIGNATURE* PCCOR_SIGNATURE;


typedef const char * MDUTF8CSTR;
typedef char * MDUTF8STR;

//*****************************************************************************
//
// Element type for Cor signature
//
//*****************************************************************************

typedef enum CorElementType
{
    ELEMENT_TYPE_END            = 0x0,
    ELEMENT_TYPE_VOID           = 0x1,
    ELEMENT_TYPE_BOOLEAN        = 0x2,
    ELEMENT_TYPE_CHAR           = 0x3,
    ELEMENT_TYPE_I1             = 0x4,
    ELEMENT_TYPE_U1             = 0x5,
    ELEMENT_TYPE_I2             = 0x6,
    ELEMENT_TYPE_U2             = 0x7,
    ELEMENT_TYPE_I4             = 0x8,
    ELEMENT_TYPE_U4             = 0x9,
    ELEMENT_TYPE_I8             = 0xa,
    ELEMENT_TYPE_U8             = 0xb,
    ELEMENT_TYPE_R4             = 0xc,
    ELEMENT_TYPE_R8             = 0xd,
    ELEMENT_TYPE_STRING         = 0xe,

    // every type above PTR will be simple type
    ELEMENT_TYPE_PTR            = 0xf,      // PTR <type>
    ELEMENT_TYPE_BYREF          = 0x10,     // BYREF <type>

    // Please use ELEMENT_TYPE_VALUETYPE. ELEMENT_TYPE_VALUECLASS is deprecated.
    ELEMENT_TYPE_VALUETYPE      = 0x11,     // VALUETYPE <class Token>
    ELEMENT_TYPE_CLASS          = 0x12,     // CLASS <class Token>
    ELEMENT_TYPE_VAR            = 0x13,     // a class type variable VAR <U1>
    ELEMENT_TYPE_ARRAY          = 0x14,     // MDARRAY <type> <rank> <bcount> <bound1> ... <lbcount> <lb1> ...
    ELEMENT_TYPE_GENERICINST    = 0x15,     // GENERICINST <generic type> <argCnt> <arg1> ... <argn>
    ELEMENT_TYPE_TYPEDBYREF     = 0x16,     // TYPEDREF  (it takes no args) a typed referece to some other type

    ELEMENT_TYPE_I              = 0x18,     // native integer size
    ELEMENT_TYPE_U              = 0x19,     // native unsigned integer size
    ELEMENT_TYPE_FNPTR          = 0x1B,     // FNPTR <complete sig for the function including calling convention>
    ELEMENT_TYPE_OBJECT         = 0x1C,     // Shortcut for System.Object
    ELEMENT_TYPE_SZARRAY        = 0x1D,     // Shortcut for single dimension zero lower bound array
                                            // SZARRAY <type>
    ELEMENT_TYPE_MVAR           = 0x1e,     // a method type variable MVAR <U1>

    // This is only for binding
    ELEMENT_TYPE_CMOD_REQD      = 0x1F,     // required C modifier : E_T_CMOD_REQD <mdTypeRef/mdTypeDef>
    ELEMENT_TYPE_CMOD_OPT       = 0x20,     // optional C modifier : E_T_CMOD_OPT <mdTypeRef/mdTypeDef>

    // This is for signatures generated internally (which will not be persisted in any way).
    ELEMENT_TYPE_INTERNAL       = 0x21,     // INTERNAL <typehandle>

    // Note that this is the max of base type excluding modifiers
    ELEMENT_TYPE_MAX            = 0x22,     // first invalid element type


    ELEMENT_TYPE_MODIFIER       = 0x40,
    ELEMENT_TYPE_SENTINEL       = 0x01 | ELEMENT_TYPE_MODIFIER, // sentinel for varargs
    ELEMENT_TYPE_PINNED         = 0x05 | ELEMENT_TYPE_MODIFIER,
    ELEMENT_TYPE_R4_HFA         = 0x06 | ELEMENT_TYPE_MODIFIER, // used only internally for R4 HFA types
    ELEMENT_TYPE_R8_HFA         = 0x07 | ELEMENT_TYPE_MODIFIER, // used only internally for R8 HFA types

} CorElementType;


//*****************************************************************************
//
// Serialization types for Custom attribute support
//
//*****************************************************************************

typedef enum CorSerializationType
{
    SERIALIZATION_TYPE_UNDEFINED    = 0,
    SERIALIZATION_TYPE_BOOLEAN      = ELEMENT_TYPE_BOOLEAN,
    SERIALIZATION_TYPE_CHAR         = ELEMENT_TYPE_CHAR,
    SERIALIZATION_TYPE_I1           = ELEMENT_TYPE_I1,
    SERIALIZATION_TYPE_U1           = ELEMENT_TYPE_U1,
    SERIALIZATION_TYPE_I2           = ELEMENT_TYPE_I2,
    SERIALIZATION_TYPE_U2           = ELEMENT_TYPE_U2,
    SERIALIZATION_TYPE_I4           = ELEMENT_TYPE_I4,
    SERIALIZATION_TYPE_U4           = ELEMENT_TYPE_U4,
    SERIALIZATION_TYPE_I8           = ELEMENT_TYPE_I8,
    SERIALIZATION_TYPE_U8           = ELEMENT_TYPE_U8,
    SERIALIZATION_TYPE_R4           = ELEMENT_TYPE_R4,
    SERIALIZATION_TYPE_R8           = ELEMENT_TYPE_R8,
    SERIALIZATION_TYPE_STRING       = ELEMENT_TYPE_STRING,
    SERIALIZATION_TYPE_SZARRAY      = ELEMENT_TYPE_SZARRAY, // Shortcut for single dimension zero lower bound array
    SERIALIZATION_TYPE_TYPE         = 0x50,
    SERIALIZATION_TYPE_TAGGED_OBJECT= 0x51,
    SERIALIZATION_TYPE_FIELD        = 0x53,
    SERIALIZATION_TYPE_PROPERTY     = 0x54,
    SERIALIZATION_TYPE_ENUM         = 0x55
} CorSerializationType;

//
// Calling convention flags.
//


typedef enum CorCallingConvention
{
    IMAGE_CEE_CS_CALLCONV_DEFAULT       = 0x0,

    IMAGE_CEE_CS_CALLCONV_VARARG        = 0x5,
    IMAGE_CEE_CS_CALLCONV_FIELD         = 0x6,
    IMAGE_CEE_CS_CALLCONV_LOCAL_SIG     = 0x7,
    IMAGE_CEE_CS_CALLCONV_PROPERTY      = 0x8,
    IMAGE_CEE_CS_CALLCONV_UNMGD         = 0x9,
    IMAGE_CEE_CS_CALLCONV_GENERICINST   = 0xa,  // generic method instantiation
    IMAGE_CEE_CS_CALLCONV_NATIVEVARARG  = 0xb,  // used ONLY for 64bit vararg PInvoke calls
    IMAGE_CEE_CS_CALLCONV_MAX           = 0xc,  // first invalid calling convention


        // The high bits of the calling convention convey additional info
    IMAGE_CEE_CS_CALLCONV_MASK      = 0x0f,  // Calling convention is bottom 4 bits
    IMAGE_CEE_CS_CALLCONV_HASTHIS   = 0x20,  // Top bit indicates a 'this' parameter
    IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS = 0x40,  // This parameter is explicitly in the signature
    IMAGE_CEE_CS_CALLCONV_GENERIC   = 0x10,  // Generic method sig with explicit number of type arguments (precedes ordinary parameter count)
} CorCallingConvention;

#define IMAGE_CEE_CS_CALLCONV_INSTANTIATION IMAGE_CEE_CS_CALLCONV_GENERICINST

typedef enum CorUnmanagedCallingConvention
{
    IMAGE_CEE_UNMANAGED_CALLCONV_C         = 0x1,
    IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL   = 0x2,
    IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL  = 0x3,
    IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL  = 0x4,

    IMAGE_CEE_CS_CALLCONV_C         = IMAGE_CEE_UNMANAGED_CALLCONV_C,
    IMAGE_CEE_CS_CALLCONV_STDCALL   = IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL,
    IMAGE_CEE_CS_CALLCONV_THISCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL,
    IMAGE_CEE_CS_CALLCONV_FASTCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL,

} CorUnmanagedCallingConvention;


typedef enum CorArgType
{
    IMAGE_CEE_CS_END        = 0x0,
    IMAGE_CEE_CS_VOID       = 0x1,
    IMAGE_CEE_CS_I4         = 0x2,
    IMAGE_CEE_CS_I8         = 0x3,
    IMAGE_CEE_CS_R4         = 0x4,
    IMAGE_CEE_CS_R8         = 0x5,
    IMAGE_CEE_CS_PTR        = 0x6,
    IMAGE_CEE_CS_OBJECT     = 0x7,
    IMAGE_CEE_CS_STRUCT4    = 0x8,
    IMAGE_CEE_CS_STRUCT32   = 0x9,
    IMAGE_CEE_CS_BYVALUE    = 0xA,
} CorArgType;


//*****************************************************************************
//
// Native type for N-Direct
//
//*****************************************************************************

typedef enum CorNativeType
{
    NATIVE_TYPE_END         = 0x0,    //DEPRECATED
    NATIVE_TYPE_VOID        = 0x1,    //DEPRECATED
    NATIVE_TYPE_BOOLEAN     = 0x2,    // (4 byte boolean value: TRUE = non-zero, FALSE = 0)
    NATIVE_TYPE_I1          = 0x3,
    NATIVE_TYPE_U1          = 0x4,
    NATIVE_TYPE_I2          = 0x5,
    NATIVE_TYPE_U2          = 0x6,
    NATIVE_TYPE_I4          = 0x7,
    NATIVE_TYPE_U4          = 0x8,
    NATIVE_TYPE_I8          = 0x9,
    NATIVE_TYPE_U8          = 0xa,
    NATIVE_TYPE_R4          = 0xb,
    NATIVE_TYPE_R8          = 0xc,
    NATIVE_TYPE_SYSCHAR     = 0xd,    //DEPRECATED
    NATIVE_TYPE_VARIANT     = 0xe,    //DEPRECATED
    NATIVE_TYPE_CURRENCY    = 0xf,
    NATIVE_TYPE_PTR         = 0x10,   //DEPRECATED

    NATIVE_TYPE_DECIMAL     = 0x11,   //DEPRECATED
    NATIVE_TYPE_DATE        = 0x12,   //DEPRECATED
    NATIVE_TYPE_BSTR        = 0x13,   //COMINTEROP
    NATIVE_TYPE_LPSTR       = 0x14,
    NATIVE_TYPE_LPWSTR      = 0x15,
    NATIVE_TYPE_LPTSTR      = 0x16,
    NATIVE_TYPE_FIXEDSYSSTRING  = 0x17,
    NATIVE_TYPE_OBJECTREF   = 0x18,   //DEPRECATED
    NATIVE_TYPE_IUNKNOWN    = 0x19,   //COMINTEROP
    NATIVE_TYPE_IDISPATCH   = 0x1a,   //COMINTEROP
    NATIVE_TYPE_STRUCT      = 0x1b,
    NATIVE_TYPE_INTF        = 0x1c,   //COMINTEROP
    NATIVE_TYPE_SAFEARRAY   = 0x1d,   //COMINTEROP
    NATIVE_TYPE_FIXEDARRAY  = 0x1e,
    NATIVE_TYPE_INT         = 0x1f,
    NATIVE_TYPE_UINT        = 0x20,

    NATIVE_TYPE_NESTEDSTRUCT  = 0x21, //DEPRECATED (use NATIVE_TYPE_STRUCT)

    NATIVE_TYPE_BYVALSTR    = 0x22,   //COMINTEROP

    NATIVE_TYPE_ANSIBSTR    = 0x23,   //COMINTEROP

    NATIVE_TYPE_TBSTR       = 0x24, // select BSTR or ANSIBSTR depending on platform
                                      //COMINTEROP

    NATIVE_TYPE_VARIANTBOOL = 0x25, // (2-byte boolean value: TRUE = -1, FALSE = 0)
                                      //COMINTEROP
    NATIVE_TYPE_FUNC        = 0x26,

    NATIVE_TYPE_ASANY       = 0x28,

    NATIVE_TYPE_ARRAY       = 0x2a,
    NATIVE_TYPE_LPSTRUCT    = 0x2b,

    NATIVE_TYPE_CUSTOMMARSHALER = 0x2c,  // Custom marshaler native type. This must be followed
                                         // by a string of the following format:
                                         // "Native type name/0Custom marshaler type name/0Optional cookie/0"
                                         // Or
                                         // "{Native type GUID}/0Custom marshaler type name/0Optional cookie/0"

    NATIVE_TYPE_ERROR       = 0x2d, // This native type coupled with ELEMENT_TYPE_I4 will map to VT_HRESULT
                                    //COMINTEROP

    NATIVE_TYPE_MAX         = 0x50, // first invalid element type
} CorNativeType;


enum
{
    DESCR_GROUP_METHODDEF = 0,          // DESCR group for MethodDefs
    DESCR_GROUP_METHODIMPL,             // DESCR group for MethodImpls
};

/***********************************************************************************/
// a COR_ILMETHOD_SECT is a generic container for attributes that are private
// to a particular method.  The COR_ILMETHOD structure points to one of these
// (see GetSect()).  COR_ILMETHOD_SECT can decode the Kind of attribute (but not
// its internal data layout, and can skip past the current attibute to find the
// Next one.   The overhead for COR_ILMETHOD_SECT is a minimum of 2 bytes.

typedef enum CorILMethodSect                             // codes that identify attributes
{
    CorILMethod_Sect_Reserved    = 0,
    CorILMethod_Sect_EHTable     = 1,
    CorILMethod_Sect_OptILTable  = 2,

    CorILMethod_Sect_KindMask    = 0x3F,        // The mask for decoding the type code
    CorILMethod_Sect_FatFormat   = 0x40,        // fat format
    CorILMethod_Sect_MoreSects   = 0x80,        // there is another attribute after this one
} CorILMethodSect;

/************************************/
/* NOTE this structure must be DWORD aligned!! */

typedef struct IMAGE_COR_ILMETHOD_SECT_SMALL
{
    BYTE Kind;
    BYTE DataSize;

} IMAGE_COR_ILMETHOD_SECT_SMALL;



/************************************/
/* NOTE this structure must be DWORD aligned!! */
typedef struct IMAGE_COR_ILMETHOD_SECT_FAT
{
    unsigned Kind : 8;
    unsigned DataSize : 24;

} IMAGE_COR_ILMETHOD_SECT_FAT;



/***********************************************************************************/
/* If COR_ILMETHOD_SECT_HEADER::Kind() = CorILMethod_Sect_EHTable then the attribute
   is a list of exception handling clauses.  There are two formats, fat or small
*/
typedef enum CorExceptionFlag                       // defintitions for the Flags field below (for both big and small)
{
    COR_ILEXCEPTION_CLAUSE_NONE,                    // This is a typed handler
    COR_ILEXCEPTION_CLAUSE_OFFSETLEN = 0x0000,      // Deprecated
    COR_ILEXCEPTION_CLAUSE_DEPRECATED = 0x0000,     // Deprecated
    COR_ILEXCEPTION_CLAUSE_FILTER  = 0x0001,        // If this bit is on, then this EH entry is for a filter
    COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002,        // This clause is a finally clause
    COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004,          // Fault clause (finally that is called on exception only)
    COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008,     // duplicated clase..  this clause was duplicated down to a funclet which was pulled out of line
} CorExceptionFlag;

/***********************************/
// NOTE !!! NOTE
// This structure should line up with EE_ILEXCEPTION_CLAUSE,
// otherwise you'll have to adjust code in Excep.cpp, re: EHRangeTree
// NOTE !!! NOTE

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT
{
    CorExceptionFlag    Flags;
    DWORD               TryOffset;
    DWORD               TryLength;      // relative to start of try block
    DWORD               HandlerOffset;
    DWORD               HandlerLength;  // relative to start of handler
    union {
        DWORD           ClassToken;     // use for type-based exception handlers
        DWORD           FilterOffset;   // use for filter-based exception handlers (COR_ILEXCEPTION_FILTER is set)
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT;

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_FAT
{
    IMAGE_COR_ILMETHOD_SECT_FAT   SectFat;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size
} IMAGE_COR_ILMETHOD_SECT_EH_FAT;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL
{
#ifdef _WIN64
    unsigned            Flags         : 16;
#else // !_WIN64
    CorExceptionFlag    Flags         : 16;
#endif
    unsigned            TryOffset     : 16;
    unsigned            TryLength     : 8;  // relative to start of try block
    unsigned            HandlerOffset : 16;
    unsigned            HandlerLength : 8;  // relative to start of handler
    union {
        DWORD       ClassToken;
        DWORD       FilterOffset;
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_SMALL
{
    IMAGE_COR_ILMETHOD_SECT_SMALL SectSmall;
    WORD Reserved;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size
} IMAGE_COR_ILMETHOD_SECT_EH_SMALL;



typedef union IMAGE_COR_ILMETHOD_SECT_EH
{
    IMAGE_COR_ILMETHOD_SECT_EH_SMALL Small;
    IMAGE_COR_ILMETHOD_SECT_EH_FAT Fat;
} IMAGE_COR_ILMETHOD_SECT_EH;


/***********************************************************************************/
typedef enum CorILMethodFlags
{
    CorILMethod_InitLocals      = 0x0010,           // call default constructor on all local vars
    CorILMethod_MoreSects       = 0x0008,           // there is another attribute after this one

    CorILMethod_CompressedIL    = 0x0040,           // FIX Remove this and do it on a per Module basis

        // Indicates the format for the COR_ILMETHOD header
    CorILMethod_FormatShift     = 3,
    CorILMethod_FormatMask      = ((1 << CorILMethod_FormatShift) - 1),
    CorILMethod_TinyFormat      = 0x0002,         // use this code if the code size is even
    CorILMethod_SmallFormat     = 0x0000,
    CorILMethod_FatFormat       = 0x0003,
    CorILMethod_TinyFormat1     = 0x0006,         // use this code if the code size is odd
} CorILMethodFlags;

/***************************************************************************/
/* Used when the method is tiny (< 64 bytes), and there are no local vars */
typedef struct IMAGE_COR_ILMETHOD_TINY
{
    BYTE Flags_CodeSize;
} IMAGE_COR_ILMETHOD_TINY;

/************************************/
// This strucuture is the 'fat' layout, where no compression is attempted.
// Note that this structure can be added on at the end, thus making it extensible
typedef struct IMAGE_COR_ILMETHOD_FAT
{
    unsigned Flags    : 12;     // Flags
    unsigned Size     :  4;     // size in DWords of this structure (currently 3)
    unsigned MaxStack : 16;     // maximum number of items (I4, I, I8, obj ...), on the operand stack
    DWORD   CodeSize;           // size of the code
    mdSignature   LocalVarSigTok;     // token that indicates the signature of the local vars (0 means none)

} IMAGE_COR_ILMETHOD_FAT;

typedef union IMAGE_COR_ILMETHOD
{
    IMAGE_COR_ILMETHOD_TINY       Tiny;
    IMAGE_COR_ILMETHOD_FAT        Fat;
} IMAGE_COR_ILMETHOD;

//
// Native method descriptor.
//

typedef struct IMAGE_COR_NATIVE_DESCRIPTOR
{
    DWORD       GCInfo;
    DWORD       EHInfo;
} IMAGE_COR_NATIVE_DESCRIPTOR;


typedef struct IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY
{
    ULONG       BeginAddress;           // RVA of start of function
    ULONG       EndAddress;             // RVA of end of function
    ULONG       MIH;                    // Associated MIH
} IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY;

typedef struct IMAGE_COR_MIH_ENTRY
{
    ULONG   EHRVA;
    ULONG   MethodRVA;
    mdToken Token;
    BYTE    Flags;
    BYTE    CodeManager;
    BYTE    MIHData[0];
} IMAGE_COR_MIH_ENTRY;

//*****************************************************************************
// Non VOS v-table entries.  Define an array of these pointed to by
// IMAGE_COR20_HEADER.VTableFixups.  Each entry describes a contiguous array of
// v-table slots.  The slots start out initialized to the meta data token value
// for the method they need to call.  At image load time, the CLR Loader will
// turn each entry into a pointer to machine code for the CPU and can be
// called directly.
//*****************************************************************************

typedef struct IMAGE_COR_VTABLEFIXUP
{
    ULONG       RVA;                    // Offset of v-table array in image.
    USHORT      Count;                  // How many entries at location.
    USHORT      Type;                   // COR_VTABLE_xxx type of entries.
} IMAGE_COR_VTABLEFIXUP;





//*****************************************************************************
//*****************************************************************************
//
// M E T A - D A T A    D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
//
// Enums for SetOption API.
//
//*****************************************************************************

// flags for MetaDataCheckDuplicatesFor
typedef enum CorCheckDuplicatesFor
{
    MDDupAll                    = 0xffffffff,
    MDDupENC                    = MDDupAll,
    MDNoDupChecks               = 0x00000000,
    MDDupTypeDef                = 0x00000001,
    MDDupInterfaceImpl          = 0x00000002,
    MDDupMethodDef              = 0x00000004,
    MDDupTypeRef                = 0x00000008,
    MDDupMemberRef              = 0x00000010,
    MDDupCustomAttribute        = 0x00000020,
    MDDupParamDef               = 0x00000040,
    MDDupPermission             = 0x00000080,
    MDDupProperty               = 0x00000100,
    MDDupEvent                  = 0x00000200,
    MDDupFieldDef               = 0x00000400,
    MDDupSignature              = 0x00000800,
    MDDupModuleRef              = 0x00001000,
    MDDupTypeSpec               = 0x00002000,
    MDDupImplMap                = 0x00004000,
    MDDupAssemblyRef            = 0x00008000,
    MDDupFile                   = 0x00010000,
    MDDupExportedType           = 0x00020000,
    MDDupManifestResource       = 0x00040000,
    MDDupGenericParam           = 0x00080000,
    MDDupMethodSpec             = 0x00100000,
    MDDupGenericParamConstraint = 0x00200000,
    // gap for debug junk
    MDDupAssembly               = 0x10000000,

    // This is the default behavior on metadata. It will check duplicates for TypeRef, MemberRef, Signature, TypeSpec and MethodSpec.
    MDDupDefault = MDNoDupChecks | MDDupTypeRef | MDDupMemberRef | MDDupSignature | MDDupTypeSpec | MDDupMethodSpec,
} CorCheckDuplicatesFor;

// flags for MetaDataRefToDefCheck
typedef enum CorRefToDefCheck
{
    // default behavior is to always perform TypeRef to TypeDef and MemberRef to MethodDef/FieldDef optimization
    MDRefToDefDefault           = 0x00000003,
    MDRefToDefAll               = 0xffffffff,
    MDRefToDefNone              = 0x00000000,
    MDTypeRefToDef              = 0x00000001,
    MDMemberRefToDef            = 0x00000002
} CorRefToDefCheck;


// MetaDataNotificationForTokenMovement
typedef enum CorNotificationForTokenMovement
{
    // default behavior is to notify TypeRef, MethodDef, MemberRef, and FieldDef token remaps
    MDNotifyDefault             = 0x0000000f,
    MDNotifyAll                 = 0xffffffff,
    MDNotifyNone                = 0x00000000,
    MDNotifyMethodDef           = 0x00000001,
    MDNotifyMemberRef           = 0x00000002,
    MDNotifyFieldDef            = 0x00000004,
    MDNotifyTypeRef             = 0x00000008,

    MDNotifyTypeDef             = 0x00000010,
    MDNotifyParamDef            = 0x00000020,
    MDNotifyInterfaceImpl       = 0x00000040,
    MDNotifyProperty            = 0x00000080,
    MDNotifyEvent               = 0x00000100,
    MDNotifySignature           = 0x00000200,
    MDNotifyTypeSpec            = 0x00000400,
    MDNotifyCustomAttribute     = 0x00000800,
    MDNotifySecurityValue       = 0x00001000,
    MDNotifyPermission          = 0x00002000,
    MDNotifyModuleRef           = 0x00004000,

    MDNotifyNameSpace           = 0x00008000,

    MDNotifyAssemblyRef         = 0x01000000,
    MDNotifyFile                = 0x02000000,
    MDNotifyExportedType        = 0x04000000,
    MDNotifyResource            = 0x08000000,
} CorNotificationForTokenMovement;


typedef enum CorSetENC
{
    MDSetENCOn                  = 0x00000001,   // Deprecated name.
    MDSetENCOff                 = 0x00000002,   // Deprecated name.

    MDUpdateENC                 = 0x00000001,   // ENC mode.  Tokens don't move; can be updated.
    MDUpdateFull                = 0x00000002,   // "Normal" update mode.
    MDUpdateExtension           = 0x00000003,   // Extension mode.  Tokens don't move, adds only.
    MDUpdateIncremental         = 0x00000004,   // Incremental compilation
    MDUpdateDelta               = 0x00000005,   // If ENC on, save only deltas.
    MDUpdateMask                = 0x00000007,


} CorSetENC;

#define IsENCDelta(x)                       (((x) & MDUpdateMask) == MDUpdateDelta)

// flags used in SetOption when pair with MetaDataErrorIfEmitOutOfOrder guid
typedef enum CorErrorIfEmitOutOfOrder
{
    MDErrorOutOfOrderDefault    = 0x00000000,   // default not to generate any error
    MDErrorOutOfOrderNone       = 0x00000000,   // do not generate error for out of order emit
    MDErrorOutOfOrderAll        = 0xffffffff,   // generate out of order emit for method, field, param, property, and event
    MDMethodOutOfOrder          = 0x00000001,   // generate error when methods are emitted out of order
    MDFieldOutOfOrder           = 0x00000002,   // generate error when fields are emitted out of order
    MDParamOutOfOrder           = 0x00000004,   // generate error when params are emitted out of order
    MDPropertyOutOfOrder        = 0x00000008,   // generate error when properties are emitted out of order
    MDEventOutOfOrder           = 0x00000010,   // generate error when events are emitted out of order
} CorErrorIfEmitOutOfOrder;


// flags used in SetOption when pair with MetaDataImportOption guid
typedef enum CorImportOptions
{
    MDImportOptionDefault       = 0x00000000,   // default to skip over deleted records
    MDImportOptionAll           = 0xFFFFFFFF,   // Enumerate everything
    MDImportOptionAllTypeDefs   = 0x00000001,   // all of the typedefs including the deleted typedef
    MDImportOptionAllMethodDefs = 0x00000002,   // all of the methoddefs including the deleted ones
    MDImportOptionAllFieldDefs  = 0x00000004,   // all of the fielddefs including the deleted ones
    MDImportOptionAllProperties = 0x00000008,   // all of the properties including the deleted ones
    MDImportOptionAllEvents     = 0x00000010,   // all of the events including the deleted ones
    MDImportOptionAllCustomAttributes = 0x00000020, // all of the custom attributes including the deleted ones
    MDImportOptionAllExportedTypes  = 0x00000040,   // all of the ExportedTypes including the deleted ones

} CorImportOptions;


// flags for MetaDataThreadSafetyOptions
typedef enum CorThreadSafetyOptions
{
    // default behavior is to have thread safety turn off. This means that MetaData APIs will not take reader/writer
    // lock. Clients is responsible to make sure the properly thread synchornization when using MetaData APIs.
    MDThreadSafetyDefault       = 0x00000000,
    MDThreadSafetyOff           = 0x00000000,
    MDThreadSafetyOn            = 0x00000001,
} CorThreadSafetyOptions;


// flags for MetaDataLinkerOptions
typedef enum CorLinkerOptions
{
    // default behavior is not to keep private types
    MDAssembly          = 0x00000000,
    MDNetModule         = 0x00000001,
} CorLinkerOptions;

// flags for MetaDataMergeOptions
typedef enum MergeFlags
{
    MergeFlagsNone      =   0,
    MergeManifest       =   0x00000001,     
    DropMemberRefCAs    =   0x00000002,
    NoDupCheck          =   0x00000004,
    MergeExportedTypes  =   0x00000008
} MergeFlags;


//
// struct used to retrieve field offset
// used by GetClassLayout and SetClassLayout
//

#ifndef _COR_FIELD_OFFSET_
#define _COR_FIELD_OFFSET_

typedef struct COR_FIELD_OFFSET
{
    mdFieldDef  ridOfField;
    ULONG       ulOffset;
} COR_FIELD_OFFSET;

#endif

typedef struct IMAGE_COR_FIXUPENTRY
{
    ULONG ulRVA;
    ULONG Count;
} IMAGE_COR_FIXUPENTRY;


//
// Token tags.
//
typedef enum CorTokenType
{
    mdtModule               = 0x00000000,       //
    mdtTypeRef              = 0x01000000,       //
    mdtTypeDef              = 0x02000000,       //
    mdtFieldDef             = 0x04000000,       //
    mdtMethodDef            = 0x06000000,       //
    mdtParamDef             = 0x08000000,       //
    mdtInterfaceImpl        = 0x09000000,       //
    mdtMemberRef            = 0x0a000000,       //
    mdtCustomAttribute      = 0x0c000000,       //
    mdtPermission           = 0x0e000000,       //
    mdtSignature            = 0x11000000,       //
    mdtEvent                = 0x14000000,       //
    mdtProperty             = 0x17000000,       //
    mdtModuleRef            = 0x1a000000,       //
    mdtTypeSpec             = 0x1b000000,       //
    mdtAssembly             = 0x20000000,       //
    mdtAssemblyRef          = 0x23000000,       //
    mdtFile                 = 0x26000000,       //
    mdtExportedType         = 0x27000000,       //
    mdtManifestResource     = 0x28000000,       //
    mdtGenericParam         = 0x2a000000,       //
    mdtMethodSpec           = 0x2b000000,       //
    mdtGenericParamConstraint = 0x2c000000,

    mdtString               = 0x70000000,       //
    mdtName                 = 0x71000000,       //
    mdtBaseType             = 0x72000000,       // Leave this on the high end value. This does not correspond to metadata table
} CorTokenType;

//
// Build / decompose tokens.
//
#define RidToToken(rid,tktype) ((rid) |= (tktype))
#define TokenFromRid(rid,tktype) ((rid) | (tktype))
#define RidFromToken(tk) ((RID) ((tk) & 0x00ffffff))
#define TypeFromToken(tk) ((ULONG32)((tk) & 0xff000000))
#define IsNilToken(tk) ((RidFromToken(tk)) == 0)

//
// Nil tokens
//
#define mdTokenNil                  ((mdToken)0)
#define mdModuleNil                 ((mdModule)mdtModule)
#define mdTypeRefNil                ((mdTypeRef)mdtTypeRef)
#define mdTypeDefNil                ((mdTypeDef)mdtTypeDef)
#define mdFieldDefNil               ((mdFieldDef)mdtFieldDef)
#define mdMethodDefNil              ((mdMethodDef)mdtMethodDef)
#define mdParamDefNil               ((mdParamDef)mdtParamDef)
#define mdInterfaceImplNil          ((mdInterfaceImpl)mdtInterfaceImpl)
#define mdMemberRefNil              ((mdMemberRef)mdtMemberRef)
#define mdCustomAttributeNil        ((mdCustomAttribute)mdtCustomAttribute)
#define mdPermissionNil             ((mdPermission)mdtPermission)
#define mdSignatureNil              ((mdSignature)mdtSignature)
#define mdEventNil                  ((mdEvent)mdtEvent)
#define mdPropertyNil               ((mdProperty)mdtProperty)
#define mdModuleRefNil              ((mdModuleRef)mdtModuleRef)
#define mdTypeSpecNil               ((mdTypeSpec)mdtTypeSpec)
#define mdAssemblyNil               ((mdAssembly)mdtAssembly)
#define mdAssemblyRefNil            ((mdAssemblyRef)mdtAssemblyRef)
#define mdFileNil                   ((mdFile)mdtFile)
#define mdExportedTypeNil           ((mdExportedType)mdtExportedType)
#define mdManifestResourceNil       ((mdManifestResource)mdtManifestResource)

#define mdGenericParamNil           ((mdGenericParam)mdtGenericParam)
#define mdGenericParamConstraintNil ((mdGenericParamConstraint)mdtGenericParamConstraint)
#define mdMethodSpecNil             ((mdMethodSpec)mdtMethodSpec)

#define mdStringNil                 ((mdString)mdtString)

//
// Open bits.
//
typedef enum CorOpenFlags
{
    ofRead              =   0x00000000,     // Open scope for read
    ofWrite             =   0x00000001,     // Open scope for write.
    ofReadWriteMask     =   0x00000001,     // Mask for read/write bit.

    ofCopyMemory        =   0x00000002,     // Open scope with memory. Ask metadata to maintain its own copy of memory.

    ofManifestMetadata  =   0x00000008,     // Open scope on ngen image, return the manifest metadata instead of the IL metadata
    ofReadOnly          =   0x00000010,     // Open scope for read. Will be unable to QI for a IMetadataEmit* interface
    ofTakeOwnership     =   0x00000020,     // The memory was allocated with CoTaskMemAlloc and will be freed by the metadata

    // These are obsolete and are ignored.
    ofCacheImage        =   0x00000004,     // EE maps but does not do relocations or verify image
    ofNoTypeLib         =   0x00000080,     // Don't OpenScope on a typelib.

    // Internal bits
    ofReserved1         =   0x00000100,     // Reserved for internal use.
    ofReserved2         =   0x00000200,     // Reserved for internal use.
    ofReserved          =   0xffffff40      // All the reserved bits.

} CorOpenFlags;

#define IsOfRead(x)                         (((x) & ofReadWriteMask) == ofRead)
#define IsOfReadWrite(x)                    (((x) & ofReadWriteMask) == ofWrite)

#define IsOfCopyMemory(x)                   ((x) & ofCopyMemory)
#define IsOfManifestMetadata(x)             ((x) & ofManifestMetadata)

#define IsOfReadOnly(x)                     ((x) & ofReadOnly)
#define IsOfTakeOwnership(x)                ((x) & ofTakeOwnership)

#define IsOfReserved(x)                     (((x) & ofReserved) != 0)

typedef CorTypeAttr CorRegTypeAttr;

//
// Opaque type for an enumeration handle.
//
typedef void *HCORENUM;


// Note that this must be kept in sync with System.AttributeTargets.
typedef enum CorAttributeTargets
{
    catAssembly      = 0x0001,
    catModule        = 0x0002,
    catClass         = 0x0004,
    catStruct        = 0x0008,
    catEnum          = 0x0010,
    catConstructor   = 0x0020,
    catMethod        = 0x0040,
    catProperty      = 0x0080,
    catField         = 0x0100,
    catEvent         = 0x0200,
    catInterface     = 0x0400,
    catParameter     = 0x0800,
    catDelegate      = 0x1000,
    catGenericParameter = 0x4000,

    catAll           = catAssembly | catModule | catClass | catStruct | catEnum | catConstructor |
                    catMethod | catProperty | catField | catEvent | catInterface | catParameter | catDelegate | catGenericParameter,
    catClassMembers  = catClass | catStruct | catEnum | catConstructor | catMethod | catProperty | catField | catEvent | catDelegate | catInterface,

} CorAttributeTargets;

#ifndef MACROS_NOT_SUPPORTED
//
// Some well-known custom attributes
//
#ifndef IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS
  #define IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS (IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS)
#endif

#define INTEROP_DISPID_TYPE_W                   L"System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_TYPE                     "System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_SIG                      {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_INTERFACETYPE_TYPE_W            L"System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_TYPE              "System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_CLASSINTERFACE_TYPE_W           L"System.Runtime.InteropServices.ClassInterfaceAttribute"
#define INTEROP_CLASSINTERFACE_TYPE             "System.Runtime.InteropServices.ClassInterfaceAttribute"
#define INTEROP_CLASSINTERFACE_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMVISIBLE_TYPE_W               L"System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_TYPE                 "System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_COMREGISTERFUNCTION_TYPE_W      L"System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_TYPE        "System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMUNREGISTERFUNCTION_TYPE_W    L"System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_TYPE      "System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_SIG       {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IMPORTEDFROMTYPELIB_TYPE_W      L"System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_TYPE        "System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_IDISPATCHIMPL_TYPE_W            L"System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_TYPE              "System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMSOURCEINTERFACES_TYPE_W      L"System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_TYPE        "System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMDEFAULTINTERFACE_TYPE_W      L"System.Runtime.InteropServices.ComDefaultInterfaceAttribute"
#define INTEROP_COMDEFAULTINTERFACE_TYPE        "System.Runtime.InteropServices.ComDefaultInterfaceAttribute"

#define INTEROP_COMCONVERSIONLOSS_TYPE_W        L"System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_TYPE          "System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_SIG           {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_BESTFITMAPPING_TYPE_W           L"System.Runtime.InteropServices.BestFitMappingAttribute"
#define INTEROP_BESTFITMAPPING_TYPE             "System.Runtime.InteropServices.BestFitMappingAttribute"
#define INTEROP_BESTFITMAPPING_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 2, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_TYPELIBTYPE_TYPE_W              L"System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_TYPE                "System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBFUNC_TYPE_W              L"System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_TYPE                "System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBVAR_TYPE_W               L"System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_TYPE                 "System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_MARSHALAS_TYPE_W                L"System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_TYPE                  "System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMIMPORT_TYPE_W                L"System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_TYPE                  "System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_GUID_TYPE_W                     L"System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_TYPE                       "System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_SIG                        {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_DEFAULTMEMBER_TYPE_W            L"System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_TYPE              "System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMEMULATE_TYPE_W               L"System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_TYPE                 "System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_PRESERVESIG_TYPE_W              L"System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_TYPE                "System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_IN_TYPE_W                       L"System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_TYPE                         "System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_SIG                          {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_OUT_TYPE_W                      L"System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_TYPE                        "System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_SIG                         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMALIASNAME_TYPE_W             L"System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_TYPE               "System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_PARAMARRAY_TYPE_W               L"System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_TYPE                 "System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_LCIDCONVERSION_TYPE_W           L"System.Runtime.InteropServices.LCIDConversionAttribute"
#define INTEROP_LCIDCONVERSION_TYPE             "System.Runtime.InteropServices.LCIDConversionAttribute"
#define INTEROP_LCIDCONVERSION_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_COMSUBSTITUTABLEINTERFACE_TYPE_W    L"System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute"
#define INTEROP_COMSUBSTITUTABLEINTERFACE_TYPE      "System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute"
#define INTEROP_COMSUBSTITUTABLEINTERFACE_SIG       {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_DECIMALVALUE_TYPE_W             L"System.Runtime.CompilerServices.DecimalConstantAttribute"
#define INTEROP_DECIMALVALUE_TYPE               "System.Runtime.CompilerServices.DecimalConstantAttribute"
#define INTEROP_DECIMALVALUE_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 5, ELEMENT_TYPE_VOID, ELEMENT_TYPE_U1, ELEMENT_TYPE_U1, ELEMENT_TYPE_U4, ELEMENT_TYPE_U4, ELEMENT_TYPE_U4}

#define INTEROP_DATETIMEVALUE_TYPE_W            L"System.Runtime.CompilerServices.DateTimeConstantAttribute"
#define INTEROP_DATETIMEVALUE_TYPE              "System.Runtime.CompilerServices.DateTimeConstantAttribute"
#define INTEROP_DATETIMEVALUE_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I8}

#define INTEROP_IUNKNOWNVALUE_TYPE_W            L"System.Runtime.CompilerServices.IUnknownConstantAttribute"
#define INTEROP_IUNKNOWNVALUE_TYPE               "System.Runtime.CompilerServices.IUnknownConstantAttribute"
#define INTEROP_IUNKNOWNVALUE_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IDISPATCHVALUE_TYPE_W           L"System.Runtime.CompilerServices.IDispatchConstantAttribute"
#define INTEROP_IDISPATCHVALUE_TYPE              "System.Runtime.CompilerServices.IDispatchConstantAttribute"
#define INTEROP_IDISPATCHVALUE_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_AUTOPROXY_TYPE_W                L"System.Runtime.InteropServices.AutomationProxyAttribute"
#define INTEROP_AUTOPROXY_TYPE                  "System.Runtime.InteropServices.AutomationProxyAttribute"
#define INTEROP_AUTOPROXY_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_TYPELIBIMPORTCLASS_TYPE_W       L"System.Runtime.InteropServices.TypeLibImportClassAttribute"
#define INTEROP_TYPELIBIMPORTCLASS_TYPE         "System.Runtime.InteropServices.TypeLibImportClassAttribute"


#define INTEROP_TYPELIBVERSION_TYPE_W           L"System.Runtime.InteropServices.TypeLibVersionAttribute"
#define INTEROP_TYPELIBVERSION_TYPE             "System.Runtime.InteropServices.TypeLibVersionAttribute"
#define INTEROP_TYPELIBVERSION_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 2, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2}

#define INTEROP_COMCOMPATIBLEVERSION_TYPE_W     L"System.Runtime.InteropServices.ComCompatibleVersionAttribute"
#define INTEROP_COMCOMPATIBLEVERSION_TYPE       "System.Runtime.InteropServices.ComCompatibleVersionAttribute"
#define INTEROP_COMCOMPATIBLEVERSION_SIG        {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 4, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2}

#define INTEROP_COMEVENTINTERFACE_TYPE_W        L"System.Runtime.InteropServices.ComEventInterfaceAttribute"
#define INTEROP_COMEVENTINTERFACE_TYPE          "System.Runtime.InteropServices.ComEventInterfaceAttribute"

#define INTEROP_COCLASS_TYPE_W                  L"System.Runtime.InteropServices.CoClassAttribute"
#define INTEROP_COCLASS_TYPE                    "System.Runtime.InteropServices.CoClassAttribute"

#define INTEROP_SERIALIZABLE_TYPE_W             L"System.SerializableAttribute"
#define INTEROP_SERIALIZABLE_TYPE               "System.SerializableAttribute"
#define INTEROP_SERIALIZABLE_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_SETWIN32CONTEXTINIDISPATCHATTRIBUTE_TYPE_W  L"System.Runtime.InteropServices.SetWin32ContextInIDispatchAttribute"
#define INTEROP_SETWIN32CONTEXTINIDISPATCHATTRIBUTE_TYPE     "System.Runtime.InteropServices.SetWin32ContextInIDispatchAttribute"
#define INTEROP_SETWIN32CONTEXTINIDISPATCHATTRIBUTE_SIG     {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define FRIEND_ASSEMBLY_TYPE_W                  L"System.Runtime.CompilerServices.InternalsVisibleToAttribute"
#define FRIEND_ASSEMBLY_TYPE                     "System.Runtime.CompilerServices.InternalsVisibleToAttribute"
#define FRIEND_ASSEMBLY_SIG                     {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define DEFAULTDOMAIN_STA_TYPE_W                L"System.STAThreadAttribute"
#define DEFAULTDOMAIN_STA_TYPE                   "System.STAThreadAttribute"
#define DEFAULTDOMAIN_STA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_MTA_TYPE_W                L"System.MTAThreadAttribute"
#define DEFAULTDOMAIN_MTA_TYPE                   "System.MTAThreadAttribute"
#define DEFAULTDOMAIN_MTA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE_W L"System.LoaderOptimizationAttribute"
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE    "System.LoaderOptimizationAttribute"
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_SIG    {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I1}


// Keep in sync with CompilationRelaxations.cs
typedef enum CompilationRelaxationsEnum
{
    CompilationRelaxations_NoStringInterning       = 0x0008,
        
} CompilationRelaxationEnum;

#define COMPILATIONRELAXATIONS_TYPE_W           L"System.Runtime.CompilerServices.CompilationRelaxationsAttribute"
#define COMPILATIONRELAXATIONS_TYPE             "System.Runtime.CompilerServices.CompilationRelaxationsAttribute"


// Keep in sync with RuntimeCompatibilityAttribute.cs
#define RUNTIMECOMPATIBILITY_TYPE_W             L"System.Runtime.CompilerServices.RuntimeCompatibilityAttribute"
#define RUNTIMECOMPATIBILITY_TYPE               "System.Runtime.CompilerServices.RuntimeCompatibilityAttribute"


// Keep in sync with AssemblySettingAttributes.cs

typedef enum NGenHintEnum
{    
    NGenDefault             = 0x0000, // No preference specified

    NGenEager               = 0x0001, // NGen at install time
    NGenLazy                = 0x0002, // NGen after install time
    NGenNever               = 0x0003  // Assembly should not be ngened      
};

typedef enum LoadHintEnum
{
    LoadDefault             = 0x0000, // No preference specified

    LoadAlways              = 0x0001, // Dependency is always loaded
    LoadSometimes           = 0x0002, // Dependency is sometimes loaded
    LoadNever               = 0x0003  // Dependency is never loaded
};

#define NGEN_TYPE_W                             L"System.Runtime.CompilerServices.NGenAttribute"
#define NGEN_TYPE                               "System.Runtime.CompilerServices.NGenAttribute"

#define DEFAULTDEPENDENCY_TYPE_W                L"System.Runtime.CompilerServices.DefaultDependencyAttribute"
#define DEFAULTDEPENDENCY_TYPE                  "System.Runtime.CompilerServices.DefaultDependencyAttribute"

#define DEPENDENCY_TYPE_W                       L"System.Runtime.CompilerServices.DependencyAttribute"
#define DEPENDENCY_TYPE                         "System.Runtime.CompilerServices.DependencyAttribute"


#define CMOD_CALLCONV_NAMESPACE_OLD             "System.Runtime.InteropServices"
#define CMOD_CALLCONV_NAMESPACE                 "System.Runtime.CompilerServices"
#define CMOD_CALLCONV_NAME_CDECL                "CallConvCdecl"
#define CMOD_CALLCONV_NAME_STDCALL              "CallConvStdcall"
#define CMOD_CALLCONV_NAME_THISCALL             "CallConvThiscall"
#define CMOD_CALLCONV_NAME_FASTCALL             "CallConvFastcall"

#endif // MACROS_NOT_SUPPORTED

//
// GetSaveSize accuracy
//
#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
typedef enum CorSaveSize
{
    cssAccurate             = 0x0000,               // Find exact save size, accurate but slower.
    cssQuick                = 0x0001,               // Estimate save size, may pad estimate, but faster.
    cssDiscardTransientCAs  = 0x0002,               // remove all of the CAs of discardable types
} CorSaveSize;
#endif

#define COR_IS_METHOD_MANAGED_IL(flags)         ((flags & 0xf) == (miIL | miManaged))
#define COR_IS_METHOD_MANAGED_OPTIL(flags)      ((flags & 0xf) == (miOPTIL | miManaged))
#define COR_IS_METHOD_MANAGED_NATIVE(flags)     ((flags & 0xf) == (miNative | miManaged))
#define COR_IS_METHOD_UNMANAGED_NATIVE(flags)   ((flags & 0xf) == (miNative | miUnmanaged))

//
// Enum used with NATIVE_TYPE_ARRAY.
//
typedef enum NativeTypeArrayFlags
{
    ntaSizeParamIndexSpecified = 0x0001,
    ntaReserved                = 0xfffe      // All the reserved bits.
};

//
// Opaque types for security properties and values.
//
typedef void  *  PSECURITY_PROPS ;
typedef void  *  PSECURITY_VALUE ;
typedef void ** PPSECURITY_PROPS ;
typedef void ** PPSECURITY_VALUE ;

//-------------------------------------
//--- Security data structures
//-------------------------------------

// Descriptor for a single security custom attribute.
typedef struct COR_SECATTR {
    mdMemberRef     tkCtor;         // Ref to constructor of security attribute.
    const void      *pCustomAttribute;  // Blob describing ctor args and field/property values.
    ULONG           cbCustomAttribute;  // Length of the above blob.
} COR_SECATTR;

#endif // __CORHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\corprof.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for corprof.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __corprof_h__
#define __corprof_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICorProfilerCallback_FWD_DEFINED__
#define __ICorProfilerCallback_FWD_DEFINED__
typedef interface ICorProfilerCallback ICorProfilerCallback;
#endif 	/* __ICorProfilerCallback_FWD_DEFINED__ */


#ifndef __ICorProfilerCallback2_FWD_DEFINED__
#define __ICorProfilerCallback2_FWD_DEFINED__
typedef interface ICorProfilerCallback2 ICorProfilerCallback2;
#endif 	/* __ICorProfilerCallback2_FWD_DEFINED__ */


#ifndef __ICorProfilerInfo_FWD_DEFINED__
#define __ICorProfilerInfo_FWD_DEFINED__
typedef interface ICorProfilerInfo ICorProfilerInfo;
#endif 	/* __ICorProfilerInfo_FWD_DEFINED__ */


#ifndef __ICorProfilerInfo2_FWD_DEFINED__
#define __ICorProfilerInfo2_FWD_DEFINED__
typedef interface ICorProfilerInfo2 ICorProfilerInfo2;
#endif 	/* __ICorProfilerInfo2_FWD_DEFINED__ */


#ifndef __ICorProfilerObjectEnum_FWD_DEFINED__
#define __ICorProfilerObjectEnum_FWD_DEFINED__
typedef interface ICorProfilerObjectEnum ICorProfilerObjectEnum;
#endif 	/* __ICorProfilerObjectEnum_FWD_DEFINED__ */


#ifndef __IMethodMalloc_FWD_DEFINED__
#define __IMethodMalloc_FWD_DEFINED__
typedef interface IMethodMalloc IMethodMalloc;
#endif 	/* __IMethodMalloc_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_corprof_0000 */
/* [local] */ 

#define PROFILER_REGKEY_ROOT            L"software\\microsoft\\.NETFramework\\Profilers"
#define PROFILER_REGVALUE_HELPSTRING    L"HelpString"
#define PROFILER_REGVALUE_PROFID        L"ProfilerID"
#define CorDB_CONTROL_Profiling         "Cor_Enable_Profiling"
#define CorDB_CONTROL_ProfilingL       L"Cor_Enable_Profiling"
#if 0
typedef LONG32 mdToken;

typedef mdToken mdModule;

typedef mdToken mdTypeDef;

typedef mdToken mdMethodDef;

typedef mdToken mdFieldDef;

typedef ULONG CorElementType;


#endif
typedef const BYTE *LPCBYTE;

typedef BYTE *LPBYTE;

#ifndef _COR_IL_MAP
#define _COR_IL_MAP
typedef struct _COR_IL_MAP
    {
    ULONG32 oldOffset;
    ULONG32 newOffset;
    BOOL fAccurate;
    } 	COR_IL_MAP;

#endif //_COR_IL_MAP
#ifndef _COR_DEBUG_IL_TO_NATIVE_MAP_
#define _COR_DEBUG_IL_TO_NATIVE_MAP_
typedef 
enum CorDebugIlToNativeMappingTypes
    {	NO_MAPPING	= -1,
	PROLOG	= -2,
	EPILOG	= -3
    } 	CorDebugIlToNativeMappingTypes;

typedef struct COR_DEBUG_IL_TO_NATIVE_MAP
    {
    ULONG32 ilOffset;
    ULONG32 nativeStartOffset;
    ULONG32 nativeEndOffset;
    } 	COR_DEBUG_IL_TO_NATIVE_MAP;

#endif // _COR_DEBUG_IL_TO_NATIVE_MAP_
#ifndef _COR_FIELD_OFFSET_
#define _COR_FIELD_OFFSET_
typedef struct _COR_FIELD_OFFSET
    {
    mdFieldDef ridOfField;
    ULONG ulOffset;
    } 	COR_FIELD_OFFSET;

#endif // _COR_FIELD_OFFSET_
typedef UINT_PTR ProcessID;

typedef UINT_PTR AssemblyID;

typedef UINT_PTR AppDomainID;

typedef UINT_PTR ModuleID;

typedef UINT_PTR ClassID;

typedef UINT_PTR ThreadID;

typedef UINT_PTR ContextID;

typedef UINT_PTR FunctionID;

typedef UINT_PTR ObjectID;

typedef UINT_PTR GCHandleID;

typedef UINT_PTR __stdcall __stdcall FunctionIDMapper( 
    FunctionID funcId,
    BOOL *pbHookFunction);

typedef 
enum _COR_PRF_SNAPSHOT_INFO
    {	COR_PRF_SNAPSHOT_DEFAULT	= 0,
	COR_PRF_SNAPSHOT_REGISTER_CONTEXT	= 0x1
    } 	COR_PRF_SNAPSHOT_INFO;

typedef UINT_PTR COR_PRF_FRAME_INFO;

typedef struct _COR_PRF_FUNCTION_ARGUMENT_RANGE
    {
    UINT_PTR startAddress;
    ULONG length;
    } 	COR_PRF_FUNCTION_ARGUMENT_RANGE;

typedef struct _COR_PRF_FUNCTION_ARGUMENT_INFO
    {
    ULONG numRanges;
    ULONG totalArgumentSize;
    COR_PRF_FUNCTION_ARGUMENT_RANGE ranges[ 1 ];
    } 	COR_PRF_FUNCTION_ARGUMENT_INFO;

typedef struct _COR_PRF_CODE_INFO
    {
    UINT_PTR startAddress;
    SIZE_T size;
    } 	COR_PRF_CODE_INFO;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0001
    {	COR_PRF_FIELD_NOT_A_STATIC	= 0,
	COR_PRF_FIELD_APP_DOMAIN_STATIC	= 0x1,
	COR_PRF_FIELD_THREAD_STATIC	= 0x2,
	COR_PRF_FIELD_CONTEXT_STATIC	= 0x4,
	COR_PRF_FIELD_RVA_STATIC	= 0x8
    } 	COR_PRF_STATIC_TYPE;

typedef void FunctionEnter( 
    FunctionID funcID);

typedef void FunctionLeave( 
    FunctionID funcID);

typedef void FunctionTailcall( 
    FunctionID funcID);

typedef void FunctionEnter2( 
    FunctionID funcId,
    UINT_PTR clientData,
    COR_PRF_FRAME_INFO func,
    COR_PRF_FUNCTION_ARGUMENT_INFO *argumentInfo);

typedef void FunctionLeave2( 
    FunctionID funcId,
    UINT_PTR clientData,
    COR_PRF_FRAME_INFO func,
    COR_PRF_FUNCTION_ARGUMENT_RANGE *retvalRange);

typedef void FunctionTailcall2( 
    FunctionID funcId,
    UINT_PTR clientData,
    COR_PRF_FRAME_INFO func);

typedef HRESULT __stdcall __stdcall StackSnapshotCallback( 
    FunctionID funcId,
    UINT_PTR ip,
    COR_PRF_FRAME_INFO frameInfo,
    ULONG32 contextSize,
    BYTE context[  ],
    void *clientData);

typedef /* [public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0002
    {	COR_PRF_MONITOR_NONE	= 0,
	COR_PRF_MONITOR_FUNCTION_UNLOADS	= 0x1,
	COR_PRF_MONITOR_CLASS_LOADS	= 0x2,
	COR_PRF_MONITOR_MODULE_LOADS	= 0x4,
	COR_PRF_MONITOR_ASSEMBLY_LOADS	= 0x8,
	COR_PRF_MONITOR_APPDOMAIN_LOADS	= 0x10,
	COR_PRF_MONITOR_JIT_COMPILATION	= 0x20,
	COR_PRF_MONITOR_EXCEPTIONS	= 0x40,
	COR_PRF_MONITOR_GC	= 0x80,
	COR_PRF_MONITOR_OBJECT_ALLOCATED	= 0x100,
	COR_PRF_MONITOR_THREADS	= 0x200,
	COR_PRF_MONITOR_REMOTING	= 0x400,
	COR_PRF_MONITOR_CODE_TRANSITIONS	= 0x800,
	COR_PRF_MONITOR_ENTERLEAVE	= 0x1000,
	COR_PRF_MONITOR_CCW	= 0x2000,
	COR_PRF_MONITOR_REMOTING_COOKIE	= 0x4000 | COR_PRF_MONITOR_REMOTING,
	COR_PRF_MONITOR_REMOTING_ASYNC	= 0x8000 | COR_PRF_MONITOR_REMOTING,
	COR_PRF_MONITOR_SUSPENDS	= 0x10000,
	COR_PRF_MONITOR_CACHE_SEARCHES	= 0x20000,
	COR_PRF_MONITOR_CLR_EXCEPTIONS	= 0x1000000,
	COR_PRF_MONITOR_ALL	= 0x107ffff,
	COR_PRF_ENABLE_REJIT	= 0x40000,
	COR_PRF_ENABLE_INPROC_DEBUGGING	= 0x80000,
	COR_PRF_ENABLE_JIT_MAPS	= 0x100000,
	COR_PRF_DISABLE_INLINING	= 0x200000,
	COR_PRF_DISABLE_OPTIMIZATIONS	= 0x400000,
	COR_PRF_ENABLE_OBJECT_ALLOCATED	= 0x800000,
	COR_PRF_ENABLE_FUNCTION_ARGS	= 0x2000000,
	COR_PRF_ENABLE_FUNCTION_RETVAL	= 0x4000000,
	COR_PRF_ENABLE_FRAME_INFO	= 0x8000000,
	COR_PRF_ENABLE_STACK_SNAPSHOT	= 0x10000000,
	COR_PRF_USE_PROFILE_IMAGES	= 0x20000000,
	COR_PRF_ALL	= 0x3fffffff,
	COR_PRF_MONITOR_IMMUTABLE	= COR_PRF_MONITOR_CODE_TRANSITIONS | COR_PRF_MONITOR_REMOTING | COR_PRF_MONITOR_REMOTING_COOKIE | COR_PRF_MONITOR_REMOTING_ASYNC | COR_PRF_MONITOR_GC | COR_PRF_ENABLE_REJIT | COR_PRF_ENABLE_INPROC_DEBUGGING | COR_PRF_ENABLE_JIT_MAPS | COR_PRF_DISABLE_OPTIMIZATIONS | COR_PRF_DISABLE_INLINING | COR_PRF_ENABLE_OBJECT_ALLOCATED | COR_PRF_ENABLE_FUNCTION_ARGS | COR_PRF_ENABLE_FUNCTION_RETVAL | COR_PRF_ENABLE_FRAME_INFO | COR_PRF_ENABLE_STACK_SNAPSHOT | COR_PRF_USE_PROFILE_IMAGES
    } 	COR_PRF_MONITOR;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0003
    {	PROFILER_PARENT_UNKNOWN	= 0xfffffffd,
	PROFILER_GLOBAL_CLASS	= 0xfffffffe,
	PROFILER_GLOBAL_MODULE	= 0xffffffff
    } 	COR_PRF_MISC;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0004
    {	COR_PRF_CACHED_FUNCTION_FOUND	= 0,
	COR_PRF_CACHED_FUNCTION_NOT_FOUND	= COR_PRF_CACHED_FUNCTION_FOUND + 1
    } 	COR_PRF_JIT_CACHE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0005
    {	COR_PRF_TRANSITION_CALL	= 0,
	COR_PRF_TRANSITION_RETURN	= COR_PRF_TRANSITION_CALL + 1
    } 	COR_PRF_TRANSITION_REASON;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0006
    {	COR_PRF_SUSPEND_OTHER	= 0,
	COR_PRF_SUSPEND_FOR_GC	= 1,
	COR_PRF_SUSPEND_FOR_APPDOMAIN_SHUTDOWN	= 2,
	COR_PRF_SUSPEND_FOR_CODE_PITCHING	= 3,
	COR_PRF_SUSPEND_FOR_SHUTDOWN	= 4,
	COR_PRF_SUSPEND_FOR_INPROC_DEBUGGER	= 6,
	COR_PRF_SUSPEND_FOR_GC_PREP	= 7
    } 	COR_PRF_SUSPEND_REASON;









extern RPC_IF_HANDLE __MIDL_itf_corprof_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corprof_0000_v0_0_s_ifspec;

#ifndef __ICorProfilerCallback_INTERFACE_DEFINED__
#define __ICorProfilerCallback_INTERFACE_DEFINED__

/* interface ICorProfilerCallback */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("176FBED1-A55C-4796-98CA-A9DA0EF883E7")
    ICorProfilerCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *pICorProfilerInfoUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainCreationStarted( 
            /* [in] */ AppDomainID appDomainId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainCreationFinished( 
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainShutdownStarted( 
            /* [in] */ AppDomainID appDomainId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainShutdownFinished( 
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyLoadStarted( 
            /* [in] */ AssemblyID assemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyLoadFinished( 
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyUnloadStarted( 
            /* [in] */ AssemblyID assemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyUnloadFinished( 
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleLoadStarted( 
            /* [in] */ ModuleID moduleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleLoadFinished( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleUnloadStarted( 
            /* [in] */ ModuleID moduleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleUnloadFinished( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleAttachedToAssembly( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ AssemblyID AssemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassLoadStarted( 
            /* [in] */ ClassID classId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassLoadFinished( 
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassUnloadStarted( 
            /* [in] */ ClassID classId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassUnloadFinished( 
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FunctionUnloadStarted( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCompilationStarted( 
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fIsSafeToBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCompilationFinished( 
            /* [in] */ FunctionID functionId,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ BOOL fIsSafeToBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCachedFunctionSearchStarted( 
            /* [in] */ FunctionID functionId,
            /* [out] */ BOOL *pbUseCachedFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCachedFunctionSearchFinished( 
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_JIT_CACHE result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITFunctionPitched( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITInlining( 
            /* [in] */ FunctionID callerId,
            /* [in] */ FunctionID calleeId,
            /* [out] */ BOOL *pfShouldInline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadCreated( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadDestroyed( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadAssignedToOSThread( 
            /* [in] */ ThreadID managedThreadId,
            /* [in] */ DWORD osThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientInvocationStarted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientSendingMessage( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientReceivingReply( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientInvocationFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerReceivingMessage( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerInvocationStarted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerInvocationReturned( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerSendingReply( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmanagedToManagedTransition( 
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ManagedToUnmanagedTransition( 
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeSuspendStarted( 
            /* [in] */ COR_PRF_SUSPEND_REASON suspendReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeSuspendFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeSuspendAborted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeResumeStarted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeResumeFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeThreadSuspended( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeThreadResumed( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MovedReferences( 
            /* [in] */ ULONG cMovedObjectIDRanges,
            /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
            /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectAllocated( 
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectsAllocatedByClass( 
            /* [in] */ ULONG cClassCount,
            /* [size_is][in] */ ClassID classIds[  ],
            /* [size_is][in] */ ULONG cObjects[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectReferences( 
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG cObjectRefs,
            /* [size_is][in] */ ObjectID objectRefIds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RootReferences( 
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionThrown( 
            /* [in] */ ObjectID thrownObjectId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFunctionEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFunctionLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFilterEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFilterLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchCatcherFound( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionOSHandlerEnter( 
            /* [in] */ UINT_PTR __unused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionOSHandlerLeave( 
            /* [in] */ UINT_PTR __unused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFunctionEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFunctionLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFinallyEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFinallyLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCatcherEnter( 
            /* [in] */ FunctionID functionId,
            /* [in] */ ObjectID objectId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCatcherLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE COMClassicVTableCreated( 
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable,
            /* [in] */ ULONG cSlots) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE COMClassicVTableDestroyed( 
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCLRCatcherFound( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCLRCatcherExecute( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICorProfilerCallback * This,
            /* [in] */ IUnknown *pICorProfilerInfoUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainCreationStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainCreationFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainShutdownStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainShutdownFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyLoadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyLoadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyUnloadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleLoadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleLoadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleUnloadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleAttachedToAssembly )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ AssemblyID AssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassLoadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassLoadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ClassUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassUnloadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *FunctionUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *JITCompilationStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fIsSafeToBlock);
        
        HRESULT ( STDMETHODCALLTYPE *JITCompilationFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ BOOL fIsSafeToBlock);
        
        HRESULT ( STDMETHODCALLTYPE *JITCachedFunctionSearchStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ BOOL *pbUseCachedFunction);
        
        HRESULT ( STDMETHODCALLTYPE *JITCachedFunctionSearchFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_JIT_CACHE result);
        
        HRESULT ( STDMETHODCALLTYPE *JITFunctionPitched )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *JITInlining )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID callerId,
            /* [in] */ FunctionID calleeId,
            /* [out] */ BOOL *pfShouldInline);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadCreated )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadDestroyed )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadAssignedToOSThread )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID managedThreadId,
            /* [in] */ DWORD osThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientInvocationStarted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientSendingMessage )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientReceivingReply )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientInvocationFinished )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerReceivingMessage )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerInvocationStarted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerInvocationReturned )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerSendingReply )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *UnmanagedToManagedTransition )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *ManagedToUnmanagedTransition )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ COR_PRF_SUSPEND_REASON suspendReason);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendFinished )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendAborted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeResumeStarted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeResumeFinished )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeThreadSuspended )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeThreadResumed )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *MovedReferences )( 
            ICorProfilerCallback * This,
            /* [in] */ ULONG cMovedObjectIDRanges,
            /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
            /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectAllocated )( 
            ICorProfilerCallback * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectsAllocatedByClass )( 
            ICorProfilerCallback * This,
            /* [in] */ ULONG cClassCount,
            /* [size_is][in] */ ClassID classIds[  ],
            /* [size_is][in] */ ULONG cObjects[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectReferences )( 
            ICorProfilerCallback * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG cObjectRefs,
            /* [size_is][in] */ ObjectID objectRefIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RootReferences )( 
            ICorProfilerCallback * This,
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionThrown )( 
            ICorProfilerCallback * This,
            /* [in] */ ObjectID thrownObjectId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFunctionEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFunctionLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFilterEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFilterLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchCatcherFound )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionOSHandlerEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ UINT_PTR __unused);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionOSHandlerLeave )( 
            ICorProfilerCallback * This,
            /* [in] */ UINT_PTR __unused);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFunctionEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFunctionLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFinallyEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFinallyLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCatcherEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ ObjectID objectId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCatcherLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *COMClassicVTableCreated )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable,
            /* [in] */ ULONG cSlots);
        
        HRESULT ( STDMETHODCALLTYPE *COMClassicVTableDestroyed )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCLRCatcherFound )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCLRCatcherExecute )( 
            ICorProfilerCallback * This);
        
        END_INTERFACE
    } ICorProfilerCallbackVtbl;

    interface ICorProfilerCallback
    {
        CONST_VTBL struct ICorProfilerCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorProfilerCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorProfilerCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorProfilerCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorProfilerCallback_Initialize(This,pICorProfilerInfoUnk)	\
    (This)->lpVtbl -> Initialize(This,pICorProfilerInfoUnk)

#define ICorProfilerCallback_Shutdown(This)	\
    (This)->lpVtbl -> Shutdown(This)

#define ICorProfilerCallback_AppDomainCreationStarted(This,appDomainId)	\
    (This)->lpVtbl -> AppDomainCreationStarted(This,appDomainId)

#define ICorProfilerCallback_AppDomainCreationFinished(This,appDomainId,hrStatus)	\
    (This)->lpVtbl -> AppDomainCreationFinished(This,appDomainId,hrStatus)

#define ICorProfilerCallback_AppDomainShutdownStarted(This,appDomainId)	\
    (This)->lpVtbl -> AppDomainShutdownStarted(This,appDomainId)

#define ICorProfilerCallback_AppDomainShutdownFinished(This,appDomainId,hrStatus)	\
    (This)->lpVtbl -> AppDomainShutdownFinished(This,appDomainId,hrStatus)

#define ICorProfilerCallback_AssemblyLoadStarted(This,assemblyId)	\
    (This)->lpVtbl -> AssemblyLoadStarted(This,assemblyId)

#define ICorProfilerCallback_AssemblyLoadFinished(This,assemblyId,hrStatus)	\
    (This)->lpVtbl -> AssemblyLoadFinished(This,assemblyId,hrStatus)

#define ICorProfilerCallback_AssemblyUnloadStarted(This,assemblyId)	\
    (This)->lpVtbl -> AssemblyUnloadStarted(This,assemblyId)

#define ICorProfilerCallback_AssemblyUnloadFinished(This,assemblyId,hrStatus)	\
    (This)->lpVtbl -> AssemblyUnloadFinished(This,assemblyId,hrStatus)

#define ICorProfilerCallback_ModuleLoadStarted(This,moduleId)	\
    (This)->lpVtbl -> ModuleLoadStarted(This,moduleId)

#define ICorProfilerCallback_ModuleLoadFinished(This,moduleId,hrStatus)	\
    (This)->lpVtbl -> ModuleLoadFinished(This,moduleId,hrStatus)

#define ICorProfilerCallback_ModuleUnloadStarted(This,moduleId)	\
    (This)->lpVtbl -> ModuleUnloadStarted(This,moduleId)

#define ICorProfilerCallback_ModuleUnloadFinished(This,moduleId,hrStatus)	\
    (This)->lpVtbl -> ModuleUnloadFinished(This,moduleId,hrStatus)

#define ICorProfilerCallback_ModuleAttachedToAssembly(This,moduleId,AssemblyId)	\
    (This)->lpVtbl -> ModuleAttachedToAssembly(This,moduleId,AssemblyId)

#define ICorProfilerCallback_ClassLoadStarted(This,classId)	\
    (This)->lpVtbl -> ClassLoadStarted(This,classId)

#define ICorProfilerCallback_ClassLoadFinished(This,classId,hrStatus)	\
    (This)->lpVtbl -> ClassLoadFinished(This,classId,hrStatus)

#define ICorProfilerCallback_ClassUnloadStarted(This,classId)	\
    (This)->lpVtbl -> ClassUnloadStarted(This,classId)

#define ICorProfilerCallback_ClassUnloadFinished(This,classId,hrStatus)	\
    (This)->lpVtbl -> ClassUnloadFinished(This,classId,hrStatus)

#define ICorProfilerCallback_FunctionUnloadStarted(This,functionId)	\
    (This)->lpVtbl -> FunctionUnloadStarted(This,functionId)

#define ICorProfilerCallback_JITCompilationStarted(This,functionId,fIsSafeToBlock)	\
    (This)->lpVtbl -> JITCompilationStarted(This,functionId,fIsSafeToBlock)

#define ICorProfilerCallback_JITCompilationFinished(This,functionId,hrStatus,fIsSafeToBlock)	\
    (This)->lpVtbl -> JITCompilationFinished(This,functionId,hrStatus,fIsSafeToBlock)

#define ICorProfilerCallback_JITCachedFunctionSearchStarted(This,functionId,pbUseCachedFunction)	\
    (This)->lpVtbl -> JITCachedFunctionSearchStarted(This,functionId,pbUseCachedFunction)

#define ICorProfilerCallback_JITCachedFunctionSearchFinished(This,functionId,result)	\
    (This)->lpVtbl -> JITCachedFunctionSearchFinished(This,functionId,result)

#define ICorProfilerCallback_JITFunctionPitched(This,functionId)	\
    (This)->lpVtbl -> JITFunctionPitched(This,functionId)

#define ICorProfilerCallback_JITInlining(This,callerId,calleeId,pfShouldInline)	\
    (This)->lpVtbl -> JITInlining(This,callerId,calleeId,pfShouldInline)

#define ICorProfilerCallback_ThreadCreated(This,threadId)	\
    (This)->lpVtbl -> ThreadCreated(This,threadId)

#define ICorProfilerCallback_ThreadDestroyed(This,threadId)	\
    (This)->lpVtbl -> ThreadDestroyed(This,threadId)

#define ICorProfilerCallback_ThreadAssignedToOSThread(This,managedThreadId,osThreadId)	\
    (This)->lpVtbl -> ThreadAssignedToOSThread(This,managedThreadId,osThreadId)

#define ICorProfilerCallback_RemotingClientInvocationStarted(This)	\
    (This)->lpVtbl -> RemotingClientInvocationStarted(This)

#define ICorProfilerCallback_RemotingClientSendingMessage(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingClientSendingMessage(This,pCookie,fIsAsync)

#define ICorProfilerCallback_RemotingClientReceivingReply(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingClientReceivingReply(This,pCookie,fIsAsync)

#define ICorProfilerCallback_RemotingClientInvocationFinished(This)	\
    (This)->lpVtbl -> RemotingClientInvocationFinished(This)

#define ICorProfilerCallback_RemotingServerReceivingMessage(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingServerReceivingMessage(This,pCookie,fIsAsync)

#define ICorProfilerCallback_RemotingServerInvocationStarted(This)	\
    (This)->lpVtbl -> RemotingServerInvocationStarted(This)

#define ICorProfilerCallback_RemotingServerInvocationReturned(This)	\
    (This)->lpVtbl -> RemotingServerInvocationReturned(This)

#define ICorProfilerCallback_RemotingServerSendingReply(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingServerSendingReply(This,pCookie,fIsAsync)

#define ICorProfilerCallback_UnmanagedToManagedTransition(This,functionId,reason)	\
    (This)->lpVtbl -> UnmanagedToManagedTransition(This,functionId,reason)

#define ICorProfilerCallback_ManagedToUnmanagedTransition(This,functionId,reason)	\
    (This)->lpVtbl -> ManagedToUnmanagedTransition(This,functionId,reason)

#define ICorProfilerCallback_RuntimeSuspendStarted(This,suspendReason)	\
    (This)->lpVtbl -> RuntimeSuspendStarted(This,suspendReason)

#define ICorProfilerCallback_RuntimeSuspendFinished(This)	\
    (This)->lpVtbl -> RuntimeSuspendFinished(This)

#define ICorProfilerCallback_RuntimeSuspendAborted(This)	\
    (This)->lpVtbl -> RuntimeSuspendAborted(This)

#define ICorProfilerCallback_RuntimeResumeStarted(This)	\
    (This)->lpVtbl -> RuntimeResumeStarted(This)

#define ICorProfilerCallback_RuntimeResumeFinished(This)	\
    (This)->lpVtbl -> RuntimeResumeFinished(This)

#define ICorProfilerCallback_RuntimeThreadSuspended(This,threadId)	\
    (This)->lpVtbl -> RuntimeThreadSuspended(This,threadId)

#define ICorProfilerCallback_RuntimeThreadResumed(This,threadId)	\
    (This)->lpVtbl -> RuntimeThreadResumed(This,threadId)

#define ICorProfilerCallback_MovedReferences(This,cMovedObjectIDRanges,oldObjectIDRangeStart,newObjectIDRangeStart,cObjectIDRangeLength)	\
    (This)->lpVtbl -> MovedReferences(This,cMovedObjectIDRanges,oldObjectIDRangeStart,newObjectIDRangeStart,cObjectIDRangeLength)

#define ICorProfilerCallback_ObjectAllocated(This,objectId,classId)	\
    (This)->lpVtbl -> ObjectAllocated(This,objectId,classId)

#define ICorProfilerCallback_ObjectsAllocatedByClass(This,cClassCount,classIds,cObjects)	\
    (This)->lpVtbl -> ObjectsAllocatedByClass(This,cClassCount,classIds,cObjects)

#define ICorProfilerCallback_ObjectReferences(This,objectId,classId,cObjectRefs,objectRefIds)	\
    (This)->lpVtbl -> ObjectReferences(This,objectId,classId,cObjectRefs,objectRefIds)

#define ICorProfilerCallback_RootReferences(This,cRootRefs,rootRefIds)	\
    (This)->lpVtbl -> RootReferences(This,cRootRefs,rootRefIds)

#define ICorProfilerCallback_ExceptionThrown(This,thrownObjectId)	\
    (This)->lpVtbl -> ExceptionThrown(This,thrownObjectId)

#define ICorProfilerCallback_ExceptionSearchFunctionEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchFunctionEnter(This,functionId)

#define ICorProfilerCallback_ExceptionSearchFunctionLeave(This)	\
    (This)->lpVtbl -> ExceptionSearchFunctionLeave(This)

#define ICorProfilerCallback_ExceptionSearchFilterEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchFilterEnter(This,functionId)

#define ICorProfilerCallback_ExceptionSearchFilterLeave(This)	\
    (This)->lpVtbl -> ExceptionSearchFilterLeave(This)

#define ICorProfilerCallback_ExceptionSearchCatcherFound(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchCatcherFound(This,functionId)

#define ICorProfilerCallback_ExceptionOSHandlerEnter(This,__unused)	\
    (This)->lpVtbl -> ExceptionOSHandlerEnter(This,__unused)

#define ICorProfilerCallback_ExceptionOSHandlerLeave(This,__unused)	\
    (This)->lpVtbl -> ExceptionOSHandlerLeave(This,__unused)

#define ICorProfilerCallback_ExceptionUnwindFunctionEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionUnwindFunctionEnter(This,functionId)

#define ICorProfilerCallback_ExceptionUnwindFunctionLeave(This)	\
    (This)->lpVtbl -> ExceptionUnwindFunctionLeave(This)

#define ICorProfilerCallback_ExceptionUnwindFinallyEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionUnwindFinallyEnter(This,functionId)

#define ICorProfilerCallback_ExceptionUnwindFinallyLeave(This)	\
    (This)->lpVtbl -> ExceptionUnwindFinallyLeave(This)

#define ICorProfilerCallback_ExceptionCatcherEnter(This,functionId,objectId)	\
    (This)->lpVtbl -> ExceptionCatcherEnter(This,functionId,objectId)

#define ICorProfilerCallback_ExceptionCatcherLeave(This)	\
    (This)->lpVtbl -> ExceptionCatcherLeave(This)

#define ICorProfilerCallback_COMClassicVTableCreated(This,wrappedClassId,implementedIID,pVTable,cSlots)	\
    (This)->lpVtbl -> COMClassicVTableCreated(This,wrappedClassId,implementedIID,pVTable,cSlots)

#define ICorProfilerCallback_COMClassicVTableDestroyed(This,wrappedClassId,implementedIID,pVTable)	\
    (This)->lpVtbl -> COMClassicVTableDestroyed(This,wrappedClassId,implementedIID,pVTable)

#define ICorProfilerCallback_ExceptionCLRCatcherFound(This)	\
    (This)->lpVtbl -> ExceptionCLRCatcherFound(This)

#define ICorProfilerCallback_ExceptionCLRCatcherExecute(This)	\
    (This)->lpVtbl -> ExceptionCLRCatcherExecute(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorProfilerCallback_Initialize_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ IUnknown *pICorProfilerInfoUnk);


void __RPC_STUB ICorProfilerCallback_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_Shutdown_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainCreationStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId);


void __RPC_STUB ICorProfilerCallback_AppDomainCreationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainCreationFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AppDomainCreationFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainShutdownStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId);


void __RPC_STUB ICorProfilerCallback_AppDomainShutdownStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainShutdownFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AppDomainShutdownFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyLoadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId);


void __RPC_STUB ICorProfilerCallback_AssemblyLoadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyLoadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AssemblyLoadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId);


void __RPC_STUB ICorProfilerCallback_AssemblyUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyUnloadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AssemblyUnloadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleLoadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId);


void __RPC_STUB ICorProfilerCallback_ModuleLoadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleLoadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ModuleLoadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId);


void __RPC_STUB ICorProfilerCallback_ModuleUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleUnloadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ModuleUnloadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleAttachedToAssembly_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ AssemblyID AssemblyId);


void __RPC_STUB ICorProfilerCallback_ModuleAttachedToAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassLoadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId);


void __RPC_STUB ICorProfilerCallback_ClassLoadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassLoadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ClassLoadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId);


void __RPC_STUB ICorProfilerCallback_ClassUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassUnloadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ClassUnloadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_FunctionUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_FunctionUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCompilationStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ BOOL fIsSafeToBlock);


void __RPC_STUB ICorProfilerCallback_JITCompilationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCompilationFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ HRESULT hrStatus,
    /* [in] */ BOOL fIsSafeToBlock);


void __RPC_STUB ICorProfilerCallback_JITCompilationFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCachedFunctionSearchStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [out] */ BOOL *pbUseCachedFunction);


void __RPC_STUB ICorProfilerCallback_JITCachedFunctionSearchStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCachedFunctionSearchFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ COR_PRF_JIT_CACHE result);


void __RPC_STUB ICorProfilerCallback_JITCachedFunctionSearchFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITFunctionPitched_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_JITFunctionPitched_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITInlining_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID callerId,
    /* [in] */ FunctionID calleeId,
    /* [out] */ BOOL *pfShouldInline);


void __RPC_STUB ICorProfilerCallback_JITInlining_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ThreadCreated_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_ThreadCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ThreadDestroyed_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_ThreadDestroyed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ThreadAssignedToOSThread_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID managedThreadId,
    /* [in] */ DWORD osThreadId);


void __RPC_STUB ICorProfilerCallback_ThreadAssignedToOSThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientInvocationStarted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingClientInvocationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientSendingMessage_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingClientSendingMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientReceivingReply_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingClientReceivingReply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientInvocationFinished_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingClientInvocationFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerReceivingMessage_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingServerReceivingMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerInvocationStarted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingServerInvocationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerInvocationReturned_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingServerInvocationReturned_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerSendingReply_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingServerSendingReply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_UnmanagedToManagedTransition_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ COR_PRF_TRANSITION_REASON reason);


void __RPC_STUB ICorProfilerCallback_UnmanagedToManagedTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ManagedToUnmanagedTransition_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ COR_PRF_TRANSITION_REASON reason);


void __RPC_STUB ICorProfilerCallback_ManagedToUnmanagedTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeSuspendStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ COR_PRF_SUSPEND_REASON suspendReason);


void __RPC_STUB ICorProfilerCallback_RuntimeSuspendStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeSuspendFinished_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeSuspendFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeSuspendAborted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeSuspendAborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeResumeStarted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeResumeStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeResumeFinished_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeResumeFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeThreadSuspended_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_RuntimeThreadSuspended_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeThreadResumed_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_RuntimeThreadResumed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_MovedReferences_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ULONG cMovedObjectIDRanges,
    /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
    /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
    /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);


void __RPC_STUB ICorProfilerCallback_MovedReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ObjectAllocated_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ObjectID objectId,
    /* [in] */ ClassID classId);


void __RPC_STUB ICorProfilerCallback_ObjectAllocated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ObjectsAllocatedByClass_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ULONG cClassCount,
    /* [size_is][in] */ ClassID classIds[  ],
    /* [size_is][in] */ ULONG cObjects[  ]);


void __RPC_STUB ICorProfilerCallback_ObjectsAllocatedByClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ObjectReferences_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ObjectID objectId,
    /* [in] */ ClassID classId,
    /* [in] */ ULONG cObjectRefs,
    /* [size_is][in] */ ObjectID objectRefIds[  ]);


void __RPC_STUB ICorProfilerCallback_ObjectReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RootReferences_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ULONG cRootRefs,
    /* [size_is][in] */ ObjectID rootRefIds[  ]);


void __RPC_STUB ICorProfilerCallback_RootReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionThrown_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ObjectID thrownObjectId);


void __RPC_STUB ICorProfilerCallback_ExceptionThrown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFunctionEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFunctionEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFunctionLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFunctionLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFilterEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFilterEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFilterLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFilterLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchCatcherFound_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchCatcherFound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionOSHandlerEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ UINT_PTR __unused);


void __RPC_STUB ICorProfilerCallback_ExceptionOSHandlerEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionOSHandlerLeave_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ UINT_PTR __unused);


void __RPC_STUB ICorProfilerCallback_ExceptionOSHandlerLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFunctionEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFunctionEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFunctionLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFunctionLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFinallyEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFinallyEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFinallyLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFinallyLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCatcherEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ ObjectID objectId);


void __RPC_STUB ICorProfilerCallback_ExceptionCatcherEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCatcherLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionCatcherLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_COMClassicVTableCreated_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID wrappedClassId,
    /* [in] */ REFGUID implementedIID,
    /* [in] */ void *pVTable,
    /* [in] */ ULONG cSlots);


void __RPC_STUB ICorProfilerCallback_COMClassicVTableCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_COMClassicVTableDestroyed_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID wrappedClassId,
    /* [in] */ REFGUID implementedIID,
    /* [in] */ void *pVTable);


void __RPC_STUB ICorProfilerCallback_COMClassicVTableDestroyed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCLRCatcherFound_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionCLRCatcherFound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCLRCatcherExecute_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionCLRCatcherExecute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorProfilerCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_corprof_0011 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0001
    {	COR_PRF_GC_ROOT_STACK	= 1,
	COR_PRF_GC_ROOT_FINALIZER	= 2,
	COR_PRF_GC_ROOT_HANDLE	= 3,
	COR_PRF_GC_ROOT_OTHER	= 0
    } 	COR_PRF_GC_ROOT_KIND;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0002
    {	COR_PRF_GC_ROOT_PINNING	= 0x1,
	COR_PRF_GC_ROOT_WEAKREF	= 0x2,
	COR_PRF_GC_ROOT_INTERIOR	= 0x4,
	COR_PRF_GC_ROOT_REFCOUNTED	= 0x8
    } 	COR_PRF_GC_ROOT_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0003
    {	COR_PRF_FINALIZER_CRITICAL	= 0x1
    } 	COR_PRF_FINALIZER_FLAGS;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0004
    {	COR_PRF_GC_GEN_0	= 0,
	COR_PRF_GC_GEN_1	= 1,
	COR_PRF_GC_GEN_2	= 2,
	COR_PRF_GC_LARGE_OBJECT_HEAP	= 3
    } 	COR_PRF_GC_GENERATION;

typedef struct COR_PRF_GC_GENERATION_RANGE
    {
    COR_PRF_GC_GENERATION generation;
    ObjectID rangeStart;
    UINT_PTR rangeLength;
    UINT_PTR rangeLengthReserved;
    } 	COR_PRF_GC_GENERATION_RANGE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0005
    {	COR_PRF_CLAUSE_NONE	= 0,
	COR_PRF_CLAUSE_FILTER	= 1,
	COR_PRF_CLAUSE_CATCH	= 2,
	COR_PRF_CLAUSE_FINALLY	= 3
    } 	COR_PRF_CLAUSE_TYPE;

typedef struct COR_PRF_EX_CLAUSE_INFO
    {
    COR_PRF_CLAUSE_TYPE clauseType;
    UINT_PTR programCounter;
    UINT_PTR framePointer;
    UINT_PTR shadowStackPointer;
    } 	COR_PRF_EX_CLAUSE_INFO;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0006
    {	COR_PRF_GC_INDUCED	= 1,
	COR_PRF_GC_OTHER	= 0
    } 	COR_PRF_GC_REASON;



extern RPC_IF_HANDLE __MIDL_itf_corprof_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corprof_0011_v0_0_s_ifspec;

#ifndef __ICorProfilerCallback2_INTERFACE_DEFINED__
#define __ICorProfilerCallback2_INTERFACE_DEFINED__

/* interface ICorProfilerCallback2 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerCallback2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A8CC829-CCF2-49fe-BBAE-0F022228071A")
    ICorProfilerCallback2 : public ICorProfilerCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadNameChanged( 
            /* [in] */ ThreadID threadId,
            /* [in] */ ULONG cchName,
            /* [in] */ WCHAR name[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GarbageCollectionStarted( 
            /* [in] */ int cGenerations,
            /* [length_is][size_is][in] */ BOOL generationCollected[  ],
            /* [in] */ COR_PRF_GC_REASON reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SurvivingReferences( 
            /* [in] */ ULONG cSurvivingObjectIDRanges,
            /* [size_is][in] */ ObjectID objectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GarbageCollectionFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinalizeableObjectQueued( 
            /* [in] */ DWORD finalizerFlags,
            /* [in] */ ObjectID objectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RootReferences2( 
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ],
            /* [size_is][in] */ COR_PRF_GC_ROOT_KIND rootKinds[  ],
            /* [size_is][in] */ COR_PRF_GC_ROOT_FLAGS rootFlags[  ],
            /* [size_is][in] */ UINT_PTR rootIds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleCreated( 
            /* [in] */ GCHandleID handleId,
            /* [in] */ ObjectID initialObjectId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleDestroyed( 
            /* [in] */ GCHandleID handleId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerCallback2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerCallback2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerCallback2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICorProfilerCallback2 * This,
            /* [in] */ IUnknown *pICorProfilerInfoUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainCreationStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AppDomainID appDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainCreationFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainShutdownStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AppDomainID appDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainShutdownFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyLoadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AssemblyID assemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyLoadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyUnloadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AssemblyID assemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyUnloadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleLoadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ModuleID moduleId);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleLoadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleUnloadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ModuleID moduleId);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleUnloadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleAttachedToAssembly )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ AssemblyID AssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassLoadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassLoadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ClassUnloadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassUnloadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *FunctionUnloadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *JITCompilationStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fIsSafeToBlock);
        
        HRESULT ( STDMETHODCALLTYPE *JITCompilationFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ BOOL fIsSafeToBlock);
        
        HRESULT ( STDMETHODCALLTYPE *JITCachedFunctionSearchStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ BOOL *pbUseCachedFunction);
        
        HRESULT ( STDMETHODCALLTYPE *JITCachedFunctionSearchFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_JIT_CACHE result);
        
        HRESULT ( STDMETHODCALLTYPE *JITFunctionPitched )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *JITInlining )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID callerId,
            /* [in] */ FunctionID calleeId,
            /* [out] */ BOOL *pfShouldInline);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadCreated )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadDestroyed )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadAssignedToOSThread )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID managedThreadId,
            /* [in] */ DWORD osThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientInvocationStarted )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientSendingMessage )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientReceivingReply )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientInvocationFinished )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerReceivingMessage )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerInvocationStarted )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerInvocationReturned )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerSendingReply )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *UnmanagedToManagedTransition )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *ManagedToUnmanagedTransition )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ COR_PRF_SUSPEND_REASON suspendReason);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendFinished )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendAborted )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeResumeStarted )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeResumeFinished )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeThreadSuspended )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeThreadResumed )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *MovedReferences )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ULONG cMovedObjectIDRanges,
            /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
            /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectAllocated )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectsAllocatedByClass )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ULONG cClassCount,
            /* [size_is][in] */ ClassID classIds[  ],
            /* [size_is][in] */ ULONG cObjects[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectReferences )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG cObjectRefs,
            /* [size_is][in] */ ObjectID objectRefIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RootReferences )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionThrown )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ObjectID thrownObjectId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFunctionEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFunctionLeave )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFilterEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFilterLeave )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchCatcherFound )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionOSHandlerEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ UINT_PTR __unused);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionOSHandlerLeave )( 
            ICorProfilerCallback2 * This,
            /* [in] */ UINT_PTR __unused);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFunctionEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFunctionLeave )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFinallyEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFinallyLeave )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCatcherEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ ObjectID objectId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCatcherLeave )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *COMClassicVTableCreated )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable,
            /* [in] */ ULONG cSlots);
        
        HRESULT ( STDMETHODCALLTYPE *COMClassicVTableDestroyed )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCLRCatcherFound )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCLRCatcherExecute )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadNameChanged )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID threadId,
            /* [in] */ ULONG cchName,
            /* [in] */ WCHAR name[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GarbageCollectionStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ int cGenerations,
            /* [length_is][size_is][in] */ BOOL generationCollected[  ],
            /* [in] */ COR_PRF_GC_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *SurvivingReferences )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ULONG cSurvivingObjectIDRanges,
            /* [size_is][in] */ ObjectID objectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GarbageCollectionFinished )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *FinalizeableObjectQueued )( 
            ICorProfilerCallback2 * This,
            /* [in] */ DWORD finalizerFlags,
            /* [in] */ ObjectID objectID);
        
        HRESULT ( STDMETHODCALLTYPE *RootReferences2 )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ],
            /* [size_is][in] */ COR_PRF_GC_ROOT_KIND rootKinds[  ],
            /* [size_is][in] */ COR_PRF_GC_ROOT_FLAGS rootFlags[  ],
            /* [size_is][in] */ UINT_PTR rootIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *HandleCreated )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GCHandleID handleId,
            /* [in] */ ObjectID initialObjectId);
        
        HRESULT ( STDMETHODCALLTYPE *HandleDestroyed )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GCHandleID handleId);
        
        END_INTERFACE
    } ICorProfilerCallback2Vtbl;

    interface ICorProfilerCallback2
    {
        CONST_VTBL struct ICorProfilerCallback2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorProfilerCallback2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorProfilerCallback2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorProfilerCallback2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorProfilerCallback2_Initialize(This,pICorProfilerInfoUnk)	\
    (This)->lpVtbl -> Initialize(This,pICorProfilerInfoUnk)

#define ICorProfilerCallback2_Shutdown(This)	\
    (This)->lpVtbl -> Shutdown(This)

#define ICorProfilerCallback2_AppDomainCreationStarted(This,appDomainId)	\
    (This)->lpVtbl -> AppDomainCreationStarted(This,appDomainId)

#define ICorProfilerCallback2_AppDomainCreationFinished(This,appDomainId,hrStatus)	\
    (This)->lpVtbl -> AppDomainCreationFinished(This,appDomainId,hrStatus)

#define ICorProfilerCallback2_AppDomainShutdownStarted(This,appDomainId)	\
    (This)->lpVtbl -> AppDomainShutdownStarted(This,appDomainId)

#define ICorProfilerCallback2_AppDomainShutdownFinished(This,appDomainId,hrStatus)	\
    (This)->lpVtbl -> AppDomainShutdownFinished(This,appDomainId,hrStatus)

#define ICorProfilerCallback2_AssemblyLoadStarted(This,assemblyId)	\
    (This)->lpVtbl -> AssemblyLoadStarted(This,assemblyId)

#define ICorProfilerCallback2_AssemblyLoadFinished(This,assemblyId,hrStatus)	\
    (This)->lpVtbl -> AssemblyLoadFinished(This,assemblyId,hrStatus)

#define ICorProfilerCallback2_AssemblyUnloadStarted(This,assemblyId)	\
    (This)->lpVtbl -> AssemblyUnloadStarted(This,assemblyId)

#define ICorProfilerCallback2_AssemblyUnloadFinished(This,assemblyId,hrStatus)	\
    (This)->lpVtbl -> AssemblyUnloadFinished(This,assemblyId,hrStatus)

#define ICorProfilerCallback2_ModuleLoadStarted(This,moduleId)	\
    (This)->lpVtbl -> ModuleLoadStarted(This,moduleId)

#define ICorProfilerCallback2_ModuleLoadFinished(This,moduleId,hrStatus)	\
    (This)->lpVtbl -> ModuleLoadFinished(This,moduleId,hrStatus)

#define ICorProfilerCallback2_ModuleUnloadStarted(This,moduleId)	\
    (This)->lpVtbl -> ModuleUnloadStarted(This,moduleId)

#define ICorProfilerCallback2_ModuleUnloadFinished(This,moduleId,hrStatus)	\
    (This)->lpVtbl -> ModuleUnloadFinished(This,moduleId,hrStatus)

#define ICorProfilerCallback2_ModuleAttachedToAssembly(This,moduleId,AssemblyId)	\
    (This)->lpVtbl -> ModuleAttachedToAssembly(This,moduleId,AssemblyId)

#define ICorProfilerCallback2_ClassLoadStarted(This,classId)	\
    (This)->lpVtbl -> ClassLoadStarted(This,classId)

#define ICorProfilerCallback2_ClassLoadFinished(This,classId,hrStatus)	\
    (This)->lpVtbl -> ClassLoadFinished(This,classId,hrStatus)

#define ICorProfilerCallback2_ClassUnloadStarted(This,classId)	\
    (This)->lpVtbl -> ClassUnloadStarted(This,classId)

#define ICorProfilerCallback2_ClassUnloadFinished(This,classId,hrStatus)	\
    (This)->lpVtbl -> ClassUnloadFinished(This,classId,hrStatus)

#define ICorProfilerCallback2_FunctionUnloadStarted(This,functionId)	\
    (This)->lpVtbl -> FunctionUnloadStarted(This,functionId)

#define ICorProfilerCallback2_JITCompilationStarted(This,functionId,fIsSafeToBlock)	\
    (This)->lpVtbl -> JITCompilationStarted(This,functionId,fIsSafeToBlock)

#define ICorProfilerCallback2_JITCompilationFinished(This,functionId,hrStatus,fIsSafeToBlock)	\
    (This)->lpVtbl -> JITCompilationFinished(This,functionId,hrStatus,fIsSafeToBlock)

#define ICorProfilerCallback2_JITCachedFunctionSearchStarted(This,functionId,pbUseCachedFunction)	\
    (This)->lpVtbl -> JITCachedFunctionSearchStarted(This,functionId,pbUseCachedFunction)

#define ICorProfilerCallback2_JITCachedFunctionSearchFinished(This,functionId,result)	\
    (This)->lpVtbl -> JITCachedFunctionSearchFinished(This,functionId,result)

#define ICorProfilerCallback2_JITFunctionPitched(This,functionId)	\
    (This)->lpVtbl -> JITFunctionPitched(This,functionId)

#define ICorProfilerCallback2_JITInlining(This,callerId,calleeId,pfShouldInline)	\
    (This)->lpVtbl -> JITInlining(This,callerId,calleeId,pfShouldInline)

#define ICorProfilerCallback2_ThreadCreated(This,threadId)	\
    (This)->lpVtbl -> ThreadCreated(This,threadId)

#define ICorProfilerCallback2_ThreadDestroyed(This,threadId)	\
    (This)->lpVtbl -> ThreadDestroyed(This,threadId)

#define ICorProfilerCallback2_ThreadAssignedToOSThread(This,managedThreadId,osThreadId)	\
    (This)->lpVtbl -> ThreadAssignedToOSThread(This,managedThreadId,osThreadId)

#define ICorProfilerCallback2_RemotingClientInvocationStarted(This)	\
    (This)->lpVtbl -> RemotingClientInvocationStarted(This)

#define ICorProfilerCallback2_RemotingClientSendingMessage(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingClientSendingMessage(This,pCookie,fIsAsync)

#define ICorProfilerCallback2_RemotingClientReceivingReply(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingClientReceivingReply(This,pCookie,fIsAsync)

#define ICorProfilerCallback2_RemotingClientInvocationFinished(This)	\
    (This)->lpVtbl -> RemotingClientInvocationFinished(This)

#define ICorProfilerCallback2_RemotingServerReceivingMessage(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingServerReceivingMessage(This,pCookie,fIsAsync)

#define ICorProfilerCallback2_RemotingServerInvocationStarted(This)	\
    (This)->lpVtbl -> RemotingServerInvocationStarted(This)

#define ICorProfilerCallback2_RemotingServerInvocationReturned(This)	\
    (This)->lpVtbl -> RemotingServerInvocationReturned(This)

#define ICorProfilerCallback2_RemotingServerSendingReply(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingServerSendingReply(This,pCookie,fIsAsync)

#define ICorProfilerCallback2_UnmanagedToManagedTransition(This,functionId,reason)	\
    (This)->lpVtbl -> UnmanagedToManagedTransition(This,functionId,reason)

#define ICorProfilerCallback2_ManagedToUnmanagedTransition(This,functionId,reason)	\
    (This)->lpVtbl -> ManagedToUnmanagedTransition(This,functionId,reason)

#define ICorProfilerCallback2_RuntimeSuspendStarted(This,suspendReason)	\
    (This)->lpVtbl -> RuntimeSuspendStarted(This,suspendReason)

#define ICorProfilerCallback2_RuntimeSuspendFinished(This)	\
    (This)->lpVtbl -> RuntimeSuspendFinished(This)

#define ICorProfilerCallback2_RuntimeSuspendAborted(This)	\
    (This)->lpVtbl -> RuntimeSuspendAborted(This)

#define ICorProfilerCallback2_RuntimeResumeStarted(This)	\
    (This)->lpVtbl -> RuntimeResumeStarted(This)

#define ICorProfilerCallback2_RuntimeResumeFinished(This)	\
    (This)->lpVtbl -> RuntimeResumeFinished(This)

#define ICorProfilerCallback2_RuntimeThreadSuspended(This,threadId)	\
    (This)->lpVtbl -> RuntimeThreadSuspended(This,threadId)

#define ICorProfilerCallback2_RuntimeThreadResumed(This,threadId)	\
    (This)->lpVtbl -> RuntimeThreadResumed(This,threadId)

#define ICorProfilerCallback2_MovedReferences(This,cMovedObjectIDRanges,oldObjectIDRangeStart,newObjectIDRangeStart,cObjectIDRangeLength)	\
    (This)->lpVtbl -> MovedReferences(This,cMovedObjectIDRanges,oldObjectIDRangeStart,newObjectIDRangeStart,cObjectIDRangeLength)

#define ICorProfilerCallback2_ObjectAllocated(This,objectId,classId)	\
    (This)->lpVtbl -> ObjectAllocated(This,objectId,classId)

#define ICorProfilerCallback2_ObjectsAllocatedByClass(This,cClassCount,classIds,cObjects)	\
    (This)->lpVtbl -> ObjectsAllocatedByClass(This,cClassCount,classIds,cObjects)

#define ICorProfilerCallback2_ObjectReferences(This,objectId,classId,cObjectRefs,objectRefIds)	\
    (This)->lpVtbl -> ObjectReferences(This,objectId,classId,cObjectRefs,objectRefIds)

#define ICorProfilerCallback2_RootReferences(This,cRootRefs,rootRefIds)	\
    (This)->lpVtbl -> RootReferences(This,cRootRefs,rootRefIds)

#define ICorProfilerCallback2_ExceptionThrown(This,thrownObjectId)	\
    (This)->lpVtbl -> ExceptionThrown(This,thrownObjectId)

#define ICorProfilerCallback2_ExceptionSearchFunctionEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchFunctionEnter(This,functionId)

#define ICorProfilerCallback2_ExceptionSearchFunctionLeave(This)	\
    (This)->lpVtbl -> ExceptionSearchFunctionLeave(This)

#define ICorProfilerCallback2_ExceptionSearchFilterEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchFilterEnter(This,functionId)

#define ICorProfilerCallback2_ExceptionSearchFilterLeave(This)	\
    (This)->lpVtbl -> ExceptionSearchFilterLeave(This)

#define ICorProfilerCallback2_ExceptionSearchCatcherFound(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchCatcherFound(This,functionId)

#define ICorProfilerCallback2_ExceptionOSHandlerEnter(This,__unused)	\
    (This)->lpVtbl -> ExceptionOSHandlerEnter(This,__unused)

#define ICorProfilerCallback2_ExceptionOSHandlerLeave(This,__unused)	\
    (This)->lpVtbl -> ExceptionOSHandlerLeave(This,__unused)

#define ICorProfilerCallback2_ExceptionUnwindFunctionEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionUnwindFunctionEnter(This,functionId)

#define ICorProfilerCallback2_ExceptionUnwindFunctionLeave(This)	\
    (This)->lpVtbl -> ExceptionUnwindFunctionLeave(This)

#define ICorProfilerCallback2_ExceptionUnwindFinallyEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionUnwindFinallyEnter(This,functionId)

#define ICorProfilerCallback2_ExceptionUnwindFinallyLeave(This)	\
    (This)->lpVtbl -> ExceptionUnwindFinallyLeave(This)

#define ICorProfilerCallback2_ExceptionCatcherEnter(This,functionId,objectId)	\
    (This)->lpVtbl -> ExceptionCatcherEnter(This,functionId,objectId)

#define ICorProfilerCallback2_ExceptionCatcherLeave(This)	\
    (This)->lpVtbl -> ExceptionCatcherLeave(This)

#define ICorProfilerCallback2_COMClassicVTableCreated(This,wrappedClassId,implementedIID,pVTable,cSlots)	\
    (This)->lpVtbl -> COMClassicVTableCreated(This,wrappedClassId,implementedIID,pVTable,cSlots)

#define ICorProfilerCallback2_COMClassicVTableDestroyed(This,wrappedClassId,implementedIID,pVTable)	\
    (This)->lpVtbl -> COMClassicVTableDestroyed(This,wrappedClassId,implementedIID,pVTable)

#define ICorProfilerCallback2_ExceptionCLRCatcherFound(This)	\
    (This)->lpVtbl -> ExceptionCLRCatcherFound(This)

#define ICorProfilerCallback2_ExceptionCLRCatcherExecute(This)	\
    (This)->lpVtbl -> ExceptionCLRCatcherExecute(This)


#define ICorProfilerCallback2_ThreadNameChanged(This,threadId,cchName,name)	\
    (This)->lpVtbl -> ThreadNameChanged(This,threadId,cchName,name)

#define ICorProfilerCallback2_GarbageCollectionStarted(This,cGenerations,generationCollected,reason)	\
    (This)->lpVtbl -> GarbageCollectionStarted(This,cGenerations,generationCollected,reason)

#define ICorProfilerCallback2_SurvivingReferences(This,cSurvivingObjectIDRanges,objectIDRangeStart,cObjectIDRangeLength)	\
    (This)->lpVtbl -> SurvivingReferences(This,cSurvivingObjectIDRanges,objectIDRangeStart,cObjectIDRangeLength)

#define ICorProfilerCallback2_GarbageCollectionFinished(This)	\
    (This)->lpVtbl -> GarbageCollectionFinished(This)

#define ICorProfilerCallback2_FinalizeableObjectQueued(This,finalizerFlags,objectID)	\
    (This)->lpVtbl -> FinalizeableObjectQueued(This,finalizerFlags,objectID)

#define ICorProfilerCallback2_RootReferences2(This,cRootRefs,rootRefIds,rootKinds,rootFlags,rootIds)	\
    (This)->lpVtbl -> RootReferences2(This,cRootRefs,rootRefIds,rootKinds,rootFlags,rootIds)

#define ICorProfilerCallback2_HandleCreated(This,handleId,initialObjectId)	\
    (This)->lpVtbl -> HandleCreated(This,handleId,initialObjectId)

#define ICorProfilerCallback2_HandleDestroyed(This,handleId)	\
    (This)->lpVtbl -> HandleDestroyed(This,handleId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_ThreadNameChanged_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ ThreadID threadId,
    /* [in] */ ULONG cchName,
    /* [in] */ WCHAR name[  ]);


void __RPC_STUB ICorProfilerCallback2_ThreadNameChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_GarbageCollectionStarted_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ int cGenerations,
    /* [length_is][size_is][in] */ BOOL generationCollected[  ],
    /* [in] */ COR_PRF_GC_REASON reason);


void __RPC_STUB ICorProfilerCallback2_GarbageCollectionStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_SurvivingReferences_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ ULONG cSurvivingObjectIDRanges,
    /* [size_is][in] */ ObjectID objectIDRangeStart[  ],
    /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);


void __RPC_STUB ICorProfilerCallback2_SurvivingReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_GarbageCollectionFinished_Proxy( 
    ICorProfilerCallback2 * This);


void __RPC_STUB ICorProfilerCallback2_GarbageCollectionFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_FinalizeableObjectQueued_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ DWORD finalizerFlags,
    /* [in] */ ObjectID objectID);


void __RPC_STUB ICorProfilerCallback2_FinalizeableObjectQueued_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_RootReferences2_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ ULONG cRootRefs,
    /* [size_is][in] */ ObjectID rootRefIds[  ],
    /* [size_is][in] */ COR_PRF_GC_ROOT_KIND rootKinds[  ],
    /* [size_is][in] */ COR_PRF_GC_ROOT_FLAGS rootFlags[  ],
    /* [size_is][in] */ UINT_PTR rootIds[  ]);


void __RPC_STUB ICorProfilerCallback2_RootReferences2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_HandleCreated_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ GCHandleID handleId,
    /* [in] */ ObjectID initialObjectId);


void __RPC_STUB ICorProfilerCallback2_HandleCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_HandleDestroyed_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ GCHandleID handleId);


void __RPC_STUB ICorProfilerCallback2_HandleDestroyed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorProfilerCallback2_INTERFACE_DEFINED__ */


#ifndef __ICorProfilerInfo_INTERFACE_DEFINED__
#define __ICorProfilerInfo_INTERFACE_DEFINED__

/* interface ICorProfilerInfo */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28B5557D-3F3F-48b4-90B2-5F9EEA2F6C48")
    ICorProfilerInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassFromObject( 
            /* [in] */ ObjectID objectId,
            /* [out] */ ClassID *pClassId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassFromToken( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ClassID *pClassId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeInfo( 
            /* [in] */ FunctionID functionId,
            /* [out] */ LPCBYTE *pStart,
            /* [out] */ ULONG *pcSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEventMask( 
            /* [out] */ DWORD *pdwEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromIP( 
            /* [in] */ LPCBYTE ip,
            /* [out] */ FunctionID *pFunctionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromToken( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdToken token,
            /* [out] */ FunctionID *pFunctionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandleFromThread( 
            /* [in] */ ThreadID threadId,
            /* [out] */ HANDLE *phThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectSize( 
            /* [in] */ ObjectID objectId,
            /* [out] */ ULONG *pcSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsArrayClass( 
            /* [in] */ ClassID classId,
            /* [out] */ CorElementType *pBaseElemType,
            /* [out] */ ClassID *pBaseClassId,
            /* [out] */ ULONG *pcRank) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadInfo( 
            /* [in] */ ThreadID threadId,
            /* [out] */ DWORD *pdwWin32ThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadID( 
            /* [out] */ ThreadID *pThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassIDInfo( 
            /* [in] */ ClassID classId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdTypeDef *pTypeDefToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionInfo( 
            /* [in] */ FunctionID functionId,
            /* [out] */ ClassID *pClassId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventMask( 
            /* [in] */ DWORD dwEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnterLeaveFunctionHooks( 
            /* [in] */ FunctionEnter *pFuncEnter,
            /* [in] */ FunctionLeave *pFuncLeave,
            /* [in] */ FunctionTailcall *pFuncTailcall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFunctionIDMapper( 
            /* [in] */ FunctionIDMapper *pFunc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTokenAndMetaDataFromFunction( 
            /* [in] */ FunctionID functionId,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppImport,
            /* [out] */ mdToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleInfo( 
            /* [in] */ ModuleID moduleId,
            /* [out] */ LPCBYTE *ppBaseLoadAddress,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AssemblyID *pAssemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleMetaData( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ DWORD dwOpenFlags,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILFunctionBody( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodId,
            /* [out] */ LPCBYTE *ppMethodHeader,
            /* [out] */ ULONG *pcbMethodSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILFunctionBodyAllocator( 
            /* [in] */ ModuleID moduleId,
            /* [out] */ IMethodMalloc **ppMalloc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetILFunctionBody( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodid,
            /* [in] */ LPCBYTE pbNewILMethodHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomainInfo( 
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ ProcessID *pProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyInfo( 
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AppDomainID *pAppDomainId,
            /* [out] */ ModuleID *pModuleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFunctionReJIT( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceGC( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetILInstrumentedCodeMap( 
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fStartJit,
            /* [in] */ ULONG cILMapEntries,
            /* [size_is][in] */ COR_IL_MAP rgILMapEntries[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInprocInspectionInterface( 
            /* [out] */ IUnknown **ppicd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInprocInspectionIThisThread( 
            /* [out] */ IUnknown **ppicd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ThreadID threadId,
            /* [out] */ ContextID *pContextId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginInprocDebugging( 
            /* [in] */ BOOL fThisThreadOnly,
            /* [out] */ DWORD *pdwProfilerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndInprocDebugging( 
            /* [in] */ DWORD dwProfilerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILToNativeMapping( 
            /* [in] */ FunctionID functionId,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromObject )( 
            ICorProfilerInfo * This,
            /* [in] */ ObjectID objectId,
            /* [out] */ ClassID *pClassId);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromToken )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ClassID *pClassId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ LPCBYTE *pStart,
            /* [out] */ ULONG *pcSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventMask )( 
            ICorProfilerInfo * This,
            /* [out] */ DWORD *pdwEvents);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromIP )( 
            ICorProfilerInfo * This,
            /* [in] */ LPCBYTE ip,
            /* [out] */ FunctionID *pFunctionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromToken )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdToken token,
            /* [out] */ FunctionID *pFunctionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandleFromThread )( 
            ICorProfilerInfo * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ HANDLE *phThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectSize )( 
            ICorProfilerInfo * This,
            /* [in] */ ObjectID objectId,
            /* [out] */ ULONG *pcSize);
        
        HRESULT ( STDMETHODCALLTYPE *IsArrayClass )( 
            ICorProfilerInfo * This,
            /* [in] */ ClassID classId,
            /* [out] */ CorElementType *pBaseElemType,
            /* [out] */ ClassID *pBaseClassId,
            /* [out] */ ULONG *pcRank);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ DWORD *pdwWin32ThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICorProfilerInfo * This,
            /* [out] */ ThreadID *pThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassIDInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ ClassID classId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdTypeDef *pTypeDefToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ ClassID *pClassId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *SetEventMask )( 
            ICorProfilerInfo * This,
            /* [in] */ DWORD dwEvents);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnterLeaveFunctionHooks )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionEnter *pFuncEnter,
            /* [in] */ FunctionLeave *pFuncLeave,
            /* [in] */ FunctionTailcall *pFuncTailcall);
        
        HRESULT ( STDMETHODCALLTYPE *SetFunctionIDMapper )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionIDMapper *pFunc);
        
        HRESULT ( STDMETHODCALLTYPE *GetTokenAndMetaDataFromFunction )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppImport,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [out] */ LPCBYTE *ppBaseLoadAddress,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AssemblyID *pAssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleMetaData )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ DWORD dwOpenFlags,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetILFunctionBody )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodId,
            /* [out] */ LPCBYTE *ppMethodHeader,
            /* [out] */ ULONG *pcbMethodSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetILFunctionBodyAllocator )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [out] */ IMethodMalloc **ppMalloc);
        
        HRESULT ( STDMETHODCALLTYPE *SetILFunctionBody )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodid,
            /* [in] */ LPCBYTE pbNewILMethodHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomainInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ ProcessID *pProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AppDomainID *pAppDomainId,
            /* [out] */ ModuleID *pModuleId);
        
        HRESULT ( STDMETHODCALLTYPE *SetFunctionReJIT )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ForceGC )( 
            ICorProfilerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetILInstrumentedCodeMap )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fStartJit,
            /* [in] */ ULONG cILMapEntries,
            /* [size_is][in] */ COR_IL_MAP rgILMapEntries[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetInprocInspectionInterface )( 
            ICorProfilerInfo * This,
            /* [out] */ IUnknown **ppicd);
        
        HRESULT ( STDMETHODCALLTYPE *GetInprocInspectionIThisThread )( 
            ICorProfilerInfo * This,
            /* [out] */ IUnknown **ppicd);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorProfilerInfo * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ ContextID *pContextId);
        
        HRESULT ( STDMETHODCALLTYPE *BeginInprocDebugging )( 
            ICorProfilerInfo * This,
            /* [in] */ BOOL fThisThreadOnly,
            /* [out] */ DWORD *pdwProfilerContext);
        
        HRESULT ( STDMETHODCALLTYPE *EndInprocDebugging )( 
            ICorProfilerInfo * This,
            /* [in] */ DWORD dwProfilerContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetILToNativeMapping )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);
        
        END_INTERFACE
    } ICorProfilerInfoVtbl;

    interface ICorProfilerInfo
    {
        CONST_VTBL struct ICorProfilerInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorProfilerInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorProfilerInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorProfilerInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorProfilerInfo_GetClassFromObject(This,objectId,pClassId)	\
    (This)->lpVtbl -> GetClassFromObject(This,objectId,pClassId)

#define ICorProfilerInfo_GetClassFromToken(This,moduleId,typeDef,pClassId)	\
    (This)->lpVtbl -> GetClassFromToken(This,moduleId,typeDef,pClassId)

#define ICorProfilerInfo_GetCodeInfo(This,functionId,pStart,pcSize)	\
    (This)->lpVtbl -> GetCodeInfo(This,functionId,pStart,pcSize)

#define ICorProfilerInfo_GetEventMask(This,pdwEvents)	\
    (This)->lpVtbl -> GetEventMask(This,pdwEvents)

#define ICorProfilerInfo_GetFunctionFromIP(This,ip,pFunctionId)	\
    (This)->lpVtbl -> GetFunctionFromIP(This,ip,pFunctionId)

#define ICorProfilerInfo_GetFunctionFromToken(This,moduleId,token,pFunctionId)	\
    (This)->lpVtbl -> GetFunctionFromToken(This,moduleId,token,pFunctionId)

#define ICorProfilerInfo_GetHandleFromThread(This,threadId,phThread)	\
    (This)->lpVtbl -> GetHandleFromThread(This,threadId,phThread)

#define ICorProfilerInfo_GetObjectSize(This,objectId,pcSize)	\
    (This)->lpVtbl -> GetObjectSize(This,objectId,pcSize)

#define ICorProfilerInfo_IsArrayClass(This,classId,pBaseElemType,pBaseClassId,pcRank)	\
    (This)->lpVtbl -> IsArrayClass(This,classId,pBaseElemType,pBaseClassId,pcRank)

#define ICorProfilerInfo_GetThreadInfo(This,threadId,pdwWin32ThreadId)	\
    (This)->lpVtbl -> GetThreadInfo(This,threadId,pdwWin32ThreadId)

#define ICorProfilerInfo_GetCurrentThreadID(This,pThreadId)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,pThreadId)

#define ICorProfilerInfo_GetClassIDInfo(This,classId,pModuleId,pTypeDefToken)	\
    (This)->lpVtbl -> GetClassIDInfo(This,classId,pModuleId,pTypeDefToken)

#define ICorProfilerInfo_GetFunctionInfo(This,functionId,pClassId,pModuleId,pToken)	\
    (This)->lpVtbl -> GetFunctionInfo(This,functionId,pClassId,pModuleId,pToken)

#define ICorProfilerInfo_SetEventMask(This,dwEvents)	\
    (This)->lpVtbl -> SetEventMask(This,dwEvents)

#define ICorProfilerInfo_SetEnterLeaveFunctionHooks(This,pFuncEnter,pFuncLeave,pFuncTailcall)	\
    (This)->lpVtbl -> SetEnterLeaveFunctionHooks(This,pFuncEnter,pFuncLeave,pFuncTailcall)

#define ICorProfilerInfo_SetFunctionIDMapper(This,pFunc)	\
    (This)->lpVtbl -> SetFunctionIDMapper(This,pFunc)

#define ICorProfilerInfo_GetTokenAndMetaDataFromFunction(This,functionId,riid,ppImport,pToken)	\
    (This)->lpVtbl -> GetTokenAndMetaDataFromFunction(This,functionId,riid,ppImport,pToken)

#define ICorProfilerInfo_GetModuleInfo(This,moduleId,ppBaseLoadAddress,cchName,pcchName,szName,pAssemblyId)	\
    (This)->lpVtbl -> GetModuleInfo(This,moduleId,ppBaseLoadAddress,cchName,pcchName,szName,pAssemblyId)

#define ICorProfilerInfo_GetModuleMetaData(This,moduleId,dwOpenFlags,riid,ppOut)	\
    (This)->lpVtbl -> GetModuleMetaData(This,moduleId,dwOpenFlags,riid,ppOut)

#define ICorProfilerInfo_GetILFunctionBody(This,moduleId,methodId,ppMethodHeader,pcbMethodSize)	\
    (This)->lpVtbl -> GetILFunctionBody(This,moduleId,methodId,ppMethodHeader,pcbMethodSize)

#define ICorProfilerInfo_GetILFunctionBodyAllocator(This,moduleId,ppMalloc)	\
    (This)->lpVtbl -> GetILFunctionBodyAllocator(This,moduleId,ppMalloc)

#define ICorProfilerInfo_SetILFunctionBody(This,moduleId,methodid,pbNewILMethodHeader)	\
    (This)->lpVtbl -> SetILFunctionBody(This,moduleId,methodid,pbNewILMethodHeader)

#define ICorProfilerInfo_GetAppDomainInfo(This,appDomainId,cchName,pcchName,szName,pProcessId)	\
    (This)->lpVtbl -> GetAppDomainInfo(This,appDomainId,cchName,pcchName,szName,pProcessId)

#define ICorProfilerInfo_GetAssemblyInfo(This,assemblyId,cchName,pcchName,szName,pAppDomainId,pModuleId)	\
    (This)->lpVtbl -> GetAssemblyInfo(This,assemblyId,cchName,pcchName,szName,pAppDomainId,pModuleId)

#define ICorProfilerInfo_SetFunctionReJIT(This,functionId)	\
    (This)->lpVtbl -> SetFunctionReJIT(This,functionId)

#define ICorProfilerInfo_ForceGC(This)	\
    (This)->lpVtbl -> ForceGC(This)

#define ICorProfilerInfo_SetILInstrumentedCodeMap(This,functionId,fStartJit,cILMapEntries,rgILMapEntries)	\
    (This)->lpVtbl -> SetILInstrumentedCodeMap(This,functionId,fStartJit,cILMapEntries,rgILMapEntries)

#define ICorProfilerInfo_GetInprocInspectionInterface(This,ppicd)	\
    (This)->lpVtbl -> GetInprocInspectionInterface(This,ppicd)

#define ICorProfilerInfo_GetInprocInspectionIThisThread(This,ppicd)	\
    (This)->lpVtbl -> GetInprocInspectionIThisThread(This,ppicd)

#define ICorProfilerInfo_GetThreadContext(This,threadId,pContextId)	\
    (This)->lpVtbl -> GetThreadContext(This,threadId,pContextId)

#define ICorProfilerInfo_BeginInprocDebugging(This,fThisThreadOnly,pdwProfilerContext)	\
    (This)->lpVtbl -> BeginInprocDebugging(This,fThisThreadOnly,pdwProfilerContext)

#define ICorProfilerInfo_EndInprocDebugging(This,dwProfilerContext)	\
    (This)->lpVtbl -> EndInprocDebugging(This,dwProfilerContext)

#define ICorProfilerInfo_GetILToNativeMapping(This,functionId,cMap,pcMap,map)	\
    (This)->lpVtbl -> GetILToNativeMapping(This,functionId,cMap,pcMap,map)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetClassFromObject_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ObjectID objectId,
    /* [out] */ ClassID *pClassId);


void __RPC_STUB ICorProfilerInfo_GetClassFromObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetClassFromToken_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdTypeDef typeDef,
    /* [out] */ ClassID *pClassId);


void __RPC_STUB ICorProfilerInfo_GetClassFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetCodeInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [out] */ LPCBYTE *pStart,
    /* [out] */ ULONG *pcSize);


void __RPC_STUB ICorProfilerInfo_GetCodeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetEventMask_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ DWORD *pdwEvents);


void __RPC_STUB ICorProfilerInfo_GetEventMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetFunctionFromIP_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ LPCBYTE ip,
    /* [out] */ FunctionID *pFunctionId);


void __RPC_STUB ICorProfilerInfo_GetFunctionFromIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetFunctionFromToken_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdToken token,
    /* [out] */ FunctionID *pFunctionId);


void __RPC_STUB ICorProfilerInfo_GetFunctionFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetHandleFromThread_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ThreadID threadId,
    /* [out] */ HANDLE *phThread);


void __RPC_STUB ICorProfilerInfo_GetHandleFromThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetObjectSize_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ObjectID objectId,
    /* [out] */ ULONG *pcSize);


void __RPC_STUB ICorProfilerInfo_GetObjectSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_IsArrayClass_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ClassID classId,
    /* [out] */ CorElementType *pBaseElemType,
    /* [out] */ ClassID *pBaseClassId,
    /* [out] */ ULONG *pcRank);


void __RPC_STUB ICorProfilerInfo_IsArrayClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetThreadInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ThreadID threadId,
    /* [out] */ DWORD *pdwWin32ThreadId);


void __RPC_STUB ICorProfilerInfo_GetThreadInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetCurrentThreadID_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ ThreadID *pThreadId);


void __RPC_STUB ICorProfilerInfo_GetCurrentThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetClassIDInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ClassID classId,
    /* [out] */ ModuleID *pModuleId,
    /* [out] */ mdTypeDef *pTypeDefToken);


void __RPC_STUB ICorProfilerInfo_GetClassIDInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetFunctionInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [out] */ ClassID *pClassId,
    /* [out] */ ModuleID *pModuleId,
    /* [out] */ mdToken *pToken);


void __RPC_STUB ICorProfilerInfo_GetFunctionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetEventMask_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ DWORD dwEvents);


void __RPC_STUB ICorProfilerInfo_SetEventMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetEnterLeaveFunctionHooks_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionEnter *pFuncEnter,
    /* [in] */ FunctionLeave *pFuncLeave,
    /* [in] */ FunctionTailcall *pFuncTailcall);


void __RPC_STUB ICorProfilerInfo_SetEnterLeaveFunctionHooks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetFunctionIDMapper_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionIDMapper *pFunc);


void __RPC_STUB ICorProfilerInfo_SetFunctionIDMapper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetTokenAndMetaDataFromFunction_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppImport,
    /* [out] */ mdToken *pToken);


void __RPC_STUB ICorProfilerInfo_GetTokenAndMetaDataFromFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetModuleInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [out] */ LPCBYTE *ppBaseLoadAddress,
    /* [in] */ ULONG cchName,
    /* [out] */ ULONG *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ],
    /* [out] */ AssemblyID *pAssemblyId);


void __RPC_STUB ICorProfilerInfo_GetModuleInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetModuleMetaData_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ DWORD dwOpenFlags,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppOut);


void __RPC_STUB ICorProfilerInfo_GetModuleMetaData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetILFunctionBody_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdMethodDef methodId,
    /* [out] */ LPCBYTE *ppMethodHeader,
    /* [out] */ ULONG *pcbMethodSize);


void __RPC_STUB ICorProfilerInfo_GetILFunctionBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetILFunctionBodyAllocator_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [out] */ IMethodMalloc **ppMalloc);


void __RPC_STUB ICorProfilerInfo_GetILFunctionBodyAllocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetILFunctionBody_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdMethodDef methodid,
    /* [in] */ LPCBYTE pbNewILMethodHeader);


void __RPC_STUB ICorProfilerInfo_SetILFunctionBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetAppDomainInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ AppDomainID appDomainId,
    /* [in] */ ULONG cchName,
    /* [out] */ ULONG *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ],
    /* [out] */ ProcessID *pProcessId);


void __RPC_STUB ICorProfilerInfo_GetAppDomainInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetAssemblyInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ AssemblyID assemblyId,
    /* [in] */ ULONG cchName,
    /* [out] */ ULONG *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ],
    /* [out] */ AppDomainID *pAppDomainId,
    /* [out] */ ModuleID *pModuleId);


void __RPC_STUB ICorProfilerInfo_GetAssemblyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetFunctionReJIT_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerInfo_SetFunctionReJIT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_ForceGC_Proxy( 
    ICorProfilerInfo * This);


void __RPC_STUB ICorProfilerInfo_ForceGC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetILInstrumentedCodeMap_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ BOOL fStartJit,
    /* [in] */ ULONG cILMapEntries,
    /* [size_is][in] */ COR_IL_MAP rgILMapEntries[  ]);


void __RPC_STUB ICorProfilerInfo_SetILInstrumentedCodeMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetInprocInspectionInterface_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ IUnknown **ppicd);


void __RPC_STUB ICorProfilerInfo_GetInprocInspectionInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetInprocInspectionIThisThread_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ IUnknown **ppicd);


void __RPC_STUB ICorProfilerInfo_GetInprocInspectionIThisThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetThreadContext_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ThreadID threadId,
    /* [out] */ ContextID *pContextId);


void __RPC_STUB ICorProfilerInfo_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_BeginInprocDebugging_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ BOOL fThisThreadOnly,
    /* [out] */ DWORD *pdwProfilerContext);


void __RPC_STUB ICorProfilerInfo_BeginInprocDebugging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_EndInprocDebugging_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ DWORD dwProfilerContext);


void __RPC_STUB ICorProfilerInfo_EndInprocDebugging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetILToNativeMapping_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ ULONG32 cMap,
    /* [out] */ ULONG32 *pcMap,
    /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);


void __RPC_STUB ICorProfilerInfo_GetILToNativeMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorProfilerInfo_INTERFACE_DEFINED__ */


#ifndef __ICorProfilerInfo2_INTERFACE_DEFINED__
#define __ICorProfilerInfo2_INTERFACE_DEFINED__

/* interface ICorProfilerInfo2 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC0935CD-A518-487d-B0BB-A93214E65478")
    ICorProfilerInfo2 : public ICorProfilerInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoStackSnapshot( 
            /* [in] */ ThreadID thread,
            /* [in] */ StackSnapshotCallback *callback,
            /* [in] */ ULONG32 infoFlags,
            /* [in] */ void *clientData,
            /* [length_is][size_is][in] */ BYTE context[  ],
            /* [in] */ ULONG32 contextSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnterLeaveFunctionHooks2( 
            /* [in] */ FunctionEnter2 *pFuncEnter,
            /* [in] */ FunctionLeave2 *pFuncLeave,
            /* [in] */ FunctionTailcall2 *pFuncTailcall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionInfo2( 
            /* [in] */ FunctionID funcId,
            /* [in] */ COR_PRF_FRAME_INFO frameInfo,
            /* [out] */ ClassID *pClassId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdToken *pToken,
            /* [in] */ ULONG32 cTypeArgs,
            /* [out] */ ULONG32 *pcTypeArgs,
            /* [out] */ ClassID typeArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringLayout( 
            /* [out] */ ULONG *pBufferLengthOffset,
            /* [out] */ ULONG *pStringLengthOffset,
            /* [out] */ ULONG *pBufferOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassLayout( 
            /* [in] */ ClassID classID,
            /* [out][in] */ COR_FIELD_OFFSET rFieldOffset[  ],
            /* [in] */ ULONG cFieldOffset,
            /* [out] */ ULONG *pcFieldOffset,
            /* [out] */ ULONG *pulClassSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassIDInfo2( 
            /* [in] */ ClassID classId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdTypeDef *pTypeDefToken,
            /* [out] */ ClassID *pParentClassId,
            /* [in] */ ULONG32 cNumTypeArgs,
            /* [out] */ ULONG32 *pcNumTypeArgs,
            /* [out] */ ClassID typeArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeInfo2( 
            /* [in] */ FunctionID functionID,
            /* [in] */ ULONG32 cCodeInfos,
            /* [out] */ ULONG32 *pcCodeInfos,
            /* [length_is][size_is][out] */ COR_PRF_CODE_INFO codeInfos[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassFromTokenAndTypeArgs( 
            /* [in] */ ModuleID moduleID,
            /* [in] */ mdTypeDef typeDef,
            /* [in] */ ULONG32 cTypeArgs,
            /* [size_is][in] */ ClassID typeArgs[  ],
            /* [out] */ ClassID *pClassID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromTokenAndTypeArgs( 
            /* [in] */ ModuleID moduleID,
            /* [in] */ mdMethodDef funcDef,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG32 cTypeArgs,
            /* [size_is][in] */ ClassID typeArgs[  ],
            /* [out] */ FunctionID *pFunctionID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumModuleFrozenObjects( 
            /* [in] */ ModuleID moduleID,
            /* [out] */ ICorProfilerObjectEnum **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArrayObjectInfo( 
            /* [in] */ ObjectID objectId,
            /* [in] */ ULONG32 cDimensions,
            /* [length_is][size_is][out] */ ULONG32 pDimensionSizes[  ],
            /* [length_is][size_is][out] */ int pDimensionLowerBounds[  ],
            /* [out] */ BYTE **ppData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBoxClassLayout( 
            /* [in] */ ClassID classId,
            /* [out] */ ULONG32 *pBufferOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadAppDomain( 
            /* [in] */ ThreadID threadId,
            /* [out] */ AppDomainID *pAppDomainId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRVAStaticAddress( 
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [out] */ void **ppAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomainStaticAddress( 
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [in] */ AppDomainID appDomainId,
            /* [out] */ void **ppAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadStaticAddress( 
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [in] */ ThreadID threadId,
            /* [out] */ void **ppAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextStaticAddress( 
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [in] */ ContextID contextId,
            /* [out] */ void **ppAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStaticFieldInfo( 
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [out] */ COR_PRF_STATIC_TYPE *pFieldInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGenerationBounds( 
            /* [in] */ ULONG cObjectRanges,
            /* [out] */ ULONG *pcObjectRanges,
            /* [length_is][size_is][out] */ COR_PRF_GC_GENERATION_RANGE ranges[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectGeneration( 
            /* [in] */ ObjectID objectId,
            /* [out] */ COR_PRF_GC_GENERATION_RANGE *range) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNotifiedExceptionClauseInfo( 
            /* [out] */ COR_PRF_EX_CLAUSE_INFO *pinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromObject )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ObjectID objectId,
            /* [out] */ Cla