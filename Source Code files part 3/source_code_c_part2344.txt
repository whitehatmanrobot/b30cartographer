 i ].IgnoreRangeCount = OldFileInfoArray[ i ].IgnoreRangeCount;
        OldFileInfoByHandle[ i ].IgnoreRangeArray = OldFileInfoArray[ i ].IgnoreRangeArray;
        OldFileInfoByHandle[ i ].RetainRangeCount = OldFileInfoArray[ i ].RetainRangeCount;
        OldFileInfoByHandle[ i ].RetainRangeArray = OldFileInfoArray[ i ].RetainRangeArray;

        if ( OldFileInfoArray[ i ].OldFileName == NULL ) {

            if ( OldFileCount != 1 ) {
                SetLastError( ERROR_INVALID_PARAMETER );
                Success = FALSE;
                break;
                }

            OldFileInfoByHandle[ i ].OldFileHandle = INVALID_HANDLE_VALUE;
            }
        else {

            OldFileInfoByHandle[ i ].OldFileHandle = CreateFileW(
                                                         OldFileInfoArray[ i ].OldFileName,
                                                         GENERIC_READ,
                                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                         NULL,
                                                         OPEN_EXISTING,
                                                         FILE_FLAG_SEQUENTIAL_SCAN,
                                                         NULL
                                                         );
            if ( OldFileInfoByHandle[ i ].OldFileHandle == INVALID_HANDLE_VALUE ) {
                Success = FALSE;
                break;
                }
            }
        }

    if ( Success ) {

        Success = FALSE;

        NewFileHandle = CreateFileW(
                            NewFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

            PatchFileHandle = CreateFileW(
                                  PatchFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL
                                  );

            if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

                Success = CreatePatchFileByHandlesEx(
                              OldFileCount,
                              OldFileInfoByHandle,
                              NewFileHandle,
                              PatchFileHandle,
                              OptionFlags,
                              OptionData,
                              ProgressCallback,
                              CallbackContext
                              );

                CloseHandle( PatchFileHandle );

                if ( ! Success ) {
                    DeleteFileW( PatchFileName );
                    }
                }

            CloseHandle( NewFileHandle );
            }
        }

    for ( i = 0; i < OldFileCount; i++ ) {
        if (( OldFileInfoByHandle[ i ].OldFileHandle != NULL ) &&
            ( OldFileInfoByHandle[ i ].OldFileHandle != INVALID_HANDLE_VALUE )) {

            CloseHandle( OldFileInfoByHandle[ i ].OldFileHandle );
            }
        }

    return Success;
    }


BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PPATCH_INTERLEAVE_MAP* InterleaveMapArray;
    PATCH_HEADER_INFO HeaderInfo;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_NT_HEADERS OldFileNtHeader;
    PPATCH_DATA PatchArray;
    PFILETIME PatchFileTime;
    FILETIME NewFileTime;
    PUCHAR   NewFileMapped;
    ULONG    NewFileSize;
    ULONG    NewFileCrc;
    ULONG    NewFileCoffBase;
    ULONG    NewFileCoffTime;
    ULONG    NewFileResTime;
    ULONG    NewFileCompressedSize;
    PUCHAR   OldFileMapped;
    ULONG    OldFileSize;
    ULONG    OldFileCrc;
    PUCHAR   PatchFileMapped;
    PUCHAR   PatchBuffer;
    ULONG    PatchBufferSize;
    PUCHAR   PatchAltBuffer;
    ULONG    PatchAltSize;
    ULONG    PatchDataSize;
    ULONG    PatchFileCrc;
    ULONG    HeaderSize;
    ULONG    HeaderOldFileCount;
    ULONG    ProgressPosition;
    ULONG    ProgressMaximum;
    ULONG    ErrorCode;
    BOOL     TryLzxBoth;
    BOOL     Success;
    BOOL     Transform;
    BOOL     TransformedE8;
    HANDLE   SubAllocatorHandle;
    HANDLE   LocalSubAlloc;
    ULONG    EstimatedLzxMemory;
    ULONG    MaxLzxWindowForce;
    ULONG    ExtendedOptionFlags;
    ULONG    AltExtendedOptionFlags;
    ULONG    OldFileOriginalChecksum;
    ULONG    OldFileOriginalTimeDate;
    ULONG    LargestOldFileSize;
    ULONG    i, j;
    PUCHAR   p;

    LocalSubAlloc = NULL;

    if (( OldFileCount == 0 ) || ( OldFileCount > 127 )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    ZeroMemory( &HeaderInfo, sizeof( HeaderInfo ));

    HeaderInfo.InterleaveMapArray = _alloca( OldFileCount * sizeof( PVOID ));
    HeaderInfo.OldFileInfoArray   = _alloca( OldFileCount * sizeof( HEADER_OLD_FILE_INFO ));
    PatchArray                    = _alloca( OldFileCount * sizeof( PATCH_DATA ));

    ZeroMemory( HeaderInfo.InterleaveMapArray, OldFileCount * sizeof( PVOID ));
    ZeroMemory( HeaderInfo.OldFileInfoArray,   OldFileCount * sizeof( HEADER_OLD_FILE_INFO ));
    ZeroMemory( PatchArray,                    OldFileCount * sizeof( PATCH_DATA ));

    if ( OptionFlags & PATCH_OPTION_SIGNATURE_MD5 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    if (( OptionFlags & 0x0000FFFF ) == PATCH_OPTION_USE_BEST ) {

        OptionFlags |= ( PATCH_OPTION_USE_LZX_BEST );

        //
        //  Can't turn on LZX_LARGE or INTERLEAVE flags here because they
        //  might create a patch that is not compatible with older applyer.
        //
        //  It sucks to not have an option that means "do the best you can",
        //  but if we have such an option, people will always use it, and
        //  will always create patches that are not backward compatible
        //  with older applyer.  So, we have to put the new features under
        //  new flags.
        //
        //  Idea for future:  REQUIRE a flag for "target applyer version
        //  is xxx".  Then any build scripts for older creator will only
        //  target older applyer.  If no flag is specified, it will simply
        //  refuse to create a patch.  You have to specify the applyer ver.
        //

        }

    for ( i = 1; i < OldFileCount; i++ ) {

        if ( OldFileInfoArray[ i ].OldFileHandle == INVALID_HANDLE_VALUE ) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
            }

        if ( OldFileInfoArray[ i ].RetainRangeCount != OldFileInfoArray[ 0 ].RetainRangeCount ) {
            SetLastError( ERROR_PATCH_RETAIN_RANGES_DIFFER );
            return FALSE;
            }

        for ( j = 0; j < OldFileInfoArray[ 0 ].RetainRangeCount; j++ ) {
            if (( OldFileInfoArray[ i ].RetainRangeArray[ j ].OffsetInNewFile !=
                  OldFileInfoArray[ 0 ].RetainRangeArray[ j ].OffsetInNewFile ) ||
                ( OldFileInfoArray[ i ].RetainRangeArray[ j ].LengthInBytes !=
                  OldFileInfoArray[ 0 ].RetainRangeArray[ j ].LengthInBytes )) {

                SetLastError( ERROR_PATCH_RETAIN_RANGES_DIFFER );
                return FALSE;
                }
            }
        }

    Success = MyMapViewOfFileByHandle(
                  NewFileHandle,
                  &NewFileSize,
                  &NewFileMapped
                  );

    if ( ! Success ) {

        if ( GetLastError() == ERROR_SUCCESS ) {

            SetLastError( ERROR_EXTENDED_ERROR );
            }

        return FALSE;
        }

    GetFileTime( NewFileHandle, NULL, NULL, &NewFileTime );
    PatchFileTime = &NewFileTime;

    NewFileCoffBase    = 0;
    NewFileCoffTime    = 0;
    NewFileResTime     = 0;
    HeaderOldFileCount = 0;
    HeaderSize         = 0;
    NewFileCrc         = 0;     // prevent compiler warning

    ProgressPosition   = 0;
    ProgressMaximum    = 0;     // prevent compiler warning

    ExtendedOptionFlags = 0;

    InterleaveMapArray = NULL;

    LargestOldFileSize = 0;

    MaxLzxWindowForce  = 0;

    if ( OptionData ) {

        if ( OptionData->SizeOfThisStruct >=
             ( offsetof( PATCH_OPTION_DATA, ExtendedOptionFlags ) +
               sizeof( OptionData->ExtendedOptionFlags ))) {

            ExtendedOptionFlags = OptionData->ExtendedOptionFlags;
            }

        if (( OptionFlags & PATCH_OPTION_INTERLEAVE_FILES ) &&
            ( OptionData->SizeOfThisStruct >=
              ( offsetof( PATCH_OPTION_DATA, InterleaveMapArray ) +
                sizeof( OptionData->InterleaveMapArray )))) {

            InterleaveMapArray = OptionData->InterleaveMapArray;
            }

        if ( OptionData->SizeOfThisStruct >=
             ( offsetof( PATCH_OPTION_DATA, MaxLzxWindowSize ) +
               sizeof( OptionData->MaxLzxWindowSize ))) {

            MaxLzxWindowForce = OptionData->MaxLzxWindowSize;
            }
        }

    ExtendedOptionFlags |= PATCH_TRANSFORM_CREATION;

    __try {

        NtHeader = GetNtHeader( NewFileMapped, NewFileSize );

        if ( ! ( OptionFlags & PATCH_OPTION_NO_REBASE )) {
            if ( NtHeader ) {
                NewFileCoffTime = NtHeader->FileHeader.TimeDateStamp;
                NewFileCoffBase = NtHeader->OptionalHeader.ImageBase;
                }
            else {
                OptionFlags |= PATCH_OPTION_NO_REBASE;
                }
            }

        if (( NtHeader ) && ( NtHeader->OptionalHeader.CheckSum == 0 )) {
            OptionFlags |= PATCH_OPTION_NO_CHECKSUM;
            }

        if ( ! ( OptionFlags & PATCH_OPTION_NO_RESTIMEFIX )) {

            if ( NtHeader ) {

                PIMAGE_RESOURCE_DIRECTORY ResDir;

                ResDir = ImageDirectoryMappedAddress(
                             NtHeader,
                             IMAGE_DIRECTORY_ENTRY_RESOURCE,
                             NULL,
                             NewFileMapped,
                             NewFileSize
                             );

                if ( ResDir ) {
                    NewFileResTime = ResDir->TimeDateStamp;
                    }
                }

            if ( NewFileResTime == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            }

        TryLzxBoth = FALSE;

        if (( OptionFlags & PATCH_OPTION_USE_LZX_BEST ) == PATCH_OPTION_USE_LZX_BEST ) {

            OptionFlags &= ~PATCH_OPTION_USE_LZX_B;     // No E8 translation on first try.

            if ( NewFileSize >= sizeof( IMAGE_DOS_HEADER )) {

                if ((( ! NtHeader ) && ( *(UNALIGNED USHORT *)NewFileMapped == 0x5A4D )) ||             // MZ, and not PE
                    (( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ))) {    // PE, and i386

                    TryLzxBoth = TRUE;  //  Will force E8 translation on second try.
                    }
                }
            }

        for ( i = 0; i < OldFileCount; i++ ) {

            OldFileSize = 0;

            if ( OldFileInfoArray[ i ].OldFileHandle != INVALID_HANDLE_VALUE ) {
                 OldFileSize = GetFileSize( OldFileInfoArray[ i ].OldFileHandle, NULL );
                 }

            if ( LargestOldFileSize < OldFileSize ) {
                 LargestOldFileSize = OldFileSize;
                 }
            }

        if (( LargestOldFileSize != 0 ) &&                                                      // don't do this for null patches
            (( OptionFlags & PATCH_OPTION_USE_LZX_BEST ) == PATCH_OPTION_USE_LZX_B ) &&         // caller is requesting forced E8 translation
            (( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ))) {    // PE, i386

            //
            //  Caller is requesting forced LZX E8 translation, so disable
            //  rift-based E8 transformation unless this is a zero patch.
            //

            ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELCALLS;
            }

        if ( OptionFlags & PATCH_OPTION_INTERLEAVE_FILES ) {

            if ( InterleaveMapArray == NULL ) {

                if (( ROUNDUP2( LargestOldFileSize, LZX_BLOCKSIZE ) + NewFileSize ) > LzxMaxWindowSize( OptionFlags, MaxLzxWindowForce )) {

                    //
                    //  Need to create default interleave map.
                    //

                    LocalSubAlloc = CreateSubAllocator( MINIMUM_VM_ALLOCATION, MINIMUM_VM_ALLOCATION );

                    if ( LocalSubAlloc == NULL ) {
                        Success = FALSE;
                        __leave;
                        }

                    InterleaveMapArray = SubAllocate( LocalSubAlloc, OldFileCount * sizeof( PVOID ));

                    if ( InterleaveMapArray == NULL ) {
                        Success = FALSE;
                        __leave;
                        }

                    for ( i = 0; i < OldFileCount; i++ ) {

                        OldFileSize = 0;

                        if ( OldFileInfoArray[ i ].OldFileHandle != INVALID_HANDLE_VALUE ) {
                             OldFileSize = GetFileSize( OldFileInfoArray[ i ].OldFileHandle, NULL );
                             }

                        if ( OldFileSize != 0 ) {

                            InterleaveMapArray[ i ] = CreateDefaultInterleaveMap(
                                                           LocalSubAlloc,
                                                           OldFileSize,
                                                           NewFileSize,
                                                           OptionFlags,
                                                           MaxLzxWindowForce
                                                           );
                            }
                        }
                    }

                else {

                    //
                    //  We don't need to interleave any files, and no map
                    //  was specified, so we turn off the interleave flag.
                    //

                    OptionFlags &= ~PATCH_OPTION_INTERLEAVE_FILES;
                    }
                }
            }

        ProgressMaximum = NewFileSize * OldFileCount;

        for ( i = 0; i < OldFileCount; i++ ) {

            OldFileSize = 0;

            if ( OldFileInfoArray[ i ].OldFileHandle != INVALID_HANDLE_VALUE ) {
                OldFileSize = GetFileSize( OldFileInfoArray[ i ].OldFileHandle, NULL );
                }

            ProgressMaximum += LzxOldFileInsertSize(
                                   OldFileSize,
                                   OptionFlags,
                                   MaxLzxWindowForce,
                                   InterleaveMapArray ? InterleaveMapArray[ i ] : NULL
                                   );

            if (( InterleaveMapArray      ) &&
                ( InterleaveMapArray[ i ] ) &&
                ( InterleaveMapArray[ i ]->CountRanges > 1 )) {

                TryLzxBoth = FALSE;

                //
                //  Won't prevent caller from explicitly trying LZX E8 (LZX_B),
                //  but we won't try it automatically since interleaving will
                //  confuse LZX's internal E8 EIP counter.
                //

                }
            }

        if ( TryLzxBoth ) {
            ProgressMaximum *= 2;
            }

        if ( OptionFlags & PATCH_OPTION_FAIL_IF_BIGGER ) {
            ProgressMaximum += NewFileSize;
            }

RetryWithDifferentTransform:

        Success = ProgressCallbackWrapper(
                      ProgressCallback,
                      CallbackContext,
                      0,
                      ProgressMaximum
                      );

        if ( ! Success ) {
            __leave;
            }

        for ( j = 0; j < OldFileInfoArray[ 0 ].RetainRangeCount; j++ ) {
            ZeroMemory(
                OldFileInfoArray[ 0 ].RetainRangeArray[ j ].OffsetInNewFile + NewFileMapped,
                OldFileInfoArray[ 0 ].RetainRangeArray[ j ].LengthInBytes
                );
            }

        NewFileCrc = Crc32( 0xFFFFFFFF, NewFileMapped, NewFileSize ) ^ 0xFFFFFFFF;

        PatchBufferSize = ROUNDUP2( NewFileSize + ( NewFileSize / 256 ) + 1, 0x10000 );

        Success = FALSE;

        for ( i = 0; i < OldFileCount; i++ ) {

            if ( OldFileInfoArray[ i ].OldFileHandle == INVALID_HANDLE_VALUE ) {

                OldFileSize = 0;
                OldFileMapped = NULL;
                }
            else {

                Success = MyMapViewOfFileByHandle(
                              OldFileInfoArray[ i ].OldFileHandle,
                              &OldFileSize,
                              &OldFileMapped
                              );

                if ( ! Success ) {
                    break;
                    }
                }

            //
            //  Before normalizing, compare to new file for exact match.
            //

            PatchDataSize = 0;
            PatchBuffer = NULL;
            OldFileCrc = 0;
            Success = FALSE;

            if (( OldFileSize != 0 ) && ( OldFileSize == NewFileSize )) {

                if (( SafeCompleteCrc32( OldFileMapped, OldFileSize, &OldFileCrc )) &&
                    ( OldFileCrc == NewFileCrc )) {

                    __try {
                        Success = ( memcmp( NewFileMapped, OldFileMapped, NewFileSize ) == 0 );
                        }
                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                        SetLastError( GetExceptionCode() );
                        Success = FALSE;
                        }
                    }
                }

            if ( ! Success ) {

                OldFileOriginalChecksum = 0;
                OldFileOriginalTimeDate = 0;
                OldFileNtHeader = NULL;

                __try {

                    OldFileNtHeader = GetNtHeader( OldFileMapped, OldFileSize );

                    if ( OldFileNtHeader ) {

                        OldFileOriginalChecksum = OldFileNtHeader->OptionalHeader.CheckSum;
                        OldFileOriginalTimeDate = OldFileNtHeader->FileHeader.TimeDateStamp;
                        }
                    }

                __except( EXCEPTION_EXECUTE_HANDLER ) {
                    }

                Success = NormalizeOldFileImageForPatching(
                              OldFileMapped,
                              OldFileSize,
                              OptionFlags,
                              OptionData,
                              NewFileCoffBase,
                              NewFileCoffTime,
                              OldFileInfoArray[ i ].IgnoreRangeCount,
                              OldFileInfoArray[ i ].IgnoreRangeArray,
                              OldFileInfoArray[ i ].RetainRangeCount,
                              OldFileInfoArray[ i ].RetainRangeArray
                              );

                if ( Success ) {

                    Success = SafeCompleteCrc32( OldFileMapped, OldFileSize, &OldFileCrc );

                    if ( Success ) {

                        //
                        //  Now determine if this old file is the same as any already
                        //  processed old files.
                        //

                        Success = FALSE;

                        for ( j = 0; j < HeaderOldFileCount; j++ ) {

                            if (( HeaderInfo.OldFileInfoArray[ j ].OldFileCrc  == OldFileCrc  ) &&
                                ( HeaderInfo.OldFileInfoArray[ j ].OldFileSize == OldFileSize ) &&
                                ( OldFileSize != 0 )) {

                                //
                                //  We have to remap the other old file here to make the
                                //  comparison.
                                //

                                PUCHAR CompareFileMapped;
                                ULONG  CompareFileSize;

                                Success = MyMapViewOfFileByHandle(
                                              HeaderInfo.OldFileInfoArray[ j ].OldFileHandle,
                                              &CompareFileSize,
                                              &CompareFileMapped
                                              );

                                if ( Success ) {

                                    ASSERT( CompareFileSize == HeaderInfo.OldFileInfoArray[ j ].OldFileSize );

                                    NormalizeOldFileImageForPatching(
                                        CompareFileMapped,
                                        CompareFileSize,
                                        OptionFlags,
                                        OptionData,
                                        NewFileCoffBase,
                                        NewFileCoffTime,
                                        HeaderInfo.OldFileInfoArray[ j ].IgnoreRangeCount,
                                        HeaderInfo.OldFileInfoArray[ j ].IgnoreRangeArray,
                                        HeaderInfo.OldFileInfoArray[ j ].RetainRangeCount,
                                        HeaderInfo.OldFileInfoArray[ j ].RetainRangeArray
                                        );

                                    __try {
                                        Success = ( memcmp( CompareFileMapped, OldFileMapped, OldFileSize ) == 0 );
                                        }
                                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                                        SetLastError( GetExceptionCode() );
                                        Success = FALSE;
                                        }

                                    UnmapViewOfFile( CompareFileMapped );

                                    if ( Success ) {
                                        goto SkipThisOldFile;
                                        }
                                    }
                                }
                            }

                        //
                        //  Now see if normalized old file is same as new file.
                        //

                        if (( NewFileCrc == OldFileCrc  ) && ( NewFileSize == OldFileSize ) && ( OldFileSize != 0 )) {

                            __try {
                                Success = ( memcmp( NewFileMapped, OldFileMapped, NewFileSize ) == 0 );
                                }
                            __except( EXCEPTION_EXECUTE_HANDLER ) {
                                SetLastError( GetExceptionCode() );
                                Success = FALSE;
                                }
                            }

                        if ( ! Success ) {

                            //
                            //  It's a unique file, so create the patch for it.
                            //
                            //  First we need to apply the transforms.
                            //

                            TransformedE8 = FALSE;
                            Transform     = TRUE;

                            //
                            //  NOTE: This test for NtHeader is a perf tweak
                            //        for non-coff files.  If we ever have any
                            //        transformations for non-coff files, this
                            //        test should be removed.
                            //

                            if (( NtHeader ) && ( OldFileNtHeader )) {

                                //
                                //  See if rift table already provided by
                                //  caller so we don't need to generate it.
                                //

                                if (( OptionData ) &&
                                    ( OptionData->SizeOfThisStruct >=
                                        ( offsetof( PATCH_OPTION_DATA, OldFileSymbolPathArray ) +
                                          sizeof( OptionData->OldFileSymbolPathArray ))) &&
                                    ( OptionData->SymbolOptionFlags & PATCH_SYMBOL_EXTERNAL_RIFT ) &&
                                    ( OptionData->OldFileSymbolPathArray ) &&
                                    ( OptionData->OldFileSymbolPathArray[ i ] )) {

                                    //
                                    //  This hidden private flag that tells us the rift information
                                    //  is already specified for us.  The LPCSTR pointer at
                                    //  OptionData->OldFileSymbolPathArray[ i ] is really a
                                    //  PRIFT_TABLE pointer.  Note that no validation of external
                                    //  rift data is performed (must be in ascending order with
                                    //  no OldRva duplicates).
                                    //
                                    //  We need to be careful to treat this external rift table
                                    //  differently in that we don't want to free the arrays
                                    //  like we do for our internally allocated rift tables.
                                    //  So, mark the RiftEntryAlloc field as zero to indicate
                                    //  that the rift arrays were not internally allocated.
                                    //

                                    PRIFT_TABLE ExternalRiftTable = (PVOID) OptionData->OldFileSymbolPathArray[ i ];

                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc = 0;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount = ExternalRiftTable->RiftEntryCount;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray = ExternalRiftTable->RiftEntryArray;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray = ExternalRiftTable->RiftUsageArray;
                                    }

                                else {

                                    //
                                    //  Need to allocate rift arrays and generate rift data.
                                    //  This (NewSize+OldSize) allocation will provide enough
                                    //  space for one rift entry for every byte in the files.
                                    //

                                    ULONG AllocCount = ( NewFileSize + OldFileSize );

                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount = 0;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc = AllocCount;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray = MyVirtualAlloc( AllocCount * sizeof( RIFT_ENTRY ));
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray = MyVirtualAlloc( AllocCount * sizeof( UCHAR ));

                                    if (( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray == NULL ) ||
                                        ( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray == NULL )) {

                                        Transform = FALSE;
                                        }

                                    else {

                                        Transform = GenerateRiftTable(
                                                        OldFileInfoArray[ i ].OldFileHandle,
                                                        OldFileMapped,
                                                        OldFileSize,
                                                        OldFileOriginalChecksum,
                                                        OldFileOriginalTimeDate,
                                                        NewFileHandle,
                                                        NewFileMapped,
                                                        NewFileSize,
                                                        OptionFlags,
                                                        OptionData,
                                                        i,
                                                        &HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable
                                                        );

                                        ASSERT( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount <= HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc );

#ifdef TESTCODE
                                        printf( "\r%9d unique rift entries generated\n", HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount );
#endif
                                        }
                                    }

                                if ( Transform ) {

                                    if ( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount != 0 ) {

                                        TransformedE8 = (( OldFileNtHeader ) && ( ! ( ExtendedOptionFlags & PATCH_TRANSFORM_NO_RELCALLS )));

                                        Transform = TransformOldFileImageForPatching(
                                                        &ExtendedOptionFlags,
                                                        OldFileMapped,
                                                        OldFileSize,
                                                        NewFileResTime,
                                                        &HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable
                                                        );
                                        }
                                    }
                                }

                            if ( Transform ) {

                                PatchBuffer = MyVirtualAlloc( PatchBufferSize );

                                if ( PatchBuffer != NULL ) {

                                    EstimatedLzxMemory = EstimateLzxCompressionMemoryRequirement(
                                                             OldFileSize,
                                                             NewFileSize,
                                                             OptionFlags,
                                                             MaxLzxWindowForce
                                                             );

                                    SubAllocatorHandle = CreateSubAllocator(
                                                             EstimatedLzxMemory,
                                                             MINIMUM_VM_ALLOCATION
                                                             );

                                    if ( SubAllocatorHandle != NULL ) {

                                        __try {
                                            ErrorCode = CreateRawLzxPatchDataFromBuffers(
                                                            OldFileMapped,
                                                            OldFileSize,
                                                            NewFileMapped,
                                                            NewFileSize,
                                                            PatchBufferSize,
                                                            PatchBuffer,
                                                            &PatchDataSize,
                                                            OptionFlags,
                                                            MaxLzxWindowForce,
                                                            InterleaveMapArray ? InterleaveMapArray[ i ] : NULL,
                                                            SubAllocate,
                                                            SubAllocatorHandle,
                                                            ProgressCallback,
                                                            CallbackContext,
                                                            ProgressPosition,
                                                            ProgressMaximum
                                                            );
                                            }
                                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                                            ErrorCode = GetExceptionCode();
                                            }

                                        DestroySubAllocator( SubAllocatorHandle );

                                        if ( ErrorCode == NO_ERROR ) {

                                            Success = TRUE;

                                            if ( TryLzxBoth ) {

                                                AltExtendedOptionFlags = ExtendedOptionFlags;

                                                if ( TransformedE8 ) {

                                                    //
                                                    //  Need to map, normalize, and transform
                                                    //  old file again without E8 transform.
                                                    //

                                                    AltExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELCALLS;

                                                    if ( OldFileMapped != NULL ) {

                                                        UnmapViewOfFile( OldFileMapped );
                                                        OldFileMapped = NULL;
                                                        }

                                                    if ( OldFileInfoArray[ 0 ].OldFileHandle == INVALID_HANDLE_VALUE ) {

                                                        OldFileSize = 0;
                                                        Success = TRUE;
                                                        }
                                                    else {

                                                        Success = MyMapViewOfFileByHandle(
                                                                      OldFileInfoArray[ i ].OldFileHandle,
                                                                      &OldFileSize,
                                                                      &OldFileMapped
                                                                      );
                                                        }

                                                    if ( Success ) {

                                                        Success = NormalizeOldFileImageForPatching(
                                                                      OldFileMapped,
                                                                      OldFileSize,
                                                                      OptionFlags,
                                                                      OptionData,
                                                                      NewFileCoffBase,
                                                                      NewFileCoffTime,
                                                                      OldFileInfoArray[ i ].IgnoreRangeCount,
                                                                      OldFileInfoArray[ i ].IgnoreRangeArray,
                                                                      OldFileInfoArray[ i ].RetainRangeCount,
                                                                      OldFileInfoArray[ i ].RetainRangeArray
                                                                      );

                                                        if ( Success ) {

                                                            if ( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount != 0 ) {

                                                                Success = TransformOldFileImageForPatching(
                                                                              &AltExtendedOptionFlags,
                                                                              OldFileMapped,
                                                                              OldFileSize,
                                                                              NewFileResTime,
                                                                              &HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable
                                                                              );
                                                                }
                                                            }
                                                        }
                                                    }

                                                if ( Success ) {

                                                    PatchAltBuffer = MyVirtualAlloc( PatchBufferSize );

                                                    if ( PatchAltBuffer != NULL ) {

                                                        SubAllocatorHandle = CreateSubAllocator(
                                                                                 EstimatedLzxMemory,
                                                                                 MINIMUM_VM_ALLOCATION
                                                                                 );

                                                        if ( SubAllocatorHandle != NULL ) {

                                                            ULONG ProgressStart = ProgressPosition +
                                                                                  NewFileSize +
                                                                                  LzxOldFileInsertSize(
                                                                                      OldFileSize,
                                                                                      OptionFlags,
                                                                                      MaxLzxWindowForce,
                                                                                      InterleaveMapArray ? InterleaveMapArray[ i ] : NULL
                                                                                      );

                                                            PatchAltSize = 0;   // prevent compiler warning

                                                            __try {
                                                                ErrorCode = CreateRawLzxPatchDataFromBuffers(
                                                                                OldFileMapped,
                                                                                OldFileSize,
                                                                                NewFileMapped,
                                                                                NewFileSize,
                                                                                PatchBufferSize,
                                                                                PatchAltBuffer,
                                                                                &PatchAltSize,
                                                                                OptionFlags | PATCH_OPTION_USE_LZX_B,
                                                                                MaxLzxWindowForce,
                                                                                InterleaveMapArray ? InterleaveMapArray[ i ] : NULL,
                                                                                SubAllocate,
                                                                                SubAllocatorHandle,
                                                                                ProgressCallback,
                                                                                CallbackContext,
                                                                                ProgressStart,
                                                                                ProgressMaximum
                                                                                );
                                                                }
                                                            __except( EXCEPTION_EXECUTE_HANDLER ) {
                                                                ErrorCode = GetExceptionCode();
                                                                }

                                                            DestroySubAllocator( SubAllocatorHandle );

                                                            if (( ErrorCode == NO_ERROR ) && ( PatchAltSize <= PatchDataSize )) {
                                                                MyVirtualFree( PatchBuffer );
                                                                PatchBuffer   = PatchAltBuffer;
                                                                PatchDataSize = PatchAltSize;
                                                                ExtendedOptionFlags = AltExtendedOptionFlags;
                                                                }
                                                            else {
                                                                MyVirtualFree( PatchAltBuffer );
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                        else {
                                            SetLastError( ErrorCode );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

            if ( Success ) {

                PatchArray[ HeaderOldFileCount ].PatchData = PatchBuffer;
                PatchArray[ HeaderOldFileCount ].PatchSize = PatchDataSize;

                if ( PatchDataSize == 0 ) {
                    ASSERT( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc == 0 );
                    ASSERT( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount == 0 );
                    ASSERT( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray == NULL );
                    ASSERT( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray == NULL );
                    }

                HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].OldFileHandle    = OldFileInfoArray[ i ].OldFileHandle;
                HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].OldFileSize      = OldFileSize;
                HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].OldFileCrc       = OldFileCrc;
                HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].PatchDataSize    = PatchDataSize;
                HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].IgnoreRangeCount = OldFileInfoArray[ i ].IgnoreRangeCount;
                HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].IgnoreRangeArray = OldFileInfoArray[ i ].IgnoreRangeArray;
                HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RetainRangeCount = OldFileInfoArray[ i ].RetainRangeCount;
                HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RetainRangeArray = OldFileInfoArray[ i ].RetainRangeArray;

                if (( InterleaveMapArray != NULL ) && ( PatchDataSize > 0 ))
                {
                    HeaderInfo.InterleaveMapArray[ HeaderOldFileCount ] = InterleaveMapArray[ i ];
                }

                //
                //  We overestimate (worst case) the possible
                //  header size here.  Note that typical rift
                //  encoding size is around 5 bytes per entry,
                //  but we expect that to decrease when we switch
                //  to Huffman encoding for the rift table.
                //

                HeaderSize += 32;
                HeaderSize += HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE );
                HeaderSize += HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RetainRangeCount * sizeof( PATCH_RETAIN_RANGE );
                HeaderSize += HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount * sizeof( RIFT_ENTRY );

                if ( HeaderInfo.InterleaveMapArray[ HeaderOldFileCount ] ) {
                    HeaderSize += HeaderInfo.InterleaveMapArray[ HeaderOldFileCount ]->CountRanges * sizeof( HeaderInfo.InterleaveMapArray[ HeaderOldFileCount ]->Range[ 0 ] );
                    }

                ++HeaderOldFileCount;
                }

SkipThisOldFile:

            if ( OldFileMapped != NULL ) {
                UnmapViewOfFile( OldFileMapped );
                OldFileMapped = NULL;
                }

            if ( Success ) {

                ULONG ProgressAmount = NewFileSize +
                                       LzxOldFileInsertSize(
                                           OldFileSize,
                                           OptionFlags,
                                           MaxLzxWindowForce,
                                           InterleaveMapArray ? InterleaveMapArray[ i ] : NULL
                                           );

                ProgressPosition += ProgressAmount * ( TryLzxBoth ? 2 : 1 );

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              ProgressPosition,
                              ProgressMaximum
                              );
                }

            if ( ! Success ) {
                break;
                }
            }

        if (( ! Success ) && ( GetLastError() == PATCH_ERROR_RETRY_NO_RESOURCE )) {

            DEBUGCODE( printf( "Resource transform failure, trying again with no resource transform\n" ));

            ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RESOURCE;

            goto RetryWithDifferentTransform;
            }
        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    if ( Success ) {

        if (( OptionFlags & PATCH_OPTION_FAIL_IF_SAME_FILE ) &&
            ( HeaderOldFileCount == 1 ) &&
            ( PatchArray[ 0 ].PatchSize == 0 )) {

            SetLastError( ERROR_PATCH_SAME_FILE );
            Success = FALSE;
            }
        }

    PatchBuffer   = NULL;
    PatchDataSize = 0;

    if ( Success ) {

        //
        //  Create header
        //

        Success = FALSE;

        HeaderSize = ROUNDUP2( HeaderSize, 0x10000 );

        PatchBuffer = MyVirtualAlloc( HeaderSize );

        if ( PatchBuffer != NULL ) {

            Success = TRUE;

            //
            //  Compute size of PatchData without the header.
            //

            PatchDataSize = 0;

            for ( i = 0; i < HeaderOldFileCount; i++ ) {
                PatchDataSize += PatchArray[ i ].PatchSize;
                }

            //
            //  Don't need to encode NewFileResTime if the patch is simply
            //  a header with no patch data (new file is same as old file).
            //  We do still need the NewFileCoffTime and NewFileCoffBase
            //  though because we still need to normalize the old file.
            //

            if ( PatchDataSize == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                NewFileResTime = 0;
                }

            //
            //  Don't need to set PATCH_OPTION_LZX_LARGE unless an LZX window larger
            //  than 8Mb was used.  This allows backwards compatibility by default for
            //  files smaller than 8Mb.
            //

            if ( OptionFlags & PATCH_OPTION_USE_LZX_LARGE ) {

                if ( LzxWindowSize( LargestOldFileSize, NewFileSize, OptionFlags, MaxLzxWindowForce ) <= LZX_MAXWINDOW_8 ) {

                    OptionFlags &= ~PATCH_OPTION_USE_LZX_LARGE;
                    }
                }

            //
            //  If no PE transformations performed, turn off PE transform bits
            //  in ExtendedOptionFlags so we don't needlessly encode extended
            //  options dword in header.
            //
            //  NOTE: It's important where we do this -- code below this may
            //  turn back on some bits in the ExtendedOptionFlags to indicate
            //  limited LZX window.
            //

            if ( ! ( ExtendedOptionFlags & PATCH_TRANSFORM_ANY_PE )) {
                ExtendedOptionFlags = 0;    // assumes all extended options flags are PE options
                }

            ExtendedOptionFlags &= ~PATCH_TRANSFORM_ANY_PE;     // don't encode this flag in header
            ExtendedOptionFlags &= ~PATCH_TRANSFORM_CREATION;   // don't encode this flag in header

            if ( MaxLzxWindowForce ) {

                ULONG WindowSizeConstrained;
                ULONG WindowSizeDefault;

                WindowSizeConstrained = LzxWindowSize(
                                            LargestOldFileSize,
                                            NewFileSize,
                                            OptionFlags,
                                            MaxLzxWindowForce
                                            );

                WindowSizeDefault     = LzxWindowSize(
                                            LargestOldFileSize,
                                            NewFileSize,
                                            OptionFlags,
                                            0
                                            );

                if ( WindowSizeConstrained < WindowSizeDefault ) {
                    HeaderInfo.WindowSize = WindowSizeConstrained;
                    ExtendedOptionFlags  |= PATCH_OPTION_SPECIFIED_WINDOW;
                    }
                else {
#ifdef TESTCODE
                    printf( "\rSpecified window size 0x%X (0x%X) not necessary to encode\n", MaxLzxWindowForce, WindowSizeConstrained );
#endif // TESTCODE
                    }
                }

            if ( HeaderInfo.WindowSize == 0 ) {
                ExtendedOptionFlags &= ~PATCH_OPTION_SPECIFIED_WINDOW;
                }

            if ( ExtendedOptionFlags ) {
                OptionFlags |=  PATCH_OPTION_EXTENDED_OPTIONS;
                }
            else {
                OptionFlags &= ~PATCH_OPTION_EXTENDED_OPTIONS;
                }

            HeaderInfo.Signature           = PATCH_SIGNATURE;
            HeaderInfo.OptionFlags         = OptionFlags;
            HeaderInfo.ExtendedOptionFlags = ExtendedOptionFlags;
            HeaderInfo.NewFileCoffBase     = NewFileCoffBase;
            HeaderInfo.NewFileCoffTime     = NewFileCoffTime;
            HeaderInfo.NewFileResTime      = NewFileResTime;
            HeaderInfo.NewFileSize         = NewFileSize;
            HeaderInfo.NewFileCrc          = NewFileCrc;
            HeaderInfo.OldFileCount        = HeaderOldFileCount;
            HeaderInfo.NewFileTime         = 0;

            if ( ! ( OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) {

                HeaderInfo.NewFileTime = FileTimeToUlongTime( &NewFileTime );
                PatchFileTime = NULL;
                }

            HeaderSize = EncodePatchHeader( &HeaderInfo, PatchBuffer );

            PatchDataSize += HeaderSize + sizeof( ULONG );

            //
            //  Now we know the size of the patch file, so if we want to
            //  make sure it's not bigger than just compressing the new
            //  file, we need to compress the new file to see (the output
            //  of the compression is discarded -- we just want to know
            //  how big it would be.  Obviously if the patch file is bigger
            //  than the raw new file, no need to compress the new file to
            //  see if that is smaller!
            //

            if ( OptionFlags & PATCH_OPTION_FAIL_IF_BIGGER ) {

                if ( PatchDataSize > NewFileSize ) {
                    SetLastError( ERROR_PATCH_BIGGER_THAN_COMPRESSED );
                    Success = FALSE;
                    }

                else {

                    EstimatedLzxMemory = EstimateLzxCompressionMemoryRequirement(
                                             0,
                                             NewFileSize,
                                             0,
                                             0x200000   // LZX CAB has only 2Mb window size
                                             );

                    SubAllocatorHandle = CreateSubAllocator(
                                             EstimatedLzxMemory,
                                             MINIMUM_VM_ALLOCATION
                                             );

                    if ( SubAllocatorHandle != NULL ) {

                        NewFileCompressedSize = 0;  // prevent compiler warning

                        __try {
                            ErrorCode = RawLzxCompressBuffer(
                                            NewFileMapped,
                                            NewFileSize,
                                            0,
                                            NULL,
                                            &NewFileCompressedSize,
                                            0x200000,   // LZX CAB has only 2Mb window size
                                            SubAllocate,
                                            SubAllocatorHandle,
                                            ProgressCallback,
                                            CallbackContext,
                                            ProgressPosition,
                                            ProgressMaximum
                                            );
                            }
                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                            ErrorCode = GetExceptionCode();
                            }

                        DestroySubAllocator( SubAllocatorHandle );

                        if ( ErrorCode == NO_ERROR ) {
                            if ( PatchDataSize > NewFileCompressedSize ) {
                                SetLastError( ERROR_PATCH_BIGGER_THAN_COMPRESSED );
                                Success = FALSE;
                                }
                            }
                        }
                    }

                if ( Success ) {

                    ProgressPosition += NewFileSize;

                    Success = ProgressCallbackWrapper(
                                  ProgressCallback,
                                  CallbackContext,
                                  ProgressPosition,
                                  ProgressMaximum
                                  );
                    }
                }
            }
        }

    if ( NewFileMapped != NULL ) {
        UnmapViewOfFile( NewFileMapped );
        NewFileMapped = NULL;
        }

    if ( Success ) {

        Success = MyCreateMappedFileByHandle(
                      PatchFileHandle,
                      PatchDataSize,
                      &PatchFileMapped
                      );

        if ( Success ) {

            __try {

                p = PatchFileMapped;
                CopyMemory( p, PatchBuffer, HeaderSize );
                p += HeaderSize;

                for ( i = 0; i < HeaderOldFileCount; i++ ) {
                    if ( PatchArray[ i ].PatchSize != 0 ) {
                        CopyMemory( p, PatchArray[ i ].PatchData, PatchArray[ i ].PatchSize );
                        p += PatchArray[ i ].PatchSize;
                        }
                    }

                PatchFileCrc = Crc32( 0xFFFFFFFF, PatchFileMapped, PatchDataSize - sizeof( ULONG ));

                *(UNALIGNED ULONG *)( PatchFileMapped + PatchDataSize - sizeof( ULONG )) = PatchFileCrc;

                }

            __except( EXCEPTION_EXECUTE_HANDLER ) {
                SetLastError( GetExceptionCode() );
                PatchDataSize = 0;
                Success = FALSE;
                }

            MyUnmapCreatedMappedFile(
                PatchFileHandle,
                PatchFileMapped,
                PatchDataSize,
                PatchFileTime
                );
            }
        }

    //
    //  Cleanup
    //

    if ( LocalSubAlloc ) {
        DestroySubAllocator( LocalSubAlloc );
        }

    if ( PatchBuffer ) {
        MyVirtualFree( PatchBuffer );
        }

    for ( i = 0; i < OldFileCount; i++ ) {
        if ( PatchArray[ i ].PatchData ) {
            MyVirtualFree( PatchArray[ i ].PatchData );
            }
        if ( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftEntryAlloc ) {
            if ( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftEntryArray ) {
                MyVirtualFree( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftEntryArray );
                }
            if ( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftUsageArray ) {
                MyVirtualFree( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftUsageArray );
                }
            }
        }

    if ( Success ) {
        ASSERT( ProgressPosition == ProgressMaximum );
        }

    if (( ! Success ) &&
        ( GetLastError() == ERROR_SUCCESS )) {

        SetLastError( ERROR_EXTENDED_ERROR );
        }

    return Success;
    }


BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    )
    {
    HANDLE PatchFileHandle;
    HANDLE HeaderFileHandle;
    BOOL   Success = FALSE;

    PatchFileHandle = CreateFileA(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_RANDOM_ACCESS,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        HeaderFileHandle = CreateFileA(
                               PatchHeaderFileName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );


        if ( HeaderFileHandle != INVALID_HANDLE_VALUE ) {

            Success = ExtractPatchHeaderToFileByHandles(
                          PatchFileHandle,
                          HeaderFileHandle
                          );

            CloseHandle( HeaderFileHandle );

            if ( ! Success ) {
                DeleteFileA( PatchHeaderFileName );
                }
            }

        CloseHandle( PatchFileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    )
    {
    HANDLE PatchFileHandle;
    HANDLE HeaderFileHandle;
    BOOL   Success = FALSE;

    PatchFileHandle = CreateFileW(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_RANDOM_ACCESS,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        HeaderFileHandle = CreateFileW(
                               PatchHeaderFileName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );


        if ( HeaderFileHandle != INVALID_HANDLE_VALUE ) {

            Success = ExtractPatchHeaderToFileByHandles(
                          PatchFileHandle,
                          HeaderFileHandle
                          );

            CloseHandle( HeaderFileHandle );

            if ( ! Success ) {
                DeleteFileW( PatchHeaderFileName );
                }
            }

        CloseHandle( PatchFileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    )
    {
    PPATCH_HEADER_INFO HeaderInfo;
    HANDLE   SubAllocator;
    PUCHAR   PatchFileMapped;
    FILETIME PatchFileTime;
    ULONG    PatchFileSize;
    ULONG    PatchFileCrc;
    ULONG    PatchHeaderSize;
    ULONG    ActualSize;
    ULONG    i;
    BOOL     Success;
    BOOL     Mapped;

    Success = FALSE;

    Mapped = MyMapViewOfFileByHandle(
                 PatchFileHandle,
                 &PatchFileSize,
                 &PatchFileMapped
                 );

    if ( Mapped ) {

        GetFileTime( PatchFileHandle, NULL, NULL, &PatchFileTime );

        PatchFileCrc = 0;

        SafeCompleteCrc32( PatchFileMapped, PatchFileSize, &PatchFileCrc );

        if ( PatchFileCrc == 0xFFFFFFFF ) {

            SubAllocator = CreateSubAllocator( 0x10000, 0x10000 );

            if ( SubAllocator ) {

                Success = DecodePatchHeader(
                              PatchFileMapped,
                              PatchFileSize,
                              SubAllocator,
                              &PatchHeaderSize,
                              &HeaderInfo
                              );

                if ( Success ) {

                    //
                    //  Header extraction is provided so that a header without
                    //  the bulk of the patch data can be used to determine if
                    //  an old file is correct for this patch header (can be
                    //  patched).
                    //
                    //  Since the extracted header will not be used to actually
                    //  apply, we don't need any of the header data that is
                    //  used only for transformation (RiftTable and NewResTime).
                    //  Since NewResTime is typically encoded as one byte (as
                    //  delta from NewCoffTime), we won't bother throwing it
                    //  away, but we will throw away the RiftTable.
                    //
                    //  The interleave map is also not needed for this, but
                    //  we want to leave the interleave flag on in the header
                    //  to make sure the applyer understands how to deal with
                    //  this flag.  This means each interleave map will contain
                    //  zero entries (cost one byte per old file in header).
                    //
                    //  Zero out the rift entry counts, then re-create the
                    //  patch header with the zeroed rift counts (create over
                    //  the write-copy mapped patch file buffer, then write
                    //  that buffer to disk).
                    //

                    for ( i = 0; i < HeaderInfo->OldFileCount; i++ ) {

                        HeaderInfo->OldFileInfoArray[ i ].RiftTable.RiftEntryCount = 0;

                        if ( HeaderInfo->InterleaveMapArray ) {
                             HeaderInfo->InterleaveMapArray[ i ] = NULL;
                             }
                        }

                    __try {

                        PatchHeaderSize = EncodePatchHeader( HeaderInfo, PatchFileMapped );

                        PatchFileCrc = Crc32( 0xFFFFFFFF, PatchFileMapped, PatchHeaderSize );

                        *(UNALIGNED ULONG *)( PatchFileMapped + PatchHeaderSize ) = PatchFileCrc;

                        Success = WriteFile(
                                      PatchHeaderFileHandle,
                                      PatchFileMapped,
                                      PatchHeaderSize + sizeof( ULONG ),
                                      &ActualSize,
                                      NULL
                                      );
                        }

                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                        SetLastError( GetExceptionCode() );
                        Success = FALSE;
                        }

                    if ( Success ) {
                        SetFileTime( PatchHeaderFileHandle, NULL, NULL, &PatchFileTime );
                        }
                    }

                DestroySubAllocator( SubAllocator );
                }
            }

        else {
            SetLastError( ERROR_PATCH_CORRUPT );
            }

        UnmapViewOfFile( PatchFileMapped );
        }

    return Success;
    }


#endif // ! PATCH_APPLY_CODE_ONLY


//
//  Following group of functions and exported apis are exclusively for
//  applying patches.  If we're only compiling the create code, ignore
//  this group of functions.
//

#ifndef PATCH_CREATE_CODE_ONLY

PVOID
SaveRetainRanges(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN ULONG  RetainRangeCount,
    IN PPATCH_RETAIN_RANGE RetainRangeArray,
    IN BOOL   SaveFromNewFile
    )
    {
    PUCHAR Buffer, p;
    ULONG  Offset;
    ULONG  TotalSize = 0;
    ULONG  i;

    for ( i = 0; i < RetainRangeCount; i++ ) {
        TotalSize += RetainRangeArray[ i ].LengthInBytes;
        }

    Buffer = MyVirtualAlloc( TotalSize );

    if ( Buffer ) {

        __try {

            p = Buffer;

            for ( i = 0; i < RetainRangeCount; i++ ) {

                Offset = SaveFromNewFile ?
                             RetainRangeArray[ i ].OffsetInNewFile :
                             RetainRangeArray[ i ].OffsetInOldFile;

                if (( Offset + RetainRangeArray[ i ].LengthInBytes ) <= FileSize ) {
                    CopyMemory( p, MappedFile + Offset, RetainRangeArray[ i ].LengthInBytes );
                    }

                p += RetainRangeArray[ i ].LengthInBytes;
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( GetExceptionCode() );
            MyVirtualFree( Buffer );
            Buffer = NULL;
            }
        }

    return Buffer;
    }


BOOL
CreateNewFileFromOldFileMapped(
    IN  PUCHAR                   OldFileMapped,
    IN  ULONG                    OldFileSize,
    OUT HANDLE                   NewFileHandle,
    IN  PFILETIME                NewFileTime,
    IN  ULONG                    NewFileExpectedCrc,
    IN  ULONG                    RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE      RetainRangeArray,
    IN  PUCHAR                   RetainBuffer,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PUCHAR NewFileMapped;
    ULONG  NewFileCrc;
    BOOL   Success;
    ULONG  i;

    Success = MyCreateMappedFileByHandle(
                  NewFileHandle,
                  OldFileSize,
                  &NewFileMapped
                  );

    if ( Success ) {

        __try {

            CopyMemory( NewFileMapped, OldFileMapped, OldFileSize );

            NewFileCrc = Crc32( 0xFFFFFFFF, NewFileMapped, OldFileSize ) ^ 0xFFFFFFFF;

            if ( NewFileCrc == NewFileExpectedCrc ) {

                for ( i = 0; i < RetainRangeCount; i++ ) {
                    if (( RetainRangeArray[ i ].OffsetInNewFile + RetainRangeArray[ i ].LengthInBytes ) <= OldFileSize ) {
                        CopyMemory(
                            RetainRangeArray[ i ].OffsetInNewFile + NewFileMapped,
                            RetainBuffer,
                            RetainRangeArray[ i ].LengthInBytes
                            );
                        }
                    RetainBuffer += RetainRangeArray[ i ].LengthInBytes;
                    }

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              OldFileSize,
                              OldFileSize
                              );
                }

            else {
                SetLastError( ERROR_PATCH_WRONG_FILE );
                OldFileSize = 0;
                Success = FALSE;
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( GetExceptionCode());
            OldFileSize = 0;
            Success = FALSE;
            }

        MyUnmapCreatedMappedFile(
            NewFileHandle,
            NewFileMapped,
            OldFileSize,
            NewFileTime
            );
        }

    return Success;
    }


BOOL
CreateNewFileFromPatchData(
    IN  PUCHAR                   OldFileMapped,
    IN  ULONG                    OldFileSize,
    IN  PUCHAR                   PatchData,
    IN  ULONG                    PatchDataSize,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    NewFileSize,
    IN  PFILETIME                NewFileTime,
    IN  ULONG                    NewFileExpectedCrc,
    IN  ULONG                    RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE      RetainRangeArray,
    IN  PUCHAR                   RetainBuffer,
    IN  ULONG                    OptionFlags,
    IN  PVOID                    OptionData,
    IN  ULONG                    WindowSize,
    IN  PPATCH_INTERLEAVE_MAP    InterleaveMap,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    HANDLE SubAllocatorHandle;
    ULONG  EstimatedLzxMemory;
    PUCHAR NewFileMapped;
    ULONG  NewFileCrc;
    ULONG  ErrorCode;
    BOOL   Success;
    ULONG  i;

    UNREFERENCED_PARAMETER( OptionData );

    Success = MyCreateMappedFileByHandle(
                  NewFileHandle,
                  NewFileSize,
                  &NewFileMapped
                  );

    if ( Success ) {

        ErrorCode = NO_ERROR;

        EstimatedLzxMemory = EstimateLzxDecompressionMemoryRequirement(
                                 OldFileSize,
                                 NewFileSize,
                                 OptionFlags,
                                 WindowSize
                                 );

        SubAllocatorHandle = CreateSubAllocator(
                                 EstimatedLzxMemory,
                                 MINIMUM_VM_ALLOCATION
                                 );

        if ( SubAllocatorHandle != NULL ) {

            __try {

                ErrorCode = ApplyRawLzxPatchToBuffer(
                                OldFileMapped,
                                OldFileSize,
                                PatchData,
                                PatchDataSize,
                                NewFileMapped,
                                NewFileSize,
                                OptionFlags,
                                WindowSize,
                                InterleaveMap,
                                SubAllocate,
                                SubAllocatorHandle,
                                ProgressCallback,
                                CallbackContext,
                                0,
                                NewFileSize
                                );

                if ( ErrorCode == NO_ERROR ) {

                    NewFileCrc = Crc32( 0xFFFFFFFF, NewFileMapped, NewFileSize ) ^ 0xFFFFFFFF;

                    if ( NewFileCrc == NewFileExpectedCrc ) {

                        for ( i = 0; i < RetainRangeCount; i++ ) {
                            if (( RetainRangeArray[ i ].OffsetInNewFile + RetainRangeArray[ i ].LengthInBytes ) <= OldFileSize ) {
                                CopyMemory(
                                    RetainRangeArray[ i ].OffsetInNewFile + NewFileMapped,
                                    RetainBuffer,
                                    RetainRangeArray[ i ].LengthInBytes
                                    );
                                }
                            RetainBuffer += RetainRangeArray[ i ].LengthInBytes;
                            }
                        }

                    else {

                        ErrorCode = ERROR_PATCH_WRONG_FILE;

                        }
                    }

#ifdef TESTCODE

                if ( ErrorCode != NO_ERROR ) {

                    HANDLE hFile = CreateFile(
                                       "Wrong.out",
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL
                                       );

                    if ( hFile != INVALID_HANDLE_VALUE ) {

                        DWORD Actual;

                        WriteFile( hFile, NewFileMapped, NewFileSize, &Actual, NULL );

                        CloseHandle( hFile );

                        }
                    }

#endif // TESTCODE

                }

            __except( EXCEPTION_EXECUTE_HANDLER ) {
                ErrorCode = GetExceptionCode();
                }

            DestroySubAllocator( SubAllocatorHandle );
            }

        MyUnmapCreatedMappedFile(
            NewFileHandle,
            NewFileMapped,
            ( ErrorCode == NO_ERROR ) ? NewFileSize : 0,
            NewFileTime
            );

        if ( ErrorCode == NO_ERROR ) {
            Success = TRUE;
            }
        else {
            SetLastError( ErrorCode );
            Success = FALSE;
            }
        }

    return Success;
    }


BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PHEADER_OLD_FILE_INFO OldFileInfo;
    PPATCH_HEADER_INFO HeaderInfo;
    PPATCH_RETAIN_RANGE RetainRangeArray;
    ULONG    RetainRangeCount;
    PUCHAR   RetainBuffer;
    HANDLE   SubAllocator;
    ULONG    PatchHeaderSize;
    FILETIME NewFileTime;
    PUCHAR   PatchFileMapped;
    ULONG    PatchFileSize;
    ULONG    PatchFileCrc;
    PUCHAR   PatchData;
    PUCHAR   OldFileMapped;
    ULONG    OldFileSize;
    ULONG    OldFileCrc;
    BOOL     Mapped;
    BOOL     Success;
    BOOL     Finished;
    ULONG    i;

    Success = FALSE;

    Mapped = MyMapViewOfFileByHandle(
                 PatchFileHandle,
                 &PatchFileSize,
                 &PatchFileMapped
                 );

    if ( Mapped ) {

        GetFileTime( PatchFileHandle, NULL, NULL, &NewFileTime );

        PatchFileCrc = 0;

        SafeCompleteCrc32( PatchFileMapped, PatchFileSize, &PatchFileCrc );

        if ( PatchFileCrc == 0xFFFFFFFF ) {

            SubAllocator = CreateSubAllocator( 0x10000, 0x10000 );

            if ( SubAllocator ) {

                Success = DecodePatchHeader(
                              PatchFileMapped,
                              PatchFileSize,
                              SubAllocator,
                              &PatchHeaderSize,
                              &HeaderInfo
                              );

                if ( Success ) {

                    //
                    //  Patch is valid.
                    //

                    Success = ProgressCallbackWrapper(
                                  ProgressCallback,
                                  CallbackContext,
                                  0,
                                  HeaderInfo->NewFileSize
                                  );

                    if ( Success ) {

                        Finished = FALSE;
                        Success  = FALSE;

                        if (( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) &&
                            ( HeaderInfo->NewFileTime != 0 )) {

                            UlongTimeToFileTime( HeaderInfo->NewFileTime, &NewFileTime );
                            }

                        if ( OldFileHandle == INVALID_HANDLE_VALUE ) {

                            OldFileSize = 0;
                            }
                        else {

                            OldFileSize = GetFileSize( OldFileHandle, NULL );
                            }

                        //
                        //  First see if the old file is really the new file.
                        //

                        if ( OldFileSize == HeaderInfo->NewFileSize ) {

                            if ( OldFileHandle == INVALID_HANDLE_VALUE ) {

                                OldFileMapped = NULL;
                                Mapped = TRUE;
                                }
                            else {

                                Mapped = MyMapViewOfFileByHandle(
                                             OldFileHandle,
                                             &OldFileSize,
                                             &OldFileMapped
                                             );
                                }

                            if ( ! Mapped ) {
                                Success  = FALSE;
                                Finished = TRUE;
                                }

                            else {

                                RetainBuffer     = NULL;
                                OldFileCrc       = 0;
                                OldFileInfo      = &HeaderInfo->OldFileInfoArray[ 0 ];
                                RetainRangeCount = OldFileInfo->RetainRangeCount;
                                RetainRangeArray = OldFileInfo->RetainRangeArray;

                                if (( RetainRangeCount != 0 ) &&
                                    ( ! ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ))) {

                                    RetainBuffer = SaveRetainRanges(
                                                       OldFileMapped,
                                                       OldFileSize,
                                                       RetainRangeCount,
                                                       RetainRangeArray,
                                                       TRUE
                                                       );

                                    if ( RetainBuffer == NULL ) {
                                        Finished = TRUE;
                                        }
                                    }

                                if ( ! Finished ) {

                                    __try {

                                        //
                                        //  First see if they match exact, without
                                        //  normalizing.
                                        //

                                        for ( i = 0; i < RetainRangeCount; i++ ) {
                                            if (( RetainRangeArray[ i ].OffsetInNewFile + RetainRangeArray[ i ].LengthInBytes ) <= OldFileSize ) {
                                                ZeroMemory( OldFileMapped + RetainRangeArray[ i ].OffsetInNewFile, RetainRangeArray[ i ].LengthInBytes );
                                                }
                                            }

                                        OldFileCrc = Crc32( 0xFFFFFFFF, OldFileMapped, OldFileSize ) ^ 0xFFFFFFFF;

                                        if ( OldFileCrc != HeaderInfo->NewFileCrc ) {

                                            //
                                            //  Don't match exact, so try with
                                            //  normalizing.
                                            //
                                            //  NOTE: We're assuming here that the
                                            //  zeroed retain ranges don't overlap
                                            //  with the binding info that we're
                                            //  correcting.
                                            //

                                            NormalizeOldFileImageForPatching(
                                                OldFileMapped,
                                                OldFileSize,
                                                HeaderInfo->OptionFlags,
                                                NULL,   // we don't tunnel any OptionData currently
                                                HeaderInfo->NewFileCoffBase,
                                                HeaderInfo->NewFileCoffTime,
                                                0,
                                                NULL,
                                                0,
                                                NULL
                                                );

                                            OldFileCrc = Crc32( 0xFFFFFFFF, OldFileMapped, OldFileSize ) ^ 0xFFFFFFFF;
                                            }
                                        }

                                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                                        SetLastError( GetExceptionCode() );
                                        Finished = TRUE;
                                        }

                                    if (( ! Finished ) &&
                                        ( OldFileCrc  == HeaderInfo->NewFileCrc  ) &&
                                        ( OldFileSize == HeaderInfo->NewFileSize )) {

                                        Finished = TRUE;

                                        if ( ApplyOptionFlags & APPLY_OPTION_FAIL_IF_EXACT ) {
                                            SetLastError( ERROR_PATCH_NOT_NECESSARY );
                                            Success = FALSE;
                                            }
                                        else if ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ) {
                                            Success = TRUE;
                                            }
                                        else if ( HeaderInfo->NewFileSize == 0 ) {
                                            SetFileTime( NewFileHandle, NULL, NULL, &NewFileTime );
                                            Success = TRUE;
                                            }
                                        else {
                                            Success = CreateNewFileFromOldFileMapped(
                                                          OldFileMapped,
                                                          OldFileSize,
                                                          NewFileHandle,
                                                          &NewFileTime,
                                                          HeaderInfo->NewFileCrc,
                                                          RetainRangeCount,
                                                          RetainRangeArray,
                                                          RetainBuffer,
                                                          ProgressCallback,
                                                          CallbackContext
                                                          );
                                            }
                                        }

                                    if ( RetainBuffer != NULL ) {
                                        MyVirtualFree( RetainBuffer );
                                        }
                                    }

                                if ( OldFileMapped != NULL ) {
                                    UnmapViewOfFile( OldFileMapped );
                                    }
                                }
                            }

                        if ( ! Finished ) {

                            //
                            //  Now see if the old file matches one of the old
                            //  files we have in our patch file.  For each set
                            //  of old file info in our patch file, we have to
                            //  remap the old file to check it since each old
                            //  file might have different ignore range parameters
                            //  (we modify the buffer for the ignore ranges).
                            //

                            PatchData = PatchFileMapped + PatchHeaderSize;
                            Success   = FALSE;

                            for ( i = 0; ( i < HeaderInfo->OldFileCount ) && ( ! Finished ) && ( ! Success ); i++ ) {

                                OldFileInfo = &HeaderInfo->OldFileInfoArray[ i ];

                                if ( OldFileInfo->OldFileSize == OldFileSize ) {

                                    if ( OldFileHandle == INVALID_HANDLE_VALUE ) {

                                        OldFileMapped = NULL;
                                        Mapped = TRUE;
                                        }
                                    else {

                                        Mapped = MyMapViewOfFileByHandle(
                                                     OldFileHandle,
                                                     &OldFileSize,
                                                     &OldFileMapped
                                                     );
                                        }

                                    if ( ! Mapped ) {
                                        Finished = TRUE;
                                        }

                                    else {

                                        RetainBuffer = NULL;

                                        if (( OldFileInfo->RetainRangeCount != 0 ) &&
                                            ( ! ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ))) {

                                            RetainBuffer = SaveRetainRanges(
                                                               OldFileMapped,
                                                               OldFileSize,
                                                               OldFileInfo->RetainRangeCount,
                                                               OldFileInfo->RetainRangeArray,
                                                               FALSE
                                                               );

                                            if ( RetainBuffer == NULL ) {
                                                Finished = TRUE;
                                                }
                                            }

                                        if ( ! Finished ) {

                                            NormalizeOldFileImageForPatching(
                                                OldFileMapped,
                                                OldFileSize,
                                                HeaderInfo->OptionFlags,
                                                NULL,   // we don't tunnel any OptionData currently
                                                HeaderInfo->NewFileCoffBase,
                                                HeaderInfo->NewFileCoffTime,
                                                OldFileInfo->IgnoreRangeCount,
                                                OldFileInfo->IgnoreRangeArray,
                                                OldFileInfo->RetainRangeCount,
                                                OldFileInfo->RetainRangeArray
                                                );

                                            OldFileCrc = 0;

                                            if (( SafeCompleteCrc32( OldFileMapped, OldFileSize, &OldFileCrc )) &&
                                                ( OldFileCrc  == OldFileInfo->OldFileCrc  ) &&
                                                ( OldFileSize == OldFileInfo->OldFileSize )) {

                                                //
                                                //  CRC's match
                                                //

                                                if ( HeaderInfo->NewFileSize == 0 ) {

                                                    if (( OldFileSize == 0 ) && ( ApplyOptionFlags & APPLY_OPTION_FAIL_IF_CLOSE )) {
                                                        SetLastError( ERROR_PATCH_NOT_NECESSARY );
                                                        Finished = TRUE;
                                                        }
                                                    else if ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ) {
                                                        Success = TRUE;
                                                        }
                                                    else {
                                                        //already zero length
                                                        SetFileTime( NewFileHandle, NULL, NULL, &NewFileTime );
                                                        Success = TRUE;
                                                        }
                                                    }
                                                else if ( OldFileInfo->PatchDataSize == 0 ) {

                                                    if (( OldFileSize == HeaderInfo->NewFileSize ) && ( ApplyOptionFlags & APPLY_OPTION_FAIL_IF_CLOSE )) {
                                                        SetLastError( ERROR_PATCH_NOT_NECESSARY );
                                                        Finished = TRUE;
                                                        }
                                                    else if ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ) {
                                                        Success = TRUE;
                                                        }
                                                    else {
                                                        Success = CreateNewFileFromOldFileMapped(
                                                                      OldFileMapped,
                                                                      OldFileSize,
                                                                      NewFileHandle,
                                                                      &NewFileTime,
                                                                      HeaderInfo->NewFileCrc,
                                                                      OldFileInfo->RetainRangeCount,
                                                                      OldFileInfo->RetainRangeArray,
                                                                      RetainBuffer,
                                                                      ProgressCallback,
                                                                      CallbackContext
                                                                      );
                                                        if ( ! Success ) {
                                                            Finished = TRUE;
                                                            }
                                                        }
                                                    }

                                                else {

                                                    if ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ) {
                                                        Success = TRUE;
                                                        }
                                                    else if (( PatchData + OldFileInfo->PatchDataSize ) > ( PatchFileMapped + PatchFileSize )) {
                                                        SetLastError( ERROR_PATCH_NOT_AVAILABLE );
                                                        Finished = TRUE;
                                                        }
                                                    else {

                                                        Success = TRUE;

                                                        if ( OldFileInfo->RiftTable.RiftEntryCount != 0 ) {

                                                            Success = TransformOldFileImageForPatching(
                                                                          &HeaderInfo->ExtendedOptionFlags,
                                                                          OldFileMapped,
                                                                          OldFileSize,
                                                                          HeaderInfo->NewFileResTime,
                                                                          &OldFileInfo->RiftTable
                                                                          );
                                                            }

                                                        if ( Success ) {

                                                            Success = CreateNewFileFromPatchData(
                                                                           OldFileMapped,
                                                                           OldFileSize,
                                                                           PatchData,
                                                                           OldFileInfo->PatchDataSize,
                                                                           NewFileHandle,
                                                                           HeaderInfo->NewFileSize,
                                                                           &NewFileTime,
                                                                           HeaderInfo->NewFileCrc,
                                                                           OldFileInfo->RetainRangeCount,
                                                                           OldFileInfo->RetainRangeArray,
                                                                           RetainBuffer,
                                                                           HeaderInfo->OptionFlags,
                                                                           NULL, /* no option data */
                                                                           HeaderInfo->WindowSize,
                                                                           HeaderInfo->InterleaveMapArray ? HeaderInfo->InterleaveMapArray[ i ] : NULL,
                                                                           ProgressCallback,
                                                                           CallbackContext
                                                                           );
                                                            }

                                                        if ( ! Success ) {
                                                            Finished = TRUE;
                                                            }
                                                        }
                                                    }
                                                }

                                            if ( RetainBuffer != NULL ) {
                                                MyVirtualFree( RetainBuffer );
                                                }
                                            }

                                        if ( OldFileMapped != NULL ) {

                                            UnmapViewOfFile( OldFileMapped );
                                            }
                                        }
                                    }

                                PatchData += OldFileInfo->PatchDataSize;
                                }

                            if (( ! Finished ) && ( ! Success )) {
                                SetLastError( ERROR_PATCH_WRONG_FILE );
                                }
                            }
                        }
                    }

                DestroySubAllocator( SubAllocator );
                }
            }

        else {
            SetLastError( ERROR_PATCH_CORRUPT );
            }

        UnmapViewOfFile( PatchFileMapped );
        }

    if (( ! Success ) &&
        ( GetLastError() == ERROR_SUCCESS )) {

        SetLastError( ERROR_EXTENDED_ERROR );
        }

    return Success;
    }


BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileByHandles(
               PatchFileHandle,
               OldFileHandle,
               INVALID_HANDLE_VALUE,
               ApplyOptionFlags | APPLY_OPTION_TEST_ONLY
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileByHandlesEx(
               PatchFileHandle,
               OldFileHandle,
               NewFileHandle,
               ApplyOptionFlags,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileA(
               PatchFileName,
               OldFileName,
               INVALID_HANDLE_VALUE,
               ApplyOptionFlags | APPLY_OPTION_TEST_ONLY
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileExA(
               PatchFileName,
               OldFileName,
               NewFileName,
               ApplyOptionFlags,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    HANDLE PatchFileHandle;
    HANDLE OldFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success = FALSE;

    if ( OldFileName == NULL ) {

        OldFileHandle = INVALID_HANDLE_VALUE;
        }
    else {

        OldFileHandle = CreateFileA(
                            OldFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( OldFileHandle == INVALID_HANDLE_VALUE ) {

            return Success;
            }
        }

    PatchFileHandle = CreateFileA(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        NewFileHandle = CreateFileA(
                            NewFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

            Success = ApplyPatchToFileByHandlesEx(
                          PatchFileHandle,
                          OldFileHandle,
                          NewFileHandle,
                          ApplyOptionFlags,
                          ProgressCallback,
                          CallbackContext
                          );

            CloseHandle( NewFileHandle );

            if ( ! Success ) {
                DeleteFileA( NewFileName );
                }
            }

        CloseHandle( PatchFileHandle );
        }

    if ( OldFileHandle != INVALID_HANDLE_VALUE ) {

        CloseHandle( OldFileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    )
    {
    return ApplyPatchToFileW(
               PatchFileName,
               OldFileName,
               INVALID_HANDLE_VALUE,
               ApplyOptionFlags | APPLY_OPTION_TEST_ONLY
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    )
    {
    return ApplyPatchToFileExW(
               PatchFileName,
               OldFileName,
               NewFileName,
               ApplyOptionFlags,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    HANDLE PatchFileHandle;
    HANDLE OldFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success = FALSE;

    if ( OldFileName == NULL ) {

        OldFileHandle = INVALID_HANDLE_VALUE;
        }
    else {

        OldFileHandle = CreateFileW(
                            OldFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( OldFileHandle == INVALID_HANDLE_VALUE ) {

            return Success;
            }
        }

    PatchFileHandle = CreateFileW(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        NewFileHandle = CreateFileW(
                            NewFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

            Success = ApplyPatchToFileByHandlesEx(
                          PatchFileHandle,
                          OldFileHandle,
                          NewFileHandle,
                          ApplyOptionFlags,
                          ProgressCallback,
                          CallbackContext
                          );

            CloseHandle( NewFileHandle );

            if ( ! Success ) {
                DeleteFileW( NewFileName );
                }
            }

        CloseHandle( PatchFileHandle );
        }

    if ( OldFileHandle != INVALID_HANDLE_VALUE ) {

        CloseHandle( OldFileHandle );
        }

    return Success;
    }

#endif // ! PATCH_CREATE_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\pestuff.h ===
#ifndef _PATCH_PESTUFF_H_
#define _PATCH_PESTUFF_H_

#ifdef __cplusplus
extern "C" {
#endif

PIMAGE_NT_HEADERS
__fastcall
GetNtHeader(
    IN PVOID MappedFile,
    IN ULONG MappedFileSize
    );

BOOL
NormalizeCoffImage(
    IN OUT PIMAGE_NT_HEADERS NtHeader,
    IN OUT PUCHAR            MappedFile,
    IN     ULONG             FileSize,
    IN     ULONG             OptionFlags,
    IN     PVOID             OptionData,
    IN     ULONG             NewFileCoffBase,
    IN     ULONG             NewFileCoffTime
    );

BOOL
TransformCoffImage(
    IN OUT PULONG            TransformOptions,
    IN OUT PIMAGE_NT_HEADERS NtHeader,
    IN OUT PUCHAR            OldFileMapped,
    IN     ULONG             OldFileSize,
    IN     ULONG             NewFileResTime,
    IN OUT PRIFT_TABLE       RiftTable,
    IN OUT PUCHAR OPTIONAL   HintMap,
    ...
    );

BOOL
GenerateRiftTable(
    IN HANDLE OldFileHandle,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN ULONG  OldFileOriginalChecksum,
    IN ULONG  OldFileOriginalTimeDate,
    IN HANDLE NewFileHandle,
    IN PUCHAR NewFileMapped,
    IN ULONG  NewFileSize,
    IN ULONG  OptionFlags,
    IN PVOID  OptionData,
    IN ULONG  OldFileIndex,
    IN PVOID  RiftTable
    );

BOOL
AddRiftEntryToTable(
    IN PRIFT_TABLE RiftTable,
    IN ULONG       OldRva,
    IN ULONG       NewRva
    );

VOID
InitImagehlpCritSect(
    VOID
    );

VOID
UnloadImagehlp(
    VOID
    );

#define X86_OPCODE_NOP  0x90
#define X86_OPCODE_LOCK 0xF0

BOOL
SmashLockPrefixesInMappedImage(
    IN PUCHAR            MappedFile,
    IN ULONG             FileSize,
    IN PIMAGE_NT_HEADERS NtHeader,
    IN UCHAR             NewOpCode      // X86_OPCODE_NOP or X86_OPCODE_LOCK
    );

USHORT
ChkSum(
    IN USHORT  Initial,
    IN PUSHORT Buffer,
    IN ULONG   Bytes
    );

PVOID
__fastcall
ImageDirectoryMappedAddress(
    IN  PIMAGE_NT_HEADERS NtHeader,
    IN  ULONG             DirectoryIndex,
    OUT PULONG OPTIONAL   DirectorySize,
    IN  PUCHAR            MappedBase,
    IN  ULONG             MappedSize
    );


#ifdef __cplusplus
}
#endif

#endif // _PATCH_PESTUFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\patchprv.h ===
//
//  patchprv.h
//
//  Private interface options for creating patch files.
//
//  Author: Tom McGuire (tommcg) 2/98
//
//  Copyright (C) Microsoft, 1997-2000.
//
//  MICROSOFT CONFIDENTIAL
//

#ifndef _PATCHPRV_H_
#define _PATCHPRV_H_

#ifdef __cplusplus
extern "C" {
#endif

#define PATCH_SIGNATURE     '91AP'          // PA19 patch signature

#define PATCH_VERSION_TEXT  "5.2.9347.0"

#define PATCH_RESOURCE_VER  5,2,9347,0      // major, minor, build#, qfe#

//
//  DONT FORGET TO CHANGE THE DLL VERSION NUMBER IN SRC_DLL.INC !!!!
//


typedef struct _RIFT_ENTRY {
    ULONG OldFileRva;
    ULONG NewFileRva;
    } RIFT_ENTRY, *PRIFT_ENTRY;

typedef struct _RIFT_TABLE {
    ULONG       RiftEntryCount;
    ULONG       RiftEntryAlloc;
    PRIFT_ENTRY RiftEntryArray;
    PUCHAR      RiftUsageArray;
    } RIFT_TABLE, *PRIFT_TABLE;

typedef struct _PATCH_HEADER_OLD_FILE_INFO {
    HANDLE              OldFileHandle;
    ULONG               OldFileSize;
    ULONG               OldFileCrc;
    ULONG               PatchDataSize;
    ULONG               IgnoreRangeCount;
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;
    PPATCH_RETAIN_RANGE RetainRangeArray;
    RIFT_TABLE          RiftTable;
    } HEADER_OLD_FILE_INFO, *PHEADER_OLD_FILE_INFO;

typedef struct _PATCH_HEADER_INFO {
    ULONG Signature;
    ULONG OptionFlags;
    ULONG ExtendedOptionFlags;
    ULONG NewFileCoffBase;
    ULONG NewFileCoffTime;
    ULONG NewFileResTime;
    ULONG NewFileTime;
    ULONG NewFileSize;
    ULONG NewFileCrc;
    ULONG OldFileCount;
    PHEADER_OLD_FILE_INFO OldFileInfoArray;
    PPATCH_INTERLEAVE_MAP* InterleaveMapArray;
    ULONG WindowSize;
    } PATCH_HEADER_INFO, *PPATCH_HEADER_INFO;


BOOL
ProgressCallbackWrapper(
    IN PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN PVOID                    CallbackContext,
    IN ULONG                    CurrentPosition,
    IN ULONG                    MaximumPosition
    );

BOOL
WINAPIV
NormalizeOldFileImageForPatching(
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN ULONG OptionFlags,
    IN PVOID OptionData,
    IN ULONG NewFileCoffBase,
    IN ULONG NewFileCoffTime,
    IN ULONG IgnoreRangeCount,
    IN PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN ULONG RetainRangeCount,
    IN PPATCH_RETAIN_RANGE RetainRangeArray,
    ...
    );

BOOL
WINAPIV
TransformOldFileImageForPatching(
    IN OUT PULONG TransformOptions,
    IN OUT PVOID  OldFileMapped,
    IN     ULONG  OldFileSize,
    IN     ULONG  NewFileResTime,
    IN     PRIFT_TABLE RiftTable,
    ...
    );

BOOL
DecodePatchHeader(
    IN  PVOID               PatchHeader,
    IN  ULONG               PatchHeaderMaxSize,
    IN  HANDLE              SubAllocator,
    OUT PULONG              PatchHeaderActualSize,
    OUT PPATCH_HEADER_INFO *HeaderInfo
    );

ULONG
EncodePatchHeader(
    IN  PPATCH_HEADER_INFO HeaderInfo,
    OUT PVOID              PatchHeaderBuffer
    );

//
//  The following is a private flag to indicate external rift data is being
//  specified in the OptionData->OldFileSymbolPathArray[ OldFileIndex ] field
//  (really a PRIFT_TABLE pointer).
//

#define PATCH_SYMBOL_EXTERNAL_RIFT      PATCH_SYMBOL_RESERVED1

//
//  The following is an internal flag stored in the patch header to indicate
//  the ExtendedOptionFlags field is present (non-zero) in the header.  It is
//  never necessary to specify this flag when creating a patch.
//

#define PATCH_OPTION_EXTENDED_OPTIONS   PATCH_OPTION_RESERVED1

//
//  Following are flags in the ExtendedOptionFlags field.
//

#define PATCH_TRANSFORM_NO_RELOCS       0x00000001  // don't xform relocs
#define PATCH_TRANSFORM_NO_IMPORTS      0x00000002  // don't xform imports
#define PATCH_TRANSFORM_NO_EXPORTS      0x00000004  // don't xform exports
#define PATCH_TRANSFORM_NO_RELJMPS      0x00000008  // don't xform E9 or 0F 8x instructions
#define PATCH_TRANSFORM_NO_RELCALLS     0x00000010  // don't xform E8 instructions
#define PATCH_TRANSFORM_NO_RESOURCE     0x00000020  // don't xform resources

#define PATCH_TRANSFORM_CREATION        0x10000000  // validate PE structures during patch creation
                                                    // (not encoded in patch header for decoder)

#define PATCH_TRANSFORM_ANY_PE          0x20000000  // during patch creation, any PE transforms done?

#define PATCH_OPTION_SPECIFIED_WINDOW   0x00010000  // lzx window size encoded

//
//  Following error indicates patch creator should try again with
//  PATCH_TRANSFORM_NO_RESOURCE enabled.
//

#define PATCH_ERROR_RETRY_NO_RESOURCE   ERROR_PATCH_CREATE_RESERVED_07


VOID
__fastcall
RiftQsort(
    PRIFT_ENTRY LowerBound,
    PRIFT_ENTRY UpperBound
    );


#ifdef __cplusplus
}
#endif

#endif // _PATCHPRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\pestuff.c ===
#include <precomp.h>

//
//  pestuff.c
//
//  Author: Tom McGuire (tommcg) 2/97 - 3/98
//
//  Copyright (C) Microsoft, 1997-2000.
//
//  MICROSOFT CONFIDENTIAL
//


#define MAX_SYMBOL_NAME_LENGTH  2048

#if ( _MSC_VER >= 1300 )
    #define DEBUGBREAK __debugbreak();
#else
    #define DEBUGBREAK   DebugBreak();
#endif

#ifndef IMAGE_REL_BASED_SECTION
#define IMAGE_REL_BASED_SECTION 6
#endif

#ifndef IMAGE_REL_BASED_REL32
#define IMAGE_REL_BASED_REL32   7
#endif

BOOL
PeValidateRelocations(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PUCHAR            FileMapped,
    IN ULONG             FileSize
    );

BOOL
PeValidateImports(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PUCHAR            FileMapped,
    IN ULONG             FileSize
    );

BOOL
PeValidateExports(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PUCHAR            FileMapped,
    IN ULONG             FileSize
    );

BOOL
PeValidateResources(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PUCHAR            FileMapped,
    IN ULONG             FileSize
    );


typedef struct _SYMBOL_CONTEXT SYMBOL_CONTEXT, *PSYMBOL_CONTEXT;

struct _SYMBOL_CONTEXT {
    SYMBOL_TREE NewDecoratedSymbolTree;
    SYMBOL_TREE NewUndecoratedSymbolTree;
    SYMBOL_TREE OldUndecoratedSymbolTree;
    ULONG       NewImageBase;
    ULONG       OldImageBase;
    ULONG       SymbolOptionFlags;
    PRIFT_TABLE RiftTable;
#ifdef TESTCODE
    HANDLE      OutFile;
#endif
    };


typedef struct _RELOC_ARRAY_ENTRY RELOC_ARRAY_ENTRY, *PRELOC_ARRAY_ENTRY;

struct _RELOC_ARRAY_ENTRY {
    ULONG  RelocRva;
    UCHAR  RelocType;
    USHORT HighAdjValue;
    };


#ifndef PATCH_APPLY_CODE_ONLY

#ifdef TESTCODE
ULONG CountDecoratedMatches;
ULONG CountUndecoratedMatches;
#endif

LPCSTR ImagehlpImportNames[] = {
           "SymInitialize",
           "SymGetOptions",
           "SymSetOptions",
           "SymLoadModule",
           "SymGetModuleInfo",
           "SymEnumerateSymbols",
           "UnDecorateSymbolName",
           "SymUnloadModule",
           "SymCleanup"
           };

#define COUNT_IMAGEHLP_IMPORTS ( sizeof( ImagehlpImportNames ) / sizeof( ImagehlpImportNames[ 0 ] ))

//
//  NOTE:  Above names must be in SAME ORDER as the prototypes below.
//

union {

    VOID ( __stdcall * Imports[ COUNT_IMAGEHLP_IMPORTS ] )();

    struct {
        BOOL  ( __stdcall * SymInitialize        )( HANDLE, LPCSTR, BOOL );
        DWORD ( __stdcall * SymGetOptions        )( VOID );
        DWORD ( __stdcall * SymSetOptions        )( DWORD );
        DWORD ( __stdcall * SymLoadModule        )( HANDLE, HANDLE, LPCSTR, LPCSTR, DWORD, DWORD );
        BOOL  ( __stdcall * SymGetModuleInfo     )( HANLDE, DWORD, PIMAGEHLP_MODULE );
        BOOL  ( __stdcall * SymEnumerateSymbols  )( HANDLE, DWORD, PSYM_ENUMSYMBOLS_CALLBACK, PVOID );
        BOOL  ( __stdcall * UnDecorateSymbolName )( LPCSTR, LPSTR, DWORD, DWORD );
        BOOL  ( __stdcall * SymUnloadModule      )( HANDLE, DWORD );
        BOOL  ( __stdcall * SymCleanup           )( HANDLE );
        };
    } Imagehlp;


BOOL ImagehlpCritSectInitialized;
CRITICAL_SECTION ImagehlpCritSect;
HANDLE hLibImagehlp;
HANDLE hProc;
IMAGEHLP_MODULE ImagehlpModuleInfo;

VOID
InitImagehlpCritSect(
    VOID
    )
    {
    if ( ! ImagehlpCritSectInitialized ) {
        InitializeCriticalSection( &ImagehlpCritSect );
        ImagehlpCritSectInitialized = TRUE;
        hProc = GetCurrentProcess();
        }
    }


BOOL
LoadImagehlp(
    VOID
    )
    {
    HANDLE hLib;
    ULONG i;

    if ( Imagehlp.Imports[ COUNT_IMAGEHLP_IMPORTS - 1 ] == NULL ) {

        hLib = LoadLibrary( "dbghelp.dll" );

        if ( hLib == NULL ) {
            return FALSE;
            }

        for ( i = 0; i < COUNT_IMAGEHLP_IMPORTS; i++ ) {

            Imagehlp.Imports[ i ] = GetProcAddress( hLib, ImagehlpImportNames[ i ] );

            if ( Imagehlp.Imports[ i ] == NULL ) {

                FreeLibrary( hLib );
                return FALSE;
                }
            }

        hLibImagehlp = hLib;
        }

    return TRUE;
    }


#ifdef BUILDING_PATCHAPI_DLL

VOID
UnloadImagehlp(
    VOID
    )
    {
    if ( hLibImagehlp ) {
        FreeLibrary( hLibImagehlp );
        hLibImagehlp = NULL;
        Imagehlp.Imports[ COUNT_IMAGEHLP_IMPORTS - 1 ] = NULL;
        DeleteCriticalSection( &ImagehlpCritSect );
        ImagehlpCritSectInitialized = FALSE;
        }
    }

#endif // BUILDING_PATCHAPI_DLL

#endif // ! PATCH_APPLY_CODE_ONLY


PIMAGE_NT_HEADERS
__fastcall
GetNtHeader(
    IN PVOID MappedFile,
    IN ULONG MappedFileSize
    )
    {
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS RetHeader;
    PIMAGE_NT_HEADERS NtHeader;

    RetHeader = NULL;

    __try {

        if ( MappedFileSize >= 0x200 ) {

            DosHeader = (PIMAGE_DOS_HEADER) MappedFile;

            if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {

                NtHeader = (PIMAGE_NT_HEADERS)((PUCHAR) MappedFile + DosHeader->e_lfanew );

                if (((PUCHAR) NtHeader + sizeof( IMAGE_NT_HEADERS )) <= ((PUCHAR) MappedFile + MappedFileSize )) {

                    if ( NtHeader->Signature == IMAGE_NT_SIGNATURE ) {

                        if ( NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ) {

                            RetHeader = NtHeader;

                            }
                        }
                    }
                }
            }
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        }

    return RetHeader;
    }


BOOL
__fastcall
IsImageRvaInExecutableSection(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG             Rva
    )
    {
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG i;

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if (( Rva >= SectionHeader[ i ].VirtualAddress ) &&
            ( Rva <  SectionHeader[ i ].VirtualAddress + SectionHeader[ i ].Misc.VirtualSize )) {

            return (( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) ? TRUE : FALSE );
            }
        }

    return FALSE;
    }


ULONG
__fastcall
ImageRvaToFileOffset(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG             Rva
    )
    {
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG i;

    if ( Rva < NtHeader->OptionalHeader.SizeOfHeaders ) {
        return Rva;
        }

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if (( Rva >= SectionHeader[ i ].VirtualAddress ) &&
            ( Rva <  SectionHeader[ i ].VirtualAddress + SectionHeader[ i ].SizeOfRawData )) {

            return ( SectionHeader[ i ].PointerToRawData + ( Rva - SectionHeader[ i ].VirtualAddress ));
            }
        }

    return 0;
    }


PVOID
__fastcall
ImageRvaToMappedAddress(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG             Rva,
    IN PVOID             MappedBase,
    IN ULONG             MappedSize
    )
    {
    ULONG MappedOffset = ImageRvaToFileOffset( NtHeader, Rva );

    if (( MappedOffset ) && ( MappedOffset < MappedSize )) {
        return ((PUCHAR)MappedBase + MappedOffset );
        }

    return NULL;
    }

ULONG
__fastcall
ImageVaToFileOffset(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG             Va
    )
    {
    return ImageRvaToFileOffset( NtHeader, Va - NtHeader->OptionalHeader.ImageBase );
    }


PVOID
__fastcall
ImageVaToMappedAddress(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG             Va,
    IN PVOID             MappedBase,
    IN ULONG             MappedSize
    )
    {
    return ImageRvaToMappedAddress( NtHeader, Va - NtHeader->OptionalHeader.ImageBase, MappedBase, MappedSize );
    }


ULONG
__fastcall
ImageDirectoryRvaAndSize(
    IN  PIMAGE_NT_HEADERS NtHeader,
    IN  ULONG             DirectoryIndex,
    OUT PULONG OPTIONAL   DirectorySize
    )
    {
    if ( DirectoryIndex < NtHeader->OptionalHeader.NumberOfRvaAndSizes ) {

        if ( DirectorySize ) {
            *DirectorySize = NtHeader->OptionalHeader.DataDirectory[ DirectoryIndex ].Size;
            }

        return NtHeader->OptionalHeader.DataDirectory[ DirectoryIndex ].VirtualAddress;
        }

    return 0;
    }


ULONG
__fastcall
ImageDirectoryOffsetAndSize(
    IN  PIMAGE_NT_HEADERS NtHeader,
    IN  ULONG             DirectoryIndex,
    OUT PULONG OPTIONAL   DirectorySize
    )
    {
    ULONG Rva = ImageDirectoryRvaAndSize( NtHeader, DirectoryIndex, DirectorySize );

    if ( Rva ) {
        return ImageRvaToFileOffset( NtHeader, Rva );
        }

    return 0;
    }


PVOID
__fastcall
ImageDirectoryMappedAddress(
    IN  PIMAGE_NT_HEADERS NtHeader,
    IN  ULONG             DirectoryIndex,
    OUT PULONG OPTIONAL   DirectorySize,
    IN  PUCHAR            MappedBase,
    IN  ULONG             MappedSize
    )
    {
    PUCHAR Directory;
    ULONG  LocalSize;
    ULONG  Rva;

    Rva = ImageDirectoryRvaAndSize( NtHeader, DirectoryIndex, &LocalSize );

    if ( Rva ) {

        Directory = ImageRvaToMappedAddress( NtHeader, Rva, MappedBase, MappedSize );

        if (( Directory ) && (( Directory + LocalSize ) <= ( MappedBase + MappedSize ))) {

            if ( DirectorySize ) {
                *DirectorySize = LocalSize;
                }

            return Directory;
            }
        }

    return NULL;
    }


ULONG
__fastcall
FileOffsetToImageRva(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG             FileOffset
    )
    {
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG i;

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if (( FileOffset >= SectionHeader[ i ].PointerToRawData ) &&
            ( FileOffset <  SectionHeader[ i ].PointerToRawData + SectionHeader[ i ].SizeOfRawData )) {

            return ( SectionHeader[ i ].VirtualAddress + ( FileOffset - SectionHeader[ i ].PointerToRawData ));
            }
        }

    return 0;
    }


ULONG
MappedAddressToImageRva(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PVOID             MappedAddress,
    IN PVOID             MappedFile
    )
    {
    LONG FileOffset = (PUCHAR)MappedAddress - (PUCHAR)MappedFile;

    if ( FileOffset > 0 ) {
        return FileOffsetToImageRva( NtHeader, FileOffset );
        }

    return 0;
    }


BOOL
RebaseMappedImage(
    IN PUCHAR            MappedFile,
    IN ULONG             FileSize,
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG             NewBase
    )
    {
    PIMAGE_BASE_RELOCATION RelocBlock;
    LONG                   RelocAmount;
    LONG                   RelocDirRemaining;
    ULONG                  RelocDirSize;
    PUCHAR                 RelocBlockMa;
    PUCHAR                 RelocFixupMa;
    ULONG                  RelocCount;
    PUSHORT                RelocEntry;
    PUCHAR                 MappedFileEnd;
    BOOL                   Modified;

    //
    //  Carefully rebase the image, ignoring invalid info as much as possible
    //  without taking an access violation.  We don't want to use try/except
    //  here because this code needs to be workable without any imports from
    //  kernel32.dll.  This code is not intended to catch errors in invalid
    //  rebase info -- it is intended to silently do the best it can at
    //  rebasing the image in memory.  If the rebase info is valid, it will
    //  correctly rebase the image.  If the rebase info is not valid, it will
    //  attempt to avoid causing an access violation.
    //

    ASSERT( NtHeader->OptionalHeader.ImageBase != NewBase );
    ASSERT(( NewBase & 0x0000FFFF ) == 0 );
    ASSERT(( NewBase & 0xFFFF0000 ) != 0 );

    Modified      = FALSE;
    MappedFileEnd = MappedFile + FileSize;
    RelocAmount   = NewBase - NtHeader->OptionalHeader.ImageBase;

    RelocBlock = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_BASERELOC, &RelocDirSize, MappedFile, FileSize );

    if ( RelocBlock ) {

        NtHeader->OptionalHeader.ImageBase = NewBase;
        Modified = TRUE;

        RelocDirRemaining = (LONG)RelocDirSize;

        while ( RelocDirRemaining > 0 ) {

            if (( RelocBlock->SizeOfBlock <= (ULONG)RelocDirRemaining ) &&
                ( RelocBlock->SizeOfBlock > sizeof( IMAGE_BASE_RELOCATION ))) {

                //
                //  ImageRvaToMappedAddress returns NULL if the Rva is zero,
                //  but that is a valid base address of a reloc block.  Use
                //  ImageRvaToFileOffset instead.
                //

                RelocBlockMa = MappedFile + ImageRvaToFileOffset( NtHeader, RelocBlock->VirtualAddress );

                if ( RelocBlockMa ) {

                    RelocEntry = (PUSHORT)((ULONG)RelocBlock + sizeof( IMAGE_BASE_RELOCATION ));
                    RelocCount = ( RelocBlock->SizeOfBlock - sizeof( IMAGE_BASE_RELOCATION )) / sizeof( USHORT );

                    while ( RelocCount-- ) {

                        RelocFixupMa = RelocBlockMa + ( *RelocEntry & 0x0FFF );

                        if ( RelocFixupMa < MappedFileEnd ) {

                            switch ( *RelocEntry >> 12 ) {

                                case IMAGE_REL_BASED_HIGHLOW:

                                    *(UNALIGNED LONG *)RelocFixupMa += RelocAmount;
                                    break;

                                case IMAGE_REL_BASED_LOW:

                                    *(UNALIGNED USHORT *)RelocFixupMa = (USHORT)( *(UNALIGNED SHORT *)RelocFixupMa + RelocAmount );
                                    break;

                                case IMAGE_REL_BASED_HIGH:

                                    *(UNALIGNED USHORT *)RelocFixupMa = (USHORT)((( *(UNALIGNED USHORT *)RelocFixupMa << 16 ) + RelocAmount ) >> 16 );
                                    break;

                                case IMAGE_REL_BASED_HIGHADJ:

                                    ++RelocEntry;
                                    --RelocCount;

                                    *(UNALIGNED USHORT *)RelocFixupMa = (USHORT)((( *(UNALIGNED USHORT *)RelocFixupMa << 16 ) + *(UNALIGNED SHORT *)RelocEntry + RelocAmount + 0x8000 ) >> 16 );
                                    break;

                                //
                                //  Just skip and continue if we don't
                                //  recognize the reloc type.
                                //

                                }
                            }

                        ++RelocEntry;

                        }
                    }
                }
            else {
                break;  // invalid reloc structure
                }

            RelocDirRemaining -= RelocBlock->SizeOfBlock;
            RelocBlock = (PIMAGE_BASE_RELOCATION)((ULONG)RelocBlock + RelocBlock->SizeOfBlock );

            }
        }

    return Modified;
    }


BOOL
UnBindMappedImage(
    IN PUCHAR            MappedFile,
    IN ULONG             FileSize,
    IN PIMAGE_NT_HEADERS NtHeader
    )
    {
    PIMAGE_SECTION_HEADER    SectionHeader;
    ULONG                    SectionCount;
    DWORDLONG                SectionName;
    PIMAGE_IMPORT_DESCRIPTOR ImportDesc;
    PVOID                    BoundImportDir;
    ULONG                    BoundImportSize;
    PULONG                   OriginalIat;
    PULONG                   BoundIat;
    PUCHAR                   MappedFileEnd;
    BOOL                     Modified;
    ULONG                    i;

    Modified       = FALSE;
    MappedFileEnd  = MappedFile + FileSize;
    BoundImportDir = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT, &BoundImportSize, MappedFile, FileSize );

    if ( BoundImportDir ) {

        //
        //  Zero the bound import directory and pointers to bound
        //  import directory.
        //

        ZeroMemory( BoundImportDir, BoundImportSize );

        NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress = 0;
        NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size           = 0;

        Modified = TRUE;
        }

    //
    //  Now walk imports and zero the TimeDate and
    //  ForwarderChain fields.
    //

    ImportDesc = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_IMPORT, NULL, MappedFile, FileSize );

    if ( ImportDesc ) {

        while (((ULONG)ImportDesc <= ((ULONG)MappedFileEnd - sizeof( IMAGE_IMPORT_DESCRIPTOR ))) &&
               ( ImportDesc->Characteristics )) {

            if ( ImportDesc->TimeDateStamp ) {

                //
                //  This is a bound import.  Copy the unbound
                //  IAT over the bound IAT to restore.
                //

                ImportDesc->TimeDateStamp = 0;
                Modified = TRUE;

                OriginalIat = ImageRvaToMappedAddress( NtHeader, (ULONG)ImportDesc->OriginalFirstThunk, MappedFile, FileSize );
                BoundIat    = ImageRvaToMappedAddress( NtHeader, (ULONG)ImportDesc->FirstThunk,         MappedFile, FileSize );

                if (( OriginalIat ) && ( BoundIat )) {

                    while (((PUCHAR)( OriginalIat + 1 ) <= MappedFileEnd ) &&
                           ((PUCHAR)( BoundIat    + 1 ) <= MappedFileEnd ) &&
                           ( *OriginalIat )) {

                        *BoundIat++ = *OriginalIat++;
                        }
                    }
                }

            if ( ImportDesc->ForwarderChain ) {
                 ImportDesc->ForwarderChain = 0;
                 Modified = TRUE;
                 }

            ++ImportDesc;
            }
        }

    //
    //  The bind utility marks the .idata section as read-only so we want to
    //  change it back to read-write.
    //

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        SectionName = *(UNALIGNED DWORDLONG*)( &SectionHeader[ i ].Name );
        SectionName |= 0x2020202020202020;  // fast lower case

        if ( SectionName == 0x202061746164692E ) {      // ".idata  "

            if ( ! ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_WRITE )) {

                SectionHeader[ i ].Characteristics |= ( IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE );
                Modified = TRUE;
                }

            break;
            }
        }

    return Modified;
    }


BOOL
SmashLockPrefixesInMappedImage(
    IN PUCHAR            MappedFile,
    IN ULONG             FileSize,
    IN PIMAGE_NT_HEADERS NtHeader,
    IN UCHAR             NewOpCode      // X86_OPCODE_NOP or X86_OPCODE_LOCK
    )
    {
    PIMAGE_LOAD_CONFIG_DIRECTORY LoadConfig;
    PUCHAR*                      LockPrefixEntry;
    PUCHAR                       LockPrefixInstruction;
    BOOL                         Modified;

    Modified   = FALSE;
    LoadConfig = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, NULL, MappedFile, FileSize );

    if ( LoadConfig ) {

        if ( LoadConfig->LockPrefixTable ) {

            //
            //  The LoadConfig->LockPrefixTable field and
            //  the lock prefix addresses are stored in the
            //  image as image VA, not RVA values.
            //

            LockPrefixEntry = ImageVaToMappedAddress( NtHeader, (ULONG)( LoadConfig->LockPrefixTable ), MappedFile, FileSize );

            if ( LockPrefixEntry ) {

                while ( *LockPrefixEntry ) {

                    LockPrefixInstruction = ImageVaToMappedAddress( NtHeader, (ULONG)( *LockPrefixEntry ), MappedFile, FileSize );

                    if ( LockPrefixInstruction ) {

                        if ( *LockPrefixInstruction != NewOpCode ) {

                            //
                            //  Lock prefix instruction is not what we want,
                            //  so modify it.
                            //

                            *LockPrefixInstruction = NewOpCode;
                            Modified = TRUE;
                            }
                        }

                    ++LockPrefixEntry;

                    }
                }
            }
        }

    return Modified;
    }


USHORT
ChkSum(
    IN USHORT  Initial,
    IN PUSHORT Buffer,
    IN ULONG   Bytes
    )
    {
    PUSHORT p = Buffer;
    ULONG WordsRemaining = Bytes / 2;
    ULONG WordsInChunk;
    ULONG SumChunk;
    ULONG SumTotal;

    SumTotal = Initial;

    while ( WordsRemaining ) {

        WordsInChunk = WordsRemaining;

        if ( WordsInChunk > 0x10000 ) {
             WordsInChunk = 0x10000;
             }

        WordsRemaining -= WordsInChunk;

        SumChunk = 0;

        do  {
            SumChunk += *p++;
            }
        while ( --WordsInChunk != 0 );

        SumTotal += ( SumChunk >> 16 ) + ( SumChunk & 0xFFFF );
        }

    if ( Bytes % 2 ) {

        SumTotal += *((PBYTE) p);
        }

    return (USHORT)(( SumTotal >> 16 ) + ( SumTotal & 0xFFFF ));
    }


BOOL
NormalizeCoffImage(
    IN OUT PIMAGE_NT_HEADERS NtHeader,
    IN OUT PUCHAR            MappedFile,
    IN     ULONG             FileSize,
    IN     ULONG             OptionFlags,
    IN     PVOID             OptionData,
    IN     ULONG             NewFileCoffBase,
    IN     ULONG             NewFileCoffTime
    )
    {
    BOOL Modified = FALSE;

    UNREFERENCED_PARAMETER( OptionData );

    if ( ! ( OptionFlags & PATCH_OPTION_NO_REBASE )) {

        if (( NewFileCoffTime != 0 ) && ( NtHeader->FileHeader.TimeDateStamp != NewFileCoffTime )) {
             NtHeader->FileHeader.TimeDateStamp = NewFileCoffTime;
             Modified = TRUE;
             }

        if (( NewFileCoffBase != 0 ) && ( NtHeader->OptionalHeader.ImageBase != NewFileCoffBase )) {
            Modified |= RebaseMappedImage( MappedFile, FileSize, NtHeader, NewFileCoffBase );
            }
        }

    if ( ! ( OptionFlags & PATCH_OPTION_NO_BINDFIX )) {
        Modified |= UnBindMappedImage( MappedFile, FileSize, NtHeader );
        }

    if ( ! ( OptionFlags & PATCH_OPTION_NO_LOCKFIX )) {
        Modified |= SmashLockPrefixesInMappedImage( MappedFile, FileSize, NtHeader, X86_OPCODE_LOCK );
        }

    //
    //  If the target file has zero checksum (PATCH_OPTION_NO_CHECKSUM),
    //  set the checksum in this image to zero.
    //
    //  Otherwise, if we either modified the image or if the image has
    //  a zero checksum, recompute the correct checksum.
    //

    if ( OptionFlags & PATCH_OPTION_NO_CHECKSUM ) {

        if ( NtHeader->OptionalHeader.CheckSum != 0 ) {
             NtHeader->OptionalHeader.CheckSum = 0;
             Modified = TRUE;
             }
        }

    else {

        if ( Modified ) {
             *(volatile ULONG *)( &NtHeader->OptionalHeader.CheckSum ) = 0;
             NtHeader->OptionalHeader.CheckSum = ChkSum( 0, (PVOID)MappedFile, FileSize ) + FileSize;
             }
        }

    return Modified;
    }


//
//  For some odd reason, the VC4 compiler says there is unreachable code
//  in the GetNewRvaFromRiftTable and FindRiftTableEntryForOldRva functions,
//  but I can't find it by inspection, and the VC5 and VC6 compilers don't
//  complain about it, so it's probably just a VC4 bug.  So, if the compiler
//  version is previous to VC5, disable this particular warning.
//

#if ( _MSC_VER < 1100 )
#pragma warning( disable: 4702 )    // unreachable code
#endif

ULONG
__fastcall
GetNewRvaFromRiftTable(
    IN PRIFT_TABLE RiftTable,
    IN ULONG OldRva
    )
    {
    PRIFT_ENTRY RiftEntryArray;
    ULONG NewRva;
    ULONG Index;
    ULONG MinIndexInclusive;
    ULONG MaxIndexExclusive;
    LONG  Displacement;
    BOOL  Found;

    //
    //  Rift table is in sorted order by OldRva, so do a binary search for
    //  matching or nearest preceding OldRva value.
    //

    RiftEntryArray    = RiftTable->RiftEntryArray;
    MaxIndexExclusive = RiftTable->RiftEntryCount;
    MinIndexInclusive = 0;
    Index             = 0;
    Found             = FALSE;

    while (( ! Found ) && ( MinIndexInclusive < MaxIndexExclusive )) {

        Index = ( MinIndexInclusive + MaxIndexExclusive ) / 2;    // won't overflow

        if ( RiftEntryArray[ Index ].OldFileRva < OldRva ) {
            MinIndexInclusive = Index + 1;
            }
        else if ( RiftEntryArray[ Index ].OldFileRva > OldRva ) {
            MaxIndexExclusive = Index;
            }
        else {
            Found = TRUE;
            break;
            }
        }

    if ( ! Found ) {

        //
        //  MinIndex is pointing to next highest entry, which could also be
        //  the zeroth entry if the search value was lower than anything in
        //  the table.
        //

        if ( MinIndexInclusive == 0 ) {
            return OldRva;  // zero displacement
            }

        Index = MinIndexInclusive - 1;
        }

    Displacement = (LONG)( RiftEntryArray[ Index ].NewFileRva - RiftEntryArray[ Index ].OldFileRva );

#ifndef PATCH_APPLY_CODE_ONLY

    //
    //  If we're updating the RiftUsageArray during compression, we want to
    //  mark the contributing entry as being used.
    //

    if ( RiftTable->RiftUsageArray != NULL ) {
         RiftTable->RiftUsageArray[ Index ] = 1;
         }

#endif

    NewRva = OldRva + Displacement;

    return NewRva;
    }


ULONG
__fastcall
FindRiftTableEntryForOldRva(
    IN PRIFT_TABLE RiftTable,
    IN ULONG OldRva
    )
    {
    PRIFT_ENTRY RiftEntryArray;
    ULONG MinIndexInclusive;
    ULONG MaxIndexExclusive;
    ULONG Index;
    BOOL  Found;

    //
    //  Rift table is in sorted order by OldRva, so do a binary search for
    //  matching or nearest preceding OldRva value.
    //

    RiftEntryArray    = RiftTable->RiftEntryArray;
    MaxIndexExclusive = RiftTable->RiftEntryCount;
    MinIndexInclusive = 0;
    Index             = 0;
    Found             = FALSE;

    while (( ! Found ) && ( MinIndexInclusive < MaxIndexExclusive )) {

        Index = ( MinIndexInclusive + MaxIndexExclusive ) / 2;    // won't overflow

        if ( RiftEntryArray[ Index ].OldFileRva < OldRva ) {
            MinIndexInclusive = Index + 1;
            }
        else if ( RiftEntryArray[ Index ].OldFileRva > OldRva ) {
            MaxIndexExclusive = Index;
            }
        else {
            Found = TRUE;
            break;
            }
        }

    if ( ! Found ) {

        //
        //  MinIndex is pointing to next highest entry, which could also be
        //  the zeroth entry if the search value was lower than anything in
        //  the table.
        //

        if ( MinIndexInclusive == 0 ) {
            return 0;
            }

        Index = MinIndexInclusive - 1;
        }

    return Index;
    }


#if ( _MSC_VER < 1100 )
#pragma warning( default: 4702 )    // unreachable code
#endif


VOID
__inline
ChangeOldRvaToNewRva(
    IN PRIFT_TABLE RiftTable,
    IN OUT PVOID AddressOfRvaToChange
    )
    {
    //
    //  Assuming all addresses of RVAs in a PE image are aligned.
    //

    PULONG RvaToChange = AddressOfRvaToChange;

    *RvaToChange = GetNewRvaFromRiftTable(
                       RiftTable,
                       *RvaToChange
                       );
    }


VOID
__inline
SwapRelocs(
    PRELOC_ARRAY_ENTRY One,
    PRELOC_ARRAY_ENTRY Two
    )
    {
    RELOC_ARRAY_ENTRY Tmp;

    Tmp  = *One;
    *One = *Two;
    *Two =  Tmp;
    }


VOID
__fastcall
RelocQsort(
    PRELOC_ARRAY_ENTRY LowerBound,
    PRELOC_ARRAY_ENTRY UpperBound
    )
    {
    PRELOC_ARRAY_ENTRY Lower = LowerBound;
    PRELOC_ARRAY_ENTRY Upper = UpperBound;
    PRELOC_ARRAY_ENTRY Pivot = Lower + (( Upper - Lower ) / 2 );
    ULONG PivotRva = Pivot->RelocRva;

    do  {

        while (( Lower <= Upper ) && ( Lower->RelocRva <= PivotRva )) {
            ++Lower;
            }

        while (( Upper >= Lower ) && ( Upper->RelocRva >= PivotRva )) {
            --Upper;
            }

        if ( Lower < Upper ) {
            SwapRelocs( Lower++, Upper-- );
            }
        }

    while ( Lower <= Upper );

    if ( Lower < Pivot ) {
        SwapRelocs( Lower, Pivot );
        Pivot = Lower;
        }
    else if ( Upper > Pivot ) {
        SwapRelocs( Upper, Pivot );
        Pivot = Upper;
        }

    if ( LowerBound < ( Pivot - 1 )) {
        RelocQsort( LowerBound, Pivot - 1 );
        }

    if (( Pivot + 1 ) < UpperBound ) {
        RelocQsort( Pivot + 1, UpperBound );
        }
    }


VOID
TransformOldFile_PE_Relocations(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PVOID             FileMappedImage,
    IN ULONG             FileSize,
    IN PRIFT_TABLE       RiftTable,
    IN PUCHAR            HintMap
    )
    {
    PUCHAR                 MappedFile;
    PUCHAR                 MappedFileEnd;
    ULONG                  ImageBaseVa;
    ULONG                  ImageLastVa;
    PUCHAR                 ImageFirstSectionMa;     // Mapped address
    ULONG                  ImageFirstSectionVa;     // Virtual address
    ULONG                  RelocDirOff;
    ULONG                  RelocDirSize;
    LONG                   RelocDirRemaining;
    PIMAGE_BASE_RELOCATION RelocBlock;
    ULONG                  RelocBlockBaseMa;        // Mapped address
    ULONG                  RelocBlockBaseVa;        // Virtual address
    ULONG                  RelocCount;
    PUSHORT                RelocEntry;
    PUSHORT                RelocFirst;
    UCHAR                  RelocType;
    ULONG                  RelocFixupMa;            // Mapped address
    ULONG                  RelocFixupVa;            // Virtual address
    ULONG                  RelocFixupRva;
    ULONG                  RelocTargetVa;           // Virtual address
    ULONG                  RelocTargetRva;
    ULONG                  NewRva;
    ULONG                  NewVa;
    PRELOC_ARRAY_ENTRY     RelocArray;
    ULONG                  RelocArrayCount;
    ULONG                  RelocArrayIndex;
    PIMAGE_SECTION_HEADER  SectionHeader;
    ULONG                  SectionCount;
    DWORDLONG              SectionName;
    PUCHAR                 p;
    ULONG                  i;

#ifdef TESTCODE

    ULONG CountRelocChanges = 0;

#endif // TESTCODE

    MappedFile    = FileMappedImage;
    MappedFileEnd = MappedFile + FileSize;
    ImageBaseVa   = NtHeader->OptionalHeader.ImageBase;
    RelocDirOff   = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_BASERELOC, &RelocDirSize );

    if (( RelocDirOff ) && (( RelocDirOff + RelocDirSize ) <= FileSize )) {

        memset( HintMap + RelocDirOff, 0x03, RelocDirSize );  // NOTE: may need to be OR'd if other bits are mutually exlusive

        //  allocate an array for the new reloc entries, approximating the needed size

        RelocArray = MyVirtualAlloc( sizeof( *RelocArray ) * ( RelocDirSize / sizeof(USHORT)));

        if ( RelocArray != NULL ) {

            RelocArrayCount = 0;

            RelocBlock = (PIMAGE_BASE_RELOCATION)( MappedFile + RelocDirOff );

            RelocDirRemaining = (LONG)RelocDirSize;

            while ( RelocDirRemaining > 0 ) {

                if (( RelocBlock->SizeOfBlock <= (ULONG)RelocDirRemaining ) &&
                    ( RelocBlock->SizeOfBlock > sizeof( IMAGE_BASE_RELOCATION ))) {

                    //
                    //  ImageRvaToMappedAddress returns NULL if the Rva is zero,
                    //  but that is a valid base address of a reloc block.  Use
                    //  ImageRvaToFileOffset instead.
                    //

                    RelocBlockBaseMa = (ULONG)MappedFile + ImageRvaToFileOffset( NtHeader, RelocBlock->VirtualAddress );

                    if ( RelocBlockBaseMa ) {

                        RelocBlockBaseVa = RelocBlock->VirtualAddress + ImageBaseVa;
                        RelocEntry       = (PUSHORT)((ULONG)RelocBlock + sizeof( IMAGE_BASE_RELOCATION ));
                        RelocCount       = ( RelocBlock->SizeOfBlock - sizeof( IMAGE_BASE_RELOCATION )) / sizeof( USHORT );

                        while ( RelocCount-- ) {

                            RelocType = (UCHAR)( *RelocEntry >> 12 );

                            if ( RelocType != IMAGE_REL_BASED_ABSOLUTE ) {

                                RelocFixupMa  = RelocBlockBaseMa + ( *RelocEntry & 0x0FFF );
                                RelocFixupVa  = RelocBlockBaseVa + ( *RelocEntry & 0x0FFF );
                                RelocFixupRva = RelocFixupVa - ImageBaseVa;

                                RelocArray[ RelocArrayCount ].RelocRva  = GetNewRvaFromRiftTable(
                                                                              RiftTable,
                                                                              RelocFixupRva
                                                                              );

                                RelocArray[ RelocArrayCount ].RelocType = RelocType;

                                switch ( RelocType ) {

                                    case IMAGE_REL_BASED_HIGHLOW:

                                        if ( RelocFixupMa < (ULONG)MappedFileEnd ) {

                                            *(UNALIGNED ULONG *)( HintMap + ( RelocFixupMa - (ULONG)MappedFile )) |= 0x01010101;    // don't transform again during E8 pass

                                            //
                                            //  Target is a 32-bit VA that we want to
                                            //  change to the corresponding VA in the
                                            //  new file.
                                            //

                                            RelocTargetVa  = *(UNALIGNED ULONG *) RelocFixupMa;
                                            RelocTargetRva = RelocTargetVa - ImageBaseVa;

                                            NewRva = GetNewRvaFromRiftTable(
                                                         RiftTable,
                                                         RelocTargetRva
                                                         );

                                            if ( NewRva != RelocTargetRva ) {

                                                NewVa = NewRva + ImageBaseVa;
                                                *(UNALIGNED ULONG *) RelocFixupMa = NewVa;
#ifdef TESTCODE
                                                ++CountRelocChanges;
#endif // TESTCODE
                                                }

                                            }

                                        break;

                                    case IMAGE_REL_BASED_LOW:
                                    case IMAGE_REL_BASED_HIGH:

                                        if ( RelocFixupMa < (ULONG)MappedFileEnd ) {
                                            *(UNALIGNED USHORT *)( HintMap + ( RelocFixupMa - (ULONG)MappedFile )) |= 0x0101; // don't transform again during E8 pass
                                            }

                                        break;

                                    case IMAGE_REL_BASED_HIGHADJ:

                                        if ( RelocFixupMa < (ULONG)MappedFileEnd ) {
                                            *(UNALIGNED USHORT *)( HintMap + ( RelocFixupMa - (ULONG)MappedFile )) |= 0x0101; // don't transform again during E8 pass
                                            }

                                        ++RelocEntry;
                                        --RelocCount;

                                        RelocArray[ RelocArrayCount ].HighAdjValue = *RelocEntry;

                                        break;
                                    }

                                ++RelocArrayCount;
                                }

                            ++RelocEntry;
                            }
                        }
                    }
                else {

#ifdef TESTCODE
                    printf( "\rInvalid .reloc directory\n" );
#endif TESTCODE

                    break;  // invalid reloc structure
                    }


                RelocDirRemaining -= RelocBlock->SizeOfBlock;
                RelocBlock = (PIMAGE_BASE_RELOCATION)((ULONG)RelocBlock + RelocBlock->SizeOfBlock );
                }

#ifdef TESTCODE

            printf( "\r%9d modified reloc targets\n", CountRelocChanges );

#endif TESTCODE

            //
            //  Now we want to reconstruct the .reloc table based on the new values
            //  hoping that it will more closely match the .reloc table in the new
            //  file.
            //
            //  First we want to sort our RelocArray by Rva.
            //

            if ( RelocArrayCount > 1 ) {
                RelocQsort( &RelocArray[ 0 ], &RelocArray[ RelocArrayCount - 1 ] );

#ifdef TESTCODE

                for ( i = 0; i < RelocArrayCount - 1; i++ ) {
                    if ( RelocArray[ i ].RelocRva > RelocArray[ i + 1 ].RelocRva ) {

                        printf( "\nReloc sort failed at index %d of %d\n", i, RelocArrayCount );

                        for ( i = 0; i < RelocArrayCount; i++ ) {
                            printf( "%08X\n", RelocArray[ i ].RelocRva );
                            }

                        exit( 1 );
                        break;
                        }
                    }

#endif // TESTCODE

                }

            RelocDirRemaining = (LONG)RelocDirSize;

            //
            //  Look for .reloc section to determine max size we can use for new
            //  .reloc data (may be bigger than old RelocDirSize).
            //

            SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
            SectionCount  = NtHeader->FileHeader.NumberOfSections;

            for ( i = 0; i < SectionCount; i++ ) {

                SectionName = *(UNALIGNED DWORDLONG*)( &SectionHeader[ i ].Name );
                SectionName |= 0x2020202020202020;  // fast lower case

                if ( SectionName == 0x2020636F6C65722E ) {      // ".reloc  "

                    if (( RelocDirOff >= SectionHeader[ i ].PointerToRawData ) &&
                        ( RelocDirOff <  SectionHeader[ i ].PointerToRawData + SectionHeader[ i ].SizeOfRawData )) {

                        RelocDirRemaining = ( SectionHeader[ i ].PointerToRawData + SectionHeader[ i ].SizeOfRawData ) - RelocDirOff;
                        }
                    }
                }

            RelocDirRemaining &= ~1;    // force to even value
            RelocBlock = (PIMAGE_BASE_RELOCATION)( MappedFile + RelocDirOff );
            RelocArrayIndex = 0;

            while (( RelocDirRemaining > sizeof( IMAGE_BASE_RELOCATION )) &&
                   ( RelocArrayIndex < RelocArrayCount )) {

                RelocBlock->VirtualAddress = ( RelocArray[ RelocArrayIndex ].RelocRva & 0xFFFFF000 );
                RelocFirst = RelocEntry    = (PUSHORT)((ULONG)RelocBlock + sizeof( IMAGE_BASE_RELOCATION ));
                RelocDirRemaining         -= sizeof( IMAGE_BASE_RELOCATION );

                while (( RelocDirRemaining > 0 ) &&
                       ( RelocArrayIndex < RelocArrayCount ) &&
                       (( RelocArray[ RelocArrayIndex ].RelocRva & 0xFFFFF000 ) == RelocBlock->VirtualAddress )) {

                    *RelocEntry++ = (USHORT)(( RelocArray[ RelocArrayIndex ].RelocType << 12 ) | ( RelocArray[ RelocArrayIndex ].RelocRva & 0x00000FFF ));
                    RelocDirRemaining -= sizeof( USHORT );

                    if ((( RelocArray[ RelocArrayIndex ].RelocType << 12 ) == IMAGE_REL_BASED_HIGHADJ ) &&
                        ( RelocDirRemaining > 0 )) {

                        *RelocEntry++ = RelocArray[ RelocArrayIndex ].HighAdjValue;
                        RelocDirRemaining -= sizeof( USHORT );
                        }

                    ++RelocArrayIndex;
                    }

                if (( RelocDirRemaining > 0 ) && ((ULONG)RelocEntry & 2 )) {
                    *RelocEntry++ = 0;
                    RelocDirRemaining -= sizeof( USHORT );
                    }

                RelocBlock->SizeOfBlock = ((ULONG)RelocEntry - (ULONG)RelocFirst ) + sizeof( IMAGE_BASE_RELOCATION );
                RelocBlock = (PIMAGE_BASE_RELOCATION)((ULONG)RelocBlock + RelocBlock->SizeOfBlock );
                }

            MyVirtualFree( RelocArray );
            }
        }

    else {

        //
        //  No relocation table exists for this binary.  We can still perform
        //  this transformation for x86 images by inferring some of the
        //  relocation targets in the mapped image by scanning the image for
        //  4-byte values that are virtual addresses that fall within the
        //  mapped image range.  We start with the address of the first
        //  section, assuming no relocs occur in the image header.
        //

        if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

            ImageFirstSectionMa = MappedFile  + IMAGE_FIRST_SECTION( NtHeader )->PointerToRawData;
            ImageFirstSectionVa = ImageBaseVa + IMAGE_FIRST_SECTION( NtHeader )->VirtualAddress;
            ImageLastVa         = ImageBaseVa + NtHeader->OptionalHeader.SizeOfImage;

            for ( p = ImageFirstSectionMa; p < ( MappedFileEnd - 4 ); p++ ) {

                RelocTargetVa = *(UNALIGNED ULONG *) p;

                if (( RelocTargetVa >= ImageFirstSectionVa ) && ( RelocTargetVa < ImageLastVa )) {

                    //
                    //  This looks like a 32-bit VA that points within the image,
                    //  so we'll transform it to the corresponding new address.
                    //

                    *(UNALIGNED ULONG *)( HintMap + ((ULONG)p - (ULONG)MappedFile )) |= 0x01010101; // don't transform again during E8 pass

                    RelocTargetRva = RelocTargetVa - ImageBaseVa;

                    NewRva = GetNewRvaFromRiftTable( RiftTable, RelocTargetRva );

                    if ( NewRva != RelocTargetRva ) {
                        NewVa = NewRva + ImageBaseVa;
                        *(UNALIGNED ULONG *) p = NewVa;

#ifdef TESTCODE
                        ++CountRelocChanges;
#endif // TESTCODE

                        }

                    p += 3;
                    }
                }

#ifdef TESTCODE

            printf( "\r%9d modified inferred reloc targets (old algorithm)\n", CountRelocChanges );

#endif // TESTCODE

            }
        }
    }


VOID
TransformOldFile_PE_InferRelocsX86(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PVOID             FileMappedImage,
    IN ULONG             FileSize,
    IN PRIFT_TABLE       RiftTable,
    IN PUCHAR            HintMap
    )
{
    //
    //  No relocation table exists for this binary.  We can still perform
    //  this transformation for x86 images by inferring some of the
    //  relocation targets in the mapped image by scanning the image for
    //  4-byte values that appear to be virtual addresses that fall within
    //  the image size range.  We start with the address of the first
    //  section, assuming no relocs occur in the image header.
    //

    PBYTE MappedFile    = (PBYTE) FileMappedImage;
    ULONG ImageBaseVa   = NtHeader->OptionalHeader.ImageBase;
    ULONG ImageLastVa   = NtHeader->OptionalHeader.SizeOfImage + ImageBaseVa;
    ULONG FileOffset    = NtHeader->OptionalHeader.SizeOfHeaders;
    ULONG LastOffset    = FileSize - 4;
    BYTE  HighByte      = (BYTE)( ImageBaseVa >> 24 );

#ifdef TESTCODE
    ULONG CountRelocChanges = 0;
#endif TESTCODE

    while ( FileOffset < LastOffset )
    {
        if ( MappedFile[ FileOffset + 3 ] == HighByte )
        {
            ULONG RelocTargetVa = *(ULONG UNALIGNED*)( MappedFile + FileOffset );

            if (( RelocTargetVa > ImageBaseVa ) &&
                ( RelocTargetVa < ImageLastVa ))
            {
                ULONG HintValue = *(ULONG UNALIGNED*)( HintMap + FileOffset );

                if (( HintValue & 0x02020202 ) == 0 )
                {
                    *(ULONG UNALIGNED*)( HintMap + FileOffset ) = ( HintValue | 0x01010101 ); // don't transform again during E8 pass, and as a target this cannot be the first byte of an instruction

                    {
                        ULONG OldTargetRva = RelocTargetVa - ImageBaseVa;
                        ULONG NewTargetRva = GetNewRvaFromRiftTable( RiftTable, OldTargetRva );

                        if ( NewTargetRva != OldTargetRva )
                        {
                            *(ULONG UNALIGNED*)( MappedFile + FileOffset ) = ( ImageBaseVa + NewTargetRva );
#ifdef TESTCODE
                            ++CountRelocChanges;
#endif TESTCODE
                        }
                    }

                    FileOffset += 4;
                    continue;
                }
            }
        }

        FileOffset++;
    }

#ifdef TESTCODE
    printf( "\r%9d modified inferred reloc targets (new algorithm)\n", CountRelocChanges );
#endif TESTCODE

}


VOID
TransformOldFile_PE_Exports(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PVOID             FileMappedImage,
    IN ULONG             FileSize,
    IN PRIFT_TABLE       RiftTable,
    IN PUCHAR            HintMap
    )
    {
    PUCHAR                  MappedFile;
    PUCHAR                  MappedFileEnd;
    ULONG                   FileOffset;
    ULONG                   ExportDirOff;
    ULONG                   ExportDirSize;
    PIMAGE_EXPORT_DIRECTORY ExportBlock;
    ULONG                   EntryCount;
    PULONG                  Entry;

    MappedFile    = FileMappedImage;
    MappedFileEnd = MappedFile + FileSize;

    ExportDirOff = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportDirSize );

    if (( ExportDirOff ) && (( ExportDirOff + ExportDirSize ) <= FileSize )) {

        memset( HintMap + ExportDirOff, 0x03, ExportDirSize );  // NOTE: may need to be OR'd if other mutually exclusive bits are used

        ExportBlock = (PIMAGE_EXPORT_DIRECTORY)( MappedFile + ExportDirOff );

        EntryCount = ExportBlock->NumberOfFunctions;
        FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ExportBlock->AddressOfFunctions );

        if (( FileOffset + EntryCount * sizeof( ULONG )) <= FileSize ) {
            memset( HintMap + FileOffset, 0x03, EntryCount * sizeof( ULONG )); // NOTE: may need to be OR'd if other bits are used
            }

        Entry = (PULONG)( MappedFile + FileOffset );

        while (( EntryCount-- ) && ((PUCHAR)( Entry + 1 ) <= MappedFileEnd )) {
            ChangeOldRvaToNewRva( RiftTable, Entry++ );
            }

        EntryCount = ExportBlock->NumberOfNames;
        FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ExportBlock->AddressOfNames );

        if (( FileOffset + EntryCount * sizeof( ULONG )) <= FileSize ) {
            memset( HintMap + FileOffset, 0x03, EntryCount * sizeof( ULONG )); // NOTE: may need to be OR'd if other bits are used
            }

        Entry = (PULONG)( MappedFile + FileOffset );

        while (( EntryCount-- ) && ((PUCHAR)( Entry + 1 ) <= MappedFileEnd )) {
            ChangeOldRvaToNewRva( RiftTable, Entry++ );
            }

        EntryCount = ExportBlock->NumberOfNames;
        FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ExportBlock->AddressOfNameOrdinals );

        if (( FileOffset + EntryCount * sizeof( USHORT )) <= FileSize ) {
            memset( HintMap + FileOffset, 0x03, EntryCount * sizeof( USHORT )); // NOTE: may need to be OR'd if other bits are used
            }

        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->Name );
        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->AddressOfFunctions );
        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->AddressOfNames );
        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->AddressOfNameOrdinals );
        }

    return;
    }


VOID
TransformOldFile_PE_Imports(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PVOID             FileMappedImage,
    IN ULONG             FileSize,
    IN PRIFT_TABLE       RiftTable,
    IN PUCHAR            HintMap
    )
    {
    PUCHAR                   MappedFile;
    PUCHAR                   MappedFileEnd;
    ULONG                    FileOffset;
    ULONG                    ImportDirOff;
    ULONG                    ImportDirSize;
    ULONG                    ImportByNameDataOffset;
    PIMAGE_IMPORT_BY_NAME    ImportByNameData;
    PIMAGE_IMPORT_DESCRIPTOR ImportBlock;
    PIMAGE_THUNK_DATA        ThunkDataStart;
    PIMAGE_THUNK_DATA        ThunkData;

    MappedFile    = FileMappedImage;
    MappedFileEnd = MappedFile + FileSize;

    ImportDirOff = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportDirSize );

    if (( ImportDirOff ) && (( ImportDirOff + ImportDirSize ) <= FileSize )) {

        memset( HintMap + ImportDirOff, 0x03, ImportDirSize );  // NOTE: may need to be OR'd if other mutually exclusive bits are used

        ImportBlock = (PIMAGE_IMPORT_DESCRIPTOR)( MappedFile + ImportDirOff );

        while (( (PUCHAR)( ImportBlock + 1 ) <= MappedFileEnd ) &&
               ( ImportBlock->OriginalFirstThunk != 0 )) {

            if ( ! ImportBlock->TimeDateStamp ) {

                FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ImportBlock->OriginalFirstThunk );

                ThunkData = ThunkDataStart = (PIMAGE_THUNK_DATA)( MappedFile + FileOffset );

                while (( (PUCHAR)( ThunkData + 1 ) <= MappedFileEnd ) &&
                       ( ThunkData->u1.Ordinal != 0 )) {

                    if ( ! IMAGE_SNAP_BY_ORDINAL( ThunkData->u1.Ordinal )) {

                        ImportByNameDataOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ThunkData->u1.AddressOfData );

                        ImportByNameData = (PIMAGE_IMPORT_BY_NAME)( MappedFile + ImportByNameDataOffset );

                        memset( HintMap + ImportByNameDataOffset, 0x03, strlen( (LPSTR)ImportByNameData->Name ) + 3 ); // NOTE: may need to be OR'd if other bits are used

                        ChangeOldRvaToNewRva( RiftTable, &ThunkData->u1.AddressOfData );
                        }

                    ThunkData++;
                    }

                memset( HintMap + FileOffset, 0x03, ((ULONG)ThunkData - (ULONG)ThunkDataStart )); // NOTE: may need to be OR'd if other bits are used

                FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ImportBlock->FirstThunk );

                ThunkData = ThunkDataStart = (PIMAGE_THUNK_DATA)( MappedFile + FileOffset );

                while (( (PUCHAR)( ThunkData + 1 ) <= MappedFileEnd ) &&
                       ( ThunkData->u1.Ordinal != 0 )) {

                    if ( ! IMAGE_SNAP_BY_ORDINAL( ThunkData->u1.Ordinal )) {

                        ImportByNameDataOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ThunkData->u1.AddressOfData );

                        ImportByNameData = (PIMAGE_IMPORT_BY_NAME)( MappedFile + ImportByNameDataOffset );

                        memset( HintMap + ImportByNameDataOffset, 0x03, strlen( (LPSTR)ImportByNameData->Name ) + 3 ); // NOTE: may need to be OR'd if other bits are used

                        ChangeOldRvaToNewRva( RiftTable, &ThunkData->u1.AddressOfData );
                        }

                    ThunkData++;
                    }

                memset( HintMap + FileOffset, 0x03, ((ULONG)ThunkData - (ULONG)ThunkDataStart )); // NOTE: may need to be OR'd if other bits are used
                }

            ChangeOldRvaToNewRva( RiftTable, &ImportBlock->Name );
            ChangeOldRvaToNewRva( RiftTable, &ImportBlock->OriginalFirstThunk );
            ChangeOldRvaToNewRva( RiftTable, &ImportBlock->FirstThunk );

            ImportBlock++;
            }
        }

    //
    //  BUGBUG:  Another other big thing that will prevent long matches through
    //           the IMAGE_IMPORT_BY_NAME entries is the Hint values which
    //           may change (from implib for dll being imported).  The Hint
    //           values are stored between each of the names.  Maybe a separate
    //           "hint rift table" to fix those, or zero out all the hints in
    //           both the old and new files, then after the new file is built,
    //           go fill-in the hint values.
    //
    //           Currently we have no infrastructure for pre-modification of
    //           the new file before compression and post-modification after
    //           decompression.
    //

    return;
    }


#ifdef DONTCOMPILE  // jmps2 and jmps3 are experimental


VOID
TransformOldFile_PE_RelativeJmps2(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PUCHAR            OldFileMapped,
    IN ULONG             OldFileSize,
    IN PUCHAR            NewFileMapped,         // OPTIONAL
    IN ULONG             NewFileSize,           // OPTIONAL
    IN PRIFT_TABLE       RiftTable,
    IN PUCHAR            HintMap
    )
    {
    PIMAGE_NT_HEADERS     NewNtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG                 SectionCount;
    PUCHAR                SectionStart;
    PUCHAR                SectionExtent;
    PUCHAR                SearchExtent;
    ULONG                 SectionLength;
    ULONG                 SectionOffset;
    ULONG                 SectionBaseRva;
    ULONG                 SectionLastRva;
    ULONG                 ImageLastRva;
    LONG                  Displacement;
    LONG                  NewDisplacement;
    ULONG                 OffsetInSection;
    ULONG                 OriginRva;
    ULONG                 TargetRva;
    ULONG                 NewOriginRva;
    ULONG                 NewTargetRva;
    ULONG                 i;
    PUCHAR                p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative call or branch instructions (different opcodes for
    //  different machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeBranchChanges = 0;
    ULONG CountRiftModifications = 0;
    ULONG CountRiftDeletions = 0;

    ULONG CountUnmatchedBranches = 0;

    ULONG CountUnmatchedE8 = 0;
    ULONG CountUnmatchedE9 = 0;
    ULONG CountUnmatched0F = 0;

    ULONG CountUnmatchedE8Targets = 0;
    ULONG CountUnmatchedE9Targets = 0;
    ULONG CountUnmatched0FTargets = 0;

    ULONG CountUnmatchedE8Followers = 0;
    ULONG CountUnmatchedE9Followers = 0;
    ULONG CountUnmatched0FFollowers = 0;

    ULONG CountUnmatchedE8Instructions = 0;
    ULONG CountUnmatchedE9Instructions = 0;
    ULONG CountUnmatched0FInstructions = 0;

    ULONG CountBranchInversions = 0;

#endif // TESTCODE

    NewNtHeader   = NewFileMapped ? GetNtHeader( NewFileMapped, NewFileSize ) : NULL;
    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = OldFileMapped + SectionOffset;
            SectionLastRva = SectionBaseRva + SectionLength;

            if (( SectionOffset < OldFileSize ) &&
                (( SectionOffset + SectionLength ) <= OldFileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if (( *p == 0xE8 ) ||       // call relative
                            ( *p == 0xE9 ) ||       // jmp relative
                            (( *p == 0x0F ) &&      // jcc relative (0F 8x)
                             (( *( p + 1 ) & 0xF0 ) == 0x80 ) &&
                             ( ++p < SearchExtent ))) {

                            //
                            //  Relative displacement is stored as
                            //  32-bit signed value following these
                            //  opcodes.  The displacement is relative
                            //  to the NEXT instruction, which is at
                            //  (p + 5).
                            //

                            Displacement = *(UNALIGNED LONG*)( p + 1 );

                            //
                            //  We expect a lot of false positives here because
                            //  occurences of <E8>, <E9>, and <0F><8x> will
                            //  likely occur in other parts of the instruction
                            //  stream so now we validate that the TargetRva
                            //  falls within the image and within an executable
                            //  section.
                            //
                            //  Also, for jmp and jcc instructions, verify that
                            //  the displacement is larger than +/- 127 because
                            //  if it wasn't, the instruction should have been
                            //  encoded as an 8-bit near branch, not a 32-bit
                            //  branch.  This prevents us from falsely matching
                            //  data that looks like:
                            //
                            //      xxE9xxxx 00000000
                            //

                            if (( *p == 0xE8 ) ||
                                ( Displacement >  127 ) ||
                                ( Displacement < -128 )) {

                                OffsetInSection = ( p + 5 ) - SectionStart;
                                OriginRva       = SectionBaseRva + OffsetInSection;
                                TargetRva       = OriginRva + Displacement;

                                if ((( TargetRva >= SectionBaseRva ) &&
                                     ( TargetRva <  SectionLastRva )) ||
                                    (( TargetRva <  ImageLastRva ) &&
                                     ( IsImageRvaInExecutableSection( NtHeader, TargetRva )))) {

                                    //
                                    //  Looks like a valid TargetRva.
                                    //

#ifndef PATCH_APPLY_CODE_ONLY

                                    //
                                    //  If we're creating the patch, then we need
                                    //  to validate the corresponding branch in the
                                    //  new file (might want to modify a rift entry).
                                    //

                                    if ( NewFileMapped != NULL ) {     // we're compressing

                                        BOOL OriginNext  = FALSE;
                                        BOOL OriginFound = FALSE;
                                        BOOL TargetNext  = FALSE;
                                        BOOL TargetFound = FALSE;

                                        ULONG  RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OriginRva );
                                        ULONG  NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                                        PUCHAR NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                                        ULONG NewOriginRva1 = NewOriginRva;
                                        ULONG NewOriginMo1  = NewOriginMa - NewFileMapped;
                                        ULONG NewOriginVa1  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;

                                        ULONG NewOriginRva2 = 0;
                                        ULONG NewOriginMo2  = 0;
                                        ULONG NewOriginVa2  = 0;

                                        UCHAR OldInstruction = *p;
                                        UCHAR NewInstruction = *( NewOriginMa - 5 );
                                        BOOL  InstructionsMatch = ( *p == *( NewOriginMa - 5 ));
                                        BOOL  FollowersMatch    = ( *( p + 5 ) == *NewOriginMa );
#endif // TESTCODE

                                        if (( *p == *( NewOriginMa - 5 )) &&    // instructions match, and
                                            (( *p == 0xE9 ) ||                  //   jmp instruction, or
                                             ( *( p + 5 ) == *NewOriginMa ))) { //   followers match

                                            OriginFound = TRUE;
                                            }

                                        else {

                                            if (( RiftIndexOrigin + 1 ) < RiftTable->RiftEntryCount ) {

                                                NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );
                                                NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                                                NewOriginRva2 = NewOriginRva;
                                                NewOriginMo2  = NewOriginMa - NewFileMapped;
                                                NewOriginVa2  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;
#endif // TESTCODE

                                                if (( *p == *( NewOriginMa - 5 )) &&    // instructions match, and
                                                    (( *p == 0xE9 ) ||                  //   jmp instruction, or
                                                     ( *( p + 5 ) == *NewOriginMa ))) { //   followers match

                                                    OriginFound = TRUE;
                                                    OriginNext  = TRUE;
                                                    }
                                                }
                                            }

                                        if ( OriginFound ) {

                                            ULONG  RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, TargetRva );
                                            ULONG  NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );
                                            PUCHAR NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );
                                            PUCHAR TargetMa = OldFileMapped + ImageRvaToFileOffset( NtHeader, TargetRva );

                                            if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                                TargetFound = TRUE;
                                                }

                                            else {

                                                if (( RiftIndexTarget + 1 ) < RiftTable->RiftEntryCount ) {

                                                    NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );
                                                    NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );

                                                    if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                                        TargetFound = TRUE;
                                                        TargetNext  = TRUE;
                                                        }
                                                    }
                                                }

                                            if ( TargetFound ) {    // target and origin found

                                                if ( OriginNext ) {

                                                    //
                                                    //  Coast the rift entry at [RiftIndexOrigin+1]
                                                    //  backwards to the Rva of the instruction.
                                                    //

                                                    LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva - OriginRva );

                                                    RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva -= Delta;
                                                    RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                                    ++CountRiftModifications;
#endif // TESTCODE
                                                    ASSERT( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );

                                                    if ( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva ) {
                                                         RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva;
#ifdef TESTCODE
                                                         ++CountRiftDeletions;
#endif // TESTCODE
                                                         }
                                                    }

                                                if ( TargetNext ) {

                                                    //
                                                    //  Coast the rift entry at [RiftIndexTarget+1]
                                                    //  backwards to the Rva of the target.
                                                    //

                                                    LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva - TargetRva );

                                                    RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva -= Delta;
                                                    RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                                    ++CountRiftModifications;
#endif // TESTCODE
                                                    ASSERT( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );

                                                    if ( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva ) {
                                                         RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva;
#ifdef TESTCODE
                                                         ++CountRiftDeletions;
#endif // TESTCODE
                                                         }
                                                    }
                                                }
                                            }
#ifdef TESTCODE
                                        if ( ! (( OriginFound ) && ( TargetFound ))) {

                                            ++CountUnmatchedBranches;

                                            switch ( *p ) {

                                                case 0xE8:

                                                    ++CountUnmatchedE8;

                                                    if ( OriginFound ) {
                                                        ++CountUnmatchedE8Targets;
                                                        }
                                                    else if ( InstructionsMatch ) {
                                                        ASSERT( ! FollowersMatch );
                                                        ++CountUnmatchedE8Followers;
                                                        }
                                                    else {
                                                        ++CountUnmatchedE8Instructions;

                                                        printf( "\rUnmatched E8 at old RVA %08X (VA %08X, FO %08X)\n"
                                                                  "    with either new RVA %08X (VA %08X, FO %08X)\n"
                                                                  "     or backcoasted RVA %08X (VA %08X, FO %08X)\n\n",
                                                                OriginRva - 5,
                                                                ( OriginRva - 5 ) + NtHeader->OptionalHeader.ImageBase,
                                                                p - OldFileMapped,
                                                                NewOriginRva1,
                                                                NewOriginVa1,
                                                                NewOriginMo1,
                                                                NewOriginRva2,
                                                                NewOriginVa2,
                                                                NewOriginMo2
                                                              );
                                                        }


                                                    break;

                                                case 0xE9:

                                                    ++CountUnmatchedE9;

                                                    if ( OriginFound ) {
                                                        ++CountUnmatchedE9Targets;
                                                        }
                                                    else {
                                                        ++CountUnmatchedE9Instructions;
                                                        }

                                                    break;

                                                default:

                                                    ++CountUnmatched0F;

                                                    if ( OriginFound ) {
                                                        ++CountUnmatched0FTargets;
                                                        }
                                                    else if ( InstructionsMatch ) {
                                                        ASSERT( ! FollowersMatch );
                                                        ++CountUnmatched0FFollowers;
                                                        }
                                                    else {
                                                        ++CountUnmatched0FInstructions;
                                                        }

                                                    if ( ! InstructionsMatch ) {
                                                        if (( OldInstruction & ~1 ) == ( NewInstruction & ~1 )) {
                                                            ++CountBranchInversions;
                                                            }
                                                        }

                                                    break;

                                                }
                                            }
#endif // TESTCODE
                                        }

#endif // PATCH_APPLY_CODE_ONLY

                                    NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                                    NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                                    NewDisplacement = NewTargetRva - NewOriginRva;

                                    if ( NewDisplacement != Displacement ) {
                                        *(UNALIGNED LONG*)( p + 1 ) = NewDisplacement;
#ifdef TESTCODE
                                        ++CountRelativeBranchChanges;
#endif // TESTCODE
                                        }

                                    p += 4;
                                    }
                                }
                            }
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative call/jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%d modified relative branches\n", CountRelativeBranchChanges );
    printf( "%d rift back-coasting modifications due to branch inspection\n", CountRiftModifications );
    printf( "%d rift deletions due to branch inspection back-coasting\n", CountRiftDeletions );
    printf( "%d total unmatched relative branches, composed of:\n", CountUnmatchedBranches );

    printf( "\t%d unmatched E8 (call)\n", CountUnmatchedE8 );
    printf( "\t\t%d unmatched E8 (call) instructions\n", CountUnmatchedE8Instructions );
    printf( "\t\t%d unmatched E8 (call) followers\n", CountUnmatchedE8Followers );
    printf( "\t\t%d unmatched E8 (call) targets\n", CountUnmatchedE8Targets );

    printf( "\t%d unmatched E9 (jmp)\n",    CountUnmatchedE9 );
    printf( "\t\t%d unmatched E9 (jmp) instructions\n", CountUnmatchedE9Instructions );
    printf( "\t\t%d unmatched E9 (jmp) targets\n", CountUnmatchedE9Targets );

    printf( "\t%d unmatched 0F 8x (jcc)\n", CountUnmatched0F );
    printf( "\t\t%d unmatched 0F 8x (jcc) instructions\n", CountUnmatched0FInstructions );
    printf( "\t\t\t%d unmatched 0F 8x (jcc) instruction inversions\n", CountBranchInversions );
    printf( "\t\t%d unmatched 0F 8x (jcc) followers\n", CountUnmatched0FFollowers );
    printf( "\t\t%d unmatched 0F 8x (jcc) targets\n", CountUnmatched0FTargets );

#endif // TESTCODE

    }


#ifdef _M_IX86

__inline char * mymemchr( char *buf, int c, unsigned count ) {

    __asm {
            mov     edi, buf
            mov     ecx, count
            mov     eax, c
            repne   scasb
            lea     eax, [edi-1]
            jz      RETURNIT
            xor     eax, eax
RETURNIT:
        }
    }

#else // ! _M_IX86

#define mymemchr memchr

#endif // ! _M_IX86



VOID
TransformOldFile_PE_RelativeJmps3(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PUCHAR            OldFileMapped,
    IN ULONG             OldFileSize,
    IN PUCHAR            NewFileMapped,         // OPTIONAL
    IN ULONG             NewFileSize,           // OPTIONAL
    IN PRIFT_TABLE       RiftTable,
    IN PUCHAR            HintMap
    )
    {
    PIMAGE_NT_HEADERS     NewNtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG                 SectionCount;
    PUCHAR                SectionStart;
    PUCHAR                SectionExtent;
    ULONG                 SearchExtent;
    ULONG                 SectionLength;
    ULONG                 SectionOffset;
    ULONG                 SectionBaseRva;
    ULONG                 SectionLastRva;
    ULONG                 ImageLastRva;
    LONG                  DisplacementValue;
    LONG                  NewDisplacement;
    LONG                  OffsetToRvaAdjust;
    ULONG                 FileOffset;
    ULONG                 TargetOffset;
    UCHAR                 Instruction;
    ULONG                 InstructionLength;
    ULONG                 DisplacementOrigin;
    ULONG                 DisplacementOffset;
    BOOL                  Skip;
    ULONG                 OffsetInSection;
    ULONG                 OriginRva;
    ULONG                 TargetRva;
    ULONG                 NewOriginRva;
    ULONG                 NewTargetRva;
    ULONG                 i;
    ULONG                 j;
    PUCHAR                p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative call or branch instructions (different opcodes for
    //  different machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeBranchChanges = 0;
    ULONG CountRiftModifications = 0;
    ULONG CountRiftDeletions = 0;

    ULONG CountUnmatchedBranches = 0;

    ULONG CountUnmatchedE8 = 0;
    ULONG CountUnmatchedE9 = 0;
    ULONG CountUnmatched0F = 0;

    ULONG CountUnmatchedE8Targets = 0;
    ULONG CountUnmatchedE9Targets = 0;
    ULONG CountUnmatched0FTargets = 0;

    ULONG CountUnmatchedE8Followers = 0;
    ULONG CountUnmatchedE9Followers = 0;
    ULONG CountUnmatched0FFollowers = 0;

    ULONG CountUnmatchedE8Instructions = 0;
    ULONG CountUnmatchedE9Instructions = 0;
    ULONG CountUnmatched0FInstructions = 0;

    ULONG CountBranchInversions = 0;

#endif // TESTCODE

    NewNtHeader   = NewFileMapped ? GetNtHeader( NewFileMapped, NewFileSize ) : NULL;
    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage - 1;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = OldFileMapped + SectionOffset;
            SectionLastRva = SectionBaseRva + SectionLength;
            OffsetToRvaAdjust = SectionHeader[ i ].VirtualAddress - SectionHeader[ i ].PointerToRawData;

            if (( SectionOffset < OldFileSize ) &&
                (( SectionOffset + SectionLength ) <= OldFileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionOffset + SectionLength - 6;

                    for ( FileOffset = SectionOffset; FileOffset < SearchExtent; FileOffset++ ) {

                        Instruction = OldFileMapped[ FileOffset ];

                        switch ( Instruction ) {

                            case 0xE8:

                                InstructionLength  = 6;     // E8 xx xx xx xx yy
                                DisplacementOrigin = FileOffset + 5;
                                DisplacementOffset = 1;
                                break;

                            case 0xE9:

                                InstructionLength  = 5;     // E9 xx xx xx xx
                                DisplacementOrigin = FileOffset + 5;
                                DisplacementOffset = 1;
                                break;

                            case 0x0F:

                                if (( OldFileMapped[ FileOffset + 1 ] & 0xF0 ) != 0x80 ) {
                                    continue;
                                    }

                                InstructionLength  = 7;     // 0F 8x yy yy yy yy zz
                                DisplacementOrigin = FileOffset + 6;
                                DisplacementOffset = 2;
                                break;

                            default:

                                continue;

                            }

                        Skip = FALSE;

                        for ( j = 0; j < InstructionLength; j++ ) {
                            if ( HintMap[ FileOffset + j ] & 0x01 ) {
                                Skip = TRUE;
                                break;
                                }
                            }

                        if ( Skip ) {
                            continue;
                            }

                        DisplacementValue = *(UNALIGNED LONG*)( OldFileMapped + FileOffset + DisplacementOffset );

                        if (( Instruction != 0xE8 ) &&
                            (( DisplacementValue > 127 ) || ( DisplacementValue < -128 ))) {

                            continue;
                            }

                        OriginRva = DisplacementOrigin + OffsetToRvaAdjust;
                        TargetRva = OriginRva + DisplacementValue;

                        if ( TargetRva > ImageLastRva ) {
                            continue;
                            }

                        TargetOffset = ImageRvaToFileOffset( NtHeader, TargetRva );

                        if ( HintMap[ TargetOffset ] & 0x01 ) {
                            continue;
                            }

#ifndef PATCH_APPLY_CODE_ONLY

                        //
                        //  If we're creating the patch, then we want
                        //  to validate the corresponding branch in the
                        //  new file (might want to modify a rift entry).
                        //

                        if ( NewFileMapped != NULL ) {     // we're compressing

                            BOOL OriginNext  = FALSE;
                            BOOL OriginFound = FALSE;
                            BOOL TargetNext  = FALSE;
                            BOOL TargetFound = FALSE;

                            ULONG  RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OriginRva );
                            ULONG  NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                            PUCHAR NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                            ULONG NewOriginRva1 = NewOriginRva;
                            ULONG NewOriginMo1  = NewOriginMa - NewFileMapped;
                            ULONG NewOriginVa1  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;

                            ULONG NewOriginRva2 = 0;
                            ULONG NewOriginMo2  = 0;
                            ULONG NewOriginVa2  = 0;

                            BOOL InstructionsMatch;
                            BOOL FollowersMatch;
                            BOOL BranchInversion;

                            BranchInversion = FALSE;

                            if ( Instruction == 0x0F ) {
                                InstructionsMatch = ( *( NewOriginMa - 6 ) == Instruction ) && ( *( NewOriginMa - 5 ) == OldFileMapped[ FileOffset + 1 ] );

                                if ( ! InstructionsMatch ) {
                                    BranchInversion = ( *( NewOriginMa - 6 ) == Instruction ) && (( *( NewOriginMa - 5 ) & ~1 ) == ( OldFileMapped[ FileOffset + 1 ] & ~1 ));
                                    }
                                }
                            else {
                                InstructionsMatch = ( *( NewOriginMa - 5 ) == Instruction );
                                }

                            FollowersMatch = ( *NewOriginMa == OldFileMapped[ DisplacementOrigin ] );

#endif // TESTCODE

                            if (( InstructionsMatch ) &&
                                (( FollowersMatch ) || ( Instruction == 0xE9 ))) {

                                OriginFound = TRUE;
                                }

                            else {

                                if (( RiftIndexOrigin + 1 ) < RiftTable->RiftEntryCount ) {

                                    NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );
                                    NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                                    NewOriginRva2 = NewOriginRva;
                                    NewOriginMo2  = NewOriginMa - NewFileMapped;
                                    NewOriginVa2  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;
#endif // TESTCODE

                                    if ( Instruction == 0x0F ) {
                                        InstructionsMatch = ( *( NewOriginMa - 6 ) == Instruction ) && ( *( NewOriginMa - 5 ) == OldFileMapped[ FileOffset + 1 ] );
                                        }
                                    else {
                                        InstructionsMatch = ( *( NewOriginMa - 5 ) == Instruction );
                                        }

                                    FollowersMatch = ( *NewOriginMa == OldFileMapped[ DisplacementOrigin ] );

                                    if (( InstructionsMatch ) &&
                                        (( FollowersMatch ) || ( Instruction == 0xE9 ))) {

                                        OriginFound = TRUE;
                                        OriginNext  = TRUE;
                                        }
                                    }
                                }

                            if ( OriginFound ) {

                                ULONG  RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, TargetRva );
                                ULONG  NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );
                                PUCHAR NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );
                                PUCHAR TargetMa = OldFileMapped + ImageRvaToFileOffset( NtHeader, TargetRva );

                                if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                    TargetFound = TRUE;
                                    }

                                else {

                                    if (( RiftIndexTarget + 1 ) < RiftTable->RiftEntryCount ) {

                                        NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );
                                        NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );

                                        if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                            TargetFound = TRUE;
                                            TargetNext  = TRUE;
                                            }
                                        }
                                    }

                                if ( TargetFound ) {    // target and origin found

                                    if ( OriginNext ) {

                                        //
                                        //  Coast the rift entry at [RiftIndexOrigin+1]
                                        //  backwards to the Rva of the instruction.
                                        //

                                        LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva - OriginRva );

                                        RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva -= Delta;
                                        RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                        ++CountRiftModifications;
#endif // TESTCODE
                                        ASSERT( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );

                                        if ( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva ) {
                                             RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva;
#ifdef TESTCODE
                                             ++CountRiftDeletions;
#endif // TESTCODE
                                             }
                                        }

                                    if ( TargetNext ) {

                                        //
                                        //  Coast the rift entry at [RiftIndexTarget+1]
                                        //  backwards to the Rva of the target.
                                        //

                                        LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva - TargetRva );

                                        RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva -= Delta;
                                        RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                        ++CountRiftModifications;
#endif // TESTCODE
                                        ASSERT( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );

                                        if ( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva ) {
                                             RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva;
#ifdef TESTCODE
                                             ++CountRiftDeletions;
#endif // TESTCODE
                                             }
                                        }
                                    }
                                }
#ifdef TESTCODE
                            if ( ! (( OriginFound ) && ( TargetFound ))) {

                                ++CountUnmatchedBranches;

                                switch ( Instruction ) {

                                    case 0xE8:

                                        ++CountUnmatchedE8;

                                        if ( OriginFound ) {
                                            ++CountUnmatchedE8Targets;
                                            }
                                        else if ( InstructionsMatch ) {
                                            ASSERT( ! FollowersMatch );
                                            ++CountUnmatchedE8Followers;
                                            }
                                        else {
                                            ++CountUnmatchedE8Instructions;

                                            printf( "\rUnmatched E8 at old RVA %08X (VA %08X, FO %08X)\n"
                                                      "    with either new RVA %08X (VA %08X, FO %08X)\n"
                                                      "     or backcoasted RVA %08X (VA %08X, FO %08X)\n\n",
                                                    OriginRva - 5,
                                                    ( OriginRva - 5 ) + NtHeader->OptionalHeader.ImageBase,
                                                    FileOffset,
                                                    NewOriginRva1,
                                                    NewOriginVa1,
                                                    NewOriginMo1,
                                                    NewOriginRva2,
                                                    NewOriginVa2,
                                                    NewOriginMo2
                                                  );
                                            }


                                        break;

                                    case 0xE9:

                                        ++CountUnmatchedE9;

                                        if ( OriginFound ) {
                                            ++CountUnmatchedE9Targets;
                                            }
                                        else {
                                            ++CountUnmatchedE9Instructions;
                                            }

                                        break;

                                    default:

                                        ++CountUnmatched0F;

                                        if ( OriginFound ) {
                                            ++CountUnmatched0FTargets;
                                            }
                                        else if ( InstructionsMatch ) {
                                            ASSERT( ! FollowersMatch );
                                            ++CountUnmatched0FFollowers;
                                            }
                                        else {
                                            ++CountUnmatched0FInstructions;
                                            }

                                        if ( BranchInversion ) {
                                            ++CountBranchInversions;
                                            }

                                        break;

                                    }
                                }
#endif // TESTCODE
                            }

#endif // PATCH_APPLY_CODE_ONLY

                        NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                        NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                        NewDisplacement = NewTargetRva - NewOriginRva;

                        if ( NewDisplacement != DisplacementValue ) {
                            *(UNALIGNED LONG*)( OldFileMapped + FileOffset + DisplacementOffset ) = NewDisplacement;
#ifdef TESTCODE
                            ++CountRelativeBranchChanges;
#endif // TESTCODE
                            }

                        FileOffset = DisplacementOrigin - 1;
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative call/jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%d modified relative branches\n", CountRelativeBranchChanges );
    printf( "%d rift back-coasting modifications due to branch inspection\n", CountRiftModifications );
    printf( "%d rift deletions due to branch inspection back-coasting\n", CountRiftDeletions );
    printf( "%d total unmatched relative branches, composed of:\n", CountUnmatchedBranches );

    printf( "\t%d unmatched E8 (call)\n", CountUnmatchedE8 );
    printf( "\t\t%d unmatched E8 (call) instructions\n", CountUnmatchedE8Instructions );
    printf( "\t\t%d unmatched E8 (call) followers\n", CountUnmatchedE8Followers );
    printf( "\t\t%d unmatched E8 (call) targets\n", CountUnmatchedE8Targets );

    printf( "\t%d unmatched E9 (jmp)\n",    CountUnmatchedE9 );
    printf( "\t\t%d unmatched E9 (jmp) instructions\n", CountUnmatchedE9Instructions );
    printf( "\t\t%d unmatched E9 (jmp) targets\n", CountUnmatchedE9Targets );

    printf( "\t%d unmatched 0F 8x (jcc)\n", CountUnmatched0F );
    printf( "\t\t%d unmatched 0F 8x (jcc) instructions\n", CountUnmatched0FInstructions );
    printf( "\t\t\t%d unmatched 0F 8x (jcc) instruction inversions\n", CountBranchInversions );
    printf( "\t\t%d unmatched 0F 8x (jcc) followers\n", CountUnmatched0FFollowers );
    printf( "\t\t%d unmatched 0F 8x (jcc) targets\n", CountUnmatched0FTargets );

#endif // TESTCODE

    }


#endif // DONTCOMPILE

VOID
TransformOldFile_PE_RelativeJmps(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PVOID             FileMappedImage,
    IN ULONG             FileSize,
    IN PRIFT_TABLE       RiftTable,
    IN PUCHAR            HintMap
    )
    {
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG                 SectionCount;
    PUCHAR                SectionStart;
    PUCHAR                SearchExtent;
    ULONG                 SectionLength;
    ULONG                 SectionOffset;
    ULONG                 SectionBaseRva;
    ULONG                 ImageLastRva;
    LONG                  Displacement;
    LONG                  NewDisplacement;
    ULONG                 OffsetInSection;
    ULONG                 OriginRva;
    ULONG                 TargetRva;
    ULONG                 NewOriginRva;
    ULONG                 NewTargetRva;
    ULONG                 TargetOffset;
    BOOL                  Skip;
    ULONG                 i;
    ULONG                 j;
    PUCHAR                p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative branch instructions (different opcodes for different
    //  machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeBranchChanges = 0;

#endif // TESTCODE

    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = (PUCHAR)FileMappedImage + SectionOffset;

            if (( SectionOffset < FileSize ) &&
                (( SectionOffset + SectionLength ) <= FileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if (( *p == 0xE9 ) ||       // jmp relative32 (E9)
                            (( *p == 0x0F ) &&      // jcc relative32 (0F 8x)
                             (( *( p + 1 ) & 0xF0 ) == 0x80 ) &&
                             ( ++p < SearchExtent ))) {

                            //
                            //  Validate that instruction and target are NOT
                            //  something we've already identified as something
                            //  else (reloc target, etc).
                            //

                            Skip = FALSE;

                            if (( *p & 0xF0 ) == 0x80 ) {
                                if ( HintMap[ SectionOffset + ( p - SectionStart ) - 1 ] & 0x01 ) {
                                    Skip = TRUE;
                                    }
                                }

                            if ( ! Skip ) {
                                for ( j = 0; j < 5; j++ ) {
                                    if ( HintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                        Skip = TRUE;
                                        break;
                                        }
                                    }
                                }

                            if ( ! Skip ) {

                                //
                                //  Relative displacement is stored as 32-bit
                                //  signed value following these opcodes.  The
                                //  displacement is relative to the NEXT
                                //  instruction, which is at (p + 5).
                                //
                                //  Also, for jmp and jcc instructions, verify that
                                //  the displacement is larger than +/- 127 because
                                //  if it wasn't, the instruction should have been
                                //  encoded as an 8-bit near branch, not a 32-bit
                                //  branch.  This prevents us from falsely matching
                                //  data that looks like:
                                //
                                //      xxE9xxxx 00000000
                                //

                                Displacement = *(UNALIGNED LONG*)( p + 1 );

                                if (( Displacement >  127 ) ||
                                    ( Displacement < -128 )) {

                                    OffsetInSection = ( p + 5 ) - SectionStart;
                                    OriginRva       = SectionBaseRva + OffsetInSection;
                                    TargetRva       = OriginRva + Displacement;

                                    //
                                    //  We expect a lot of false positives here because
                                    //  occurences of <E9>, and <0F><8x> will
                                    //  likely occur in other parts of the instruction
                                    //  stream so now we validate that the TargetRva
                                    //  falls within the image and within an executable
                                    //  section.
                                    //

                                    if ( TargetRva < ImageLastRva ) {

                                        TargetOffset = ImageRvaToFileOffset( NtHeader, TargetRva );

                                        if ( ! ( HintMap[ TargetOffset ] & 0x01 )) {

                                            //
                                            //  Looks like a valid TargetRva, so lookup its
                                            //  corresponding "new" RVA in the rift table.
                                            //

                                            NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                                            NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                                            NewDisplacement = NewTargetRva - NewOriginRva;

                                            if (( NewDisplacement >  127 ) ||
                                                ( NewDisplacement < -128 )) {

                                                if ( NewDisplacement != Displacement ) {

                                                    *(UNALIGNED LONG*)( p + 1 ) = NewDisplacement;
#ifdef TESTCODE
                                                    ++CountRelativeBranchChanges;
#endif // TESTCODE
                                                    }
                                                }

                                            else {

                                                //
                                                //  If new displacement is 8 bits, it would be
                                                //  encoded as an 8-bit relative instruction.
                                                //  For E9, instructions, that is EB.  For
                                                //  0F 8x instructions, that is 7x.  In both
                                                //  cases, we're shrinking the instruction stream.
                                                //  We'll leave the extra bytes alone.
                                                //

                                                if ( *p == 0xE9 ) {

                                                    *p = 0xEB;
                                                    *( p + 1 ) = (CHAR) NewDisplacement;
                                                    }

                                                else {

                                                    *( p - 1 ) = (UCHAR)(( *p & 0x0F ) | ( 0x70 ));
                                                    *p = (CHAR) NewDisplacement;
                                                    }

#ifdef TESTCODE
                                                ++CountRelativeBranchChanges;
#endif // TESTCODE

                                                }

                                            p += 4;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%9d modified relative branches\n", CountRelativeBranchChanges );

#endif // TESTCODE

    }


VOID
TransformOldFile_PE_RelativeCalls(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PVOID             FileMappedImage,
    IN ULONG             FileSize,
    IN PRIFT_TABLE       RiftTable,
    IN PUCHAR            HintMap
    )
    {
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG                 SectionCount;
    PUCHAR                SectionStart;
    PUCHAR                SearchExtent;
    ULONG                 SectionLength;
    ULONG                 SectionOffset;
    ULONG                 SectionBaseRva;
    ULONG                 ImageLastRva;
    LONG                  Displacement;
    LONG                  NewDisplacement;
    ULONG                 OffsetInSection;
    ULONG                 OriginRva;
    ULONG                 TargetRva;
    ULONG                 NewOriginRva;
    ULONG                 NewTargetRva;
    ULONG                 TargetOffset;
    BOOL                  Skip;
    ULONG                 i;
    ULONG                 j;
    PUCHAR                p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative call or branch instructions (different opcodes for
    //  different machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeCallChanges = 0;

#endif // TESTCODE

    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = (PUCHAR)FileMappedImage + SectionOffset;

            if (( SectionOffset < FileSize ) &&
                (( SectionOffset + SectionLength ) <= FileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if ( *p == 0xE8 ) {         // call relative32

                            //
                            //  Validate that instruction and target are NOT
                            //  something we've already identified as something
                            //  else (reloc target, etc).
                            //

                            Skip = FALSE;

                            for ( j = 0; j < 5; j++ ) {
                                if ( HintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                    Skip = TRUE;
                                    break;
                                    }
                                }

                            if ( ! Skip ) {

                                //
                                //  Relative displacement is stored as 32-bit
                                //  signed value following these opcodes.  The
                                //  displacement is relative to the NEXT
                                //  instruction, which is at (p + 5).
                                //

                                Displacement    = *(UNALIGNED LONG*)( p + 1 );
                                OffsetInSection = ( p + 5 ) - SectionStart;
                                OriginRva       = SectionBaseRva + OffsetInSection;
                                TargetRva       = OriginRva + Displacement;

                                //
                                //  We expect a lot of false positives here because
                                //  occurences of <E8> will
                                //  likely occur in other parts of the instruction
                                //  stream so now we validate that the TargetRva
                                //  falls within the image and within an executable
                                //  section.
                                //

                                if ( TargetRva < ImageLastRva ) {

                                    TargetOffset = ImageRvaToFileOffset( NtHeader, TargetRva );

                                    if ( ! ( HintMap[ TargetOffset ] & 0x01 )) {

                                        //
                                        //  Looks like a valid TargetRva, so lookup its
                                        //  corresponding "new" RVA in the rift table.
                                        //

                                        NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                                        NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                                        NewDisplacement = NewTargetRva - NewOriginRva;

                                        if ( NewDisplacement != Displacement ) {

                                            *(UNALIGNED LONG*)( p + 1 ) = NewDisplacement;
#ifdef TESTCODE
                                            ++CountRelativeCallChanges;
#endif // TESTCODE
                                            }

                                        p += 4;
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative call/jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%9d modified relative calls\n", CountRelativeCallChanges );

#endif // TESTCODE

    }


VOID
TransformOldFile_PE_MarkNonExe(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PUCHAR            OldFileMapped,
    IN ULONG             OldFileSize,
    IN PUCHAR            HintMap
    )
    {
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG Offset;
    ULONG Size;
    ULONG Rva;
    ULONG i;

    UNREFERENCED_PARAMETER( OldFileMapped );

    //
    //  Need to mark all non-exectuble bytes in hint map:
    //
    //      Image header
    //      All PE image directories (import, export, etc)
    //      All non-executable sections
    //      All relocation targets
    //         (a reloc target can be in the middle of an instruction, but
    //          never the first byte of an instruction)
    //
    //  NOTE: This is the first painting routine run, so it does memset
    //        instead of bitwise OR, knowing that only zeros already exist.
    //

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( ! ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE )) {

            Offset = SectionHeader[ i ].PointerToRawData;

            if ( Offset < OldFileSize ) {

                Size = SectionHeader[ i ].SizeOfRawData;

                if ( Size > ( OldFileSize - Offset )) {
                     Size = ( OldFileSize - Offset );
                     }

                memset( HintMap + Offset, 0x01, Size );
                }
            }
        }

    memset( HintMap, 0x03, NtHeader->OptionalHeader.SizeOfHeaders );

    for ( i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++ ) {

        Rva  = NtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress;
        Size = NtHeader->OptionalHeader.DataDirectory[ i ].Size;

        if (( Rva != 0 ) && ( Size != 0 )) {

            Offset = ImageRvaToFileOffset( NtHeader, Rva );

            if (( Offset != 0 ) && ( Offset < OldFileSize )) {

                if ( Size > ( OldFileSize - Offset )) {
                     Size = ( OldFileSize - Offset );
                     }

                memset( HintMap + Offset, 0x03, Size );
                }
            }
        }
    }


typedef struct _RES_RECURSION_CONTEXT {
    PRIFT_TABLE RiftTable;
    PUCHAR      ResBase;
    PUCHAR      ResEnd;
    ULONG       ResSize;
    ULONG       ResDone;
    ULONG       ResTime;
    ULONG       OldResRva;
    ULONG       NewResRva;
    BOOL        AnyErrors;
    } RES_RECURSION_CONTEXT, *PRES_RECURSION_CONTEXT;


VOID
TransformResourceRecursive(
    IN PRES_RECURSION_CONTEXT ResContext,
    IN IMAGE_RESOURCE_DIRECTORY UNALIGNED* ResDir
    )
    {
    IMAGE_RESOURCE_DIRECTORY_ENTRY UNALIGNED* ResEntry;
    IMAGE_RESOURCE_DATA_ENTRY      UNALIGNED* ResData;
    ULONG ResCount;
    ULONG NewOff;
    ULONG NewRva;

    if (((PUCHAR)( ResDir     ) < ResContext->ResBase ) ||
        ((PUCHAR)( ResDir + 1 ) > ResContext->ResEnd  )) {

        DEBUGCODE(
            printf(
                "\rTransformResource: ResDir at RVA %06X out of range %06X-%06X\n",
                ResContext->OldResRva + ((PUCHAR)ResDir - ResContext->ResBase ),
                ResContext->OldResRva,
                ResContext->OldResRva + ResContext->ResSize
                )
            );

        ResContext->AnyErrors = TRUE;
        return;
        }

    ResContext->ResDone += sizeof( *ResDir );

    if ( ResContext->ResDone > ResContext->ResSize ) {
        DEBUGCODE( printf( "\rTransformResource: ResDone %u exceeds ResSize %u\n", ResContext->ResDone, ResContext->ResSize ));
        ResContext->AnyErrors = TRUE;
        return;
        }

    if ( ResDir->TimeDateStamp != ResContext->ResTime ) {
         ResDir->TimeDateStamp  = ResContext->ResTime;
         }

    ResCount = ResDir->NumberOfNamedEntries + ResDir->NumberOfIdEntries;
    ResEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( ResDir + 1 );

    while ( ResCount > 0 ) {

        if ((PUCHAR)( ResEntry + 1 ) > ResContext->ResEnd ) {

            DEBUGCODE(
                printf(
                    "\rTransformResource: ResEntry at RVA %06X out of range %06X-%06X\n",
                    ResContext->OldResRva + ((PUCHAR)ResEntry - ResContext->ResBase ),
                    ResContext->OldResRva,
                    ResContext->OldResRva + ResContext->ResSize
                    )
                );

            ResContext->AnyErrors = TRUE;
            return;
        }

        ResContext->ResDone += sizeof( *ResEntry );

        if ( ResContext->ResDone > ResContext->ResSize ) {
            DEBUGCODE( printf( "\rTransformResource: ResDone %u exceeds ResSize %u\n", ResContext->ResDone, ResContext->ResSize ));
            ResContext->AnyErrors = TRUE;
            return;
            }

        if ( ResEntry->DataIsDirectory ) {

            if (( ResEntry->OffsetToDirectory + sizeof( IMAGE_RESOURCE_DIRECTORY )) > ResContext->ResSize ) {

                DEBUGCODE(
                    printf(
                        "\rTransformResource: ResEntry->OffsetToDirectory %06X (+%u) exceeds ResDirSize %06X\n",
                        ResEntry->OffsetToDirectory,
                        sizeof( IMAGE_RESOURCE_DIRECTORY ),
                        ResContext->ResSize
                        )
                    );

                ResContext->AnyErrors = TRUE;

                //
                //  This is not fatal, but previously this would trigger bad resource for backward compat.
                //

                }

            else {

                TransformResourceRecursive(
                    ResContext,
                    (PIMAGE_RESOURCE_DIRECTORY)( ResContext->ResBase + ResEntry->OffsetToDirectory )
                    );

                if ( ResContext->ResDone > ResContext->ResSize ) {
                    ResContext->AnyErrors = TRUE;
                    return;
                    }
                }
            }

        else {

            ResData = (PIMAGE_RESOURCE_DATA_ENTRY)( ResContext->ResBase + ResEntry->OffsetToData );

            if (((PUCHAR)( ResData     ) < ResContext->ResBase ) ||
                ((PUCHAR)( ResData + 1 ) > ResContext->ResEnd  )) {

                DEBUGCODE(
                    printf(
                        "\rTransformResource: ResData at RVA %06X out of range %06X-%06X\n",
                        ResContext->OldResRva + ((PUCHAR)ResData - ResContext->ResBase ),
                        ResContext->OldResRva,
                        ResContext->OldResRva + ResContext->ResSize
                        )
                    );

                ResContext->AnyErrors = TRUE;

                //
                //  This is not fatal, and did not previously trigger bad resource directory for backwards compat.
                //
                }

            else {

                ResContext->ResDone += ResData->Size;

                if ( ResContext->ResDone > ResContext->ResSize ) {
                    DEBUGCODE( printf( "\rTransformResource: ResDone %u exceeds ResSize %u\n", ResContext->ResDone, ResContext->ResSize ));
                    ResContext->AnyErrors = TRUE;
                    return;
                    }

                //
                //  ResData->OffsetToData is an RVA, not offset from ResBase.
                //

                NewRva = GetNewRvaFromRiftTable( ResContext->RiftTable, ResData->OffsetToData );

                if ( ResData->OffsetToData != NewRva ) {
                     ResData->OffsetToData  = NewRva;
                     }
                }
            }

        NewRva = GetNewRvaFromRiftTable( ResContext->RiftTable, ResContext->OldResRva + ResEntry->OffsetToDirectory );
        NewOff = NewRva - ResContext->NewResRva;

        if ( ResEntry->OffsetToDirectory != NewOff ) {
             ResEntry->OffsetToDirectory  = NewOff;
             }

        if ( ResEntry->NameIsString ) {

            NewRva = GetNewRvaFromRiftTable( ResContext->RiftTable, ResContext->OldResRva + ResEntry->NameOffset );
            NewOff = NewRva - ResContext->NewResRva;

            if ( ResEntry->NameOffset != NewOff ) {
                 ResEntry->NameOffset  = NewOff;
                 }
            }

        ++ResEntry;
        --ResCount;
        }
    }


BOOL
TransformOldFile_PE_Resources(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PUCHAR            OldFileMapped,
    IN ULONG             OldFileSize,
    IN ULONG             NewFileResTime,
    IN PRIFT_TABLE       RiftTable
    )
    {
    RES_RECURSION_CONTEXT ResContext;

    ResContext.ResBase = ImageDirectoryMappedAddress(
                             NtHeader,
                             IMAGE_DIRECTORY_ENTRY_RESOURCE,
                             &ResContext.ResSize,
                             OldFileMapped,
                             OldFileSize
                             );

    if (( ResContext.ResBase != 0 ) && ( ResContext.ResSize >= sizeof( IMAGE_RESOURCE_DIRECTORY ))) {

        ResContext.ResEnd    = ResContext.ResBase + ResContext.ResSize;
        ResContext.ResDone   = 0;
        ResContext.OldResRva = ImageDirectoryRvaAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_RESOURCE, NULL );
        ResContext.NewResRva = GetNewRvaFromRiftTable( RiftTable, ResContext.OldResRva );
        ResContext.ResTime   = NewFileResTime;
        ResContext.RiftTable = RiftTable;
        ResContext.AnyErrors = FALSE;

        TransformResourceRecursive(
            &ResContext,
            (PIMAGE_RESOURCE_DIRECTORY) ResContext.ResBase
            );

        return ( ! ResContext.AnyErrors );
        }

    return TRUE;
    }


BOOL
TransformCoffImage(
    IN OUT PULONG            TransformOptions,
    IN OUT PIMAGE_NT_HEADERS NtHeader,
    IN OUT PUCHAR            OldFileMapped,
    IN     ULONG             OldFileSize,
    IN     ULONG             NewFileResTime,
    IN OUT PRIFT_TABLE       RiftTable,
    IN OUT PUCHAR OPTIONAL   HintMap,
    ...
    )
    {
    ULONG  OptionsX = *TransformOptions;
    PUCHAR InternalHintMap = NULL;
    BOOL   Success = FALSE;

#ifndef PATCH_APPLY_CODE_ONLY

    if ( OptionsX & PATCH_TRANSFORM_CREATION ) {

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RELOCS )) {

            __try {
                Success = PeValidateRelocations( NtHeader, OldFileMapped, OldFileSize );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                Success = FALSE;
                }

            if ( ! Success ) {
                OptionsX |= PATCH_TRANSFORM_NO_RELOCS;
                }
            }

#ifdef DONTCOMPILE

        //
        //  This code turns off NEW_IRELOC if a reloc directory exists,
        //  presumably to save extended options dword in patch header,
        //  and to make new patches compatibile with old applyers when
        //  otherwise don't need new applyer.
        //

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RELOCS )) {

            if ( OptionsX & PATCH_TRANSFORM_PE_IRELOC_2 ) {

                __try {

                    if ( NtHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386 ) {

                        //
                        //  Don't need PATCH_TRANSFORM_PE_IRELOC_2 semantics
                        //  (costs extra DWORD for extended options in header)
                        //

                        OptionsX &= ~PATCH_TRANSFORM_PE_IRELOC_2;
                        }

                    else {

                        ULONG RelocDirSize = 0;
                        ULONG RelocDirOff  = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_BASERELOC, &RelocDirSize );

                        if (( RelocDirOff != 0 ) && (( RelocDirOff + RelocDirSize ) <= OldFileSize )) {

                            //
                            //  Don't need PATCH_TRANSFORM_PE_IRELOC_2 semantics
                            //  (costs extra DWORD for extended options in header)
                            //

                            OptionsX &= ~PATCH_TRANSFORM_PE_IRELOC_2;
                            }
                        }
                    }
                __except( EXCEPTION_EXECUTE_HANDLER ) {
                    }
                }
            }

#endif DONTCOMPILE

#ifdef DONTCOMPILE  // UNDONE: Implement PeValidateImports/Exports/Resources

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_IMPORTS )) {

            __try {
                Success = PeValidateImports( NtHeader, OldFileMapped, OldFileSize );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                Success = FALSE;
                }

            if ( ! Success ) {
                OptionsX |= PATCH_TRANSFORM_NO_IMPORTS;
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_EXPORTS )) {

            __try {
                Success = PeValidateExports( NtHeader, OldFileMapped, OldFileSize );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                Success = FALSE;
                }

            if ( ! Success ) {
                OptionsX |= PATCH_TRANSFORM_NO_EXPORTS;
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RESOURCE )) {

            __try {
                Success = PeValidateResources( NtHeader, OldFileMapped, OldFileSize );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                Success = FALSE;
                }

            if ( ! Success ) {
                OptionsX |= PATCH_TRANSFORM_NO_RESOURCE;
                }
            }

#endif DONTCOMPILE

        *TransformOptions = OptionsX;
        }


#endif // ! PATCH_APPLY_CODE_ONLY


#ifndef PATCH_APPLY_CODE_ONLY

    //
    //  Initialize (zero) the rift usage array
    //

    if ( RiftTable->RiftUsageArray != NULL ) {
        ZeroMemory( RiftTable->RiftUsageArray, RiftTable->RiftEntryAlloc * sizeof( RiftTable->RiftUsageArray[ 0 ] ));
        }

#endif // ! PATCH_APPLY_CODE_ONLY


    //
    //  Allocated parallel "hint" mapping the same size as the old
    //  file.  Each one of the 8 bits corresponding to each byte in
    //  the old file can be used to track information about that
    //  byte during the transformations.
    //

    if ( HintMap == NULL ) {

        InternalHintMap = MyVirtualAlloc( OldFileSize );

        if ( InternalHintMap == NULL ) {
            return FALSE;   // GLE already set
            }

        HintMap = InternalHintMap;
        }

    //
    //  Apply PE image transforms (each inside try/except)
    //

    Success = TRUE;     // innocent until proven guilty

    __try {
        TransformOldFile_PE_MarkNonExe( NtHeader, OldFileMapped, OldFileSize, HintMap );
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        Success = FALSE;
        }

    if ( OptionsX & ( PATCH_TRANSFORM_PE_IRELOC_2 | PATCH_TRANSFORM_PE_RESOURCE_2 )) {

        //
        //  Do PE structure walking transforms first, then do reloc, then E8/0F8x.
        //

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_IMPORTS )) {
            __try {
                TransformOldFile_PE_Imports( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_EXPORTS )) {
            __try {
                TransformOldFile_PE_Exports( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RESOURCE )) {
            __try {
                TransformOldFile_PE_Resources( NtHeader, OldFileMapped, OldFileSize, NewFileResTime, RiftTable );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RELOCS )) {
            __try {

                if ( ! ( OptionsX & PATCH_TRANSFORM_PE_IRELOC_2 )) {
                    TransformOldFile_PE_Relocations( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                    }
                else {

                    ULONG RelocDirSize = 0;
                    ULONG RelocDirOff  = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_BASERELOC, &RelocDirSize );

                    if (( RelocDirOff ) && (( RelocDirOff + RelocDirSize ) <= OldFileSize )) {
                        TransformOldFile_PE_Relocations( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                        }
                    else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {
                        TransformOldFile_PE_InferRelocsX86( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                        }
                    }
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RELJMPS )) {
            __try {
                TransformOldFile_PE_RelativeJmps( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RELCALLS )) {
            __try {
                TransformOldFile_PE_RelativeCalls( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }
        }

    else {

        //
        //  Old compatible transform order.
        //

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RELOCS )) {
            __try {
                TransformOldFile_PE_Relocations( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_IMPORTS )) {
            __try {
                TransformOldFile_PE_Imports( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_EXPORTS )) {
            __try {
                TransformOldFile_PE_Exports( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RELJMPS )) {
            __try {
                TransformOldFile_PE_RelativeJmps( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RELCALLS )) {
            __try {
                TransformOldFile_PE_RelativeCalls( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( OptionsX & PATCH_TRANSFORM_NO_RESOURCE )) {

#ifndef PATCH_APPLY_CODE_ONLY

            if ( OptionsX & PATCH_TRANSFORM_CREATION ) {

                __try {
                    Success = TransformOldFile_PE_Resources( NtHeader, OldFileMapped, OldFileSize, NewFileResTime, RiftTable );
                    }
                __except( EXCEPTION_EXECUTE_HANDLER ) {
                    Success = FALSE;
                    }

                if ( ! Success ) {
                    SetLastError( PATCH_ERROR_RETRY_NO_RESOURCE );  // creation caller must remap and retry with PATCH_TRANSFORM_NO_RESOURCE
                    }
                }

            else

#endif
                {   // applying: no error return

                __try {
                    TransformOldFile_PE_Resources( NtHeader, OldFileMapped, OldFileSize, NewFileResTime, RiftTable );
                    }
                __except( EXCEPTION_EXECUTE_HANDLER ) {
                    }
                }
            }
        }

    if ( InternalHintMap != NULL ) {
        MyVirtualFree( InternalHintMap );
        }

    return Success;
    }


#ifndef PATCH_APPLY_CODE_ONLY

BOOL
PeValidateRelocations(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PUCHAR            FileMapped,
    IN ULONG             FileSize
    )
{
    __try
    {
        ULONG ImageSize    = NtHeader->OptionalHeader.SizeOfImage;
        ULONG RelocDirSize = 0;
        ULONG RelocDirOff  = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_BASERELOC, &RelocDirSize );
        ULONG RelocBaseRva;
        ULONG RelocCount;
        ULONG BlockSize;
        USHORT UNALIGNED* RelocEntry;
        IMAGE_BASE_RELOCATION UNALIGNED* RelocBlock;

        if ( RelocDirOff != 0 )
        {
            if (( RelocDirOff + RelocDirSize ) > FileSize )
            {
                DEBUGCODE( printf( "\rWarning: .reloc dir extent (%06X+%X) exceeds file size (%06X)\n", RelocDirOff, RelocDirSize, FileSize ));
                return FALSE;
            }

            RelocBlock = (PIMAGE_BASE_RELOCATION)( FileMapped + RelocDirOff );

            while ( RelocDirSize != 0 )
            {
                if ( RelocDirSize < sizeof( IMAGE_BASE_RELOCATION ))
                {
                    DEBUGCODE( printf( "\rWarning: .reloc residual size (%u) too small for reloc block\n", RelocDirSize ));
                    return FALSE;
                }

                if ( (ULONG_PTR)RelocBlock & 3 )
                {
                    DEBUGCODE( printf( "\rWarning: .reloc block misaligned\n" ));
                    // not fatal, we use explicit unaligned dereferences
                }

                RelocBaseRva = RelocBlock->VirtualAddress;
                BlockSize    = RelocBlock->SizeOfBlock;

                if ( BlockSize > RelocDirSize )
                {
                    DEBUGCODE( printf( "\rWarning: .reloc block size %u exceeds remaining .reloc dir size %u\n", BlockSize, RelocDirSize ));
                    return FALSE;
                }

                if ( BlockSize < sizeof( IMAGE_BASE_RELOCATION ))
                {
                    DEBUGCODE( printf( "\rWarning: .reloc block size %u smaller than minimum size %u\n", BlockSize, sizeof( IMAGE_BASE_RELOCATION )));
                    return FALSE;
                }

                if ( BlockSize & 1 )
                {
                    DEBUGCODE( printf( "\rWarning: .reloc block size %u not a multiple of 2 bytes\n", BlockSize ));
                    return FALSE;
                }

                if ( RelocBaseRva >= ImageSize )
                {
                    DEBUGCODE( printf( "\rWarning: .reloc block base RVA %06X beyond image size %06X\n", RelocBaseRva, ImageSize ));
                    // not fatal unless at least one entry uses it and then exceeds imagesize
                }

                if ( RelocBaseRva & 0x0FFF )
                {
                    DEBUGCODE( printf( "\rWarning: .reloc block base RVA %06X low 12 bits not zero\n", RelocBaseRva ));
                    // not fatal, just strange
                }

                RelocEntry = (PUSHORT)( RelocBlock + 1 );
                RelocCount = ( BlockSize - sizeof( IMAGE_BASE_RELOCATION )) / sizeof( USHORT );

                if ( RelocCount == 0 )
                {
                    DEBUGCODE( printf( "\rWarning: .reloc block size %u has zero entries.\n", BlockSize ));
                    // not fatal, just strange
                }

                while ( RelocCount-- )
                {
                    ULONG RelocOffset = *RelocEntry & 0x0FFF;
                    UCHAR RelocType   = (UCHAR)( *RelocEntry >> 12 );
                    ULONG RelocRva    = RelocBaseRva + RelocOffset;
                    ULONG RelocSize   = 0;

                    switch ( RelocType )
                    {
                        case IMAGE_REL_BASED_HIGH:
                        case IMAGE_REL_BASED_LOW:

                            RelocSize = 2;
                            break;

                        case IMAGE_REL_BASED_HIGHLOW:
                        case IMAGE_REL_BASED_MIPS_JMPADDR:

                            RelocSize = 4;
                            break;

                        case IMAGE_REL_BASED_HIGHADJ:

                            if ( RelocCount == 0 )
                            {
                                DEBUGCODE( printf( "\rWarning: .reloc entry HIGHADJ with no trailing reloc entry.\n" ));
                                return FALSE;
                            }

                            RelocCount--;
                            RelocEntry++;   // skip the highadj value

                            RelocSize = 2;
                            break;

                        case IMAGE_REL_BASED_IA64_IMM64:

                            RelocRva &= 0xFFFFFFF0;     // mask low 4 bits to bundle boundary
                            RelocSize = 16;             // reloc bits scattered over 16 byte bundle
                            break;

                        case IMAGE_REL_BASED_DIR64:

                            RelocSize = 8;
                            break;

                        case IMAGE_REL_BASED_ABSOLUTE:
                        case IMAGE_REL_BASED_SECTION:
                        case IMAGE_REL_BASED_REL32:

                            break;

                        default:

                            DEBUGCODE( printf( "\rWarning: .reloc entry type %u unrecognized, ignored\n", RelocType ));
                            break;
                    }

                    if ( RelocSize != 0 )
                    {
                        if (( RelocRva + RelocSize ) > ImageSize )
                        {
                            DEBUGCODE( printf( "\rWarning: .reloc entry target RVA %06X,%X exceeds image size %06X\n", RelocRva, RelocSize, ImageSize ));
                            return FALSE;
                        }
                    }

                    RelocEntry++;
                }

                RelocBlock = (PIMAGE_BASE_RELOCATION)((PBYTE)RelocBlock + BlockSize );
                RelocDirSize -= BlockSize;
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DEBUGCODE( printf( "\rWarning: exception %08X while walking .reloc directory\n", GetExceptionCode() ));
        return FALSE;
    }

    return TRUE;
}



#endif // ! PATCH_APPLY_CODE_ONLY


#ifndef PATCH_APPLY_CODE_ONLY

#ifdef TESTCODE
    ULONG BreakOnRiftInsertionOld;
    ULONG BreakOnRiftInsertionNew;
#endif


BOOL
AddRiftEntryToTable(
    IN PRIFT_TABLE RiftTable,
    IN ULONG       OldRva,
    IN ULONG       NewRva
    )
    {
    ULONG RiftIndex;

    if (( OldRva != 0 ) && ( NewRva != 0 )) {

#ifdef TESTCODE

        if (( OldRva == BreakOnRiftInsertionOld ) ||
            ( NewRva == BreakOnRiftInsertionNew ))
        {
            DEBUGBREAK;
        }

#endif

        RiftIndex = RiftTable->RiftEntryCount;

        if (( RiftIndex + 1 ) < RiftTable->RiftEntryAlloc ) {
            RiftTable->RiftEntryCount = RiftIndex + 1;
            RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva = OldRva;
            RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva = NewRva;
            return TRUE;
            }

#ifdef TESTCODE

        else {
            printf( "\rInsufficient RiftEntryAlloc, discarding rift entry\n" );
            }
#endif

        }

    return FALSE;
    }


BOOL
InsertRiftEntryInSortedTable(
    IN PRIFT_TABLE RiftTable,
    IN ULONG       RiftIndex,
    IN ULONG       OldRva,
    IN ULONG       NewRva
    )
    {
    if (( OldRva != 0 ) && ( NewRva != 0 )) {

#ifdef TESTCODE

        if (( OldRva == BreakOnRiftInsertionOld ) ||
            ( NewRva == BreakOnRiftInsertionNew ))
        {
            DEBUGBREAK;
        }

#endif

        //
        //  First scoot to the correct index in case RiftIndex is off by a few.
        //

        while (( RiftIndex > 0 ) && ( RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva > OldRva )) {
            --RiftIndex;
            }

        while (( RiftIndex < RiftTable->RiftEntryCount ) && ( RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva < OldRva )) {
            ++RiftIndex;
            }

        if ( RiftIndex < RiftTable->RiftEntryCount ) {

            if ( RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva == OldRva ) {

                //
                //  Don't insert duplicates.  If it matches an existing OldRva,
                //  just warn if the NewRva doesn't match the rift.
                //

#ifdef TESTCODE

                if ( RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva != NewRva ) {

                    printf( "\rAttempt to insert different rift at same OldRva\n"
                            "    OldRva:%08X NewRva:%08X (discarded)\n"
                            "    OldRva:%08X NewRva:%08X (kept)\n\n",
                            OldRva,
                            NewRva,
                            RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva,
                            RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva
                          );

                    return FALSE;
                    }

#endif /* TESTCODE */

                return TRUE;
                }
            }

        //
        //  Verify we have enough allocation to insert a new entry.
        //

        if (( RiftTable->RiftEntryCount + 1 ) < RiftTable->RiftEntryAlloc ) {

            //
            //  Slide everything from RiftIndex to make room for new
            //  entry at RiftIndex.
            //

            LONG CountToMove = RiftTable->RiftEntryCount - RiftIndex;

            if ( CountToMove > 0 ) {

                MoveMemory(
                    &RiftTable->RiftEntryArray[ RiftIndex + 1 ],
                    &RiftTable->RiftEntryArray[ RiftIndex ],
                    CountToMove * sizeof( RiftTable->RiftEntryArray[ 0 ] )
                    );

#ifdef DONTCOMPILE  // we don't use the RiftUsageArray when we're inserting

                if ( RiftTable->RiftUsageArray ) {

                    MoveMemory(
                        &RiftTable->RiftUsageArray[ RiftIndex + 1 ],
                        &RiftTable->RiftUsageArray[ RiftIndex ],
                        CountToMove * sizeof( RiftTable->RiftUsageArray[ 0 ] )
                        );
                    }

#endif // DONTCOMPILE

                }

#ifdef DONTCOMPILE  // we don't use the RiftUsageArray when we're inserting

            RiftTable->RiftUsageArray[ RiftIndex ] = 0;

#endif // DONTCOMPILE

            RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva = OldRva;
            RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva = NewRva;
            RiftTable->RiftEntryCount++;

            return TRUE;
            }
        }

    return FALSE;
    }


VOID
__inline
SwapRifts(
    PRIFT_ENTRY One,
    PRIFT_ENTRY Two
    )
    {
    RIFT_ENTRY Tmp;

    Tmp  = *One;
    *One = *Two;
    *Two =  Tmp;
    }


VOID
__fastcall
RiftQsort(
    PRIFT_ENTRY LowerBound,
    PRIFT_ENTRY UpperBound
    )
    {
    PRIFT_ENTRY Lower = LowerBound;
    PRIFT_ENTRY Upper = UpperBound;
    PRIFT_ENTRY Pivot = Lower + (( Upper - Lower ) / 2 );
    ULONG PivotRva = Pivot->OldFileRva;

    do  {

        while (( Lower <= Upper ) && ( Lower->OldFileRva <= PivotRva )) {
            ++Lower;
            }

        while (( Upper >= Lower ) && ( Upper->OldFileRva >= PivotRva )) {
            --Upper;
            }

        if ( Lower < Upper ) {
            SwapRifts( Lower++, Upper-- );
            }
        }

    while ( Lower <= Upper );

    if ( Lower < Pivot ) {
        SwapRifts( Lower, Pivot );
        Pivot = Lower;
        }
    else if ( Upper > Pivot ) {
        SwapRifts( Upper, Pivot );
        Pivot = Upper;
        }

    if ( LowerBound < ( Pivot - 1 )) {
        RiftQsort( LowerBound, Pivot - 1 );
        }

    if (( Pivot + 1 ) < UpperBound ) {
        RiftQsort( Pivot + 1, UpperBound );
        }
    }


#ifdef DONTCOMPILE  // old code

VOID
RiftSortAndRemoveDuplicates(
    IN PUCHAR            OldFileMapped,
    IN ULONG             OldFileSize,
    IN PIMAGE_NT_HEADERS OldFileNtHeader,
    IN PUCHAR            NewFileMapped,
    IN ULONG             NewFileSize,
    IN PIMAGE_NT_HEADERS NewFileNtHeader,
    IN OUT PRIFT_TABLE   RiftTable
    )
    {
    ULONG i, n;

    if ( RiftTable->RiftEntryCount > 1 ) {

        n = RiftTable->RiftEntryCount - 1;

        RiftQsort( &RiftTable->RiftEntryArray[ 0 ], &RiftTable->RiftEntryArray[ n ] );

        for ( i = 0; i < n; i++ ) {

            while (( i < n ) &&
                   ( RiftTable->RiftEntryArray[ i     ].OldFileRva ==
                     RiftTable->RiftEntryArray[ i + 1 ].OldFileRva )) {

                if ( RiftTable->RiftEntryArray[ i     ].NewFileRva !=
                     RiftTable->RiftEntryArray[ i + 1 ].NewFileRva ) {

                    //
                    //  This is an ambiguous entry since the OldRva values
                    //  match but the NewRva values do not.  Inspect the
                    //  bytes in the old and new files and choose the one
                    //  that is correct.  If both are correct, or neither is
                    //  correct, choose the lower of the two NewRva values.
                    //

                    ULONG  ChosenNewRva;
                    PUCHAR OldFileRiftMa;
                    PUCHAR NewFileRiftMa1;
                    PUCHAR NewFileRiftMa2;

#ifdef TESTCODE
                    LPSTR Method = "lower";
#endif

                    ChosenNewRva = MIN( RiftTable->RiftEntryArray[ i     ].NewFileRva,
                                        RiftTable->RiftEntryArray[ i + 1 ].NewFileRva );

                    OldFileRiftMa = ImageRvaToMappedAddress(
                                        OldFileNtHeader,
                                        RiftTable->RiftEntryArray[ i ].OldFileRva,
                                        OldFileMapped,
                                        OldFileSize
                                        );

                    NewFileRiftMa1 = ImageRvaToMappedAddress(
                                         NewFileNtHeader,
                                         RiftTable->RiftEntryArray[ i ].NewFileRva,
                                         NewFileMapped,
                                         NewFileSize
                                         );

                    NewFileRiftMa2 = ImageRvaToMappedAddress(
                                         NewFileNtHeader,
                                         RiftTable->RiftEntryArray[ i + 1 ].NewFileRva,
                                         NewFileMapped,
                                         NewFileSize
                                         );

                    //
                    //  Use try/except to touch the mapped files.
                    //

                    __try {

                        if ( OldFileRiftMa != NULL ) {

                            if ((  NewFileRiftMa1 != NULL ) &&
                                ( *NewFileRiftMa1 == *OldFileRiftMa ) &&
                                ((  NewFileRiftMa2 == NULL ) ||
                                 ( *NewFileRiftMa2 != *OldFileRiftMa ))) {

                                ChosenNewRva = RiftTable->RiftEntryArray[ i ].NewFileRva;
#ifdef TESTCODE
                                Method = "match inspection";
#endif
                                }

                            else if ((  NewFileRiftMa2 != NULL ) &&
                                     ( *NewFileRiftMa2 == *OldFileRiftMa ) &&
                                     ((  NewFileRiftMa1 == NULL ) ||
                                      ( *NewFileRiftMa1 != *OldFileRiftMa ))) {

                                ChosenNewRva = RiftTable->RiftEntryArray[ i + 1 ].NewFileRva;
#ifdef TESTCODE
                                Method = "match inspection";
#endif
                                }
                            }
                        }

                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                        }

#ifdef TESTCODE
                    printf(
                        "RiftInfo contains ambiguous entries:\n"
                        "    OldRva:%08X NewRva:%08X (discarded)\n"
                        "    OldRva:%08X NewRva:%08X (kept %s)\n\n",
                        RiftTable->RiftEntryArray[ i ].OldFileRva,
                        ( RiftTable->RiftEntryArray[ i ].NewFileRva == ChosenNewRva ) ?
                          RiftTable->RiftEntryArray[ i + 1 ].NewFileRva :
                          RiftTable->RiftEntryArray[ i ].NewFileRva,
                        RiftTable->RiftEntryArray[ i ].OldFileRva,
                        ChosenNewRva,
                        Method
                        );
#endif
                    RiftTable->RiftEntryArray[ i + 1 ].NewFileRva = ChosenNewRva;
                    }



                MoveMemory(
                    &RiftTable->RiftEntryArray[ i ],
                    &RiftTable->RiftEntryArray[ i + 1 ],
                    ( n - i ) * sizeof( RIFT_ENTRY )
                    );

                --n;

                }
            }

        RiftTable->RiftEntryCount = n + 1;
        }
    }

#endif


VOID
RiftSortAndRemoveDuplicates(
    IN PUCHAR            OldFileMapped,
    IN ULONG             OldFileSize,
    IN PIMAGE_NT_HEADERS OldFileNtHeader,
    IN PUCHAR            NewFileMapped,
    IN ULONG             NewFileSize,
    IN PIMAGE_NT_HEADERS NewFileNtHeader,
    IN OUT PRIFT_TABLE   RiftTable
    )
    {
    ULONG n = RiftTable->RiftEntryCount;
    ULONG i = 0;
    ULONG t = 0;

    if ( n <= 1 ) {
        return;
        }

    RiftQsort( &RiftTable->RiftEntryArray[ 0 ], &RiftTable->RiftEntryArray[ n - 1 ] );

    while ( i < n ) {

        if (( i < ( n - 1 )) &&
            ( RiftTable->RiftEntryArray[ i     ].OldFileRva ==
              RiftTable->RiftEntryArray[ i + 1 ].OldFileRva )) {

            if ( RiftTable->RiftEntryArray[ i     ].NewFileRva !=
                 RiftTable->RiftEntryArray[ i + 1 ].NewFileRva ) {

                //
                //  This is an ambiguous entry since the OldRva values
                //  match but the NewRva values do not.  Inspect the
                //  bytes in the old and new files and choose the one
                //  that is correct.  If both are correct, or neither is
                //  correct, choose the lower of the two NewRva values.
                //

                ULONG  ChosenNewRva;
                PUCHAR OldFileRiftMa;
                PUCHAR NewFileRiftMa1;
                PUCHAR NewFileRiftMa2;

#ifdef TESTCODE
                LPSTR Method = "lower";
#endif

                ChosenNewRva = MIN( RiftTable->RiftEntryArray[ i     ].NewFileRva,
                                    RiftTable->RiftEntryArray[ i + 1 ].NewFileRva );

                OldFileRiftMa = ImageRvaToMappedAddress(
                                    OldFileNtHeader,
                                    RiftTable->RiftEntryArray[ i ].OldFileRva,
                                    OldFileMapped,
                                    OldFileSize
                                    );

                NewFileRiftMa1 = ImageRvaToMappedAddress(
                                     NewFileNtHeader,
                                     RiftTable->RiftEntryArray[ i ].NewFileRva,
                                     NewFileMapped,
                                     NewFileSize
                                     );

                NewFileRiftMa2 = ImageRvaToMappedAddress(
                                     NewFileNtHeader,
                                     RiftTable->RiftEntryArray[ i + 1 ].NewFileRva,
                                     NewFileMapped,
                                     NewFileSize
                                     );

                //
                //  Use try/except to touch the mapped files.
                //

                __try {

                    if ( OldFileRiftMa != NULL ) {

                        if ((  NewFileRiftMa1 != NULL ) &&
                            ( *NewFileRiftMa1 == *OldFileRiftMa ) &&
                            ((  NewFileRiftMa2 == NULL ) ||
                             ( *NewFileRiftMa2 != *OldFileRiftMa ))) {

                            ChosenNewRva = RiftTable->RiftEntryArray[ i ].NewFileRva;
#ifdef TESTCODE
                            Method = "match inspection";
#endif
                            }

                        else if ((  NewFileRiftMa2 != NULL ) &&
                                 ( *NewFileRiftMa2 == *OldFileRiftMa ) &&
                                 ((  NewFileRiftMa1 == NULL ) ||
                                  ( *NewFileRiftMa1 != *OldFileRiftMa ))) {

                            ChosenNewRva = RiftTable->RiftEntryArray[ i + 1 ].NewFileRva;
#ifdef TESTCODE
                            Method = "match inspection";
#endif
                            }
                        }
                    }

                __except( EXCEPTION_EXECUTE_HANDLER ) {
                    }

#ifdef TESTCODE
                printf(
                    "RiftInfo contains ambiguous entries:\n"
                    "    OldRva:%08X NewRva:%08X (discarded)\n"
                    "    OldRva:%08X NewRva:%08X (kept %s)\n\n",
                    RiftTable->RiftEntryArray[ i ].OldFileRva,
                    ( RiftTable->RiftEntryArray[ i ].NewFileRva == ChosenNewRva ) ?
                      RiftTable->RiftEntryArray[ i + 1 ].NewFileRva :
                      RiftTable->RiftEntryArray[ i ].NewFileRva,
                    RiftTable->RiftEntryArray[ i ].OldFileRva,
                    ChosenNewRva,
                    Method
                    );
#endif
                RiftTable->RiftEntryArray[ i + 1 ].NewFileRva = ChosenNewRva;
                }

            }

        else {

            if ( i != t ) {
                RiftTable->RiftEntryArray[ t ] = RiftTable->RiftEntryArray[ i ];
                }

            ++t;
            }

        ++i;
        }

    RiftTable->RiftEntryCount = t;
    }



BOOL
IsMatchingResourceString(
    IN PIMAGE_RESOURCE_DIR_STRING_U OldString,
    IN PIMAGE_RESOURCE_DIR_STRING_U NewString
    )
    {
    ULONG Length = OldString->Length;
    ULONG i;

    if ( OldString->Length != NewString->Length ) {
        return FALSE;
        }

    for ( i = 0; i < Length; i++ ) {
        if ( OldString->NameString[ i ] != NewString->NameString[ i ] ) {
            return FALSE;
            }
        }

    return TRUE;
    }


VOID
GetResourceRiftInfoRecursive(
    IN PIMAGE_RESOURCE_DIRECTORY OldResDir,
    IN PUCHAR OldResBase,
    IN PUCHAR OldResEnd,
    IN ULONG  OldResRva,
    IN PIMAGE_RESOURCE_DIRECTORY NewResDir,
    IN PUCHAR NewResBase,
    IN PUCHAR NewResEnd,
    IN ULONG  NewResRva,
    IN PRIFT_TABLE RiftTable
    )
    {
    PIMAGE_RESOURCE_DIRECTORY_ENTRY OldResEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY NewResEntry;
    ULONG OldResEntryCount;
    ULONG NewResEntryCount;
    PIMAGE_RESOURCE_DATA_ENTRY OldResData;
    PIMAGE_RESOURCE_DATA_ENTRY NewResData;

    if ((( (PUCHAR) OldResDir + sizeof( IMAGE_RESOURCE_DIRECTORY )) < OldResEnd ) &&
        (( (PUCHAR) NewResDir + sizeof( IMAGE_RESOURCE_DIRECTORY )) < NewResEnd )) {

        OldResEntryCount = OldResDir->NumberOfNamedEntries + OldResDir->NumberOfIdEntries;
        OldResEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY) ( OldResDir + 1 );

        while (( OldResEntryCount > 0 ) && ((PUCHAR)OldResEntry < OldResEnd )) {

            NewResEntryCount = NewResDir->NumberOfNamedEntries + NewResDir->NumberOfIdEntries;
            NewResEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( NewResDir + 1 );

            while ( NewResEntryCount > 0 ) {

                if ( (PUCHAR) NewResEntry > NewResEnd ) {
                    NewResEntryCount = 0;
                    break;
                    }

                if ( !OldResEntry->NameIsString && !NewResEntry->NameIsString &&
                     ( OldResEntry->Id == NewResEntry->Id )) {
                    break;
                    }
                else if (( OldResEntry->NameIsString && NewResEntry->NameIsString ) &&
                        IsMatchingResourceString(
                            (PIMAGE_RESOURCE_DIR_STRING_U)( OldResBase + OldResEntry->NameOffset ),
                            (PIMAGE_RESOURCE_DIR_STRING_U)( NewResBase + NewResEntry->NameOffset ))) {
                    break;
                    }

                ++NewResEntry;
                --NewResEntryCount;
                }

            if ( NewResEntryCount > 0 ) {

                if ( OldResEntry->NameIsString ) {

                    AddRiftEntryToTable(
                        RiftTable,
                        OldResRva + OldResEntry->NameOffset,
                        NewResRva + NewResEntry->NameOffset
                        );
                    }

                AddRiftEntryToTable(
                    RiftTable,
                    OldResRva + OldResEntry->OffsetToDirectory,
                    NewResRva + NewResEntry->OffsetToDirectory
                    );

                if ( OldResEntry->DataIsDirectory ) {

                    GetResourceRiftInfoRecursive(
                        (PIMAGE_RESOURCE_DIRECTORY)( OldResBase + OldResEntry->OffsetToDirectory ),
                        OldResBase,
                        OldResEnd,
                        OldResRva,
                        (PIMAGE_RESOURCE_DIRECTORY)( NewResBase + NewResEntry->OffsetToDirectory ),
                        NewResBase,
                        NewResEnd,
                        NewResRva,
                        RiftTable
                        );
                    }
                else {

                    OldResData = (PIMAGE_RESOURCE_DATA_ENTRY)( OldResBase + OldResEntry->OffsetToData );
                    NewResData = (PIMAGE_RESOURCE_DATA_ENTRY)( NewResBase + NewResEntry->OffsetToData );

                    AddRiftEntryToTable(
                        RiftTable,
                        OldResData->OffsetToData,
                        NewResData->OffsetToData
                        );
                    }
                }

            ++OldResEntry;
            --OldResEntryCount;
            }
        }
    }


BOOL
GetImageNonSymbolRiftInfo(
    IN PUCHAR            OldFileMapped,
    IN ULONG             OldFileSize,
    IN PIMAGE_NT_HEADERS OldFileNtHeader,
    IN PUCHAR            NewFileMapped,
    IN ULONG             NewFileSize,
    IN PIMAGE_NT_HEADERS NewFileNtHeader,
    IN HANDLE            SubAllocator,
    IN PRIFT_TABLE       RiftTable
    )
    {

    //
    //  Create rifts for sections by section names.
    //

    {
    PIMAGE_SECTION_HEADER OldSectionHeader;
    PIMAGE_SECTION_HEADER NewSectionHeader;
    ULONG                 OldSectionCount;
    ULONG                 NewSectionCount;
    ULONG                 i, j;

    OldSectionHeader = IMAGE_FIRST_SECTION( OldFileNtHeader );
    OldSectionCount  = OldFileNtHeader->FileHeader.NumberOfSections;

    NewSectionHeader = IMAGE_FIRST_SECTION( NewFileNtHeader );
    NewSectionCount  = NewFileNtHeader->FileHeader.NumberOfSections;

    ASSERT( sizeof( OldSectionHeader->Name ) == sizeof( DWORDLONG ));

    for ( i = 0; i < OldSectionCount; i++ ) {

        for ( j = 0; j < NewSectionCount; j++ ) {

            if ( *(UNALIGNED DWORDLONG *)OldSectionHeader[ i ].Name ==
                 *(UNALIGNED DWORDLONG *)NewSectionHeader[ j ].Name ) {

                //
                //  Add a rift entry for this section name match.
                //
                //  Note that we create rift values here that are minus
                //  one from the actual section boundary because if a
                //  symbol exists at the start of the section, its rift
                //  entry would conflict with this section entry.
                //

                AddRiftEntryToTable(
                    RiftTable,
                    OldSectionHeader[ i ].VirtualAddress - 1,
                    NewSectionHeader[ i ].VirtualAddress - 1
                    );

                break;
                }
            }
        }
    }


    //
    //  Create rifts for image directories.
    //

    {
    ULONG i, n;

    n = MIN( OldFileNtHeader->OptionalHeader.NumberOfRvaAndSizes,
             NewFileNtHeader->OptionalHeader.NumberOfRvaAndSizes );

    for ( i = 0; i < n; i++ ) {

        if (( OldFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress ) &&
            ( OldFileNtHeader->OptionalHeader.DataDirectory[ i ].Size           ) &&
            ( NewFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress ) &&
            ( NewFileNtHeader->OptionalHeader.DataDirectory[ i ].Size           )) {

            AddRiftEntryToTable(
                RiftTable,
                OldFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress,
                NewFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress
                );
            }
        }
    }

    //
    //  Create rifts for image export directory
    //

    {
    PIMAGE_EXPORT_DIRECTORY OldExportDir;
    PIMAGE_EXPORT_DIRECTORY NewExportDir;
    ULONG                   OldExportIndex;
    ULONG                   NewExportIndex;
    ULONG                   OldExportNameCount;
    ULONG                   NewExportNameCount;
    ULONG                   OldExportFunctionCount;
    ULONG                   NewExportFunctionCount;
    PULONG                  OldExportFunctionArray;
    PULONG                  NewExportFunctionArray;
    PUSHORT                 OldExportNameToOrdinal;
    PUSHORT                 NewExportNameToOrdinal;
    PULONG                  OldExportNameArray;
    PULONG                  NewExportNameArray;
    LPSTR                   OldExportName;
    LPSTR                   NewExportName;
    ULONG                   OldOrdinal;
    ULONG                   NewOrdinal;
    LONG                    OrdinalBaseNewToOld;
    PBYTE                   NewExportOrdinalNameExists;
    PSYMBOL_NODE            NewExportSymbolNode;
    SYMBOL_TREE             NewExportNameTree;

    OldExportDir = ImageDirectoryMappedAddress(
                       OldFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                       NULL,
                       OldFileMapped,
                       OldFileSize
                       );

    NewExportDir = ImageDirectoryMappedAddress(
                       NewFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                       NULL,
                       NewFileMapped,
                       NewFileSize
                       );

    if (( OldExportDir ) && ( NewExportDir )) {

        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->Name ),                  (ULONG)( NewExportDir->Name ));
        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->AddressOfFunctions ),    (ULONG)( NewExportDir->AddressOfFunctions ));
        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->AddressOfNames ),        (ULONG)( NewExportDir->AddressOfNames ));
        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->AddressOfNameOrdinals ), (ULONG)( NewExportDir->AddressOfNameOrdinals ));

        //
        //  Now build a tree of new export names, then walk old export names
        //  looking for matches in tree of new export names.
        //

        SymRBInitTree(
            &NewExportNameTree,
            SubAllocator
            );

        //
        //  First insert new export names.
        //

        NewExportNameCount     = NewExportDir->NumberOfNames;
        NewExportFunctionCount = NewExportDir->NumberOfFunctions;
        NewExportFunctionArray = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG) NewExportDir->AddressOfFunctions,    NewFileMapped, NewFileSize );
        NewExportNameToOrdinal = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG) NewExportDir->AddressOfNameOrdinals, NewFileMapped, NewFileSize );
        NewExportNameArray     = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG) NewExportDir->AddressOfNames,        NewFileMapped, NewFileSize );

        if ( NewExportNameArray ) {

            for ( NewExportIndex = 0; NewExportIndex < NewExportNameCount; NewExportIndex++ ) {

                if ( NewExportNameArray[ NewExportIndex ] ) {

                    NewExportName = ImageRvaToMappedAddress( NewFileNtHeader, NewExportNameArray[ NewExportIndex ], NewFileMapped, NewFileSize );

                    if ( NewExportName ) {

                        SymRBInsert( &NewExportNameTree, NewExportName, NewExportIndex );

                        }
                    }
                }
            }

        //
        //  Walk old export names and match them up.
        //

        OldExportNameCount     = OldExportDir->NumberOfNames;
        OldExportFunctionCount = OldExportDir->NumberOfFunctions;
        OldExportFunctionArray = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG) OldExportDir->AddressOfFunctions,    OldFileMapped, OldFileSize );
        OldExportNameToOrdinal = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG) OldExportDir->AddressOfNameOrdinals, OldFileMapped, OldFileSize );
        OldExportNameArray     = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG) OldExportDir->AddressOfNames,        OldFileMapped, OldFileSize );

        if ( OldExportNameArray ) {

            for ( OldExportIndex = 0; OldExportIndex < OldExportNameCount; OldExportIndex++ ) {

                if ( OldExportNameArray[ OldExportIndex ] ) {

                    OldExportName = ImageRvaToMappedAddress( OldFileNtHeader, OldExportNameArray[ OldExportIndex ], OldFileMapped, OldFileSize );

                    if ( OldExportName ) {

                        NewExportSymbolNode = SymRBFind( &NewExportNameTree, OldExportName );

                        if ( NewExportSymbolNode ) {

                            //
                            //  Found a name match.  The Rva field in the
                            //  symbol node contains the index into the
                            //  NewExportNameArray.
                            //
                            //  This match gives us two rift entries: one
                            //  for the locations of the names themselves,
                            //  and another for the locations of the
                            //  functions corresponding to those names.
                            //

                            NewExportIndex = NewExportSymbolNode->Rva;

                            AddRiftEntryToTable(
                                RiftTable,
                                OldExportNameArray[ OldExportIndex ],
                                NewExportNameArray[ NewExportIndex ]
                                );

                            if ( OldExportNameToOrdinal && NewExportNameToOrdinal ) {

                                OldOrdinal = OldExportNameToOrdinal[ OldExportIndex ];
                                NewOrdinal = NewExportNameToOrdinal[ NewExportIndex ];

                                if (( OldOrdinal < OldExportFunctionCount ) &&
                                    ( NewOrdinal < NewExportFunctionCount )) {

                                    AddRiftEntryToTable(
                                        RiftTable,
                                        OldExportFunctionArray[ OldOrdinal ],
                                        NewExportFunctionArray[ NewOrdinal ]
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }

        //
        //  Now use ordinals to match any exports that don't have names.
        //  We use the NameToOrdinal table to determine if a name exists.
        //  For all ordinals that don't have a NameToOrdinal entry, we
        //  create a match.
        //

        if (( NewExportFunctionArray ) && ( NewExportNameToOrdinal )) {

            NewExportOrdinalNameExists = SubAllocate( SubAllocator, NewExportFunctionCount * sizeof( NewExportOrdinalNameExists[ 0 ] ));

            if ( NewExportOrdinalNameExists != NULL ) {

                for ( NewExportIndex = 0; NewExportIndex < NewExportNameCount; NewExportIndex++ ) {

                    NewOrdinal = NewExportNameToOrdinal[ NewExportIndex ];

                    if ( NewOrdinal < NewExportFunctionCount ) {

                        NewExportOrdinalNameExists[ NewOrdinal ] = TRUE;

                        }
                    }

                OrdinalBaseNewToOld = (LONG)NewExportDir->Base - (LONG)OldExportDir->Base;

                for ( NewOrdinal = 0; NewOrdinal < NewExportFunctionCount; NewOrdinal++ ) {

                    if ( ! NewExportOrdinalNameExists[ NewOrdinal ] ) {

                        OldOrdinal = NewOrdinal + OrdinalBaseNewToOld;

                        if ( OldOrdinal < OldExportFunctionCount ) {

                            AddRiftEntryToTable(
                                RiftTable,
                                OldExportFunctionArray[ OldOrdinal ],
                                NewExportFunctionArray[ NewOrdinal ]
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    //
    //  Create rifts for image import directory
    //

    {
    PIMAGE_IMPORT_DESCRIPTOR OldImportDir;
    PIMAGE_IMPORT_DESCRIPTOR NewImportDir;

    ULONG                    OldImportDirRva;
    ULONG                    NewImportDirRva;

    ULONG                    OldImportDirIndex;
    ULONG                    NewImportDirIndex;

    LPSTR                    OldImportDllName;
    LPSTR                    NewImportDllName;

    LPSTR                    OldImportDllNameLowercase;
    LPSTR                    NewImportDllNameLowercase;

    PIMAGE_THUNK_DATA        OldImportThunk;
    PIMAGE_THUNK_DATA        NewImportThunk;

    PIMAGE_THUNK_DATA        OldImportOriginalThunk;
    PIMAGE_THUNK_DATA        NewImportOriginalThunk;

    ULONG                    OldImportThunkIndex;
    ULONG                    NewImportThunkIndex;

    PIMAGE_IMPORT_BY_NAME    OldImportByName;
    PIMAGE_IMPORT_BY_NAME    NewImportByName;

    LPSTR                    OldImportName;
    LPSTR                    NewImportName;

    SYMBOL_TREE NewImportDllNameTree;
    SYMBOL_TREE NewImportFunctionNameTree;

    PSYMBOL_NODE NewImportDllSymbolNode;
    PSYMBOL_NODE NewImportFunctionSymbolNode;



    OldImportDirRva = ImageDirectoryRvaAndSize(
                          OldFileNtHeader,
                          IMAGE_DIRECTORY_ENTRY_IMPORT,
                          NULL
                          );

    NewImportDirRva = ImageDirectoryRvaAndSize(
                          NewFileNtHeader,
                          IMAGE_DIRECTORY_ENTRY_IMPORT,
                          NULL
                          );

    OldImportDir = ImageDirectoryMappedAddress(
                       OldFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_IMPORT,
                       NULL,
                       OldFileMapped,
                       OldFileSize
                       );

    NewImportDir = ImageDirectoryMappedAddress(
                       NewFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_IMPORT,
                       NULL,
                       NewFileMapped,
                       NewFileSize
                       );

    if (( OldImportDir ) && ( NewImportDir )) {

        //
        //  Now build a tree of new import names, then walk old export names
        //  looking for matches in tree of new import names.
        //

        SymRBInitTree(
            &NewImportDllNameTree,
            SubAllocator
            );

        SymRBInitTree(
            &NewImportFunctionNameTree,
            SubAllocator
            );

        for ( NewImportDirIndex = 0; NewImportDir[ NewImportDirIndex ].Characteristics; NewImportDirIndex++ ) {

            if ( NewImportDir[ NewImportDirIndex ].Name ) {

                NewImportDllName = ImageRvaToMappedAddress( NewFileNtHeader, NewImportDir[ NewImportDirIndex ].Name, NewFileMapped, NewFileSize );

                if ( NewImportDllName ) {

                    NewImportDllNameLowercase = MySubAllocStrDup( SubAllocator, NewImportDllName );

                    if ( NewImportDllNameLowercase ) {

                        MyLowercase( NewImportDllNameLowercase );

                        SymRBInsert( &NewImportDllNameTree, NewImportDllNameLowercase, NewImportDirIndex );

                        NewImportThunk = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportDir[ NewImportDirIndex ].FirstThunk, NewFileMapped, NewFileSize );

                        if ( NewImportThunk ) {

                            for ( NewImportThunkIndex = 0; NewImportThunk[ NewImportThunkIndex ].u1.Ordinal; NewImportThunkIndex++ ) {

                                if ( ! IMAGE_SNAP_BY_ORDINAL( NewImportThunk[ NewImportThunkIndex ].u1.Ordinal )) {

                                    NewImportByName = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportThunk[ NewImportThunkIndex ].u1.AddressOfData, NewFileMapped, NewFileSize );

                                    if ( NewImportByName ) {

                                        NewImportName = MySubAllocStrDupAndCat(
                                                            SubAllocator,
                                                            NewImportDllNameLowercase,
                                                            (LPSTR)NewImportByName->Name,
                                                            '!'
                                                            );

                                        if ( NewImportName ) {

                                            SymRBInsert( &NewImportFunctionNameTree, NewImportName, NewImportThunkIndex );

                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

        for ( OldImportDirIndex = 0; OldImportDir[ OldImportDirIndex ].Characteristics; OldImportDirIndex++ ) {

            if ( OldImportDir[ OldImportDirIndex ].Name ) {

                OldImportDllName = ImageRvaToMappedAddress( OldFileNtHeader, OldImportDir[ OldImportDirIndex ].Name, OldFileMapped, OldFileSize );

                if ( OldImportDllName ) {

                    OldImportDllNameLowercase = MySubAllocStrDup( SubAllocator, OldImportDllName );

                    if ( OldImportDllNameLowercase ) {

                        MyLowercase( OldImportDllNameLowercase );

                        NewImportDllSymbolNode = SymRBFind( &NewImportDllNameTree, OldImportDllNameLowercase );

                        if ( NewImportDllSymbolNode ) {

                            //
                            //  Found a matching dll import descriptor.
                            //  This will give us four rifts: one for the
                            //  descriptor itself, another for the
                            //  dll name referenced by the descriptor, and
                            //  the FirstThunk and OriginalFirstThunk
                            //  arrays.
                            //
                            //  The index of the new import descriptor is
                            //  stored in the Rva field of the node.
                            //

                            NewImportDirIndex = NewImportDllSymbolNode->Rva;

                            AddRiftEntryToTable(
                                RiftTable,
                                (ULONG)((PIMAGE_IMPORT_DESCRIPTOR)OldImportDirRva + OldImportDirIndex ),
                                (ULONG)((PIMAGE_IMPORT_DESCRIPTOR)NewImportDirRva + NewImportDirIndex )
                                );

                            AddRiftEntryToTable(
                                RiftTable,
                                (ULONG)OldImportDir[ OldImportDirIndex ].Name,
                                (ULONG)NewImportDir[ NewImportDirIndex ].Name
                                );

                            AddRiftEntryToTable(
                                RiftTable,
                                (ULONG)OldImportDir[ OldImportDirIndex ].OriginalFirstThunk,
                                (ULONG)NewImportDir[ NewImportDirIndex ].OriginalFirstThunk
                                );

                            AddRiftEntryToTable(
                                RiftTable,
                                (ULONG)OldImportDir[ OldImportDirIndex ].FirstThunk,
                                (ULONG)NewImportDir[ NewImportDirIndex ].FirstThunk
                                );

                            OldImportThunk = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG)OldImportDir[ OldImportDirIndex ].FirstThunk, OldFileMapped, OldFileSize );

                            if ( OldImportThunk ) {

                                for ( OldImportThunkIndex = 0; OldImportThunk[ OldImportThunkIndex ].u1.Ordinal; OldImportThunkIndex++ ) {

                                    if ( ! IMAGE_SNAP_BY_ORDINAL( OldImportThunk[ OldImportThunkIndex ].u1.Ordinal )) {

                                        OldImportByName = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG)OldImportThunk[ OldImportThunkIndex ].u1.AddressOfData, OldFileMapped, OldFileSize );

                                        if ( OldImportByName ) {

                                            OldImportName = MySubAllocStrDupAndCat(
                                                                SubAllocator,
                                                                OldImportDllNameLowercase,
                                                                (LPSTR)OldImportByName->Name,
                                                                '!'
                                                                );

                                            if ( OldImportName ) {

                                                NewImportFunctionSymbolNode = SymRBFind( &NewImportFunctionNameTree, OldImportName );

                                                if ( NewImportFunctionSymbolNode ) {

                                                    //
                                                    //  Found a matching import function name.
                                                    //  This will give us two rifts: one for the
                                                    //  FirstThunk arrays and another for the
                                                    //  OriginalFirstThunk arrays.
                                                    //
                                                    //  The index of the new import thunk is
                                                    //  stored in the Rva field of the node.
                                                    //

                                                    NewImportThunkIndex = NewImportFunctionSymbolNode->Rva;

                                                    NewImportThunk = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportDir[ NewImportDirIndex ].FirstThunk, NewFileMapped, NewFileSize );

                                                    if ( NewImportThunk ) {

                                                        AddRiftEntryToTable(
                                                            RiftTable,
                                                            (ULONG)OldImportThunk[ OldImportThunkIndex ].u1.AddressOfData,
                                                            (ULONG)NewImportThunk[ NewImportThunkIndex ].u1.AddressOfData
                                                            );
                                                        }

                                                    OldImportOriginalThunk = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG)OldImportDir[ OldImportDirIndex ].OriginalFirstThunk, OldFileMapped, OldFileSize );
                                                    NewImportOriginalThunk = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportDir[ NewImportDirIndex ].OriginalFirstThunk, NewFileMapped, NewFileSize );

                                                    if ( OldImportOriginalThunk && NewImportOriginalThunk ) {

                                                        AddRiftEntryToTable(
                                                            RiftTable,
                                                            (ULONG)OldImportOriginalThunk[ OldImportThunkIndex ].u1.AddressOfData,
                                                            (ULONG)NewImportOriginalThunk[ NewImportThunkIndex ].u1.AddressOfData
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    //
    //  Create rift entries for resources
    //

    {
    PUCHAR OldResBase, NewResBase;
    ULONG  OldResSize, NewResSize;
    ULONG  OldResRva,  NewResRva;

    OldResBase = ImageDirectoryMappedAddress(
                OldFileNtHeader,
                IMAGE_DIRECTORY_ENTRY_RESOURCE,
                &OldResSize,
                OldFileMapped,
                OldFileSize
                );

    NewResBase = ImageDirectoryMappedAddress(
                NewFileNtHeader,
                IMAGE_DIRECTORY_ENTRY_RESOURCE,
                &NewResSize,
                NewFileMapped,
                NewFileSize
                );

    if ( OldResBase && NewResBase ) {

        OldResRva = ImageDirectoryRvaAndSize( OldFileNtHeader, IMAGE_DIRECTORY_ENTRY_RESOURCE, NULL );
        NewResRva = ImageDirectoryRvaAndSize( NewFileNtHeader, IMAGE_DIRECTORY_ENTRY_RESOURCE, NULL );

        GetResourceRiftInfoRecursive(
            (PIMAGE_RESOURCE_DIRECTORY) OldResBase,
            OldResBase,
            OldResBase + OldResSize,
            OldResRva,
            (PIMAGE_RESOURCE_DIRECTORY) NewResBase,
            NewResBase,
            NewResBase + NewResSize,
            NewResRva,
            RiftTable
            );
        }
    }

    //
    //  BUGBUG: Gen rift info for other non-symbol stuff here.
    //

#ifdef TESTCODE
    printf( "\r%9d non-symbol rift entries\n", RiftTable->RiftEntryCount );
#endif

    return TRUE;
    }


VOID
MyUndecorateSymbol(
    IN  LPCSTR DecoratedSymbol,
    OUT LPSTR  UndecoratedSymbol,
    IN  DWORD  BufferSize
    )
    {
    LPCSTR d;
    LPCSTR e;
    ULONG  Len;
    ULONG  Ext;

    *UndecoratedSymbol = 0;   // in case UnDecorateSymbolName fails

    d = DecoratedSymbol;

    if (( d[ 0 ] == '.' ) &&
        ( d[ 1 ] == '.' ) &&
        ( d[ 2 ] == '?' )) {

        d += 2;
        }

    if ( *d == '?' ) {

        Imagehlp.UnDecorateSymbolName( d, UndecoratedSymbol, BufferSize, UNDNAME_NAME_ONLY );

        //
        //  UnDecorateSymbolName will strip any trailing '_nnn' (from BBT omap
        //  info), but we want to preserved it.  Check for that pattern in the
        //  original, and if found, append it to the new string.
        //

        d += strlen( d + 1 );   // point d to last character in string

        if (( *d >= '0' ) && ( *d <= '9' )) {

            do  {
                --d;
                }
            while (( *d >= '0' ) && ( *d <= '9' ));

            if ( *d == '_' ) {

                //
                //  Matches the '_nnn' pattern, append to new string.
                //

                if (( strlen( UndecoratedSymbol ) + strlen( d )) < ( BufferSize - 1 )) {
                    strcat( UndecoratedSymbol, d );
                    }
                }
            }
        }

    else {

        //
        //  Strip any preceding '_' or '@'.
        //

        if (( *d == '_' ) || ( *d == '@' )) {
            ++d;
            }

        //
        //  Find end of name as either terminator or '@nn'.
        //

        for ( e = d; ( *e ) && ( *e != '@' ); ) {
            ++e;
            }

        //
        //  Copy as much of name as will fit in the buffer.
        //

        Len = e - d;

        if ( Len > ( BufferSize - 1 )) {
             Len = ( BufferSize - 1 );
             }

        memcpy( UndecoratedSymbol, d, Len );

        if ( *e == '@' ) {

            //
            //  Skip '@nn' to append remainder of symbol
            //

            do  {
                ++e;
                }
            while (( *e >= '0' ) && ( *e <= '9' ));

            d = e;

            while ( *e ) {
                ++e;
                }

            //
            //  Now 'd' points to first character after '@nn' and 'e' points
            //  to end of the string.  If the extension will fit in the buffer,
            //  append it.
            //

            Ext = e - d;

            if (( Len + Ext ) < ( BufferSize - 1 )) {
                memcpy( UndecoratedSymbol + Len, d, Ext );
                }

            Len += Ext;
            }

        //
        //  Terminate the string.
        //

        UndecoratedSymbol[ Len ] = 0;
        }
    }


BOOL
UndecorateSymbolAndAddToTree(
    IN LPCSTR       SymbolName,
    IN ULONG        Rva,
    IN PSYMBOL_TREE SymbolTree
    )
    {
    ULONG SymbolNameSize  = strlen( SymbolName ) + 1;
    LPSTR UndecoratedName = _alloca( SymbolNameSize );
    PSYMBOL_NODE SymbolNode;

    MyUndecorateSymbol(
        SymbolName,
        UndecoratedName,
        SymbolNameSize
        );

    SymbolNode = SymRBInsert(
                     SymbolTree,
                     UndecoratedName,
                     Rva
                     );

    return ( SymbolNode != NULL );
    }


BOOL
CALLBACK
NewFileEnumSymbolsCallback(
    LPSTR SymbolName,
    ULONG SymbolAddr,
    ULONG SymbolSize,
    PVOID Context
    )
    {
    PSYMBOL_CONTEXT SymbolContext = Context;
    PSYMBOL_NODE SymbolNode;
    ULONG NewRva;

    UNREFERENCED_PARAMETER( SymbolSize );

#ifdef TESTCODE

    if ( SymbolContext->OutFile != INVALID_HANDLE_VALUE ) {

        CHAR  TextBuffer[ 16 + MAX_SYMBOL_NAME_LENGTH ];
        CHAR  Discarded;
        DWORD Actual;

        Discarded = 'X';
        NewRva = SymbolAddr;

        if ( NewRva > SymbolContext->NewImageBase ) {
            NewRva -= SymbolContext->NewImageBase;
            Discarded = ' ';
            }

        sprintf( TextBuffer, "%08X %c %s\r\n", NewRva, Discarded, SymbolName );
        WriteFile( SymbolContext->OutFile, TextBuffer, strlen( TextBuffer ), &Actual, NULL );
        }

#endif // TESTCODE

    if ( SymbolAddr > SymbolContext->NewImageBase ) {

        NewRva = SymbolAddr - SymbolContext->NewImageBase;

        SymbolNode = SymRBInsert(
                         &SymbolContext->NewDecoratedSymbolTree,
                         SymbolName,
                         NewRva
                         );

        return ( SymbolNode != NULL );
        }

    return TRUE;
    }


BOOL
CALLBACK
OldFileEnumSymbolsCallback(
    LPSTR SymbolName,
    ULONG SymbolAddr,
    ULONG SymbolSize,
    PVOID Context
    )
    {
    PSYMBOL_CONTEXT SymbolContext = Context;
    PSYMBOL_NODE SymbolNode;
    ULONG OldRva;

    UNREFERENCED_PARAMETER( SymbolSize );

#ifdef TESTCODE

    if ( SymbolContext->OutFile != INVALID_HANDLE_VALUE ) {

        CHAR  TextBuffer[ 16 + MAX_SYMBOL_NAME_LENGTH ];
        CHAR  Discarded;
        DWORD Actual;

        Discarded = 'X';
        OldRva = SymbolAddr;

        if ( OldRva > SymbolContext->OldImageBase ) {
            OldRva -= SymbolContext->OldImageBase;
            Discarded = ' ';
            }

        sprintf( TextBuffer, "%08X %c %s\r\n", OldRva, Discarded, SymbolName );
        WriteFile( SymbolContext->OutFile, TextBuffer, strlen( TextBuffer ), &Actual, NULL );
        }

#endif // TESTCODE

    if ( SymbolAddr > SymbolContext->OldImageBase ) {

        OldRva = SymbolAddr - SymbolContext->OldImageBase;

        SymbolNode = SymRBFind(
                         &SymbolContext->NewDecoratedSymbolTree,
                         SymbolName
                         );

        if ( SymbolNode ) {

            AddRiftEntryToTable( SymbolContext->RiftTable, OldRva, SymbolNode->Rva );

            SymbolNode->Hit = 1;

#ifdef TESTCODE

            CountDecoratedMatches++;

#endif // TESTCODE

            }

        else {

            //
            //  Didn't find matching new symbol.  Build a tree of unmatched
            //  old symbols with UNdecorated names.  Later we'll match up
            //  remaining unmatched new symbols to these unmatched old symbols
            //  by their undecorated names.
            //

            if ( SymbolContext->SymbolOptionFlags & PATCH_SYMBOL_UNDECORATED_TOO ) {

                return UndecorateSymbolAndAddToTree(
                           SymbolName,
                           OldRva,
                           &SymbolContext->OldUndecoratedSymbolTree
                           );
                }
            }
        }

    return TRUE;
    }


BOOL
MatchRemainingSymbolsThisNode(
    IN PSYMBOL_NODE NewDecoratedSymbolNode,
    IN PSYMBOL_TREE NewUndecoratedSymbolTree,
    IN PSYMBOL_TREE OldUndecoratedSymbolTree,
    IN PRIFT_TABLE  RiftTable
    )
    {
    if ( ! NewDecoratedSymbolNode->Hit ) {

        ULONG SymbolNameSize     = strlen( NewDecoratedSymbolNode->SymbolName ) + 1;
        LPSTR NewUndecoratedName = _alloca( SymbolNameSize );
        PSYMBOL_NODE NewUndecoratedSymbolNode;
        PSYMBOL_NODE OldUndecoratedSymbolNode;

        MyUndecorateSymbol(
            NewDecoratedSymbolNode->SymbolName,
            NewUndecoratedName,
            SymbolNameSize
            );

        OldUndecoratedSymbolNode = SymRBFind(
                                       OldUndecoratedSymbolTree,
                                       NewUndecoratedName
                                       );

        if ( OldUndecoratedSymbolNode ) {

            AddRiftEntryToTable(
                RiftTable,
                OldUndecoratedSymbolNode->Rva,
                NewDecoratedSymbolNode->Rva
                );

            OldUndecoratedSymbolNode->Hit = 1;

#ifdef TESTCODE

            CountUndecoratedMatches++;

#endif // TESTCODE

            }

        else {

            //
            //  This new symbol has no match in the old symbol tree.  Build a
            //  tree of unmatched new undecorated symbols.
            //

            NewUndecoratedSymbolNode = SymRBInsert(
                                           NewUndecoratedSymbolTree,
                                           NewUndecoratedName,
                                           NewDecoratedSymbolNode->Rva
                                           );

            return ( NewUndecoratedSymbolNode != NULL );
            }
        }

    return TRUE;
    }


BOOL
MatchRemainingSymbolsRecursive(
    IN PSYMBOL_NODE NewDecoratedSymbolNode,
    IN PSYMBOL_TREE NewUndecoratedSymbolTree,
    IN PSYMBOL_TREE OldUndecoratedSymbolTree,
    IN PRIFT_TABLE  RiftTable
    )
    {
    if ( NewDecoratedSymbolNode == RBNIL ) {
        return TRUE;
        }

    return ( MatchRemainingSymbolsRecursive( NewDecoratedSymbolNode->Left,  NewUndecoratedSymbolTree, OldUndecoratedSymbolTree, RiftTable ) &&
             MatchRemainingSymbolsRecursive( NewDecoratedSymbolNode->Right, NewUndecoratedSymbolTree, OldUndecoratedSymbolTree, RiftTable ) &&
             MatchRemainingSymbolsThisNode(  NewDecoratedSymbolNode,        NewUndecoratedSymbolTree, OldUndecoratedSymbolTree, RiftTable ));
    }


#ifdef TESTCODE

VOID
DumpUnHitSymbolNode(
    IN PSYMBOL_NODE SymbolNode,
    IN HANDLE hFile
    )
    {
    CHAR  TextBuffer[ 16 + MAX_SYMBOL_NAME_LENGTH ];
    DWORD Actual;

    if ( ! SymbolNode->Hit ) {
        sprintf( TextBuffer, "%08X   %s\r\n", SymbolNode->Rva, SymbolNode->SymbolName );
        WriteFile( hFile, TextBuffer, strlen( TextBuffer ), &Actual, NULL );
        }
    }


VOID
DumpUnHitSymbolNodesRecursive(
    IN PSYMBOL_NODE SymbolNode,
    IN HANDLE hFile
    )
    {
    if ( SymbolNode == RBNIL ) {
        return;
        }

    //
    //  The tree is in hash order, not Rva order, so the output will appear
    //  to be in random order (easily solved with sort.exe utility).
    //

    DumpUnHitSymbolNode( SymbolNode, hFile );
    DumpUnHitSymbolNodesRecursive( SymbolNode->Left,  hFile );
    DumpUnHitSymbolNodesRecursive( SymbolNode->Right, hFile );
    }


VOID
DumpUnHitSymbolNodes(
    IN PSYMBOL_TREE SymbolTree,
    IN LPCSTR DumpFileName
    )
    {
    HANDLE hFile;

    hFile = CreateFile(
                DumpFileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if ( hFile != INVALID_HANDLE_VALUE ) {

        DumpUnHitSymbolNodesRecursive( SymbolTree->Root, hFile );

        CloseHandle( hFile );
        }
    }

#endif // TESTCODE


BOOL
MatchRemainingSymbols(
    IN PSYMBOL_TREE NewDecoratedSymbolTree,
    IN PSYMBOL_TREE NewUndecoratedSymbolTree,
    IN PSYMBOL_TREE OldUndecoratedSymbolTree,
    IN PRIFT_TABLE  RiftTable
    )
    {
    BOOL Success;

    //
    //  Walk old tree, for each unmatched symbol, undecorate it and try to
    //  find match in the undecorated new symbol tree.  If it fails to match,
    //  add it to the old undecorated tree.
    //

    Success = MatchRemainingSymbolsRecursive(
                  NewDecoratedSymbolTree->Root,
                  NewUndecoratedSymbolTree,
                  OldUndecoratedSymbolTree,
                  RiftTable
                  );

    if ( Success ) {

        //
        //  Now we have remaining unmatched undecorated symbols in the
        //  OldUndecoratedSymbolTree and NewUndecoratedSymbolTree.
        //
        //  Here is an opportunity to do soft name matching, like for
        //  BBT omap generated symbol names (have trailing '_nnn').
        //  Unfortunately, current versions of imagehlp append an '_nnn'
        //  value that is useless becaue it is not the offset from the
        //  start of the function.
        //

#ifdef TESTCODE

        DumpUnHitSymbolNodes( OldUndecoratedSymbolTree, "UnmatchedOldSymbols.out" );
        DumpUnHitSymbolNodes( NewUndecoratedSymbolTree, "UnmatchedNewSymbols.out" );

#endif // TESTCODE

        }

    return Success;
    }


BOOL
GetImageSymbolRiftInfo(
    IN HANDLE                  OldFileHandle,
    IN PUCHAR                  OldFileMapped,
    IN ULONG                   OldFileSize,
    IN PIMAGE_NT_HEADERS       OldFileNtHeader,
    IN LPCSTR                  OldFileSymPath,
    IN ULONG                   OldFileOriginalChecksum,
    IN ULONG                   OldFileOriginalTimeDate,
    IN ULONG                   OldFileIndex,
    IN HANDLE                  NewFileHandle,
    IN PUCHAR                  NewFileMapped,
    IN ULONG                   NewFileSize,
    IN PIMAGE_NT_HEADERS       NewFileNtHeader,
    IN LPCSTR                  NewFileSymPath,
    IN ULONG                   SymbolOptionFlags,
    IN HANDLE                  SubAllocator,
    IN PRIFT_TABLE             RiftTable,
    IN PPATCH_SYMLOAD_CALLBACK SymLoadCallback,
    IN PVOID                   SymLoadContext
    )
    {
    SYMBOL_CONTEXT SymbolContext;
    DWORD SymOptions;
    ULONG OldBase;
    ULONG NewBase;
    BOOL  Success;

#ifdef TESTCODE
    ULONG InitialRiftEntries = RiftTable->RiftEntryCount;
#endif

    UNREFERENCED_PARAMETER( OldFileNtHeader );
    UNREFERENCED_PARAMETER( OldFileMapped );
    UNREFERENCED_PARAMETER( OldFileSize );
    UNREFERENCED_PARAMETER( NewFileMapped );
    UNREFERENCED_PARAMETER( NewFileSize );

    InitImagehlpCritSect();

    EnterCriticalSection( &ImagehlpCritSect );

    Success = LoadImagehlp();

    if ( Success ) {

        __try {

            SymOptions = Imagehlp.SymGetOptions();

            SymOptions &= ~SYMOPT_CASE_INSENSITIVE;
            SymOptions &= ~SYMOPT_UNDNAME;
            SymOptions &= ~SYMOPT_DEFERRED_LOADS;

            Imagehlp.SymSetOptions( SymOptions );

            Success = Imagehlp.SymInitialize( hProc, NewFileSymPath, FALSE );

            if ( Success ) {

                __try {

                    SymRBInitTree(
                        &SymbolContext.NewDecoratedSymbolTree,
                        SubAllocator
                        );

                    SymRBInitTree(
                        &SymbolContext.NewUndecoratedSymbolTree,
                        SubAllocator
                        );

                    SymRBInitTree(
                        &SymbolContext.OldUndecoratedSymbolTree,
                        SubAllocator
                        );

                    NewBase = Imagehlp.SymLoadModule( hProc, NewFileHandle, NULL, "New", (ULONG)NewFileMapped, NewFileSize );

                    Success = ( NewBase != 0 );

                    if ( Success ) {

                        __try {

                            if ( SymLoadCallback ) {

                                ZeroMemory( &ImagehlpModuleInfo, sizeof( ImagehlpModuleInfo ));
                                ImagehlpModuleInfo.SizeOfStruct = sizeof( ImagehlpModuleInfo );

                                Success = Imagehlp.SymGetModuleInfo(
                                              hProc,
                                              NewBase,
                                              &ImagehlpModuleInfo
                                              );

                                if ( Success ) {

                                    Success = SymLoadCallback(
                                                  0,
                                                  ImagehlpModuleInfo.LoadedImageName,
                                                  ImagehlpModuleInfo.SymType,
                                                  ImagehlpModuleInfo.CheckSum,
                                                  ImagehlpModuleInfo.TimeDateStamp,
                                                  NewFileNtHeader->OptionalHeader.CheckSum,
                                                  NewFileNtHeader->FileHeader.TimeDateStamp,
                                                  SymLoadContext
                                                  );
                                    }
                                }

                            if ( Success ) {

                                SymbolContext.NewImageBase      = NewBase;
                                SymbolContext.SymbolOptionFlags = SymbolOptionFlags;
                                SymbolContext.RiftTable         = RiftTable;
#ifdef TESTCODE
                                CountDecoratedMatches   = 0;
                                CountUndecoratedMatches = 0;

                                SymbolContext.OutFile = CreateFile(
                                                            "NewSymbols.out",
                                                            GENERIC_WRITE,
                                                            FILE_SHARE_READ,
                                                            NULL,
                                                            CREATE_ALWAYS,
                                                            FILE_ATTRIBUTE_NORMAL,
                                                            NULL
                                                            );
#endif // TESTCODE

                                Success = Imagehlp.SymEnumerateSymbols( hProc, NewBase, NewFileEnumSymbolsCallback, &SymbolContext );

#ifdef TESTCODE
                                if ( SymbolContext.OutFile != INVALID_HANDLE_VALUE ) {
                                    CloseHandle( SymbolContext.OutFile );
                                    }
#endif // TESTCODE
                                }
                        }

                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                            Success = FALSE;
                            }

                        Imagehlp.SymUnloadModule( hProc, NewBase );
                        }
                    }

                __except( EXCEPTION_EXECUTE_HANDLER ) {
                    Success = FALSE;
                    }

                //
                //  Must do cleanup and reinitialize Imagehlp for this
                //  process identifier.  Otherwise it thinks the old
                //  module is still hanging around.
                //

                Imagehlp.SymCleanup( hProc );

                if ( Success ) {

                    Success = Imagehlp.SymInitialize( hProc, OldFileSymPath, FALSE );

                    if ( Success ) {

                        __try {

                            OldBase = Imagehlp.SymLoadModule( hProc, OldFileHandle, NULL, "Old", (ULONG)OldFileMapped, OldFileSize );

                            Success = ( OldBase != 0 );

                            if ( Success ) {

                                __try {

                                    if ( SymLoadCallback ) {

                                        ZeroMemory( &ImagehlpModuleInfo, sizeof( ImagehlpModuleInfo ));
                                        ImagehlpModuleInfo.SizeOfStruct = sizeof( ImagehlpModuleInfo );

                                        Success = Imagehlp.SymGetModuleInfo(
                                                      hProc,
                                                      OldBase,
                                                      &ImagehlpModuleInfo
                                                      );

                                        if ( Success ) {

                                            Success = SymLoadCallback(
                                                          OldFileIndex + 1,
                                                          ImagehlpModuleInfo.LoadedImageName,
                                                          ImagehlpModuleInfo.SymType,
                                                          ImagehlpModuleInfo.CheckSum,
                                                          ImagehlpModuleInfo.TimeDateStamp,
                                                          OldFileOriginalChecksum,
                                                          OldFileOriginalTimeDate,
                                                          SymLoadContext
                                                          );
                                            }
                                        }

                                    if ( Success ) {

                                        SymbolContext.OldImageBase = OldBase;
#ifdef TESTCODE
                                        SymbolContext.OutFile = CreateFile(
                                                                    "OldSymbols.out",
                                                                    GENERIC_WRITE,
                                                                    FILE_SHARE_READ,
                                                                    NULL,
                                                                    CREATE_ALWAYS,
                                                                    FILE_ATTRIBUTE_NORMAL,
                                                                    NULL
                                                                    );
#endif // TESTCODE

                                        Success = Imagehlp.SymEnumerateSymbols( hProc, OldBase, OldFileEnumSymbolsCallback, &SymbolContext );

#ifdef TESTCODE
                                        if ( SymbolContext.OutFile != INVALID_HANDLE_VALUE ) {
                                            CloseHandle( SymbolContext.OutFile );
                                            }
#endif // TESTCODE
                                        }

                                    if ( Success ) {

                                        //
                                        //  Need to match remaining decorated new symbols in tree
                                        //  with unmatched now-undecorated old symbols in other tree.
                                        //

                                        if ( SymbolOptionFlags & PATCH_SYMBOL_UNDECORATED_TOO ) {

                                            Success = MatchRemainingSymbols(
                                                          &SymbolContext.NewDecoratedSymbolTree,
                                                          &SymbolContext.NewUndecoratedSymbolTree,
                                                          &SymbolContext.OldUndecoratedSymbolTree,
                                                          RiftTable
                                                          );
                                            }
                                        }
                                    }

                                __except( EXCEPTION_EXECUTE_HANDLER ) {
                                    Success = FALSE;
                                    }

                                Imagehlp.SymUnloadModule( hProc, OldBase );
                                }
                            }

                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                            Success = FALSE;
                            }

                        Imagehlp.SymCleanup( hProc );
                        }
                    }
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            Success = FALSE;
            }
        }

    LeaveCriticalSection( &ImagehlpCritSect );

    if ( ! Success ) {
        SetLastError( ERROR_PATCH_IMAGEHLP_FAILURE );
        }

#ifdef TESTCODE
    printf( "\r%9d decorated symbol matches\n", CountDecoratedMatches );
    printf( "\r%9d undecorated symbol matches\n", CountUndecoratedMatches );
    printf( "\r%9d rift entries from symbols\n", RiftTable->RiftEntryCount - InitialRiftEntries );
#endif

    return Success;
    }


BOOL
OptimizeImageRiftInfo(
    IN PUCHAR             OldFileMapped,
    IN ULONG              OldFileSize,
    IN PIMAGE_NT_HEADERS  OldFileNtHeader,
    IN PUCHAR             NewFileMapped,
    IN ULONG              NewFileSize,
    IN PIMAGE_NT_HEADERS  NewFileNtHeader,
    IN HANDLE             SubAllocator,
    IN PRIFT_TABLE        RiftTable
    )
    {
    UNREFERENCED_PARAMETER( OldFileMapped );
    UNREFERENCED_PARAMETER( OldFileSize );
    UNREFERENCED_PARAMETER( OldFileNtHeader );
    UNREFERENCED_PARAMETER( NewFileMapped );
    UNREFERENCED_PARAMETER( NewFileSize );
    UNREFERENCED_PARAMETER( NewFileNtHeader );
    UNREFERENCED_PARAMETER( SubAllocator );
    UNREFERENCED_PARAMETER( RiftTable );

    return TRUE;
    }

#if 0   // BUGBUG: This is test code

BOOL
OptimizeImageRiftInfo(
    IN PUCHAR             OldFileMapped,
    IN ULONG              OldFileSize,
    IN PIMAGE_NT_HEADERS  OldFileNtHeader,
    IN PUCHAR             NewFileMapped,
    IN ULONG              NewFileSize,
    IN PIMAGE_NT_HEADERS  NewFileNtHeader,
    IN HANDLE             SubAllocator,
    IN PRIFT_TABLE        RiftTable
    )
    {
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  OldFileLastRva;
    ULONG  NewFileLastRva;
    LONG   OldDisplacement;
    LONG   NewDisplacement;
    ULONG  OffsetInSection;
    ULONG  OldOriginRva;
    ULONG  OldTargetRva;
    ULONG  TargetOffset;
    PUCHAR OldFileHintMap;
    PUCHAR NewFileHintMap;
    PUCHAR OldFileCopy;
    PUCHAR NewFileCopy;
    PVOID  OldFileCopyNtHeader;
    PVOID  NewFileCopyNtHeader;
    BOOL   Success;
    BOOL   Skip;
    ULONG  i;
    ULONG  j;
    PUCHAR p;

#ifdef TESTCODE
    ULONG CountVerifiedE8Rifts = 0;
    ULONG CountDiscoveredE8Rifts = 0;
#endif // TESTCODE

    //
    //  Stage1:
    //
    //      Trusting existing rift info, search for E8/E9/Jcc instructions in
    //      the Old file, get the corresponding rift, inspect the corresponding
    //      instruction in the New file.  If they match, great.  If they don't
    //      match, search for a correponding instruction in the new file by
    //      looking forward up to the next rift.  If find a suitable match,
    //      create a new rift entry to support it.
    //
    //      BUGBUG: We don't have the benefit of non-exe marked bytes here.
    //

    if ( OldFileNtHeader->FileHeader.Machine != NewFileNtHeader->FileHeader.Machine ) {
        return TRUE;    // not much we can do here!
        }

    //
    //  We need the HintMap to determine which bytes in the files are not
    //  executable.  The Transform function currently provides this, but
    //  we don't want to modify our mapped file views here.  So, allocate
    //  a range of VM and make a copy of the file to Transform, perform
    //  the transformations on that copy just to produce a hint map, then
    //  free the transformed copy (do this for both old and new files).
    //

    Success = FALSE;

    OldFileHintMap = MyVirtualAlloc( OldFileSize );
    NewFileHintMap = MyVirtualAlloc( NewFileSize );

    if ( OldFileHintMap && NewFileHintMap ) {

        OldFileCopy = MyVirtualAlloc( OldFileSize );

        if ( OldFileCopy ) {

            CopyMemory( OldFileCopy, OldFileMapped, OldFileSize );

            OldFileCopyNtHeader = GetNtHeader( OldFileCopy, OldFileSize );

            Success = TransformCoffImage(
                          ( PATCH_TRANSFORM_NO_RELJMPS | PATCH_TRANSFORM_NO_RELCALLS | PATCH_TRANSFORM_NO_RESOURCE ),
                          OldFileCopyNtHeader,
                          OldFileCopy,
                          OldFileSize,
                          0,
                          RiftTable,
                          OldFileHintMap
                          );

            MyVirtualFree( OldFileCopy );
            }

        if ( Success ) {

            Success = FALSE;

            NewFileCopy = MyVirtualAlloc( NewFileSize );

            if ( NewFileCopy ) {

                CopyMemory( NewFileCopy, NewFileMapped, NewFileSize );

                NewFileCopyNtHeader = GetNtHeader( NewFileCopy, NewFileSize );

                Success = TransformCoffImage(
                              ( PATCH_TRANSFORM_NO_RELJMPS | PATCH_TRANSFORM_NO_RELCALLS | PATCH_TRANSFORM_NO_RESOURCE ),
                              NewFileCopyNtHeader,
                              NewFileCopy,
                              NewFileSize,
                              0,
                              RiftTable,
                              NewFileHintMap
                              );

                MyVirtualFree( NewFileCopy );
                }
            }
        }

    if ( Success ) {

        //
        //  We now have valid OldFileHintMap and NewFileHintMap.
        //

        OldFileLastRva = OldFileNtHeader->OptionalHeader.SizeOfImage;
        NewFileLastRva = NewFileNtHeader->OptionalHeader.SizeOfImage;

        InsertRiftEntryInSortedTable( RiftTable, RiftTable->RiftEntryCount, OldFileLastRva, NewFileLastRva );

        SectionHeader  = IMAGE_FIRST_SECTION( OldFileNtHeader );
        SectionCount   = OldFileNtHeader->FileHeader.NumberOfSections;

        for ( i = 0; i < SectionCount; i++ ) {

            if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

                SectionBaseRva = SectionHeader[ i ].VirtualAddress;
                SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
                SectionOffset  = SectionHeader[ i ].PointerToRawData;
                SectionStart   = OldFileMapped + SectionOffset;

                if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if ( *p == 0xE8 ) {         // call relative32

                            //
                            //  Validate that instruction is not something that
                            //  the HintMap indicates is not an executable
                            //  instruction.  We're looking for a relative
                            //  call instruction here, so it would not be a
                            //  reloc target.
                            //

                            Skip = FALSE;

                            for ( j = 0; j < 5; j++ ) {
                                if ( OldFileHintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                    Skip = TRUE;
                                    break;
                                    }
                                }

                            if ( Skip ) {
                                continue;
                                }

                            //
                            //  Relative displacement is stored as 32-bit
                            //  signed value following these opcodes.  The
                            //  displacement is relative to the NEXT
                            //  instruction, which is at (p + 5).
                            //

                            OldDisplacement = *(UNALIGNED LONG*)( p + 1 );
                            OffsetInSection = ( p + 5 ) - SectionStart;
                            OldOriginRva     = SectionBaseRva + OffsetInSection;
                            OldTargetRva     = OldOriginRva + OldDisplacement;

                            //
                            //  We expect a lot of false positives here because
                            //  occurences of <E8> will
                            //  likely occur in other parts of the instruction
                            //  stream so now we validate that the TargetRva
                            //  falls within the image and within an executable
                            //  section.
                            //

                            if ( OldTargetRva < OldFileLastRva ) {

                                TargetOffset = ImageRvaToFileOffset( OldFileNtHeader, OldTargetRva );

                                if ( ! ( OldFileHintMap[ TargetOffset ] & 0x01 )) {

                                    //
                                    //  Looks like a valid TargetRva, so lookup the
                                    //  corresponding "new" RVAs in the rift table.
                                    //

                                    ULONG RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OldOriginRva );
                                    ULONG RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, OldTargetRva );

                                    ULONG NewOriginRva = OldOriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                                    ULONG NewTargetRva = OldTargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );

                                    PUCHAR NewOriginMa = ImageRvaToMappedAddress( NewFileNtHeader, NewOriginRva, NewFileMapped, NewFileSize );
                                    PUCHAR NewTargetMa = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                    PUCHAR OldTargetMa = ImageRvaToMappedAddress( OldFileNtHeader, OldTargetRva, OldFileMapped, OldFileSize );
                                    PUCHAR OldOriginMa = p + 5;

                                    if (( NewOriginMa ) && ( NewTargetMa ) && ( OldTargetMa )) {

                                        PUCHAR OldInstruct = p;
                                        PUCHAR NewInstruct = NewOriginMa - 5;

                                        //
                                        //  A verified call instruction should match the
                                        //  instruction byte, the byte following the
                                        //  instruction, and the target byte, because
                                        //  they should all be executable code that is
                                        //  not modified by relocs.
                                        //
                                        //  Also verify the NewFileHintMap.
                                        //

                                        if (( *OldInstruct == *NewInstruct ) &&
                                            ( *OldOriginMa == *NewOriginMa ) &&
                                            ( *OldTargetMa == *NewTargetMa )) {

                                            ULONG NewInstructOffset = NewInstruct - NewFileMapped;
                                            ULONG NewTargetOffset   = NewTargetMa - NewFileMapped;
                                            BOOL  Skip = FALSE;

                                            for ( j = 0; j < 5; j++ ) {
                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                    Skip = TRUE;
                                                    break;
                                                    }
                                                }

                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                Skip = TRUE;
                                                }

                                            if ( ! Skip ) {

                                                //
                                                //  This is a bonafide good match.  Add a rift entry
                                                //  for both the instruction and the target.  We do
                                                //  this so that subsequent rift insertions don't get
                                                //  between the rift that coasted to these and these.
                                                //

                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexOrigin, OldOriginRva - 5, NewOriginRva - 5 );
                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexTarget, OldTargetRva, NewTargetRva );
#ifdef TESTCODE
                                                CountVerifiedE8Rifts++;
#endif // TESTCODE

                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  BUGBUG: Implement Alpha platform stuff here.
                    //

                    }
                }
            }

        for ( i = 0; i < SectionCount; i++ ) {

            if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

                SectionBaseRva = SectionHeader[ i ].VirtualAddress;
                SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
                SectionOffset  = SectionHeader[ i ].PointerToRawData;
                SectionStart   = OldFileMapped + SectionOffset;

                if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if ( *p == 0xE8 ) {         // call relative32

                            //
                            //  Validate that instruction is not something that
                            //  the HintMap indicates is not an executable
                            //  instruction.  We're looking for a relative
                            //  call instruction here, so it would not be a
                            //  reloc target.
                            //

                            Skip = FALSE;

                            for ( j = 0; j < 5; j++ ) {
                                if ( OldFileHintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                    Skip = TRUE;
                                    break;
                                    }
                                }

                            if ( Skip ) {
                                continue;
                                }

                            //
                            //  Relative displacement is stored as 32-bit
                            //  signed value following these opcodes.  The
                            //  displacement is relative to the NEXT
                            //  instruction, which is at (p + 5).
                            //

                            OldDisplacement = *(UNALIGNED LONG*)( p + 1 );
                            OffsetInSection = ( p + 5 ) - SectionStart;
                            OldOriginRva     = SectionBaseRva + OffsetInSection;
                            OldTargetRva     = OldOriginRva + OldDisplacement;

                            //
                            //  We expect a lot of false positives here because
                            //  occurences of <E8> will
                            //  likely occur in other parts of the instruction
                            //  stream so now we validate that the TargetRva
                            //  falls within the image and within an executable
                            //  section.
                            //

                            if ( OldTargetRva < OldFileLastRva ) {

                                TargetOffset = ImageRvaToFileOffset( OldFileNtHeader, OldTargetRva );

                                if ( ! ( OldFileHintMap[ TargetOffset ] & 0x01 )) {

                                    //
                                    //  Looks like a valid TargetRva, so lookup the
                                    //  corresponding "new" RVAs in the rift table.
                                    //

                                    ULONG RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OldOriginRva );
                                    ULONG RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, OldTargetRva );

                                    ULONG NewOriginRva = OldOriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                                    ULONG NewTargetRva = OldTargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );

                                    PUCHAR NewOriginMa = ImageRvaToMappedAddress( NewFileNtHeader, NewOriginRva, NewFileMapped, NewFileSize );
                                    PUCHAR NewTargetMa = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                    PUCHAR OldTargetMa = ImageRvaToMappedAddress( OldFileNtHeader, OldTargetRva, OldFileMapped, OldFileSize );
                                    PUCHAR OldOriginMa = p + 5;

                                    if (( NewOriginMa ) && ( NewTargetMa ) && ( OldTargetMa )) {

                                        PUCHAR OldInstruct = p;
                                        PUCHAR NewInstruct = NewOriginMa - 5;

                                        //
                                        //  A verified call instruction should match the
                                        //  instruction byte, the byte following the
                                        //  instruction, and the target byte, because
                                        //  they should all be executable code that is
                                        //  not modified by relocs.
                                        //
                                        //  Check NewHintMap too.
                                        //

                                        if (( *OldInstruct == *NewInstruct ) &&
                                            ( *OldOriginMa == *NewOriginMa ) &&
                                            ( *OldTargetMa == *NewTargetMa )) {

                                            ULONG NewInstructOffset = NewInstruct - NewFileMapped;
                                            ULONG NewTargetOffset   = NewTargetMa - NewFileMapped;
                                            BOOL  Skip = FALSE;

                                            for ( j = 0; j < 5; j++ ) {
                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                    Skip = TRUE;
                                                    break;
                                                    }
                                                }

                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                Skip = TRUE;
                                                }

                                            if ( ! Skip ) {

                                                //
                                                //  This is a bonafide good match.
                                                //

                                                continue;
                                                }
                                            }

                                        {

                                            //
                                            //  Instructions don't match.  Scan to find
                                            //  matching instruction in new file.  Scan
                                            //  the extent of this rift entry.
                                            //

                                            PUCHAR ScanInstruct;
                                            PUCHAR LowestMaToScan;
                                            PUCHAR HighestMaToScan;
                                            ULONG  LowestRvaToScan  = RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva;
                                            ULONG  HighestRvaToScan = RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva;
                                            ULONG  ExpectedTargetRva = NewTargetRva;
                                            BOOL   Found = FALSE;

                                            LowestMaToScan  = ImageRvaToMappedAddress( NewFileNtHeader, LowestRvaToScan,  NewFileMapped, NewFileSize );
                                            HighestMaToScan = ImageRvaToMappedAddress( NewFileNtHeader, HighestRvaToScan, NewFileMapped, NewFileSize );

                                            HighestMaToScan -= 5;   // size of instruction

                                            for ( ScanInstruct = NewInstruct + 1; ScanInstruct <= HighestMaToScan; ScanInstruct++ ) {

                                                if ( *ScanInstruct == 0xE8 ) {

                                                    //
                                                    //  BUGBUG: check NewHintMap
                                                    //

                                                    NewOriginMa     = ScanInstruct + 5;
                                                    NewOriginRva    = MappedAddressToImageRva( NewFileNtHeader, NewOriginMa, NewFileMapped );
                                                    NewDisplacement = *(UNALIGNED LONG*)( ScanInstruct + 1 );
                                                    NewTargetRva    = NewOriginRva + NewDisplacement;
                                                    NewTargetMa     = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                                    if (( NewOriginRva ) && ( NewTargetMa )) {

                                                        //
                                                        //  We already know *OldInstruct == *ScanInstruct
                                                        //

                                                        if (( *OldOriginMa == *NewOriginMa ) &&
                                                            ( *OldTargetMa == *NewTargetMa ) &&
                                                            ( NewTargetRva == ExpectedTargetRva )) {

                                                            ULONG NewInstructOffset = ScanInstruct - NewFileMapped;
                                                            ULONG NewTargetOffset   = NewTargetMa  - NewFileMapped;
                                                            BOOL  Skip = FALSE;

                                                            for ( j = 0; j < 5; j++ ) {
                                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                                    Skip = TRUE;
                                                                    break;
                                                                    }
                                                                }

                                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                                Skip = TRUE;
                                                                }

                                                            if ( ! Skip ) {

                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexOrigin, OldOriginRva - 5, NewOriginRva - 5 );
                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexTarget, OldTargetRva, NewTargetRva );
                                                                Found = TRUE;
#ifdef TESTCODE
                                                                CountDiscoveredE8Rifts++;
#endif // TESTCODE
                                                                break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                            if ( Found ) {
                                                continue;
                                                }

                                            for ( ScanInstruct = NewInstruct - 1; ScanInstruct >= LowestMaToScan; ScanInstruct-- ) {

                                                if ( *ScanInstruct == 0xE8 ) {

                                                    //
                                                    //  BUGBUG: check NewHintMap
                                                    //

                                                    NewOriginMa     = ScanInstruct + 5;
                                                    NewOriginRva    = MappedAddressToImageRva( NewFileNtHeader, NewOriginMa, NewFileMapped );
                                                    NewDisplacement = *(UNALIGNED LONG*)( ScanInstruct + 1 );
                                                    NewTargetRva    = NewOriginRva + NewDisplacement;
                                                    NewTargetMa     = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                                    if (( NewOriginRva ) && ( NewTargetMa )) {

                                                        //
                                                        //  We already know *OldInstruct == *ScanInstruct
                                                        //

                                                        if (( *OldOriginMa == *NewOriginMa ) &&
                                                            ( *OldTargetMa == *NewTargetMa ) &&
                                                            ( NewTargetRva == ExpectedTargetRva )) {

                                                            ULONG NewInstructOffset = ScanInstruct - NewFileMapped;
                                                            ULONG NewTargetOffset   = NewTargetMa  - NewFileMapped;
                                                            BOOL  Skip = FALSE;

                                                            for ( j = 0; j < 5; j++ ) {
                                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                                    Skip = TRUE;
                                                                    break;
                                                                    }
                                                                }

                                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                                Skip = TRUE;
                                                                }

                                                            if ( ! Skip ) {

                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexOrigin, OldOriginRva - 5, NewOriginRva - 5 );
                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexTarget, OldTargetRva, NewTargetRva );
                                                                Found = TRUE;
#ifdef TESTCODE
                                                                CountDiscoveredE8Rifts++;
#endif // TESTCODE
                                                                break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  BUGBUG: Implement Alpha platform stuff here.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE
    printf( "\r%9d verified E8 rifts\n", CountVerifiedE8Rifts );
    printf( "\r%9d discovered E8 rifts\n", CountDiscoveredE8Rifts );
#endif // TESTCODE

    if ( OldFileHintMap ) {
        MyVirtualFree( OldFileHintMap );
        }

    if ( NewFileHintMap ) {
        MyVirtualFree( NewFileHintMap );
        }

    return Success;
    }


#endif // 0 (test code)


BOOL
GenerateRiftTable(
    IN HANDLE OldFileHandle,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN ULONG  OldFileOriginalChecksum,
    IN ULONG  OldFileOriginalTimeDate,
    IN HANDLE NewFileHandle,
    IN PUCHAR NewFileMapped,
    IN ULONG  NewFileSize,
    IN ULONG  OptionFlags,
    IN PPATCH_OPTION_DATA OptionData,
    IN ULONG  OldFileIndex,
    IN PRIFT_TABLE RiftTable
    )
    {
    PIMAGE_NT_HEADERS OldFileNtHeader;
    PIMAGE_NT_HEADERS NewFileNtHeader;
    LPCSTR OldFileSymPath;
    LPCSTR NewFileSymPath;
    HANDLE SubAllocator;
    ULONG SymbolOptionFlags;
    BOOL Success = FALSE;

    UNREFERENCED_PARAMETER( OptionFlags );

    SymbolOptionFlags = 0;
    SubAllocator = NULL;

    __try {

        //
        //  See if both files are PE images.
        //

        OldFileNtHeader = GetNtHeader( OldFileMapped, OldFileSize );

        if ( OldFileNtHeader ) {

            NewFileNtHeader = GetNtHeader( NewFileMapped, NewFileSize );

            if ( NewFileNtHeader ) {

                //
                //  Both files are PE images.
                //

                SubAllocator = CreateSubAllocator( 0x100000, 0x100000 );

                if ( ! SubAllocator ) {
                    Success = FALSE;
                    __leave;
                    }

                //
                //  Even without symbols, we can still generate some
                //  basic rift info from PE import and export names, etc.
                //

                Success = GetImageNonSymbolRiftInfo(
                              OldFileMapped,
                              OldFileSize,
                              OldFileNtHeader,
                              NewFileMapped,
                              NewFileSize,
                              NewFileNtHeader,
                              SubAllocator,
                              RiftTable
                              );

                //
                //  Now attempt to get rift info from symbols.
                //

                if (( OptionData ) &&
                    ( OptionData->SizeOfThisStruct >=
                        ( offsetof( PATCH_OPTION_DATA, SymLoadContext ) +
                          sizeof( OptionData->SymLoadContext )))) {

                    SymbolOptionFlags = OptionData->SymbolOptionFlags;

                    if ( ! ( SymbolOptionFlags & PATCH_SYMBOL_NO_IMAGEHLP )) {

                        if ( OptionData->OldFileSymbolPathArray ) {

                            OldFileSymPath = OptionData->OldFileSymbolPathArray[ OldFileIndex ];
                            NewFileSymPath = OptionData->NewFileSymbolPath;

                            if (( OldFileSymPath ) && ( NewFileSymPath )) {

                                //
                                //  tommcg 11/15/2000, before loading imagehlp, attempt to open the
                                //  OldFileSymPath and NewFileSymPath directly as files to see if
                                //  they are really psyminfo files.  If the open fails, or if both
                                //  old and new cannot be opened, fall back to imagehlp.
                                //

                                Success = GetImageSymbolRiftInfoFromPsymFiles(
                                              OldFileHandle,
                                              OldFileMapped,
                                              OldFileSize,
                                              OldFileNtHeader,
                                              OldFileSymPath,
                                              OldFileOriginalChecksum,
                                              OldFileOriginalTimeDate,
                                              OldFileIndex,
                                              NewFileHandle,
                                              NewFileMapped,
                                              NewFileSize,
                                              NewFileNtHeader,
                                              NewFileSymPath,
                                              SymbolOptionFlags,
                                              SubAllocator,
                                              RiftTable,
                                              OptionData->SymLoadCallback,
                                              OptionData->SymLoadContext
                                              );

                                if ( ! Success ) {

                                    Success = GetImageSymbolRiftInfo(
                                                  OldFileHandle,
                                                  OldFileMapped,
                                                  OldFileSize,
                                                  OldFileNtHeader,
                                                  OldFileSymPath,
                                                  OldFileOriginalChecksum,
                                                  OldFileOriginalTimeDate,
                                                  OldFileIndex,
                                                  NewFileHandle,
                                                  NewFileMapped,
                                                  NewFileSize,
                                                  NewFileNtHeader,
                                                  NewFileSymPath,
                                                  SymbolOptionFlags,
                                                  SubAllocator,
                                                  RiftTable,
                                                  OptionData->SymLoadCallback,
                                                  OptionData->SymLoadContext
                                                  );
                                    }

                                if ( SymbolOptionFlags & PATCH_SYMBOL_NO_FAILURES ) {
#ifdef TESTCODE
                                    if (( ! Success ) && ( GetLastError() == ERROR_PATCH_IMAGEHLP_FAILURE )) {
                                        printf( "\rWARNING: Imagehlp.Dll failure\n" );
                                        }
#endif
                                    Success = TRUE;
                                    }
                                }
                            }
                        }
                    }

                if ( Success ) {

                    RiftSortAndRemoveDuplicates(
                        OldFileMapped,
                        OldFileSize,
                        OldFileNtHeader,
                        NewFileMapped,
                        NewFileSize,
                        NewFileNtHeader,
                        RiftTable
                        );

                    //
                    //  Now we can optimize the rift info by peeking into
                    //  the mapped files.
                    //

                    Success = OptimizeImageRiftInfo(
                                  OldFileMapped,
                                  OldFileSize,
                                  OldFileNtHeader,
                                  NewFileMapped,
                                  NewFileSize,
                                  NewFileNtHeader,
                                  SubAllocator,
                                  RiftTable
                                  );
                    }

#ifdef TESTCODE

                if ( Success ) {

                    HANDLE hFile = CreateFile(
                                       "RiftInfo.out",
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL
                                       );

                    if ( hFile != INVALID_HANDLE_VALUE ) {

                        CHAR  TextBuffer[ 24 ];
                        DWORD Actual;
                        ULONG i;

                        for ( i = 0; i < RiftTable->RiftEntryCount; i++ ) {
                            sprintf( TextBuffer, "%08X %08X\r\n", RiftTable->RiftEntryArray[ i ].OldFileRva, RiftTable->RiftEntryArray[ i ].NewFileRva );
                            WriteFile( hFile, TextBuffer, 19, &Actual, NULL );
                            }

                        CloseHandle( hFile );
                        }
                    }

#endif // TESTCODE

                }
            }
        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    if ( SubAllocator ) {
        DestroySubAllocator( SubAllocator );
        }

    return Success;
    }



#endif // PATCH_APPLY_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\redblack.c ===
#include <precomp.h>

/*
    redblack.c

    Implementation of red-black binary tree insertion, deletion, and search.
    This algorithm efficiently guarantees that the tree depth will never exceed
    2*Lg(N), so a one million node tree would have a worst case depth of 40.
    This insertion implementation is non-recursive and very efficient (the
    average insertion speed is less than twice the average search speed).

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998-2000.

    2/98, modified this version of redblack.c for debug symbol lookups.

*/

#ifndef PATCH_APPLY_CODE_ONLY

//
//  Rather than storing NULL links as NULL, we point NULL links to a special
//  "Empty" node which is always black and its children links point to itself.
//  We do this to simplify the color testing for children and grandchildren
//  such that any link can be dereferenced and even double-dereferenced without
//  explicitly checking for NULL.  The empty node must be colored black.
//

const SYMBOL_NODE SymRBEmptyNode = { RBNIL, RBNIL };


VOID
SymRBInitTree(
    IN OUT PSYMBOL_TREE Tree,
    IN HANDLE SubAllocator
    )
    {
#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
    Tree->CountNodes = 0;
    Tree->DeletedAny = FALSE;
#endif
    Tree->Root = RBNIL;
    Tree->SubAllocator = SubAllocator;
    }


PSYMBOL_NODE
SymRBFind(
    IN PSYMBOL_TREE Tree,
    IN LPSTR SymbolName
    )
    {
    PSYMBOL_NODE Node = Tree->Root;
    ULONG        Hash;
    int          Compare;

    Hash = HashName( SymbolName );

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            Node =  Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            Node =  Node->Right;
            }
        else {

            Compare = strcmp( SymbolName, Node->SymbolName );

            if ( Compare == 0 ) {
                return Node;
                }
            else if ( Compare < 0 ) {
                Node =  Node->Left;
                }
            else {
                Node =  Node->Right;
                }
            }
        }

    return NULL;
    }


PSYMBOL_NODE
SymRBInsert(
    IN OUT PSYMBOL_TREE Tree,
    IN     LPSTR SymbolName,
    IN     ULONG Rva
    )
    {
    PSYMBOL_NODE * Stack[ MAX_DEPTH ];
    PSYMBOL_NODE **StackPointer = Stack;
    PSYMBOL_NODE * Link;
    PSYMBOL_NODE   Node;
    PSYMBOL_NODE   Sibling;
    PSYMBOL_NODE   Parent;
    PSYMBOL_NODE   Child;
    PSYMBOL_NODE   NewNode;
    ULONG          NameLength;
    ULONG          Hash;
    int            Compare;

    ASSERT( ! Tree->DeletedAny );

    Hash = HashName( SymbolName );

    //
    //  Walk down the tree to find either an existing node with the same key
    //  (in which case we simply return) or the insertion point for the new
    //  node.  At each traversal we need to store the address of the link to
    //  the next node so we can retrace the traversal path for balancing.
    //  The speed of insertion is highly dependent on traversing the tree
    //  quickly, so all balancing operations are deferred until after the
    //  traversal is complete.
    //

    *StackPointer++ = &Tree->Root;

    Node = Tree->Root;

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            *StackPointer++ = &Node->Left;
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            *StackPointer++ = &Node->Right;
            Node = Node->Right;
            }
        else {

            Compare = strcmp( SymbolName, Node->SymbolName );

            if ( Compare == 0 ) {

                //
                //  Found a matching symbol.
                //

                return Node;
                }

            else if ( Compare < 0 ) {
                *StackPointer++ = &Node->Left;
                Node = Node->Left;
                }
            else {
                *StackPointer++ = &Node->Right;
                Node = Node->Right;
                }
            }
        }

    //
    //  Didn't find a matching entry, so allocate a new node and add it
    //  to the tree.
    //

    NameLength = strlen( SymbolName ) + 1;

    NewNode = SubAllocate( Tree->SubAllocator, ( sizeof( SYMBOL_NODE ) + NameLength ));

    if ( NewNode == NULL ) {
        return NULL;
        }

#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
    Tree->CountNodes++;
#endif

    NewNode->Left   = RBNIL;
    NewNode->Right  = RBNIL;
    NewNode->Hash   = Hash;
    NewNode->RvaWithStatusBits = Rva | 0x80000000;  // make new node RED, not hit
    memcpy( NewNode->SymbolName, SymbolName, NameLength );

    //
    //  Insert new node under last link we traversed.  The top of the stack
    //  contains the address of the last link we traversed.
    //

    Link = *( --StackPointer );
    *Link = NewNode;

    //
    //  Now walk back up the traversal chain to see if any balancing is
    //  needed.  This terminates in one of three ways: we walk all the way
    //  up to the root (StackPointer == Stack), or find a black node that
    //  we don't need to change (no balancing needs to be done above a
    //  black node), or we perform a balancing rotation (only one necessary).
    //

    Node = NewNode;
    Child = RBNIL;

    while ( StackPointer > Stack ) {

        Link = *( --StackPointer );
        Parent = *Link;

        //
        //  Node is always red here.
        //

        if ( IS_BLACK( Parent )) {

            Sibling = ( Parent->Left == Node ) ? Parent->Right : Parent->Left;

            if ( IS_RED( Sibling )) {

                //
                //  Both Node and its Sibling are red, so change them both to
                //  black and make the Parent red.  This essentially moves the
                //  red link up the tree so balancing can be performed at a
                //  higher level.
                //
                //        Pb                     Pr
                //       /  \       ---->       /  \
                //      Cr  Sr                 Cb  Sb
                //

                MARK_BLACK( Sibling );
                MARK_BLACK( Node );
                MARK_RED( Parent );
                }

            else {

                //
                //  This is a terminal case.  The Parent is black, and it's
                //  not going to be changed to red.  If the Node's child is
                //  red, we perform an appropriate rotation to balance the
                //  tree.  If the Node's child is black, we're done.
                //

                if ( IS_RED( Child )) {

                    if ( Node->Left == Child ) {

                        if ( Parent->Left == Node ) {

                            //
                            //       Pb             Nb
                            //      /  \           /  \
                            //     Nr   Z   to    Cr  Pr
                            //    /  \                / \
                            //   Cr   Y              Y   Z
                            //

                            MARK_RED( Parent );
                            Parent->Left = Node->Right;
                            Node->Right = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            //
                            //       Pb                Cb
                            //      /  \              /  \
                            //     W    Nr    to     Pr   Nr
                            //         /  \         / \   / \
                            //        Cr   Z       W   X Y   Z
                            //       /  \
                            //      X    Y
                            //

                            MARK_RED( Parent );
                            Parent->Right = Child->Left;
                            Child->Left = Parent;
                            Node->Left = Child->Right;
                            Child->Right = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }

                    else {

                        if ( Parent->Right == Node ) {

                            MARK_RED( Parent );
                            Parent->Right = Node->Left;
                            Node->Left = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            MARK_RED( Parent );
                            Parent->Left = Child->Right;
                            Child->Right = Parent;
                            Node->Right = Child->Left;
                            Child->Left = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }
                    }

                return NewNode;
                }
            }

        Child = Node;
        Node = Parent;
        }

    //
    //  We bubbled red up to the root -- restore it to black.
    //

    MARK_BLACK( Tree->Root );
    return NewNode;
    }

#endif // ! PATCH_APPLY_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\precomp.h ===
#define BUILDING_PATCHAPI 1

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

#pragma warning( push, 3 )
#include <windows.h>
#include <imagehlp.h>
#pragma warning( pop )

#pragma warning( disable: 4001 )    // single line comments
#pragma warning( disable: 4115 )    // type definition in parentheses
#pragma warning( disable: 4200 )    // zero-sized array in struct/union
#pragma warning( disable: 4201 )    // nameless struct/union
#pragma warning( disable: 4204 )    // non-constant initializer
#pragma warning( disable: 4206 )    // empty file after preprocessing
#pragma warning( disable: 4209 )    // benign redefinition
#pragma warning( disable: 4213 )    // cast on l-value
#pragma warning( disable: 4214 )    // bit field other than int
#pragma warning( disable: 4514 )    // unreferenced inline function

#include <stdlib.h>                 // for debug printf

#include "md5.h"
#include "misc.h"
#include "redblack.h"
#include "patchapi.h"
#include "patchprv.h"
#include "patchlzx.h"
#include "pestuff.h"
#include "psym.h"

typedef void t_encoder_context;
typedef void t_decoder_context;

#include <encapi.h>
#include <decapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\psym.h ===
#ifndef _PATCH_PSYM_H_
#define _PATCH_PSYM_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOL
GetImageSymbolRiftInfoFromPsymFiles(
    IN HANDLE                  OldFileHandle,
    IN PUCHAR                  OldFileMapped,
    IN ULONG                   OldFileSize,
    IN PIMAGE_NT_HEADERS       OldFileNtHeader,
    IN LPCSTR                  OldFileSymPath,
    IN ULONG                   OldFileOriginalChecksum,
    IN ULONG                   OldFileOriginalTimeDate,
    IN ULONG                   OldFileIndex,
    IN HANDLE                  NewFileHandle,
    IN PUCHAR                  NewFileMapped,
    IN ULONG                   NewFileSize,
    IN PIMAGE_NT_HEADERS       NewFileNtHeader,
    IN LPCSTR                  NewFileSymPath,
    IN ULONG                   SymbolOptionFlags,
    IN HANDLE                  SubAllocator,
    IN PRIFT_TABLE             RiftTable,
    IN PPATCH_SYMLOAD_CALLBACK SymLoadCallback,
    IN PVOID                   SymLoadContext
    );

#ifdef __cplusplus
}
#endif

#endif /* _PATCH_PSYM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\redblack.h ===
/*
    redblack.h

    Prototypes and node structure definition for red-black binary trees.
    See redblack.c for details and implementation.

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998-2000.

    2/98, modified this version of redblack.h for debug symbol lookups.

*/

#ifndef _REDBLACK_H_
#define _REDBLACK_H_

typedef struct _SYMBOL_NODE SYMBOL_NODE, *PSYMBOL_NODE;
typedef struct _SYMBOL_TREE SYMBOL_TREE, *PSYMBOL_TREE;

struct _SYMBOL_NODE {
    PSYMBOL_NODE Left;
    PSYMBOL_NODE Right;
    ULONG        Hash;
    union {
      ULONG      RvaWithStatusBits;
      struct {
        ULONG    Rva:30;
        ULONG    Hit:1;
        ULONG    Red:1;
        };
      };
    CHAR         SymbolName[ 0 ];
    };

struct _SYMBOL_TREE {
    PSYMBOL_NODE Root;
    HANDLE SubAllocator;
#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
    ULONG CountNodes;
    BOOL DeletedAny;
#endif
    };


#define RBNIL ((PSYMBOL_NODE)&SymRBEmptyNode)

extern const SYMBOL_NODE SymRBEmptyNode;


//
//  Although "Red" can be stored in its own 1-byte or 4-byte field, keeping the
//  nodes smaller by encoding "Red" as a one-bit field with another value
//  provides better performance (more nodes tend to stay in the cache).  To
//  provide flexibility in storage of the RED property, all references to RED
//  and BLACK are made through the following macros which can be changed as
//  necessary:
//

#define IS_RED( Node )            (   (Node)->Red )
#define IS_BLACK( Node )          ( ! (Node)->Red )
#define MARK_RED( Node )          (   (Node)->Red = 1 )
#define MARK_BLACK( Node )        (   (Node)->Red = 0 )

//
//  The maximum tree depth is 2*Lg(N).  Since we could never have more than
//  2^X nodes with X-bit pointers, we can safely say the absolute maximum
//  depth will be 2*Lg(2^X) which is 2*X.  The size of a pointer in bits is
//  its size in bytes times 8 bits, so 2*(sizeof(p)*8) is our maximum depth.
//  So for 32-bit pointers, our maximum depth is 64.
//
//  If you know the maximum possible number of nodes in advance (like the size
//  of the address space divided by the size of a node), you can tweak this
//  value a bit smaller to 2*Lg(N).  Note that it's important for this max
//  depth be evalutated to a constant value at compile time.
//
//  For this implementation, we'll assume the maximum number of nodes is
//  128 million, so the max depth is 54 (2*Lg(2^27)).  Note that no runtime
//  checks are made to ensure we don't exceed this number, but since our
//  minimum node allocation size is 32 bytes, that would be a maximum of
//  100 million nodes in a 3GB address space.
//

#define MAX_DEPTH 54


//
//  The following prototypes are the red-black tree interface.
//

VOID
SymRBInitTree(
    IN OUT PSYMBOL_TREE Tree,
    IN HANDLE SubAllocator
    );

PSYMBOL_NODE
SymRBInsert(
    IN OUT PSYMBOL_TREE Tree,
    IN     LPSTR SymbolName,
    IN     ULONG Rva
    );

PSYMBOL_NODE
SymRBFind(
    IN PSYMBOL_TREE Tree,
    IN LPSTR SymbolName
    );

PSYMBOL_NODE
SymRBFindAndDelete(
    IN OUT PSYMBOL_TREE Tree,
    IN     LPSTR SymbolName
    );

#endif // _REDBLACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\psym.cpp ===
#include <precomp.h>

//
//  psym.cpp
//
//  Author: Tom McGuire (tommcg)
//
//  Copyright (C) Microsoft, 2000-2001.
//

#ifndef PATCH_APPLY_CODE_ONLY

#define TBUFSIZE 0x10000                // sizeof ScratchBuffer allocation

#define NAME_HASH_TABLE_COUNT 0x2000    // 8192 x sizeof(PVOID) == 32K or 64K
#define SYM_HASH_TABLE_COUNT  0x2000    // 8192 x sizeof(PVOID) == 32K or 64K

typedef const unsigned char *PCBYTE;


struct NAMENODE
{
    NAMENODE* Next;
    ULONG     Hash;                     // high 16 bits contains name length
    CHAR      Name[ 0 ];                // variable length, null terminated
};


struct FRAGMENT
{
    FRAGMENT* Next;
    ULONG     SymOffset;
    ULONG     FragRva;
};


struct SYMNODE
{
    SYMNODE*  Next;
    NAMENODE* NameId;
    FRAGMENT  BaseFrag;

#ifdef DEBUGCODE
    ULONG     MatchCount;
#endif

};


class NAMETABLE
{

public:

    NAMENODE* __fastcall InsertName( LPCSTR Name );
    NAMENODE* __fastcall LookupName( LPCSTR Name );
    NAMENODE* __fastcall LocateNode( LPCSTR Name, BOOL Insert );

    NAMETABLE( HANDLE hSubAllocator );

//private:

    HANDLE      m_SubAllocator;
    NAMENODE**  m_NameHashTable;

};


NAMETABLE::NAMETABLE( HANDLE hSubAllocator )
{
    m_SubAllocator  = hSubAllocator;
    m_NameHashTable = (NAMENODE**) SubAllocate(
                                       hSubAllocator,
                                       NAME_HASH_TABLE_COUNT * sizeof( PVOID )
                                       );
}


NAMENODE* __fastcall NAMETABLE::LookupName( LPCSTR Name )
{
    return LocateNode( Name, false );
}


NAMENODE* __fastcall NAMETABLE::InsertName( LPCSTR Name )
{
    return LocateNode( Name, true );
}


NAMENODE* __fastcall NAMETABLE::LocateNode( LPCSTR Name, BOOL Insert )
{
    ASSERT( m_NameHashTable != NULL );

    ULONG Length = 0;
    ULONG Hash   = (ULONG) -1;

    while ( Name[ Length ] != 0 )
    {
        Hash = _rotl( Hash, 3 ) ^ *(UNALIGNED WORD *)&Name[ Length++ ];
    }

    ASSERT( Length < 0x10000 );

    Hash = (( Hash ^ ( Hash >> 16 )) & 0xFFFF ) | ( Length << 16 );

    ASSERT(( Hash >> 16 ) == Length );

    NAMENODE** Link = &m_NameHashTable[ Hash % NAME_HASH_TABLE_COUNT ];
    NAMENODE*  Node = *Link;

    while ( Node != NULL )
    {
        Link = &Node->Next;

        if ( Hash == Node->Hash )
        {
            if ( memcmp( Name, Node->Name, Length ) == 0 )
            {
                return Node;
            }
        }

        Node = *Link;
    }

    if ( Insert )
    {
        Node = (NAMENODE*) SubAllocate( m_SubAllocator, sizeof( NAMENODE ) + Length + 1 );

        if ( Node != NULL )
        {
            Node->Hash = Hash;

#ifdef DONTCOMPILE  // not necessary since SubAllocate returns zeroed memory

            Node->Next = NULL;

            memcpy( Node->Name, Name, Length + 1 );

#endif

            memcpy( Node->Name, Name, Length );

            *Link = Node;
        }
    }

    return Node;
}


class SYMTABLE
{

public:

    SYMNODE* __fastcall InsertSym( NAMENODE* NameId );
    SYMNODE* __fastcall InsertSym( LPCSTR Name );
    SYMNODE* __fastcall LookupSym( NAMENODE* NameId );
    SYMNODE* __fastcall LookupSym( LPCSTR Name );
    SYMNODE* __fastcall LocateNode( NAMENODE* NameId, BOOL Insert );

    SYMTABLE( NAMETABLE* NameTable, HANDLE SubAllocator );

//private:

    HANDLE      m_SubAllocator;
    SYMNODE**   m_SymHashTable;
    NAMETABLE*  m_NameTable;

};


SYMTABLE::SYMTABLE( NAMETABLE* NameTable, HANDLE hSubAllocator )
{
    m_NameTable    = NameTable;
    m_SubAllocator = hSubAllocator;

    m_SymHashTable = (SYMNODE**) SubAllocate(
                                     hSubAllocator,
                                     SYM_HASH_TABLE_COUNT * sizeof( PVOID )
                                     );
}


SYMNODE* __fastcall SYMTABLE::LookupSym( NAMENODE* NameId )
{
    return LocateNode( NameId, false );
}


SYMNODE* __fastcall SYMTABLE::LookupSym( LPCSTR Name )
{
    NAMENODE* NameNode = m_NameTable->LookupName( Name );

    if ( NameNode != NULL )
    {
        return LocateNode( NameNode, false );
    }

    return FALSE;
}


SYMNODE* __fastcall SYMTABLE::InsertSym( NAMENODE* NameId )
{
    return LocateNode( NameId, true );
}


SYMNODE* __fastcall SYMTABLE::InsertSym( LPCSTR Name )
{
    NAMENODE* NameNode = m_NameTable->InsertName( Name );

    if ( NameNode != NULL )
    {
        return LocateNode( NameNode, true );
    }

    return FALSE;
}


SYMNODE* __fastcall SYMTABLE::LocateNode( NAMENODE* NameId, BOOL Insert )
{
    ASSERT( m_SymHashTable != NULL );

    SYMNODE** Link = &m_SymHashTable[ ((ULONG)NameId >> 2 ) % SYM_HASH_TABLE_COUNT ];
    SYMNODE*  Node = *Link;

    while ( Node != NULL )
    {
        Link = &Node->Next;

        if ( NameId == Node->NameId )
        {
            return Node;
        }

        Node = *Link;
    }

    if ( Insert )
    {
        Node = (SYMNODE*) SubAllocate( m_SubAllocator, sizeof( SYMNODE ));

        if ( Node != NULL )
        {
            Node->NameId = NameId;

#ifdef DONTCOMPILE  // not necessary since SubAllocate returns zeroed memory

            Node->Next               = NULL;
            Node->BaseFrag.Next      = NULL;
            Node->BaseFrag.SymOffset = 0;
            Node->BaseFrag.FragRva   = 0;

            DEBUGCODE( Node->MatchCount = 0 );
#endif

            *Link = Node;
        }
    }

    return Node;
}


#ifdef _M_IX86

//
//  x86 compiler doesn't have intrinsic memchr, so we'll do our own.  Note that
//  "repne scasb" is slower (2X) than simply comparing one byte at a time on
//  Pentium II and III.
//

PCBYTE
__inline
__fastcall
ScanForChar(
    IN PCBYTE Buffer,
    IN ULONG  BufLength,
    IN CHAR   SearchFor
    )
{
    PCBYTE p;
    ULONG  n;

    for ( p = Buffer, n = BufLength; n > 0; p++, n-- )
    {
        if ( *p == SearchFor )
        {
            return p;
        }
    }

    return NULL;
}

#else   // ! _M_IX86

PCBYTE
__inline
__fastcall
ScanForChar(
    IN PCBYTE Buffer,
    IN ULONG  BufLength,
    IN CHAR   SearchFor
    )
{
    return memchr( Buffer, SearchFor, BufLength );
}

#endif  // ! _M_IX86


int
__inline
__fastcall
MySimpleCompareCaseInsensitive(
    IN PCBYTE One,
    IN PCBYTE Two,
    IN ULONG  Len
    )
{
    while ( Len-- )
    {
        int Diff = ( *One | 0x20 ) - ( *Two | 0x20 );

        if ( Diff != 0 )
        {
            return Diff;
        }

        One++;
        Two++;
    }

    return 0;
}



DWORDLONG
__fastcall
HexStrToUnsigned64(
    IN LPCSTR HexStr
    )
{
    LPCSTR    p = HexStr;
    DWORDLONG Value = 0;
    DWORDLONG NewValue;
    ULONG     Digit;

    for ( ;; )
    {
        Digit = ( *p++ ) - 0x30;

        NewValue = Value << 4;

        if ( Digit > 9 )
        {
            Digit = ( Digit & 0x1F ) - 7;

            if ( ( Digit > 15 ) || ( Digit < 10 ) )
            {
                return Value;
            }
        }

        Value = NewValue | Digit;
    }
}


ULONG
__fastcall
HexStrToUnsigned32(
    IN LPCSTR HexStr
    )
{
    LPCSTR p = HexStr;
    ULONG  Value = 0;
    ULONG  NewValue;
    ULONG  Digit;

    for ( ;; )
    {
        Digit = ( *p++ ) - 0x30;

        NewValue = Value << 4;

        if ( Digit > 9 )
        {
            Digit = ( Digit & 0x1F ) - 7;

            if ( ( Digit > 15 ) || ( Digit < 10 ) )
            {
                return Value;
            }
        }

        Value = NewValue | Digit;
    }
}


BOOL __inline __fastcall IsWhiteSpace( BYTE b )
{
    return(( b == ' ' ) || ( b == '\t' ) || ( b == '\r' ));
}


PCBYTE
__fastcall
GetNextIniValue(
    PCBYTE IniLine,
    PCBYTE EndOfFile,
    PBYTE  NameBuffer,
    ULONG  NameBufSize,
    PBYTE  ValueBuffer,
    ULONG  ValueBufSize
    )
{
    if (( IniLine != NULL ) && ( IniLine < EndOfFile ))
    {
        PBYTE pNameOut  = NameBuffer;
        PBYTE pNameEnd  = NameBuffer + NameBufSize - 1;
        PBYTE pValueOut = ValueBuffer;
        PBYTE pValueEnd = ValueBuffer + ValueBufSize - 1;

        BOOL BeforeEquals = TRUE;
        BOOL IgnoreSpaces = TRUE;
        BOOL InsideQuotes = FALSE;
        BOOL AfterComment = FALSE;

        PCBYTE p;

        for ( p = IniLine; ( p < EndOfFile ) && ( *p != '\n' ) && ( *p != 0 ); p++ )
        {
            if ( ! AfterComment )
            {
                if ( *p == '\"' )
                {         // start or end of quoted string
                    InsideQuotes = ( ! InsideQuotes );
                    IgnoreSpaces = ( ! InsideQuotes );
                    continue;
                }

                if ( ! InsideQuotes )
                {
                    if ( ( *p == '=' ) && ( BeforeEquals ) )
                    {
                        BeforeEquals = FALSE;
                        IgnoreSpaces = TRUE;
                        continue;
                    }

                    if ( *p == ';' )
                    {      // rest of line is comment
                        AfterComment = TRUE;
                        continue;
                    }
                }

                if ( ( ! IgnoreSpaces ) || ( ! IsWhiteSpace( *p )) )
                {
                    IgnoreSpaces = FALSE;

                    if ( BeforeEquals )
                    {
                        if ( pNameOut < pNameEnd )
                        {
                            *pNameOut++ = *p;
                        }
                    }
                    else
                    {
                        if ( pValueOut < pValueEnd )
                        {
                            *pValueOut++ = *p;
                        }
                    }
                }
            }
        }

        while ( ( pNameOut > NameBuffer ) && ( IsWhiteSpace( *( pNameOut - 1 ))) )
        {
            --pNameOut;
        }

        if ( pNameOut <= pNameEnd )
        {
            *pNameOut = 0;
        }

        while ( ( pValueOut > ValueBuffer ) && ( IsWhiteSpace( *( pValueOut - 1 ))) )
        {
            --pValueOut;
        }

        if ( pValueOut <= pValueEnd )
        {
            *pValueOut = 0;
        }

        return ( p < EndOfFile ) ? ( p + 1 ) : EndOfFile;
    }

    return NULL;
}


PCBYTE
__fastcall
MyFindIniSection(
    LPCSTR SectionName,
    PCBYTE IniFile,
    ULONG  IniFileSize
    )
{
    PCBYTE p = IniFile;
    ULONG  n = strlen( SectionName );
    PCBYTE z = IniFile + IniFileSize - ( n + 2 );

    while ( p < z )
    {
        p = ScanForChar( p, z - p, '[' );

        if ( p == NULL )
        {
            break;
        }

        if ( ( p == IniFile ) || ( *( p - 1 ) == '\n' ) )
        {
            ++p;

            if ( *( p + n ) == ']' )
            {
                if ( MySimpleCompareCaseInsensitive( p, (PCBYTE)SectionName, n ) == 0 )
                {
                    p += n + 1;

                    z = ScanForChar( p, z - p, '\n' );

                    if ( z != NULL )
                    {
                        p = z + 1;
                    }

                    return p;
                }
            }
        }

        ++p;
    }

    return NULL;
}


PCBYTE
__fastcall
MyFindIniValue(
    PCBYTE IniSection,
    PCBYTE IniFileOrSectionEnd,
    LPCSTR ValueName,
    PBYTE  ValueBuffer,
    ULONG  ValueBufSize
    )
{
    BYTE   FieldName[ 256 ];
    PCBYTE NextLine = IniSection;
    PCBYTE ThisLine;
    ULONG  ValueNameLength = strlen( ValueName );

    for ( ;; )
    {
        ThisLine = NextLine;            // start of this line

        NextLine = GetNextIniValue( ThisLine, IniFileOrSectionEnd, FieldName, sizeof( FieldName ), ValueBuffer, ValueBufSize );

        if ( NextLine == NULL )         // end of file
        {
            break;
        }

        if ( *FieldName == '[' )        // end of section (start of next)
        {
            break;
        }

        if ( MySimpleCompareCaseInsensitive( FieldName, (PCBYTE)ValueName, ValueNameLength ) == 0 )
        {
            return ThisLine;            // line containing found name/value
        }
    }

    return NULL;
}


PCBYTE
__fastcall
GetNextPsymSymbol(
    PCBYTE IniLine,
    PCBYTE EndOfFile,
    ULONG* SymbolRva,
    ULONG* SymbolOffset,
    PBYTE  NameBuffer,
    ULONG  NameBufSize
    )
{
    BYTE   RvaTextBuffer[ 32 ];
    PCBYTE NextLine = IniLine;
    ULONG  RvaValue;
    ULONG  Offset = 0;
    PBYTE  p;

    for ( ;; )
    {
        NextLine = GetNextIniValue(
                                  NextLine,
                                  EndOfFile,
                                  RvaTextBuffer,
                                  sizeof( RvaTextBuffer ),
                                  NameBuffer,
                                  NameBufSize
                                  );

        if ( ( NextLine == NULL ) || ( *RvaTextBuffer == '[' ) )
        {
            //
            //  End of file, or start of next section
            //

            return NULL;
        }

        if (( *RvaTextBuffer == 0 ) || ( *NameBuffer == 0 ))
        {
            //
            //  Blank line or not a valid Rva/Name pair.
            //

            continue;
        }

        //
        //  We want to ignore symbols starting with "PE\" because we have
        //  our own non-symbol rift generation code for PE RVA fields.
        //

        if ( ( *(DWORD*)( NameBuffer ) & 0x00FFFFFF ) == 0x005C4550 )
        {
            continue;
        }

        RvaValue = HexStrToUnsigned32( (LPCSTR) RvaTextBuffer );

        break;
    }

    //
    //  Look for "\$BB+123" in the symbol name to determine if this
    //  symbol is a BBT fragment.
    //

    for ( p = NameBuffer; *p != 0; p++ )
    {
        if ( ( *p == '\\' ) && ( *(UNALIGNED DWORD*)( p + 1 ) == '+BB$' ) )
        {
            *p = 0;             // terminate at parent symbol name

            p += 5;             // point at decimal offset

            while ( ( *p >= '0' ) && ( *p <= '9' ) )
            {
                Offset = ( Offset * 10 ) + ( *p++ - '0' );
            }

            break;
        }
    }

    *SymbolOffset = Offset;
    *SymbolRva    = RvaValue;

    return NextLine;
}


#ifdef DONTCOMPILE  // BUGBUG: this should be removed

void
__fastcall
SwapFragArrayEntries(
    FRAGMENT* One,
    FRAGMENT* Two
    )
{
    ULONG Temp1    = One->SymOffset;
    ULONG Temp2    = One->FragRva;

    One->SymOffset = Two->SymOffset;
    One->FragRva   = Two->FragRva;

    Two->SymOffset = Temp1;
    Two->FragRva   = Temp2;
}


VOID
__fastcall
QsortFragArray(
    FRAGMENT* LowerBound,
    FRAGMENT* UpperBound
    )
{
    FRAGMENT* Lower = LowerBound;
    FRAGMENT* Upper = UpperBound;
    FRAGMENT* Pivot = Lower + (( Upper - Lower ) / 2 );
    ULONG     Value = Pivot->SymOffset;

    do
    {
        while (( Lower <= Upper ) && ( Lower->SymOffset <= Value ))
        {
            ++Lower;
        }

        while (( Upper >= Lower ) && ( Upper->SymOffset >= Value ))
        {
            --Upper;
        }

        if ( Lower < Upper )
        {
            SwapFragArrayEntries( Lower++, Upper-- );
        }
    }
    while ( Lower <= Upper );

    if ( Lower < Pivot )
    {
        SwapFragArrayEntries( Lower, Pivot );
        Pivot = Lower;
    }
    else if ( Upper > Pivot )
    {
        SwapFragArrayEntries( Upper, Pivot );
        Pivot = Upper;
    }

    if ( LowerBound < ( Pivot - 1 ))
    {
        QsortFragArray( LowerBound, Pivot - 1 );
    }

    if (( Pivot + 1 ) < UpperBound )
    {
        QsortFragArray( Pivot + 1, UpperBound );
    }
}


#endif


#ifdef TESTCODE

VOID
DumpUnMatchedSymNodes(
    SYMTABLE* SymTable,
    LPCSTR    DumpFileName
    )
{
    CHAR TextBuffer[ 4000 ];

    HANDLE hFile = CreateFile(
                       DumpFileName,
                       GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        for ( unsigned Slot = 0; Slot < SYM_HASH_TABLE_COUNT; Slot++ )
        {
            SYMNODE* SymNode = SymTable->m_SymHashTable[ Slot ];

            while ( SymNode != NULL )
            {
                if ( SymNode->MatchCount == 0 )
                {
                    DWORD Actual = sprintf( TextBuffer, "%06X %s\r\n", SymNode->BaseFrag.FragRva, SymNode->NameId->Name );
                    WriteFile( hFile, TextBuffer, Actual, &Actual, NULL );
                }

                SymNode = SymNode->Next;
            }
        }

        CloseHandle( hFile );
    }
}

#endif /* TESTCODE */


extern "C"
BOOL
GetImageSymbolRiftInfoFromPsymFiles(
    IN HANDLE                  OldFileHandle,
    IN PUCHAR                  OldFileMapped,
    IN ULONG                   OldFileSize,
    IN PIMAGE_NT_HEADERS       OldFileNtHeader,
    IN LPCSTR                  OldFileSymPath,
    IN ULONG                   OldFileOriginalChecksum,
    IN ULONG                   OldFileOriginalTimeDate,
    IN ULONG                   OldFileIndex,
    IN HANDLE                  NewFileHandle,
    IN PUCHAR                  NewFileMapped,
    IN ULONG                   NewFileSize,
    IN PIMAGE_NT_HEADERS       NewFileNtHeader,
    IN LPCSTR                  NewFileSymPath,
    IN ULONG                   SymbolOptionFlags,
    IN HANDLE                  SubAllocator,
    IN PRIFT_TABLE             RiftTable,
    IN PPATCH_SYMLOAD_CALLBACK SymLoadCallback,
    IN PVOID                   SymLoadContext
    )
{
    HANDLE OldFilePsymHandle  = NULL;
    PCBYTE OldFilePsymMapped  = NULL;
    HANDLE NewFilePsymHandle  = NULL;
    PCBYTE NewFilePsymMapped  = NULL;
    PBYTE  ScratchBuffer      = NULL;
    BOOL   CompleteSuccess    = FALSE;

    UNREFERENCED_PARAMETER( OldFileHandle );
    UNREFERENCED_PARAMETER( OldFileMapped );
    UNREFERENCED_PARAMETER( OldFileSize );
    UNREFERENCED_PARAMETER( OldFileNtHeader );

    UNREFERENCED_PARAMETER( NewFileHandle );
    UNREFERENCED_PARAMETER( NewFileMapped );
    UNREFERENCED_PARAMETER( NewFileSize );

    UNREFERENCED_PARAMETER( SymbolOptionFlags );

    __try {

        PCBYTE OldPsymInfoSection;
        PCBYTE OldPsymSymSection;
        PCBYTE NewPsymInfoSection;
        PCBYTE NewPsymSymSection;
        ULONG  OldFilePsymSize;
        ULONG  NewFilePsymSize;
        ULONG  Value32;
        BOOL   Success;
        PCBYTE p;
        PCBYTE z;

        ScratchBuffer = (PBYTE) VirtualAlloc( NULL, TBUFSIZE, MEM_COMMIT, PAGE_READWRITE );

        if ( ScratchBuffer == NULL )
        {
            __leave;
        }

        Success = MyMapViewOfFileA(
                      OldFileSymPath,
                      &OldFilePsymSize,
                      &OldFilePsymHandle,
                      (PVOID*)&OldFilePsymMapped
                      );

        if ( ! Success )
        {
            __leave;
        }

        OldPsymInfoSection = MyFindIniSection( "PsymInfo", OldFilePsymMapped, 4096 );

        if ( OldPsymInfoSection == NULL )
        {
            __leave;
        }

        z = OldFilePsymMapped + OldFilePsymSize;

        MyFindIniValue( OldPsymInfoSection, z, "PsymVer", ScratchBuffer, TBUFSIZE );

        if ( ( ScratchBuffer[ 0 ] != '1' ) || ( ScratchBuffer[ 1 ] != '.' ) )
        {
            __leave;
        }

        MyFindIniValue( OldPsymInfoSection, z, "ExeTime", ScratchBuffer, TBUFSIZE );

        if ( ( Value32 = HexStrToUnsigned32( (LPCSTR) ScratchBuffer )) != 0 )
        {
            if ( Value32 != OldFileOriginalTimeDate )
            {
                __leave;
            }
        }

        OldPsymSymSection = MyFindIniSection( "Symbols", OldFilePsymMapped, OldFilePsymSize );

        if ( OldPsymSymSection == NULL )
        {
            __leave;
        }

        Success = MyMapViewOfFileA(
                      NewFileSymPath,
                      &NewFilePsymSize,
                      &NewFilePsymHandle,
                      (PVOID*)&NewFilePsymMapped
                      );

        if ( ! Success )
        {
            __leave;
        }

        NewPsymInfoSection = MyFindIniSection( "PsymInfo", NewFilePsymMapped, 4096 );

        if ( NewPsymInfoSection == NULL )
        {
            __leave;
        }

        z = NewFilePsymMapped + NewFilePsymSize;

        MyFindIniValue( NewPsymInfoSection, z, "PsymVer", ScratchBuffer, TBUFSIZE );

        if ( ( ScratchBuffer[ 0 ] != '1' ) || ( ScratchBuffer[ 1 ] != '.' ) )
        {
            __leave;
        }

        MyFindIniValue( NewPsymInfoSection, z, "ExeTime", ScratchBuffer, TBUFSIZE );

        if ( ( Value32 = HexStrToUnsigned32( (LPCSTR) ScratchBuffer )) != 0 )
        {
            if ( Value32 != NewFileNtHeader->FileHeader.TimeDateStamp )
            {
                __leave;
            }
        }

        NewPsymSymSection = MyFindIniSection( "Symbols", NewFilePsymMapped, NewFilePsymSize );

        if ( NewPsymSymSection == NULL )
        {
            __leave;
        }

        //
        //  Now we have both old and new psym files mapped and verified.
        //

        if ( SymLoadCallback )
        {
            Success = SymLoadCallback(
                         OldFileIndex + 1,         // 1 for first old file, etc
                         OldFileSymPath,
                         0x1001,                   // fake imagehlp SymType
                         OldFileOriginalChecksum,
                         OldFileOriginalTimeDate,
                         OldFileOriginalChecksum,
                         OldFileOriginalTimeDate,
                         SymLoadContext
                         );

            if ( ! Success )
            {
                __leave;
            }

            Success = SymLoadCallback(
                         0,                        // 0 for new file
                         NewFileSymPath,
                         0x1001,                   // fake imagehlp SymType
                         NewFileNtHeader->OptionalHeader.CheckSum,
                         NewFileNtHeader->FileHeader.TimeDateStamp,
                         NewFileNtHeader->OptionalHeader.CheckSum,
                         NewFileNtHeader->FileHeader.TimeDateStamp,
                         SymLoadContext
                         );

            if ( ! Success )
            {
                __leave;
            }
        }

        //
        //  Psym files approved by caller's SymLoadCallback routine.
        //

        NAMETABLE SymNameTable( SubAllocator );
        SYMTABLE  OldSymTable( &SymNameTable, SubAllocator );
        SYMTABLE  NewSymTable( &SymNameTable, SubAllocator );

        z = NewFilePsymMapped + NewFilePsymSize;
        p = NewPsymSymSection;

        for ( ;; )
        {
            ULONG SymRva;
            ULONG SymOffset;

            p = GetNextPsymSymbol( p, z, &SymRva, &SymOffset, ScratchBuffer, TBUFSIZE );

            if ( p == NULL )
            {
                break;
            }

            SYMNODE* SymNode = NewSymTable.InsertSym( (LPCSTR) ScratchBuffer );

            if ( SymNode )
            {
                if (( SymOffset == 0 ) && ( SymNode->BaseFrag.FragRva == 0 ))
                {
                    SymNode->BaseFrag.FragRva = SymRva;
                }
                else                    // fragment
                {
                    FRAGMENT* Frag = (FRAGMENT*) SubAllocate( NewSymTable.m_SubAllocator, sizeof( FRAGMENT ));

                    if ( Frag )
                    {
                        Frag->SymOffset = SymOffset;
                        Frag->FragRva   = SymRva;

                        FRAGMENT** Link = &SymNode->BaseFrag.Next;
                        FRAGMENT*  Next = *Link;

                        while (( Next ) && ( Next->SymOffset < SymOffset ))
                        {
                            Link = &Next->Next;
                            Next = *Link;
                        }

                        Frag->Next = Next;
                        *Link = Frag;
                    }
                }
            }
        }

        //
        //  Now load the old symbols the same way.
        //

        z = OldFilePsymMapped + OldFilePsymSize;
        p = OldPsymSymSection;

        for ( ;; )
        {
            ULONG SymRva;
            ULONG SymOffset;

            p = GetNextPsymSymbol( p, z, &SymRva, &SymOffset, ScratchBuffer, TBUFSIZE );

            if ( p == NULL )
            {
                break;
            }

            SYMNODE* SymNode = OldSymTable.InsertSym( (LPCSTR) ScratchBuffer );

            if ( SymNode )
            {
                if (( SymOffset == 0 ) && ( SymNode->BaseFrag.FragRva == 0 ))
                {
                    SymNode->BaseFrag.FragRva = SymRva;
                }
                else                    // fragment
                {
                    FRAGMENT* Frag = (FRAGMENT*) SubAllocate( OldSymTable.m_SubAllocator, sizeof( FRAGMENT ));

                    if ( Frag )
                    {
                        Frag->SymOffset = SymOffset;
                        Frag->FragRva   = SymRva;

                        FRAGMENT** Link = &SymNode->BaseFrag.Next;
                        FRAGMENT*  Next = *Link;

                        while (( Next ) && ( Next->SymOffset < SymOffset ))
                        {
                            Link = &Next->Next;
                            Next = *Link;
                        }

                        Frag->Next = Next;
                        *Link = Frag;
                    }
                }
            }
        }

        //
        //  Now walk old symbols, find matching new symbol, and create
        //  rift entries.
        //

        for ( unsigned Slot = 0; Slot < SYM_HASH_TABLE_COUNT; Slot++ )
        {
            SYMNODE* OldSymNode = OldSymTable.m_SymHashTable[ Slot ];

            while ( OldSymNode != NULL )
            {
                SYMNODE* NewSymNode = NewSymTable.LookupSym( OldSymNode->NameId );

                if ( NewSymNode != NULL )
                {
                    DEBUGCODE( NewSymNode->MatchCount++ );
                    DEBUGCODE( OldSymNode->MatchCount++ );

                    FRAGMENT* OldFrag = &OldSymNode->BaseFrag;
                    FRAGMENT* NewFrag = &NewSymNode->BaseFrag;

                    do
                    {
                        ULONG OldRva = OldFrag->FragRva;
                        ULONG NewRva = NewFrag->FragRva;

                        if ( OldFrag->SymOffset <= NewFrag->SymOffset )
                        {
                            OldRva += ( NewFrag->SymOffset - OldFrag->SymOffset );
                        }
                        else
                        {
                            NewRva += ( OldFrag->SymOffset - NewFrag->SymOffset );
                        }

                        AddRiftEntryToTable( RiftTable, OldRva, NewRva );

                        ULONG OldNextFragOffset = OldFrag->Next ? OldFrag->Next->SymOffset : 0xFFFFFFFF;
                        ULONG NewNextFragOffset = NewFrag->Next ? NewFrag->Next->SymOffset : 0xFFFFFFFF;

                        if ( OldNextFragOffset <= NewNextFragOffset )
                        {
                            OldFrag = OldFrag->Next;
                        }

                        if ( NewNextFragOffset <= OldNextFragOffset )
                        {
                            NewFrag = NewFrag->Next;
                        }

                        ASSERT((( OldFrag != NULL ) && ( NewFrag != NULL )) ||
                               (( OldFrag == NULL ) && ( NewFrag == NULL )));
                    }
                    while (( OldFrag ) && ( NewFrag ));

                }

                OldSymNode = OldSymNode->Next;
            }
        }

#ifdef TESTCODE

        DumpUnMatchedSymNodes( &OldSymTable, "UnmatchedOldSymbols.out" );
        DumpUnMatchedSymNodes( &NewSymTable, "UnmatchedNewSymbols.out" );

#endif // TESTCODE

        CompleteSuccess = TRUE;
    }

    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DEBUGCODE( printf( "\nException %08X processing psym files\n", GetExceptionCode() ));
    }

    if ( ScratchBuffer )
    {
        VirtualFree( ScratchBuffer, 0, MEM_RELEASE );
    }

    if ( OldFilePsymMapped )
    {
        UnmapViewOfFile( OldFilePsymMapped );
    }

    if ( NewFilePsymMapped )
    {
        UnmapViewOfFile( NewFilePsymMapped );
    }

    if ( OldFilePsymHandle )
    {
        CloseHandle( OldFilePsymHandle );
    }

    if ( NewFilePsymHandle )
    {
        CloseHandle( NewFilePsymHandle );
    }

    return CompleteSuccess;
}


#endif /* ! PATCH_APPLY_CODE_ONLY */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\sources.inc ===
TARGETPATH=..\..\bin

UMTYPE=windows

SOURCES=..\patchapi.c \
        ..\patchlzx.c \
        ..\pestuff.c  \
        ..\redblack.c \
        ..\psym.cpp   \
        ..\misc.c     \
        ..\md5.c

INCLUDES=..;..\..\lzx\encoder;..\..\lzx\decoder

#
#  Turn off precompiled headers for now since a bug in VC6 causes a "PchSym"
#  object to wind up in the binary's .data section.  Well we don't otherwise
#  have a .data section, so this stupid "PchSym" essentially costs a whole
#  page of address space.  Once this bug in VC6 is fixed, or if using another
#  compiler, can turn precompiled headers back on.
#

# PRECOMPILED_INCLUDE=..\precomp.h
# PRECOMPILED_PCH=precomp.pch
# PRECOMPILED_OBJ=precomp.obj

MSC_WARNING_LEVEL=/W4

MSC_OPTIMIZATION=/Oxs

NO_NTDLL=1

#
#  Even though we're building DLLs here, we don't want to use MSVCRT.DLL
#  because that file doesn't exist on standard Win95 systems.  Instead we'll
#  use LIBCMT.LIB to drag in the few things we need from the CRT such as
#  memmove and alloca support.
#

USE_LIBCMT=1

#
#  But, if we're building test or debug versions, which need printf support,
#  we'll use MSVCRT.DLL instead.
#

!IFDEF TESTCODE
C_DEFINES=$(C_DEFINES) -DTESTCODE=$(TESTCODE)
USE_LIBCMT=
USE_CRTDLL=1
!ENDIF

!IFDEF DEBUG
MSC_OPTIMIZATION=/Od
C_DEFINES=$(C_DEFINES) -DDEBUG=$(DEBUG)
USE_LIBCMT=
USE_CRTDLL=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\src_dll.inc ===
#
#  Must set TARGETNAME and DLLBASE before including this file
#

TARGETTYPE=DYNLINK

UMTYPE=windows

TARGETLIBS=$(BASEDIR)\public\sdk\lib\*\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           ..\..\lzx\encoder\obj\*\lzxpc.lib \
           ..\..\lzx\decoder\obj\*\lzxpd.lib

C_DEFINES=$(C_DEFINES) -DBUILDING_PATCHAPI_DLL=1

SOURCES=$(SOURCES) $(TARGETNAME).rc

#
#  This is a hacky way to get the PE file version stamp to be something
#  other than what NT's makefile.def tries to force it to be.  We're assuming
#  here that DLLBASE gets used in the linker command line AFTER makefile.def
#  inserts its own -version option.
#

DLLBASE=$(DLLBASE) -version:5.2

#
#  To avoid dragging in bloated c-runtime exception handling code, we build
#  our own scaled down version for x86 only.  We have to include our own
#  handler for x86 because we can't link with msvcrt.dll since it isn't
#  available on Win95 systems.  For non-x86 platforms, we can use ntdll.dll
#  directly, which also buys us the imports for intrinsic memory operations
#  without pulling in msvcrt.dll.
#

i386_SOURCES=..\i386\exsup.asm  \
             ..\i386\exsup3.asm

!if "$(TARGET_DIRECTORY)" != "i386"
!undef NO_NTDLL
USE_NTDLL=1
!endif

LINKER_FLAGS=$(LINKER_FLAGS) /OPT:NOWIN98 /PDBPATH:NONE

NTTARGETFILES=DELEXPFILE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\i386\cmacros.inc ===
comment $

	SCCSID = "@(#)cmacros.mas:1.12"

cmacros - assembly macros for interfacing to hhls

(C)Copyright Microsoft Corp. 1984-1997

$

;; Revision History
;;
;;	1.00	05/03/84	Initial Release
;;
;;	1.01	05/06/84	Greg Whitten
;;				Added defgrp and changed cMerge to Microsoft C
;;				Added copyright message and changed to 1.01
;;				Changes should have no affect on working programs
;;
;;	1.02	07/10/84	Steve Wood
;;				Added labelx macros
;;
;;	1.03	07/14/84	Greg Whitten
;;				Added defines for ?pu, ?adj, ?lblpu
;;				  (removes undefined errors)
;;				Changes should have no affect on working programs
;;
;;	1.04	07/18/84	Greg Whitten
;;				Added local control from PL/M or C conventions
;;				  except for cCall macro
;;
;;	1.05	08/06/84	Steve Wood
;;				Made ?PLM and ?WIN be the defaults
;;
;;	1.06	01/02/85	Steve Wood
;;				Changed createSeg and defgrp to automatically
;;				  define the ln_assumes macro and the lnoffset
;;				  and lnbase equates for each logical segment
;;				  name.
;;
;;	1.07	02/19/85	Walt Moore
;;				Added farptr macro for defining a far pointer
;;				to be used in a cCall.	Folded regptr into
;;				farptr.  Space compaction in macros.  Changed
;;				?pp to be smaller.  Moved ?ia out of ?al1 into
;;				?aloc.	Merged cProc and ?pd into one macro.
;;				Changed some %outs to use the error macro so
;;				an error would be generated.  Added makeframe
;;				and parmR to cProc.  Changed error to also put
;;                              the error message in the listing.
;;				Deleted the smashes macro.
;;
;;	1.08	03/18/85	Steve Wood
;;				Added NODATA support.
;;
;;	1.09	03/27/85	Steve Wood
;;				Added ?definitions
;;
;;	2.00	04/01/85	Steve Wood
;;				April fools
;;
;;	2.01	06/17/85	Steve Wood
;;				Changed NODATA to always generate POP DS
;;				  for return address patching
;;
;;	2.02	02/11/86	Steve Wood
;;				Added ATOMIC keyword to cProc macro
;;				Changed far epilog to use LEA SP,BP-2
;;				Changed error macro to ??error to avoid
;;				  conflict
;;
;;	2.03	03/06/86	Steve Wood
;;				Fixed bug with ATOMIC and locals in far proc
;;				Added DOS5 switch to disable INC/DEC BP
;;				  instructions in special far prologs/epilogs
;;
;;	2.04	08/07/86	Scott Randell
;;				Fixed bug with ATOMIC and ?TF
;;				  (was doing unnecessary MOV SP,BP)
;;				Added pcode profile ?PROFILE
;;
;;	2.05	08/12/86	Walt Moore
;;				Changed _TEXT alignment to word.
;;				Added/corrected some comments.
;;				Removed redundant init of ?pc in cProc
;;				Made ATOMIC require NODATA
;;				Moved definition of non-underscored 'C' label
;;				  from the cProc to the cBegin macro
;;				Minor clean-up of code
;;
;;	2.06	09/11/86	Walt Moore
;;				Added private stack checking
;;				Put local control for PL/M or C into cCall
;;
;;
;;	2.07	09/19/86	Steve Wood
;;				Added ?SMALL, ?MEDIUM, etc.  symbols
;;				Added forceframe keyword to cProc macro.
;;				Interpret ?TF for all epilogs.
;;
;;	3.xx.a	02/26/87	Walt Moore
;;				Massive rework.  Documentation coming.
;;
;;	3.xx.b	04/08/87	NeilK
;;				Added parmH, which is like parmW except
;;				that it reserves 4 bytes on frame.
;;
;;	3.xx.c	05/11/87	Walt Moore
;;				Added <> to ?ap so that arg <DataOFFSET foo>
;;				can be used.
;;
;;	3.01	07/03/87	Walt Moore
;;				parm_bytes_&procname is now generated for
;;				all cProcs, and is the number of bytes of
;;				parameters to the cProc.
;;
;;				NO_BP added as a keyword to cProc which
;;				causes all equates to be generated without
;;				reference to BP for the procedure.  All type
;;				info is still generated, but the user must
;;				supply any segment and base register.
;;				?NO_BP, if defined, makes this the default.
;;
;;				USE_BP can be specified on the cProc line
;;				to force the generation of BP in equates.
;;
;;				Moved definition of xxxxBASE.  The equ was to
;;				a forward reference.
;;
;;				Don't generate a warning for a nogen if only
;;				parameters are present.
;;
;;				Keywords for cProc, cBegin, cEnd, and registers
;;				are now allowed to be either all upper case or
;;				all lower case.
;;
;;				Only generate warnings on pass 2.
;;
;;	3.02	07/06/87	Walt Moore
;;				Boy did I screw up <nogen>  If the text is
;;				recognized as nogen, then process it as such,
;;				else ignore it and generate frame as needed.
;;
;;	3.03	07/14/87	Walt Moore
;;				Added <partial> keyword to the cBegin macro
;;				to only allocate locals and save registers.
;;				Used in conjunction with dispatching in the
;;				Winthorn engine and drivers.
;;
;;				Added cleanframe macro which will take the
;;				frame down, but not generate the RET statement.
;;				Used in conjunction with dispatching in the
;;				Winthorn engine and drivers.
;;
;;	3.04	07/16/87	Walt Moore
;;				globalD was generating off and seg name
;;				without word ptr override, giving them a
;;				dword attribute
;;
;;	3.05	07/17/87	Walt Moore
;;				.xcref cleanframe
;;
;;	3.06    07/24/87	Hans Spiller
;;				32 bit small model (?SMALL32):
;;				  new entry exit sequences using pseudoregs
;;				  mach independant register names (IAX, etc)
;;				  parmI/localI (int size variables)
;;				  mpush/mpop uses mach independant names
;;				  IPUSHF, IPOPF, IPUSHA,IPOPA,IIRET
;;				  
;;				case sensitivity bugfix. the compiler
;;				  generates "CODE", not "Code"
;;
;;				32 bit issues as yet undone:  allocation
;;			        macros for dealing with 32 bit mode far
;;				pointers, globalI, staticI, parmR, saving
;;				si,di vs. esi,edi,ebx
;;
;;	3.06a   09/29/87	Mark Roberts
;;				32 bit small model (?SMALL32):
;;				  fix a few bugs and add staticI
;;
;;	3.06b	07/20/87	Scott Randell
;;				Fix up for ?COW compatibility, added ?NOATOMIC
;;				to 3.xx version.
;;
;;	3.06c	04/29/88	Jim Schaad
;;				Put in ?DFDATA to force data segments even if
;;				?NODATA is set.
;;
;;	3.06d	05/02/88	Andy Padawer
;;				Bug fixes for 3.06b (cEnd), 3.06c (general).
;;
;;	3.06e	08/31/88	Andy Padawer
;;				use "if memS32" not "ifdef ?SMALL32".
;;
;;	3.06f   05/12/89	Mark Roberts
;;			  	fix staticI, globalDP and add globalI
;;
;;	3.06g   12/07/89	Mark Roberts
;;			  	add externI
;;
;;	3.06h	01/25/90	Jan de Rie
;;				add ?DFCODE to allow suppressing code segments
;;
;; Assembly macros for interfacing to C
;;
;;      User settable conditional assembly flags used within the cmacros
;;
;;	Memory model flags.  Set only one of the following.  memS is the
;;	default.  The symbols with ? are for defining from the command line
;;      and the memx symbols are numeric symbols that can be set in your source
;;      file prior to including this file.
;;
;;	    ?SMALL   memS - small model
;;	    ?MEDIUM  memM - medium model
;;	    ?LARGE   memL - large model
;;	    ?COMPACT memC - compact model
;;	    ?HUGE    memH - huge model
;;	    ?SMALL32 memS32 - 32 bit small model
;;
;;	?DF	Define flag.  If this flag is 0, then defines default segment
;;		and group definitions based on the compiler flag.  If this
;;              flag is 1, then does not define any segments or groups.
;;
;;	?DFDATA Define Data Flag.  If this flag is 0, then defines default
;;		data segment and group definitions based on compiler flag.
;;		If this flag is 1, then does not define any data segments
;;		or groups.
;;
;;	?DFCODE Define Code Flag.  If this flag is 0, then defines default
;;		code segments based on the compiler flag.  If this flag is 1,
;;		then does not define the code segments.  Inactive if
;;		?DF is 1.
;;
;;	?TF	Tight flag.  If this flag is 0, then use longer epilog
;;		sequence that safely cleans up a stack frame.  If this flag is
;;              1, then use more efficient epilog that assumes the stack is
;;		valid (SP)
;;
;;	?WIN	Windows flag.  Enables generation of special prolog/epilog
;;		for far procedures.  Default value is 1 (Windows).
;;
;;	?COW	Character Windows flag.  To be used in conjunction with ?WIN,
;;		If defined will not save DS for ?NODATA far prolog/epilog
;;		(CW does not modify the DS on the stack).
;;
;;	DOS5	If defined, then special far prolog/epilog seqeuences will not
;;		include the INC/DEC BP instructions.
;;
;;	?PLM	Calling convention flag.  If this flag is 0, then the
;;		calling convention used is that of C.  If this flag
;;		is 1, then the PL/M calling convention is used.
;;		The default value is 1.  The PL/M calling convention
;;		is used by pascal, fortran, basic, and cobol.
;;
;;		In the C calling convention, arguments are passed
;;              in reverse order; arg0 is the last pushed, argn is the
;;              first pushed.  also, it is the callers responsibility
;;              to remove the arguments from the stack upon a return
;;              from a call.
;;
;;		In the PL/M calling comvention, arguments are passed
;;              as encountered; arg0 is the first pushed, argn is the
;;              last pushed.  also, it is the called procedure's
;;              responsibility to remove parameters from the stack
;;		before returning (using the RET n instruction)
;;
;;	?NODATA If defined, then no data segment or DGROUP is defined and
;;              the special prolog/epilog sequences will not contain the
;;		code needed to setup DS.
;;
;;	?CHKSTK If defined, then prolog sequences for cProcs with local
;;		parameters will call the CHKSTK procedure to allocate
;;              the stack space.
;;
;;	?CHKSTKPROC	If defined, then this macro will be invoked to
;;                      perform the stack checking, otherwise the
;;                      standard stack checking procedure will be
;;			performed.  ?CHKSTKPROC must be declared
;;                      before the cmacros are included in the source
;;			else the standard chkstk routine will be declared
;;                      as an external symbol.
;;
;;			On entry to the user's stack checking procedure,
;;                      the frame has been setup except for allocating
;;                      local variable space and saving autosave registers.
;;
;;			The user supplied macro is passed as an argument
;;                      the number of byte of stack space requested.
;;
;;	?PROFILE  If defined then all far cBegin entries will have StartNMeas,
;;		  and all cEnd will have StopNMeas calls, StartNMeas and
;;		  StopNMeas will be defined as externfp
;;
;;	?NOPARMR  If defined, then the "parmR"	 macro	will not be defined.
;;
;;	?NOGLOBAL If defined, then the "globalx" macros will not be defined.
;;
;;	?NOSTATIC If defined, then the "staticx" macros will not be defined.
;;
;;	?NOEXTERN If defined, then the "externx" macros will not be defined.
;;
;;	?NOLABEL  If defined, then the "labelx"  macros will not be defined.
;;
;;	?NODEF	  If defined, then the "defx"	 macros will not be defined.
;;
;;	?NOPTR	  If defined, then "farptr & regptr"	will not be defined.
;;
;;	?QUIET	  If defined, then only error messages will be issued to
;;		  the console.	If undefined, then certain cmacro text will
;;		  be generated to the console.
;;
;;	?NOATOMIC If defined, then ATOMIC will be ignored (for giving real
;;		  frames to all procedures (and profiling).
;;
;;	?NO_BP	  If defined, then equates generated for parms and locals
;;		  will not explicitly reference BP.
;;	IAX, ICX, IDX, IBX, ISP, IBP, ISI, IDI
;;		  these pseudo registers expand to either ax..., or eax...
;;		  depending upon 32bit mode being enabled.  they should be
;;		  used whenever a pointer or integer is being used in order
;;		  to make source code machine independant



.xcref					;;Get rid of a lot of symbols


;	??_out	- output given message to the console unless ?QUIET has
;	been specified.
;
;	usage:
;		??_out	<t>
;
;	where:
;		<t> is the message to output

.xcref	??_out
??_out macro t
  ifndef ?QUIET
    %out t
  endif
endm



;	outif - output msg if name is non-zero.  if name is undefined,
;	set name = 0, else set name to the default value.
;
;	usage:
;		outif	name,defval,onmsg,offmsg
;	where:
;		name	name of symbol
;		defval	default value to give symbol if not defined
;			if blank, then 0 will be used
;		onmsg	text to display if symbol is non-zero
;		offmsg	test to be displayed if symbol is zero


outif macro name,defval,onmsg,offmsg
  ifndef name
    ifb <defval>
      name=0
    else
      name=defval
    endif
  endif
  if name
    name=1
    ifnb <onmsg>
      ??_out <! onmsg>
    endif
  else
    ifnb <offmsg>
      ??_out <! offmsg>
    endif
  endif
endm



;	??error - output msg and generate an assembly time error
;		  on regardess of assembler pass
;	usage:
;		??error <t>
;	where:
;		t	is the text to be output


.xcref	??error
??error macro	msg
  %out e r r o r ----- msg		;;to console
  .err e r r o r ----- msg		;;forced error by assembler
endm


;	??error2 - output msg and generate an assembly time error
;		   on pass 2 only
;	usage:
;		??error2 <t>
;	where:
;		t	is the text to be output


.xcref	??error2
??error2 macro	 msg
  if2
  %out e r r o r ----- msg		;;to console
  .err e r r o r ----- msg		;;forced error by assembler
  endif
endm


.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized,memS32,sizeI,wordI

;if1					;;Only on pass 1
  ASMpass=1
  ifdef ?SMALL				;;inform user what is going on
    memS=1
  endif
  ifdef ?MEDIUM
    memM=1
  endif
  ifdef ?COMPACT
    memC=1
  endif
  ifdef ?LARGE
    memL=1
  endif
  ifdef ?HUGE
    memH=1
  endif
  ifdef ?SMALL32
    memS32=1
  endif
  ifdef ?FLAT32
    memF32=1
  endif

  ??_out  <cMacros Version 3.06h - 01/25/90>
  ??_out  <Copyright (C) Microsoft Corp. 1984-1990.  All rights reserved.>
  outif   memS,0,<Small Model>
  outif   memM,0,<Medium model>
  outif   memL,0,<Large Model>
  outif   memC,0,<Compact Model>
  outif   memH,0,<Huge Model>
  outif	  memS32,0,<32 Bit Small Model>
  outif   memF32,0,<32 Bit Flat Model>

  memMOD= memS + memM + memL + memC + memH + memS32
  if memMOD ne 1
    if memMOD eq 0
      memS = 1				; assume small model
      outif   memS,0,<Small model>
    else
      ??error	<must have only 1 memory model selected>
    endif
  endif

  sizec=  memM + memL + memH		; large code
  sized=  memL + memC + (memH*2)	; large data (2 if huge)
  ;; note that memS32 is used generaly to indicate 32 bitness.  I
  ;; doubt very much whether anyone will ever do other models in
  ;; 32 bit code...
  if memS32
    sizeI = 4				; size of a push
    wordI equ <dword>
    asmdI equ <dd>
  else
    sizeI = 2
    wordI equ <word>
    asmdI equ <dw>
  endif

  outif ?DF,0,<No segments or groups will be defined>
  outif ?DFDATA,0,<No data segments will be defined>
  outif ?DFCODE,0,<No code segments will be defined>
  outif ?TF,0,<Epilog sequences assume valid SP>
  outif ?WIN,1,<Windows support>
  outif	?COW,0,<Characters Windows support>
  outif ?PLM,1,<PL/M calling convention>
  outif	?NOATOMIC,0,<ATOMIC disabled>
  outif ?NODATA,0,<NODATA module>

  ife ?NODATA
    ?nodata1=0
  else
    ?nodata1=1
  endif

  ifndef ?CHKSTK
    ?chkstk1=0
  else
    ?chkstk1=1
    ifdef ?CHKSTKPROC
      ??_out <! Private stack checking enabled>
    else
      ??_out <! Stack checking enabled>
    endif
  endif

  ifndef DOS5
    ?DOS5=0
  else
    ?DOS5=1
    ??_out <! DOS5 module>
  endif

  ifdef ?PROFILE
    ??_out <! Native profiling enabled>
  endif

  ifndef ?NO_BP
    ?no_bp1=0
  else
    ?no_bp1=1
    ??_out <! NO_BP is default>
  endif
;else
  ASMpass=2
;endif

;; define pseudo registers and instructions for 386/8086 independance
if memS32
  .386
  IAX equ <eax>
  ICX equ <ecx>
  IDX equ <edx>
  IBX equ <ebx>
  ISP equ <esp>
  IBP equ <ebp>
  ISI equ <esi>
  IDI equ <edi>
  IPUSHF equ pushfd
  IPOPF equ popfd
  IPUSHA equ pushad
  IPOPA equ popad
  IIRET equ iretd
else
  IAX equ <ax>
  ICX equ <cx>
  IDX equ <dx>
  IBX equ <bx>
  ISP equ <sp>
  IBP equ <bp>
  ISI equ <si>
  IDI equ <di>
  IPUSHF equ pushf
  IPOPF equ popf
;  IPUSHA equ pusha
;  IPOPA equ popa
  IIRET equ iret
endif

;;	Initialize all symbols used in the macros.  Theses symbols will not be
;;      included in any cross reference listing.

	.xcref	?n,?ax,?ah,?al,?bx,?bh
	.xcref	?bl,?cx,?ch,?cl,?dx,?dh
	.xcref	?dl,?si,?di,?es,?ds,?bp
	.xcref	?sp,?ss,?cs
	.xcref	?n,?AX,?AH,?AL,?BX,?BH
	.xcref	?BL,?CX,?CH,?CL,?DX,?DH
	.xcref	?DL,?SI,?DI,?ES,?DS,?BP
	.xcref	?SP,?SS,?CS
	.xcref  ?EAX,?EBX,?ECX,?EDX,?ESI,?EDI,?ESP,?EBP
	.xcref  ?eax,?ebx,?ecx,?edx,?esi,?edi,?esp,?ebp
	.xcref  ?IAX,?IBX,?ICX,?IDX,?ISI,?IDI,?ISP,?IBP

	.xcref	?rsl,?cpd,?argl,?argc,?ba
	.xcref	?acb,???,?po
	.xcref	?pas,?pc

	.xcref	uconcat,mpush,mpop
	.xcref	?ri,?pp,?pp1,?al1
	.xcref	?ad,?ap,?atal,?dd,?dd1,?dd2
	.xcref	?pg,?pg1,?aloc,?cs1,?cs2
	.xcref	?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
	.xcref	?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
	.xcref	?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
	.xcref	defgrp,addseg,createSeg
	.xcref	save,outif,errnz,errn$,errnz1
	.xcref	?PLMPrevParm,?gcc
	.xcref	?cCall1,?pcc,?no_bp1,?no_bp2
	.xcref	?cbe,?pcbe



;;      conditionals set by the macros
;;
;;	?pc	Procedure class.  If this is set to 1, then the procedure
;;              is a far procedure, else it is a near procedure.
;;
;;	?ia	Interface adjustment count for far procedures.	The
;;              interface adjustment defines the number of bytes of
;;		storage allocated between BP and the first frame variable
;;              allocated on the stack.
;;
;;		Normally zero, it will be adjusted for both far windows
;;              procedures and by register parameters.
;;
;;	?cpd	Current procedure defined.  This is set to a non-zero
;;		value if a procedure is being defined (i.e a cProc has
;;		been encountered, and cBegin has not).
;;
;;	?ba	Begin active.  This is set to a non-zero value if a
;;		cBegin is active (i.e. a cBegin has been encountered,
;;		and cEnd has not).
;;
;;	?wfp	Windows far procedure.	Set if a windows far procedure
;;
;;	?pcc	procedure calling conventing.  Calling convention for
;;		this procedure.  May be different than the default set
;;		via ?PLM
;;
;;
;;	Other variables that are defined once so that the .xcref command
;;      doesn't get too upset if they show up missing!

?rsl    =       0                       ;;0 = no register to save
?cpd    =       0                       ;;<> 0 if in a procedure definition
?argl   =       0                       ;;length of arguments pushed on stack
?argc   =       0                       ;;# of arguments so far
?ba     =       0                       ;;<>0 if in a procedure (xbegin)
?acb    =       0                       ;;number of arguments to a call
???     =       0                       ;;byte count of local storage
?po     =       0                       ;;byte count of parameters
?pas    =       0                       ;;autosave value for procedure
?pc     =       0                       ;;class of a procedure (near/far)
?ia     =       0                       ;;no adjustment
?pu     =       0                       ;;public flag for some macros
?adj    =       0                       ;;initial define for .xcref
?rp     =       0                       ;;count of register parameters
?uf     =       0                       ;;user's frame code specified
?nd	=	0			;;NODATA keyword specified
?nx	=	0			;;ATOMIC keyword specified
?wfp    =       0                       ;;window far procedure
?ff     =       0                       ;;forceframe keyword specified
?dd2	=	0			;;used for globalx and staticx
?cCall1 =	0			;;used for cCalls
?pcc	=	?PLM			;;procedure calling convention
?PLMPrevParm =	0			;;Used in parameter processing
?no_bp2 =	?no_bp1 		;;BP / No BP flag
?cbe	=	0			;;cbegin/cEnd keyword flag

	.xcref	?casen
if1					;;only define ?casen on pass 1
?casen	=	0			;;case sensitive assembly if <> 0
endif



?n      =       0000000000000000b       ;;register none
?ax	=	0000000000000011b	;;register ax
?ah	=	0000000000000001b	;;register ah
?al	=	0000000000000010b	;;register al
?bx	=	0000000000001100b	;;register bx
?bh	=	0000000000000100b	;;register bh
?bl	=	0000000000001000b	;;register bl
?cx	=	0000000000110000b	;;register cx
?ch	=	0000000000010000b	;;register ch
?cl	=	0000000000100000b	;;register cl
?dx	=	0000000011000000b	;;register dx
?dh	=	0000000001000000b	;;register dh
?dl	=	0000000010000000b	;;register dl
?si	=	0000000100000000b	;;register si
?di	=	0000001000000000b	;;register di
?es	=	0000010000000000b	;;register es
?ds	=	0000100000000000b	;;register ds
?bp	=	0001000000000000b	;;register bp
?sp	=	0010000000000000b	;;register sp
?ss	=	0100000000000000b	;;register ss
?cs	=	1000000000000000b	;;register cs
					;;Incase we're case sensitive
?AX	=	0000000000000011b	;;register ax
?AH	=	0000000000000001b	;;register ah
?AL	=	0000000000000010b	;;register al
?BX	=	0000000000001100b	;;register bx
?BH	=	0000000000000100b	;;register bh
?BL	=	0000000000001000b	;;register bl
?CX	=	0000000000110000b	;;register cx
?CH	=	0000000000010000b	;;register ch
?CL	=	0000000000100000b	;;register cl
?DX	=	0000000011000000b	;;register dx
?DH	=	0000000001000000b	;;register dh
?DL	=	0000000010000000b	;;register dl
?SI	=	0000000100000000b	;;register si
?DI	=	0000001000000000b	;;register di
?ES	=	0000010000000000b	;;register es
?DS	=	0000100000000000b	;;register ds
?BP	=	0001000000000000b	;;register bp
?SP	=	0010000000000000b	;;register sp
?SS	=	0100000000000000b	;;register ss
?CS	=	1000000000000000b	;;register cs

?EAX	=	0000000000000011b	;;register ax
?EBX	=	0000000000001100b	;;register bx
?ECX	=	0000000000110000b	;;register cx
?EDX	=	0000000011000000b	;;register dx
?ESI	=	0000000100000000b	;;register si
?EDI	=	0000001000000000b	;;register di
?EBP	=	0001000000000000b	;;register bp
?ESP	=	0010000000000000b	;;register sp

?eax	=	0000000000000011b	;;register ax
?ebx	=	0000000000001100b	;;register bx
?ecx	=	0000000000110000b	;;register cx
?edx	=	0000000011000000b	;;register dx
?esi	=	0000000100000000b	;;register si
?edi	=	0000001000000000b	;;register di
?ebp	=	0001000000000000b	;;register bp
?esp	=	0010000000000000b	;;register sp

?IAX	=	0000000000000011b	;;register ax
?IBX	=	0000000000001100b	;;register bx
?ICX	=	0000000000110000b	;;register cx
?IDX	=	0000000011000000b	;;register dx
?ISI	=	0000000100000000b	;;register si
?IDI	=	0000001000000000b	;;register di
?IBP	=	0001000000000000b	;;register bp
?ISP	=	0010000000000000b	;;register sp

        .cref



;;      uconcat - unconditionally generate a statement from a field
;;      of given parameters
;;
;;      usage:
;;		uconcat  a,b,c,d,e,f,g
;;
;;      where:
;;              a,b   are concatenated for field 1
;;              c,d   are concatenated for field 2
;;		e,f,g are concatenated for field 3

uconcat macro a,b,c,d,e,f,g
  a&b c&d e&f&g
endm



;;      mpush pushes multiple registers onto the stack according to
;;      a register specification.
;;
;;      format:
;;              mpush   r
;;
;;      where:
;;              r       is a numeric expression returned from ?ri
;;                      or any other valid register expression

mpush macro r
  irp x,<IAX,IBX,ICX,IDX,ISI,IDI,es,ds,IBP,ISP,ss,cs>
    if (r and ?&&x)
      push x								      ;@
    endif
  endm
endm



;;      mpop pops multiple registers from the stack according to
;;      a register specification.
;;
;;      format:
;;              mpop    r
;;
;;      where:
;;              r       is a numeric expression returned from ?ri
;;                      or any other valid register expression

mpop macro r
  irp x,<cs,ss,ISP,IBP,ds,es,IDI,ISI,IDX,ICX,IBX,IAX>
    if (r and ?&&x)
      pop x								      ;@
    endif
  endm
endm


;;      save - flag that the indicated registers are to be saved/restored
;;
;;	A flag is created which indicates which registers are to be saved
;;	when the cCall macro is invoked, and then restored after the call.
;;
;;      usage:
;;              save    <r>
;;
;;      where  r  is the list of registers to save, which may be:
;;
;;		register     saves
;;		   AX	      AX
;;		   AH	      AX
;;		   AL	      AX
;;		   BX	      BX
;;		   BH	      BX
;;		   BL	      BX
;;		   CX	      CX
;;		   CH	      CX
;;		   CL	      CX
;;		   DX	      DX
;;		   DH	      DX
;;		   DL	      DX
;;		   SI	      SI
;;		   DI	      DI
;;		   ES	      ES
;;		   DS	      DS
;;		   BP	      BP
;;
;;		  none	    nothing
;;
;;      the macro generates a value for the variable ?rsl

save macro r
  ?rsl=0				;;initialize save list
  ?ri ?rsl,<r>				;;generate magic number
endm



;;      ?ri - or register indexes to variable
;;
;;      ?ri is a macro that examines the passed argument list and computes
;;      a register index variable.
;;
;;	The values ORed with the variable are:
;;
;;              ?n       equ     0000000000000000b;
;;		?AX	 equ	 0000000000000011b;
;;		?AH	 equ	 0000000000000001b;
;;		?AL	 equ	 0000000000000010b;
;;		?BX	 equ	 0000000000001100b;
;;		?BH	 equ	 0000000000000100b;
;;		?BL	 equ	 0000000000001000b;
;;		?CX	 equ	 0000000000110000b;
;;		?CH	 equ	 0000000000010000b;
;;		?CL	 equ	 0000000000100000b;
;;		?DX	 equ	 0000000011000000b;
;;		?DH	 equ	 0000000001000000b;
;;		?DL	 equ	 0000000010000000b;
;;		?SI	 equ	 0000000100000000b;
;;		?DI	 equ	 0000001000000000b;
;;		?ES	 equ	 0000010000000000b;
;;		?DS	 equ	 0000100000000000b;
;;		?BP	 equ	 0001000000000000b;
;;		?SP	 equ	 0010000000000000b;
;;		?SS	 equ	 0100000000000000b;
;;		?CS	 equ	 1000000000000000b;
;;      usage:
;;		?ri n,<rl>
;s mach independant names;      where:
;;              n       is the variable to contain the new index value
;;		r	is the register list

?ri macro n,r
  irp x,<r>
    ifdef ?&&x				;;if defined, then add to list
      n=n or ?&&x
    else
      ??error2 <unknown register x>
      .err
    endif
  endm
endm



;;      parmx - generate reference to parameter(s) on the stack
;;
;;	An equate is generated for addressing a paramter(s)
;;      on the stack for the current procedural frame.
;;
;;	An error message is generated if there isn't a current frame.
;;
;;      usage:
;;              parmX   n
;;      where:
;;              X       is the type of the argument(s)  B=byte, W=word, D=dword
;;			I = machine independant int size
;;              n       is the name(s) to be given the parameter(s).
;;
;;	Bytes are considered to be two bytes long for alignment.
;;
;;	The parmd form of the macro generates three equates:
;;
;;              name       -    for accessing the parameter as a double word
;;              off_name   -    for accessing the offset  (lsw) of the parameter
;;              seg_name   -    for accessing the segment (msw) of the parameter

.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP,parmH,parmI
.cref

parmB macro n
  ?pp <n>,<byte>,sizeI,1
endm

parmW macro n
  ?pp <n>,<word>,sizeI,2
endm

parmI macro n
  ?pp <n>,wordI,sizeI,sizeI
endm

parmD macro n
  ife ?pcc				;;if to assemble for C
    irp x,<n>
      ?pp <&&x>,<dword>,0,4
      ?pp <off_&&x>,<word>,2,2
      ?pp <seg_&&x>,<word>,2,2
    endm
  else					;;if to assemble for PL/M
    irp x,<n>
      ?pp <seg_&&x>,<word>,2,2
      ?pp <off_&&x>,<word>,2,2
      ?pp <&&x>,<dword>,0,4
    endm
  endif
endm

parmH macro n
  ?pp <n>,<word>,4,2
endm

parmQ macro n
  ?pp <n>,<qword>,8,8
endm

parmT macro n
  ?pp <n>,<tbyte>,10,10
endm

if sizec
  parmCP macro n
    parmD <n>
  endm
else
  parmCP macro n
    parmW <n>
  endm
endif

if sized
  parmDP macro n
    parmD <n>
  endm
else
  parmDP macro n
    parmI <n>
  endm
endif



;;      ?pp is the generalized parameter definition macro
;;
;;      usage:
;;              ?pp m,t,l,s
;;
;;      where:
;;              n       is the name(s) of the parameters
;;              t       is the type (word, dword)
;;              l       is the length to update parameter byte count by
;;              s       is the internal typing size


?pp macro n,t,l,s			;;process parameter
  if ?cpd				;;must be in a procedure definition
    .xcref
    irp x,<n>
      .xcref ?t&&x			;;don't want this in xref
      ?t&&x=s				;;save size info
      ife ?pcc				;;if C calling convention
	?pp1 x,<t>,,,%(?po+?adj)
	?po=?po+l			;;update parameter offset
      else				;;else assemble for PL/M
	?PLMPrevParm=?PLMPrevParm+1	;;Show next parameter
	?po=?po+l			;;update parameter offset
	?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
      endif
    endm
    .cref
  else
    ??error2 <parm(s) "&n" declared outside proc def>
  endif
endm



;;	?pp1 is the macro that generates the text equate for the
;;	parameter.  Two options exist, one for the C calling
;;      convention where the last parameter was the first pushed onto
;;	the stack ('C' convention), and one for the PL/M calling
;;      convention where the first parameter was the first
;;      pushed (also the same as ms-pascal).
;;
;;	The text generated will be of one of two forms:
;;
;;		name equ (type ptr [bp+(adj+offset)]) for C
;;           or
;;		name equ (type ptr [bp+adj+?po-offset]) for PL/M
;;
;;
;;	For C, since parameters are pushed first last, the offset
;;      plus the adjust will point to the correct parameter.
;;
;;	For PL/M, since parameters are pushed first first, the offset
;;	of a parameter is much more complicated.  A known portion of
;;      the offset can be computed when the text equate is generated.
;;
;;	What is known is the number of garbage bytes between BP and
;;      the nearest parameter (in this case the last parameter), and
;;      also how many bytes of parameters have preceeded this parameter.
;;
;;	What is unknown is how many total bytes of parameters there will
;;      be, which affects all the generated text equates since the offset
;;      from bp must be determined at some point.
;;
;;	Well, the offset from BP can be computed with one variable if
;;      the following is remembered:
;;
;;          the offset of any parameter from the first parameter is always
;;          the current parameter offset (?po).
;;
;;	With this in mind, you just have to figure out where the first
;;      parameter is, which is:
;;
;;              bp + garbage adjustment + distance to first parameter
;;         or
;;              bp + ?adj + ?po
;;
;;	This implies that any parameter can be defined as:
;;
;;              bp + ?adj + ?po -%?po
;;
;;	Make any sense?
;;
;;	For PL/M, a chain of self-purging macros will be generated
;;	which will pass the evaluated ?po to any previous incarnation
;;	of the macro.  This will allow the text equate to be generated
;;	with the actual offset instead of the symbolic ?po.
;;
;;
;;      usage:
;;		?pp1	n,t,o,a,b,cpc,ppc
;;
;;      where:
;;              n    is the name to be given the equate
;;              t    is the type (byte, word, dword)
;;              o    is the offset from the first parameter
;;              a    is the adjustment
;;              b    is the adjustment plus the offset from the first parameter
;;		cpc  is the number of parameters so far
;;		ppc  is cpc - 1


?pp1 macro n,t,o,a,b,cpc,ppc
  ife ?pcc				;;if to generate for C
    if ?no_bp2
      n equ (t ptr [+b])
    else
      n equ (t ptr [IBP][+b])
    endif
  else					;;else generate for PL/M
    .xcref
    .xcref ?PLMParm&cpc
    .cref
    if ?no_bp2
      ?PLMParm&cpc &macro po
	uconcat <n>,,<equ>,,<(t ptr [+>,%(a+po-o),<])>
	?PLMParm&ppc po
	purge ?PLMParm&cpc
      &endm
    else
      ?PLMParm&cpc &macro po
	uconcat <n>,,<equ>,,<(t ptr [IBP][+>,%(a+po-o),<])>
	?PLMParm&ppc po
	purge ?PLMParm&cpc
      &endm
    endif
  endif
endm



;;	parmR - register parameter
;;
;;	parmR is the macro used for generating register parameters.
;;	The space allocated for the register parameters will be
;;      the ?ia (interface adjust) area which is between the  old
;;	BP and the first parameter.  Normally this is empty (?ia=0),
;;      or has the saved ds for a windows far procedure.
;;
;;	Byte and dword register parameters will be allowed.
;;
;;      usage:
;;		parmR	n,r,r2
;;      where:
;;              n       is the name of the parameter
;;              r       is the register it is in
;;              r2      is the offset register if a dword


ifndef ?NOPARMR
  .xcref
  .xcref ?pr,parmR
  .cref

  parmR macro n,r,r2
    ?pr n,r,r2,%?rp,%(?ia+2)
  endm

  ;;	?pr - register parameter
  ;;
  ;;	?pr is the actual macro for generating the equates for
  ;;	register parameters.
  ;;
  ;;	usage:
  ;;		parmR	n,r,r2,i,o
  ;;	where:
  ;;		n	is the name of the parameter
  ;;		r	is the register it is in
  ;;		r2	is the offset register if a dword
  ;;		i	is the index of the ?rp to generate
  ;;		o	is the offset from bp where the parm will be

  ?pr macro n,r,r2,i,o
    .xcref
    ifnb <r2>				;;if a dword parameter
      parmR seg_&n,r			;;define segment equate
      parmR off_&n,r2			;;define offset  equate
      if ?no_bp2
	n equ (dword ptr [-o-2])	;;define dword equate
      else
	n equ (dword ptr [bp][-o-2])	;;define dword equate
      endif
      .xcref ?t&n
      ?t&n=4				;;show a dword to cmacros
    else
      .xcref ?rp&i
      ?rp&i=0				;;show no register(s)
      ifdef ?&r 			;;define register if valid
	?rp&i=?&r
      endif

      if ??? or (?cpd eq 0) or (?rp&i eq 0)
	??error2 <invalid parmR encountered: &n,&r>
	exitm
      endif

      if ?no_bp2
	n equ (word ptr [-o])		;;assume a word register
      else
	n equ (word ptr [bp][-o])	;;assume a word register
      endif
      .xcref ?t&n
      ?t&n=2				;;show a word to cmacros
      irp x,<bh,ch,dh,bl,cl,dl,ah,al>
	if ?&&x eq ?&r			;;if really a byte register
	  if ?no_bp2
	    n equ (byte ptr [-o])	;;  then make it a byte
	  else
	    n equ (byte ptr [bp][-o])	;;  then make it a byte
	  endif
	  ?t&n=1			;;show a byte to cmacros
	  exitm
	endif
      endm
      ?ia=?ia+2 			;;show this guy is out there
      ?rp=?rp+1 			;;show one more register parameter
    endif
    .cref
  endm
endif



;;      localx - generate reference to a local variable on the stack
;;
;;	An equate is generated for addressing a local variable
;;      on the stack for the current procedural frame.
;;
;;      usage:
;;              localx    n
;;      where:
;;              x       is the type b=byte, w=word, d=dword, v=variable size
;;              n       is the name(s) to be given the variable(s).
;;
;;	Bytes are considered to be two bytes long for alignment reasons
;;
;;	The locald form of the macro generates three equates:
;;
;;              name       -    for accessing the variable as a double word
;;              off_name   -    for accessing the offset  (lsw) of the variable
;;              seg_name   -    for accessing the segment (msw) of the variable


.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV,localI
.cref

localB macro n
  ?aloc <n>,<byte ptr>,1,1,0		;; no alignment
endm

localW macro n
  ?aloc <n>,<word ptr>,2,2,1		;; word aligned
endm

localI macro n
  ?aloc <n>,&wordI&< ptr>,sizeI,sizeI,1	;; dword aligned
endm

localD macro n
  irp x,<n>
    ?aloc <seg_&&x>,<word ptr>,2,2,1	;; word aligned
    ?aloc <off_&&x>,<word ptr>,2,2,1	;; word aligned
    ?aloc <&&x>,<dword ptr>,0,4,1	;; word aligned
  endm
endm

localQ macro n
  ?aloc <n>,<qword ptr>,8,8,1		;; word aligned
endm

localT macro n
  ?aloc <n>,<tbyte ptr>,10,10,1 	;; word aligned
endm

if sizec
  localCP macro n
    localD <n>
  endm
else
  localCP macro n
    localW <n>
  endm
endif

if sized
  localDP macro n
    localD <n>
  endm
else
  localDP macro n
    localI <n>
  endm
endif

localV macro n,a
  ?aloc <n>,,%(a),0,1			;; word aligned
endm


;;      ?aloc is the macro that actually allocates local storage.
;;      it is only invoked by the localx macros.
;;
;;      usage:
;;              ?aloc  n,t,l,s,a
;;      where:
;;              n      is a list of names of local variable of the
;;                      given type.
;;              t       is the text string for the given variable
;;                      and is one of:
;;                          word  ptr
;;                          dword ptr
;;                          byte  ptr
;;                      or alternatively left blank for variable size
;;                      allocations (no implicit type).
;;              l       is the size of the variable in bytes
;;              s       is the internal type flag (size), and is one of:
;;                              word     - 2
;;                              dword    - 4
;;                              byte     - 1
;;                              variable - 0
;;              a       is a flag indicating that word alignment is to be
;;                      forced for this type of item.
;;
;;	NOTE:	It is assumed that the stack is already aligned on a word
;;		boundary when the cProc is invoked.  The macros will guarantee
;;		to allocate an even number of bytes on the stack to maintain
;;              word alignment.


?aloc macro n,t,l,s,a
  if ?cpd				;;must be in a proc def
    .xcref
    irp x,<n>				;;generate symbol equates
      ???=???+l 			;;update length of locals
      if a				;;if align, then force word alignment
	if memS32 and l GT 2
	  ???=((??? + 3) and 0fffffffch) ;; dword alignment
	else
	  ???=((??? + 1) and 0fffeh)
	endif
      endif
      ?al1 x,<t>,%(???+?ia)		;;?ia will always be valid (0 or 2)
      .xcref ?t&&x
      ?t&&x=s				;;save size info
    endm
    .cref
  else
    ??error2 <locals "&n" declared outside procedure def>
  endif
endm



;;      ?al1 - allocate local, continued.
;;
;;      ?al1 actually generates the text equate for the local variable.
;;	The form of the text equate generated is more or less:
;;
;;		name equ (type ptr [bp-?ia-nn])
;;          or
;;		name equ ([bp-?ia-nn])
;;
;;      where:
;;              ?ia   is defined to be either zero, or is defined to be
;;		      the number of bytes between the saved BP and the first
;;		      local.  ?ia is only applicable if the current cProc is
;;		      a windows far procedure or if parmRs have been
;;		      encountered.  If not, the ?ia will be zero.  since ?ia
;;		      is determinable prior to invoking this macro, it will be
;;		      added into the  offset ("nn") passed to this macro
;;
;;      usage:
;;              ?al1 n,t,o
;;      where:
;;              n    is the name for the text equate
;;              t    is the type of the equate
;;              o    is the offset of the equate


?al1 macro n,t,o
  if ?no_bp2
    n equ (t [-o])
  else
    n equ (t [IBP][-o])
  endif
endm


;;	?gcc - get calling convention
;;
;;	?gcv sets the given symbol to the calling convention
;;	to be used.
;;
;;	usage:
;;		?gcc s,i,cc
;;
;;	where:
;;		s  is the symbol to return the convention in
;;		   s = 0 if 'C' calling convention
;;		   s = 1 if PL/M (PASCAL) calling convention
;;		i  is the initial value for s
;;		cc is the calling convention override, and may be one of
;;		   C	  use 'C' convention
;;		   PLM	  use PL/M calling convention
;;		   PASCAL use PL/M calling convention

?gcc macro s,i,cc
  s = i 				;;Set default calling convention
  ifnb <cc>
    ifidn <cc>,<C>			;;If overriding default
      s=0				;;  'C' calling convention
    endif
    ifidn <cc>,<PLM>
      s=1				;;  PL/M calling convention
    endif
    ifidn <cc>,<PASCAL>
      s=1				;;  PL/M calling convention
    endif
  endif
endm



ifndef ?NOGLOBAL
  .xcref
  .xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP,globalI
  .cref

  ;;	globalx - define global data of type x
  ;;
  ;;	usage:
  ;;		globalx n,i,s,c
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is the name to be given the variable.
  ;;		i	is the initial value of the variable.
  ;;		s	is the duplication factor
  ;;		c	is the convention, C for C, PLM or PASCAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.
  ;;
  ;;	The D form will generate two extra equates of the form off_n and seg_n.

  globalB macro n,i,s,c
    ?ad <n>,1
    ?dd n,1,<byte>,<db>,<i>,<s>,<c>
  endm

  globalW macro n,i,s,c
    ?ad <n>,2
    ?dd n,1,<word>,<dw>,<i>,<s>,<c>
  endm

  globalI macro n,i,s,c
    ?ad <n>,2
    ?dd n,1,wordI,%asmdI,<i>,<s>,<c>
  endm

  globalD macro n,i,s,c
    ?ad <n>,4
    ?dd n,1,<dword>,<dd>,<i>,<s>,<c>
    off_&n equ word ptr n[0]
    seg_&n equ word ptr n[2]
  endm

  globalQ macro n,i,s,c
    ?ad <n>,8
    ?dd n,1,<qword>,<dq>,<i>,<s>,<c>
  endm

  globalT macro n,i,s,c
    ?ad <n>,10
    ?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
  endm

  if sizec
    globalCP macro n,i,s,c
      globalD n,<i>,<s>,<c>
    endm
  else
    globalCP macro n,i,s,c
      globalW n,<i>,<s>,<c>
    endm
  endif

  if sized
    globalDP macro n,i,s,c
      globalD n,<i>,<s>,<c>
    endm
  else
    globalDP macro n,i,s,c
      globalI n,<i>,<s>,<c>
    endm
  endif

endif


ifndef ?NOSTATIC
  .xcref
  .xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP,staticI
  .cref

  ;;	staticx - define static data of type x
  ;;
  ;;	usage:
  ;;		staticx n,i,s
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is the name to be given the variable.
  ;;		i	is the initial value of the variable.
  ;;		s	is the duplication factor
  ;;
  ;;	statics do not generate an underscored version of the symbol
  ;;	since they are intended to be internal symbols.  If they are
  ;;	required to be public, use globlax.


  staticB macro n,i,s
    ?ad <n>,1
    ?dd n,0,<byte>,<db>,<i>,<s>,<PLM>	;;PLM to keep from generating _
  endm

  staticW macro n,i,s
    ?ad <n>,2
    ?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
  endm

  staticD macro n,i,s
    ?ad <n>,4
    ?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
  endm

  staticI macro n,i,s
    ?ad <n>,sizeI
    ?dd n,0,wordI,%asmdI,<i>,<s>,<PLM>
  endm

  staticQ macro n,i,s
    ?ad <n>,8
    ?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
  endm

  staticT macro n,i,s
    ?ad <n>,10
    ?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
  endm

  if sizec
    staticCP macro n,i,s
      staticD n,<i>,<s>
    endm
  else
    staticCP macro n,i,s
      staticW n,<i>,<s>
    endm
  endif

  if sized
    staticDP macro n,i,s
      staticD n,<i>,<s>
    endm
  else
    staticDP macro   n,i,s
      staticI n,<i>,<s>
    endm
  endif
endif



;;      ?dd is the generalized data definition macro.
;;
;;      format:
;;		?dd n,p,t,d,i,s,c
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              t       is the assembler type (byte, word, dword)
;;              d       is the assembler directive (db,dw or dd)
;;              i       is the initial value
;;              s       is a duplication factor
;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
;;			The default (?PLM flag) will be used if not specified.


?dd macro n,p,t,d,i,s,c
  ?gcc ?dd2,%?PLM,<c>			;;Set calling convention
  ife ?dd2				;;If 'C'
    n label t
    ?dd1 _&n,p,<d>,<i>,<s>		;;Microsoft C uses leading underscores
  else
    ?dd1 n,p,<d>,<i>,<s>		;;If PL/M
  endif
endm



;;      ?dd1 is the generalized data definition macro.
;;
;;      format:
;;              ?dd1 n,p,d,i,s
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              d       is the assembler directive (db,dw or dd)
;;              i       is the initial value
;;              s       is a duplication factor


?dd1 macro n,p,d,i,s
  if p
    public n
  endif
  ifb <s>
    n d i
  else
    ifb <i>
      n d s dup (?)
    else
      n d s dup (i)
    endif
  endif
endm



ifndef ?NOEXTERN
  .xcref
  .xcref ?ex1,?ex2,externB,externW,externD,externQ,externT,externI
  .xcref externNP,externFP,externP,externCP,externDP,externA
  .cref
  ?ex2 = 0

  ;;	externx - define external data of type x
  ;;
  ;;	usage:
  ;;		externx n,c
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer
  ;;			dp=data pointer,  a=absolute
  ;;		n	is a list of names to define
  ;;		c	is the convention, C for C, PLM or PSACAL forPL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  externA macro n,c			;;40h is reserved for whatever will
    ?ex1 <n>,40h,<abs>,<c>,<>		;;  be done in the future for ASB
  endm					;;  externals

  externB macro n,c
    ?ex1 <n>,1,<byte>,<c>,<>
  endm

  externW macro n,c
    ?ex1 <n>,2,<word>,<c>,<>
  endm

  externD macro n,c
    ?ex1 <n>,4,<dword>,<c>,<>
  endm

  externI macro n,c
    ?ex1 <n>,sizeI,%wordI,<c>,<>
  endm

  externQ macro n,c
    ?ex1 <n>,8,<qword>,<c>,<>
  endm

  externT macro n,c
    ?ex1 <n>,10,<tbyte>,<c>,<>
  endm

  externNP macro n,c
    ?ex1 <n>,2,<near>,<c>,<cc>
  endm

  externFP macro n,c
    ?ex1 <n>,4,<far>,<c>,<cc>
  endm

  if sizec
    externP macro n,c
      ?ex1 <n>,4,<far>,<c>,<cc>
    endm
  else
    externP macro n,c
      ?ex1 <n>,2,<near>,<c>,<cc>
    endm
  endif

  if sizec
    externCP macro n,c
      ?ex1 <n>,4,<dword>,<c>,<>
    endm
  else
    externCP macro n,c
      ?ex1 <n>,2,<word>,<c>,<>
    endm
  endif

  if sized
    externDP macro n,c
      ?ex1 <n>,4,<dword>,<c>,<>
    endm
  else
    externDP macro n,c
      ?ex1 <n>,2,<word>,<c>,<>
    endm
  endif



  ;;	?ex1 is the generalized external definition macro
  ;;
  ;;	format:
  ;;		?ex1 n,s,d,c,scv
  ;;	where:
  ;;		n	is are the names of the externals
  ;;		s	is the size in bytes (used for typing)
  ;;		d	is the type
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.
  ;;		scv	save calling convention.  If this field is "cc", then
  ;;			the calling convention will be saved in a ?CCn equ.

  ?ex1 macro n,s,d,c,scv
    ?gcc ?ex2,%?PLM,<c>
    irp x,<n>
      .xcref
      .xcref ?t&&x
      .cref
      ?t&&x=s				;;save size info
      ife ?ex2
	extrn _&&x:&d
	x equ _&&x
      else
	extrn x:&d
      endif
      ifidn <scv>,<cc>			;;save calling convention (C or PL/M)
	.xcref				;;  if NP, FP, or P
	.xcref ?CC&&x
	.cref
	?CC&&x=?ex2
      endif
    endm
  endm
endif



ifndef ?NOLABEL
  .xcref
  .xcref ?lb1,?lblpu,?lb2
  .xcref labelB,labelW,labelD,labelQ,labelT
  .xcref labelNP,labelFP,labelP,labelCP,labelDP
  .cref
  ?lblpu = 0
  ?lb2 = 0

  ;;	  labelx - define label of data type x
  ;;
  ;;	  usage:
  ;;		  labelx n,c
  ;;	  where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is a list of names to define, the first of which can
  ;;			be the keyword public
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  labelB macro n,c
    ?lb1 <n>,1,<byte>,<c>
  endm

  labelW macro n,c
    ?lb1 <n>,2,<word>,<c>
  endm

  labelD macro n,c
    ?lb1 <n>,4,<dword>,<c>
  endm

  labelQ macro n,c
    ?lb1 <n>,8,<qword>,<c>
  endm

  labelT macro n,c
    ?lb1 <n>,10,<tbyte>,<c>
  endm

  labelNP macro n,c
    ?lb1 <n>,2,<near>,<c>
  endm

  labelFP macro n,c
    ?lb1 <n>,4,<far>,<c>
  endm

  if sizec
    labelP macro n,c
      ?lb1 <n>,4,<far>,<c>
    endm
  else
    labelP macro n,c
      ?lb1 <n>,2,<near>,<c>
    endm
  endif

  if sizec
    labelCP macro n,c
      ?lb1 <n>,4,<dword>,<c>
    endm
  else
    labelCP macro n,c
      ?lb1 <n>,2,<word>,<c>
    endm
  endif

  if sized
    labelDP macro n,c
      ?lb1 <n>,4,<dword>,<c>
    endm
  else
    labelDP macro n,c
      ?lb1 <n>,2,<word>,<c>
    endm
  endif


  ;;	?lb1 is the generalized label definition macro
  ;;
  ;;	format:
  ;;		?lb1 n,s,d
  ;;	where:
  ;;		n	are the names of the labels
  ;;		s	is the size in bytes (used for typing)
  ;;		d	is the type
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  ?lb1 macro n,s,d,c
   ?gcc ?lb2,%?PLM,<c>
    ?lblpu=0
    irp x,<n>
      ifidn <x>,<PUBLIC>
	?lblpu=1
      else
	.xcref
	.xcref ?t&&x
	.cref
	?t&&x=s 			;;save size info
	ife ?lb2			;;If C
	  if ?lblpu
	     public _&&x
	  endif
	  _&&x label &d
	  x equ _&&x
	else				;;If PL/M
	  if ?lblpu
	     public x
	  endif
	  x label &d
	endif
      endif
    endm
  endm
endif



ifndef ?NODEF

  ;;	defx - inform macros that name is of type x
  ;;
  ;;	The given name(s) is flaged to be of the given type.  This macro
  ;;	is intended for giving types to variables that were not generated
  ;;	by the macros (i.e., static storage).  There must be a type definition
  ;;	for all parameters in a call list.
  ;;
  ;;	usage:
  ;;		defx	n
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;		n      is the name(s) to be given the variable(s).
  ;;
  ;;	Bytes are considered to be two bytes long for alignment reasons

  .xcref
  .xcref defB,defW,defD,defQ,defT,defCP,defDP
  .cref

  defB macro n
    ?ad <n>,1
  endm

  defW macro n
    ?ad <n>,2
  endm

  defD macro n
    ?ad <n>,4
  endm

  defQ macro n
    ?ad <n>,8
  endm

  defT macro n
    ?ad <n>,10
  endm

  if sizec
    defCP macro n
      defD <n>
    endm
  else
    defCP macro n
      defW <n>
    endm
  endif

  if sized
    defDP macro n
      defD <n>
    endm
  else
    defDP macro n
      defW <n>
    endm
  endif
endif



;	?ad is the macro which creates a definition for the given
;	symbol
;
;	usage:
;		?ad <n>,s
;	where:
;		n is a list of names to define
;		s is the size info (1,2,4,8,10)


?ad macro n,s
  irp x,<n>
    .xcref
    .xcref ?t&&x
    .cref
    ?t&&x=s				;;save size info
  endm
endm



ifndef ?NOPTR
  .xcref
  .xcref regPtr,farPtr
  .cref

  ;;	regPtr generates information allowing a 32-bit pointer currently
  ;;	in a register to be pushed as a parameter to a subroutine using
  ;;	the cCall macro.
  ;;
  ;;	usage:
  ;;		regptr	n,s,o
  ;;	where:
  ;;		n	is the name the argument will be known as
  ;;		s	is the register containing the segment portion
  ;;			of the pointer
  ;;		o	is the register containing the offset portion
  ;;			of the pointer
  ;;
  ;;	2/14/85 - made obsolete with farptr

  regPtr macro n,s,o
    farPtr n,s,o
  endm



  ;;	farPtr generates information allowing a 32-bit pointer to be
  ;;	pushed as a parameter to a subroutine using the cCall macro.
  ;;
  ;;	usage:
  ;;		farptr	n,s,o
  ;;	where:
  ;;		n	is the name the argument will be known as
  ;;		s	is the segment portion of the pointer
  ;;		o	is the offset portion of the pointer
  ;;
  ;;	Note that any cast must have been made in the argument itself
  ;;	(i.e. regptr ptr1,ds,<word ptr 3[si]>)


  farPtr macro n,s,o
    .xcref
    .xcref ?t&n
    .cref
    n &macro
      push s								      ;@
      push o								      ;@
    &endm
    ?t&n=80h
  endm
endif



;;      arg - declare argument
;;
;;	The given argument(s) is added to the argument list structure
;;
;;      format:
;;              arg     a
;;
;;      where:
;;              a       is any valid argument to push.
;;
;;	If any element in arglist has not been defined or isn't a 16-bit
;;      register, then a complete specification must have been given in a
;;      text equate and a defx also given (if not, you'll pay the penalty!)


arg macro a
  irp x,<a>
    ?argc=?argc+1			;;increment the arg count
    ?atal <x>,%?argc			;;generate argument
  endm
endm



;;      ?atal (add to argument list) generates a macro that will cause
;;	the given argument to be processed when invoked.  It is used by
;;      the arg macro only.


?atal macro n,i
  .xcref
  .xcref ?ali&i
  .cref
  ?ali&i &macro
    ?ap <n>
  &endm
endm



;;      ?ap - process arguments and place onto stack
;;
;;	The given argument is processed (type checking) and place on
;;	the stack for a pending call.  There must be a type definition
;;	for all arguments (except words).  This can be done by using
;;      text equates and the defx macro.
;;
;;      format:
;;              ?ap n
;;      where:
;;              n       is the name of the argument to be pushed
;;
;;	The variable  ?argl  is updated by the length of the arguments
;;      pushed so that the stack can be cleaned up after the call.


?ap macro n
  ?argl=?argl+2 			;;assume one word is pushed
  ifdef ?t&n
    ife ?t&n-1				;;byte type
      push word ptr (n) 						      ;@
      exitm
    endif

    ife ?t&n-2				;;word type
      push n								      ;@
      exitm
    endif

    ife ?t&n-4				;;dword type
      push word ptr (n)[2]						      ;@
      push word ptr (n) 						      ;@
      ?argl=?argl+2
      exitm
    endif

    ife ?t&n-8				;;qword type
      push word ptr (n)[6]						      ;@
      push word ptr (n)[4]						      ;@
      push word ptr (n)[2]						      ;@
      push word ptr (n) 						      ;@
      ?argl=?argl+6
      exitm
    endif

    if ?t&n and 80h			;;far pointer type
      n
      ?argl=?argl+2
      exitm
    endif

    ife ?t&n				;;variable storage
      push word ptr (n) 						      ;@
      exitm
    endif
  endif

  push n				;;unknown or register or immediate    ;@
endm



;;	cCall - call a 'c' language procedure
;;
;;	The given procedure is called with the given parameters.
;;	If the calling convention is C, the arguments are pushed
;;      in reverse order, and removed after the called procedure
;;	returns.  If the calling conventing is PL/M, the arguments
;;      are pushed as they were encountered, and the called procedure
;;      is assumed to have removed them from the stack.
;;
;;	The calling convention priority will be:
;;	   1)	that specified on the cCall if present
;;	   2)	that defined by the target
;;	   3)	the default (?PLM flag)
;;
;;      format:
;;		ccall n,<a>,c
;;
;;      where:
;;              n       is the name of the procedure to call
;;              a       are arguments to be pushed (optional, may be
;;                      specified with the "arg" macro.
;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
;;			The default (?PLM flag) will be used if not specified.


cCall macro n,a,c
  ifnb <a>				;;add any arguments to list
    arg <a>
  endif
  mpush %?rsl				;;save registers (if any)

  ifdef ?CC&n				;;if calling convention has been
    ?cCall1=?CC&n			;;   defined for target, use it
  else					;;else use the default
    ?cCall1=?PLM
  endif

  ifnb <c>				;;If possible override, check it out
    ?gcc ?cCall1,%?cCall1,<c>
  endif

  ?argl=0				;;init argument length
  ife ?cCall1				;;if C calling convention
    ?acb=?argc				;;initialize for looping
  else
    ?acb=1				;;initialize for looping
  endif

  rept ?argc				;;push arguments and purge macros
    uconcat <?ali>,%?acb
    uconcat <purge>,,<?ali>,%?acb
    ife ?cCall1 			;;if C calling convention
      ?acb=?acb-1
    else
      ?acb=?acb+1
    endif
  endm
  call n				;;call the procedure		      ;@
  if ((?cCall1 eq 0) and (?argl ne 0))	;;If C calling convention and arguments
    add sp,?argl			;;  then remove them		      ;@
  endif
  mpop %?rsl				;;pop all specified regs
  ?rsl=0				;;invalidate save list
  ?argc= 0				;;    "      arguments
  ?argl= 0
endm




;;	cProc - define a 'c' procedure
;;
;;	cProc is the procedure definition for procedures.
;;
;;      format:
;;		cProc n,cf,a
;;      where:
;;              n       is the name of the procedure
;;
;;		cf	controls certain definitions, and may be:
;;			    NEAR       proc is to be a near label
;;			    FAR        proc is to be a far  label
;;			    PUBLIC     proc is to be defined as public
;;			    SMALL      call makeframe procedure
;;			    NODATA     dont create prolog code to setup DS
;;			    ATOMIC     don't link stack if not needed
;;				       NODATA must be specified for ATOMIC
;;			    FORCEFRAME Force generation of a frame
;;			    C	       proc is to be a C    procedure
;;			    PLM        proc is to be a PL/M procedure
;;			    PASCAL     proc is to be a PL/M procedure
;;			    WIN        proc is to be a windows procedure
;;			    NONWIN     proc isn't to be a windows procedure
;;			    NO_BP      don't generate BP in text equates
;;			    BP	       generate BP in text equates
;;
;;              a       is a list of registers that are to be saved whenever
;;                      the procedure is invoked.
;;
;;			makeframe procedure:   If small is specified, then
;;                      the "makeframe procedure" is invoked instead of
;;                      generating normal prologues/epilogues
;;
;;			A call is performed to the makeframe procedure.  The
;;                      call is followed by two bytes.  the first byte is the
;;                      number of locals to allocate for the frame, the second
;;			is the number of bytes of parameters.  The makeframe
;;			procedure will in turn call the cProc routine at the
;;			address following the data bytes.  When the cProc is
;;                      finished, it will do a near return to the makeframe
;;                      procedure to clean up the frame and exit.
;;
;;			Note that register parameters and makeframe are
;;                      incompatible and cannot be used together.
;;
;;			The makeframe procedure will save SI, DI, and also
;;			DS if a far procedure.	These registers will be
;;                      removed from the autosave list if specified.


cProc macro n,cf,a
  if ?cpd
    ?utpe				;;generate unterminated proc error
  endif

  ?cpd=1				;;a procdef is active now
  ???=0 				;;no locals are defined yet
  ?argc=0				;;no arguments are defined
  ?ba=0 				;;not in a procedure
  ?po=0 				;;initial parameter offset
  ?pu=0 				;;initial public setting
  ?ia=0 				;;no special prolog/epilog
  ?adj=2*sizeI				;;parameter adjustment (near ret+bp)
  ?rp=0 				;;no register parameters
  ?uf=0 				;;don't use makeframe
  ?wfp=?WIN				;;default far procedure (win or not)
  ?ff=0 				;;don't force frame setup
  ?pas=0				;;process register save list
  ?pcc=?PLM				;;calling convention (C or PL/M)
  ?no_bp2=?no_bp1			;;Default base register generation

  ifnb <a>				;;register save list
    ?ri ?pas,<a>
  endif

  ?pc=sizec				;;default size
  ?nd=?nodata1				;;default NODATA flag
  ?nx=0 				;;default is not ATOMIC

  irp x,<cf>
    ifdef ??_cproc_&&x
      ??_cproc_&&x
    else
      ??error2 <e r r o r - unknown keyword x>
      .err
    endif

  endm

  if ?pcc				;;If PLM
    ?PLMPrevParm=0			;;  show no previous parameter
    .xcref
    .xcref ?PLMParm0
    .cref
    ?PLMParm0 &macro			;;Null macro to terminate
    purge ?PLMParm0
    &endm
  endif

  .xcref
  .xcref ?CC&n
  .cref
  ?CC&n=?pcc				;;Save procedure type

  if (?nx eq 1) and (?nd eq 0)		;;ATOMIC requires NODATA
    ?nx = 0				;;clear the ATOMIC keyword
    ??error2 <ATOMIC specified without NODATA - ATOMIC ignored>
  endif

  if ?pc				;;if a far procedure
    if ?wfp				;;if windows
      ife ?nx				;;if not ATOMIC
        ife ?COW			;; COW dos not save DS
	  ?ia=2				;;  adjust locals for saved ds
	  ?pas = ?pas and (not ?ds)	;;no need for extra save
	endif
      endif
    endif
    ?adj=?adj+sizeI 			;;far, make parameter adjustment
  else
    ?wfp=0				;;not a far windows procedure
  endif

  ?pas = ?pas and (not (?sp+?cs+?ss))	;;make no sense to save these

  if ?uf				;;don't save these if user frame
    ?pas = ?pas and (not (?bp+?si+?di))
  endif

  ife ?pcc
    ?pg  <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
  else
    ?pg  <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
  endif
endm




;;      ?pg - generate begin and nested macros for current procedure
;;
;;      format:
;;		?pg n,p,c,a,w,nnu,cc
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              c       is the class definition for the procedure
;;              a       is an enumerated list of registers to save
;;                      at entry and restore at exit
;;              w       true if a far windows procedure
;;		nnu	procedure name without any underscore
;;		cc	calling convention (C or PL/M)
;;
;;
;;      local stack allocation will be forced to an even byte count to
;;      maintain stack word alignment.


?pg macro n,p,c,a,w,nnu,cc
  .xcref
  if ?uf				;;if user frame
    if ?nd
      ??error2 <NODATA encountered in &n - user frame ignored>
      ?uf=0
    endif
  endif

  .xcref cBegin
  cBegin &macro g			;;generate cBegin macro
    .xcref
    if cc				;;Finish definition of parameters
      uconcat <?PLMParm>,%?PLMPrevParm,%?po
    endif

    if ?uf				;;if user frame
      if ?rp				;;If register parameters
	??error2 <parmR encountered in &n - user frame ignored>
	?uf=0
      endif
    endif
    ?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc,<nnu>,%??? ;;generate cEnd macro
    ?cpd=0				;;terminate current proc def
    ?argc=0				;;no arguments are defined yet
    ?ba=1				;;have reached a begin
    ???=(???+1) and 0fffeh		;;word align local storage

    if p				;;If to be public
      public n
    endif

    ife c				;;declare procedure type
      n proc near
    else
      n proc far
    endif

    ife cc				;;if 'C' calling convention
      nnu equ n 			;;  generate label without underscore
    endif

    ?cbe = 0				;;Assume no command on cBegin line
    ifnb <g>
      ?pcbe <g>,<nnu>,<cBegin>
    endif
    if ?cbe eq 1			;;if nogen, then cannot have locals
      if ???+a+?rp			;;  saved regs, or parmRs
	if2
	  ??_out <cBegin - possibly invalid use of nogen>
	endif
      endif
    else				;;else must generate a frame
      if ?uf				;;if user frame code specified
	 ?mf c,%???,%?po		;;  call user's makeframe
	 mpush a			;;  save specified registers
      else
	ife ?cbe			;;If full frame to be set up
	  if w				;;if a far windows procedure
	    ife ?nd			;;if not NODATA,
	      mov IAX,ds 		;;   then set AX = current ds, and    ;@
	      nop			;;   leave room for  MOV AX,1234h     ;@
	    endif
	    ife ?nx			;;if not ATOMIC, far frame must be set
	      ife ?DOS5 		;;if not DOS5, then set far frame flag
		inc IBP			;;  by incrementing the old bp	      ;@
	      endif
	      push IBP							      ;@
	      mov IBP,ISP 						      ;@
	      ife ?COW			;; save DS not needed for CW
	  	push ds							      ;@
	      endif
	    else			;;ATOMIC procedure
	      if ?ff+???+?po+?rp	;;if any locals or parameters
		push IBP 		;;  then must set frame pointer       ;@
		mov IBP,ISP		;;  to be able to access them	      ;@
	      endif
	    endif
	    ife ?nd			;;if not NODATA, then AX should
	      mov ds,IAX 		;;  have the ds to use		      ;@
	    endif
	  else				;;not windows.	use standard prolog
	    if ?ff+???+?po+?rp		;;if any locals or parameters
	      push IBP			;;  then must set frame pointer       ;@
	      mov IBP,ISP 		;;  to be able to access them	      ;@
	    endif
	  endif
	  if ?rp			;;if parmR's, push them before
	    ?uf=0			;;  allocating locals and saving
	    rept ?rp			;;  the autosave registers
	      uconcat mpush,,?rp,%?uf
	      ?uf=?uf+1
	    endm
	  endif
	  if ???			;;if locals to allocate
	    if ?chkstk1 		;;if stack checking enabled
	      ifdef ?CHKSTKPROC 	;;if user supplied stack checking
		?CHKSTKPROC %???	;;  invoke it with bytes requested
	      else
		mov IAX,???		;;invoke default stack checking       ;@
		ife cc
		  call _chkstk						      ;@
		else
		  call chkstk						      ;@
		endif
	      endif
	    else			;;no stack checking
	      sub   ISP,???		;; allocate any local storage	      ;@
	    endif
	  endif
	else				;;partial frame, only set locals
	  if ?rp			;;If parmRs, error
	    ??error2 <cBegin - parmRs encountered with partial frame>
	  else
	    if ???			;;Only realloc frame if locals
	      lea ISP,[IBP][-???-?ia]	;;?ia will adjust for saved BP	      ;@
	    endif
	  endif
	endif
	mpush a 			;;save autosave registers
      endif

      ifdef ?PROFILE			;;if profiling enabled
	if c				;;  and a far procedure
	  call StartNMeas		;;  invoke profile start procedure    ;@
	endif
      endif

    endif

    .cref
    purge cBegin			;;remove the macro
  &endm 				;;end of cBegin macro

  .xcref ?utpe
  ?utpe &macro
    ??error2 <unterminated procedure definition: "&n">
  &endm
  .cref
endm					;;end of ?pg macro




;;      ?pg1 - generate end macro for current procedure
;;
;;      format:
;;		?pg1 n,c,a,o,w,f,d,r,cc,nnu,lc
;;      where:
;;              n       is the name of the procedure
;;              c       is the class definition for the procedure
;;              a       is an enumerated list of registers to save
;;                      at entry and restore at exit
;;              o       is the number of bytes of paramteres to remove at exit
;;              w       true if a far windows procedure
;;              f       is 1 if to use the user's makeframe procedure
;;		d	is 1 if NODATA procedure
;;              r       number of register parameters
;;		cc	calling convention (C or PL/M)
;;		nnu	procedure name without any underscore
;;		lc	locals byte count


?pg1 macro n,c,a,o,w,f,d,r,cc,nnu,lc
  .xcref
  .xcref cEnd

  parm_bytes_&nnu = o			;;Define number of parameter bytes

  cEnd &macro g 			;;start of cEnd macro
    .xcref
    ?ba=0				;;no longer in a procedure
    ?cbe = 0				;;Assume no command on cBegin line
    ifnb <g>
      ?pcbe <g>,<nnu>,<cEnd>
    endif
    if ?cbe eq 1			;;if nogen, then cannot have parmRs
      if a+r+lc 			;;  locals, or saved registers
	if2
	  ??_out <cEnd - possibly invalid use of nogen>
	endif
      endif
    else				;;else must remove the frame
      ifdef ?PROFILE			;;if profiling enabled
	if c				;;  and a far procedure
	  call StopNMeas		;;  invoke profile stop procedure
	endif				;;  (doesn't trash DX:AX)
      endif
      mpop a				;;restore autosaved registers
      if f				;;if to use the "makeframe" procedure
	db 0c3h 			;;  near return to user's makeframe    @
      else
	if w				;;if far win proc, use special epilog
	  ife ?nx			;;if not ATOMIC, bp was pushed
	    ife ?COW			;; restore DS not needed for CW
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
		lea sp,-2[bp]		;;  or locals or parmR's, get valid SP @
	      endif
	      pop ds			;;restore saved ds and bp	       @
	    else
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
	        mov sp,bp
	      endif
	    endif
	    pop IBP			;;				       @
	    ife ?DOS5			;;if not DOS5, bp was
	      dec IBP			;;  incremented to mark far frame      @
	    endif
	  else				;;ATOMIC frame was set up
	    if memS32
	      leave
	    else
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
	        mov ISP,IBP 		;;  or locals or parmR's, get valid SP @
	      endif
	      if ???+?po+r
	        pop IBP						      ;@
	      endif
	    endif
	  endif
	else				;;non-windows standard epilog
	  if ?ff+???+?po+r		;;if any parameters
	    if (?TF eq 0) or (???+r)	;;if cannot assume valid SP
	      mov ISP,IBP 		;;  or locals or parmR's, get valid SP;@
	    endif
	    pop IBP							      ;@
	  endif
	endif
	if ?cbe ne 4			;;Don't generate ret if ??cleanframe??   e
	  ife cc			;;if C calling convention
	    ret 			;;  return			      ;@
	  else				;;else
	    ret o			;;  return and remove paramteres      ;@
	  endif
	endif
      endif
    endif
    if ?cbe ne 4			;;Don't delete macro if ??cleanframe??   e
      n endp				;;end of process
      .cref
      purge cEnd			;;remove the macro
    else
      .cref
    endif
  &endm
  .cref
endm


;;	cleanframe
;;
;;	cleanframe removes a cMacros generated frame, invoking cEnd
;;	with a special keyword which will keep the cEnd macro from
;;	generating a return statement and purging itself.

.xcref
.xcref cleanframe
cleanframe macro
  cEnd <??cleanframe??>
endm
.cref



;; The following macros are used to speed up the processing of the
;; command allowed on a cProc command line.  They simply set or clear
;; the correct flag as needed.

.xcref
.xcref ??_cproc_FAR,??_cproc_NEAR,??_cproc_PUBLIC,??_cproc_SMALL
.xcref ??_cproc_DATA,??_cproc_NODATA,??_cproc_ATOMIC,??_cproc_C
.xcref ??_cproc_PLM,??_cproc_PASCAL,??_cproc_WIN,??_cproc_NONWIN
.xcref ??_cproc_NO_BP,??_cproc_BP

.xcref ??_cproc_far,??_cproc_near,??_cproc_public,??_cproc_small
.xcref ??_cproc_data,??_cproc_nodata,??_cproc_atomic,??_cproc_c
.xcref ??_cproc_plm,??_cproc_pascal,??_cproc_win,??_cproc_nonwin
.xcref ??_cproc_no_bp,??_cproc_bp
.cref

??_cproc_FAR macro
 ?pc=1
endm

??_cproc_NEAR macro
  ?pc=0
endm

??_cproc_PUBLIC macro
  ?pu=1
endm

??_cproc_SMALL macro
  ?uf=1
endm

??_cproc_DATA macro
  ?nd=0
endm

??_cproc_NODATA macro
  ?nd=1
endm

??_cproc_ATOMIC macro
  ?nx=1
endm

??_cproc_C macro
  ?pcc=0
endm

??_cproc_PLM macro
  ?pcc=1
endm

??_cproc_PASCAL macro
  ?pcc=1
endm

??_cproc_WIN macro
  ?wfp=1
endm

??_cproc_NONWIN macro
  ?wfp=0
endm

??_cproc_NO_BP macro
  ?no_bp2=1
endm

??_cproc_BP macro
  ?no_bp2=0
endm

??_cproc_far macro
 ?pc=1
endm

??_cproc_near macro
  ?pc=0
endm

??_cproc_public macro
  ?pu=1
endm

??_cproc_small macro
  ?uf=1
endm

??_cproc_data macro
  ?nd=0
endm

??_cproc_nodata macro
  ?nd=1
endm

??_cproc_atomic macro
  ?nx=1
endm

??_cproc_c macro
  ?pcc=0
endm

??_cproc_plm macro
  ?pcc=1
endm

??_cproc_pascal macro
  ?pcc=1
endm

??_cproc_win macro
  ?wfp=1
endm

??_cproc_nonwin macro
  ?wfp=0
endm

??_cproc_no_bp macro
  ?no_bp2=1
endm

??_cproc_bp macro
  ?no_bp2=0
endm


;	?pcbe is the macro which processes the text on cBegin/cEnd
;	The text is allowed to be:
;
;		NOGEN	nogen
;		PARTIAL partial
;		the procedure name as given on the cProc line
;
;	usage:
;		?pcbe <g>,<nnu>,<mt>
;	where:
;		g	is the text on the cBegin/cEnd line
;		nnu	is the procedure name without any underscores
;		mt	macro type (cBegin/cEnd)
;
;	The variable ?cbe is set to the following value
;
;		0 = invalid (defualt action>
;		1 = nogen
;		2 = partial frame
;		4 = clean frame


?pcbe macro g,nnu,mt
  ifidn <g>,<NOGEN>
    ?cbe = 1
  else
    ifidn <g>,<nogen>
      ?cbe = 1
    else
      ifidn <mt>,<cBegin>
	ifidn <g>,<PARTIAL>
	  ?cbe = 2
	else
	  ifidn <g>,<partial>
	    ?cbe = 2
	  else
	    ifdif <g>,<nnu>
	      ??error2 <mt - unknown keyword g>
	    endif
	  endif
	endif
      else
	ifidn <g>,<??cleanframe??>
	  ?cbe = 4
	else
	  ifdif <g>,<nnu>
	    ??error2 <mt - unknown keyword g>
	  endif
	endif
      endif
    endif
  endif
endm



;	assumes is a macro that will set up the assumes for a segment
;	or group created with the createSeg macro.  If the assumed
;	value passed in isn't known, then a normal assume is made.
;
;       usage:
;               assumes s,g
;
;       where:
;               s       is the register to make the assumption about
;		g	is the value to assume is in it
;
; as a hack, substitute FLAT for g if memF32 is set


assumes macro   s,ln
  if  memF32
    assume s:FLAT
  endif
  ife memF32
    ifndef ln&_assumes
      assume s:ln
    else
      ln&_assumes s
    endif
  endif
endm



;	createSeg is a macro that sets up a segment definition and
;	a logical name for that segment.  The logical name can be
;       used to enter the segment, but it cannot be used for anything
;       else.
;
;       usage:
;		createSeg n,ln,a,co,cl,grp
;       where:
;               n       is the physical name of the segment
;               ln      is the name it is to be invoked by
;               a       is the alignment, and is optional
;               co      is the combine type, and is optional
;               cl      is the class, and is optional
;               grp     is the name of the group that contains this segment


createSeg macro n,ln,a,co,cl,grp
  ifnb <cl>
    n segment a co '&cl'
  else
    n segment a co
  endif
  n ends
  ifnb <grp>
    addseg grp,n
  else
    ln&OFFSET equ offset n:
    ln&BASE equ n
    ?cs3 <ln>,<n>
  endif
  ?cs1 <ln>,<n>
endm


addseg macro grp,seg
  .xcref
  .xcref grp&_def
  .cref
  ifndef  grp&_def
    grp&_def=0
  endif
  if grp&_def ne ASMpass
    .xcref
    .xcref grp&_add
    .cref
    grp&_add &macro s
      grp&_in <seg>,s
    &endm
    .xcref
    .xcref grp&_in
    .cref
    grp&_in &macro sl,s
      ifb <s>
	grp group sl
      else
	grp&_add &macro  ns
	grp&_in  <sl,s>,ns
	&endm
      endif
    &endm
    grp&_def=ASMpass
  else
    grp&_add seg
  endif
endm


defgrp macro grp,ln
  addseg grp
  ifnb <ln>
    irp x,<ln>
      ?cs3 <&x>,<grp>
      x&&OFFSET equ offset grp:
      x&&BASE equ grp
    endm
  endif
endm


?cs1 macro ln,n
  .xcref
  .xcref ln&_sbegin
  .cref
  ln&_sbegin &macro
    .xcref
    .xcref ?mf
    .cref
    ?mf &&macro c,l,p			;;when sBegin is invoked, generate
      if c				;;  the makeframe macro
	extrn n&_FARFRAME:near		;;  make frame for far procedures     ;@
	call n&_FARFRAME						      ;@
      else
	extrn n&_NEARFRAME:near 	;;  make frame for near procedures    ;@
	call n&_NEARFRAME						      ;@
      endif
      db l shr 1			;;define number of locals	      ;@
      db p shr 1			;;define number of parameters	      ;@
      &&endm
    ?cs2 <ln>,<n>
    n segment
  &endm
endm


?cs2 macro ln,n
  .xcref
  .xcref sEnd
  .cref
  sEnd &macro
    n ends
    purge ?mf				;;delete the makeframe macro
    purge sEnd
  &endm
endm


?cs3 macro ln,n
  .xcref
  .xcref ln&_assumes
  .cref
  ln&_assumes &macro s
    assume s:&n
  &endm
endm



;	sBegin is the macro that opens up the definition of a segment.
;	The segment must have already been defined with the createSeg
;       macro.
;
;       usage:
;		sBegin ln
;
;       where:
;               ln      is the logical name given to the segment when
;                       it was declared.

.xcref
.xcref sBegin
.cref
sBegin macro ln
  ln&_sbegin
endm

BeginDATA macro
  ife memF32
    sBegin DATA
  else
    .data
  endif
endm

BeginCODE macro
  ife memF32
    sBegin CODE
  else
    .code
  endif
endm

EndDATA macro
  ife memF32
    sEnd DATA
  endif
endm

EndCODE macro
  ife memF32
    sEnd CODE
  endif
endm

ife ?DF

  ;	Define all segments that will be used.	This will allow the
  ;	assume and groups to be set up at one given place, and also
  ;	allow quick changes to be made
  ;
  ;	createSeg name,logname,align,combine,class,group

ife ?DFCODE
  createSeg _TEXT,CODE,%wordI,public,CODE
endif
  ife ?nodata1
    createSeg _DATA,DATA,%wordI,public,DATA,DGROUP
    defgrp DGROUP,DATA
  else
    ife ?DFDATA
      createSeg _DATA,DATA,%wordI,public,DATA,DGROUP
      defgrp DGROUP,DATA
    endif
  endif

  if ?chkstk1
    ifndef ?CHKSTKPROC
      externp <chkstk>
    endif
  endif
endif


;       errnz exp - generate error message if expression isn't zero
;
;	The errnz will generate an error message if the expression "exp"
;	does not evaluate to zero.  This macro is very useful for testing
;       relationships between items, labels, and data that was coded into
;       an application.
;
;                  errnz   <offset $ - offset label>   ;error if not at "label"
;                  errnz   <eofflag and 00000001b>     ;eofflag must be bit 0
;
;	For expressions involving more than one token, the angle brackets
;       must be used.
;
;	The macro is only evaluated on pass 2, so forward references may be
;       used in the expression.

errnz macro x				;;display error if expression is <>0
  if2
    if x				;;if expression is non-zero,
      errnz1  <x>,%(x)
    endif
  endif
endm

errnz1 macro x1,x2
  = *errnz* x1 = x2
  .err
endm



;       errn$ label,exp - generate error message if label (exp) <> $
;
;	The errnz will generate an error message if the label and "exp"
;       does not evaluate to the current value of the location counter.
;	This macro is very useful for testing relationships between
;       labels and the location counter that was coded into an application.
;
;       examples:  errn$   label        ;error if not at "label"
;                  errn$   label,+3     ;error if not three bytes from "label"
;                  errn$   label,-3     ;error if not three bytes past "label"
;
;	If no "exp" is given, it is the same as specifying 0
;
;	The macro is only evaluated on pass 2, so forward references may be
;       used in the expression.

errn$ macro l,x 			;;error if <$-label1 (exp2)> <>0
  errnz   <offset $ - offset l x>
endm



;;	If profile has been specified, declare the profile routines
;;	to be external and far.  It would be best if this could be done
;;	when the call is actually made, but then the fix-up would be
;;	generated as segment-relative.


ifdef ?PROFILE
  externFP  <StartNMeas,StopNMeas>
endif

if memF32
  .model small
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\i386\exsup.inc ===
;***
;exsup.inc
;
;       Copyright (C) 1993-1997, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Common data structures & definitions for exsup.asm and other
;       Structured Exception Handling support modules.
;
;Revision History:
;       04-13-93  JWM   Initial version
;       12-05-93  PML   Update for C9.0
;       01-12-94  PML   Move jmp_buf struct here, add new fields
;       01-13-95  JWM   Added _NLG_INFO struct.
;       06-05-95  JWM   Added uoffFramePointer to _NLG_INFO struct.
;
;******************************************************************************


;handler dispositions
DISPOSITION_DISMISS             equ     0
DISPOSITION_CONTINUE_SEARCH     equ     1
DISPOSITION_NESTED_EXCEPTION    equ     2
DISPOSITION_COLLIDED_UNWIND     equ     3

;filter return codes
FILTER_ACCEPT           equ     1
FILTER_DISMISS          equ     -1
FILTER_CONTINUE_SEARCH  equ     0

;handler flags settings..
EXCEPTION_UNWINDING     equ     2
EXCEPTION_EXIT_UNWIND   equ     4
EXCEPTION_UNWIND_CONTEXT equ    EXCEPTION_UNWINDING OR EXCEPTION_EXIT_UNWIND

TRYLEVEL_NONE           equ     -1
TRYLEVEL_INVALID        equ     -2

;callback interface codes (mimimal required set)
CB_GET_MAX_CODE         equ     0
CB_DO_LOCAL_UNWIND      equ     1
CB_GET_FRAME_EBP        equ     2
CB_GET_SCOPE_INDEX      equ     3
CB_GET_SCOPE_DATA       equ     4
MAX_CALLBACK_CODE       equ     4

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;     int _ebp;
;     PEXCEPTION_POINTERS xpointers;
;};
_EXCEPTION_REGISTRATION struc
    prev                dd      ?
    handler             dd      ?
_EXCEPTION_REGISTRATION ends

;setjmp/longjmp buffer
_JMP_BUF struc
    saved_ebp           dd      ?
    saved_ebx           dd      ?
    saved_edi           dd      ?
    saved_esi           dd      ?
    saved_esp           dd      ?
    saved_return        dd      ?
    saved_xregistration dd      ?
    saved_trylevel      dd      ?
    ; following only found in C9.0 or later jmp_buf
    version_cookie      dd      ?
    unwind_func         dd      ?
    unwind_data         dd      6 dup(?)
_JMP_BUF ends

; Cookie placed in the jmp_buf to identify the new, longer form
JMPBUF_COOKIE   equ     'VC20'

; Offset of TryLevel in a C8.0 SEH registration node
C8_TRYLEVEL     equ     12

; NLG struct (debugging info)
;
; struct {
;    unsigned long   dwSig;
;    unsigned long   uoffDestination;
;    unsigned long   dwCode;
;    unsigned long   uoffFramePointer;
; } _NLG_Destination = {EH_MAGIC_NUMBER1,0,0,0};

;MAGIC_NUMBER1           equ     019930520h
;
;_NLG_INFO struc
;    dwSig                       dd      MAGIC_NUMBER1
;    uoffDestination     dd      0
;    dwCode                      dd      0
;    uoffFramePointer    dd      0
;_NLG_INFO ends

; This constant is also defined in mtdll.h!
;_NLG_LOCK               equ     01ah
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\i386\pversion.inc ===
;	SCCSID = "@(#)pversion.inc:1.8"
?PLM = 1
?WIN = 0
REALFAR = 0		; used for QC only
ifdef large
 ?LARGE		equ	1
endif
ifdef compact
 ?COMPACT	equ	1
endif
ifdef medium
 ?MEDIUM	equ	1
endif
ifdef small
 ?SMALL		equ	1
endif
ifdef small32
 ?SMALL32	equ	1
 memS32		=	1
else
 memS32		=	0
endif
ifdef flat32
 ?FLAT32	equ	1
 memF32		=	1
else
 memF32		=	0
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\i386\exsup.asm ===
;***
;exsup.asm
;
;       Copyright (c) 1993-1997, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Exception handling for i386.  This file contains those routines
;       common to both C8.0 and C9.0.
;
;Notes:
;
;Revision History:
;       04-13-93  JWM   setjmp(), longjmp() & raisex() moved to setjmp.asm;
;                       common data definitions moved to exsup.inc.
;       10-18-93  GJF   Ensure direction flag is clear in _except_handler2
;       12-16-93  PML   Accept <0,0,>0 from except filter, not just -1,0,+1
;       01-10-94  PML   Moved C8-specific __except_handler2 to exsup2.inc.
;                       Only C8/C9 common routines left here.
;       01-20-94  GJF   Gave _EXCEPTION_REGISTRATION a _COMMON suffix (fix
;                       from SteveWo).
;       02-10-94  GJF   -1 is the end-of-exception-handler chain marker, not 0.
;       01-11-95  SKS   Remove MASM 5.X support
;       04-18-95  JWM   Added NLG support
;       04-21-95  JWM   NLG routines moved from setjmp.asm, NLG data from
;                       frame.cpp.
;       04-25-95  JWM   Added __NLG_Return2 label.
;       06-07-95  JWM   NLG now multithread safe.
;       06-20-95  JWM   dwCode passed on stack (11803).
;       07-11-95  JWM   unwanted prologue removed from NLG_Notify (11803).
;       07-21-95  JWM   Added new entry point, _NLG_Notify1 (16585).
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =       1
?NODATA =       1
include cmacros.inc
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?
ifndef _BUILD_DLL_LIB_
extrn _RtlUnwind@16:near
endif           ; _BUILD_DLL_LIB_

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;};
_EXCEPTION_REGISTRATION_COMMON struc    ; C8.0/C9.0 common only
                        dd      ?       ; prev (OS-req, def'd in exsup.inc)
                        dd      ?       ; handler (ditto)
;private:
    scopetable          dd      ?       ; C8/C9 common
    trylevel            dd      ?       ; C8/C9 common
_EXCEPTION_REGISTRATION_COMMON ends

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

assumes DS,DATA
assumes FS,DATA

public __except_list
__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

;BeginDATA
;
;__NLG_Destination _NLG_INFO <>
;PUBLIC __NLG_Destination
;
;EndDATA

BeginCODE

ifndef _BUILD_DLL_LIB_

;NB: call to RtlUnwind appears to trash ebx! and possibly others so just
; to be save, we save all callee save regs.
cProc _global_unwind2,<C,PUBLIC>,<IBX,ISI,IDI,IBP>
        parmDP  stop
cBegin
        push    0                       ; ReturnValue
        push    0                       ; ExceptionRecord
        push    offset flat:_gu_return  ; TargetIp
        push    stop                    ; TargetFrame

        call    _RtlUnwind@16
_gu_return:
cEnd

endif           ; _BUILD_DLL_LIB_

;_unwind_handler(
;  PEXCEPTION_RECORD xr,
;  PREGISTRATION_RECORD establisher,
;  PCONTEXT context,
;  PREGISTRATION_RECORD dispatcher);
;
;this is a special purpose handler used to guard our local unwinder.
; its job is to catch collided unwinds.
;
;NB: this code is basically stolen from the NT routine xcptmisc.asm
; and is basically the same method used by the system unwinder (RtlUnwind).
;
cProc _unwind_handler,<C>
cBegin
        mov     ecx, dword ptr [esp+4]
        test    dword ptr [ecx.exception_flags], EXCEPTION_UNWIND_CONTEXT
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jz      short _uh_return

    ; We collide in a _local_unwind.  We set the dispatched to the
    ; establisher just before the local handler so we can unwind
    ; any future local handlers.

        mov     eax, [esp+8]            ; Our establisher is the one
                                        ; in front of the local one

        mov     edx, [esp+16]
        mov     [edx], eax              ; set dispatcher to local_unwind2

        mov     eax, DISPOSITION_COLLIDED_UNWIND
_uh_return:
cEnd

;/* _LOCAL_UNWIND2 - run all termination handlers listed in the scope table
; * associated with the given registration record, from the current lexical
; * level through enclosing levels up to, but not including the given 'stop'
; * level.
; */
;void _local_unwind2(PEXCEPTION_REGISTRATION xr, int stop)
;{
;    int ix;
;
;    for(ix=xr->trylevel; ix!=-1 && ix!=stop; ix=xr->xscope[i].enclosing_level){
;       /* NULL indicates that this entry is for a termination handler */
;       if(xr->xscope[i].filter==NULL){
;           /* NB: call to the termination handler may trash callee save regs */
;           (*xr->xscope[i].specific_handler)();
;       }
;    }
;    xr->trylevel=stop;
;}
;/* NOTE: frame (ebp) is setup by caller of __local_unwind2 */

;PUBLIC  __NLG_Return2

cProc _local_unwind2,<C,PUBLIC>
cBegin
        push    ebx
        push    esi
        push    edi     ;call to the handler may trash, so we must save it

        mov     eax, [esp+16]           ; (eax) = PEXCEPTION_REGISTRATION

        ;link in a handler to guard our unwind
        push    eax
        push    TRYLEVEL_INVALID
        push    OFFSET FLAT:__unwind_handler
        push    fs:__except_list
        mov     fs:__except_list, esp

_lu_top:
        mov     eax, [esp+32]           ; (eax) = PEXCEPTION_REGISTRATION
        mov     ebx, [eax.scopetable]
        mov     esi, [eax.trylevel]

        cmp     esi, -1                 ; REVIEW: do we need this extra check?
        je      short _lu_done
        cmp     esi, [esp+36]
        je      short _lu_done

        lea     esi, [esi+esi*2]        ; esi*= 3

        mov     ecx, [(ebx+esi*4).enclosing_level]
        mov     [esp+8], ecx            ; save enclosing level
        mov     [eax.trylevel], ecx

        cmp     dword ptr [(ebx+esi*4).filter], 0
        jnz     short _lu_continue

;        push    0101h
;        mov     eax, [(ebx+esi*4).specific_handler]
;        call    _NLG_Notify

        call    [(ebx+esi*4).specific_handler]

;__NLG_Return2::
_lu_continue:
        jmp     short _lu_top
_lu_done:
        pop     fs:__except_list
        add     esp, 4*3                ; cleanup stack

        pop     edi                     ; restore c-runtime registers
        pop     esi
        pop     ebx
cEnd

;/* _ABNORMAL_TERMINATION - return TRUE if __finally clause entered via
; * _local_unwind2.
; */
;BOOLEAN _abnormal_termination(void);
;cProc _abnormal_termination,<C,PUBLIC>
;cBegin
;        xor     eax, eax                ; assume FALSE
;
;        mov     ecx, fs:__except_list
;        cmp     [ecx.handler], offset FLAT:__unwind_handler
;        jne     short _at_done          ; UnwindHandler first?
;
;        mov     edx, [ecx+12]           ; establisher of local_unwind2
;        mov     edx, [edx.trylevel]     ; is trylevel the same as the
;        cmp     [ecx+8], edx            ; local_unwind level?
;        jne     short _at_done          ; no - then FALSE
;
;        mov     eax, 1                  ; currently in _abnormal_termination
;_at_done:
;cEnd

;
; NLG entrypoints, for debugger support
; On entry: address of non-local goto in eax
;

;public __NLG_Dispatch

;OPTION PROLOGUE:NONE
;OPTION EPILOGUE:NONE

;_NLG_Notify1 PROC C PUBLIC
;        push ebx
;        push ecx
;        mov  ebx, OFFSET __NLG_Destination
;        jmp  __NLG_go           ; ecx is already set
;_NLG_Notify1 ENDP
;
;_NLG_Notify PROC C PUBLIC, dwInCode:DWORD
;        push ebx
;        push ecx
;        mov  ebx, OFFSET __NLG_Destination
;        mov  ecx, dwInCode
;__NLG_Go:
;        mov  [ebx.dwCode], ecx
;        mov  [ebx.uoffDestination], eax
;        mov  [ebx.uoffFramePointer], ebp
;__NLG_Dispatch::
;        pop  ecx
;        pop  ebx
;        ret  4
;_NLG_Notify ENDP
;
;OPTION PROLOGUE:PROLOGUEDEF
;OPTION EPILOGUE:EPILOGUEDEF

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\i386\exsup3.asm ===
;***
;exsup3.asm
;
;       Copyright (c) 1994-1997, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Exception handling for i386.  This is just the C9.0 version of
;       the language-specific exception handler.  The C8.0 version is
;       found in exsup2.asm, and the routines common to both C8 and C9
;       are found in exsup.asm.
;
;Notes:
;
;Revision History:
;       01-10-94  PML   Create VC/C++ 2.0 (C9.0) version from C8.0 original
;       01-11-95  SKS   Remove MASM 5.X support
;       04-18-95  JWM   Added NLG support
;       06-07-95  JWM   __SetNLGCode() used, for multithread safety.
;       06-20-95  JWM   __SetNLGCode() removed, code passed on stack (11803).
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =       1
?NODATA =       1
include cmacros.inc
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?

extrn __global_unwind2:near
extrn __local_unwind2:near
;extrn __NLG_Notify:near

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;/* _esp, xpointers at negative offset */
;     int _esp;
;     PEXCEPTION_POINTERS xpointers;
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;};
;private (at negative offsets from node ptr)
    _esp                =       -8
    xpointers           =       -4
_C9_EXCEPTION_REGISTRATION struc        ; C9.0 version
;public:
                        dd      ?       ; prev (common)
                        dd      ?       ; handler (common)
;private:
    scopetable          dd      ?
    trylevel            dd      ?
_C9_EXCEPTION_REGISTRATION ends
FRAME_EBP_OFFSET equ 16

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

;/* following is the structure returned by the _exception_info() intrinsic. */
;typedef struct _EXCEPTION_POINTERS EXCEPTION_POINTERS;
;typedef struct EXCEPTION_POINTERS *PEXCEPTION_POINTERS;
;struct _EXCEPTION_POINTERS{
;    PEXCEPTION_RECORD ExceptionRecord;
;    PCONTEXT Context;
;};
_EXCEPTION_POINTERS struc
    ep_xrecord          dd      ?
    ep_context          dd      ?
_EXCEPTION_POINTERS ends
SIZEOF_EXCEPTION_POINTERS equ 8

;extern __NLG_Destination:_NLG_INFO

assumes DS,DATA
assumes FS,DATA

__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

BeginCODE

;EXTERN C __SetNLGCode:near

;/* _EXCEPT_HANDLER3 - Try to find an exception handler listed in the scope
; * table associated with the given registration record, that wants to accept
; * the current exception. If we find one, run it (and never return).
; * RETURNS: (*if* it returns)
; *  DISPOSITION_DISMISS - dismiss the exception.
; *  DISPOSITION_CONTINUE_SEARCH - pass the exception up to enclosing handlers
; */
;int _except_handler3(
;       PEXCEPTION_RECORD exception_record,
;       PEXCEPTION_REGISTRATION registration,
;       PCONTEXT context,
;       PEXCEPTION_REGISTRATION dispatcher)
;{
;    int ix, filter_result;
;
;    for(ix=registration->trylevel; ix!=-1; ix=registration->xscope[ix].enclosing_level){
;       /* if filter==NULL, then this is an entry for a termination handler */
;       if(registration->xscope[ix].filter){
;           /* NB: call to the filter may trash the callee save
;              registers. (this is *not* a standard cdecl function) */
;           filter_result=(*registration->xscope[ix].filter)(xinfo);
;           if(filter_result==FILTER_DISMISS)
;               return(-1); /* dismiss */
;           if(filter_result==FILTER_ACCEPT){
;               _global_unwind2(registration);
;               _local_unwind2(registration, ix);
;               (*registration->xscope[ix].specific_handler)(void);
;               assert(UNREACHED); /*should never return from handler*/
;           }
;           assert(filter_result==FILTER_CONTINUE_SEARCH);
;       }
;    }
;    return(0); /* didnt find one */
;}
        db      'VC20'  ;; VC/C++ 2.0/32-bit (C9.0) version
        db      'XC00'  ;; so debugger can recognize this proc (cuda:3936)
cProc _except_handler3,<C,PUBLIC>,<IBX,ISI,IDI,IBP>
        parmDP  xrecord
        parmDP  registration
        parmDP  context
        parmDP  dispatcher
        localV  xp,SIZEOF_EXCEPTION_POINTERS
cBegin
        ;4*4b for callee saves + 4b return address + 4b param = 24

        ;DF in indeterminate state at time of exception, so clear it
        cld

        mov     ebx, registration               ;ebx= PEXCEPTION_REGISTRATION
        mov     eax, xrecord

        test    [eax.exception_flags], EXCEPTION_UNWIND_CONTEXT
        jnz     _lh_unwinding

        ;build the EXCEPTION_POINTERS locally store its address in the
        ; registration record. this is the pointer that is returned by
        ; the _eception_info intrinsic.
        mov     xp.ep_xrecord, eax
        mov     eax, context
        mov     xp.ep_context, eax
        lea     eax, xp
        mov     [ebx.xpointers], eax

        mov     esi, [ebx.trylevel]             ;esi= try level
        mov     edi, [ebx.scopetable]           ;edi= scope table base
_lh_top:
        cmp     esi, -1
        je      short _lh_bagit
        lea     ecx, [esi+esi*2]                ;ecx= trylevel*3
        cmp     dword ptr [(edi+ecx*4).filter], 0
        je      short _lh_continue              ;term handler, so keep looking

        ;filter may trash *all* registers, so save ebp and scopetable offset
        push    esi
        push    ebp

        lea     ebp, FRAME_EBP_OFFSET[ebx]
        call    [(edi+ecx*4).filter]            ;call the filter

        pop     ebp
        pop     esi
        ;ebx may have been trashed by the filter, so we must reload
        mov     ebx, registration

        ; Accept <0, 0, >0 instead of just -1, 0, +1
        or      eax, eax
        jz      short _lh_continue
        js      short _lh_dismiss
        ;assert(eax==FILTER_ACCEPT)

        ;reload xscope base, cuz it was trashed by the filter call
        mov     edi, [ebx.scopetable]
        ;load handler address before we loose components of address mode
        push    ebx                             ;registration*
        call    __global_unwind2                ;run term handlers
        add     esp, 4

        ;setup ebp for the local unwinder and the specific handler
        lea     ebp, FRAME_EBP_OFFSET[ebx]

        ;the stop try level == accepting except level
        push    esi                             ;stop try level
        push    ebx                             ;registration*
        call    __local_unwind2
        add     esp, 8
        lea     ecx, [esi+esi*2]                ;ecx=trylevel*3

;        push    01h
;        mov     eax, [(edi+ecx*4).specific_handler]
;        call    __NLG_Notify

; set the current trylevel to our enclosing level immediately
; before giving control to the handler. it is the enclosing
; level, if any, that guards the handler.
        mov     eax, [(edi+ecx*4).enclosing_level]
        mov     [ebx.trylevel], eax
        call    [(edi+ecx*4).specific_handler]  ;call the except handler
        ;assert(0)                              ;(NB! should not return)

_lh_continue:
        ;reload the scope table base, possibly trashed by call to filter
        mov     edi, [ebx.scopetable]
        lea     ecx, [esi+esi*2]
        mov     esi, [edi+ecx*4+0]              ;load the enclosing trylevel
        jmp     short _lh_top

_lh_dismiss:
        mov     eax, DISPOSITION_DISMISS        ;dismiss the exception
        jmp     short _lh_return

_lh_bagit:
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jmp     short _lh_return

_lh_unwinding:
        push    ebp
        lea     ebp, FRAME_EBP_OFFSET[ebx]
        push    -1
        push    ebx
        call    __local_unwind2
        add     esp, 8
        pop     ebp
        ;the return value is not really relevent in an unwind context
        mov     eax, DISPOSITION_CONTINUE_SEARCH

_lh_return:
cEnd

;public __seh_longjmp_unwind@4
;__seh_longjmp_unwind@4 proc near
;        push    ebp
;        mov     ecx, 8[esp]
;        mov     ebp, [ecx.saved_ebp]
;        mov     eax, [ecx.saved_trylevel]
;        push    eax
;        mov     eax, [ecx.saved_xregistration]
;        push    eax
;        call    __local_unwind2
;        add     esp, 8
;        pop     ebp
;        ret     4
;__seh_longjmp_unwind@4 endp

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\mspatch\makefile.inc ===
DELEXPFILE:
  @if exist ..\..\bin\$(TARGET_DIRECTORY)\mspatch.exp \
       @del ..\..\bin\$(TARGET_DIRECTORY)\mspatch.exp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\mspatchc\makefile.inc ===
DELEXPFILE:
  @if exist ..\..\bin\$(TARGET_DIRECTORY)\mspatchc.exp \
       @del ..\..\bin\$(TARGET_DIRECTORY)\mspatchc.exp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\mspatcha\makefile.inc ===
DELEXPFILE:
  @if exist ..\..\bin\$(TARGET_DIRECTORY)\mspatcha.exp \
       @del ..\..\bin\$(TARGET_DIRECTORY)\mspatcha.exp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\mpatch\makefile.inc ===
EXENAME=mpatch.exe
PDBNAME=mpatch.pdb

COPYTOBIN:
  @if exist obj\$(TARGET_DIRECTORY)\$(EXENAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(EXENAME) ..\..\..\bin\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(PDBNAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(PDBNAME) ..\..\..\bin\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\apatch\makefile.inc ===
EXENAME=apatch.exe
PDBNAME=apatch.pdb

COPYTOBIN:
  @if exist obj\$(TARGET_DIRECTORY)\$(EXENAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(EXENAME) ..\..\..\bin\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(PDBNAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(PDBNAME) ..\..\..\bin\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\mpatches\makefile.inc ===
EXENAME=mpatches.exe
PDBNAME=mpatches.pdb

COPYTOBIN:
  @if exist obj\$(TARGET_DIRECTORY)\$(EXENAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(EXENAME) ..\..\..\bin\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(PDBNAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(PDBNAME) ..\..\..\bin\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\apatch\apatch.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <windows.h>

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <stdlib.h>
#include <stdio.h>

#include "patchapi.h"
#include "patchprv.h"

void CopyRight( void ) {
    printf(
        "\n"
        "APATCH " PATCH_VERSION_TEXT " Patch Application Utility\n"
        "Copyright (C) Microsoft, 1997-2001\n"
        "\n"
        );
    }


void Usage( void ) {
    printf(
        "Usage:  APATCH PatchFile OldFile TargetNewFile\n\n"
        );
    exit( 1 );
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    UNREFERENCED_PARAMETER( CallbackContext );

    if ( CurrentPosition & 0xFF000000 ) {
        CurrentPosition >>= 8;
        MaximumPosition >>= 8;
        }

    if ( MaximumPosition != 0 ) {
        fprintf( stderr, "\r%3.1f%% complete", ( CurrentPosition * 100.0 ) / MaximumPosition );
        }

    return TRUE;
    }


void __cdecl main( int argc, char *argv[] ) {

    LPSTR OldFileName   = NULL;
    LPSTR PatchFileName = NULL;
    LPSTR NewFileName   = NULL;
    BOOL  Success;
    LPSTR arg;
    int   i;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    CopyRight();

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }

        if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else {
            Usage();
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        }

    DeleteFile( NewFileName );

    if (( _stricmp( OldFileName, "nul"  ) == 0 ) ||
        ( _stricmp( OldFileName, "null" ) == 0 )) {

        OldFileName = NULL;
        }

    Success = ApplyPatchToFileEx(
                  PatchFileName,
                  OldFileName,
                  NewFileName,
                  0,
                  MyProgressCallback,
                  NULL
                  );

    printf( "\n\n" );

    if ( ! Success ) {

        CHAR  ErrorText[ 16 ];
        ULONG ErrorCode = GetLastError();

        sprintf( ErrorText, ( ErrorCode < 0x10000000 ) ? "%d" : "%X", ErrorCode );

        printf( "Failed to create file from patch (%s)\n", ErrorText );

        exit( 1 );
        }

    printf( "OK\n" );
    exit( 0 );

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\apatch\tracing.c ===
//BUGBUG Make sure building with an empty rift table generates the same patch as before rifting

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <windows.h>

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <stdlib.h>
#include <stdio.h>

#include "patchapi.h"

#ifdef TRACING

#define FILESIZE (3000000)

long g_OldFilePosition;
unsigned long g_cLiterals = 0;
unsigned long g_cMatches = 0;
unsigned long g_cMatchBytes = 0;

#if 0   /* distance.xls */
unsigned long cDistances[6000000] = { 0 };
#endif

#ifdef COMPOSITION  /* composition.xls */
#define BUCKET_SIZE (4096)
#define NBUCKETS (FILESIZE / BUCKET_SIZE)
enum { LITERAL, MATCH_OLD, MATCH_NEW, BUCKET_TYPES };
unsigned long cBuckets[NBUCKETS][BUCKET_TYPES] = { { 0,0,0 } };
#endif

#if 0   /* rifts */
#define NO_DISPLACEMENT (333333333)
long iDisplacement[FILESIZE];
#endif

#if 0   /* slots */
#define MAX_SLOTS 500
unsigned long cSlotUsed[MAX_SLOTS];
#endif

typedef struct
{
    unsigned long ulRegionOffset;
    unsigned long ulRegionSize;
    unsigned long ulRegionAddress;
} FILE_REGION;

#define MAX_REGIONS 50

int cRegionsOld = 0;
FILE_REGION RegionsOld[MAX_REGIONS];
int cRegionsNew = 0;
FILE_REGION RegionsNew[MAX_REGIONS];


typedef struct
{
    unsigned long ulNewOffset;
    unsigned long ulOldOffset;
    unsigned long ulMatchLength;
} MATCH_LOG_ENTRY;

#define MAX_MATCH_LOG_ENTRIES (500000)

int cMatchLogEntries = 0;
MATCH_LOG_ENTRY MatchLog[MAX_MATCH_LOG_ENTRIES];


typedef struct _a_POINTER_REMAP
{
    struct _a_POINTER_REMAP *pNext;
    unsigned long ulNewPointer;
    unsigned long ulOldPointer;
    unsigned long ulLength;
} POINTER_REMAP;

POINTER_REMAP *pPointerRemapList;


#ifdef RIFTGEN
static char isRelocEntry[FILESIZE] = { '\0' };

#ifdef RIFTGEN2   /* references */
typedef struct _a_reference
{
    struct _a_reference *pNext;
    long iDisplacement;
} REFERENCE;

static REFERENCE *pReferences[FILESIZE] = { NULL };
#endif
#endif


static int QueryRelocsInRange(unsigned long ulAddress, unsigned long ulLength)
{
    int iRegion;
    unsigned long ulFileOffset;
    int fRelocsFound = FALSE;

    for (iRegion = 0; iRegion < cRegionsOld; iRegion++)
    {
        if ((ulAddress >= RegionsOld[iRegion].ulRegionAddress) &&
            (ulAddress < (RegionsOld[iRegion].ulRegionAddress + RegionsOld[iRegion].ulRegionSize)))
        {
            break;
        }
    }

    if (iRegion != cRegionsOld)
    {
        ulFileOffset = RegionsOld[iRegion].ulRegionOffset + (ulAddress - RegionsOld[iRegion].ulRegionAddress);

        while (ulLength--)
        {
            if (isRelocEntry[ulFileOffset])
            {
                fRelocsFound = TRUE;
                break;
            }

            ulFileOffset++;
            ulAddress++;
        }
    }

    return(fRelocsFound);
}


static void DisplayMatchLog(void)
{
    int iMatchLogEntry;
    unsigned long ulNewOffset;
    unsigned long ulOldOffset;
    int iNewFileRegion;
    int iOldFileRegion;
    unsigned long ulMatchLength;
    unsigned long ulLocalLength;
    unsigned long ulNewDisplacement;
    unsigned long ulOldDisplacement;
    POINTER_REMAP *pRemap;
    POINTER_REMAP **ppBacklink;
    unsigned long ulNewPointer;
    unsigned long ulOldPointer;
    long lLastDisplacement;

    if (cMatchLogEntries == 0)
    {
        return;
    }

    pPointerRemapList = NULL;

    for (iMatchLogEntry = 0; iMatchLogEntry < cMatchLogEntries; iMatchLogEntry++)
    {
        ulNewOffset = MatchLog[iMatchLogEntry].ulNewOffset;
        ulOldOffset = MatchLog[iMatchLogEntry].ulOldOffset;
        ulMatchLength = MatchLog[iMatchLogEntry].ulMatchLength;

        while (ulMatchLength)               /* until all is done */
        {
            ulLocalLength = ulMatchLength;  /* might get clipped */

            /* locate corresponding new file region to get it's address */

            for (iNewFileRegion = 0; iNewFileRegion < cRegionsNew; iNewFileRegion++)
            {
                if ((ulNewOffset >= RegionsNew[iNewFileRegion].ulRegionOffset) &&
                    (ulNewOffset < (RegionsNew[iNewFileRegion].ulRegionOffset + RegionsNew[iNewFileRegion].ulRegionSize)))
                {
                    break;
                }
            }

            if (iNewFileRegion == cRegionsNew)
            {
                goto dontcare;
            }

            /* clip if match spans beyond this region */

            ulNewDisplacement = ulNewOffset - RegionsNew[iNewFileRegion].ulRegionOffset;
            ulNewPointer = RegionsNew[iNewFileRegion].ulRegionAddress + ulNewDisplacement;

            if (ulLocalLength > (RegionsNew[iNewFileRegion].ulRegionSize - ulNewDisplacement))
            {
                ulLocalLength = (RegionsNew[iNewFileRegion].ulRegionSize - ulNewDisplacement);
            }

            /* locate corresponding old file region to get it's address */

            for (iOldFileRegion = 0; iOldFileRegion < cRegionsOld; iOldFileRegion++)
            {
                if ((ulOldOffset >= RegionsOld[iOldFileRegion].ulRegionOffset) &&
                    (ulOldOffset < (RegionsOld[iOldFileRegion].ulRegionOffset + RegionsOld[iOldFileRegion].ulRegionSize)))
                {
                    break;
                }
            }

            if (iOldFileRegion == cRegionsOld)
            {
                goto dontcare;
            }

            /* clip if match spans beyond this region */

            ulOldDisplacement = ulOldOffset - RegionsOld[iOldFileRegion].ulRegionOffset;
            ulOldPointer = RegionsOld[iOldFileRegion].ulRegionAddress + ulOldDisplacement;

            if (ulLocalLength > (RegionsOld[iOldFileRegion].ulRegionSize - ulOldDisplacement))
            {
                ulLocalLength = (RegionsOld[iOldFileRegion].ulRegionSize - ulOldDisplacement);
            }

            /* see if any relocs in the range */

            if (QueryRelocsInRange(ulOldPointer, ulLocalLength))
            {
                /* sorted insertion of this new remap into the list */

                ppBacklink = &pPointerRemapList;

                while (*ppBacklink != NULL)
                {
                    if ((*ppBacklink)->ulOldPointer > ulOldPointer)
                    {
                        break;
                    }

                    ppBacklink = &((*ppBacklink)->pNext);
                }

                pRemap = GlobalAlloc( GMEM_FIXED, sizeof(POINTER_REMAP) );

                pRemap->ulNewPointer = ulNewPointer;
                pRemap->ulOldPointer = ulOldPointer;
                pRemap->ulLength = ulLocalLength;

                pRemap->pNext = *ppBacklink;
                *ppBacklink = pRemap;
            }

            /* move on to next match or fragment */

            ulNewOffset   += ulLocalLength;
            ulOldOffset   += ulLocalLength;
            ulMatchLength -= ulLocalLength;
        }
dontcare:
        NULL;    //BUGBUG entertain compiler bug: label must have a statement
    }

    printf("%08X\n", RegionsOld[ 0 ].ulRegionAddress);

    lLastDisplacement = 0;

    for (pRemap = pPointerRemapList; pRemap != NULL; pRemap = pRemap->pNext)
    {
        if (lLastDisplacement != (long) (pRemap->ulNewPointer - pRemap->ulOldPointer))
        {
            lLastDisplacement = pRemap->ulNewPointer - pRemap->ulOldPointer;

            printf("%08X %08X\n", pRemap->ulOldPointer, pRemap->ulNewPointer);
        }
    }
}

#endif


void CopyRight( void ) {
    MessageBox(
        NULL,
        "\n"
        "APATCH 0.15 Patch Application Utility\n"
        "Copyright (C) Microsoft, 1997\n"
        "\n",
        "APATCH Copyright",
        MB_OK);
    }


void Usage( void ) {
    MessageBox(NULL,
        "Usage:  APATCH PatchFile OldFile TargetNewFile\n\n",
        "APATCH Usage",
        MB_OK);
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    UNREFERENCED_PARAMETER( CallbackContext );

    if ( CurrentPosition & 0xFF000000 ) {
        CurrentPosition >>= 8;
        MaximumPosition >>= 8;
        }

    if ( MaximumPosition != 0 ) {
//BUGBUG guigauge: printf( "\r%3d%% complete", ( CurrentPosition * 100 ) / MaximumPosition );
        }

    return TRUE;
    }


int StrChr( char *psz, char c )
{
    while (*psz)
    {
        if (*psz++ == c)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}


int __cdecl main( int argc, char *argv[] ) {

    LPSTR OldFileName   = NULL;
    LPSTR PatchFileName = NULL;
    LPSTR NewFileName   = NULL;
    BOOL  Success;
    LPSTR arg;
    int   i;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    //BUGBUG CopyRight();

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( StrChr( arg, '?' )) {
            Usage();
            goto bail;
            }

        if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else {
            Usage();
            goto bail;
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        goto bail;
        }

    DeleteFile( NewFileName );

#ifdef TRACING
#if 0   /* rifts */
    {
        long filepos;

        for (filepos = 0; filepos < FILESIZE; filepos++)
        {
            iDisplacement[filepos] = NO_DISPLACEMENT;
        }
    }
#endif
#endif

    Success = ApplyPatchToFileEx(
                  PatchFileName,
                  OldFileName,
                  NewFileName,
                  0,
                  MyProgressCallback,
                  NULL
                  );

    if ( ! Success ) {

        CHAR  ErrorText[ 16 ];
        ULONG ErrorCode = GetLastError();
        CHAR  Message[100];

        wsprintf( ErrorText, ( ErrorCode < 0x10000000 ) ? "%d" : "%X", ErrorCode );

        wsprintf( Message, "Failed to create file from patch (%s)\n", ErrorText );

        MessageBox( NULL, Message, "APATCH Failed", MB_OK );

        return( 1 );
        }

#ifdef TRACING
    {
#ifdef COMPOSITION   /* composition.xls */
        {
            int iBucket;

            for (iBucket = 0; iBucket < NBUCKETS; iBucket++)
            {
                if ((cBuckets[iBucket][LITERAL] || cBuckets[iBucket][MATCH_OLD] || cBuckets[iBucket][MATCH_NEW]))
                {
                    printf("%9lu %9lu %9lu %9lu\n",
                        iBucket * BUCKET_SIZE,
                        cBuckets[iBucket][LITERAL],
                        cBuckets[iBucket][MATCH_OLD],
                        cBuckets[iBucket][MATCH_NEW]);
                }
            }
        }
#endif

#if 0
        printf("%9lu bytes from literals\n", g_cLiterals);
        printf("%9lu bytes from %lu matches\n", g_cMatchBytes, g_cMatches);
        printf("%9lu bytes total\n", g_cLiterals + g_cMatchBytes);
#endif

#if 0   /* distance.xls */
        {
            int iDistance;

            for (iDistance = 0; iDistance < (sizeof(cDistances)/sizeof(cDistances[0])); iDistance++)
            {
                if (cDistances[iDistance] != 0)
                {
                    printf("%9ld   %9ld\n", iDistance, cDistances[iDistance]);
                }
            }
        }
#endif

#if 0   /* rifts */
        {
            long filepos;
            long iLastDisplacement = NO_DISPLACEMENT;

            for (filepos = 0; filepos < FILESIZE; filepos++)
            {
                if (iDisplacement[filepos] != NO_DISPLACEMENT)
                {
                    if (iLastDisplacement != iDisplacement[filepos])
                    {
                        iLastDisplacement = iDisplacement[filepos];

                        printf("%9lu %9ld\n", filepos, iDisplacement[filepos]);
                    }
                }
            }
        }
#endif

#if 0   /* slots */
        {  
            int slot;

            for (slot = 0; slot < MAX_SLOTS; slot++)
            {
                if (cSlotUsed[slot])
                {
                    printf("%5d  %9ld\n", slot, cSlotUsed[slot]);
                }
            }
        }
#endif

#ifdef RIFTGEN2   /* generating faked references for relrifts file */
        {   
            int index;
            REFERENCE *pReference, *pKill;
            int iLast = 0;
            int cEntries = 0;
            int cEntriesHit = 0;
            int iBest;

            for (index = 0; index < FILESIZE; index++)
            {
                pReference = pReferences[index];

                if (isRelocEntry[index])
                {
                    cEntries++;
                }

                if (pReference != NULL)
                {
                    if (isRelocEntry[index])
                    {
                        cEntriesHit++;
                    }

                    if (pReference->pNext != NULL)                  /* multiple values */
                    {
                        /* knowing the number of reloc entries interested could help here */

                        /* see if the last value is one of the choices */

                        while (pReference)
                        {
                            if (pReference->iDisplacement == iLast)
                            {
                                goto found;
                            }

                            pReference = pReference->pNext;
                        }

                        /* choose the value nearest the last value */

                        pReference = pReferences[index];
                        
                        while (pReference != NULL)
                        {
                            if (abs(pReference->iDisplacement - iLast) < abs(iBest - iLast))
                            {
                                iBest = pReference->iDisplacement;
                            }

                            pReference = pReference->pNext;
                        }

                        iLast = iBest;
                        printf("%d %d\n", index, iLast);

found:                  
                        /* now free the list */

                        pReference = pReferences[index];
                        
                        while (pReference != NULL)
                        {
                            pKill = pReference;
                            pReference = pReference->pNext;
                            GlobalFree(pKill);
                        }
                    }
                    else
                    {
                        if (iLast != pReference->iDisplacement)    /* a simple rift */
                        {
                            iLast = pReference->iDisplacement;
                            printf("%d %d\n", index, iLast);
                        }

                        GlobalFree(pReference);
                    }
                }
            }

            //fprintf(stderr, "%d hit of %d total relocation targets\n", cEntriesHit, cEntries);
        }
#endif

        DisplayMatchLog();
    }
#endif

//    MessageBox( NULL, "OK\n", "APATCH Done", MB_OK );

bail:

    return( 0 );

    }

#ifdef TRACING

void TracingSetOldFilePosition(long oldpos)
{
    g_OldFilePosition = oldpos;
}


void TracingLiteral(long bufpos, byte c)
{
#ifdef COMPOSITION   /* composition.xls */
    int iBucket = bufpos / BUCKET_SIZE;

    cBuckets[iBucket][LITERAL]++;
#endif

    g_cLiterals++;

#ifdef DECO_DETAILS   /* trace */
    printf("%08lX: %02X\n", bufpos, (byte) c);
#endif
}


void TracingMatch(long bufpos,long srcpos,long window,int length,int slot)
{
    static long iLastDisplacement = -1;

    g_cMatches++;
    g_cMatchBytes += length;

#if 0   /* slots */
    if (slot < MAX_SLOTS)
    {
        cSlotUsed[slot]++;
    }
    else
    {
        printf("Slot number out of range (%d)\n", slot);
    }
#endif

    if (srcpos < g_OldFilePosition)
    {
#ifdef COMPOSITION   /* composition.xls */
        int iBucket = bufpos / BUCKET_SIZE;
        int eBucket = (bufpos + length - 1) / BUCKET_SIZE;

        if (iBucket == eBucket)
        {
            cBuckets[iBucket][MATCH_NEW] += length;
        }
        else
        {
            long length1 = (eBucket * BUCKET_SIZE) - bufpos;
            cBuckets[iBucket][MATCH_NEW] += length1;
            cBuckets[eBucket][MATCH_NEW] += (length - length1);
        }
#endif

#ifdef DECO_DETAILS   /* trace */
        {
            int iDistance = bufpos - srcpos;

            printf("%08lX..%08lX:  %08lX..%08lX  (%d,%u)\n",  /* new file refs no [...] */
                bufpos,
                bufpos + length - 1,
                srcpos,
                srcpos + length - 1,
                -iDistance,
                length);
        }
#endif

#if 0
        if (iLastDisplacement != (srcpos - bufpos))
        {
            iLastDisplacement = (srcpos - bufpos);

            printf("%9ld %9ld %9ld\n",
                bufpos,
                srcpos,
                srcpos - bufpos);
        }
#endif
    }
    else
    {
#ifdef COMPOSITION   /* composition.xls */
        int iBucket = bufpos / BUCKET_SIZE;
        int eBucket = (bufpos + length - 1) / BUCKET_SIZE;

        if (iBucket == eBucket)
        {
            cBuckets[iBucket][MATCH_OLD] += length;
        }
        else
        {
            long length1 = (eBucket * BUCKET_SIZE) - bufpos;
            cBuckets[iBucket][MATCH_OLD] += length1;
            cBuckets[eBucket][MATCH_OLD] += (length - length1);
        }
#endif

        if ((cMatchLogEntries != 0) &&
            ((MatchLog[cMatchLogEntries - 1].ulNewOffset + MatchLog[cMatchLogEntries - 1].ulMatchLength) == (unsigned long) bufpos) &&
            ((MatchLog[cMatchLogEntries - 1].ulOldOffset + MatchLog[cMatchLogEntries - 1].ulMatchLength) == (unsigned long) (srcpos - g_OldFilePosition)))
        {
            MatchLog[cMatchLogEntries - 1].ulMatchLength += length;
        }
        else if (cMatchLogEntries < MAX_MATCH_LOG_ENTRIES)
        {
            MatchLog[cMatchLogEntries].ulNewOffset = bufpos;
            MatchLog[cMatchLogEntries].ulOldOffset = srcpos - g_OldFilePosition;
            MatchLog[cMatchLogEntries].ulMatchLength = length;
            cMatchLogEntries++;
        }

#ifdef DECO_DETAILS   /* trace */
        {
            int iDistance = bufpos - srcpos + window;

            printf("%08lX..%08lX: [%08lX..%08lX] (%d,%u)\n",  /* old file refs in [...] */
                bufpos,
                bufpos + length - 1,
                srcpos - g_OldFilePosition,
                srcpos - g_OldFilePosition + length - 1,
                -iDistance,
                length);
        }
#endif

#if 0   /* rifts */
        {
            int index;

            for (index = 0; index < length; index++)
            {
                iDisplacement[bufpos + index] = bufpos - srcpos + g_OldFilePosition;
            }
        }
#endif

#if 0
        if (iLastDisplacement != (bufpos - srcpos + g_OldFilePosition))
        {
            iLastDisplacement = (bufpos - srcpos + g_OldFilePosition);

            printf("%9ld %9ld %9ld\n",
                bufpos,
                srcpos - g_OldFilePosition,
                bufpos - srcpos + g_OldFilePosition);
        }
#endif

#ifdef RIFTGEN2   /* references */
        {
            int index;
            REFERENCE *pReference;
            long iOldFilePosition;

            for (index = 0; index < length; index++)
            {
                iOldFilePosition = srcpos - g_OldFilePosition + index;

                if (isRelocEntry[iOldFilePosition])
                {
                    pReference = GlobalAlloc(GMEM_FIXED, sizeof(REFERENCE));

                    pReference->pNext = pReferences[iOldFilePosition];
                    pReferences[iOldFilePosition] = pReference;
                    pReference->iDisplacement = bufpos - srcpos + g_OldFilePosition;
                }
            }
        }
#endif
    }

#if 0   /* distance.xls */
    {
        int iDistance = bufpos - srcpos + window;

        if ((iDistance < 1) || (iDistance >= (sizeof(cDistances)/sizeof(cDistances[0]))))
        {
            printf("That's a strange distance.\n");
        }
        else
        {
            cDistances[iDistance]++;
        }
    }
#endif
}

#ifdef RIFTGEN
void TracingSetIsRelocEntry(ULONG OldFileOffset, ULONG Va)
{
//    printf("offset 0x%08X is Va 0x%08X\n", OldFileOffset, Va);
//      ie, "offset 0x00000DF9 is Va 0x703B17F9" when base=0x703B0000

    isRelocEntry[OldFileOffset] = '\1';
}
#endif


void TracingReportAddresses(int FileNumber, ULONG FileOffset, ULONG Size, ULONG Address)
{
    if ( FileNumber )
    {
        RegionsNew[cRegionsNew].ulRegionOffset = FileOffset;
        RegionsNew[cRegionsNew].ulRegionSize = Size;
        RegionsNew[cRegionsNew].ulRegionAddress = Address;
        cRegionsNew++;
    }
    else
    {
        RegionsOld[cRegionsOld].ulRegionOffset = FileOffset;
        RegionsOld[cRegionsOld].ulRegionSize = Size;
        RegionsOld[cRegionsOld].ulRegionAddress = Address;
        cRegionsOld++;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\mpatch\mpatch.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )
#include <windows.h>
#include <wincrypt.h>
#pragma warning( disable: 4201 )
#include <imagehlp.h>
#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#include "patchapi.h"
#include "patchprv.h"
#include "patchlzx.h"

void CopyRight( void ) {
    printf(
        "\n"
        "MPATCH " PATCH_VERSION_TEXT " Patch Creation Utility\n"
        "Copyright (C) Microsoft, 1997-2001\n"
        "\n"
        );
    }


void __declspec( noreturn ) Usage( void ) {

    printf(
"Usage:  MPATCH [options] OldFile[;OldFile2[;OldFile3]] NewFile TargetPatchFile\n"
"\n"
"        Options:\n"
"\n"
"          -NOBINDFIX   Turn off automatic compensation for bound imports in\n"
"                       the the old file.  The default is to ignore binding\n"
"                       data in the old file during patch creation which will\n"
"                       cause the application of the patch to succeed whether\n"
"                       or not the old file on the target machine is bound, not\n"
"                       bound, or even bound to different import addresses.\n"
"                       If the files are not Win32 binaries, this option is\n"
"                       ignored and has no effect.\n"
"\n"
"          -NOLOCKFIX   Turn off automatic compensation for smashed lock prefix\n"
"                       instructions.  If the files are not Win32 binaries,\n"
"                       this option is ignored and has no effect.\n"
"\n"
"          -NOREBASE    Turn off automatic internal rebasing of old file to new\n"
"                       file's image base address.  If the files are not Win32\n"
"                       binaries, this option is ignored and has no effect.\n"
"\n"
"          -NORESTIME   Turn off automatic fixup of resource section timestamps\n"
"                       (ignored if not Win32 binaries).\n"
"\n"
"          -NOCHECKSUM  Enable automatic compensation for old file's checksums.\n"
"\n"
"          -NOSTORETIME Don't store the timestamp of the new file in the patch\n"
"                       file.  Instead, set the timestamp of the patch file to\n"
"                       the timestamp of the new file.\n"
"\n"
"          -IGNORE:Offset,Length[,FileNumber]\n"
"\n"
"                       Ignore a range of bytes in the OldFile because those\n"
"                       bytes might be different in the old file being patched\n"
"                       on the target machine.\n"
"\n"
"          -RETAIN:Offset,Length[,OffsetInNewFile[,FileNumber]]\n"
"\n"
"                       When applying the patch, preserve the range of bytes in\n"
"                       the old file and copy them to the new file at the given\n"
"                       OffsetInNewFile.\n"
"\n"
#ifdef TESTCODE
"          -RIFTINFO:FileName[,FileNumber]\n"
"\n"
"                       Use rift table information from FileName (produced from\n"
"                       riftinfo.exe).\n"
"\n"
#endif
"          -FAILBIGGER  If patch file is bigger than simple compressed file,\n"
"                       don't create the patch file (takes longer).\n"
"\n"
"          -FAILIFSAME  If old and new files are the same (ignoring binding\n"
"                       differences, etc), don't create the patch file.\n"
"\n"
"          -DOCOMPARE   After patch creation, perform ordinary compression to\n"
"                       determine reference size for patch savings comparison.\n"
"\n"
"          -NOPROGRESS  Don't display percent complete while building patch.\n"
"\n"
"          -NEWSYMPATH:PathName[;PathName]\n"
"\n"
"                       For NewFile, search for symbol file(s) in these path\n"
"                       locations (recursive search each path until found).\n"
"                       The default is to search for symbol files(s) starting\n"
"                       in the same directory as the NewFile.\n"
"\n"
"          -OLDSYMPATH:PathName[;PathName][,FileNumber]\n"
"\n"
"                       For OldFile, search for symbol file(s) in these path\n"
"                       locations (recursive search each path until found).\n"
"                       The default is to search for symbol files(s) starting\n"
"                       in the same directory as the OldFile.\n"
"\n"
"          -UNDECORATED After matching decorated symbol names, match remaining\n"
"                       symbols using undecorated names.\n"
"\n"
"          -NOSYMS      Don't use debug symbol files when creating the patch.\n"
"\n"
"          -NOSYMFAIL   Don't fail to create patch if symbols cannot be loaded.\n"
"\n"
"          -NOSYMWARN   Don't warn if symbols can't be found or don't match the\n"
"                       corresponding file (symbol checksum mismatch).\n"
"\n"
"          -USEBADSYMS  Rather than ignoring symbols if the checksums don't\n"
"                       match the corresponding files, use the bad symbols.\n"
"\n"
"          -E8          Force LZX E8 call translation for x86 binaries\n"
"                       (better if no symbols and files are very different).\n"
"\n"
"          -NOE8        Force no LZX E8 call translation for x86 binaries.\n"
"                       (better when using symbols or files are very similar).\n"
"\n"
"                       If neither -E8 or -NOE8 are specified, and the files\n"
"                       are x86 binaries, the patch will be built internally\n"
"                       twice and the smaller will be chosen for output.\n"
"\n"
"          -WINDOW:nn   Limit the LZX compression memory window to 2^nn bytes\n"
"                       (nn is a power of two >= 17: 128KB).  Patch creation\n"
"                       memory requirement may be 10X this amount, but patch\n"
"                       applier will only this amount of memory plus the size\n"
"                       of the output file (requires version 5.2 or higher).\n"
"\n"
"          -MSPATCHA_WIN2000  Assure the patch file can be applied with version\n"
"                       1.94 of MSPATCHA.DLL (Windows 2000).  May increase size\n"
"                       of patch file if old and new file sizes combined are\n"
"                       larger than 8MB.\n"
"\n"
"          -MSPATCHA_WINXP    Assure the patch file can be used with version\n"
"                       5.1 of MSPATCHA.DLL (Windows XP).  May increase size\n"
"                       of patch file if old and new file sizes combined are\n"
"                       larger than 32MB.\n"
"\n"
"          MPATCH will also look for environment variables named \"MPATCH\"\n"
"          followed by an underscore and the name of the option.  Command line\n"
"          specified options override environment variable options.  Examples:\n"
"\n"
"              MPATCH_NOPROGRESS=1\n"
"              MPATCH_NEWSYMPATH=c:\\winnt\\symbols;\\\\server\\share\\symbols\n"
"\n"
        );
    exit( 1 );
    }


BOOL bNoProgress;
BOOL bNoSymWarn;
BOOL bUseBadSyms;


DWORDLONG
GetFileSizeByName(
    IN LPCSTR FileName
    )
    {
    DWORDLONG FileSizeReturn;
    ULONG     FileSizeHigh;
    ULONG     FileSizeLow;
    HANDLE    hFile;

    FileSizeReturn = 0xFFFFFFFFFFFFFFFF;

    hFile = CreateFile(
                FileName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile != INVALID_HANDLE_VALUE ) {

        FileSizeLow = GetFileSize( hFile, &FileSizeHigh );

        if (( FileSizeLow != 0xFFFFFFFF ) || ( GetLastError() == NO_ERROR )) {

            FileSizeReturn = ((DWORDLONG)FileSizeHigh << 32 ) | FileSizeLow;
            }

        CloseHandle( hFile );
        }

    return FileSizeReturn;
    }


BOOL
GetMpatchEnvironString(
    IN  LPCSTR VarName,
    OUT LPSTR  Buffer,
    IN  DWORD  BufferSize
    )
    {
    CHAR EnvironName[ 256 ];

    sprintf( EnvironName, "mpatch_%s", VarName );

    if ( GetEnvironmentVariable( EnvironName, Buffer, BufferSize )) {

        return TRUE;
        }

    return FALSE;
    }


BOOL
GetMpatchEnvironValue(
    IN  LPCSTR VarName
    )
    {
    CHAR LocalBuffer[ 256 ];

    if ( GetMpatchEnvironString( VarName, LocalBuffer, sizeof( LocalBuffer ))) {

        if (( *LocalBuffer == '0' ) && ( strtoul( LocalBuffer, NULL, 0 ) == 0 )) {
            return FALSE;
            }

        return TRUE;
        }

    return FALSE;
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    UNREFERENCED_PARAMETER( CallbackContext );

    if ( MaximumPosition != 0 ) {
        fprintf( stderr, "\r%6.2f%% complete", ( CurrentPosition * 100.0 ) / MaximumPosition );
        }

    return TRUE;
    }


BOOL
CALLBACK
MySymLoadCallback(
    IN ULONG  WhichFile,
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    )
    {
    LPCSTR *FileNameArray = CallbackContext;
    LPCSTR SymTypeText;

    if (( SymType == SymNone ) || ( SymType == SymExport )) {

        //
        //  Symbols could not be found.
        //

        if ( ! bNoSymWarn ) {

            printf(
                "\n"
                "WARNING: no debug symbols for %s\n\n",
                FileNameArray[ WhichFile ]
                );
            }

        return TRUE;
        }

    //
    //  Note that the Old file checksum is the checksum AFTER normalization,
    //  so if the original .dbg file was updated with bound checksum, the
    //  old file's checksum will not match the symbol file's checksum.  But,
    //  binding a file does not change its TimeDateStamp, so that should be
    //  a valid comparison.  But, .sym files don't have a TimeDateStamp, so
    //  the SymbolFileTimeDate may be zero.  If either the checksums match
    //  or the timedate stamps match, we'll say its valid.
    //

    if (( ImageFileCheckSum == SymbolFileCheckSum ) ||
        ( ImageFileTimeDate == SymbolFileTimeDate )) {

        return TRUE;
        }

    if ( ! bNoSymWarn ) {

        switch ( SymType ) {
            case SymNone:     SymTypeText = "No";       break;
            case SymCoff:     SymTypeText = "Coff";     break;
            case SymCv:       SymTypeText = "CodeView"; break;
            case SymPdb:      SymTypeText = "Pdb";      break;
            case SymExport:   SymTypeText = "Export";   break;
            case SymDeferred: SymTypeText = "Deferred"; break;
            case SymSym:      SymTypeText = "Sym";      break;
            default:          SymTypeText = "Unknown";  break;
            }

        printf(
            "\n"
            "WARNING: %s symbols %s don't match %s:\n"
            "    symbol file checksum (%08X) does not match image (%08X), and\n"
            "    symbol file timedate (%08X) does not match image (%08X).\n\n",
            SymTypeText,
            SymbolFileName,
            FileNameArray[ WhichFile ],
            SymbolFileCheckSum,
            ImageFileCheckSum,
            SymbolFileTimeDate,
            ImageFileTimeDate
            );
        }

    return bUseBadSyms;
    }


PRIFT_TABLE RiftTableArray[ 256 ];
PATCH_OLD_FILE_INFO_A OldFileInfo[ 256 ];
LPSTR OldFileSymPathArray[ 256 ];
LPSTR NewFileSymPath;
LPSTR FileNameArray[ 257 ];

PATCH_OPTION_DATA OptionData = { sizeof( PATCH_OPTION_DATA ) };
PATCH_OPTION_DATA *OptionDataPointer = &OptionData;

CHAR TextBuffer[ 65000 ];

#pragma data_seg( ".shared" )
LONG SharedInstanceCounter = 0;
#pragma data_seg()

LONG WINAPI _InterlockedExchangeAdd( LONG*, LONG );
#pragma intrinsic( _InterlockedExchangeAdd )

void __cdecl main( int argc, char *argv[] ) {

    LPSTR OldFileName    = NULL;
    LPSTR NewFileName    = NULL;
    LPSTR PatchFileName  = NULL;

    ULONG OptionFlags    = PATCH_OPTION_USE_LZX_BEST  |
                           PATCH_OPTION_USE_LZX_LARGE |
                           PATCH_OPTION_INTERLEAVE_FILES;
    BOOL  Success;
    LPSTR arg;
    LPSTR p, q;
    LPSTR FileName;
    int   i, j, n;
    ULONG OldOffset;
    ULONG NewOffset;
    ULONG Length;
    ULONG FileNum;
    ULONG OldFileCount;
    ULONG ErrorCode;
    ULONG NewFileSize;
    ULONG PatchFileSize;
    ULONG OldFileRva;
    ULONG NewFileRva;
    BOOL  bNoCompare = TRUE;
    BOOL  bNoAffinity = FALSE;
    BOOL  Force194 = FALSE;
    BOOL  Force197 = FALSE;
    ULONG WindowSizePower = 0;
    FILE  *RiftFile;
    LPSTR FileNamePart;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    CopyRight();

    OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_PE_IRELOC_2;   // unless explicitly disabled
    OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_PE_RESOURCE_2; // unless explicitly disabled

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }
        }

    //
    //  First get environment arguments because command-line args will
    //  override them.
    //

    if ( GetMpatchEnvironValue( "e8" )) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_A;
        }

    if ( GetMpatchEnvironValue( "noe8" )) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_B;
        }

    if ( GetMpatchEnvironValue( "mspatch194compat" )) {
        Force194 = TRUE;
        }

    if ( GetMpatchEnvironValue( "mspatcha_win2000" )) {
        Force194 = TRUE;
        }

    if ( GetMpatchEnvironValue( "mspatch197compat" )) {
        Force197 = TRUE;
        }

    if ( GetMpatchEnvironValue( "mspatcha_winxp" )) {
        Force197 = TRUE;
        }

    if ( GetMpatchEnvironValue( "nobindfix" )) {
        OptionFlags |= PATCH_OPTION_NO_BINDFIX;
        }

    if ( GetMpatchEnvironValue( "nolockfix" )) {
        OptionFlags |= PATCH_OPTION_NO_LOCKFIX;
        }

    if ( GetMpatchEnvironValue( "norebase" )) {
        OptionFlags |= PATCH_OPTION_NO_REBASE;
        }

    if ( GetMpatchEnvironValue( "norestime" )) {
        OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
        }

    if ( GetMpatchEnvironValue( "nochecksum" )) {
        OptionFlags |= PATCH_OPTION_NO_CHECKSUM;
        }

    if ( GetMpatchEnvironValue( "nostoretime" )) {
        OptionFlags |= PATCH_OPTION_NO_TIMESTAMP;
        }

    if ( GetMpatchEnvironValue( "failbigger" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
        }

    if ( GetMpatchEnvironValue( "failifbigger" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
        }

    if ( GetMpatchEnvironValue( "failsame" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
        }

    if ( GetMpatchEnvironValue( "failifsame" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
        }

    if ( GetMpatchEnvironValue( "nocompare" )) {
        bNoCompare = TRUE;
        }

    if ( GetMpatchEnvironValue( "docompare" )) {
        bNoCompare = FALSE;
        }

    if ( GetMpatchEnvironValue( "compare" )) {
        bNoCompare = FALSE;
        }

    if ( GetMpatchEnvironValue( "noprogress" )) {
        bNoProgress = TRUE;
        }

    if ( GetMpatchEnvironValue( "undecorated" )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_UNDECORATED_TOO;
        }

    if ( GetMpatchEnvironValue( "nosyms" )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_IMAGEHLP;
        }

    if ( GetMpatchEnvironValue( "nosymfail" )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_FAILURES;
        }

    if ( GetMpatchEnvironValue( "nosymwarn" )) {
        bNoSymWarn = TRUE;
        }

    if ( GetMpatchEnvironValue( "noaffinity" )) {
        bNoAffinity = TRUE;
        }

    if ( GetMpatchEnvironValue( "usebadsyms" )) {
        bUseBadSyms = TRUE;
        }

    if ( GetMpatchEnvironValue( "notransformrelocs" )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELOCS;
        }

    if ( GetMpatchEnvironValue( "notransformresource" )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RESOURCE;
        }

    if ( GetMpatchEnvironValue( "notransformimports" )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_IMPORTS;
        }

    if ( GetMpatchEnvironValue( "notransformexports" )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_EXPORTS;
        }

    if ( GetMpatchEnvironValue( "notransformreljmps" )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELJMPS;
        }

    if ( GetMpatchEnvironValue( "notransformrelcalls" )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELCALLS;
        }

    if ( GetMpatchEnvironString( "window", TextBuffer, sizeof( TextBuffer ))) {
        WindowSizePower = strtoul( TextBuffer, NULL, 0 );
        }

    if ( GetMpatchEnvironString( "ignore", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q != NULL ) {

            *q = 0;

            OldOffset = strtoul( p, NULL, 0 );

            p = q + 1;
            q = strchr( p, ',' );

            if ( q ) {
                *q = 0;
                }

            Length = strtoul( p, NULL, 0 );

            FileNum = 1;

            if ( q ) {

                p = q + 1;

                FileNum = strtoul( p, NULL, 0 );

                if ( FileNum == 0 ) {
                    FileNum = 1;
                    }
                }

            if ( FileNum <= 255 ) {

                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray = realloc(
                                                                  OldFileInfo[ FileNum - 1 ].IgnoreRangeArray,
                                                                  OldFileInfo[ FileNum - 1 ].IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE ) + sizeof( PATCH_IGNORE_RANGE )
                                                                  );

                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeCount++;

                }
            }
        }

    if ( GetMpatchEnvironString( "retain", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q != NULL ) {

            *q = 0;

            OldOffset = strtoul( p, NULL, 0 );

            p = q + 1;
            q = strchr( p, ',' );

            if ( q ) {
                *q = 0;
                }

            Length = strtoul( p, NULL, 0 );

            NewOffset = OldOffset;

            FileNum = 1;

            if ( q ) {

                p = q + 1;

                q = strchr( p, ',' );

                if ( q ) {
                    *q = 0;
                    }

                NewOffset = strtoul( p, NULL, 0 );

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }
                }

            if ( FileNum <= 255 ) {

                OldFileInfo[ FileNum - 1 ].RetainRangeArray = realloc(
                                                                  OldFileInfo[ FileNum - 1 ].RetainRangeArray,
                                                                  OldFileInfo[ FileNum - 1 ].RetainRangeCount * sizeof( PATCH_RETAIN_RANGE ) + sizeof( PATCH_RETAIN_RANGE )
                                                                  );

                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInNewFile = NewOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].RetainRangeCount++;
                }
            }
        }

    if ( GetMpatchEnvironString( "riftinfo", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum <= 255 ) {

            RiftTableArray[ FileNum - 1 ] = malloc( sizeof( RIFT_TABLE ));

            if ( RiftTableArray[ FileNum - 1 ] == NULL ) {
                printf( "Out of memory\n" );
                exit( 1 );
                }

            RiftTableArray[ FileNum - 1 ]->RiftEntryCount = 0;
            RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = 0;
            RiftTableArray[ FileNum - 1 ]->RiftEntryArray = NULL;
            RiftTableArray[ FileNum - 1 ]->RiftUsageArray = NULL;

            RiftFile = fopen( FileName, "rt" );

            if ( RiftFile == NULL ) {
                printf( "Could not open %s\n", FileName );
                exit( 1 );
                }

            while ( fgets( TextBuffer, sizeof( TextBuffer ), RiftFile )) {

                //
                //  Line looks like "00001456 00002345" where each number
                //  is an RVA in hexadecimal and the first column is the
                //  OldFileRva and the second column is the NewFileRva.
                //  Any text beyond column 17 is considered a comment, and
                //  any line that does not begin with a digit is ignored.
                //

                if (( isxdigit( *TextBuffer )) && ( strlen( TextBuffer ) >= 17 )) {

                    OldFileRva = strtoul( TextBuffer,     NULL, 16 );
                    NewFileRva = strtoul( TextBuffer + 9, NULL, 16 );

                    if (( OldFileRva != 0 ) && ( NewFileRva != 0 )) {

                        RiftTableArray[ FileNum - 1 ]->RiftEntryArray = realloc(
                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray,
                            RiftTableArray[ FileNum - 1 ]->RiftEntryCount * sizeof( RIFT_ENTRY ) + sizeof( RIFT_ENTRY )
                            );

                        RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].OldFileRva = OldFileRva;
                        RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].NewFileRva = NewFileRva;
                        RiftTableArray[ FileNum - 1 ]->RiftEntryCount++;

                        }
                    }
                }

            fclose( RiftFile );

            if ( RiftTableArray[ FileNum - 1 ]->RiftEntryCount ) {

                RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = RiftTableArray[ FileNum - 1 ]->RiftEntryCount;

                RiftTableArray[ FileNum - 1 ]->RiftUsageArray = malloc( RiftTableArray[ FileNum - 1 ]->RiftEntryCount );

                if ( RiftTableArray[ FileNum - 1 ]->RiftUsageArray == NULL ) {
                    printf( "Out of memory\n" );
                    exit( 1 );
                    }

                ZeroMemory( RiftTableArray[ FileNum - 1 ]->RiftUsageArray, RiftTableArray[ FileNum - 1 ]->RiftEntryCount );
                }

            OptionData.SymbolOptionFlags |= PATCH_SYMBOL_EXTERNAL_RIFT;

            }
        }

    if ( GetMpatchEnvironString( "oldsympath", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum <= 255 ) {
            OldFileSymPathArray[ FileNum - 1 ] = _strdup( FileName );
            }
        }

    if ( GetMpatchEnvironString( "newsympath", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum == 1 ) {
            NewFileSymPath = _strdup( FileName );
            }
        }

    //
    //  Now process commandline args
    //

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }

        if (( *arg == '-' ) || ( *arg == '/' )) {

            _strlwr( ++arg );

            if ( strcmp( arg, "e8" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_USE_LZX_A;
                }
            else if ( strcmp( arg, "noe8" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_USE_LZX_B;
                }
            else if ( strcmp( arg, "mspatch194compat" ) == 0 ) {
                Force194 = TRUE;
                }
            else if ( strcmp( arg, "mspatcha_win2000" ) == 0 ) {
                Force194 = TRUE;
                }
            else if ( strcmp( arg, "mspatch197compat" ) == 0 ) {
                Force197 = TRUE;
                }
            else if ( strcmp( arg, "mspatcha_winxp" ) == 0 ) {
                Force197 = TRUE;
                }
            else if ( strcmp( arg, "nobindfix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_BINDFIX;
                }
            else if ( strcmp( arg, "bindfix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_BINDFIX;
                }
            else if ( strcmp( arg, "nolockfix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_LOCKFIX;
                }
            else if ( strcmp( arg, "lockfix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_LOCKFIX;
                }
            else if ( strcmp( arg, "norebase" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_REBASE;
                }
            else if ( strcmp( arg, "rebase" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_REBASE;
                }
            else if ( strcmp( arg, "norestime" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "norestimefix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "restime" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "restimefix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "nochecksum" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_CHECKSUM;
                }
            else if ( strcmp( arg, "checksum" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_CHECKSUM;
                }
            else if ( strcmp( arg, "nostoretime" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_TIMESTAMP;
                }
            else if ( strcmp( arg, "storetime" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_TIMESTAMP;
                }
            else if ( strcmp( arg, "failbigger" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "nofailbigger" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "failifbigger" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "nofailifbigger" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "failifsame" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "failsame" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nofailifsame" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nofailsame" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nocompare" ) == 0 ) {
                bNoCompare = TRUE;
                }
            else if ( strcmp( arg, "compare" ) == 0 ) {
                bNoCompare = FALSE;
                }
            else if ( strcmp( arg, "docompare" ) == 0 ) {
                bNoCompare = FALSE;
                }
            else if ( strcmp( arg, "noprogress" ) == 0 ) {
                bNoProgress = TRUE;
                }
            else if ( strcmp( arg, "progress" ) == 0 ) {
                bNoProgress = FALSE;
                }
            else if ( strcmp( arg, "decorated" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_UNDECORATED_TOO;
                }
            else if ( strcmp( arg, "undecorated" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_UNDECORATED_TOO;
                }
            else if ( strcmp( arg, "nosyms" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_IMAGEHLP;
                }
            else if ( strcmp( arg, "syms" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_NO_IMAGEHLP;
                }
            else if ( strcmp( arg, "nosymfail" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_FAILURES;
                }
            else if ( strcmp( arg, "symfail" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_NO_FAILURES;
                }
            else if ( strcmp( arg, "nosymwarn" ) == 0 ) {
                bNoSymWarn = TRUE;
                }
            else if ( strcmp( arg, "symwarn" ) == 0 ) {
                bNoSymWarn = FALSE;
                }
            else if ( strcmp( arg, "noaffinity" ) == 0 ) {
                bNoAffinity = TRUE;
                }
            else if ( strcmp( arg, "usebadsyms" ) == 0 ) {
                bUseBadSyms = TRUE;
                }
            else if ( strcmp( arg, "nousebadsyms" ) == 0 ) {
                bUseBadSyms = FALSE;
                }
            else if ( strcmp( arg, "nobadsyms" ) == 0 ) {
                bUseBadSyms = FALSE;
                }
            else if ( strcmp( arg, "notransformrelocs" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELOCS;
                }
            else if ( strcmp( arg, "notransformresource" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RESOURCE;
                }
            else if ( strcmp( arg, "notransformimports" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_IMPORTS;
                }
            else if ( strcmp( arg, "notransformexports" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_EXPORTS;
                }
            else if ( strcmp( arg, "notransformreljmps" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELJMPS;
                }
            else if ( strcmp( arg, "notransformrelcalls" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELCALLS;
                }
            else if ( memcmp( arg, "window:", 7 ) == 0 ) {

                WindowSizePower = strtoul( arg + 7, NULL, 0 );

                if ( WindowSizePower == 0 ) {
                    Usage();
                    }
                }

            else if ( memcmp( arg, "ignore:", 7 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q == NULL ) {
                    Usage();
                    }

                *q = 0;

                OldOffset = strtoul( p, NULL, 0 );

                p = q + 1;
                q = strchr( p, ',' );

                if ( q ) {
                    *q = 0;
                    }

                Length = strtoul( p, NULL, 0 );

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray = realloc(
                                                                  OldFileInfo[ FileNum - 1 ].IgnoreRangeArray,
                                                                  OldFileInfo[ FileNum - 1 ].IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE ) + sizeof( PATCH_IGNORE_RANGE )
                                                                  );

                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeCount++;

                }
            else if ( memcmp( arg, "retain:", 7 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q == NULL ) {
                    Usage();
                    }

                *q = 0;

                OldOffset = strtoul( p, NULL, 0 );

                p = q + 1;
                q = strchr( p, ',' );

                if ( q ) {
                    *q = 0;
                    }

                Length = strtoul( p, NULL, 0 );

                NewOffset = OldOffset;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    q = strchr( p, ',' );

                    if ( q ) {
                        *q = 0;
                        }

                    NewOffset = strtoul( p, NULL, 0 );

                    if ( q ) {

                        p = q + 1;

                        FileNum = strtoul( p, NULL, 0 );

                        if ( FileNum == 0 ) {
                            FileNum = 1;
                            }
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                OldFileInfo[ FileNum - 1 ].RetainRangeArray = realloc(
                                                                  OldFileInfo[ FileNum - 1 ].RetainRangeArray,
                                                                  OldFileInfo[ FileNum - 1 ].RetainRangeCount * sizeof( PATCH_RETAIN_RANGE ) + sizeof( PATCH_RETAIN_RANGE )
                                                                  );

                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInNewFile = NewOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].RetainRangeCount++;

                }

            else if ( memcmp( arg, "riftinfo:", 9 ) == 0 ) {

                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_EXTERNAL_RIFT;

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                RiftTableArray[ FileNum - 1 ] = malloc( sizeof( RIFT_TABLE ));

                if ( RiftTableArray[ FileNum - 1 ] == NULL ) {
                    printf( "Out of memory\n" );
                    exit( 1 );
                    }

                RiftTableArray[ FileNum - 1 ]->RiftEntryCount = 0;
                RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = 0;
                RiftTableArray[ FileNum - 1 ]->RiftEntryArray = NULL;
                RiftTableArray[ FileNum - 1 ]->RiftUsageArray = NULL;

                RiftFile = fopen( FileName, "rt" );

                if ( RiftFile == NULL ) {
                    printf( "Could not open %s\n", FileName );
                    exit( 1 );
                    }

                while ( fgets( TextBuffer, sizeof( TextBuffer ), RiftFile )) {

                    //
                    //  Line looks like "00001456 00002345" where each number
                    //  is an RVA in hexadecimal and the first column is the
                    //  OldFileRva and the second column is the NewFileRva.
                    //  Any text beyond column 17 is considered a comment, and
                    //  any line that does not begin with a digit is ignored.
                    //

                    if (( isxdigit( *TextBuffer )) && ( strlen( TextBuffer ) >= 17 )) {

                        OldFileRva = strtoul( TextBuffer,     NULL, 16 );
                        NewFileRva = strtoul( TextBuffer + 9, NULL, 16 );

                        if (( OldFileRva + NewFileRva ) != 0 ) {

                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray = realloc(
                                RiftTableArray[ FileNum - 1 ]->RiftEntryArray,
                                RiftTableArray[ FileNum - 1 ]->RiftEntryCount * sizeof( RIFT_ENTRY ) + sizeof( RIFT_ENTRY )
                                );

                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].OldFileRva = OldFileRva;
                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].NewFileRva = NewFileRva;
                            RiftTableArray[ FileNum - 1 ]->RiftEntryCount++;

                            }
                        }
                    }

                fclose( RiftFile );

                if ( RiftTableArray[ FileNum - 1 ]->RiftEntryCount ) {

                    RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = RiftTableArray[ FileNum - 1 ]->RiftEntryCount;

                    RiftTableArray[ FileNum - 1 ]->RiftUsageArray = malloc( RiftTableArray[ FileNum - 1 ]->RiftEntryCount );

                    if ( RiftTableArray[ FileNum - 1 ]->RiftUsageArray == NULL ) {
                        printf( "Out of memory\n" );
                        exit( 1 );
                        }

                    ZeroMemory( RiftTableArray[ FileNum - 1 ]->RiftUsageArray, RiftTableArray[ FileNum - 1 ]->RiftEntryCount );
                    }
                }
            else if ( memcmp( arg, "oldsympath:", 11 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                OldFileSymPathArray[ FileNum - 1 ] = _strdup( FileName );
                }
            else if ( memcmp( arg, "newsympath:", 11 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum != 1 ) {
                    Usage();
                    }

                NewFileSymPath = _strdup( FileName );
                }
            else {
                Usage();
                }
            }

        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else {
            Usage();
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        }

    if ( WindowSizePower != 0 ) {

        OptionData.ExtendedOptionFlags |= PATCH_OPTION_SPECIFIED_WINDOW;
        OptionData.MaxLzxWindowSize = 1 << WindowSizePower;

        if ( OptionData.MaxLzxWindowSize < LZX_MINWINDOW ) {
            Usage();
            }
        }

    if ( Force194 ) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_LARGE;
        Force197 = TRUE;
        }

    if ( Force197 ) {
        OptionFlags &= ~PATCH_OPTION_INTERLEAVE_FILES;
        OptionData.ExtendedOptionFlags &= ~PATCH_OPTION_SPECIFIED_WINDOW;
        OptionData.ExtendedOptionFlags &= ~PATCH_TRANSFORM_PE_IRELOC_2;
        OptionData.ExtendedOptionFlags &= ~PATCH_TRANSFORM_PE_RESOURCE_2;
        OptionData.InterleaveMapArray = NULL;
        OptionData.MaxLzxWindowSize = 0;
        }

    //
    //  Useful on MP machines, set affinity to one processor and lower
    //  priority to below normal since we are heavily CPU intensive.
    //

    if ( ! bNoAffinity ) {

        ULONG InstanceCounterSnap = _InterlockedExchangeAdd( &SharedInstanceCounter, 1 );
        ULONG ProcessAffinityMask = 1;
        ULONG SystemAffinityMask;

        GetProcessAffinityMask(
            GetCurrentProcess(),
            &ProcessAffinityMask,
            &SystemAffinityMask
            );

        if ( ProcessAffinityMask > 1 ) {

            //
            //  Note this is just a "good effort", it is not perfect because
            //  process/system affinity mask is not always packed in the lowest
            //  bits and we're not wrapping.  If this shift doesn't result in
            //  a valid mask, SetAffinityMask will simply fail leaving us
            //  running on any available processor.
            //

            ProcessAffinityMask = 1 << ( InstanceCounterSnap & 0x1F );

            SetProcessAffinityMask( GetCurrentProcess(), ProcessAffinityMask );

            }

        SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_LOWEST );

        }

    OldFileCount = 0;

    p = OldFileName;

    q = strchr( OldFileName, ';' );

    while ( q ) {

        *q = 0;

        if ( *p ) {
            OldFileInfo[ OldFileCount ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_A );
            OldFileInfo[ OldFileCount ].OldFileName = p;
            OldFileCount++;
            }

        p = q + 1;
        q = strchr( p, ';' );

        }

    if ( *p ) {
        OldFileInfo[ OldFileCount ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_A );
        OldFileInfo[ OldFileCount ].OldFileName = p;
        OldFileCount++;
        }

    //
    //  Make sure rift tables are ascending and don't contain duplicate
    //  OldRva values (ambiguous).
    //

    for ( i = 0; i < (int)OldFileCount; i++ ) {

        if (( RiftTableArray[ i ] ) && ( RiftTableArray[ i ]->RiftEntryCount > 1 )) {

            n = RiftTableArray[ i ]->RiftEntryCount - 1;

            RiftQsort( &RiftTableArray[ i ]->RiftEntryArray[ 0 ], &RiftTableArray[ i ]->RiftEntryArray[ n ] );

#ifdef TESTCODE

            for ( j = 0; j < n; j++ ) {
                if ( RiftTableArray[ i ]->RiftEntryArray[ j     ].OldFileRva >
                     RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].OldFileRva ) {

                    printf( "\nRift sort failed at index %d of %d\n", j, n + 1 );

                    for ( j = 0; j <= n; j++ ) {
                        printf( "%08X\n", RiftTableArray[ i ]->RiftEntryArray[ j ].OldFileRva );
                        }

                    exit( 1 );
                    break;
                    }
                }

#endif // TESTCODE

            for ( j = 0; j < n; j++ ) {

                while (( j < n ) &&
                       ( RiftTableArray[ i ]->RiftEntryArray[ j     ].OldFileRva ==
                         RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].OldFileRva )) {

                    if ( RiftTableArray[ i ]->RiftEntryArray[ j     ].NewFileRva !=
                         RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].NewFileRva ) {

                        //
                        //  This is an ambiguous entry since the OldRva values
                        //  match but the NewRva values do not.  Report and
                        //  discard the former.
                        //

                        printf(
                            "RiftInfo for %s contains ambiguous entries:\n"
                            "    OldRva:%08X NewRva:%08X (discarded)\n"
                            "    OldRva:%08X NewRva:%08X (kept)\n\n",
                            OldFileInfo[ i ].OldFileName,
                            RiftTableArray[ i ]->RiftEntryArray[ j ].OldFileRva,
                            RiftTableArray[ i ]->RiftEntryArray[ j ].NewFileRva,
                            RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].OldFileRva,
                            RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].NewFileRva
                            );
                        }

                    else {

                        //
                        //  This is a completely duplicate entry, so just
                        //  silently remove it.
                        //

                        }

                    MoveMemory(
                        &RiftTableArray[ i ]->RiftEntryArray[ j ],
                        &RiftTableArray[ i ]->RiftEntryArray[ j + 1 ],
                        ( n - j ) * sizeof( RIFT_ENTRY )
                        );

                    --n;

                    }
                }

            RiftTableArray[ i ]->RiftEntryCount = n + 1;

            }
        }

    for ( i = 0; i < (int)OldFileCount; i++ ) {

        if (( _stricmp( OldFileInfo[ i ].OldFileName, "nul"  ) == 0 ) ||
            ( _stricmp( OldFileInfo[ i ].OldFileName, "null" ) == 0 )) {

            OldFileCount = 1;
            OldFileInfo[ 0 ] = OldFileInfo[ i ];
            OldFileInfo[ 0 ].OldFileName = NULL;

            OptionDataPointer = NULL;   // no option data for null patches

            bNoCompare = TRUE;

            OptionFlags &= ~PATCH_OPTION_FAIL_IF_BIGGER;

            OptionFlags &= ~PATCH_OPTION_USE_LZX_A;
            OptionFlags |=  PATCH_OPTION_USE_LZX_B;        // always use E8 in LZX

            OptionFlags |=  PATCH_OPTION_NO_BINDFIX;
            OptionFlags |=  PATCH_OPTION_NO_LOCKFIX;
            OptionFlags |=  PATCH_OPTION_NO_REBASE;
            OptionFlags |=  PATCH_OPTION_NO_CHECKSUM;
            OptionFlags |=  PATCH_OPTION_NO_RESTIMEFIX;

            break;
            }

        else if ( OldFileSymPathArray[ i ] == NULL ) {

            GetFullPathName( OldFileInfo[ i ].OldFileName, sizeof( TextBuffer ), TextBuffer, &FileNamePart );

            if (( FileNamePart > TextBuffer ) && ( *( FileNamePart - 1 ) == '\\' )) {
                *( FileNamePart - 1 ) = 0;
                }

            OldFileSymPathArray[ i ] = _strdup( TextBuffer );
            }
        }

    if ( NewFileSymPath == NULL ) {

        GetFullPathName( NewFileName, sizeof( TextBuffer ), TextBuffer, &FileNamePart );

        if (( FileNamePart > TextBuffer ) && ( *( FileNamePart - 1 ) == '\\' )) {
            *( FileNamePart - 1 ) = 0;
            }

        NewFileSymPath = _strdup( TextBuffer );
        }

    OptionData.NewFileSymbolPath      = NewFileSymPath;
    OptionData.OldFileSymbolPathArray = OldFileSymPathArray;

    if ( OptionData.SymbolOptionFlags & PATCH_SYMBOL_EXTERNAL_RIFT ) {
        OptionData.OldFileSymbolPathArray = (PVOID)RiftTableArray;
        }

    OptionData.SymLoadCallback = MySymLoadCallback;
    OptionData.SymLoadContext  = FileNameArray;

    FileNameArray[ 0 ] = (LPSTR)NewFileName;

    for ( i = 0; i < (int)OldFileCount; i++ ) {
        FileNameArray[ i + 1 ] = (LPSTR)OldFileInfo[ i ].OldFileName;
        }

    Success = CreatePatchFileEx(
                  OldFileCount,
                  OldFileInfo,
                  NewFileName,
                  PatchFileName,
                  OptionFlags,
                  OptionDataPointer,
                  bNoProgress ? NULL : MyProgressCallback,
                  NULL
                  );

    ErrorCode = GetLastError();

    if (( ! Success ) && ( ErrorCode & 0xC0000000 )) {

        //
        //  try without resource fixups
        //

        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RESOURCE;

        Success = CreatePatchFileEx(
                      OldFileCount,
                      OldFileInfo,
                      NewFileName,
                      PatchFileName,
                      OptionFlags,
                      OptionDataPointer,
                      bNoProgress ? NULL : MyProgressCallback,
                      NULL
                      );

        ErrorCode = GetLastError();
        }


    printf( "\n\n" );

    if ( ! Success ) {

        CHAR ErrorText[ 16 ];

        sprintf( ErrorText, ( ErrorCode < 0x10000000 ) ? "%d" : "%X", ErrorCode );

        printf( "Failed to create patch (%s)\n", ErrorText );

        exit( 1 );
        }

    NewFileSize   = (ULONG) GetFileSizeByName( NewFileName );
    PatchFileSize = (ULONG) GetFileSizeByName( PatchFileName );

    if (( NewFileSize != 0xFFFFFFFF ) && ( NewFileSize != 0 ) && ( PatchFileSize != 0xFFFFFFFF )) {

        printf( "%d bytes (%.2f%% compression, %.2f:1)\n",
                PatchFileSize,
                ((((LONG)NewFileSize - (LONG)PatchFileSize ) * 100.0 ) / NewFileSize ),
                ((double)NewFileSize / PatchFileSize )
              );

        if ( ! bNoCompare ) {

            CHAR TempFile1[ MAX_PATH ];
            CHAR TempFile2[ MAX_PATH ];
            HANDLE hFile;

            GetTempPath( MAX_PATH, TempFile1 );
            GetTempPath( MAX_PATH, TempFile2 );
            strcat( TempFile1, "\\tt$$src.$$$" );
            strcat( TempFile2, "\\tt$$pat.$$$" );

            hFile = CreateFile(
                        TempFile1,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_TEMPORARY,
                        NULL
                        );

            if ( hFile != INVALID_HANDLE_VALUE ) {

                CloseHandle( hFile );

                Success = CreatePatchFile(
                              TempFile1,
                              NewFileName,
                              TempFile2,
                              OptionFlags & ~PATCH_OPTION_FAIL_IF_BIGGER,
                              NULL
                              );

                if ( Success ) {

                    ULONG CompFileSize = (ULONG) GetFileSizeByName( TempFile2 );

                    if (( CompFileSize != 0xFFFFFFFF ) && ( CompFileSize != 0 )) {

                        if ( CompFileSize <= PatchFileSize ) {

                            printf( "\nWARNING: Simply compressing %s would be %d bytes smaller (%.2f%%)\n",
                                    NewFileName,
                                    PatchFileSize - CompFileSize,
                                    ((((LONG)PatchFileSize - (LONG)CompFileSize ) * 100.0 ) / CompFileSize )
                                  );
                            }

                        else if ( NewFileSize != 0 ) {

                            printf( "\n%d bytes saved (%.2f%%) over estimated non-patching compression\n",
                                    CompFileSize - PatchFileSize,
                                    ((((LONG)CompFileSize - (LONG)PatchFileSize ) * 100.0 ) / CompFileSize )
                                  );
                            }
                        }
                    }
                }

            DeleteFile( TempFile1 );
            DeleteFile( TempFile2 );
            }
        }

    exit( 0 );
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\wpatch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wpatch.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\wpatch\makefile.inc ===
EXENAME=wpatch.exe
PDBNAME=wpatch.pdb

COPYTOBIN:
  @if exist obj\$(TARGET_DIRECTORY)\$(EXENAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(EXENAME) ..\..\..\bin\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(PDBNAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(PDBNAME) ..\..\..\bin\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\mpatches\redblack.c ===
/*
    redblack.c

    Implementation of red-black binary tree insertion, deletion, and search.
    This algorithm efficiently guarantees that the tree depth will never exceed
    2*Lg(N), so a one million node tree would have a worst case depth of 40.
    This insertion implementation is non-recursive and very efficient (the
    average insertion speed is less than twice the average search speed).

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998-2000.

    2/98, modified this version of redblack.c for debug symbol lookups.
    8/98, modified this version of redblack.h for generic name table.
    4/00, fixed tree walk bug when hashes match for different strings.
    4/00, added enumerator (msliger).

*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdlib.h>

#include "md5.h"
#include "misc.h"

#include "redblack.h"

#pragma intrinsic( memcpy, memcmp, strlen, _rotl )

//
//  Rather than storing NULL links as NULL, we point NULL links to a special
//  "Empty" node which is always black and its children links point to itself.
//  We do this to simplify the color testing for children and grandchildren
//  such that any link can be dereferenced and even double-dereferenced without
//  explicitly checking for NULL.  The empty node must be colored black.
//

const NAME_NODE NameRbEmptyNode = { RBNIL, RBNIL };


ULONG
__fastcall
NameRbHash(
    IN LPCSTR Name,
    IN ULONG  Length
    )
    {
    ULONG Hash = ~Length;

    while ( Length-- ) {
        Hash = _rotl( Hash, 3 ) ^ *Name++;
        }

    return Hash;
    }


VOID
NameRbInitTree(
    IN OUT PNAME_TREE Tree,
    IN HANDLE SubAllocator
    )
    {
    Tree->Root = RBNIL;
    Tree->SubAllocator = SubAllocator;
    }


PNAME_NODE
NameRbFind(
    IN PNAME_TREE Tree,
    IN LPCSTR Name
    )
    {
    PNAME_NODE Node;
    ULONG      NameLength;
    ULONG      Hash;

    NameLength = strlen( Name );

    Hash = NameRbHash( Name, NameLength );

    Node = Tree->Root;

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            Node = Node->Right;
            }
        else {  // hashes equal, compare lengths

            if ( NameLength < Node->NameLength ) {
                Node = Node->Left;
                }
            else if ( NameLength > Node->NameLength ) {
                Node = Node->Right;
                }
            else {  // hashes and lengths equal, compare strings

                int Compare = memcmp( Name, Node->Name, NameLength );

                if ( Compare == 0 ) {
                    return Node;
                    }
                else if ( Compare < 0 ) {
                    Node = Node->Left;
                    }
                else {
                    Node = Node->Right;
                    }
                }
            }
        }

    return NULL;
    }


PNAME_NODE
NameRbInsert(
    IN OUT PNAME_TREE Tree,
    IN     LPCSTR Name
    )
    {
    PNAME_NODE * Stack[ MAX_DEPTH ];
    PNAME_NODE **StackPointer = Stack;
    PNAME_NODE * Link;
    PNAME_NODE   Node;
    PNAME_NODE   Sibling;
    PNAME_NODE   Parent;
    PNAME_NODE   Child;
    PNAME_NODE   NewNode;
    ULONG        NameLength;
    ULONG        Hash;

    NameLength = strlen( Name );

    Hash = NameRbHash( Name, NameLength );

    *StackPointer++ = &Tree->Root;

    Node = Tree->Root;

    //
    //  Walk down the tree to find either an existing node with the same key
    //  (in which case we simply return) or the insertion point for the new
    //  node.  At each traversal we need to store the address of the link to
    //  the next node so we can retrace the traversal path for balancing.
    //  The speed of insertion is highly dependent on traversing the tree
    //  quickly, so all balancing operations are deferred until after the
    //  traversal is complete.
    //

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            *StackPointer++ = &Node->Left;
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            *StackPointer++ = &Node->Right;
            Node = Node->Right;
            }
        else {  // hashes equal, compare lengths

            if ( NameLength < Node->NameLength ) {
                *StackPointer++ = &Node->Left;
                Node = Node->Left;
                }
            else if ( NameLength > Node->NameLength ) {
                *StackPointer++ = &Node->Right;
                Node = Node->Right;
                }
            else {  // lengths equal, compare strings

                int Compare = memcmp( Name, Node->Name, NameLength );

                if ( Compare == 0 ) {
                    return Node;
                    }
                else if ( Compare < 0 ) {
                    *StackPointer++ = &Node->Left;
                    Node = Node->Left;
                    }
                else {
                    *StackPointer++ = &Node->Right;
                    Node = Node->Right;
                    }
                }
            }
        }

    //
    //  Didn't find a matching entry, so allocate a new node and add it
    //  to the tree.  Note that we're not allocating space for a terminator
    //  for the name data since we store the length of the name in the node.
    //

    NewNode = SubAllocate( Tree->SubAllocator, ( sizeof( NAME_NODE ) + NameLength ));

    if ( NewNode == NULL ) {
        return NULL;
        }

    NewNode->Left  = RBNIL;
    NewNode->Right = RBNIL;
    NewNode->Hash  = Hash;
    NewNode->NameLengthAndColorBit = NameLength | 0x80000000;   // MARK_RED
    memcpy( NewNode->Name, Name, NameLength );

    //
    //  Insert new node under last link we traversed.  The top of the stack
    //  contains the address of the last link we traversed.
    //

    Link = *( --StackPointer );
    *Link = NewNode;

    //
    //  Now walk back up the traversal chain to see if any balancing is
    //  needed.  This terminates in one of three ways: we walk all the way
    //  up to the root (StackPointer == Stack), or find a black node that
    //  we don't need to change (no balancing needs to be done above a
    //  black node), or we perform a balancing rotation (only one necessary).
    //

    Node = NewNode;
    Child = RBNIL;

    while ( StackPointer > Stack ) {

        Link = *( --StackPointer );
        Parent = *Link;

        //
        //  Node is always red here.
        //

        if ( IS_BLACK( Parent )) {

            Sibling = ( Parent->Left == Node ) ? Parent->Right : Parent->Left;

            if ( IS_RED( Sibling )) {

                //
                //  Both Node and its Sibling are red, so change them both to
                //  black and make the Parent red.  This essentially moves the
                //  red link up the tree so balancing can be performed at a
                //  higher level.
                //
                //        Pb                     Pr
                //       /  \       ---->       /  \
                //      Cr  Sr                 Cb  Sb
                //

                MARK_BLACK( Sibling );
                MARK_BLACK( Node );
                MARK_RED( Parent );
                }

            else {

                //
                //  This is a terminal case.  The Parent is black, and it's
                //  not going to be changed to red.  If the Node's child is
                //  red, we perform an appropriate rotation to balance the
                //  tree.  If the Node's child is black, we're done.
                //

                if ( IS_RED( Child )) {

                    if ( Node->Left == Child ) {

                        if ( Parent->Left == Node ) {

                            //
                            //       Pb             Nb
                            //      /  \           /  \
                            //     Nr   Z   to    Cr  Pr
                            //    /  \                / \
                            //   Cr   Y              Y   Z
                            //

                            MARK_RED( Parent );
                            Parent->Left = Node->Right;
                            Node->Right = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            //
                            //       Pb                Cb
                            //      /  \              /  \
                            //     W    Nr    to     Pr   Nr
                            //         /  \         / \   / \
                            //        Cr   Z       W   X Y   Z
                            //       /  \
                            //      X    Y
                            //

                            MARK_RED( Parent );
                            Parent->Right = Child->Left;
                            Child->Left = Parent;
                            Node->Left = Child->Right;
                            Child->Right = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }

                    else {

                        if ( Parent->Right == Node ) {

                            MARK_RED( Parent );
                            Parent->Right = Node->Left;
                            Node->Left = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            MARK_RED( Parent );
                            Parent->Left = Child->Right;
                            Child->Right = Parent;
                            Node->Right = Child->Left;
                            Child->Left = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }
                    }

                return NewNode;
                }
            }

        Child = Node;
        Node = Parent;
        }

    //
    //  We bubbled red up to the root -- restore it to black.
    //

    MARK_BLACK( Tree->Root );

    return NewNode;
    }


PNAME_NODE
NameRbEnumFirst(
    IN OUT PNAME_TREE_ENUM Enumerator,
    IN PNAME_TREE Tree
    )
    {
    PNAME_NODE Node = Tree->Root;
    ULONG Depth = 1;

    Enumerator->ParentList[ 0 ] = RBNIL;

    while ( Enumerator->ParentList[ Depth ] = Node,
            Node = Node->Left,
            Node != RBNIL ) {

        Depth++;
        }

    Enumerator->Depth = Depth;

    Node = Enumerator->ParentList[ Depth ];

    if ( Node == RBNIL ) {

        Node = NULL;
        }

    return( Node );
    }


PNAME_NODE
NameRbEnumNext(
    IN PNAME_TREE_ENUM Enumerator
    )
    {
    PNAME_NODE Node;
    ULONG Depth = Enumerator->Depth;

    Node = Enumerator->ParentList[ Depth ]->Right;

    if ( Node != RBNIL ) {

        while ( Enumerator->ParentList[ Depth ] = Node,
                Node = Node->Left,
                Node != RBNIL ) {

            Depth++;
            }
        }

    else {

        --Depth;
        }

    Enumerator->Depth = Depth;

    Node = Enumerator->ParentList[ Depth ];

    if ( Node == RBNIL ) {

        Node = NULL;
        }

    return( Node );
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\wpatch\wpatchid.h ===
#define DLG_PROGRESS    101
#define IDC_PROGRESS    102
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\wpatch\wpatch.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4100 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <windows.h>

#pragma warning( disable: 4001 4035 4100 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <commctrl.h>
#include "wpatchid.h"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "patchapi.h"
#include "patchprv.h"

typedef struct {
    HWND hwndProgress;
    int iPercentLast;
    } CALLBACK_CONTEXT;


void Usage( void ) {
    MessageBox( NULL,
        "WPATCH " PATCH_VERSION_TEXT " Patch Application Utility\n"
        "Copyright (C) Microsoft, 1997-2001\n"
        "\n"
        "Usage:  WPATCH PatchFile OldFile TargetNewFile",
        "Patch Application Utility",
        MB_OK
        );
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    int iPercent;
    MSG msg;
    CALLBACK_CONTEXT *pContext = CallbackContext;

    if (pContext->hwndProgress != NULL) {

        if ( CurrentPosition & 0xFF000000 ) {
            CurrentPosition >>= 8;
            MaximumPosition >>= 8;
            }

        if ( MaximumPosition != 0 ) {

            iPercent = ( CurrentPosition * 100 ) / MaximumPosition;

            if (pContext->iPercentLast != iPercent) {

                pContext->iPercentLast = iPercent;

                SendDlgItemMessage(pContext->hwndProgress, IDC_PROGRESS, PBM_SETPOS,
                    iPercent, 0);

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                        DispatchMessage(&msg);
                    }
                }
            }
        }

    return TRUE;
    }


BOOL CALLBACK ProgressWndProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0, 99));
            EnableMenuItem(GetSystemMenu(hdlg, FALSE), SC_CLOSE, MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
            return TRUE;
    }

    return 0;
}


int WINAPI WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nShowCmd)
{
    char *pchCommand;
    char *argv[50];
    int argc;
    enum { WHITESPACE, UNQUOTED, QUOTED } eState = WHITESPACE;
    LPSTR OldFileName   = NULL;
    LPSTR PatchFileName = NULL;
    LPSTR NewFileName   = NULL;
    BOOL  Success;
    LPSTR arg;
    int   i;
    int   rc;
    CALLBACK_CONTEXT Context;
    int   fWaitOnError = TRUE;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    Context.hwndProgress = NULL;
    Context.iPercentLast = -1;

    pchCommand = _strdup(lpCmdLine);    /* work on a copy */

    argv[0] = "";                       /* no EXE name supplied */
    argc = 1;                           /* that was one */

    while (*pchCommand)                 /* walk the string */
    {
        switch (eState)
        {

        case WHITESPACE:
            if (*pchCommand <= ' ')
            {
                /* ignore it */
            }
            else if (*pchCommand == '\"')
            {
                argv[argc++] = pchCommand + 1;  /* skip quote */

                eState = QUOTED;
            }
            else
            {
                argv[argc++] = pchCommand;

                eState = UNQUOTED;
            }
            break;

        case UNQUOTED:
            if (*pchCommand <= ' ')
            {
                *pchCommand = '\0';      /* nul-terminate */

                eState = WHITESPACE;
            }
            else
            {
                /* keep moving up */
            }
            break;

        case QUOTED:
            if (*pchCommand == '\"')
            {
                *pchCommand = '\0';      /* turn quote to a nul */

                eState = WHITESPACE;
            }
            else
            {
                /* keep moving up */
            }
            break;
        }

        pchCommand++;
    }

    argv[argc] = NULL;                  /* NULL-terminate the list */

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            rc = 1;
            goto bail;
            }

        if ( lstrcmpi( arg, "-QUIET" ) == 0) {
            nShowCmd = SW_HIDE;
            }
        else if ( lstrcmpi( arg, "-NOWAIT" ) == 0) {
            fWaitOnError = FALSE;
            }
        else if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else {
            Usage();
            rc = 1;
            goto bail;
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        rc = 1;
        goto bail;
        }

    if (nShowCmd != SW_HIDE) {
        InitCommonControls();

        Context.hwndProgress = CreateDialog(hInstance,
                MAKEINTRESOURCE(DLG_PROGRESS), NULL, ProgressWndProc);

        ShowWindow( Context.hwndProgress, nShowCmd );   // might be ignored per spec
        ShowWindow( Context.hwndProgress, nShowCmd );   // won't be ignored
        }

    DeleteFile( NewFileName );

    if (( lstrcmpi( OldFileName, "nul"  ) == 0 ) ||
        ( lstrcmpi( OldFileName, "null" ) == 0 )) {

        OldFileName = NULL;
        }

    Success = ApplyPatchToFileEx(
                  PatchFileName,
                  OldFileName,
                  NewFileName,
                  0,
                  MyProgressCallback,
                  &Context
                  );

    if (Context.hwndProgress != NULL)
    {
        DestroyWindow(Context.hwndProgress);
    }

    if ( ! Success ) {

        if (fWaitOnError) {
            CHAR  ErrorText[ 100 ];
            ULONG ErrorCode = GetLastError();

            wsprintf( ErrorText, "Failed to create file from patch (%X)", ErrorCode );

            MessageBox(NULL,
                ErrorText,
                "WPATCH Failed",
                MB_ICONERROR | MB_SYSTEMMODAL);
            }

        rc = 2;
        goto bail;
        }

    rc = 0;

bail:

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\mpatches\redblack.h ===
/*
    redblack.h

    Prototypes and node structure definition for red-black binary trees.
    See redblack.c for details and implementation.

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998.

    2/98, modified this version of redblack.h for debug symbol lookups.
    8/98, modified this version of redblack.h for generic name table.

*/

#ifndef _REDBLACK_H_
#define _REDBLACK_H_

#pragma warning( disable: 4200 )    // zero-sized array in struct/union
#pragma warning( disable: 4214 )    // bitfields other than int

//
//  The maximum tree depth is 2*Lg(N).  Since we could never have more than
//  2^X nodes with X-bit pointers, we can safely say the absolute maximum
//  depth will be 2*Lg(2^X) which is 2*X.  The size of a pointer in bits is
//  its size in bytes times 8 bits, so 2*(sizeof(p)*8) is our maximum depth.
//  So for 32-bit pointers, our maximum depth is 64.
//
//  If you know the maximum possible number of nodes in advance (like the size
//  of the address space divided by the size of a node), you can tweak this
//  value a bit smaller to 2*Lg(N).  Note that it's important for this max
//  depth be evalutated to a constant value at compile time.
//
//  For this implementation, we'll assume the maximum number of nodes is
//  1 million, so the max depth is 40 (2*Lg(2^20)).  Note that no runtime
//  checks are made to ensure we don't exceed this number.
//

#define MAX_DEPTH 40


typedef struct _NAME_NODE NAME_NODE, *PNAME_NODE;
typedef struct _NAME_TREE NAME_TREE, *PNAME_TREE;
typedef struct _NAME_TREE_ENUM NAME_TREE_ENUM, *PNAME_TREE_ENUM;

struct _NAME_NODE {
    PNAME_NODE Left;
    PNAME_NODE Right;
    ULONG      Hash;
    union {
      ULONG    NameLengthAndColorBit;
      struct {
        ULONG  NameLength:31;
        ULONG  Red:1;
        };
      };
    PVOID Context;
    CHAR  Name[ 0 ];
    };

struct _NAME_TREE {
    PNAME_NODE Root;
    HANDLE SubAllocator;
    };

struct _NAME_TREE_ENUM {
    ULONG Depth;
    PNAME_NODE ParentList[ MAX_DEPTH + 1 ];
    };


#define RBNIL ((PNAME_NODE)&NameRbEmptyNode)

extern const NAME_NODE NameRbEmptyNode;


//
//  Although "Red" can be stored in its own 1-byte or 4-byte field, keeping the
//  nodes smaller by encoding "Red" as a one-bit field with another value
//  provides better performance (more nodes tend to stay in the cache).  To
//  provide flexibility in storage of the RED property, all references to RED
//  and BLACK are made through the following macros which can be changed as
//  necessary:
//

#define IS_RED( Node )            (   (Node)->Red )
#define IS_BLACK( Node )          ( ! (Node)->Red )
#define MARK_RED( Node )          (   (Node)->Red = 1 )
#define MARK_BLACK( Node )        (   (Node)->Red = 0 )


//
//  The following prototypes are the red-black tree interface.
//

VOID
NameRbInitTree(
    IN OUT PNAME_TREE Tree,
    IN HANDLE SubAllocator
    );

PNAME_NODE
NameRbInsert(
    IN OUT PNAME_TREE Tree,
    IN     LPCSTR Name
    );

PNAME_NODE
NameRbFind(
    IN PNAME_TREE Tree,
    IN LPCSTR Name
    );

PNAME_NODE
NameRbEnumFirst(
    IN OUT PNAME_TREE_ENUM Enumerator,
    IN PNAME_TREE Tree
    );

PNAME_NODE
NameRbEnumNext(
    IN PNAME_TREE_ENUM Enumerator
    );

#endif // _REDBLACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\samples\mpatches\mpatches.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )
#include <windows.h>
#include <wincrypt.h>
#pragma warning( disable: 4201 )
#include <imagehlp.h>
#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#include "patchapi.h"
#include "patchprv.h"
#include "patchlzx.h"
#include "md5.h"
#include "misc.h"
#include "redblack.h"

typedef unsigned __int64 QWORD;

CHAR TextBuffer[ 65000 ];

CHAR OldDirRoot[ MAX_PATH ];
CHAR NewDirRoot[ MAX_PATH ];
CHAR PatchDirRoot[ MAX_PATH ];
CHAR OldPsymPath[ MAX_PATH ];
CHAR NewPsymPath[ MAX_PATH ];
CHAR OldSymPath[ MAX_PATH ];
CHAR NewSymPath[ MAX_PATH ];
CHAR NewFileList[ MAX_PATH ];
CHAR *NewDirRootEnd;
CHAR *OldDirRootEnd;
CHAR *PatchDirRootEnd;
CHAR PatchCache[ MAX_PATH ];
CHAR *PatchCacheEnd;
BOOL bIncremental;
BOOL bSubDirectories;
BOOL bCopyNonPatches;
BOOL bNoSymWarn;
BOOL bNoAffinity;
BOOL bUseBadSyms;
BOOL bCrcName;
BOOL bSourceIsForest;
BOOL bCaching;
BOOL bCreateFallbackFiles;


#define HASH_HEX_LENGTH ( sizeof( MD5_HASH ) * 2 + 1 )

typedef struct _a_NEWFILE NEWFILE;

struct _a_NEWFILE {
    NEWFILE     * Next;         // link to next with same base filename.ext
    NAME_NODE   * FileNode;     // ptr to parent node in NewFileTree
    NAME_NODE   * MD5Node;      // ptr to this file's node in MD5Tree
    FILETIME      FileTime;     // last modified time
    DWORD         FileSize;     // size of file
    char          Path[ 1 ];    // relative path w/trailing sep, ie "uniproc\"
    };

typedef struct _a_OLDFILE OLDFILE;

struct _a_OLDFILE {
    OLDFILE * Next;     // link to next with same base filename.ext
    char Path[ 1 ];     // relative path w/trailing sep, ie "uniproc\"
    };

typedef struct _a_SORTNODE SORTNODE;

struct _a_SORTNODE {
    NEWFILE   * NewFile;
    NAME_NODE * Node;
    };

typedef struct _a_PRODUCTFILE PRODUCTFILE;

struct _a_PRODUCTFILE {
    NEWFILE * FirstNewFile;     // link to first new file with this base filename.ext
    OLDFILE * FirstOldFile;     // link to first old file with this base filename.ext
    };

typedef struct _a_PathNode {
    struct _a_PathNode *Parent;     // ptr to parent PATHNODE, or NULL if at top
    CHAR                Name[ 1 ];  // path component at this level w/trail, ie "system32\"
    } PATHNODE;

typedef struct _a_NameNode {
    PATHNODE           *Parent;     // ptr to parent PATHNODE
    struct _a_NameNode *Next;       // link to next with same hash
    DWORD               HashValue;  // full hash value (before modulo)
    MD5_HASH            Digest;     // MD5 of this file, all 0 if unknown
    CHAR               *BaseName;   // ptr into Name, ie, "kernel32.dll"
    CHAR                Name[ 1 ];  // path rel to parent PATHNODE or just base name
    } NAMENODE;

#define     MANIFEST_DATA_FILE_NAME     "MANIFEST.DAT"
#define     MANIFEST_TEMP_FILE_NAME     "MANIFEST.$$$"

/* manifest.dat file record format */

#include <pshpack1.h>

typedef unsigned char DIGEST[16];

typedef struct
{
    unsigned long       dwSignature;    /* should be 'M','S','M','F' */
    unsigned long       dwVersion;      /* should be = 1 */
    unsigned long       cTotalFiles;    /* number of files */
    unsigned __int64    cbTotalSize;    /* total size of all files */
} MANIFEST_HEADER;

#define MANIFEST_SIGNATURE      (0x464D534D)
#define MANIFEST_VERSION        (0x00000001)

typedef struct
{
    unsigned short      cchFileName;    /* length of file name w/o NUL */
    unsigned long       cbFileSize;     /* size of this file */
    DIGEST              digest;         /* digest of this file */
/*  char                szFileName[cchFileName];  name of this file */
} MANIFEST_RECORD;

#include <poppack.h>


#define HASH_TABLE_WIDTH (10000)

PATHNODE *OldDirTree;
DWORD NameHash;
NAMENODE *NameNode;
NAMENODE * HashTable[ HASH_TABLE_WIDTH ];

LPSTR OldSymPathArray[ 1 ] = { OldSymPath };

LPSTR FileNameArray[] = { NewDirRoot, OldDirRoot };

PATCH_SYMLOAD_CALLBACK MySymLoadCallback;

PATCH_OPTION_DATA OptionData = {
    sizeof( PATCH_OPTION_DATA ),
    0,
    (LPCSTR)NewSymPath,
    (LPCSTR*)OldSymPathArray,
    0,
    MySymLoadCallback,
    FileNameArray
    };

ULONG OptionFlags = PATCH_OPTION_USE_LZX_BEST  |
                    PATCH_OPTION_USE_LZX_LARGE |
                    PATCH_OPTION_INTERLEAVE_FILES;

QWORD TotalPatchSourceSizes;
QWORD TotalPatchTargetSizes;
ULONG CountPatchFiles;

ULONG CountCopiedFiles;
QWORD TotalCopiedSizes;
ULONG ReturnCode;

ULONG ErrorCount;

HANDLE SubAllocator;
ULONG CountNewFiles;
NAME_TREE NewFileTree;
NAME_TREE MD5Tree;

const char szZeroLengthFileHash[] = "D41D8CD98F00B204E9800998ECF8427E";

#pragma data_seg( ".shared" )
LONG SharedInstanceCounter = 0;
#pragma data_seg()

LONG WINAPI _InterlockedExchangeAdd( LONG*, LONG );
#pragma intrinsic( _InterlockedExchangeAdd )


BOOL
CALLBACK
MySymLoadCallback(
    IN ULONG  WhichFile,
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    );

DWORD
HashString(
    LPCSTR String
    );

BOOL
GetFirstCandidate(
    LPSTR  OldDirRoot,
    LPSTR  OldDirFileName,
    LPCSTR NewFileName,
    CHAR  *CandidateHash
    );

BOOL
GetNextCandidate(
    LPSTR  OldDirRoot,
    LPSTR  OldDirFileName,
    LPCSTR NewFileName,
    CHAR  *CandidateHash
    );

VOID
BuildOldDirTree(
    LPSTR OldDirRoot
    );

VOID
RecursiveBuildOldDirTree(
    LPSTR OldDirPath,
    PATHNODE *Parent
    );

BOOL
LoadTreeUsingManifest(
    LPSTR RootPath,
    LPSTR RootPathEnd,
    PATHNODE * Parent
    );

VOID
BuildDirPath(
    LPSTR Buffer,
    PATHNODE *Parent
    );

VOID
AssociateNewFileDuplicates(
    VOID
    );

ULONG
MakePatchesForFile(
    LPCSTR   NewDirFileName,    // base file name in NewDirRoot, ie "kernel32.dll" in "new\uniproc\kernel32.dll"
    LPSTR    OldDirFileName,    // pos for base file name in OldDirRoot, ie "x" in "old\uniproc\x"
                                // or top base if bSourceIsForest, ie "x" in "old\x", not drilled down
    LPSTR    PatchDirFileName,  // pos for base file name in PatchDirRoot, ie "x" in "patches\uniproc\x"
    FILETIME NewFileLastWriteTime,
    DWORD    NewFileSize
    );

BOOL
AdjustPatchTime(
    LPCSTR   PatchPathName,     // full path to patch file
    FILETIME PatchTimeStamp     // time to store in patch
    );

void CopyRight( void ) {
    printf(
        "\n"
        "MPATCHES " PATCH_VERSION_TEXT " Patch Creation Utility\n"
        "Copyright (C) Microsoft, 1997-2001\n"
        "\n"
        );
    }


void __declspec( noreturn ) Usage( void ) {
    printf(
"Usage:  MPATCHES [options] OldFilesPath NewFilesPath PatchFilesPath\n"
"\n"
"        For each file in the NewFilesPath directory,\n"
"          If same named file exists in OldFilesPath directory,\n"
"            Create patch file in PatchFilesPath directory,\n"
"          Else if -COPYOTHERS was specified,\n"
"            Copy file from NewFilesPath to PatchFilesPath.\n"
"\n"
"        Options:\n"
"\n"
"          -NOBINDFIX   Turn off automatic compensation for bound imports in\n"
"                       the the old file.  The default is to ignore binding\n"
"                       data in the old file during patch creation which will\n"
"                       cause the application of the patch to succeed whether\n"
"                       or not the old file on the target machine is bound, not\n"
"                       bound, or even bound to different import addresses.\n"
"                       If the files are not Win32 binaries, this option is\n"
"                       ignored and has no effect.\n"
"\n"
"          -NOLOCKFIX   Turn off automatic compensation for smashed lock prefix\n"
"                       instructions.  If the files are not Win32 binaries,\n"
"                       this option is ignored and has no effect.\n"
"\n"
"          -NOREBASE    Turn off automatic internal rebasing of old file to new\n"
"                       file's image base address.  If the files are not Win32\n"
"                       binaries, this option is ignored and has no effect.\n"
"\n"
"          -NORESTIME   Turn off automatic fixup of resource section timestamps\n"
"                       (ignored if not Win32 binaries).\n"
"\n"
"          -NOCHECKSUM  Enable automatic compensation for old file's checksums.\n"
"\n"
"          -NOSTORETIME Don't store the timestamp of the new file in the patch\n"
"                       file.  Instead, set the timestamp of the patch file to\n"
"                       the timestamp of the new file.\n"
"\n"
"          -FAILBIGGER  If patch file is bigger than simple compressed file,\n"
"                       don't create the patch file (takes longer).\n"
"\n"
"          -NEWSYMPATH:PathName[;PathName]\n"
"\n"
"                       For files in NewFilesPath, search for symbol file(s) in\n"
"                       this path location (recursive search each path).  If\n"
"                       not specified, the default is the same directory as the\n"
"                       NewFile.\n"
"\n"
"          -OLDSYMPATH:PathName[;PathName]\n"
"\n"
"                       For files in OldFilesPath, search for symbol file(s) in\n"
"                       this path location (recursive search each path).  If\n"
"                       not specified, the default is the same directory as the\n"
"                       OldFile.\n"
"\n"
"          -NOSYMS      Don't use debug symbol files when creating the patch.\n"
"\n"
"          -NOSYMFAIL   Don't fail to create patch if symbols cannot be loaded.\n"
"\n"
"          -NOSYMWARN   Don't warn if symbols can't be found or don't match the\n"
"                       corresponding file (symbol checksum mismatch).\n"
"\n"
"          -USEBADSYMS  Rather than ignoring symbols if the checksums don't\n"
"                       match the corresponding files, use the bad symbols.\n"
"\n"
"          -E8          Force E8 call translation for x86 binaries.\n"
"\n"
"          -NOE8        Force no E8 call translation for x86 binaries.\n"
"\n"
"                       If neither -E8 or -NOE8 are specified, and the files\n"
"                       are x86 binaries, the patch will be built internally\n"
"                       twice and the smaller will be chosen for output.\n"
"\n"
"          -COPYOTHERS  For files in NewFilesPath for which no corresponding\n"
"                       file exists in OldFilesPath, copy the new file to the\n"
"                       PatchFilesPath directory.  If -FAILBIGGER is also\n"
"                       specified, this will cause the new file to be copied to\n"
"                       the patch directory if the patch file would be larger\n"
"                       than simply compressing the new file.\n"
"\n"
"          -SUBDIRS     Process subdirectories too.\n"
"\n"
"          -FOREST      Use OldFilesPath as a forest of potentially-useful old\n"
"                       files, and create a patch from every file found there\n"
"                       with the same base name as the new file.  OldFilesPath\n"
"                       is searched recursively for each base name.\n"
"\n"
"          -FILES:list  The specified list is a text file containing a list of\n"
"                       the files in NewFilesPath that are actually needed.\n"
"                       By default, patches are created for all files found in\n"
"                       NewFilesPath.  A list contains one file name per line.\n"
"\n"
"          -FALLBACKS   Create fallback files: null patches or uncompressed,\n"
"                       whichever is smaller.\n"
"\n"
"          -CACHE:path  Use the specified path as a cache of patches created.\n"
"                       The cache is checked for each patch is created, and\n"
"                       and patches which are created are added to the cache.\n"
"                       Using a cache can substantially reduce the amount of\n"
"                       time required for subsequent MPATCHES sessions.\n"
"                       By default, no cache is created or used.  The cache is\n"
"                       organized for MPATCHES use only.\n"
"\n"
"          -CHANGED     Only create patches if existing patch file has an older\n"
"                       date/time stamp as the corresponding new file.  Used to\n"
"                       incrementally updating patches for only those files\n"
"                       that changed.\n"
"\n"
"          -CRCNAME     Name patch files with CRC of normalized old file as\n"
"                       part of the filename (like foo.dll.e75a3b7d._p).\n"
"\n"
"                       Be careful using -CRCNAME together with -CHANGED.  When\n"
"                       these are used together, all files in the target patch\n"
"                       directory matching foo.dll.*._p will be deleted other\n"
"                       than the exact patch file name.  In other words, don't\n"
"                       use the same target patch directory to build patches\n"
"                       from more than one set of old files.\n"
"\n"
"          -WINDOW:nn   Limit the LZX compression memory window to 2^nn bytes\n"
"                       (nn is a power of two >= 17: 128KB).  Patch creation\n"
"                       memory requirement may be 10X this amount, but patch\n"
"                       applier will only this amount of memory plus the size\n"
"                       of the output file (available in version 1.99+).\n"
"\n"
"          -MSPATCHA_WIN2000  Assure the patch file can be applied with version\n"
"                       1.94 of MSPATCHA.DLL (Windows 2000).  May increase size\n"
"                       of patch file if old and new file sizes combined are\n"
"                       larger than 8MB.\n"
"\n"
"          -MSPATCHA_WINXP    Assure the patch file can be used with version\n"
"                       5.1 of MSPATCHA.DLL (Windows XP).  May increase size\n"
"                       of patch file if old and new file sizes combined are\n"
"                       larger than 32MB.\n"
"\n"
"          MPATCHES will also look for environment variables named \"MPATCHES\"\n"
"          followed by an underscore and the name of the option.  Command line\n"
"          specified options override environment variable options.  Examples:\n"
"\n"
"              MPATCHES_NOSTORETIME=1\n"
"              MPATCHES_NEWSYMPATH=c:\\winnt\\symbols;\\\\server\\share\\symbols\n"
"\n"

        );
    exit( 1 );
    }


DWORDLONG
GetFileSizeByName(
    IN LPCSTR FileName
    )
    {
    DWORDLONG FileSizeReturn;
    ULONG     FileSizeHigh;
    ULONG     FileSizeLow;
    HANDLE    hFile;

    FileSizeReturn = 0xFFFFFFFFFFFFFFFF;

    hFile = CreateFile(
                FileName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile != INVALID_HANDLE_VALUE ) {

        FileSizeLow = GetFileSize( hFile, &FileSizeHigh );

        if (( FileSizeLow != 0xFFFFFFFF ) || ( GetLastError() == NO_ERROR )) {

            FileSizeReturn = ((DWORDLONG)FileSizeHigh << 32 ) | FileSizeLow;
            }

        CloseHandle( hFile );
        }

    return FileSizeReturn;
    }


BOOL
IsDirectory(
    LPCSTR PathName
    )
{
    DWORD Attributes;

    Attributes = GetFileAttributes( PathName );

    if ( Attributes == 0xFFFFFFFF ) {

        return FALSE;
        }

    if ( Attributes & FILE_ATTRIBUTE_DIRECTORY ) {

        return TRUE;
        }

    return FALSE;
}


BOOL
IsFile(
    LPCSTR PathName
    )
{
    DWORD Attributes;

    Attributes = GetFileAttributes( PathName );

    if ( Attributes == 0xFFFFFFFF ) {

        return FALSE;
        }

    if ( Attributes & FILE_ATTRIBUTE_DIRECTORY ) {

        return FALSE;
        }

    return TRUE;
}


BOOL
CreateNewDirectoryForFile(
    LPSTR FileName
    )
{
    BOOL Result = FALSE;
    CHAR *p = strrchr( FileName, '\\' );

    if ( p == NULL ) {
        return FALSE;
        }

    *p = '\0';

    if ( GetFileAttributes( FileName ) == 0xFFFFFFFF ) {

        switch ( GetLastError() ) {

        case ERROR_FILE_NOT_FOUND:
            Result = CreateDirectory( FileName, NULL );
            break;

        case ERROR_PATH_NOT_FOUND:
            Result = CreateNewDirectoryForFile( FileName ) &&
                     CreateDirectory( FileName, NULL );
            break;
            }
        }

    *p = '\\';

    return( Result );
}


BOOL
GetMpatchEnvironVar(
    IN  LPCSTR VarName,
    OUT LPSTR  Buffer
    )
    {
    CHAR LocalBuffer[ 256 ];
    CHAR EnvironName[ 256 ];
    LPSTR EnvironValue;

    EnvironValue = Buffer ? Buffer : LocalBuffer;

    sprintf( EnvironName, "mpatches_%s", VarName );

    if ( GetEnvironmentVariable( EnvironName, EnvironValue, 65500 )) {

        if ( Buffer == NULL ) {

            if (( *LocalBuffer == '0' ) && ( strtoul( LocalBuffer, NULL, 0 ) == 0 )) {
                return FALSE;
                }
            }

        return TRUE;
        }

    return FALSE;
    }


VOID
StripTrailingBackslash(
    IN LPSTR PathName
    )
    {
    LPSTR p;

    if (( PathName[ 0 ] != '\0' ) &&
        ( PathName[ 1 ] == ':'  ) &&
        ( PathName[ 2 ] == '\\' ) &&
        ( PathName[ 3 ] == '\0' )) {

        return;
        }

    p = PathName + strlen( PathName );

    while (( p > PathName ) && ( *( --p ) == '\\' )) {
        *p = 0;
        }
    }


VOID
AppendTrailingBackslash(
    IN LPSTR PathName
    )
    {
    LPSTR p;

    p = PathName + strlen( PathName );

    if (( p > PathName ) && ( *( p - 1 ) != '\\' )) {
        *p++ = '\\';
        *p = 0;
        }
    }


BOOL
CALLBACK
MySymLoadCallback(
    IN ULONG  WhichFile,
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    )
    {
    LPCSTR *FileNameArray = CallbackContext;
    LPCSTR SymTypeText;

    if (( SymType == SymNone ) || ( SymType == SymExport )) {

        //
        //  Symbols could not be found.
        //

        if ( ! bNoSymWarn ) {

            printf(
                "\n"
                "WARNING: no debug symbols for %s\n\n",
                FileNameArray[ WhichFile ]
                );
            }

        return TRUE;
        }

    //
    //  Note that the Old file checksum is the checksum AFTER normalization,
    //  so if the original .dbg file was updated with bound checksum, the
    //  old file's checksum will not match the symbol file's checksum.  But,
    //  binding a file does not change its TimeDateStamp, so that should be
    //  a valid comparison.  But, .sym files don't have a TimeDateStamp, so
    //  the SymbolFileTimeDate may be zero.  If either the checksums match
    //  or the timedate stamps match, we'll say its valid.
    //

    if (( ImageFileCheckSum == SymbolFileCheckSum ) ||
        ( ImageFileTimeDate == SymbolFileTimeDate )) {

        return TRUE;
        }

    if ( ! bNoSymWarn ) {

        switch ( SymType ) {
            case SymNone:     SymTypeText = "No";       break;
            case SymCoff:     SymTypeText = "Coff";     break;
            case SymCv:       SymTypeText = "CodeView"; break;
            case SymPdb:      SymTypeText = "Pdb";      break;
            case SymExport:   SymTypeText = "Export";   break;
            case SymDeferred: SymTypeText = "Deferred"; break;
            case SymSym:      SymTypeText = "Sym";      break;
            case 0x1001:      SymTypeText = ".psym";    break;
            default:          SymTypeText = "Unknown";  break;
            }

        printf(
            "\n"
            "WARNING: %s symbols %s don't match %s:\n"
            "    symbol file checksum (%08X) does not match image (%08X), and\n"
            "    symbol file timedate (%08X) does not match image (%08X).\n\n",
            SymTypeText,
            SymbolFileName,
            FileNameArray[ WhichFile ],
            SymbolFileCheckSum,
            ImageFileCheckSum,
            SymbolFileTimeDate,
            ImageFileTimeDate
            );
        }

    return bUseBadSyms;
    }


VOID
RecursiveDescent(
    VOID
    );

VOID
BuildUsingFileList(
    VOID
    );

VOID
MyCreatePath(
    IN LPSTR FullFileName
    );

VOID
DeleteOtherPatchFiles(
    IN LPCSTR Directory,
    IN LPCSTR FileName,
    IN LPCSTR DontDeleteSignature
    );


int __cdecl
SortNodeCompare(
    const void * _SortNode1,
    const void * _SortNode2
    )
{
    const SORTNODE * SortNode1 = _SortNode1;
    const SORTNODE * SortNode2 = _SortNode2;
    int i;

    i = min( SortNode1->Node->NameLength, SortNode2->Node->NameLength );

    i = strncmp( SortNode1->Node->Name, SortNode2->Node->Name, i );

    if ( i == 0 ) {

        i = SortNode1->Node->NameLength - SortNode2->Node->NameLength;
        }

    return( i );
}

void
ReportCompressionRatio(
    QWORD qwSourceSize,
    QWORD qwTargetSize
    )
{
    double Percent = 0;
    double Ratio = 0;

    if ( qwSourceSize != 0 )
    {
        Percent = ((( signed __int64 )( qwSourceSize - qwTargetSize ) * 100.0 ) / qwSourceSize );

        if ( Percent > 99.99 )
        {
             Percent = 99.99;
        }
    }

    if ( qwTargetSize != 0 )
    {
        Ratio = ((double) qwSourceSize / qwTargetSize );

        if ( Ratio > 99999.99 )
        {
             Ratio = 99999.99;
        }
    }

    printf( "%10I64u bytes (%5.2f%%, %8.2f:1)\n", qwTargetSize, Percent, Ratio );

}


int __cdecl main( int argc, char *argv[] ) {

    LPSTR OldFileName    = NULL;
    LPSTR NewFileName    = NULL;
    LPSTR PatchFileName  = NULL;
    LPSTR PatchCachePath = NULL;
    LPSTR arg;
    LPSTR p, q;
    LPSTR FileName;
    ULONG FileNum;
    int   i;

    DWORDLONG StartTime;
    DWORDLONG StopTime;
    DWORDLONG Elapsed;
    SYSTEMTIME SysTime;

    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG TotalSeconds;

    NAME_TREE_ENUM NewFileEnumerator;
    NAME_NODE * Node;
    NEWFILE * NewFile;
    ULONG NewFileIndex;
    SORTNODE * NewFilesSorted;

    ULONG WindowSizePower = 0;

    BOOL Force194 = FALSE;
    BOOL Force197 = FALSE;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    GetSystemTimeAsFileTime( (PFILETIME)&StartTime );

    CopyRight();

    OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_PE_IRELOC_2;   // unless explicitly disabled
    OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_PE_RESOURCE_2; // unless explicitly disabled

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }
        }

    //
    //  First get environment arguments because command-line args will
    //  override them.
    //

    if ( GetMpatchEnvironVar( "e8", NULL )) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_A;
        }

    if ( GetMpatchEnvironVar( "noe8", NULL )) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_B;
        }

    if ( GetMpatchEnvironVar( "mspatch194compat", NULL )) {
        Force194 = TRUE;
        }

    if ( GetMpatchEnvironVar( "mspatcha_win2000", NULL )) {
        Force194 = TRUE;
        }

    if ( GetMpatchEnvironVar( "mspatch197compat", NULL )) {
        Force197 = TRUE;
        }

    if ( GetMpatchEnvironVar( "mspatcha_winxp", NULL )) {
        Force197 = TRUE;
        }

    if ( GetMpatchEnvironVar( "nobindfix", NULL )) {
        OptionFlags |= PATCH_OPTION_NO_BINDFIX;
        }

    if ( GetMpatchEnvironVar( "nolockfix", NULL )) {
        OptionFlags |= PATCH_OPTION_NO_LOCKFIX;
        }

    if ( GetMpatchEnvironVar( "norebase", NULL )) {
        OptionFlags |= PATCH_OPTION_NO_REBASE;
        }

    if ( GetMpatchEnvironVar( "norestime", NULL )) {
        OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
        }

    if ( GetMpatchEnvironVar( "nochecksum", NULL )) {
        OptionFlags |= PATCH_OPTION_NO_CHECKSUM;
        }

    if ( GetMpatchEnvironVar( "nostoretime", NULL )) {
        OptionFlags |= PATCH_OPTION_NO_TIMESTAMP;
        }

    if ( GetMpatchEnvironVar( "failbigger", NULL )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
        }

    if ( GetMpatchEnvironVar( "failifbigger", NULL )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
        }

    if ( GetMpatchEnvironVar( "failsame", NULL )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
        }

    if ( GetMpatchEnvironVar( "failifsame", NULL )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
        }

    if ( GetMpatchEnvironVar( "undecorated", NULL )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_UNDECORATED_TOO;
        }

    if ( GetMpatchEnvironVar( "nosyms", NULL )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_IMAGEHLP;
        }

    if ( GetMpatchEnvironVar( "nosymfail", NULL )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_FAILURES;
        }

    if ( GetMpatchEnvironVar( "nosymwarn", NULL )) {
        bNoSymWarn = TRUE;
        }

    if ( GetMpatchEnvironVar( "noaffinity", NULL )) {
        bNoAffinity = TRUE;
        }

    if ( GetMpatchEnvironVar( "usebadsyms", NULL )) {
        bUseBadSyms = TRUE;
        }

    if ( GetMpatchEnvironVar( "copyothers", NULL )) {
        bCopyNonPatches = TRUE;
        }

    if ( GetMpatchEnvironVar( "subdirs", NULL )) {
        bSubDirectories = TRUE;
        }

    if ( GetMpatchEnvironVar( "forest", NULL )) {
        bSourceIsForest = TRUE;
        }

    if ( GetMpatchEnvironVar( "changed", NULL )) {
        bIncremental = TRUE;
        }

    if ( GetMpatchEnvironVar( "crcname", NULL )) {
        bCrcName = TRUE;
        }

    if ( GetMpatchEnvironVar( "window", TextBuffer )) {
        WindowSizePower = strtoul( TextBuffer, NULL, 0 );
        }

    if ( GetMpatchEnvironVar( "oldsympath", TextBuffer )) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum == 1 ) {
            strcpy( OldSymPath, FileName );
            }
        }

    if ( GetMpatchEnvironVar( "newsympath", TextBuffer )) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum == 1 ) {
            strcpy( NewSymPath, FileName );
            }
        }

    if ( GetMpatchEnvironVar( "files", TextBuffer )) {

        strcpy( NewFileList, TextBuffer );
        }

    if ( GetMpatchEnvironVar( "cache", TextBuffer )) {

        bCaching = TRUE;
        PatchCachePath = _strdup( TextBuffer );
        }

    if ( GetMpatchEnvironVar( "fallbacks", NULL )) {

        bCreateFallbackFiles = TRUE;
        }

    if ( GetMpatchEnvironVar( "notransformrelocs", NULL  )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELOCS;
        }

    if ( GetMpatchEnvironVar( "notransformresource", NULL  )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RESOURCE;
        }

    if ( GetMpatchEnvironVar( "notransformimports", NULL  )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_IMPORTS;
        }

    if ( GetMpatchEnvironVar( "notransformexports", NULL  )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_EXPORTS;
        }

    if ( GetMpatchEnvironVar( "notransformreljmps", NULL  )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELJMPS;
        }

    if ( GetMpatchEnvironVar( "notransformrelcalls", NULL  )) {
        OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELCALLS;
        }



    //
    //  Now process commandline args
    //

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }

        if (( *arg == '-' ) || ( *arg == '/' )) {

            _strlwr( ++arg );

            if ( strcmp( arg, "e8" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_USE_LZX_A;
                }
            else if ( strcmp( arg, "noe8" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_USE_LZX_B;
                }
            else if ( strcmp( arg, "mspatch194compat" ) == 0 ) {
                Force194 = TRUE;
                }
            else if ( strcmp( arg, "mspatcha_win2000" ) == 0 ) {
                Force194 = TRUE;
                }
            else if ( strcmp( arg, "mspatch197compat" ) == 0 ) {
                Force197 = TRUE;
                }
            else if ( strcmp( arg, "mspatcha_winxp" ) == 0 ) {
                Force197 = TRUE;
                }
            else if ( strcmp( arg, "nobindfix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_BINDFIX;
                }
            else if ( strcmp( arg, "bindfix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_BINDFIX;
                }
            else if ( strcmp( arg, "nolockfix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_LOCKFIX;
                }
            else if ( strcmp( arg, "lockfix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_LOCKFIX;
                }
            else if ( strcmp( arg, "norebase" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_REBASE;
                }
            else if ( strcmp( arg, "rebase" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_REBASE;
                }
            else if ( strcmp( arg, "norestime" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "norestimefix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "restime" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "restimefix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "nochecksum" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_CHECKSUM;
                }
            else if ( strcmp( arg, "checksum" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_CHECKSUM;
                }
            else if ( strcmp( arg, "nostoretime" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_TIMESTAMP;
                }
            else if ( strcmp( arg, "storetime" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_TIMESTAMP;
                }
            else if ( strcmp( arg, "failbigger" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "nofailbigger" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "failifbigger" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "nofailifbigger" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "failifsame" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "failsame" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nofailifsame" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nofailsame" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "decorated" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_UNDECORATED_TOO;
                }
            else if ( strcmp( arg, "undecorated" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_UNDECORATED_TOO;
                }
            else if ( strcmp( arg, "nosyms" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_IMAGEHLP;
                }
            else if ( strcmp( arg, "syms" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_NO_IMAGEHLP;
                }
            else if ( strcmp( arg, "nosymfail" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_FAILURES;
                }
            else if ( strcmp( arg, "symfail" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_NO_FAILURES;
                }
            else if ( strcmp( arg, "nosymwarn" ) == 0 ) {
                bNoSymWarn = TRUE;
                }
            else if ( strcmp( arg, "symwarn" ) == 0 ) {
                bNoSymWarn = FALSE;
                }
            else if ( strcmp( arg, "noaffinity" ) == 0 ) {
                bNoAffinity = TRUE;
                }
            else if ( strcmp( arg, "usebadsyms" ) == 0 ) {
                bUseBadSyms = TRUE;
                }
            else if ( strcmp( arg, "nousebadsyms" ) == 0 ) {
                bUseBadSyms = FALSE;
                }
            else if ( strcmp( arg, "nobadsyms" ) == 0 ) {
                bUseBadSyms = FALSE;
                }
            else if ( strcmp( arg, "copyothers" ) == 0 ) {
                bCopyNonPatches = TRUE;
                }
            else if ( strcmp( arg, "nocopyothers" ) == 0 ) {
                bCopyNonPatches = FALSE;
                }
            else if ( strcmp( arg, "subdirs" ) == 0 ) {
                bSubDirectories = TRUE;
                }
            else if ( strcmp( arg, "forest" ) == 0 ) {
                bSourceIsForest = TRUE;
                }
            else if ( strcmp( arg, "changed" ) == 0 ) {
                bIncremental = TRUE;
                }
            else if ( strcmp( arg, "crcname" ) == 0 ) {
                bCrcName = TRUE;
                }
            else if ( strcmp( arg, "nocrcname" ) == 0 ) {
                bCrcName = FALSE;
                }
            else if ( memcmp( arg, "window:", 7 ) == 0 ) {

                WindowSizePower = strtoul( arg + 7, NULL, 0 );

                if ( WindowSizePower == 0 ) {
                    Usage();
                    }
                }

            else if ( memcmp( arg, "oldsympath:", 11 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum != 1 ) {
                    Usage();
                    }

                strcpy( OldSymPath, FileName );
                }
            else if ( memcmp( arg, "newsympath:", 11 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum != 1 ) {
                    Usage();
                    }

                strcpy( NewSymPath, FileName );
                }
            else if ( memcmp( arg, "files:", 6 ) == 0 ) {

                strcpy( NewFileList, strchr( arg, ':' ) + 1 );
                }
            else if ( memcmp( arg, "cache:", 6 ) == 0 ) {

                bCaching = TRUE;
                PatchCachePath = arg + 6;
                }
            else if ( strcmp( arg, "fallbacks" ) == 0 ) {

                bCreateFallbackFiles = TRUE;
                }

            else if ( strcmp( arg, "notransformrelocs" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELOCS;
                }
            else if ( strcmp( arg, "notransformresource" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RESOURCE;
                }
            else if ( strcmp( arg, "notransformimports" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_IMPORTS;
                }
            else if ( strcmp( arg, "notransformexports" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_EXPORTS;
                }
            else if ( strcmp( arg, "notransformreljmps" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELJMPS;
                }
            else if ( strcmp( arg, "notransformrelcalls" ) == 0 ) {
                OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELCALLS;
                }

            else if (( strcmp( arg, "nocompare"  ) == 0 ) ||
                     ( strcmp( arg, "docompare"  ) == 0 ) ||
                     ( strcmp( arg, "compare"    ) == 0 ) ||
                     ( strcmp( arg, "noprogress" ) == 0 ) ||
                     ( strcmp( arg, "progress"   ) == 0 )) {

                ;   // politely ignore mpatch.exe options we don't support
                }

            else {
                Usage();
                }
            }

        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else {
            Usage();
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        }

    if ( WindowSizePower != 0 ) {

		OptionFlags |= PATCH_OPTION_EXTENDED_OPTIONS;
        OptionData.ExtendedOptionFlags |= PATCH_OPTION_SPECIFIED_WINDOW;
        OptionData.MaxLzxWindowSize = 1 << WindowSizePower;

        if ( OptionData.MaxLzxWindowSize < LZX_MINWINDOW ) {
            Usage();
            }
        }

    if ( Force194 ) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_LARGE;
        Force197 = TRUE;
        }

    if ( Force197 ) {
        OptionFlags &= ~PATCH_OPTION_INTERLEAVE_FILES;
        OptionData.ExtendedOptionFlags &= ~PATCH_OPTION_SPECIFIED_WINDOW;
        OptionData.ExtendedOptionFlags &= ~PATCH_TRANSFORM_PE_IRELOC_2;
        OptionData.ExtendedOptionFlags &= ~PATCH_TRANSFORM_PE_RESOURCE_2;
        OptionData.InterleaveMapArray = NULL;
        OptionData.MaxLzxWindowSize = 0;
        }

    if ( bSourceIsForest ) {
        bCrcName = TRUE;
        }

    //
    //  Useful on MP machines, set affinity to one processor and lower
    //  priority to below normal since we are heavily CPU intensive.
    //

    if ( ! bNoAffinity ) {

        ULONG InstanceCounterSnap = _InterlockedExchangeAdd( &SharedInstanceCounter, 1 );
        ULONG ProcessAffinityMask = 1;
        ULONG SystemAffinityMask;

        GetProcessAffinityMask(
            GetCurrentProcess(),
            &ProcessAffinityMask,
            &SystemAffinityMask
            );

        if ( ProcessAffinityMask > 1 ) {

            //
            //  Note this is just a "good effort", it is not perfect because
            //  process/system affinity mask is not always packed in the lowest
            //  bits and we're not wrapping.  If this shift doesn't result in
            //  a valid mask, SetAffinityMask will simply fail leaving us
            //  running on any available processor.
            //

            ProcessAffinityMask = 1 << ( InstanceCounterSnap & 0x1F );

            SetProcessAffinityMask( GetCurrentProcess(), ProcessAffinityMask );

            }

        SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_LOWEST );

        }

    GetFullPathName( OldFileName,   sizeof( OldDirRoot ),   OldDirRoot,   &FileName );
    GetFullPathName( NewFileName,   sizeof( NewDirRoot ),   NewDirRoot,   &FileName );
    GetFullPathName( PatchFileName, sizeof( PatchDirRoot ), PatchDirRoot, &FileName );

    StripTrailingBackslash( OldDirRoot );
    StripTrailingBackslash( NewDirRoot );

    if ( ! *OldSymPath ) {
        strcpy( OldSymPath, OldDirRoot );
        }

    if ( ! *NewSymPath ) {
        strcpy( NewSymPath, NewDirRoot );
        }

    AppendTrailingBackslash( OldDirRoot );
    AppendTrailingBackslash( NewDirRoot );
    AppendTrailingBackslash( PatchDirRoot );

    _strlwr( OldDirRoot );
    _strlwr( NewDirRoot );
    _strlwr( PatchDirRoot );

    NewDirRootEnd = NewDirRoot + strlen( NewDirRoot );
    OldDirRootEnd = OldDirRoot + strlen( OldDirRoot );
    PatchDirRootEnd = PatchDirRoot + strlen( PatchDirRoot );

    if ( bCaching ) {

        GetFullPathName( PatchCachePath, sizeof( PatchCache ), PatchCache, &FileName );
        StripTrailingBackslash( PatchCache );
        AppendTrailingBackslash( PatchCache );
        PatchCacheEnd = PatchCache + strlen( PatchCache );
        CreateNewDirectoryForFile( PatchCache );
        if ( ! IsDirectory( PatchCache )) {

            printf( "MPATCHES: Invalid path for patch cache \"%s\"\n", PatchCache );
            return( 1 );
            }
        }

    SubAllocator = CreateSubAllocator( 0x10000, 0x10000 );
    if ( SubAllocator == NULL ) {

        printf( "MPATCHES: Out of memory\n" );
        return( 1 );
        }

    NameRbInitTree( &NewFileTree, SubAllocator );
    NameRbInitTree( &MD5Tree, SubAllocator );

    if ( NewFileList[ 0 ] == '\0' ) {

        RecursiveDescent();
        }
    else {

        BuildUsingFileList();
        }

    AssociateNewFileDuplicates();

    NewFilesSorted = malloc( CountNewFiles * sizeof( SORTNODE ));
    if ( NewFilesSorted == NULL ) {

        printf( "MPATCHES: Out of memory\n" );
        return( 1 );
        }

    NewFileIndex = 0;

    Node = NameRbEnumFirst( &NewFileEnumerator, &NewFileTree );

    while ( Node != NULL ) {

        for ( NewFile = ((PRODUCTFILE *) Node->Context)->FirstNewFile;
              NewFile != NULL;
              NewFile = NewFile->Next ) {

            NewFilesSorted[ NewFileIndex ].NewFile = NewFile;
            NewFilesSorted[ NewFileIndex ].Node = Node;

            NewFileIndex++;
            }

        Node = NameRbEnumNext( &NewFileEnumerator );
        }

    qsort( NewFilesSorted, CountNewFiles, sizeof( SORTNODE ), SortNodeCompare );

    if ( bSourceIsForest ) {

        OldFileName = OldDirRootEnd;
        }

    for ( NewFileIndex = 0; NewFileIndex < CountNewFiles; NewFileIndex++ ) {

        NewFile = NewFilesSorted[ NewFileIndex ].NewFile;
        Node    = NewFilesSorted[ NewFileIndex ].Node;

        strcpy( NewDirRootEnd, NewFile->Path );
        NewFileName = strchr( NewDirRootEnd, '\0' );
        memcpy( NewFileName, Node->Name, Node->NameLength );
        NewFileName[ Node->NameLength ] = '\0';

        if ( ! bSourceIsForest ) {

            strcpy( OldDirRootEnd, NewFile->Path );
            OldFileName = strchr( OldDirRootEnd, '\0' );
            }

        strcpy( PatchDirRootEnd, NewFile->Path );
        PatchFileName = strchr( PatchDirRootEnd, '\0' );

        MakePatchesForFile( NewFileName,
                            OldFileName,
                            PatchFileName,
                            NewFile->FileTime,
                            NewFile->FileSize
                            );
        }

    GetSystemTimeAsFileTime( (PFILETIME)&StopTime );

    Elapsed = StopTime - StartTime;

    FileTimeToSystemTime( (PFILETIME)&Elapsed, &SysTime );

    Hours   = SysTime.wHour;
    Minutes = SysTime.wMinute;
    Seconds = SysTime.wSecond;

    Hours += (ULONG)( SysTime.wDay - 1 ) * 24;

    TotalSeconds = ( Hours * 3600 ) + ( Minutes * 60 ) + Seconds;

    printf( "\n\nTotal:\n\n" );

    if ( CountPatchFiles > 0 ) {

        printf( "%9u patches:               ", CountPatchFiles );

        ReportCompressionRatio( TotalPatchSourceSizes, TotalPatchTargetSizes );

        }

    else {

        printf( "%9u patches\n", 0 );

        }

    if ( TotalCopiedSizes > 0 ) {

        printf( "%9u copies:      %20I64u bytes\n",
                CountCopiedFiles,
                TotalCopiedSizes
              );

        }

    else if ( bCopyNonPatches ) {

        printf( "%9u copies\n", 0 );

        }

    if (( TotalPatchSourceSizes > 0 ) && ( TotalCopiedSizes > 0 )) {

        TotalPatchSourceSizes += TotalCopiedSizes;
        TotalPatchTargetSizes += TotalCopiedSizes;
        CountPatchFiles       += CountCopiedFiles;

        printf( "%9u total:       %20I64u bytes\n", CountPatchFiles, TotalPatchSourceSizes );
        }

    if ( TotalSeconds > 0 ) {

        printf( "%3d:%02d:%02d elapsed:     %20I64u new file bytes per second\n",
                Hours,
                Minutes,
                Seconds,
                TotalPatchSourceSizes / TotalSeconds
              );
        }

    if ( ErrorCount )
    {
        printf( "\n%9u ERRORS!!!\a\a\a\n", ErrorCount );
    }

    printf( "\n" );

    if ( ErrorCount )
    {
        return ErrorCount;
    }

    return( ReturnCode );
    }


ULONG
MakePatchesForFile(
    LPCSTR   NewDirFileName,    // base file name in NewDirRoot, ie "kernel32.dll" in "new\uniproc\kernel32.dll"
    LPSTR    OldDirFileName,    // pos for base file name in OldDirRoot, ie "x" in "old\uniproc\x"
                                // or top base if bSourceIsForest, ie "x" in "old\x", not drilled down
    LPSTR    PatchDirFileName,  // pos for base file name in PatchDirRoot, ie "x" in "patches\uniproc\x"
    FILETIME NewFileLastWriteTime,
    DWORD    NewFileSize
    )
    {
    static WIN32_FILE_ATTRIBUTE_DATA FileData;
    CHAR     OldFileHash[ HASH_HEX_LENGTH ];
    CHAR     NewFileHash[ HASH_HEX_LENGTH ];
    CHAR     CrcTextBuffer[ 16 ];
    BOOL     Success;
    ULONG    PatchFileSize;
    ULONG    Result = 0;

    Success = FALSE;

    strcpy( PatchDirFileName, "x" );
    CreateNewDirectoryForFile( PatchDirRoot );

    if ( bCreateFallbackFiles ) {

        Success = FALSE;

        //
        // create null patch
        //

        if ( ! bCaching ||
             GetFilePatchSignature( NewDirRoot,
                                      PATCH_OPTION_NO_REBASE
                                    | PATCH_OPTION_NO_BINDFIX
                                    | PATCH_OPTION_NO_LOCKFIX
                                    | PATCH_OPTION_NO_RESTIMEFIX
                                    | PATCH_OPTION_SIGNATURE_MD5,
                                    NULL,
                                    0, NULL,    // no ignore
                                    0, NULL,    // no retain
                                    sizeof( NewFileHash ),
                                    NewFileHash )) {

            if ( strlen( NewDirRootEnd ) > 25 ) {

                printf( "%s\n%-25s ", NewDirRootEnd, "" );
                }
            else {

                printf( "%-25s ", NewDirRootEnd );
                }

            printf( "base  " );

            strcpy( PatchDirFileName, NewDirFileName );
            strcat( PatchDirFileName, "._p0" );

            if ( bCaching ) {

                strcpy( PatchCacheEnd, NewDirFileName );
                strcat( PatchCacheEnd, "\\" );
                strcat( PatchCacheEnd, NewFileHash );
                strcat( PatchCacheEnd, "\\" );
                strcat( PatchCacheEnd, szZeroLengthFileHash );
                }

            if (( bIncremental ) &&
                ( GetFileAttributesEx( PatchDirRoot, GetFileExInfoStandard, &FileData )) &&
                ( CompareFileTime( &FileData.ftLastWriteTime, &NewFileLastWriteTime ) == 0 )) {

                printf( "is current\n" );
                Success = TRUE;
                }

            else if ( bCaching &&
                     CopyFile( PatchCache, PatchDirRoot, FALSE ) &&
                     AdjustPatchTime( PatchDirRoot, NewFileLastWriteTime )) {

                 printf("*");

                 Success = TRUE;
                }

            else {

                PATCH_OLD_FILE_INFO_A OldFileInfo = {
                                        sizeof( PATCH_OLD_FILE_INFO_A ),
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        NULL
                                        };

                ULONG ZeroPatchOptionFlags = OptionFlags;

                ZeroPatchOptionFlags &= ~PATCH_OPTION_FAIL_IF_BIGGER;
                ZeroPatchOptionFlags &= ~PATCH_OPTION_INTERLEAVE_FILES;

                ZeroPatchOptionFlags &= ~PATCH_OPTION_USE_LZX_A;
                ZeroPatchOptionFlags |=  PATCH_OPTION_USE_LZX_B;        // always use E8 in LZX

                ZeroPatchOptionFlags |=  PATCH_OPTION_NO_BINDFIX;
                ZeroPatchOptionFlags |=  PATCH_OPTION_NO_LOCKFIX;
                ZeroPatchOptionFlags |=  PATCH_OPTION_NO_REBASE;
                ZeroPatchOptionFlags |=  PATCH_OPTION_NO_CHECKSUM;
                ZeroPatchOptionFlags |=  PATCH_OPTION_NO_RESTIMEFIX;

                Success = CreatePatchFileEx(
                              1,
                              &OldFileInfo,
                              NewDirRoot,
                              PatchDirRoot,
                              ZeroPatchOptionFlags,
                              NULL,
                              NULL,
                              NULL
                              );

                if ( Success ) {

                    printf(" ");

                    if ( bCaching ) {

                        if ( ! CopyFile( PatchDirRoot, PatchCache, FALSE )) {

                            if ( CreateNewDirectoryForFile( PatchCache )) {

                                CopyFile( PatchDirRoot, PatchCache, FALSE );
                                }
                            }
                        }
                    }

                else {

                    ULONG ErrorCode = GetLastError();

                    CHAR ErrorText[ 20 ];

                    sprintf( ErrorText, ( ErrorCode < 0x80000000 ) ? "%d" : "%X", ErrorCode );

                    printf( "failed!!! (%s)\a\n", ErrorText );

                    ErrorCount++;
                    }
                }

            if ( Success ) {

                PatchFileSize = (ULONG) GetFileSizeByName( PatchDirRoot );

                if (( NewFileSize != 0 ) && ( PatchFileSize != 0xFFFFFFFF )) {

                    if ( PatchFileSize > NewFileSize ) {

                        printf( "failed (patch bigger than new file)\n" );

                        DeleteFile( PatchDirRoot );

                        Success = FALSE;

                        //
                        //  This should not increase error count as it is
                        //  a requested failure.
                        //
                        }

                    else {

                        ReportCompressionRatio( NewFileSize, PatchFileSize );

                        TotalPatchSourceSizes += NewFileSize;
                        TotalPatchTargetSizes += PatchFileSize;
                        CountPatchFiles++;

                        }
                    }
                }

            fflush( stdout );
            }

        //
        //  if null patch fallback doesn't work out, copy uncompressed instead
        //

        if ( ! Success ) {

            strcpy( PatchDirFileName, NewDirFileName );

            if ( CopyFile( NewDirRoot, PatchDirRoot, FALSE ) ||
                ( CreateNewDirectoryForFile( PatchDirRoot ) &&
                  CopyFile( NewDirRoot, PatchDirRoot, FALSE ))) {

                Success = TRUE;
                }

            else {

                printf( "MPATCHES: Unable to create fallback file for %s\n", NewDirFileName );

                ReturnCode = 1;
                }
            }
        }

    if ( GetFirstCandidate( OldDirRoot, OldDirFileName, NewDirFileName, OldFileHash ) &&
         ( ! bCaching ||
           GetFilePatchSignature( NewDirRoot,
                                    PATCH_OPTION_NO_REBASE
                                  | PATCH_OPTION_NO_BINDFIX
                                  | PATCH_OPTION_NO_LOCKFIX
                                  | PATCH_OPTION_NO_RESTIMEFIX
                                  | PATCH_OPTION_SIGNATURE_MD5,
                                  NULL,
                                  0, NULL,    // no ignore
                                  0, NULL,    // no retain
                                  HASH_HEX_LENGTH,
                                  NewFileHash ))) {

        do {

            *CrcTextBuffer = 0;

            if ( strlen( NewDirRootEnd ) > 25 ) {

                printf( "%s\n%-25s ", NewDirRootEnd, "" );
                }
            else {

                printf( "%-25s ", NewDirRootEnd );
                }

            printf( "patch " );

            Success = TRUE;

            if ( bCrcName ) {

                Success = GetFilePatchSignature(
                              OldDirRoot,
                              OptionFlags | PATCH_OPTION_NO_CHECKSUM,
                              &OptionData,
                              0,
                              NULL,
                              0,
                              NULL,
                              sizeof( CrcTextBuffer ),
                              CrcTextBuffer
                              );

                if ( Success ) {

                    sprintf(
                        PatchDirFileName,
                        "%s.%s._p",
                        NewDirFileName,
                        CrcTextBuffer
                        );
                    }
                }

            else {

                strcpy( PatchDirFileName, NewDirFileName );
                strcat( PatchDirFileName, "._p" );
                }

            if ( bCaching ) {

                strcpy( PatchCacheEnd, NewDirFileName );
                strcat( PatchCacheEnd, "\\" );
                strcat( PatchCacheEnd, NewFileHash );
                strcat( PatchCacheEnd, "\\" );
                strcat( PatchCacheEnd, OldFileHash );
                }

            if ( Success ) {

                if (( bIncremental ) &&
                    ( GetFileAttributesEx( PatchDirRoot, GetFileExInfoStandard, &FileData )) &&
                    ( CompareFileTime( &FileData.ftLastWriteTime, &NewFileLastWriteTime ) == 0 )) {

                    // target exists with same timestamp as source, so skip it.

                    printf( "is current\n" );
                    Success = TRUE;
                    }

                else {

                    if ( bCaching &&
                         CopyFile( PatchCache, PatchDirRoot, FALSE ) &&
                         AdjustPatchTime( PatchDirRoot, NewFileLastWriteTime )) {

                         printf("*");

                         Success = TRUE;
                        }
                    else {

                        PATCH_OLD_FILE_INFO_A OldFileInfo = {
                                                sizeof( PATCH_OLD_FILE_INFO_A ),
                                                OldDirRoot,
                                                0,
                                                NULL,
                                                0,
                                                NULL
                                                };

                        strcpy( OldPsymPath, OldSymPath );
                        AppendTrailingBackslash( OldPsymPath );
                        strcat( OldPsymPath, OldDirFileName );
                        strcat( OldPsymPath, ".psym" );

                        if ( GetFileAttributes( OldPsymPath ) != (DWORD) -1 )
                        {
                            strcpy( NewPsymPath, NewSymPath );
                            AppendTrailingBackslash( NewPsymPath );
                            strcat( NewPsymPath, NewDirFileName );
                            strcat( NewPsymPath, ".psym" );

                            if ( GetFileAttributes( NewPsymPath ) != (DWORD) -1 )
                            {
                                OptionData.NewFileSymbolPath = NewPsymPath;
                                OldSymPathArray[ 0 ]         = OldPsymPath;
                            }
                        }

                        Success = CreatePatchFileEx(
                                      1,
                                      &OldFileInfo,
                                      NewDirRoot,
                                      PatchDirRoot,
                                      OptionFlags,
                                      &OptionData,
                                      NULL,
                                      NULL
                                      );

                        if (( ! Success ) && ( GetLastError() & 0xC0000000 )) {

                            //
                            //  try without resource fixups
                            //

                            ULONG OriginalExtendedOptions = OptionData.ExtendedOptionFlags;

                            OptionData.ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RESOURCE;

                            Success = CreatePatchFileEx(
                                          1,
                                          &OldFileInfo,
                                          NewDirRoot,
                                          PatchDirRoot,
                                          OptionFlags,
                                          &OptionData,
                                          NULL,
                                          NULL
                                          );

                            OptionData.ExtendedOptionFlags = OriginalExtendedOptions;

                            }

                        OptionData.NewFileSymbolPath = NewSymPath;  // restore
                        OldSymPathArray[ 0 ]         = OldSymPath;  // restore

                        if ( Success && bCaching ) {

                            // goes into cache even if larger, so we don't have to discover it again

                            if ( ! CopyFile( PatchDirRoot, PatchCache, FALSE )) {

                                if ( CreateNewDirectoryForFile( PatchCache )) {

                                    CopyFile( PatchDirRoot, PatchCache, FALSE );
                                    }
                                }
                            }

                        printf(" ");
                        }


                    if ( Success ) {

                        ULONG PatchFileSize = (ULONG) GetFileSizeByName( PatchDirRoot );

                        if (( NewFileSize != 0 ) && ( PatchFileSize != 0xFFFFFFFF )) {

                            if ( PatchFileSize > NewFileSize ) {

                                printf( "failed (patch bigger than new file)\n" );

                                DeleteFile( PatchDirRoot );
                                }
                            else {

                                ReportCompressionRatio( NewFileSize, PatchFileSize );

                                TotalPatchSourceSizes += NewFileSize;
                                TotalPatchTargetSizes += PatchFileSize;
                                CountPatchFiles++;

                                }
                            }
                        }

                    else {

                        ULONG ErrorCode = GetLastError();

                        if ( ErrorCode == ERROR_PATCH_BIGGER_THAN_COMPRESSED ) {

                            printf( "failed (patch bigger than compressed file)\n" );
                            }

                        else if ( ErrorCode == ERROR_PATCH_SAME_FILE ) {

                            printf( "skipped (same file)\n" );
                            }

                        else {

                            CHAR ErrorText[ 20 ];

                            sprintf( ErrorText, ( ErrorCode < 0x10000000 ) ? "%d" : "%X", ErrorCode );

                            printf( "failed!!! (%s)\a\n", ErrorText );

                            Result = 1;

                            ErrorCount++;
                            }
                        }
                    }
                }

            fflush( stdout );
            }
        while ( GetNextCandidate( OldDirRoot, OldDirFileName, NewDirFileName, OldFileHash ));
    }

    if ( Success ) {

        if ( ! bCreateFallbackFiles ) {

            //
            //  Found or created a patch, so make sure file does not
            //  also exist as non-patch in target directory.
            //

            strcpy( PatchDirFileName, NewDirFileName );
            DeleteFile( PatchDirRoot );
            }
        //
        //  If we're in both bIncremental and bCrcName modes, then
        //  we need to delete any other patch files for the same
        //  old file in this target directory.  This is to get rid
        //  of stale patch files.
        //

        if (( bIncremental ) && ( bCrcName )) {
            *PatchDirFileName = 0;
            DeleteOtherPatchFiles( PatchDirRoot, NewDirFileName, CrcTextBuffer );
            }
        }

    else if (( ! Success ) && ( bCopyNonPatches )) {

        if ( strlen( NewDirRootEnd ) > 25 ) {

            printf( "\r%-25s ", "" );
            }
        else {

            printf( "\r%-25s ", NewDirRootEnd );
            }

        if (( bCrcName ) && ( *CrcTextBuffer )) {

            sprintf(
                PatchDirFileName,
                "%s.%s._p",
                NewDirFileName,
                CrcTextBuffer
                );

            DeleteFile( PatchDirRoot );

            if ( bIncremental ) {
                *PatchDirFileName = 0;
                DeleteOtherPatchFiles( PatchDirRoot, NewDirFileName, CrcTextBuffer );
                }
            }

        else {

            strcpy( PatchDirFileName, NewDirFileName );
            strcat( PatchDirFileName, "._p" );
            DeleteFile( PatchDirRoot );
            }

        strcpy( PatchDirFileName, NewDirFileName );

        if (( bIncremental ) &&
            ( GetFileAttributesEx( PatchDirRoot, GetFileExInfoStandard, &FileData )) &&
            ( CompareFileTime( &FileData.ftLastWriteTime, &NewFileLastWriteTime ) == 0 )) {

            // target exists with same timestamp as source, so skip it.

            printf( "copy  is current\n" );
            Success = TRUE;
            }

        else {

            Success = CopyFile( NewDirRoot, PatchDirRoot, FALSE );

            if ( Success ) {

                printf( "copy   %10u bytes\n", NewFileSize );

                TotalCopiedSizes += NewFileSize;
                CountCopiedFiles++;

                }
            else {
                printf( "copy  failed!!! (%d)\a\n", GetLastError() );
                Result = 1;
                ErrorCount++;
                }
            }
        }

    fflush( stdout );

    return( Result );
    }


VOID
RecursiveDescent(
    VOID
    )
    {
    static WIN32_FIND_DATA FindData;
    unsigned    PathLength = strlen( NewDirRootEnd );
    LPSTR       NewDirFileName = NewDirRootEnd + PathLength;
    HANDLE      hFind;
    NAME_NODE * Node;
    NEWFILE   * NewFile;

    strcpy( NewDirFileName, "*" );

    hFind = FindFirstFile( NewDirRoot, &FindData );

    *NewDirFileName = 0;

    if ( hFind == INVALID_HANDLE_VALUE ) {
        printf( "\nFailed reading directory %s (GLE=%d)\a\n", NewDirRoot, GetLastError() );
        ReturnCode = 1;
        ErrorCount++;
        }

    else {

        do  {

            if ( ! ( FindData.dwFileAttributes & ( FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN ))) {

                _strlwr( FindData.cFileName );

                Node = NameRbInsert( &NewFileTree, FindData.cFileName );
                if ( Node == NULL ) {
                    printf( "Out of memory\n" );
                    ReturnCode = 1;
                    break;
                    }

                if ( Node->Context == NULL ) {

                    Node->Context = SubAllocate( SubAllocator, sizeof( PRODUCTFILE ));
                    if ( Node->Context == NULL ) {
                        printf( "Out of memory\n" );
                        ReturnCode = 1;
                        break;
                        }
                    }

                NewFile = SubAllocate( SubAllocator, sizeof( NEWFILE ) + PathLength );
                if ( NewFile == NULL ) {
                    printf( "Out of memory\n" );
                    ReturnCode = 1;
                    break;
                    }

                NewFile->FileNode = Node;
                NewFile->FileTime = FindData.ftLastWriteTime;
                NewFile->FileSize = FindData.nFileSizeLow;

                strcpy( NewFile->Path, NewDirRootEnd );

                NewFile->Next = ((PRODUCTFILE *) Node->Context)->FirstNewFile;
                ((PRODUCTFILE *) Node->Context)->FirstNewFile = NewFile;

                CountNewFiles++;
                }
            }
        while ( FindNextFile( hFind, &FindData ));

        if ( GetLastError() != ERROR_NO_MORE_FILES ) {
            printf( "\nFailed reading directory %s (GLE=%d)\a\n", NewDirRoot, GetLastError() );
            ErrorCount++;
            ReturnCode = 1;
            }

        FindClose( hFind );

        if ( bSubDirectories && ( ReturnCode == 0 )) {

            strcpy( NewDirFileName, "*" );

            hFind = FindFirstFile( NewDirRoot, &FindData );

            *NewDirFileName = 0;

            if ( hFind == INVALID_HANDLE_VALUE ) {
                printf( "\nFailed reading directory %s (GLE=%d)\a\n", NewDirRoot, GetLastError() );
                ErrorCount++;
                ReturnCode = 1;
                }

            else {

                do  {

                    if ((   ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )) &&
                        ( ! ( FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN    )) &&
                        ( strcmp( FindData.cFileName, "."  ) != 0 ) &&
                        ( strcmp( FindData.cFileName, ".." ) != 0 )) {

                        _strlwr( FindData.cFileName );

                        if ( strcmp( FindData.cFileName, "symbols"  ) != 0 ) {

                            strcat( FindData.cFileName, "\\" );
                            strcpy( NewDirFileName, FindData.cFileName );

                            RecursiveDescent();

                            *NewDirFileName = 0;
                            }
                        }
                    }
                while ( FindNextFile( hFind, &FindData ));

                if ( GetLastError() != ERROR_NO_MORE_FILES ) {
                    printf( "\nFailed reading directory %s (GLE=%d)\a\n", NewDirRoot, GetLastError() );
                    ErrorCount++;
                    ReturnCode = 1;
                    }

                FindClose( hFind );
                }
            }
        }
    }


#if 0
VOID
OldRecursiveDescent(
    VOID
    )
    {
    static WIN32_FIND_DATA FindData;
    LPSTR  OldDirFileName   = strchr( OldDirRoot,   0 );
    LPSTR  NewDirFileName   = strchr( NewDirRoot,   0 );
    LPSTR  PatchDirFileName = strchr( PatchDirRoot, 0 );
    BOOL   FirstPatchInDir  = TRUE;
    HANDLE hFind;
    ULONG  Result;

    strcpy( NewDirFileName, "*" );

    hFind = FindFirstFile( NewDirRoot, &FindData );

    if ( hFind == INVALID_HANDLE_VALUE ) {
        *NewDirFileName = 0;
        printf( "\nFailed reading directory %s (GLE=%d)\a\n", NewDirRoot, GetLastError() );
        ErrorCount++;
        ReturnCode = 1;
        }

    else {

        do  {

            if ( ! ( FindData.dwFileAttributes & ( FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN ))) {

                _strlwr( FindData.cFileName );

                if ( FirstPatchInDir ) {
                     FirstPatchInDir = FALSE;
                     MyCreatePath( PatchDirRoot );
                     }

                strcpy( NewDirFileName, FindData.cFileName );

                Result = MakePatchesForFile( NewDirFileName,
                                             OldDirFileName,
                                             PatchDirFileName,
                                             FindData.ftLastWriteTime,
                                             FindData.nFileSizeLow
                                             );
                if ( Result != 0 ) {

                    ReturnCode = Result;
                    }
                }
            }
        while ( FindNextFile( hFind, &FindData ));

        if ( GetLastError() != ERROR_NO_MORE_FILES ) {
            *NewDirFileName = 0;
            printf( "\nFailed reading directory %s (GLE=%d)\a\n", NewDirRoot, GetLastError() );
            ErrorCount++;
            ReturnCode = 1;
            }

        FindClose( hFind );

        if ( bSubDirectories ) {

            strcpy( NewDirFileName, "*" );

            hFind = FindFirstFile( NewDirRoot, &FindData );

            if ( hFind == INVALID_HANDLE_VALUE ) {
                *NewDirFileName = 0;
                printf( "\nFailed reading directory %s (GLE=%d)\a\n", NewDirRoot, GetLastError() );
                ErrorCount++;
                ReturnCode = 1;
                }

            else {

                do  {

                    _strlwr( FindData.cFileName );

                    if ((   ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )) &&
                        ( ! ( FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN    )) &&
                        ( strcmp( FindData.cFileName, "symbols"  ) != 0 ) &&
                        ( strcmp( FindData.cFileName, "."  ) != 0 ) &&
                        ( strcmp( FindData.cFileName, ".." ) != 0 )) {

                        strcat( FindData.cFileName, "\\" );
                        strcpy( NewDirFileName,   FindData.cFileName );
                        if ( ! bSourceIsForest ) {
                            strcpy( OldDirFileName, FindData.cFileName );
                            }
                        else {
                            *OldDirFileName = '\0';
                            }
                        strcpy( PatchDirFileName, FindData.cFileName );

                        RecursiveDescent();

                        }
                    }
                while ( FindNextFile( hFind, &FindData ));

                if ( GetLastError() != ERROR_NO_MORE_FILES ) {
                    *NewDirFileName = 0;
                    printf( "\nFailed reading directory %s (GLE=%d)\a\n", NewDirRoot, GetLastError() );
                    ErrorCount++;
                    ReturnCode = 1;
                    }

                FindClose( hFind );
                }
            }
        }

    *OldDirFileName   = 0;
    *NewDirFileName   = 0;
    *PatchDirFileName = 0;
    }
#endif


BOOL
GetNextFileName(
    IN OUT LPSTR * BufferPosition,
       OUT LPSTR * FileName
    )
    {
    LPSTR Position = * BufferPosition;

    enum { LOOKING_FOR_NAME,    // skipping all whitespace incl. line breaks
           COLLECTING_NAME,     // collecting until filename-breaking character
           COLLECTING_QUOTED,   // collecting until closing quote
           DISCARD_TO_NEWLINE,  // got a name, skipping to line break
           CHECK_NAME           // on a line break, maybe we got a name
         } State = LOOKING_FOR_NAME;

    while ( *Position != '\0' ) {

        switch ( State ) {

        case LOOKING_FOR_NAME:

            if ( strchr( " \t\r\n", *Position ) != NULL ) {

                Position++;
                }
            else if ( *Position == '"' ) {

                Position++;
                *FileName = Position;

                State = COLLECTING_QUOTED;
                }
            else {

                *FileName = Position;

                State = COLLECTING_NAME;
                }
            break;

        case COLLECTING_NAME:

            if ( strchr( "\r\n", *Position ) != NULL ) {

                State = CHECK_NAME;
                }

            else if ( strchr( ";+=,[] \"\t", *Position ) != NULL ) {

                *Position++ = '\0';

                State = DISCARD_TO_NEWLINE;
                }
            else {

                Position++;
                }
            break;

        case COLLECTING_QUOTED:

            if ( strchr( "\r\n", *Position ) != NULL ) {

                State = CHECK_NAME;
                }
            else if ( *Position == '"' ) {

                *Position++ = '\0';

                State = DISCARD_TO_NEWLINE;
                }
            else {

                Position++;
                }
            break;

        case DISCARD_TO_NEWLINE:

            if ( strchr( "\r\n", *Position ) != NULL ) {

                State = CHECK_NAME;
                }
            else {

                Position++;
                }
            break;

        case CHECK_NAME:

            *Position++ = '\0';

            if ( **FileName == '\0' ) {

                State = LOOKING_FOR_NAME;
                }
            else {

                _strlwr( *FileName );

                *BufferPosition = Position;

                return TRUE;
                }
            break;

            }
        }

    *BufferPosition = Position;

    switch ( State ) {

    case COLLECTING_NAME:
    case COLLECTING_QUOTED:
    case DISCARD_TO_NEWLINE:

        if ( **FileName != '\0' ) {

            _strlwr( *FileName );

            return TRUE;
            }
        }

    return FALSE;
    }


LPSTR
LoadFileListIntoBuffer(
    IN LPCSTR ListFileName
    )
    {
    HANDLE hList;
    DWORD  dwActual;
    DWORD  FileListLength;
    LPSTR  FileListBuffer = NULL;

    hList = CreateFile( ListFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

    if ( hList != INVALID_HANDLE_VALUE ) {

        FileListLength = GetFileSize( hList, NULL );

        if ( FileListLength != 0xFFFFFFFF ) {

            FileListBuffer = GlobalAlloc(GMEM_FIXED, FileListLength + 1 );
            if ( FileListBuffer != NULL ) {

                if ( ReadFile( hList,
                               FileListBuffer,
                               FileListLength,
                               &dwActual,
                               NULL ) &&
                     ( dwActual == FileListLength )) {

                    FileListBuffer[ FileListLength ] = '\0';
                    }
                else {

                    GlobalFree( FileListBuffer );
                    FileListBuffer = NULL;
                    }
                }
            }

        CloseHandle( hList );
        }

    if ( FileListBuffer == NULL ) {

        printf( "\nUnable to read list file \"%s\" (GLE=%d)\n", ListFileName, GetLastError() );
        }

    return FileListBuffer;
}


VOID
BuildUsingFileList(
    VOID
    )
    {
    WIN32_FILE_ATTRIBUTE_DATA FileInfo;
    unsigned                  PathLength;
    LPSTR                     FileListBuffer;
    LPSTR                     FileListPosition;
    LPSTR                     FileName;
    LPSTR                     BaseName;
    NAME_NODE               * Node;
    NEWFILE                 * NewFile;

    FileListBuffer = LoadFileListIntoBuffer( NewFileList );

    if ( FileListBuffer == NULL ) {

        ReturnCode = 1;
        return;
        }

    FileListPosition = FileListBuffer;

    while ( GetNextFileName( &FileListPosition, &FileName )) {

        if (( NewDirRootEnd + strlen( FileName ) - NewDirRoot ) >= sizeof( NewDirRoot )) {

            printf( "Invalid filename %s (too long)\n", FileName );
            ReturnCode = 1;
            }

        else {

            _strlwr( FileName );

            strcpy( NewDirRootEnd, FileName );

            if ( ! GetFileAttributesEx( NewDirRoot,
                                        GetFileExInfoStandard,
                                        &FileInfo ) ||
                (( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )) {

                printf( "\nFile %s not found\n", NewDirRoot );
                ReturnCode = 1;
                }

            BaseName = strrchr( NewDirRootEnd, '\\' );

            if ( BaseName == NULL ) {

                BaseName = NewDirRootEnd;
                }
            else {

                BaseName++;
                }

            PathLength = BaseName - NewDirRootEnd;

            Node = NameRbInsert( &NewFileTree, BaseName );
            if ( Node == NULL ) {
                printf( "Out of memory\n" );
                ReturnCode = 1;
                break;
                }

            if ( Node->Context == NULL ) {

                Node->Context = SubAllocate( SubAllocator, sizeof( PRODUCTFILE ));
                if ( Node->Context == NULL ) {
                    printf( "Out of memory\n" );
                    ReturnCode = 1;
                    break;
                    }
                }

            *BaseName = 0;

            for ( NewFile = ((PRODUCTFILE *) Node->Context)->FirstNewFile;
                  NewFile != NULL;
                  NewFile = NewFile->Next ) {

                if ( strcmp( NewFile->Path, NewDirRootEnd ) == 0 ) {
                    break;
                    }
                }

            if ( NewFile == NULL ) {

                NewFile = SubAllocate( SubAllocator, sizeof( NEWFILE ) + PathLength );
                if ( NewFile == NULL ) {
                    printf( "Out of memory\n" );
                    ReturnCode = 1;
                    break;
                    }

                NewFile->FileNode = Node;
                NewFile->FileTime = FileInfo.ftLastWriteTime;
                NewFile->FileSize = FileInfo.nFileSizeLow;

                strcpy( NewFile->Path, NewDirRootEnd );

                NewFile->Next = ((PRODUCTFILE *) Node->Context)->FirstNewFile;
                ((PRODUCTFILE *) Node->Context)->FirstNewFile = NewFile;

                CountNewFiles++;
                }
            }
        }

    GlobalFree( FileListBuffer );

    *NewDirRootEnd = 0;

    if ( ReturnCode ) {

        return;
        }
    }


VOID
MyCreatePath(
    IN LPSTR FullFileName
    )
    {
    LPSTR p = FullFileName;

    while ( *p ) {
       if ( *p == '\\' ) {
            *p = 0;
            CreateDirectory( FullFileName, NULL );
            *p = '\\';
            }
        ++p;
        }
    }


VOID
DeleteOtherPatchFiles(
    IN LPCSTR Directory,
    IN LPCSTR FileName,
    IN LPCSTR DontDeleteSignature
    )
    {
    static WIN32_FIND_DATA FindData;
    CHAR NamePattern[ MAX_PATH ];
    CHAR DontDelete[ MAX_PATH ];
    HANDLE hFind;

    sprintf( DontDelete, "%s.%s._p", FileName, DontDeleteSignature );
    sprintf( NamePattern, "%s%s.*._p", Directory, FileName );

    hFind = FindFirstFile( NewDirRoot, &FindData );

    if ( hFind != INVALID_HANDLE_VALUE ) {

        do  {

            if ( ! ( FindData.dwFileAttributes & ( FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN ))) {

                if ( _stricmp( FindData.cFileName, DontDelete ) != 0 ) {

                    sprintf( NamePattern, "%s%s", Directory, FindData.cFileName );
                    DeleteFile( NamePattern );
                    }
                }
            }

        while ( FindNextFile( hFind, &FindData ));

        FindClose( hFind );
        }
    }


BOOL
GetFirstCandidate(
    LPSTR  OldDirRoot,
    LPSTR  OldDirFileName,
    LPCSTR NewFileName,
    CHAR  *CandidateHash
    )
    {
    if ( ! bSourceIsForest ) {

        strcpy( OldDirFileName, NewFileName );

        if (( GetFileAttributes( OldDirRoot ) & ( FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN )) == 0 ) {

            if ( ! bCaching ||
                 GetFilePatchSignature( OldDirRoot,
                                          PATCH_OPTION_NO_REBASE
                                        | PATCH_OPTION_NO_BINDFIX
                                        | PATCH_OPTION_NO_LOCKFIX
                                        | PATCH_OPTION_NO_RESTIMEFIX
                                        | PATCH_OPTION_SIGNATURE_MD5,
                                        NULL,
                                        0, NULL,    // no ignore
                                        0, NULL,    // no retain
                                        HASH_HEX_LENGTH,
                                        CandidateHash )) {

                return TRUE;
                }
            }

        return FALSE;   // no matching file in OldDirRoot
        }
    else {  // if bSourceIsForest is TRUE

        if ( OldDirTree == NULL ) {

            BuildOldDirTree( OldDirRoot );
            }

        NameHash = HashString( NewFileName );
        NameNode = HashTable[ NameHash % HASH_TABLE_WIDTH ];

        return( GetNextCandidate( OldDirRoot, OldDirFileName, NewFileName, CandidateHash ));
        }
    }


BOOL
DigestToHexString(
    IN  PMD5_HASH HashValue,
    OUT LPSTR     Buffer
    )
    {
    if (( HashValue->Word32[ 0 ] ||
          HashValue->Word32[ 1 ] ||
          HashValue->Word32[ 2 ] ||
          HashValue->Word32[ 3 ] ) &&
          HashToHexString( HashValue, Buffer )) {

        return TRUE;
        }

    return FALSE;
    }


BOOL
GetNextCandidate(
    LPSTR  OldDirRoot,
    LPSTR  OldDirFileName,
    LPCSTR NewFileName,
    CHAR  *CandidateHash
    )
    {
    UNREFERENCED_PARAMETER( OldDirRoot );

    while ( NameNode != NULL ) { // if bSourceIsForest == FALSE, then NameNode = NULL

        if (( NameNode->HashValue == NameHash ) &&
            ( _stricmp( NameNode->BaseName, NewFileName ) == 0 )) {

            *OldDirFileName = '\0';
            BuildDirPath( OldDirFileName, NameNode->Parent );
            strcat( OldDirFileName, NameNode->Name );

            if ( ! bCaching ||
                 DigestToHexString( &NameNode->Digest, CandidateHash ) ||
                 GetFilePatchSignature( OldDirRoot,
                                          PATCH_OPTION_NO_REBASE
                                        | PATCH_OPTION_NO_BINDFIX
                                        | PATCH_OPTION_NO_LOCKFIX
                                        | PATCH_OPTION_NO_RESTIMEFIX
                                        | PATCH_OPTION_SIGNATURE_MD5,
                                        NULL,
                                        0, NULL,    // no ignore
                                        0, NULL,    // no retain
                                        HASH_HEX_LENGTH,
                                        CandidateHash )) {

                NameNode = NameNode->Next;

                return TRUE;
                }
            }

        NameNode = NameNode->Next;
        }

    return FALSE;
    }


DWORD
HashString(
    LPCSTR String
    )
    {
    DWORD Result = 0;

    while ( *String ) {

        Result *= 137;
        Result ^= toupper( *String );
        String++;
        }

    return Result;
    }


VOID
BuildDirPath(
    LPSTR Buffer,
    PATHNODE *Parent
    )
    {

    //  recursively reconstitute path into buffer by gathering each component name from it's parent

    if ( Parent->Parent != NULL ) {

        BuildDirPath( Buffer, Parent->Parent );
        }

    strcat( Buffer, Parent->Name );
    }


VOID
BuildOldDirTree(
    LPSTR OldDirRoot
    )
    {
    OldDirTree = GlobalAlloc(GMEM_FIXED, sizeof( PATHNODE ));
    if ( OldDirTree != NULL ) {

        OldDirTree->Parent = NULL;
        OldDirTree->Name[0] = '\0';

        RecursiveBuildOldDirTree( OldDirRoot, OldDirTree );
        }
    }


VOID
RecursiveBuildOldDirTree(
    LPSTR OldDirPath,
    PATHNODE *Parent
    )
    //TODO filter these out using new name tree instead of loading the whole tree
    {
    LPSTR OldDirPathEnd = strchr( OldDirPath, 0 );
    static WIN32_FIND_DATA FindData;
    HANDLE hFind;

    if ( LoadTreeUsingManifest( OldDirRoot,
                                OldDirPathEnd,
                                Parent )) {

        return;
        }

    strcpy( OldDirPathEnd, "*" );

    hFind = FindFirstFile( OldDirPath, &FindData );

    if ( hFind == INVALID_HANDLE_VALUE ) {
        *OldDirPathEnd = '\0';
        printf( "\nFailed reading directory %s (GLE=%d)\a\n", OldDirPath, GetLastError() );
        ErrorCount++;
        ReturnCode = 1;
        }

    else {

        do {

            if (( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                ( ! ( FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )) &&
                ( _stricmp( FindData.cFileName, "symbols"  ) != 0 ) &&
                ( strcmp( FindData.cFileName, "."  ) != 0 ) &&
                ( strcmp( FindData.cFileName, ".." ) != 0 )) {

                PATHNODE *PathNode;

                strcpy( OldDirPathEnd, FindData.cFileName );
                strcat( OldDirPathEnd, "\\" );

                PathNode = GlobalAlloc( GMEM_FIXED, sizeof( PATHNODE ) + strlen( OldDirPathEnd ));
                if ( PathNode != NULL ) {

                    PathNode->Parent = Parent;
                    strcpy( PathNode->Name, OldDirPathEnd );

                    RecursiveBuildOldDirTree( OldDirPath, PathNode );
                    }
                }
            else if ( ! ( FindData.dwFileAttributes & ( FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN ))) {

                NAMENODE *NameNode;

                NameNode = GlobalAlloc( GMEM_FIXED, sizeof( NAMENODE ) + strlen( FindData.cFileName ));
                if ( NameNode != NULL ) {

                    DWORD HashIndex = HashString( FindData.cFileName );

                    NameNode->Parent = Parent;
                    NameNode->HashValue = HashIndex;
                    NameNode->BaseName = NameNode->Name;
                    memset( &NameNode->Digest, 0, sizeof( NameNode->Digest ));
                    strcpy( NameNode->Name, FindData.cFileName );

                    HashIndex %= HASH_TABLE_WIDTH;

                    NameNode->Next = HashTable[ HashIndex ];
                    HashTable[ HashIndex ] = NameNode;
                    }
                }
            }
            while ( FindNextFile( hFind, &FindData ));

            FindClose( hFind );
        }
    }


BOOL
LoadTreeUsingManifest(
    LPSTR RootPath,
    LPSTR RootPathEnd,
    PATHNODE * Parent
    )
    {
    BOOL            Success = FALSE;
    HANDLE          hManifest;
    MANIFEST_HEADER Header;
    MANIFEST_RECORD Record;
    CHAR            FileName[ MAX_PATH + 1 ];
    DWORD           dwActual;
    NAMENODE       *NameNode;
    DWORD           HashIndex;

    strcpy( RootPathEnd, MANIFEST_DATA_FILE_NAME );

    hManifest = CreateFile( RootPath,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

    if ( hManifest == INVALID_HANDLE_VALUE ) {

        goto finished;
        }

    if (( ! ReadFile( hManifest,
                      &Header,
                      sizeof( Header ),
                      &dwActual,
                      NULL )) ||
        ( dwActual != sizeof( Header )) ||
        ( Header.dwSignature != MANIFEST_SIGNATURE ) ||
        ( Header.dwVersion != MANIFEST_VERSION )) {

        goto finished;
        }

    while ( Header.cTotalFiles-- ) {

        if (( ! ReadFile( hManifest,
                         &Record,
                         sizeof( Record ),
                         &dwActual,
                         NULL )) ||
            ( dwActual != sizeof( Record )) ||
            ( Record.cchFileName >= sizeof( FileName )) ||
            ( Record.cchFileName == 0 ) ||
            ( ! ReadFile( hManifest,
                         FileName,
                         Record.cchFileName,
                         &dwActual,
                         NULL )) ||
            ( dwActual != Record.cchFileName )) {

            goto finished;
            }

        //TODO store, filter out duplicate digests

        FileName[ Record.cchFileName ] = '\0';

        NameNode = GlobalAlloc( GMEM_FIXED, sizeof( NAMENODE ) + Record.cchFileName);
        if ( NameNode == NULL ) {

            goto finished;
            }

        NameNode->Parent = Parent;
        strcpy( NameNode->Name, FileName );
        NameNode->BaseName = strrchr( NameNode->Name, '\\' );
        if ( NameNode->BaseName == NULL ) {
            NameNode->BaseName = NameNode->Name;
            }
        else {
            NameNode->BaseName++;
            }
        memcpy( &NameNode->Digest, &Record.digest, sizeof( NameNode->Digest ));

        HashIndex = HashString( NameNode->BaseName );

        NameNode->HashValue = HashIndex;

        HashIndex %= HASH_TABLE_WIDTH;

        NameNode->Next = HashTable[ HashIndex ];
        HashTable[ HashIndex ] = NameNode;
        }

    Success = TRUE;

finished:

    if ( hManifest != INVALID_HANDLE_VALUE ) {

        CloseHandle( hManifest );
        }

    return( Success );
    }


VOID
AssociateNewFileDuplicates(
    VOID
    )
    {
#if 0
    NAME_TREE_ENUM   FileEnumerator;
    NAME_NODE      * Node;
    PRODUCTFILE    * ProductFile;
    NEWFILE        * NewFile;
    char             FileHash[ HASH_HEX_LENGTH ];

    Node = NameRbEnumFirst( &FileEnumerator, &NewFileTree );

    while ( Node != NULL ) {

        ProductFile = (PRODUCTFILE *) Node->Context;

        for ( NewFile = ProductFile->FirstNewFile; NewFile != NULL; NewFile = NewFile->Next ) {

            if ( NewFile->MD5Node == NULL ) {

                strcpy( NewDirRootEnd, NewFile->Path );


                if ( GetFilePatchSignature( NewDirRoot,
                                          PATCH_OPTION_NO_REBASE
                                        | PATCH_OPTION_NO_BINDFIX
                                        | PATCH_OPTION_NO_LOCKFIX
                                        | PATCH_OPTION_NO_RESTIMEFIX
                                        | PATCH_OPTION_SIGNATURE_MD5,
                                        NULL,
                                        0, NULL,    // no ignore
                                        0, NULL,    // no retain
                                        sizeof( FileHash ),
                                        FileHash )) {
                    }

                *NewDirRootEnd = 0;
                }

            printf( "new file %s%.*s\n", NewFile->Path, Node->NameLength, Node->Name );
            }

        Node = NameRbEnumNext( &FileEnumerator );
        }
#endif
    }


BOOL
AdjustPatchTime(
    LPCSTR   PatchPathName,     // full path to patch file
    FILETIME PatchTimeStamp     // time to store in patch
    )
{
    //  Used when an existing patch is dredged up from the cache.  It's possible that the patch
    //  has a timestamp which doesn't match the new file.  If so, update the patch's timestamp.
    //  Update the embedded file time in the patch header, if any.
    //  Returns TRUE if the file update is successful or no embedded time.
    //  Returns FALSE if the file update fails.  The patch file has probably
    //  been corrupted, and should be discarded.

    BOOL     Success = FALSE;
    HANDLE   hAllocator = NULL;
    HANDLE   FileHandle = INVALID_HANDLE_VALUE;
    HANDLE   MapHandle = NULL;
    PVOID    FileMapped = NULL;
    ULONG    FileSize, FileSizeHigh;
    PPATCH_HEADER_INFO HeaderInfo;
    ULONG    HeaderSize;
    ULONG    NewHeaderSize;
    DWORD    PatchFileCrc;

    __try {

        hAllocator = CreateSubAllocator( 0x2000, 0x10000 );
        if ( hAllocator == NULL ) {
            goto done;
            }

        //
        //  get a read/write mapping of the existing file
        //

        FileHandle = CreateFileA(
                        PatchPathName,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

        if ( FileHandle == INVALID_HANDLE_VALUE ) {
            goto done;
            }

        FileSize = GetFileSize( FileHandle, &FileSizeHigh );

        if (( FileSizeHigh != 0 ) ||
            ( FileSize == 0 )) {
            goto done;
            }

        MapHandle = CreateFileMapping( FileHandle,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       0,
                                       NULL
                                       );

        if ( MapHandle == NULL ) {
            goto done;
            }

        FileMapped = MapViewOfFile( MapHandle,
                                    FILE_MAP_ALL_ACCESS,
                                    0,
                                    0,
                                    0
                                    );

        if ( FileMapped == NULL ) {
            goto done;
            }

        //
        //  decode existing patch header
        //

        if ( ! DecodePatchHeader( FileMapped,
                                  FileSize,
                                  hAllocator,
                                  &HeaderSize,
                                  &HeaderInfo
                                  )) {
            goto done;
            }

        //
        //  if no internal timestamp, update time on patch file itself & exit
        //

        if ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_TIMESTAMP ) {

            UnmapViewOfFile( FileMapped );
            FileMapped = NULL;

            CloseHandle( MapHandle );
            MapHandle = NULL;

            SetFileTime( FileHandle, NULL, NULL, &PatchTimeStamp );

            Success = TRUE;
            goto done;
            }

        //
        //  if internal timestamp is current, leave it alone
        //

        if ( HeaderInfo->NewFileTime == FileTimeToUlongTime( &PatchTimeStamp )) {
            Success = TRUE;
            goto done;
            }

        //
        //  update internal timestamp
        //

        HeaderInfo->NewFileTime = FileTimeToUlongTime( &PatchTimeStamp );

        //
        //  try to re-encode header.  If size changes, give up (and rebuild the patch)
        //

        NewHeaderSize = EncodePatchHeader( HeaderInfo, FileMapped );

        if (NewHeaderSize != HeaderSize ) {
            goto done;
            }

        //
        //  update CRC32 on patch file
        //

        PatchFileCrc = Crc32( 0xFFFFFFFF, FileMapped, FileSize - sizeof( ULONG ));

        *(UNALIGNED ULONG *)( (BYTE *) FileMapped + FileSize - sizeof( ULONG )) = PatchFileCrc;

        FlushViewOfFile( FileMapped, 0 );
        UnmapViewOfFile( FileMapped );
        FileMapped = NULL;

        CloseHandle( MapHandle );
        MapHandle = NULL;

        Success = TRUE;
        }

    __except ( EXCEPTION_EXECUTE_HANDLER ) {

        }

done:

    if ( FileMapped != NULL ) {
        UnmapViewOfFile( FileMapped );
        }

    if ( MapHandle != NULL ) {
        CloseHandle( MapHandle );
        }

    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
        }

    if ( hAllocator != NULL ) {
        DestroySubAllocator( hAllocator );
        }

    return Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decdefs.h ===
/*
 * decdefs.h
 *
 * Structures and definitions used by the decoder
 */


typedef enum
{
	DEC_STATE_UNKNOWN,
	DEC_STATE_START_NEW_BLOCK,
	DEC_STATE_DECODING_DATA
} decoder_state;


/*
 * Size of uncompressed data chunks
 */
#define CHUNK_SIZE  32768


/*
 * Main tree decoding table parameters 
 */

/* # elements in main tree */
#define MAIN_TREE_ELEMENTS			(NUM_CHARS+(context->dec_num_position_slots<<NL_SHIFT))

/*
 * Decoding table size allows a direct lookup on the first 
 * MAIN_TREE_TABLE_BITS bits of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define MAIN_TREE_TABLE_BITS		10 

/*
 * Secondary length tree decoding table parameters
 * Decoding table size allows a direct lookup on the first
 * SECONDARY_LEN_TREE_TABLE_BITS of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define SECONDARY_LEN_TREE_TABLE_BITS	8 

/* 
 * Aligned offset tree decoding table parameters 
 */
#define ALIGNED_NUM_ELEMENTS	8

/*
 * Must be 7, since we do not use left/right for this tree;
 * everything is decoded in one lookup.
 */
#define ALIGNED_TABLE_BITS		7
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\common\compdefs.h ===
/*
 * common/compdefs.h
 *
 * Definitions for both encoder and decoder
 */

/*
 * Smallest allowable match length 
 */
#define MIN_MATCH 2

/* 
 * Maximum match length 
 */
#define MAX_MATCH (MIN_MATCH+255)

/*
 * Number of uncompressed symbols 
 */
#define NUM_CHARS 256

/*
 * Number of match lengths which are correlated with match positions 
 */
#define NUM_PRIMARY_LENGTHS     7

/*
 * Primary lengths plus the extension code
 */
#define NUM_LENGTHS             (NUM_PRIMARY_LENGTHS+1)

/*
 * Equals number of different possible match lengths minus primary lengths 
 */
#define NUM_SECONDARY_LENGTHS   ((MAX_MATCH-MIN_MATCH+1)-NUM_PRIMARY_LENGTHS)

/* NL_SHIFT = log2(NUM_LENGTHS) */
#define NL_SHIFT                3

/*
 * Number of repeated offsets 
 */
#define NUM_REPEATED_OFFSETS    3

/*
 * Number of elements in the aligned offset tree
 */
#define ALIGNED_NUM_ELEMENTS 8


/*
 * Repeat codes for outputting trees
 */

/* Minimum number of repetitions of anything we're interested in */
#define TREE_ENC_REP_MIN                4

/* Maximum repetitions for "type A" repetition of zeroes */
/* (min...min+REP_ZERO_FIRST) */
#define TREE_ENC_REP_ZERO_FIRST        16

/* Maximum repetitions for "type B" repetition of zeroes */
/* (min+REP_ZERO_FIRST...min+REP_ZERO_FIRST+REP_ZERO_SECOND) */
#define TREE_ENC_REP_ZERO_SECOND       32

/* Maximum repetitions for "type C" repetition of anything */
/* (min...min_REP_SAME_FIRST) */
#define TREE_ENC_REP_SAME_FIRST         2

/* Bits required to output the above numbers */
#define TREE_ENC_REPZ_FIRST_EXTRA_BITS  4
#define TREE_ENC_REPZ_SECOND_EXTRA_BITS 5
#define TREE_ENC_REP_SAME_EXTRA_BITS    1

/* Number of cfdata frames before E8's are turned off automatically */
#define E8_CFDATA_FRAME_THRESHOLD       32768


/*
 * Block types 
 */
typedef enum
{
		BLOCKTYPE_INVALID       = 0,
		BLOCKTYPE_VERBATIM      = 1, /* normal block */
		BLOCKTYPE_ALIGNED       = 2, /* aligned offset block */
		BLOCKTYPE_UNCOMPRESSED  = 3  /* uncompressed block */
} lzx_block_type;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\common\typedefs.h ===
/*
 * typedefs.h
 *
 * Type definitions for LZX
 */
#ifndef _TYPEDEFS_H

    #define _TYPEDEFS_H

/*
 * Definitions for LZX
 */
typedef unsigned char   byte;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned int    uint;

typedef enum
    {
    false = 0,
    true = 1
    } bool;


/*
 * Definitions for Diamond/CAB memory allocation
 */
typedef unsigned char   BYTE;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef unsigned int    UINT;


//** Define away for 32-bit (NT/Chicago) build
#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#ifndef NEAR
#define NEAR
#endif

#ifndef PVOID
typedef void * PVOID;
#endif

#ifndef HANDLE
typedef PVOID HANDLE;
#endif


typedef PVOID ( __fastcall * PFNALLOC )( HANDLE hAllocator, ULONG Size );


#endif /* _TYPEDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decalign.c ===
/*
 * decalign.c
 *
 * Decoding aligned offset block
 */
#include "decoder.h"


static long special_decode_aligned_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
    ulong   match_pos;
    ulong   temp_pos;
    long    bufpos_end;
    int             match_length;
    int             c;
    ulong   dec_bitbuf;
    char    dec_bitcount;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    byte   *dec_mem_window;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf                = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = bufpos + amount_to_decode;

    while (bufpos < bufpos_end)
        {
        /*
         * Decode an item
         */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {
#ifdef TRACING
            TracingLiteral(bufpos, (byte) c);
#endif
            dec_mem_window[bufpos] = (byte) c;
            dec_mem_window[context->dec_window_size + bufpos] = (byte) c;
            bufpos++;
            }
        else
            {
            /*
             * Get match length slot
             */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /*
             * Get match position slot
             */
            m = c >> NL_SHIFT;

            if (m > 2)
                {
                if (dec_extra_bits[ m ] >= 3)
                    {
                    if (dec_extra_bits[m]-3)
                        {
                        /* no need to getbits17 */
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
                        }
                    else
                        {
                        temp_pos = 0;
                        }

                    match_pos = MP_POS_minus2[m] + (temp_pos << 3);

                    DECODE_ALIGNED_NOEOFCHECK(temp_pos);
                    match_pos += temp_pos;
                    }
                else
                    {
                    if (dec_extra_bits[m])
                        {
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

                        match_pos += MP_POS_minus2[m];
                        }
                    else
                        {
                        match_pos = 1; // MP_POS_minus2[m==3];
                        }
                    }

                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            match_length += MIN_MATCH;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  Fetch extra match length in addition to MAX_MATCH, which
                //  is encoded like this:
                //
                //      0xxxxxxxx          (8-bit value)
                //      10xxxxxxxxxx       (10-bit value plus 2^8)
                //      110xxxxxxxxxxxx    (12-bit value plus 2^8 plus 2^10)
                //      111xxxxxxxxxxxxxxx (15-bit value)
                //
                //  15 bits is the largest possible because a match cannot
                //  span a 32K boundary.
                //
                //  We know we'll read at least 9 bits, so read 9 bits first
                //  and then determine how many additional to read based on
                //  the first 3 bits of that.
                //

                ULONG ExtraMatchLength;
                ULONG ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {

                            //
                            //  First 3 bits are '111', so that means remaining
                            //  6 bits are the first 6 bits of the 15 bit value
                            //  meaning we must read 9 more bits.
                            //

                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }

                        else {

                            //
                            //  First 3 bits are '110', so that means remaining
                            //  6 bits are the first 6 bits of the 12 bit value
                            //  meaning we must read 6 more bits.  Then we add
                            //  2^8 plus 2^10 to the value.
                            //

                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }

                    else {

                        //
                        //  First 2 bits are '10', so that means remaining
                        //  7 bits are the first 7 bits of the 10 bit value
                        //  meaning we must read 3 more bits.  Then we add
                        //  2^8 to the value.
                        //

                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                else {

                    //
                    //  First bit is a '0', so that means remaining 8 bits are
                    //  the 8 bit value to add to the match length.  No need to
                    //  mask off the leading '0'.
                    //

                    }

                match_length += ExtraMatchLength;

                }

#endif

#ifdef TRACING
            TracingMatch(bufpos,
                         bufpos-match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            do
                {
                dec_mem_window[bufpos] = dec_mem_window[(bufpos-match_pos) & context->dec_window_mask];

                if (bufpos < MAX_MATCH)
                    dec_mem_window[context->dec_window_size+bufpos] = dec_mem_window[bufpos];

                bufpos++;
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf               = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    return bufpos;
}


#ifndef ASM_DECODE_ALIGNED_OFFSET_BLOCK
long fast_decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
    ulong   match_pos;
    ulong   temp_pos;
    long    bufpos_end;
    long    decode_residue;
    int             match_length;
    int             c;
    ulong   dec_bitbuf;
    char    dec_bitcount;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    byte   *dec_mem_window;
    ulong   match_ptr;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf        = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = bufpos + amount_to_decode;

    while (bufpos < bufpos_end)
        {
        /*
         * Decode an item
         */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {

#ifdef TRACING
            TracingLiteral(bufpos, (byte) c);
#endif

            dec_mem_window[bufpos++] = (byte) c;
            }
        else
            {
            /*
             * Get match length slot
             */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /*
             * Get match position slot
             */
            m = c >> NL_SHIFT;

            if (m > 2)
                {
                if (dec_extra_bits[ m ] >= 3)
                    {
                    if (dec_extra_bits[m]-3)
                        {
                        /* no need to getbits17 */
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
                        }
                    else
                        {
                        temp_pos = 0;
                        }

                    match_pos = MP_POS_minus2[m] + (temp_pos << 3);

                    DECODE_ALIGNED_NOEOFCHECK(temp_pos);
                    match_pos += temp_pos;
                    }
                else
                    {
                    if (dec_extra_bits[m])
                        {
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

                        match_pos += MP_POS_minus2[m];
                        }
                    else
                        {
                        match_pos = MP_POS_minus2[m];
                        }
                    }

                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            match_length += MIN_MATCH;
            match_ptr = (bufpos - match_pos) & context->dec_window_mask;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  See detailed explanation above.
                //

                ULONG ExtraMatchLength, ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }
                        else {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }
                    else {
                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                match_length += ExtraMatchLength;
                }

#endif

#ifdef TRACING
            TracingMatch(bufpos,
                         bufpos - match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            do
                {
                dec_mem_window[bufpos++] = dec_mem_window[match_ptr++];
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf       = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    /* should be zero */
    decode_residue = bufpos - bufpos_end;

    bufpos &= context->dec_window_mask;
    context->dec_bufpos = bufpos;

    return decode_residue;
}
#endif


int decode_aligned_offset_block(
                               t_decoder_context * context,
                               long                BufPos,
                               int                 amount_to_decode
                               )
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
        {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = min(MAX_MATCH-BufPos, amount_to_decode);

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_aligned_block(
                                                 context,
                                                 BufPos,
                                                 amount_to_slowly_decode
                                                 );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
        }

    return fast_decode_aligned_offset_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decapi.h ===
/*
 * decapi.h
 *
 * Decoder API definitions
 */

bool __stdcall LZX_DecodeInit(
                  t_decoder_context **dec_context,
                  long                compression_window_size,
                  PFNALLOC            pfnma,
                  HANDLE              hAllocator
                  );

void __fastcall LZX_DecodeNewGroup(t_decoder_context *context);

int __stdcall LZX_Decode(
        t_decoder_context *context,
        long    bytes_to_decode,
        byte *  compressed_input_buffer,
        long    compressed_input_size,
        byte *  uncompressed_output_buffer,
        long    uncompressed_output_size,
        long *  bytes_decoded
        );

bool __fastcall LZX_DecodeInsertDictionary(
    t_decoder_context *context,
    const byte *       data,
    unsigned long      data_size
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decmacro.h ===
/*
 * decmacro.h
 *
 * Macros used by the decoder
 */


/*
 * decode an element from the aligned offset tree, without checking 
 * for the end of the input data
 */
#define DECODE_ALIGNED_NOEOFCHECK(j) \
	(j) = context->dec_aligned_table[dec_bitbuf >> (32-ALIGNED_TABLE_BITS)]; \
	FILL_BUF_NOEOFCHECK(context->dec_aligned_len[(j)]);


/*
 * Decode an element from the main tree
 * Check for EOF
 */
#define DECODE_MAIN_TREE(j) \
	j = context->dec_main_tree_table[dec_bitbuf >> (32-MAIN_TREE_TABLE_BITS)];	\
	if (j < 0)															\
	{																	\
        ulong mask = (1L << (32-1-MAIN_TREE_TABLE_BITS));               \
		do																\
		{																\
	 		j = -j;														\
	 		if (dec_bitbuf & mask)										\
                j = context->dec_main_tree_left_right[j*2+1];                   \
			else														\
                j = context->dec_main_tree_left_right[j*2];                     \
			mask >>= 1;													\
		} while (j < 0);												\
	}																	\
	FILL_BUF_FULLCHECK(context->dec_main_tree_len[j]);


/*
 * Decode an element from the secondary length tree
 * No checking for EOF
 */
#define DECODE_LEN_TREE_NOEOFCHECK(matchlen) \
    matchlen = context->dec_secondary_length_tree_table[dec_bitbuf >> (32-SECONDARY_LEN_TREE_TABLE_BITS)]; \
	if (matchlen < 0)                                                	\
	{                                                                	\
        ulong mask = (1L << (32-1-SECONDARY_LEN_TREE_TABLE_BITS));      \
		do                                                          	\
		{																\
	 		matchlen = -matchlen;                                      	\
	 		if (dec_bitbuf & mask)                                  	\
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2+1];\
			else                                                        \
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2];  \
			mask >>= 1;                                                 \
		} while (matchlen < 0);											\
	}																	\
    FILL_BUF_NOEOFCHECK(context->dec_secondary_length_tree_len[matchlen]);      \
	matchlen += NUM_PRIMARY_LENGTHS;


/*
 * read n bits from input stream into dest_var, but don't
 * check for EOF
 */
#define GET_BITS_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));			\
   FILL_BUF_NOEOFCHECK((N));					\
}


/* same as above, but don't check for EOF */
#define GET_BITS17_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));			\
   FILL_BUF17_NOEOFCHECK((N));					\
}


/*
 * Remove n bits from the input stream
 * handles 1 <= n <= 17
 *
 * FORCE an EOF check ALWAYS, whether or not we read in more
 * bytes from memory.
 *
 * This is used to ensure that we always get an EOF check often enough
 * to not overrun the extra bytes in the buffer.
 *
 * This routine is used ONLY when decoding the main tree element,
 * where we know that the code we read in will be 16 bits or less
 * in length.  Therefore we don't have to check for bitcount going
 * less than zero, twice.
 */
#define FILL_BUF_FULLCHECK(N) \
{                                    		\
	if (dec_input_curpos >= dec_end_input_pos)	\
        return -1; \
	dec_bitbuf <<= (N);            			\
	dec_bitcount -= (N);                    \
	if (dec_bitcount <= 0)      			\
	{                                 		\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2;              \
		dec_bitcount += 16;               	\
    }                                       \
}

/*
 * Same as above, but no EOF check 
 *
 * This is used when we know we will not run out of input
 */
#define FILL_BUF_NOEOFCHECK(N) 			\
{                                    	\
	dec_bitbuf <<= (N);            		\
	dec_bitcount -= (N);                \
	if (dec_bitcount <= 0)      		\
	{                                 	\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
		dec_bitcount += 16;				\
	}                                   \
}

/*
 * Same as above, but handles n=17 bits
 */
#define FILL_BUF17_NOEOFCHECK(N)        \
{                                    	\
	dec_bitbuf <<= (N);            		\
	dec_bitcount -= (N);                \
	if (dec_bitcount <= 0)      		\
	{                                 	\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
		dec_bitcount += 16;				\
		if (dec_bitcount <= 0) \
		{ \
            dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
            dec_input_curpos += 2; \
			dec_bitcount += 16;         \
		} \
	}                                   \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\countdif\countdif.c ===
/* countdif.c -- how many bytes are different between two files? */

#define PROGNAME                "CountDif"
#define PROGVERS                "0.11"


#define EXIT_NO_ERROR           ( 0 )
#define EXIT_COMMAND_ERROR      ( 1 )
#define EXIT_FILE_ERROR         ( 2 )
#define EXIT_MEMORY_ERROR       ( 3 )
#define EXIT_ASSERTION          ( 4 )


#include <stdio.h>
#include <windows.h>

#define JUMBO_HASH

#ifdef JUMBO_HASH
#define MAX_HASH_INDEX            ( 0x1000000 )   // 24-bit hash table = 64MB RAM
#else
#define MAX_HASH_INDEX            ( 0x10000 )     // 16-bit hash table = 256KB RAM
#endif

#define MAX_DWORD                 ( 0xFFFFFFFF )

#define BEST_MATCH_UNKNOWN        ( MAX_DWORD )
#define INVALID_OFFSET            ( MAX_DWORD )

#define DEFAULT_MIN_RUN_LENGTH    ( 3 )
#define DEFAULT_MAX_RUN_LENGTH    ( MAX_DWORD )
#define DEFAULT_MAX_CHAIN_LENGTH  ( 100 )

#define FEATURE_NO_HASHING        ( 0x00000001 )    // use exhaustive searching
#define FEATURE_NO_PRIORITY       ( 0x00000002 )    // walk new fragment list every time
#define FEATURE_SEQUENTIAL        ( 0x00000004 )    // work like a compressor
#define FEATURE_SHOW_FRAGMENTS    ( 0x00000010 )
#define FEATURE_SHOW_STATS        ( 0x00000020 )
#define FEATURE_SHOW_PRIORITY     ( 0x00000040 )
#define FEATURE_SHOW_DIFFERENCES  ( 0x00000100 )

#pragma warning( disable : 4102 )   // unreferenced labels


//
//  NEW_FRAGMENT nodes are contained within two separate bi-di linked lists.
//  One of the lists, rooted by Op->NewFragmentList, stays in sorted Offset
//  order.  The other list is rooted by Op->PriorityQueue, sorted in
//  descending BestMatch order (forming a priority queue.)
//

typedef struct _a_NewFragment NEW_FRAGMENT;

struct _a_NewFragment
{
    NEW_FRAGMENT * Previous;        // previous unmatched fragment
    NEW_FRAGMENT * Next;            // next unmatched fragment

    NEW_FRAGMENT * NextLarger;      // up the priority queue
    NEW_FRAGMENT * NextSmaller;     // down the priority queue

    DWORD          Offset;          // offset into file buffer
    DWORD          Length;          // length of this fragment

    DWORD          BestProspect;    // BestMatch if known, else Length

    DWORD          BestMatch;       // BEST_MATCH_UNKNOWN or length of the best match ever seen
    DWORD          BestNewOffset;   // new file buffer offset of BestMatch
    DWORD          BestOldOffset;   // old file buffer offset of BestMatch
};

typedef struct _a_NewSubFragment NEW_SUBFRAGMENT;

struct _a_NewSubFragment
{
    NEW_FRAGMENT * Fragment;        // subfrag is entirely within this
    DWORD          Offset;          // offset into file buffer
    DWORD          Length;          // length of this subfragment
};


typedef struct _a_OldFragment OLD_FRAGMENT;

struct _a_OldFragment
{
    OLD_FRAGMENT * Previous;        // previous unmatched fragment
    OLD_FRAGMENT * Next;            // next unmatched fragment
    DWORD          Offset;          // offset into file buffer
    DWORD          Length;          // length of this fragment
};

typedef struct _a_OldSubFragment OLD_SUBFRAGMENT;

struct _a_OldSubFragment
{
    OLD_FRAGMENT * Fragment;        // subfrag is entirely within this
    DWORD          Offset;          // offset into file buffer
    DWORD          Length;          // length of this subfragment
};


typedef struct _a_Operation OPERATION;

struct _a_Operation
{
    // fascinating statistical stuff

    DWORD            NumberOfFinds;
    DWORD            NumberOfSkips;
    DWORD            NumberOfRefinds;
    DWORD            NumberOfRefindsAvailable;
    DWORD            NumberOfSinkers;
    DWORD            NumberOfOldFragments;
    DWORD            NumberOfNewFragments;
    DWORD            NumberOfBytesResolvedOld;
    DWORD            NumberOfBytesResolvedNew;
    DWORD            UpdateTick;
    DWORD            SearchTick;

    // output (zero these before calling)

    DWORD            NumberOfBytesChangedOld;
    DWORD            NumberOfBytesChangedNew;
    DWORD            NumberOfBytesMatched;
    DWORD            NumberOfMatches;

    // input to CountFileDifferences()

    CHAR           * OldFileName;
    CHAR           * NewFileName;

    DWORD            MinimumRunLength;      // minimum length of a match
    DWORD            MaximumRunLength;      // maximum length of any match (max initial frag size)
    DWORD            MaximumChainLength;    // max # of hash chain hops
    DWORD            Feature;               // any of FEATURE_xxx

    // input to CountBufferDifferences()

    BYTE           * OldFileBuffer;         // min alloc = OldFileSize + MinimumRunLength
    DWORD            OldFileSize;
    BYTE           * NewFileBuffer;         // min alloc = NewFileSize + MinimumRunLength
    DWORD            NewFileSize;

    // input to CountHashDifferences()

    DWORD          * HashTable;             // [ MAX_HASH_INDEX ], offset of 1st occ. of this hash
    DWORD          * HashLinks;             // [ OldFileSize ], offset of next occ. of this hash

    // internal to CountDifferences()

    OLD_FRAGMENT   * OldFragmentList;       // link to old fragment with lowest offset
    NEW_FRAGMENT   * NewFragmentList;       // link to new fragment with lowest offset
    NEW_FRAGMENT   * PriorityQueue;         // link to largest available match
    OLD_FRAGMENT * * Container;             // [ OldFileSize ], ptr to containing fragment or NULL

    // internal to RemoveLargestMatch(), returned by GetLargestMatch()

    OLD_SUBFRAGMENT  OldBestSubFragment;
    NEW_SUBFRAGMENT  NewBestSubFragment;

    // internal to FindLargestMatchForFragment()

    OLD_SUBFRAGMENT  OldBestPairSubFragment;
    NEW_SUBFRAGMENT  NewBestPairSubFragment;
};


BOOL
StringToDword(
    CHAR * String,
    DWORD * ValuePtr
    );

int
CountFileDifferences(
    OPERATION * Operation
    );

int
CountBufferDifferences(
    OPERATION * Operation
    );

int
CountDifferences(
    OPERATION * Operation
    );

int
RemoveLargestMatch(
    OPERATION * Operation
    );

void
InsertPriority(
    OPERATION    * Operation,
    NEW_FRAGMENT * Fragment,
    NEW_FRAGMENT * NextLarger
    );

void
DeletePriority(
    OPERATION    * Operation,
    NEW_FRAGMENT * Fragment
    );

void
AdjustPriority(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment
    );

void
DeleteNewFragment(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment
    );

void
DeleteOldFragment(
    OPERATION    * Operation,
    OLD_FRAGMENT * OldFragment
    );

void
SetContainer(
    OPERATION    * Operation,
    OLD_FRAGMENT * Container,
    DWORD          Offset,
    DWORD          Length
    );

BOOL
GetLargestMatch(
    OPERATION    * Operation
    );

BOOL
GetLargestMatchUsingPriority(
    OPERATION    * Operation
    );

BOOL
GetLargestMatchForFragment(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment
    );

void
FindLargestMatchForFragment(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment
    );

void
FindLargestMatchForFragmentByHashing(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment
    );

BOOL
FindLargestMatchForFragmentPair(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment,
    OLD_FRAGMENT * OldFragment,
    DWORD          BestFoundSoFar
    );

DWORD
CountMatchingBytes(
    BYTE * Buffer1,
    BYTE * Buffer2,
    DWORD  MaximumMatch
    );

void
CountReport(
    OPERATION * Operation
    );

void
ResolvedReport(
    OPERATION * Operation
    );

void
SearchReport(
    OPERATION * Operation,
    DWORD       Status
    );

DWORD
ComputeHashIndex(
    BYTE * Buffer
    );

void
ShowAdded(
    OPERATION * Operation,
    DWORD       Offset,
    DWORD       Length
    );

void
ShowDeleted(
    OPERATION * Operation,
    DWORD       Offset,
    DWORD       Length
    );

//
//  Command line entry point.  Parse command line into operation and call CountFileDifferences().
//

int __cdecl main( int argc, char * argv[] )
{
    int Result = EXIT_COMMAND_ERROR;
	int arg;
    OPERATION Operation;
    char * Param;

    memset( &Operation, 0, sizeof( Operation ));

    Operation.MinimumRunLength = DEFAULT_MIN_RUN_LENGTH;
    Operation.MaximumRunLength = DEFAULT_MAX_RUN_LENGTH;
    Operation.MaximumChainLength = 100;

	for ( arg = 1; arg < argc; arg++ )
	{
		if (( argv[ arg ][ 0 ] == '-' ) ||
			( argv[ arg ][ 0 ] == '/' ))
        {
            switch ( argv[ arg ][ 1 ] )
            {

            case 'l':
            case 'L':

                Param = argv[ arg ] + 2;

                if ( *Param == ':' )
                {
                    Param++;
                }

                if (( *Param == '\0' ) && (( arg + 1 ) < argc ))
                {
                    Param = argv[ ++arg ];
                }

                if ( ! StringToDword( Param, &Operation.MinimumRunLength ) ||
                    ( Operation.MinimumRunLength < 3 ))
                {
                    goto unexpected;
                }

                break;

            case 'm':
            case 'M':

                Param = argv[ arg ] + 2;

                if ( *Param == ':' )
                {
                    Param++;
                }

                if (( *Param == '\0' ) && (( arg + 1 ) < argc ))
                {
                    Param = argv[ ++arg ];
                }

                if ( ! StringToDword( Param, &Operation.MaximumRunLength ) ||
                    ( Operation.MaximumRunLength < 3 ))
                {
                    goto unexpected;
                }

                break;

            case 'c':
            case 'C':

                Param = argv[ arg ] + 2;

                if ( *Param == ':' )
                {
                    Param++;
                }

                if (( *Param == '\0' ) && (( arg + 1 ) < argc ))
                {
                    Param = argv[ ++arg ];
                }

                if ( ! StringToDword( Param, &Operation.MaximumChainLength ))
                {
                    goto unexpected;
                }

                break;

            case '?':
            case 'h':
            case 'H':

                printf(
                    "\n"
                    PROGNAME " version " PROGVERS " (msliger)\n"
                    "\n"
                    "\"How many bytes are changed in this new file?\"\n"
                    "\n"
                    PROGNAME " determines how many of the bytes found in {newfile} do not exist\n"
                    "in {oldfile}, by excluding matching byte sequences of length N or larger\n"
                    "that exist in both {oldfile} and {newfile}.  The default value of N is %u.\n"
                    "\n"
                    "Usage: " PROGNAME " {oldfile} {newfile} [options]\n"
                    "\n"
                    "Options:\n"
                    "\n"
                    "  /L#  Sets the minimum run length.  Matching byte sequences of this length\n"
                    "       or larger will be excluded (considered \"unchanged\".)  Default=%u.\n"
                    "\n"
                    "  /M#  Sets the maximum run length.  No matches larger than this will be\n"
                    "       found.  (Internally, partitions the new file into separate regions,\n"
                    "       each no larger than this length.)  Default=%u.\n"
                    "\n"
                    "  /C#  Sets the maximum hash chain length.  After this many steps have been\n"
                    "       considered along the hash chain, searching will terminate (early-out).\n"
                    "       Default=%u.\n"
                    "\n"
                    "WARNING: This implementation uses exhaustive searches and performance may be\n"
                    "         unacceptable with large files.\n",
                    DEFAULT_MIN_RUN_LENGTH,
                    DEFAULT_MIN_RUN_LENGTH,
                    DEFAULT_MAX_RUN_LENGTH,
                    DEFAULT_MAX_CHAIN_LENGTH
                    );

                goto finished;

            case 'f':
            case 'F':

                Param = argv[ arg ] + 2;

                if ( *Param == ':' )
                {
                    Param++;
                }

                if (( *Param == '\0' ) && (( arg + 1 ) < argc ))
                {
                    Param = argv[ ++arg ];
                }

                if ( ! StringToDword( Param, &Operation.Feature ))
                {
                    goto unexpected;
                }

                break;

            default:

                goto unexpected;
            }
        }
        else if ( Operation.OldFileName == NULL )
        {
            Operation.OldFileName = argv[ arg ];
        }
        else if ( Operation.NewFileName == NULL )
        {
            Operation.NewFileName = argv[ arg ];
        }
		else
		{
            break;
		}
	}

    if ( arg < argc )
    {

unexpected:

        fprintf( stderr, PROGNAME ": Unexpected: '%s'\n", argv[ arg ] );

        goto finished;
    }

    if ( Operation.NewFileName == NULL )
    {
        fprintf( stderr, PROGNAME ": Incomplete command line.  Use \"" PROGNAME "\" /? to see usage.\n" );

        goto finished;
    }

    Result = CountFileDifferences( &Operation );

    if ( Result == EXIT_NO_ERROR )
    {
        CountReport( &Operation );
    }

finished:

    return( Result );
}


//
//  Given two filenames, count their differences.
//
//  Reads the two file's contents into buffers and call CountBufferDifferences().
//

int
CountFileDifferences(
    OPERATION * Operation
    )
{
    int Result = EXIT_FILE_ERROR;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    DWORD BytesRead;

    Operation->OldFileBuffer = NULL;
    Operation->NewFileBuffer = NULL;

    FileHandle = CreateFile( Operation->OldFileName,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                             );

    if ( FileHandle == INVALID_HANDLE_VALUE )
    {
        goto olderror;
    }

    Operation->OldFileSize = GetFileSize( FileHandle, NULL );

    if (( Operation->OldFileSize == INVALID_FILE_SIZE ) ||
        ( Operation->OldFileSize == 0 ))
    {
        goto olderror;
    }

    Operation->OldFileBuffer = malloc( Operation->OldFileSize + Operation->MinimumRunLength );

    if ( Operation->OldFileBuffer == NULL )
    {
        goto olderror;
    }

    memset( Operation->OldFileBuffer + Operation->OldFileSize, 0, Operation->MinimumRunLength );

    if ( ! ReadFile( FileHandle,
                     Operation->OldFileBuffer,
                     Operation->OldFileSize,
                     &BytesRead,
                     NULL ) ||
         ( BytesRead != Operation->OldFileSize ))
    {
        goto olderror;
    }

    CloseHandle( FileHandle );

    FileHandle = CreateFile( Operation->NewFileName,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                             );

    if ( FileHandle == INVALID_HANDLE_VALUE )
    {
        goto newerror;
    }

    Operation->NewFileSize = GetFileSize( FileHandle, NULL );

    if (( Operation->NewFileSize == INVALID_FILE_SIZE ) ||
        ( Operation->NewFileSize == 0 ))
    {
        goto newerror;
    }

    Operation->NewFileBuffer = malloc( Operation->NewFileSize + Operation->MinimumRunLength );

    if ( Operation->NewFileBuffer == NULL )
    {
        goto newerror;
    }

    memset( Operation->NewFileBuffer + Operation->NewFileSize, 0, Operation->MinimumRunLength );

    if ( ! ReadFile( FileHandle,
                     Operation->NewFileBuffer,
                     Operation->NewFileSize,
                     &BytesRead,
                     NULL ) ||
         ( BytesRead != Operation->NewFileSize ))
    {
        goto newerror;
    }

    CloseHandle( FileHandle );
    FileHandle = INVALID_HANDLE_VALUE;

    Result = CountBufferDifferences( Operation );

    goto finished;


olderror:

    fprintf( stderr, PROGNAME ": Unable to load old file '%s'.\n", Operation->OldFileName );

    goto finished;


newerror:

    fprintf( stderr, PROGNAME ": Unable to load new file '%s'.\n", Operation->NewFileName );

    goto finished;


finished:

    if ( FileHandle != INVALID_HANDLE_VALUE )
    {
        CloseHandle( FileHandle );
    }

    if ( Operation->OldFileBuffer != NULL )
    {
        free( Operation->OldFileBuffer );

        Operation->OldFileBuffer = NULL;
    }

    if ( Operation->NewFileBuffer != NULL )
    {
        free( Operation->NewFileBuffer );

        Operation->NewFileBuffer = NULL;
    }

    return( Result );
}


//
//  Given two buffers containing "old" and "new" data, count their differences.
//
//  Setup a hash table for lookup of old file data, and call CountDifferences().
//

int
CountBufferDifferences(
    OPERATION * Operation
    )
{
    int Result = EXIT_MEMORY_ERROR;
    BYTE * Lookup;
    DWORD Offset;
    DWORD HashIndex;

    Operation->HashLinks = NULL;
    Operation->HashTable = NULL;

    // If either file is smaller than MinimumRunLength, stop here.  They're different.

    if (( Operation->OldFileSize < Operation->MinimumRunLength ) ||
        ( Operation->NewFileSize < Operation->MinimumRunLength ))
    {
        Operation->NumberOfBytesChangedNew = Operation->NewFileSize;
        Operation->NumberOfBytesChangedOld = Operation->OldFileSize;

        if ( Operation->Feature & FEATURE_SHOW_DIFFERENCES )
        {
            ShowDeleted( Operation, 0, Operation->OldFileSize );
            ShowAdded( Operation, 0, Operation->NewFileSize );
        }

        Operation->NumberOfBytesResolvedNew = Operation->NewFileSize;
        Operation->NumberOfBytesResolvedOld = Operation->OldFileSize;

        Result = EXIT_NO_ERROR;

        goto finished;
    }

    // allocate hash table & links array

    Operation->HashTable = malloc( MAX_HASH_INDEX * sizeof( Operation->HashTable[ 0 ] ));

    if ( Operation->HashTable == NULL )
    {
        goto finished;
    }

    for ( HashIndex = 0; HashIndex < MAX_HASH_INDEX; HashIndex++ )
    {
        Operation->HashTable[ HashIndex ] = INVALID_OFFSET;
    }

    Operation->HashLinks = malloc( Operation->OldFileSize * sizeof( Operation->HashLinks[ 0 ] ));

    if ( Operation->HashLinks == NULL )
    {
        goto finished;
    }

    for ( Offset = 0; Offset < Operation->OldFileSize; Offset++ )
    {
        Operation->HashLinks[ Offset ] = INVALID_OFFSET;
    }

    // populate hashing structures from old file contents

    Offset = Operation->OldFileSize - Operation->MinimumRunLength;

    for ( Lookup = Operation->OldFileBuffer + Offset;
          Lookup >= Operation->OldFileBuffer;
          Lookup--, Offset-- )
    {
        HashIndex = ComputeHashIndex( Lookup );

        Operation->HashLinks[ Offset ] = Operation->HashTable[ HashIndex ];
        Operation->HashTable[ HashIndex ] = Offset;
    }

    // do it

    Result = CountDifferences( Operation );

finished:

    if ( Operation->HashTable != NULL )
    {
        free( Operation->HashTable );

        Operation->HashTable = NULL;
    }

    if ( Operation->HashLinks != NULL )
    {
        free( Operation->HashLinks );

        Operation->HashLinks = NULL;
    }

    return( Result );
}


//
//  Count the number of changed bytes of two files.
//
//  On entry, the files' data has been loaded into buffers, and the old file's data has been
//  indexed into a hashing structure.  Think of these buffers as fragments.  Remove the largest
//  match, possibly splitting fragments, until all fragments for either file have been exhausted.
//  Any remaining fragments must then contain changed bytes.
//
//  As fragments split, any residual sequences smaller than the minimum run length are discarded.
//

int
CountDifferences(
    OPERATION * Operation
    )
{
    int Result;
    DWORD Remaining;
    DWORD FragmentOffset;
    DWORD FragmentLength;
    NEW_FRAGMENT * Fragment;
    NEW_FRAGMENT * LastFragment;
    NEW_FRAGMENT * * BackLink;

    Operation->Container = NULL;
    Operation->OldFragmentList = NULL;
    Operation->NewFragmentList = NULL;
    Operation->NumberOfNewFragments = 0;
    Operation->PriorityQueue = NULL;

    // coordinate features

    if ( Operation->Feature & FEATURE_SEQUENTIAL )
    {
        Operation->Feature &= ~FEATURE_NO_HASHING;
    }

    // allocate container array

    Operation->Container = malloc( Operation->OldFileSize * sizeof( Operation->Container[ 0 ] ));

    if ( Operation->Container == NULL )
    {
        goto finished;
    }

    memset( Operation->Container, 0, Operation->OldFileSize * sizeof( Operation->Container[ 0 ] ));

    // allocate initial old fragment consisting of entire old buffer

    Operation->NumberOfOldFragments = 1;

    Operation->OldFragmentList = malloc( sizeof( OLD_FRAGMENT ));
    if ( Operation->OldFragmentList == NULL )
    {
        goto finished;
    }

    memset( Operation->OldFragmentList, 0, sizeof( OLD_FRAGMENT ));

    Operation->OldFragmentList->Length = Operation->OldFileSize;

    SetContainer( Operation,
                  Operation->OldFragmentList,
                  0,
                  Operation->OldFileSize
                  );

    // allocate initial new fragment(s) consisting of entire new buffer,
    // each MaximumRunLength or smaller, but none smaller than MinimumRunLength.

    Remaining = Operation->NewFileSize;
    FragmentOffset = 0;
    FragmentLength = Operation->MaximumRunLength;
    BackLink = &Operation->NewFragmentList;
    LastFragment = NULL;

    while ( Remaining > 0 )
    {
        if ( FragmentLength > Remaining )
        {
            FragmentLength = Remaining;
        }

        if ( FragmentLength < Operation->MinimumRunLength )
        {
            Operation->NumberOfBytesChangedNew  += FragmentLength;
            Operation->NumberOfBytesResolvedNew += FragmentLength;

            if ( Operation->Feature & FEATURE_SHOW_DIFFERENCES )
            {
                ShowAdded( Operation, FragmentOffset, FragmentLength );
            }

            break;
        }

        Operation->NumberOfNewFragments++;

        Fragment = malloc( sizeof( NEW_FRAGMENT ));
        if ( Fragment == NULL )
        {
            goto finished;
        }

        memset( Fragment, 0, sizeof( NEW_FRAGMENT ));

        Fragment->BestProspect = FragmentLength;

        Fragment->Offset = FragmentOffset;
        Fragment->Length = FragmentLength;
        Fragment->BestMatch = BEST_MATCH_UNKNOWN;

        Fragment->Previous = LastFragment;
        LastFragment = Fragment;

        *BackLink = Fragment;
        BackLink = &Fragment->Next;

        Remaining      -= FragmentLength;
        FragmentOffset += FragmentLength;

        AdjustPriority( Operation, Fragment );
    }

    ResolvedReport( Operation );

    //  until no fragments remain, remove the largest match

    while (( Operation->NewFragmentList != NULL ) &&
           ( Operation->OldFragmentList != NULL ))
    {
        Result = RemoveLargestMatch( Operation );

        if ( Result != EXIT_NO_ERROR )
        {
            goto finished;
        }

        ResolvedReport( Operation );
    }

    //  any remaining fragments contain changed bytes; tabulate during cleanup

    Result = EXIT_NO_ERROR;

finished:

    while ( Operation->NewFragmentList != NULL )
    {
        Operation->NumberOfBytesChangedNew  += Operation->NewFragmentList->Length;
        Operation->NumberOfBytesResolvedNew += Operation->NewFragmentList->Length;

        if ( Operation->Feature & FEATURE_SHOW_DIFFERENCES )
        {
            ShowAdded( Operation, Operation->NewFragmentList->Offset, Operation->NewFragmentList->Length );
        }

        DeleteNewFragment( Operation, Operation->NewFragmentList );
    }

    while ( Operation->OldFragmentList != NULL )
    {
        Operation->NumberOfBytesChangedOld  += Operation->OldFragmentList->Length;
        Operation->NumberOfBytesResolvedOld += Operation->OldFragmentList->Length;

        if ( Operation->Feature & FEATURE_SHOW_DIFFERENCES )
        {
            ShowDeleted( Operation, Operation->OldFragmentList->Offset, Operation->OldFragmentList->Length );
        }

        DeleteOldFragment( Operation, Operation->OldFragmentList );
    }

    Operation->UpdateTick = MAX_DWORD;  // force report
    ResolvedReport( Operation );

    if ( Operation->Container != NULL )
    {
        free( Operation->Container );

        Operation->Container = NULL;
    }

    return( Result );
}


//
//  Find and remove the largest match.  This may cause the old and/or new fragments to be split. 
//
//  For each new fragment, find the largest match which might be in any of the remaining old fragments.
//  Choose the new fragment with the largest match found, and remove the old and new subfragments that
//  describe that match.
//
//  To remove a subfragment, split the containing fragment as needed so that the subfragment represents
//  the entire containing fragment.  Regions before or after this fragment may become new, adjacent
//  fragments, or they are discarded if the resulting fragment would be too small (and therefor
//  counted as changed bytes.)  Once the subfragment represents the entire containing fragment, the
//  containing fragment is removed.
//

int
RemoveLargestMatch(
    OPERATION * Operation
    )
{
    int               Result;
    NEW_FRAGMENT    * SplitNewFragment;
    OLD_FRAGMENT    * SplitOldFragment;
    NEW_SUBFRAGMENT   NewBestSubFragment;
    OLD_SUBFRAGMENT   OldBestSubFragment;
    DWORD             ResidualSize;

    if (( Operation->Feature & FEATURE_NO_PRIORITY ) ||
        ( Operation->Feature & FEATURE_SEQUENTIAL ))
    {
        Result = GetLargestMatch( Operation );
    }
    else
    {
        Result = GetLargestMatchUsingPriority( Operation );
    }

    if ( Result == FALSE )
    {
        if ( Operation->NewFragmentList != NULL )
        {
            fprintf( stderr, PROGNAME ": assertion failed at __FILE__(__LINE__)\n" );

            Result = EXIT_ASSERTION;

            goto finished;
        }

        Result = EXIT_NO_ERROR;

        goto finished;
    }

    NewBestSubFragment = Operation->NewBestSubFragment;
    OldBestSubFragment = Operation->OldBestSubFragment;

    Operation->NumberOfMatches++;
    Operation->NumberOfBytesMatched += NewBestSubFragment.Length;
    Operation->NumberOfBytesResolvedNew += NewBestSubFragment.Length;
    Operation->NumberOfBytesResolvedOld += NewBestSubFragment.Length;

    //  Isolate NewBestSubFragment

    ResidualSize = NewBestSubFragment.Offset - NewBestSubFragment.Fragment->Offset;

    if ( ResidualSize > 0 )
    {
        if (( ResidualSize < Operation->MinimumRunLength ) ||
            ( Operation->Feature & FEATURE_SEQUENTIAL ))
        {
            // Residual at beginning of this fragment is too small.
            // Shrink fragment at head & record residual as unmatched.

            Operation->NumberOfBytesChangedNew += ResidualSize;
            Operation->NumberOfBytesResolvedNew += ResidualSize;

            if ( Operation->Feature & FEATURE_SHOW_DIFFERENCES )
            {
                ShowAdded( Operation, NewBestSubFragment.Fragment->Offset, ResidualSize );
            }
        }
        else
        {
            // Create a new fragment containing the leading residual

            Operation->NumberOfNewFragments++;

            SplitNewFragment = malloc( sizeof( NEW_FRAGMENT ));
            if ( SplitNewFragment == NULL )
            {
                Result = EXIT_MEMORY_ERROR;

                goto finished;
            }

            memset( SplitNewFragment, 0, sizeof( NEW_FRAGMENT ));

            SplitNewFragment->Previous = NewBestSubFragment.Fragment->Previous;
            SplitNewFragment->Next = NewBestSubFragment.Fragment;
            NewBestSubFragment.Fragment->Previous = SplitNewFragment;

            if ( SplitNewFragment->Previous != NULL )
            {
                SplitNewFragment->Previous->Next = SplitNewFragment;
            }
            else
            {
                Operation->NewFragmentList = SplitNewFragment;
            }

            SplitNewFragment->BestProspect = min( ResidualSize, NewBestSubFragment.Length );

            SplitNewFragment->Offset = NewBestSubFragment.Fragment->Offset;
            SplitNewFragment->Length = ResidualSize;
            SplitNewFragment->BestMatch = BEST_MATCH_UNKNOWN;

            AdjustPriority( Operation, SplitNewFragment );
        }

        NewBestSubFragment.Fragment->Offset += ResidualSize;
        NewBestSubFragment.Fragment->Length -= ResidualSize;
    }

    ResidualSize = NewBestSubFragment.Fragment->Length - NewBestSubFragment.Length;

    if ( ResidualSize > 0 )
    {
        if ( ResidualSize < Operation->MinimumRunLength )
        {
            // Residual at end of this fragment is too small.
            // Shrink fragment at end & record residual as unmatched.

            Operation->NumberOfBytesChangedNew += ResidualSize;
            Operation->NumberOfBytesResolvedNew += ResidualSize;

            if ( Operation->Feature & FEATURE_SHOW_DIFFERENCES )
            {
                ShowAdded( Operation, NewBestSubFragment.Fragment->Offset + NewBestSubFragment.Length, ResidualSize );
            }
        }
        else
        {
            // Create a new fragment containing the trailing residual

            Operation->NumberOfNewFragments++;

            SplitNewFragment = malloc( sizeof( NEW_FRAGMENT ));
            if ( SplitNewFragment == NULL )
            {
                Result = EXIT_MEMORY_ERROR;

                goto finished;
            }

            memset( SplitNewFragment, 0, sizeof( NEW_FRAGMENT ));

            SplitNewFragment->Previous = NewBestSubFragment.Fragment;
            SplitNewFragment->Next = NewBestSubFragment.Fragment->Next;
            NewBestSubFragment.Fragment->Next = SplitNewFragment;

            if ( SplitNewFragment->Next != NULL )
            {
                SplitNewFragment->Next->Previous = SplitNewFragment;
            }

            SplitNewFragment->BestProspect = min( ResidualSize, NewBestSubFragment.Length );

            SplitNewFragment->Offset = NewBestSubFragment.Fragment->Offset + NewBestSubFragment.Length;
            SplitNewFragment->Length = ResidualSize;
            SplitNewFragment->BestMatch = BEST_MATCH_UNKNOWN;

            AdjustPriority( Operation, SplitNewFragment );
        }

        NewBestSubFragment.Fragment->Length -= ResidualSize;
    }

    //  Isolate OldBestSubFragment

    ResidualSize = OldBestSubFragment.Offset - OldBestSubFragment.Fragment->Offset;

    if ( ResidualSize > 0 )
    {
        if ( ResidualSize < Operation->MinimumRunLength )
        {
            // Residual at beginning of this fragment is too small.
            // Shrink fragment at head & record residual as unmatched.

            Operation->NumberOfBytesChangedOld += ResidualSize;
            Operation->NumberOfBytesResolvedOld += ResidualSize;

            if ( Operation->Feature & FEATURE_SHOW_DIFFERENCES )
            {
                ShowDeleted( Operation, OldBestSubFragment.Fragment->Offset, ResidualSize );
            }

            SplitOldFragment = NULL;
        }
        else
        {
            // Create a new fragment containing the leading residual

            Operation->NumberOfOldFragments++;

            SplitOldFragment = malloc( sizeof( OLD_FRAGMENT ));
            if ( SplitOldFragment == NULL )
            {
                Result = EXIT_MEMORY_ERROR;

                goto finished;
            }

            memset( SplitOldFragment, 0, sizeof( OLD_FRAGMENT ));

            SplitOldFragment->Previous = OldBestSubFragment.Fragment->Previous;
            SplitOldFragment->Next = OldBestSubFragment.Fragment;
            SplitOldFragment->Next->Previous = SplitOldFragment;

            if ( SplitOldFragment->Previous != NULL )
            {
                SplitOldFragment->Previous->Next = SplitOldFragment;
            }
            else
            {
                Operation->OldFragmentList = SplitOldFragment;
            }

            SplitOldFragment->Offset = OldBestSubFragment.Fragment->Offset;
            SplitOldFragment->Length = ResidualSize;
        }

        SetContainer( Operation,
                      SplitOldFragment,
                      OldBestSubFragment.Fragment->Offset,
                      ResidualSize
                      );

        OldBestSubFragment.Fragment->Offset += ResidualSize;
        OldBestSubFragment.Fragment->Length -= ResidualSize;
    }

    ResidualSize = OldBestSubFragment.Fragment->Length - OldBestSubFragment.Length;

    if ( ResidualSize > 0 )
    {
        if ( ResidualSize < Operation->MinimumRunLength )
        {
            // Residual at end of this fragment is too small.
            // Shrink fragment at end & record residual as unmatched.

            Operation->NumberOfBytesChangedOld += ResidualSize;
            Operation->NumberOfBytesResolvedOld += ResidualSize;

            if ( Operation->Feature & FEATURE_SHOW_DIFFERENCES )
            {
                ShowDeleted( Operation, OldBestSubFragment.Fragment->Offset + OldBestSubFragment.Length, ResidualSize );
            }

            SplitOldFragment = NULL;
        }
        else
        {
            // Create a new fragment containing the trailing residual

            Operation->NumberOfOldFragments++;

            SplitOldFragment = malloc( sizeof( OLD_FRAGMENT ));
            if ( SplitOldFragment == NULL )
            {
                Result = EXIT_MEMORY_ERROR;

                goto finished;
            }

            memset( SplitOldFragment, 0, sizeof( OLD_FRAGMENT ));

            SplitOldFragment->Previous = OldBestSubFragment.Fragment;
            SplitOldFragment->Next = OldBestSubFragment.Fragment->Next;
            OldBestSubFragment.Fragment->Next = SplitOldFragment;

            if ( SplitOldFragment->Next != NULL )
            {
                SplitOldFragment->Next->Previous = SplitOldFragment;
            }

            SplitOldFragment->Offset = OldBestSubFragment.Fragment->Offset + OldBestSubFragment.Length;
            SplitOldFragment->Length = ResidualSize;
        }

        SetContainer( Operation,
                      SplitOldFragment,
                      OldBestSubFragment.Fragment->Offset + OldBestSubFragment.Length,
                      ResidualSize
                      );

        OldBestSubFragment.Fragment->Length -= ResidualSize;
    }

    if ( Operation->Feature & FEATURE_SHOW_FRAGMENTS )
    {
        printf( "Matched %u at new %u old %u.\n",
                NewBestSubFragment.Length,
                NewBestSubFragment.Offset,
                OldBestSubFragment.Offset
                );
    }

#ifdef _DEBUG
    if ( NewBestSubFragment.Fragment->Length < Operation->PriorityQueue->BestProspect )
    {
        printf( "Match selected doesn't agree with PriorityQueue\n" );
    }
#endif

    if ( Operation->Feature & FEATURE_SHOW_PRIORITY )
    {
        NEW_FRAGMENT * Priority;

        for ( Priority = Operation->PriorityQueue;
              Priority != NULL;
              Priority = Priority->NextSmaller )
        {
            printf( "   PQ: Offset: %u  Length: %u  Prospect: %u  Best: %u  (New: %u  Old: %u)\n",
                    Priority->Offset,
                    Priority->Length,
                    Priority->BestProspect,
                    Priority->BestMatch,
                    Priority->BestNewOffset,
                    Priority->BestOldOffset
                    );
        }
    }

    //  Remove NewBestSubFragment.Fragment

    DeleteNewFragment( Operation, NewBestSubFragment.Fragment );

    //  Remove OldBestSubFragment.Fragment

    DeleteOldFragment( Operation, OldBestSubFragment.Fragment );

    Result = EXIT_NO_ERROR;

finished:

    return( Result );
}


//
//  Locate the largest match between the given new fragment and any old fragment.  If this new
//  fragment was previously searched, the results of the previous search may be returned after
//  re-verification.
//
//  Sets Operation->NewBestSubFragment and Operation->OldBestSubFragment.  If no match is found,
//  Operation->NewBestSubFragment.Length will be 0 on return.
//
//  Returns TRUE if any match is found, FALSE if there are no old fragments which match any part
//  of the given new fragment.  If FALSE is returned, the caller may wish to prune the fragment.
//

BOOL
GetLargestMatchForFragment(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment
    )
{
    OLD_FRAGMENT * OldFragment;
    DWORD          BestOldEnding;
    DWORD          ThisOldEnding;

    // if this isn't the first find on this fragment, the previous find's results
    // might still be available, in which case searching again isn't necessary.

    if ( NewFragment->BestMatch != BEST_MATCH_UNKNOWN )
    {
        if ( NewFragment->BestNewOffset < NewFragment->Offset )
        {
            goto search;
        }

        if (( NewFragment->BestNewOffset + NewFragment->BestMatch ) >
            ( NewFragment->Offset + NewFragment->Length ))
        {
            goto search;
        }

        // see if an old fragment containing this former subfragment still exists

        BestOldEnding = NewFragment->BestOldOffset + NewFragment->BestMatch;

        for ( OldFragment = Operation->OldFragmentList;
              OldFragment != NULL;
              OldFragment = OldFragment->Next )
        {
            if ( OldFragment->Offset > NewFragment->BestOldOffset )
            {
                goto search;
            }

            ThisOldEnding = OldFragment->Offset + OldFragment->Length;

            if ( ThisOldEnding > NewFragment->BestOldOffset )
            {
                if ( ThisOldEnding < BestOldEnding )
                {
                    goto search;
                }

                Operation->NumberOfRefindsAvailable++;

                Operation->NewBestSubFragment.Fragment = NewFragment;
                Operation->NewBestSubFragment.Offset   = NewFragment->BestNewOffset;
                Operation->NewBestSubFragment.Length   = NewFragment->BestMatch;

                Operation->OldBestSubFragment.Fragment = OldFragment;
                Operation->OldBestSubFragment.Offset   = NewFragment->BestOldOffset;
                Operation->OldBestSubFragment.Length   = NewFragment->BestMatch;

                goto foundit;
            }
        }
    }

search:

    // search every old fragment for the best match

    if ( Operation->Feature & FEATURE_NO_HASHING )
    {
        FindLargestMatchForFragment( Operation, NewFragment );
    }
    else
    {
        FindLargestMatchForFragmentByHashing( Operation, NewFragment );
    }

    // save this best match in case we're called again and it hasn't been used 

    NewFragment->BestMatch     = Operation->NewBestSubFragment.Length;
    NewFragment->BestNewOffset = Operation->NewBestSubFragment.Offset;
    NewFragment->BestOldOffset = Operation->OldBestSubFragment.Offset;

    NewFragment->BestProspect  = Operation->NewBestSubFragment.Length;

    AdjustPriority( Operation, NewFragment );

foundit:

    if ( Operation->NewBestSubFragment.Length > Operation->MinimumRunLength )
    {
        return( TRUE );
    }

    return( FALSE );
}


//
//  Given a specific new fragment and a specific old fragment, find the largest sequence
//  of bytes the two fragments have in common.  Don't bother if the length of that largest
//  sequence isn't at least BestFoundSoFar, which indicates the length of the largest
//  sequence already found for this new fragment from some other old fragment.
//
//  Returns subfragments describing the common sequence in Operation->NewBestPairSubFragment
//  and Operation->OldBestPairSubFragment, or FALSE if no better common sequence was found.
//

BOOL
FindLargestMatchForFragmentPair(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment,
    OLD_FRAGMENT * OldFragment,
    DWORD          BestFoundSoFar
    )
{
    BYTE * NewStart = Operation->NewFileBuffer + NewFragment->Offset;
    BYTE * NewSearch;
    DWORD  NewMaxMatch;
    BYTE * NewLimit = NewStart + NewFragment->Length;

    BYTE * OldStart = Operation->OldFileBuffer + OldFragment->Offset;
    BYTE * OldSearch;
    DWORD  OldMaxMatch;
    BYTE * OldLimit = OldStart + OldFragment->Length;

    DWORD  BestMatch = 0;
    BYTE * NewBest;
    BYTE * OldBest;

    DWORD  LengthThreshold = max( BestFoundSoFar, Operation->MinimumRunLength );
    DWORD  Length;

    for ( NewSearch = NewStart, NewMaxMatch = NewFragment->Length;
          NewSearch < NewLimit;
          NewSearch++, NewMaxMatch-- )
    {
        if ( NewMaxMatch <= LengthThreshold )
        {
            break;
        }

        for ( OldSearch = OldStart, OldMaxMatch = OldFragment->Length;
              OldSearch < OldLimit;
              OldSearch++, OldMaxMatch-- )
        {
            if ( OldMaxMatch <= LengthThreshold )
            {
                break;
            }

            Length = CountMatchingBytes( NewSearch, OldSearch, min( NewMaxMatch, OldMaxMatch ));

            if ( Length > LengthThreshold )
            {
                LengthThreshold = Length;
                BestMatch = Length;
                NewBest = NewSearch;
                OldBest = OldSearch;
            }
        }
    }

    if ( BestMatch == 0 )
    {
        return( FALSE );
    }

    Operation->NewBestPairSubFragment.Fragment = NewFragment;
    Operation->NewBestPairSubFragment.Offset = NewBest - Operation->NewFileBuffer;
    Operation->NewBestPairSubFragment.Length = BestMatch;

    Operation->OldBestPairSubFragment.Fragment = OldFragment;
    Operation->OldBestPairSubFragment.Offset = OldBest - Operation->OldFileBuffer;
    Operation->OldBestPairSubFragment.Length = BestMatch;

    return( TRUE );
}


//
//  Locate the largest match between the given new fragment and any old fragment.
//
//  Sets Operation->NewBestSubFragment and Operation->OldBestSubFragment.  If no match is found,
//  Operation->NewBestSubFragment.Length will be 0 on return.
//

void
FindLargestMatchForFragment(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment
    )
{
    OLD_FRAGMENT * OldFragment;

    Operation->NewBestSubFragment.Length = 0;

    for ( OldFragment = Operation->OldFragmentList;
          OldFragment != NULL;
          OldFragment = OldFragment->Next )
    {
        if ( Operation->NewBestSubFragment.Length >= OldFragment->Length )
        {
            continue;
        }

        if ( FindLargestMatchForFragmentPair( Operation,
                                              NewFragment,
                                              OldFragment,
                                              Operation->NewBestSubFragment.Length
                                              ))           
        {
            if ( Operation->NewBestSubFragment.Length < Operation->NewBestPairSubFragment.Length )
            {
                Operation->NewBestSubFragment = Operation->NewBestPairSubFragment;
                Operation->OldBestSubFragment = Operation->OldBestPairSubFragment;
            }
        }
    }
}


//
//  Locate the largest match between the given new fragment and any old fragment.
//
//  Sets Operation->NewBestSubFragment and Operation->OldBestSubFragment.  If no match is found,
//  Operation->NewBestSubFragment.Length will be 0 on return.
//

void
FindLargestMatchForFragmentByHashing(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment
    )
{
    DWORD          HashIndex;

    BYTE         * NewStart = Operation->NewFileBuffer + NewFragment->Offset;
    BYTE         * NewSearch;
    DWORD          NewMaxMatch;
    BYTE         * NewLimit = NewStart + NewFragment->Length - Operation->MinimumRunLength + 1;

    DWORD          OldOffset;

    OLD_FRAGMENT * OldFragment;
    BYTE         * OldSearch;
    DWORD          OldMaxMatch;

    DWORD          BestMatch = 0;
    BYTE         * NewBest;
    BYTE         * OldBest;
    OLD_FRAGMENT * OldBestFragment;

    DWORD          LengthThreshold = Operation->MinimumRunLength;
    DWORD          Length;

    DWORD        * Referrer;   // for self-pruning hash chain
    DWORD          NumberOfHops;

    for ( NewSearch = NewStart, NewMaxMatch = NewFragment->Length;
          NewSearch < NewLimit;
          NewSearch++, NewMaxMatch-- )
    {
        SearchReport( Operation, NewSearch - Operation->NewFileBuffer );

        if ( NewMaxMatch <= LengthThreshold )
        {
            break;
        }

        HashIndex = ComputeHashIndex( NewSearch );

        NumberOfHops = 0;

        Referrer = &Operation->HashTable[ HashIndex ];
        
        while ( OldOffset = *Referrer, OldOffset != INVALID_OFFSET )
        {
            OldFragment = Operation->Container[ OldOffset ];

            if ( OldFragment == NULL )
            {
                *Referrer = Operation->HashLinks[ OldOffset ];  // prune hash chain

                continue;
            }

            Referrer = &Operation->HashLinks[ OldOffset ];  // ptr to next offset

            NumberOfHops++;

            OldSearch = Operation->OldFileBuffer + OldOffset;

            if (( NewSearch[ 0 ] != OldSearch[ 0 ] ) ||
                ( NewSearch[ 1 ] != OldSearch[ 1 ] ) ||
                ( NewSearch[ 2 ] != OldSearch[ 2 ] ))
            {
                continue;
            }

            OldMaxMatch = OldFragment->Offset + OldFragment->Length - OldOffset;

            if ( OldMaxMatch <= LengthThreshold )
            {
                continue;
            }

            Length = CountMatchingBytes( NewSearch, OldSearch, min( NewMaxMatch, OldMaxMatch ));

            if ( Length > LengthThreshold )
            {
                LengthThreshold = Length;
                BestMatch = Length;
                NewBest = NewSearch;
                OldBest = OldSearch;
                OldBestFragment = OldFragment;

                NumberOfHops = 0;
            }

            if ( NumberOfHops > Operation->MaximumChainLength )
            {
                break;
            }
        }

        if (( BestMatch > 0 ) &&
            ( Operation->Feature & FEATURE_SEQUENTIAL ))
        {
            break;
        }
    }

    Operation->NewBestSubFragment.Fragment = NewFragment;
    Operation->NewBestSubFragment.Offset = NewBest - Operation->NewFileBuffer;
    Operation->NewBestSubFragment.Length = BestMatch;

    Operation->OldBestSubFragment.Fragment = OldBestFragment;
    Operation->OldBestSubFragment.Offset = OldBest - Operation->OldFileBuffer;
    Operation->OldBestSubFragment.Length = BestMatch;
}


//
//  Convert a string of digits into a DWORD, return FALSE if a non-digit is seen or overflow.
//

BOOL
StringToDword(
    CHAR * String,
    DWORD * ValuePtr
    )
{
    unsigned Value = 0;
    unsigned Digit;

    if (( String[ 0 ] == '0' ) && ( String[ 1 ] == 'x' ))
    {
        String += 2;

        while ( *String != '\0' )
        {
            if (( *String >= '0' ) && ( *String <= '9' ))
            {
                Digit = *String - '0';
            }
            else if (( *String >= 'A' ) && ( *String <= 'F' ))
            {
                Digit = *String - 'A' + 10;
            }
            else if (( *String >= 'a' ) && ( *String <= 'a' ))
            {
                Digit = *String - 'a' + 10;
            }
            else
            {
                break;
            }

            if ( Value > 0x0FFFFFFF)
            {
                break;
            }

            Value *= 16;
            Value += Digit;

            String++;
        }
    }
    else
    {
        while (( *String >= '0' ) && ( *String <= '9' ))
        {
            Digit = *String - '0';

            if ( Value > 0x0FFFFFFF )
            {
                break;
            }

            Value *= 10;
            Value += Digit;

            String++;
        }
    }

    *ValuePtr = Value;

    if ( *String != '\0' )
    {
        return( FALSE );
    }

    return( TRUE );
}


//
//  Display count statistics
//

void
CountReport(
    OPERATION * Operation
    )
{
    printf( "%u matches totaling %u bytes, %u deleted bytes, %u new bytes\n",
            Operation->NumberOfMatches,
            Operation->NumberOfBytesMatched,
            Operation->NumberOfBytesChangedOld,
            Operation->NumberOfBytesChangedNew
            );

    if ( Operation->Feature & FEATURE_SHOW_STATS )
    {
        printf( "new filesize=%u, old filesize=%u, new resolved=%u, old resolved=%u\n",
                Operation->NewFileSize,
                Operation->OldFileSize,
                Operation->NumberOfBytesResolvedNew,
                Operation->NumberOfBytesResolvedOld
                );

        printf( "  Finds: %u  Skips: %u  Refinds: %u  Available: %u  Sinkers: %u\n",
                Operation->NumberOfFinds,
                Operation->NumberOfSkips,
                Operation->NumberOfRefinds,
                Operation->NumberOfRefindsAvailable,
                Operation->NumberOfSinkers
                );

        printf( "Fragments remaining: %u/%u\n",
                Operation->NumberOfNewFragments,
                Operation->NumberOfOldFragments
                );
    }
}


//
//  Display intermediate resolution statistics
//

void
ResolvedReport(
    OPERATION * Operation
    )
{
    DWORD Now = GetTickCount();

    if (( Now > ( Operation->UpdateTick + 2500 )) ||
        ( Now < ( Operation->UpdateTick )))
    {
        fprintf( stderr, "                 %u/%u new, %u/%u old (%u/%u)    \r",
                Operation->NumberOfBytesResolvedNew,
                Operation->NewFileSize,
                Operation->NumberOfBytesResolvedOld,
                Operation->OldFileSize,
                Operation->NumberOfNewFragments,
                Operation->NumberOfOldFragments
                );

        Operation->UpdateTick = Now;
    }
}


//
//  Display intermediate resolution statistics
//

void
SearchReport(
    OPERATION * Operation,
    DWORD       Status
    )
{
    DWORD Now = GetTickCount();

    if (( Now > ( Operation->SearchTick + 2500 )) ||
        ( Now < ( Operation->SearchTick )))
    {
        fprintf( stderr, " %u \r", Status );

        Operation->SearchTick = Now;
    }
}


//
//  Determine how many bytes match at the given locations, bounded by MaximumMatch
//

DWORD
CountMatchingBytes(
    BYTE * Buffer1,
    BYTE * Buffer2,
    DWORD  MaximumMatch
    )
{
    DWORD Result = 0;

    while ( *Buffer1++ == *Buffer2++ )
    {
        Result++;

        if ( Result >= MaximumMatch )
        {
            break;
        }
    }

    return( Result );
}


//
//  Return the hash function of the three bytes indicated
//

DWORD
ComputeHashIndex(
    BYTE * Buffer
    )
{
    DWORD HashIndex;

#ifdef JUMBO_HASH
    HashIndex = Buffer[ 0 ] + ( Buffer[ 1 ] << 8 ) + ( Buffer[ 2 ] << 16 );
#else
    HashIndex = Buffer[ 0 ] ^ ( Buffer[ 1 ] << 4 ) + ( Buffer[ 2 ] << 8 );
#endif

    return( HashIndex );
}


void
InsertPriority(
    OPERATION    * Operation,
    NEW_FRAGMENT * Fragment,
    NEW_FRAGMENT * NextLarger
    )
{
    Fragment->NextLarger = NextLarger;

    if ( NextLarger == NULL )
    {
        Fragment->NextSmaller = Operation->PriorityQueue;

        Operation->PriorityQueue = Fragment;
    }
    else
    {
        Fragment->NextSmaller = NextLarger->NextSmaller;

        NextLarger->NextSmaller = Fragment;
    }

    if ( Fragment->NextSmaller != NULL )
    {
        Fragment->NextSmaller->NextLarger = Fragment;
    }
}


void
DeletePriority(
    OPERATION    * Operation,
    NEW_FRAGMENT * Fragment
    )
{
    if ( Fragment->NextLarger == NULL )
    {
        Operation->PriorityQueue = Fragment->NextSmaller;
    }
    else
    {
        Fragment->NextLarger->NextSmaller = Fragment->NextSmaller;
    }

    if ( Fragment->NextSmaller != NULL )
    {
        Fragment->NextSmaller->NextLarger = Fragment->NextLarger;
    }
}


//
//  Move a fragment to the correct position within the priority queue
//
//  Note that the fragment might not be in the priority queue yet.
//

void
AdjustPriority(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment
    )
{
    NEW_FRAGMENT * Reference;
    NEW_FRAGMENT * ReferenceNext;
    BOOL IsLinked = FALSE;

    Reference = NewFragment->NextSmaller;

    if ( Reference != NULL )
    {
        IsLinked = TRUE;

        if ( Reference->BestProspect > NewFragment->BestProspect)
        {
            //  downqueue

            DeletePriority( Operation, NewFragment );

            while (( ReferenceNext = Reference->NextSmaller, ReferenceNext != NULL ) &&
                   ( ReferenceNext->BestProspect > NewFragment->BestProspect ))
            {
                Reference = ReferenceNext;
            }

            goto insert;
        }
    }

    Reference = NewFragment->NextLarger;

    if ( Reference != NULL )
    {
        IsLinked = TRUE;

        if ( Reference->BestProspect < NewFragment->BestProspect )
        {
            //  upqueue

            DeletePriority( Operation, NewFragment );

            do
            {
                Reference = Reference->NextLarger;

            } while (( Reference != NULL ) &&
                     ( Reference->BestProspect < NewFragment->BestProspect ));

            goto insert;
        }
    }

    if ( IsLinked )
    {
        goto finished;
    }

    if ( Operation->PriorityQueue == NewFragment )
    {
        IsLinked = TRUE;

        goto finished;
    }

    Reference = Operation->PriorityQueue;

    if ( Reference != NULL )
    {
        while (( ReferenceNext = Reference->NextSmaller, ReferenceNext != NULL ) &&
               ( ReferenceNext->BestProspect > NewFragment->BestProspect ))
        {
            Reference = ReferenceNext;
        }
    }

insert:

    InsertPriority( Operation, NewFragment, Reference );

finished:

    return;
}


//
//  Unlink a fragment from the NewFragmentList and PriorityQueue and delete it.
//

void
DeleteNewFragment(
    OPERATION    * Operation,
    NEW_FRAGMENT * NewFragment
    )
{
    if ( NewFragment->Previous != NULL )
    {
        NewFragment->Previous->Next = NewFragment->Next;
    }
    else
    {
        Operation->NewFragmentList = NewFragment->Next;
    }

    if ( NewFragment->Next != NULL )
    {
        NewFragment->Next->Previous = NewFragment->Previous;
    }

    DeletePriority( Operation, NewFragment );

    Operation->NumberOfNewFragments--;

    free( NewFragment );
}


//
//  Unlink a fragment from the OldFragmentList and delete it.
//

void
DeleteOldFragment(
    OPERATION    * Operation,
    OLD_FRAGMENT * OldFragment
    )
{
    SetContainer( Operation,
                  NULL,
                  OldFragment->Offset,
                  OldFragment->Length
                  );

    if ( OldFragment->Previous != NULL )
    {
        OldFragment->Previous->Next = OldFragment->Next;
    }
    else
    {
        Operation->OldFragmentList = OldFragment->Next;
    }

    if ( OldFragment->Next != NULL )
    {
        OldFragment->Next->Previous = OldFragment->Previous;
    }

    Operation->NumberOfOldFragments--;

    free( OldFragment );
}


//
//  Set all Container pointers starting at Offset for the given Length to the specified fragment.
//

void
SetContainer(
    OPERATION    * Operation,
    OLD_FRAGMENT * Container,
    DWORD          Offset,
    DWORD          Length
    )
{
    OLD_FRAGMENT * * Link;

    Link = Operation->Container + Offset;

    while ( Length-- )
    {
        *Link++ = Container;
    }
}


BOOL
GetLargestMatch(
    OPERATION * Operation
    )
{
    NEW_FRAGMENT    * NewFragment;
    NEW_FRAGMENT    * NextNewFragment;
    NEW_SUBFRAGMENT   NewBestSubFragment;
    OLD_SUBFRAGMENT   OldBestSubFragment;

    NewBestSubFragment.Length = 0;

    for ( NewFragment = Operation->NewFragmentList;
          NewFragment != NULL;
          NewFragment = NextNewFragment )
    {
        if ( Operation->Feature & FEATURE_SHOW_FRAGMENTS )
        {
            printf( "       Offset: %u  Length: %u  Prospect: %u  Best: %u  (New: %u  Old: %u)\n",
                    NewFragment->Offset,
                    NewFragment->Length,
                    NewFragment->BestProspect,
                    NewFragment->BestMatch,
                    NewFragment->BestNewOffset,
                    NewFragment->BestOldOffset
                    );
        }

        NextNewFragment = NewFragment->Next;

        if ( NewBestSubFragment.Length > NewFragment->Length )
        {
            continue;   // best is larger than this entire fragment
        }

        if ( NewBestSubFragment.Length >= NewFragment->BestMatch )
        {
            Operation->NumberOfSkips++;

            continue;   // best is larger than ever seen in this fragment
        }

        if ( NewFragment->BestMatch != BEST_MATCH_UNKNOWN )
        {
            Operation->NumberOfRefinds++;
        }
        else
        {
            Operation->NumberOfFinds++;
        }

        if ( ! GetLargestMatchForFragment( Operation,
                                           NewFragment
                                           ))
        {
            // No matches were found for this fragment.  Prune it (new changed bytes).

            Operation->NumberOfBytesChangedNew += NewFragment->Length;
            Operation->NumberOfBytesResolvedNew += NewFragment->Length;

            if ( Operation->Feature & FEATURE_SHOW_DIFFERENCES )
            {
                ShowAdded( Operation, NewFragment->Offset, NewFragment->Length );
            }

            DeleteNewFragment( Operation, NewFragment );

            if ( Operation->Feature & FEATURE_SHOW_FRAGMENTS )
            {
                printf( "   (pruned)\n" );
            }

            continue;
        }

        if ( Operation->NewBestSubFragment.Length > NewBestSubFragment.Length )
        {
            NewBestSubFragment = Operation->NewBestSubFragment;
            OldBestSubFragment = Operation->OldBestSubFragment;
        }
        else if ( Operation->NewBestSubFragment.Length == NewBestSubFragment.Length )
        {
            // Do nothing for greedy matches.  Ideally, we'd optimize to prefer edges, leave no fragments
            // smaller than MinimumRunLength, prefer entire fragments over subfragments, etc.
        }

        if ( Operation->Feature & FEATURE_SEQUENTIAL )
        {
            break;
        }
    }

    if ( NewBestSubFragment.Length == 0 )
    {
        return( FALSE );
    }

    Operation->NewBestSubFragment = NewBestSubFragment;
    Operation->OldBestSubFragment = OldBestSubFragment;

    return( TRUE );
}


BOOL
GetLargestMatchUsingPriority(
    OPERATION * Operation
    )
{
    NEW_FRAGMENT    * NewFragment;

    while ( NewFragment = Operation->PriorityQueue, NewFragment != NULL )
    {
        if ( Operation->Feature & FEATURE_SHOW_FRAGMENTS )
        {
            printf( "       Offset: %u  Length: %u  Prospect: %u  Best: %u  (New: %u  Old: %u)\n",
                    NewFragment->Offset,
                    NewFragment->Length,
                    NewFragment->BestProspect,
                    NewFragment->BestMatch,
                    NewFragment->BestNewOffset,
                    NewFragment->BestOldOffset
                    );
        }

        if ( NewFragment->BestMatch != BEST_MATCH_UNKNOWN )
        {
            Operation->NumberOfRefinds++;
        }
        else
        {
            Operation->NumberOfFinds++;
        }

        if ( ! GetLargestMatchForFragment( Operation,
                                           NewFragment
                                           ))
        {
            // No matches were found for this fragment.  Prune it (new changed bytes).

            Operation->NumberOfBytesChangedNew += NewFragment->Length;
            Operation->NumberOfBytesResolvedNew += NewFragment->Length;

            if ( Operation->Feature & FEATURE_SHOW_DIFFERENCES )
            {
                ShowAdded( Operation, NewFragment->Offset, NewFragment->Length );
            }

            DeleteNewFragment( Operation, NewFragment );

            if ( Operation->Feature & FEATURE_SHOW_FRAGMENTS )
            {
                printf( "   (pruned)\n" );
            }

            continue;
        }

        //  Calling GetLargestMatchForFragment() may have caused this fragment to
        //  sink in the priority queue.  If this isn't still the top, start over.

        if ( NewFragment != Operation->PriorityQueue )
        {
            Operation->NumberOfSinkers++;

            continue;
        }

        return( TRUE );
    }

    return( FALSE );
}


void
ShowAdded(
    OPERATION * Operation,
    DWORD       Offset,
    DWORD       Length
    )
{
    while ( Length-- )
    {
        printf( "Add: %08X  %02X\n", Offset, Operation->NewFileBuffer[ Offset ] );
        Offset++;
    }
}

void
ShowDeleted(
    OPERATION * Operation,
    DWORD       Offset,
    DWORD       Length
    )
{
    while ( Length-- )
    {
        printf( "Del: %08X  %02X\n", Offset, Operation->OldFileBuffer[ Offset ] );
        Offset++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decblk.c ===
/*
 * decblk.c
 *
 * main decoder module
 */
#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memcpy)

/*
 * Decode a block type
 */
static int decode_block(
                       t_decoder_context *context,
                       lzx_block_type     block_type,
                       long               bufpos,
                       long               amount_to_decode
                       )
{
    int result;

    if (block_type == BLOCKTYPE_ALIGNED)
        result = decode_aligned_offset_block(context, bufpos, (int) amount_to_decode);
    else if (block_type == BLOCKTYPE_VERBATIM)
        result = decode_verbatim_block(context, bufpos, (int) amount_to_decode);
    else if (block_type == BLOCKTYPE_UNCOMPRESSED)
        result = decode_uncompressed_block(context, bufpos, (int) amount_to_decode);
    else /* no other block types exist */
        result = -1;

    return result;
}



/*
 * Main decode entrypoint
 */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode)
{
    ulong                   amount_can_decode;
    long                    total_decoded;

    total_decoded = 0;

    while (bytes_to_decode > 0)
        {
        if (context->dec_decoder_state == DEC_STATE_START_NEW_BLOCK)
            {
            ulong   temp1;
            ulong   temp2;
            ulong   temp3;
            bool    do_translation;

            /*
             * If this is the first time this group, then get the
             * file size for translation.
             */
            if (context->dec_first_time_this_group)
                {
                context->dec_first_time_this_group = false;

                do_translation = (bool) getbits(context, 1);

                if (do_translation)
                    {
                    ulong high, low;

                    high = getbits(context, 16);
                    low  = getbits(context, 16);
                    context->dec_current_file_size = (high<<16)|low;
                    }
                else
                    {
                    context->dec_current_file_size = 0;
                    }
                }

            /*
             * If the last block we decoded was uncompressed, then
             * we need to skip the pad byte (if it exists), and
             * initialise the decoder's bit buffer
             */
            if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
                {
                /*
                 * If block size was odd, a pad byte is required
                 */
                if (context->dec_original_block_size & 1)
                    {
                    if (context->dec_input_curpos < context->dec_end_input_pos)
                        context->dec_input_curpos++;
                    }

                /* so that initialise_decoder_bitbuf() will succeed */
                context->dec_block_type = BLOCKTYPE_INVALID;

                initialise_decoder_bitbuf(context);
                }

            /* get the block type */
            context->dec_block_type = (lzx_block_type) getbits(context, 3);

            /* get size of block (in uncompressed bytes) to decode */
            temp1 = getbits(context, 8);
            temp2 = getbits(context, 8);
            temp3 = getbits(context, 8);

            /*
             * How large is the block we're going to decode?
             * It can be from 0...16777215 bytes (16MB)
             */
            context->dec_block_size =
            context->dec_original_block_size = (temp1<<16) + (temp2<<8) + (temp3);

            /* if block is an aligned type, read the aligned offset tree */
            if (context->dec_block_type == BLOCKTYPE_ALIGNED)
                read_aligned_offset_tree(context);

            /* read trees */
            if (context->dec_block_type == BLOCKTYPE_VERBATIM ||
                context->dec_block_type == BLOCKTYPE_ALIGNED)
                {
                /*      backup old trees */
                memcpy(
                      context->dec_main_tree_prev_len,
                      context->dec_main_tree_len,
                      MAIN_TREE_ELEMENTS
                      );

                memcpy(
                      context->dec_secondary_length_tree_prev_len,
                      context->dec_secondary_length_tree_len,
                      NUM_SECONDARY_LENGTHS
                      );

                read_main_and_secondary_trees(context);
                }
            else if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
                {
                if (handle_beginning_of_uncompressed_block(context) == false)
                    return -1;
                }
            else
                {
                /* no other block types are supported at this time */
                return -1;
                }

            context->dec_decoder_state = DEC_STATE_DECODING_DATA;
            }

        /*
         * Keep decoding until the whole block has been decoded
         */
        while ((context->dec_block_size > 0) && (bytes_to_decode > 0))
            {
            int decode_residue;

            amount_can_decode = min(context->dec_block_size, bytes_to_decode);

            /* shouldn't happen */
            if (amount_can_decode == 0)
                return -1;

            decode_residue = decode_block(
                                         context,
                                         context->dec_block_type,
                                         context->dec_bufpos,
                                         amount_can_decode
                                         );

            /*
             * We should have decoded exactly the amount we wanted,
             * since the encoder makes sure that no matches span 32K
             * boundaries.
             *
             * If the data was corrupted, it's possible that we decoded
             * up to MAX_MATCH bytes more than we wanted to.
             */
            if (decode_residue != 0)
                {
                /* error, we didn't decode what we wanted! */
                return -1;
                }

            context->dec_block_size -= amount_can_decode;
            bytes_to_decode -= amount_can_decode;
            total_decoded += amount_can_decode;
            }

        if (context->dec_block_size == 0)
            {
            context->dec_decoder_state = DEC_STATE_START_NEW_BLOCK;
            }

        if (bytes_to_decode == 0)
            {
            initialise_decoder_bitbuf(context);
            }
        }

#ifdef BIT16
    copy_data_to_output(
                       context,
                       total_decoded,
                       context->dec_output_buffer
                       );
#else
    copy_data_to_output(
                       context,
                       total_decoded,
                       context->dec_bufpos ?
                       &context->dec_mem_window[context->dec_bufpos - total_decoded] :
                       &context->dec_mem_window[context->dec_window_size - total_decoded]
                       );
#endif

    return total_decoded;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decapi.c ===
/*
 * decapi.c
 *
 * API entry points.
 */

#define ALLOC_VARS
#include "decoder.h"
#include <stdio.h>

#include <memory.h>
#pragma intrinsic(memcpy)

bool __stdcall LZX_DecodeInit(
                  t_decoder_context **dec_context,
                  long                compression_window_size,
                  PFNALLOC            pfnma,
                  HANDLE              hAllocator
                  )
{
    t_decoder_context *context= pfnma( hAllocator, sizeof( t_decoder_context ));

    if ( context == NULL ) {
        return false;
        }

    *dec_context = context;

    context->dec_malloc       = pfnma;
    context->dec_mallochandle = hAllocator;

    context->dec_window_size = compression_window_size;
    context->dec_window_mask = context->dec_window_size - 1;

    /*
     * Window size must be a power of 2
     */
    if (context->dec_window_size & context->dec_window_mask)
        return false;

    if (allocate_decompression_memory(context) == false)
        return false;

    LZX_DecodeNewGroup(context);

    return true;
}


void __fastcall LZX_DecodeNewGroup(t_decoder_context *context)
{
    reset_decoder_trees(context);
    decoder_misc_init(context);
    init_decoder_translation(context);
    context->dec_num_cfdata_frames = 0;

}


int __stdcall LZX_Decode(
              t_decoder_context *context,
              long    bytes_to_decode,
              byte *  compressed_input_buffer,
              long    compressed_input_size,
              byte *  uncompressed_output_buffer,
              long    uncompressed_output_size,
              long *  bytes_decoded
              )
{
    long    result;

    context->dec_input_curpos   = compressed_input_buffer;
    context->dec_end_input_pos  = (compressed_input_buffer + compressed_input_size + 4);

    context->dec_output_buffer  = uncompressed_output_buffer;

    init_decoder_input(context);

    result = decode_data(context, bytes_to_decode);

    context->dec_num_cfdata_frames++;

    if (result < 0)
        {
        *bytes_decoded = 0;
        return 1; /* failure */
        }
    else
        {
        *bytes_decoded = result;
        context->dec_position_at_start += result;
        return 0; /* success */
        }
}


//
// Warning, this dictionary is inserted verbatim, and is not E8
// translated.  If the encoder did E8 translation on its preloaded
// dictionary, this won't work.
//

#ifdef TRACING
ulong TracingOldDataSize;
#endif

#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))

bool __fastcall LZX_DecodeInsertDictionary(
                               t_decoder_context * context,
                               const byte *        data,
                               unsigned long       data_size
                               )
{
    if (data_size > context->dec_window_size)
        return false;

#ifdef TRACING
    TracingOldDataSize = data_size;
#endif

    memcpy(
          &context->dec_mem_window[context->dec_window_size - data_size],
          data,
          data_size
          );

    return true;
}


#ifdef TRACING

#pragma message( "LZX decoder tracing enabled" )

void
__stdcall
TracingMatch(
    ulong BufPos,
    ulong MatchPos,
    ulong WindowSize,
    ulong MatchLength,
    ulong MatchPosSlot
    )
    {
    printf(
        "\rMATCH: At %08X, From %s %08X (%9d), Len %08X (%8d)\n",
        BufPos,
         ( MatchPosSlot == 0 ) ? "L0" :
         ( MatchPosSlot == 1 ) ? "L1" :
         ( MatchPosSlot == 2 ) ? "L2" : "  ",
        MatchPos,
        MatchPos,
        MatchLength,
        MatchLength
        );
    }


void
__stdcall
TracingLiteral(
    ulong BufPos,
    ulong ch
    )
    {
    printf(
        "\rLITER: At %08X, 0x%02X '%c'\n",
        BufPos,
        ch,
        ( ch < ' ' ) ? ' ' : ch
        );
    }


#endif /* TRACING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decin.c ===
/*
 * decin.c
 *
 * Decoder inputting of compressed data
 */
#include "decoder.h"


/*
 * Initialises the bit buffer state
 */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context)
{
    byte *p;

    /*
     * If we're decoding an uncompressed block, don't use the
     * bit buffer; we're reading directly out of the input.
     */
    if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
        return;

    if ((context->dec_input_curpos + sizeof(ulong)) > context->dec_end_input_pos)
        return;

    p = context->dec_input_curpos;

    context->dec_bitbuf =
    ((ulong) p[2] | (((ulong) p[3]) << 8)) |
    ((((ulong) p[0] | (((ulong) p[1]) << 8))) << 16);

    context->dec_bitcount = 16;
    context->dec_input_curpos += 4;
}


/*
 * Initialise input buffer and bitwise i/o
 */
void NEAR init_decoder_input(t_decoder_context *context)
{
    initialise_decoder_bitbuf(context);
}


void NEAR fillbuf(t_decoder_context *context, int n)
{
    context->dec_bitbuf <<= n;
    context->dec_bitcount -= (char) n;

    if (context->dec_bitcount <= 0)
        {
        if (context->dec_input_curpos >= context->dec_end_input_pos)
            {
            context->dec_error_condition = true;
            return;
            }

        context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
        context->dec_input_curpos += 2;
        context->dec_bitcount += 16;

        if (context->dec_bitcount <= 0)
            {
            if (context->dec_input_curpos >= context->dec_end_input_pos)
                {
                context->dec_error_condition = true;
                return;
                }

            context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
            context->dec_input_curpos += 2;
            context->dec_bitcount += 16;
            }
        }
}


ulong NEAR getbits(t_decoder_context *context, int n)
{
    ulong value;

    value = context->dec_bitbuf >> (32-(n));
    fillbuf(context, n);

    return value;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decinit.c ===
/*
 * decinit.c
 *
 * Initialisation routines for LZX decoder
 */

#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memset)

/*
 * Allocate memory for decompression
 */
bool NEAR allocate_decompression_memory(t_decoder_context *context)
{
    ulong   pos_start;

    context->dec_num_position_slots = 4;
    pos_start                                               = 4;

    while (1)
        {
        pos_start += 1L << dec_extra_bits[context->dec_num_position_slots];

        context->dec_num_position_slots++;

        if (pos_start >= context->dec_window_size)
            break;
        }

    if (!(context->dec_mem_window = (byte *) context->dec_malloc( context->dec_mallochandle, context->dec_window_size+(MAX_MATCH+4))))
        return false;

    return true;
}



/*
 * Set/reset decoder trees to initial state
 */
void NEAR reset_decoder_trees(t_decoder_context *context)
{
    memset(context->dec_main_tree_len, 0, MAIN_TREE_ELEMENTS);
    memset(context->dec_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);

    memset(context->dec_secondary_length_tree_len, 0, NUM_SECONDARY_LENGTHS);
    memset(context->dec_secondary_length_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);
}


/*
 * Miscellaneous state initialisations
 */
void NEAR decoder_misc_init(t_decoder_context *context)
{
    context->dec_last_matchpos_offset[0]             = 1;
    context->dec_last_matchpos_offset[1]             = 1;
    context->dec_last_matchpos_offset[2]             = 1;

    context->dec_bufpos = 0;
    context->dec_position_at_start = 0;

    context->dec_decoder_state      = DEC_STATE_START_NEW_BLOCK;
    context->dec_block_size         = 0;

    /* so that initialise_decoder_bitbuf() will succeed */
    context->dec_block_type     = BLOCKTYPE_INVALID;

    context->dec_first_time_this_group      = true;
    context->dec_current_file_size          = 0;

    context->dec_error_condition = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decout.c ===
/*
 * decout.c
 *
 * Decoder outputting
 */

#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memcpy)

void copy_data_to_output(t_decoder_context *context, long amount, const byte *data)
{
    memcpy(
        context->dec_output_buffer,
        data,
        amount
    );

    /* perform jump translation */
    if ((context->dec_current_file_size != 0) && (context->dec_num_cfdata_frames < E8_CFDATA_FRAME_THRESHOLD))
    {
        decoder_translate_e8(
            context,
            context->dec_output_buffer,
            amount
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decproto.h ===
/*
 * decproto.h
 *
 * Decoder function prototypes
 */

/* decblk.c */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode);

/* decin.c */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context);
void NEAR init_decoder_input(t_decoder_context *context);
void NEAR fillbuf(t_decoder_context *context, int n);
ulong NEAR getbits(t_decoder_context *context, int n);

/* decinit.c */
bool NEAR allocate_decompression_memory(t_decoder_context *context);
void NEAR free_decompression_memory(t_decoder_context *context);
void NEAR decoder_misc_init(t_decoder_context *context);
void NEAR reset_decoder_trees(t_decoder_context *context);

/* decout.c */
void NEAR copy_data_to_output(t_decoder_context *context, long amount, const byte *data);

/* dectree.c */
bool NEAR read_main_and_secondary_trees(t_decoder_context *context);
bool NEAR read_aligned_offset_tree(t_decoder_context *context);

/* maketbl.c */
bool NEAR __cdecl make_table(
        t_decoder_context *context,
        int                     nchar,
        const byte      *bitlen,
        byte            tablebits,
        short           *table,
        short           *leftright
);

bool NEAR make_table_8bit(t_decoder_context *context, byte *bitlen, byte *table);

/* decxlat.c */
void NEAR init_decoder_translation(t_decoder_context *context);
void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes);

/* decalign.c */
int NEAR decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decverb.c */
int NEAR decode_verbatim_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decuncmp.c */
int NEAR decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode);
bool NEAR handle_beginning_of_uncompressed_block(t_decoder_context *context);


/*
 * 16-bit stuff:
 */
#ifdef BIT16
void NEAR DComp_Close(t_decoder_context *context);
int  NEAR DComp_Init(t_decoder_context *context);
void NEAR DComp_Reset(t_decoder_context *context);
void NEAR DComp_Save_Output_Pages(t_decoder_context *context, uint bytes_decoded);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\dectree.c ===
/*
 * dectree.c
 *
 * Decoding the encoded tree structures
 *
 * To save much code size, the fillbuf()/getbits() calls have
 * been made into functions, rather than being inlined macros.
 * The macros actually take up a lot of space.  There is no
 * performance loss from doing so here.
 */
#include "decoder.h"

/* number of elements in pre-tree */
#define NUM_DECODE_SMALL        20

/* lookup table size */
#define DS_TABLE_BITS           8

/* macro to decode a pre-tree element */
#define DECODE_SMALL(item) \
{ \
        item = small_table[context->dec_bitbuf >> (32-DS_TABLE_BITS) ]; \
        if (item < 0)                                                           \
        {                                                                                       \
      mask = (1L << (32-1-DS_TABLE_BITS));      \
      do                                                                                \
      {                                                                                 \
                        item = -item;                                           \
            if (context->dec_bitbuf & mask)     \
                                item = leftright_s[2*item+1];   \
                        else                                                            \
                                item = leftright_s[2*item];             \
                        mask >>= 1;                                                     \
                } while (item < 0);                                             \
   }                                                                                    \
   fillbuf(context, small_bitlen[item]);                \
}

/*
 * Reads a compressed tree structure
 */
static bool NEAR ReadRepTree(
                            t_decoder_context       *context,
                            int                                     num_elements,
                            byte                            *lastlen,
                            byte                            *len
                            )
{
    ulong   mask;
    int             i;
    int             consecutive;
    byte    small_bitlen[24];
    short   small_table[1 << DS_TABLE_BITS];
    short   leftright_s [2*(2 * 24 - 1)];
    short   Temp;

    /* Declare this inline to help compilers see the optimisation */
    static const byte Modulo17Lookup[] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
    };

    /* read pre-tree */
    for (i = 0; i < NUM_DECODE_SMALL; i++)
        {
        small_bitlen[i] = (byte) getbits(context, 4);
        }

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;

    /* make a table for this pre-tree */
    make_table(
              context,
              NUM_DECODE_SMALL,
              small_bitlen,
              DS_TABLE_BITS,
              small_table,
              leftright_s
              );

    for (i = 0; i < num_elements; i++)
        {
        DECODE_SMALL(Temp);

        /* exceeded input buffer? */
        if (context->dec_error_condition)
            return false;

        /* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1" zeroes */
        if (Temp == 17)
            {
            /* code 17 means "a small number of repeated zeroes" */
            consecutive = (byte) getbits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS);
            consecutive += TREE_ENC_REP_MIN;

            /* boundary check */
            if (i + consecutive >= num_elements)
                consecutive = num_elements-i;

            while (consecutive-- > 0)
                len[i++] = 0;

            i--;
            }
        else if (Temp == 18)
            {
            /* code 18 means "a large number of repeated zeroes" */

            /* Repeat "TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1...<ditto>+(1<<TREE_ENC_REPZ_SECOND_EXTRA_BITS)-1" zeroes */
            consecutive = (byte) getbits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS);
            consecutive += (TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST);

            /* boundary check */
            if (i + consecutive >= num_elements)
                consecutive = num_elements-i;

            while (consecutive-- > 0)
                len[i++] = 0;

            i--;
            }
        else if (Temp == 19)
            {
            byte    value;

            /* code 19 means "a small number of repeated somethings" */
            /* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REP_SAME_EXTRA_BITS)-1" elements */
            consecutive = (byte) getbits(context, TREE_ENC_REP_SAME_EXTRA_BITS);
            consecutive += TREE_ENC_REP_MIN;

            /* boundary check */
            if (i + consecutive >= num_elements)
                consecutive = num_elements-i;

            /* get the element number to repeat */
            DECODE_SMALL(Temp);
            value = Modulo17Lookup[(lastlen[i] - Temp)+17];

            while (consecutive-- > 0)
                len[i++] = value;

            i--;
            }
        else
            {
            len[i] = Modulo17Lookup[(lastlen[i] - Temp)+17];
            }
        }

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;
    else
        return true;
}


bool NEAR read_main_and_secondary_trees(t_decoder_context *context)
{
    /* read first 256 elements (characters) of the main tree */
    if (false == ReadRepTree(
                            context,
                            256,
                            context->dec_main_tree_prev_len,
                            context->dec_main_tree_len))
        {
        return false;
        }

    /*
     * read remaining elements (primary match lengths * positions)
     * of the main tree
     */
    if (false == ReadRepTree(
                            context,
                            context->dec_num_position_slots*NUM_LENGTHS,
                            &context->dec_main_tree_prev_len[256],
                            &context->dec_main_tree_len[256]))
        {
        return false;
        }

    /* create lookup table for the main tree */
    if (false == make_table(
                           context,
                           MAIN_TREE_ELEMENTS,
                           context->dec_main_tree_len,
                           MAIN_TREE_TABLE_BITS,
                           context->dec_main_tree_table,
                           context->dec_main_tree_left_right))
        {
        return false;
        }

    /* read secondary length tree */
    if (false == ReadRepTree(
                            context,
                            NUM_SECONDARY_LENGTHS,
                            context->dec_secondary_length_tree_prev_len,
                            context->dec_secondary_length_tree_len))
        {
        return false;
        }

    /* create lookup table for the secondary length tree */
    if (false == make_table(
                           context,
                           NUM_SECONDARY_LENGTHS,
                           context->dec_secondary_length_tree_len,
                           SECONDARY_LEN_TREE_TABLE_BITS,
                           context->dec_secondary_length_tree_table,
                           context->dec_secondary_length_tree_left_right))
        {
        return false;
        }

    return true;
}


/* read 8 element aligned offset tree */
bool NEAR read_aligned_offset_tree(t_decoder_context *context)
{
    int             i;

    /* read bit lengths of the 8 codes */
    for (i = 0; i < 8; i++)
        {
        context->dec_aligned_len[i] = (byte) getbits(context, 3);
        }

    if (context->dec_error_condition)
        return false;

    /*
     * Make table with no left/right, and byte Table[] instead of
     * short Table[]
     */
    if (false == make_table_8bit(
                                context,
                                context->dec_aligned_len,
                                (byte *) context->dec_aligned_table))
        {
        return false;
        }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decoder.h ===
/*
 * decoder.h
 *
 * Main decoder header file
 */

#ifndef DECODER_H
#define DECODER_H

#ifdef EXT
#       undef EXT
#endif

#ifdef ALLOC_VARS
#       define EXT
#else
#       define EXT extern
#endif

#ifdef USE_ASSEMBLY
#   define ASM_DECODE_VERBATIM_BLOCK
#   define ASM_TRANSLATE_E8
#   define ASM_MAKE_TABLE
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#include <stdlib.h>
#include <string.h>
#include "../common/typedefs.h"
#include "../common/compdefs.h"
#include "decmacro.h"
#include "decdefs.h"

#include "decvars.h"
#include "decapi.h"
#include "decproto.h"

#ifdef TRACING

#include <stdio.h>

void
__stdcall
TracingMatch(
    ulong BufPos,
    ulong MatchPos,
    ulong WindowSize,
    ulong MatchLength,
    ulong MatchPosSlot
    );

void
__stdcall
TracingLiteral(
    ulong BufPos,
    ulong ch
    );

#endif // TRACING

#endif /* DECODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decuncmp.c ===
/*
 * decuncmp.c
 *
 * Decoding uncompressed blocks
 */
#include "decoder.h"


int decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
    long    bytes_decoded = 0;
    long    bufpos_end;
    long    decode_residue;
    ulong   bufpos_start;
    ulong   end_copy_pos;
    byte *  p;

    bufpos_start = bufpos;
    bufpos_end = bufpos + amount_to_decode;

    p = context->dec_input_curpos;

    while (bufpos < bufpos_end)
        {
        if (p >= context->dec_end_input_pos)
            return -1; // input overflow

#ifdef TRACING
        TracingLiteral(bufpos, *p);
#endif
        context->dec_mem_window[bufpos++] = *p++;
        }

    context->dec_input_curpos = p;

    /*
     * Make sure the MAX_MATCH bytes starting at window[window_size]
     * are always the same as the first MAX_MATCH bytes starting at
     * window[0].  This is for our optimisation in decverb.c and
     * decalign.c which allows us to not have to & window_mask all the
     * time.
     */
    end_copy_pos = min(MAX_MATCH, bufpos_end);

    /*
     * Keep copying until we hit MAX_MATCH or the number of bytes
     * we decoded
     */
    while (bufpos_start < end_copy_pos)
        {
        context->dec_mem_window[bufpos_start + context->dec_window_size] =
        context->dec_mem_window[bufpos_start];
        bufpos_start++;
        }

    decode_residue = bufpos - bufpos_end;

    bufpos &= context->dec_window_mask;
    context->dec_bufpos = bufpos;

    return (int) decode_residue;
}


bool handle_beginning_of_uncompressed_block(t_decoder_context *context)
{
    int     i;

    /*
     * we want to read the 16 bits already in bitbuf, so backtrack
     * the input pointer by 2 bytes.
     */
    context->dec_input_curpos -= 2;

    if (context->dec_input_curpos+4 >= context->dec_end_input_pos)
        return false;

    /*
     * update LRU repeated offset list
     */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
        {
        context->dec_last_matchpos_offset[i] =
        ((ulong) *(  (byte *) context->dec_input_curpos)    )        |
        ((ulong) *( ((byte *) context->dec_input_curpos) + 1) << 8)  |
        ((ulong) *( ((byte *) context->dec_input_curpos) + 2) << 16) |
        ((ulong) *( ((byte *) context->dec_input_curpos) + 3) << 24);

        context->dec_input_curpos += 4; /* increment by 4 bytes */
        }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decxlat.c ===
/*
 * xlat.c
 *
 * Translate
 */
#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memcpy,memset)

void NEAR init_decoder_translation(t_decoder_context *context)
{
    context->dec_instr_pos = 0;
}


#ifdef ASM_TRANSLATE_E8
ulong __cdecl asm_decoder_translate_e8(ulong instr_pos, ulong file_size, byte *mem, long bytes);

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{
    /*
     * We don't want the ASM code to have to worry about where in the
     * context structure a particular element is
     */
    context->dec_instr_pos = asm_decoder_translate_e8(
                                                     context->dec_instr_pos,
                                                     context->dec_current_file_size,
                                                     mem,
                                                     bytes
                                                     );
}

#else /* !ASM_TRANSLATE_E8 */

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{
    ulong   end_instr_pos;
    byte    temp[6];
    byte    *mem_backup;

    if (bytes <= 6)
        {
        context->dec_instr_pos += bytes;
        return;
        }

    mem_backup = mem;

    /* backup these bytes */
    memcpy(temp, &mem[bytes-6], 6);

    /* overwrite them with 0xE8 */
    memset(&mem[bytes-6], 0xE8, 6);

    end_instr_pos = context->dec_instr_pos + bytes - 6;

    while (1)
        {
        unsigned long   absolute;

        /*
         * We are guaranteed to hit one of the 6 0xE8's we stuck at the
         * end of the buffer, even if we ran into some corrupted data
         * that resulted in our jumping over 5 bytes due to a translation
         */
        while (*mem++ != 0xE8)
            context->dec_instr_pos++;

        if (context->dec_instr_pos >= end_instr_pos)
            break;

        /*
         * There are 5 or more bytes in the buffer
         * (i.e. E8 xx xx xx xx)
         *
         * We have a complete offset available to (potentially) translate
         */

        absolute = *(UNALIGNED ulong *) mem;

        if (absolute < context->dec_current_file_size)
            {
            /* absolute >= 0 && absolute < dec_current_file_size */

            *(UNALIGNED ulong *) mem = absolute - context->dec_instr_pos;
            }
        else if ((ulong) (-(long) absolute) <= context->dec_instr_pos)
            {
            /* absolute >= -instr_pos && absolute < 0 */

            *(UNALIGNED ulong *) mem = absolute + context->dec_current_file_size;
            }

        mem += 4;
        context->dec_instr_pos += 5;
        }

    context->dec_instr_pos = end_instr_pos + 6;

    /* restore these bytes */
    memcpy(&mem_backup[bytes-6], temp, 6);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decvars.h ===
/*
 * decvars.h
 *
 * Variables for the decoder
 */

/*
 * MAX_MAIN_TREE_ELEMENTS should be >= 256 + 8*num_position_slots
 * (that comes out to 256 + 8*51 right now, for a 2 MB window).
 *
 * Make divisible by 4 so things are longword aligned.
 */
#define MAX_MAIN_TREE_ELEMENTS (256 + (8 * 291))   // 32MB

typedef struct
    {
    /* 16-bit version does not have one big window pointer */
#ifndef BIT16
    /* pointer to beginning of window buffer */
    byte                    *dec_mem_window;
#endif

    /* window/decoding buffer parameters */
    ulong               dec_window_size;
    ulong                           dec_window_mask;

    /* previous match offsets */
    ulong               dec_last_matchpos_offset[NUM_REPEATED_OFFSETS];

    /* main tree table */
    short                           dec_main_tree_table[1 << MAIN_TREE_TABLE_BITS];

    /* secondary length tree table */
    short               dec_secondary_length_tree_table[1 << SECONDARY_LEN_TREE_TABLE_BITS];

    /* main tree bit lengths */
    byte                            dec_main_tree_len[MAX_MAIN_TREE_ELEMENTS];

    /* secondary tree bit lengths */
    byte                dec_secondary_length_tree_len[NUM_SECONDARY_LENGTHS];
    byte                            pad1[3]; /* NUM_SECONDARY_LENGTHS == 249 */

    /* aligned offset table */
    char                            dec_aligned_table[1 << ALIGNED_TABLE_BITS];
    byte                            dec_aligned_len[ALIGNED_NUM_ELEMENTS];

    /* left/right pointers for main tree (2*n shorts left, 2*n shorts for right) */
    short               dec_main_tree_left_right[MAX_MAIN_TREE_ELEMENTS*4];

    /* left/right pointers for secondary length tree */
    short               dec_secondary_length_tree_left_right[NUM_SECONDARY_LENGTHS*4];

    /* input (compressed) data pointers */
    byte *              dec_input_curpos;
    byte *              dec_end_input_pos;

    /* output (uncompressed) data pointer */
    byte *              dec_output_buffer;

    /* position in data stream at start of this decode call */
    long                dec_position_at_start;

    /* previous lengths */
    byte                            dec_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS];
    byte                            dec_secondary_length_tree_prev_len[NUM_SECONDARY_LENGTHS];

    /* bitwise i/o */
    ulong               dec_bitbuf;
    signed char             dec_bitcount;

    /* number of distinct position (displacement) slots */
    ulong               dec_num_position_slots;

    bool                            dec_first_time_this_group;
    bool                dec_error_condition;

    /* misc */
    long                    dec_bufpos;
    ulong                           dec_current_file_size;
    ulong                           dec_instr_pos;
    ulong               dec_num_cfdata_frames;

    /* original size of current block being decoded (in uncompressed bytes) */
    long                dec_original_block_size;

    /* remaining size of current block being decoded (in uncompressed bytes) */
    long                            dec_block_size;

    /* type of current block being decoded */
    lzx_block_type          dec_block_type;

    /* current state of decoder */
    decoder_state           dec_decoder_state;

    /* memory allocation functions */
    PFNALLOC                        dec_malloc;
    HANDLE                          dec_mallochandle;

    } t_decoder_context;


/* declare arrays? */
#ifndef ALLOC_VARS

EXT const byte NEAR     dec_extra_bits[];
EXT const long NEAR     MP_POS_minus2[];

#else

const byte NEAR dec_extra_bits[] =
{
0,0,0,0,1,1,2,2,
3,3,4,4,5,5,6,6,
7,7,8,8,9,9,10,10,
11,11,12,12,13,13,14,14,
15,15,16,16,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17
};

/*
 * first (base) position covered by each slot
 * 2 subtracted for optimisation purposes (see decverb.c/decalign.c comments)
 */
const long NEAR MP_POS_minus2[sizeof(dec_extra_bits)] =
{
0-2,        1-2,        2-2,        3-2,        4-2,        6-2,        8-2,        12-2,
16-2,       24-2,       32-2,       48-2,       64-2,       96-2,       128-2,      192-2,
256-2,      384-2,      512-2,      768-2,      1024-2,     1536-2,     2048-2,     3072-2,
4096-2,     6144-2,     8192-2,     12288-2,    16384-2,    24576-2,    32768-2,    49152-2,
65536-2,    98304-2,    131072-2,   196608-2,   262144-2,   393216-2,   524288-2,   655360-2,
786432-2,   917504-2,   1048576-2,  1179648-2,  1310720-2,  1441792-2,  1572864-2,  1703936-2,
1835008-2,  1966080-2,  2097152-2,  2228224-2,  2359296-2,  2490368-2,  2621440-2,  2752512-2,
2883584-2,  3014656-2,  3145728-2,  3276800-2,  3407872-2,  3538944-2,  3670016-2,  3801088-2,
3932160-2,  4063232-2,  4194304-2,  4325376-2,  4456448-2,  4587520-2,  4718592-2,  4849664-2,
4980736-2,  5111808-2,  5242880-2,  5373952-2,  5505024-2,  5636096-2,  5767168-2,  5898240-2,
6029312-2,  6160384-2,  6291456-2,  6422528-2,  6553600-2,  6684672-2,  6815744-2,  6946816-2,
7077888-2,  7208960-2,  7340032-2,  7471104-2,  7602176-2,  7733248-2,  7864320-2,  7995392-2,
8126464-2,  8257536-2,  8388608-2,  8519680-2,  8650752-2,  8781824-2,  8912896-2,  9043968-2,
9175040-2,  9306112-2,  9437184-2,  9568256-2,  9699328-2,  9830400-2,  9961472-2,  10092544-2,
10223616-2, 10354688-2, 10485760-2, 10616832-2, 10747904-2, 10878976-2, 11010048-2, 11141120-2,
11272192-2, 11403264-2, 11534336-2, 11665408-2, 11796480-2, 11927552-2, 12058624-2, 12189696-2,
12320768-2, 12451840-2, 12582912-2, 12713984-2, 12845056-2, 12976128-2, 13107200-2, 13238272-2,
13369344-2, 13500416-2, 13631488-2, 13762560-2, 13893632-2, 14024704-2, 14155776-2, 14286848-2,
14417920-2, 14548992-2, 14680064-2, 14811136-2, 14942208-2, 15073280-2, 15204352-2, 15335424-2,
15466496-2, 15597568-2, 15728640-2, 15859712-2, 15990784-2, 16121856-2, 16252928-2, 16384000-2,
16515072-2, 16646144-2, 16777216-2, 16908288-2, 17039360-2, 17170432-2, 17301504-2, 17432576-2,
17563648-2, 17694720-2, 17825792-2, 17956864-2, 18087936-2, 18219008-2, 18350080-2, 18481152-2,
18612224-2, 18743296-2, 18874368-2, 19005440-2, 19136512-2, 19267584-2, 19398656-2, 19529728-2,
19660800-2, 19791872-2, 19922944-2, 20054016-2, 20185088-2, 20316160-2, 20447232-2, 20578304-2,
20709376-2, 20840448-2, 20971520-2, 21102592-2, 21233664-2, 21364736-2, 21495808-2, 21626880-2,
21757952-2, 21889024-2, 22020096-2, 22151168-2, 22282240-2, 22413312-2, 22544384-2, 22675456-2,
22806528-2, 22937600-2, 23068672-2, 23199744-2, 23330816-2, 23461888-2, 23592960-2, 23724032-2,
23855104-2, 23986176-2, 24117248-2, 24248320-2, 24379392-2, 24510464-2, 24641536-2, 24772608-2,
24903680-2, 25034752-2, 25165824-2, 25296896-2, 25427968-2, 25559040-2, 25690112-2, 25821184-2,
25952256-2, 26083328-2, 26214400-2, 26345472-2, 26476544-2, 26607616-2, 26738688-2, 26869760-2,
27000832-2, 27131904-2, 27262976-2, 27394048-2, 27525120-2, 27656192-2, 27787264-2, 27918336-2,
28049408-2, 28180480-2, 28311552-2, 28442624-2, 28573696-2, 28704768-2, 28835840-2, 28966912-2,
29097984-2, 29229056-2, 29360128-2, 29491200-2, 29622272-2, 29753344-2, 29884416-2, 30015488-2,
30146560-2, 30277632-2, 30408704-2, 30539776-2, 30670848-2, 30801920-2, 30932992-2, 31064064-2,
31195136-2, 31326208-2, 31457280-2, 31588352-2, 31719424-2, 31850496-2, 31981568-2, 32112640-2,
32243712-2, 32374784-2, 32505856-2, 32636928-2, 32768000-2, 32899072-2, 33030144-2, 33161216-2,
33292288-2, 33423360-2, 33554432-2
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\blkinit.c ===
/*
 * blkinit.c
 *
 * Block outputting initialisation
 */

#include "encoder.h"


/*
 * Create lookup table for MP_SLOT() macro
 */
void create_slot_lookup_table(t_encoder_context *context)
{
   int			j;
   int 			p;
   int 			elements_to_init;
   ushort       slotnum;

   context->enc_slot_table[0] = 0;
   context->enc_slot_table[1] = 1;
   context->enc_slot_table[2] = 2;
   context->enc_slot_table[3] = 3;

   elements_to_init = 2;

   slotnum = 4;
   p       = 4;

   do
   {
      for (j = elements_to_init; j > 0; j--)
         context->enc_slot_table[p++] = slotnum;

      slotnum++;

      for (j = elements_to_init; j > 0; j--)
         context->enc_slot_table[p++] = slotnum;

      slotnum++;
      elements_to_init <<= 1;

   } while (p < 1024);
}


/*
 * Create lookup table for figuring out how many
 * ones there are in a given byte.
 */
void create_ones_table(t_encoder_context *context)
{
	int			i, j;
	byte		ones;

	for (i = 0; i < 256; i++)
	{
		ones = 0;

		for (j = i; j; j >>= 1)
		{
			if (j & 1)
				ones++;
		}

		context->enc_ones[i] = ones;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\decverb.c ===
/*
 * decverb.c
 *
 * Decoding verbatim-bit blocks
 */
#include "decoder.h"


static long special_decode_verbatim_block(
                                         t_decoder_context   *context,
                                         long                BufPos,
                                         int                 amount_to_decode
                                         )
{
    ulong   match_pos;
    long    bufpos_end;
    int     match_length;
    int     c;
    ulong   dec_bitbuf;
    byte    *dec_input_curpos;
    byte    *dec_end_input_pos;
    byte    *dec_mem_window;
    char    dec_bitcount;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf        = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = BufPos + amount_to_decode;

    /*
     * We may overflow by up to MAX_MATCH
     */
    while (BufPos < bufpos_end)
        {
        /* decode an item from the main tree */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {
            /*      it's a character */
            /* note: c - 256 == c if c is a byte */
#ifdef TRACING
            TracingLiteral(BufPos, (byte) c);
#endif
            context->dec_mem_window[BufPos] = (byte) c;

            /* we know BufPos < bufpos_end here, so no need to check for overflow */
            context->dec_mem_window[context->dec_window_size+BufPos] = (byte) c;
            BufPos++;
            }
        else
            {
            /* get match length header */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                /* get match length footer if necessary */
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /* get match position slot */
            m = c >> NL_SHIFT;

            /* read any extra bits for the match position */
            if (m > 2)
                {
                if (m > 3) /* dec_extra_bits[m] != 0 */
                    {
                    GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
                    match_pos += MP_POS_minus2[m];
                    }
                else
                    {
                    match_pos = 1; // MP_POS_minus2[3];
                    }

                /*
                 * Add match base to "extra bits".  Our match base
                 * table has 2 subtracted from all the elements.
                 *
                 * This is because encoded positions 0,1,2 denote
                 * repeated offsets.  Encoded position 3 denotes
                 * a match 1 character away, 4 encodes 2 away, etc.
                 * Hence the subtraction of 2, which has been
                 * incorporated into the table.
                 */

                /* update LRU repeated offset list */
                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                /* positions 0, 1, 2 denote repeated offsets */
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            /* match lengths range from 2...257 */
            match_length += MIN_MATCH;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  See detailed explanation in decalign.c
                //

                ULONG ExtraMatchLength, ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }
                        else {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }
                    else {
                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                match_length += ExtraMatchLength;
                }

#endif

#ifdef TRACING
            TracingMatch(BufPos,
                         BufPos - match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            /* copy match data */
            do
                {
                context->dec_mem_window[BufPos] = context->dec_mem_window[(BufPos-match_pos) & context->dec_window_mask];

                /* replicate bytes */
                if (BufPos < MAX_MATCH) // BUGBUG: what does this do?  Does it need to be more than MAX_MATCH now?
                    context->dec_mem_window[context->dec_window_size+BufPos] = context->dec_mem_window[BufPos];

                BufPos++;
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf       = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    return BufPos;
}


#ifdef ASM_DECODE_VERBATIM_BLOCK

long __cdecl fast_decode_verbatim_block(
                                       t_decoder_context   *context,
                                       long                BufPos,
                                       int                 amount_to_decode
                                       );

#else /* !ASM_DECODE_VERBATIM_BLOCK */

long fast_decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
    ulong   match_pos;
    ulong   match_ptr;
    long    bufpos_end;
    long    decode_residue;
    int             match_length;
    int             c;
    ulong   dec_bitbuf;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    byte    *dec_mem_window;
    char    dec_bitcount;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf        = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = BufPos + amount_to_decode;

    while (BufPos < bufpos_end)
        {
        /* decode an item from the main tree */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {
            /*      it's a character */
            /* note: c - 256 == c if c is a byte */
#ifdef TRACING
            TracingLiteral(BufPos, (byte) c);
#endif
            context->dec_mem_window[BufPos++] = (byte) c;
            }
        else
            {
            /* get match length header */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                /* get match length footer if necessary */
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /* get match position slot */
            m = c >> NL_SHIFT;

            /* read any extra bits for the match position */
            if (m > 2)
                {
                if (m > 3) /* dec_extra_bits[m] != 0 */
                    {
                    GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
                    match_pos += MP_POS_minus2[m];
                    }
                else
                    {
                    match_pos = MP_POS_minus2[3];
                    }

                /*
                 * Add match base to "extra bits".  Our match base
                 * table has 2 subtracted from all the elements.
                 *
                 * This is because encoded positions 0,1,2 denote
                 * repeated offsets.  Encoded position 3 denotes
                 * a match 1 character away, 4 encodes 2 away, etc.
                 * Hence the subtraction of 2, which has been
                 * incorporated into the table.
                 */

                /* update LRU repeated offset list */
                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                /* positions 0, 1, 2 denote repeated offsets */
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            /* match lengths range from 2...257 */
            match_length += MIN_MATCH;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  See detailed explanation in decalign.c
                //

                ULONG ExtraMatchLength, ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }
                        else {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }
                    else {
                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                match_length += ExtraMatchLength;
                }

#endif

            match_ptr = (BufPos - match_pos) & context->dec_window_mask;

#ifdef TRACING
            TracingMatch(BufPos,
                         BufPos - match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            /* copy match data */

            do
                {
                context->dec_mem_window[BufPos++] = context->dec_mem_window[match_ptr++];
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf       = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    /* should be zero */
    decode_residue = BufPos - bufpos_end;

    BufPos &= context->dec_window_mask;
    context->dec_bufpos = BufPos;

    return decode_residue;
}
#endif /* ASM_DECODE_VERBATIM_BLOCK */


int decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
        {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = min(MAX_MATCH-BufPos, amount_to_decode);

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_verbatim_block(
                                                  context,
                                                  BufPos,
                                                  amount_to_slowly_decode
                                                  );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
        }

    return fast_decode_verbatim_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\decoder\maketbl.c ===
/*
 * Table-building routines
 *
 * make_table() is based on ** Public Domain ** source "AR001.ZIP".
 */

#include <memory.h>
#pragma intrinsic(memset)

#include "decoder.h"


/*
 * Make a decoding table for decoding nchar possible Huffman elements
 * with bit lengths given by bitlen.
 *
 * Output the main lookup table into table[] and use leftright[] for
 * supplementary information (for bitlengths > tablebits).
 *
 * The size of table[] is tablebits elements.
 */
#ifndef ASM_MAKE_TABLE
bool NEAR __cdecl make_table(
                            t_decoder_context *context,
                            int               nchar,
                            const byte        *bitlen,
                            byte              tablebits,
                            short             *table,
                            short             *leftright
                            )
{
    uint    i;
    int     ch;
    short * p;
    uint    count[17], weight[17], start[18];
    int     avail;
    uint    nextcode;
    uint    k;
    byte    len;
    byte    jutbits;

    for ( i = 1; i <= 16; i++ )
        count[i] = 0;

    /* count the number of elements of each bit length */
    for ( i = 0; i < (uint) nchar; i++ )
        count[bitlen[i]]++;

    start[1] = 0;

    for ( i = 1; i <= 16; i++ )
        start[i + 1] = start[i] + (count[i] << (16 - i));

#ifdef BIT16
    if ( start[17] )
    {
        return false; /* bad table */
    }
#else
    if ( start[17] != 65536 )
    {
        if ( start[17] == 0 )
        {
            /*
             * All elements are length zero
             */
            memset(table, 0, sizeof(ushort)*(1 << tablebits));
            return true; /* success */
        }
        else
        {
            return false; /* bad table */
        }
    }
#endif

    jutbits = 16 - tablebits;

    for ( i = 1; i <= tablebits; i++ )
    {
        start[i] >>= jutbits;
        weight[i] = 1 << (tablebits - i);
    }

    while ( i <= 16 )
    {
        weight[i] = 1 << (16 - i);
        i++;
    }

    i = start[tablebits+1] >> jutbits;

#ifdef BIT16
    if ( i )
#else
    if ( i != 65536 )
#endif
    {
        memset(
              &table[i],
              0,
              sizeof(ushort)*((1 << tablebits)-i)
              );
    }

    avail = nchar;

    for ( ch = 0; ch < nchar; ch++ )
    {
        if ( (len = bitlen[ch]) == 0 )
            continue;

        nextcode = start[len] + weight[len];

        if ( len <= tablebits )
        {
            if ( nextcode > (uint) (1 << tablebits) )
                return false; /* bad table */

            for ( i = start[len]; i < nextcode; i++ )
                table[i] = (short) ch;

            start[len] = nextcode;
        }
        else
        {
            byte i;

            k = start[len];
            start[len] = nextcode;
            p = &table[k >> jutbits];

            i = len - tablebits;
            k <<= tablebits;

            do
            {
                if ( *p == 0 )
                {
                    leftright[avail*2] = leftright[avail*2+1] = 0;
                    *p = (short) -avail;
                    avail++;
                }

                if ( (signed short) k < 0 ) // if (k & 32768)
                    p = &leftright[-(*p)*2+1];
                else
                    p = &leftright[-(*p)*2];

                k <<= 1;
                i--;
            } while ( i );

            *p = (short) ch;
        }
    }

    return true;
}
#endif


/*
 * Specialised make table routine where it is known that there are
 * only 8 elements (nchar=8) and tablebits=7 (128 byte lookup table).
 *
 * Since there can be no overflow, this will be a direct lookup.
 *
 * Important difference; the lookup table returns a byte, not a ushort.
 */
bool NEAR make_table_8bit(t_decoder_context *context, byte bitlen[], byte table[])
{
    ushort count[17], weight[17], start[18];
    ushort i;
    ushort nextcode;
    byte   len;
    byte   ch;

    for ( i = 1; i <= 16; i++ )
        count[i] = 0;

    for ( i = 0; i < 8; i++ )
        count[bitlen[i]]++;

    start[1] = 0;

    for ( i = 1; i <= 16; i++ )
        start[i + 1] = start[i] + (count[i] << (16 - i));

    if ( start[17] != 0 )
        return false; /* bad table */

    for ( i = 1; i <= 7; i++ )
    {
        start[i] >>= 9;
        weight[i]  = 1 << (7 - i);
    }

    while ( i <= 16 )
    {
        weight[i] = 1 << (16 - i);
        i++;
    }

    memset(table, 0, 1<<7);

    for ( ch = 0; ch < 8; ch++ )
    {
        if ( (len = bitlen[ch]) == 0 )
            continue;

        nextcode = start[len] + weight[len];

        if ( nextcode > (1 << 7) )
            return false; /* bad table */

        for ( i = start[len]; i < nextcode; i++ )
            table[i] = ch;

        start[len] = nextcode;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\bsearch.c ===
/*
 * bsearch.c
 *
 * Binary search for optimal encoder
 */
#include "encoder.h"


#define left    context->enc_Left
#define right   context->enc_Right


/*
 * Define this to force checking that all search locations visited
 * are valid.
 *
 * For debugging purposes only.
 */
#if defined( _DEBUG ) || defined( DEBUG )
    #define VERIFY_SEARCHES
#endif

#ifdef VERIFY_SEARCHES

    #define VERIFY_SEARCH_CODE(routine_name) \
    { \
            int debug_search; \
            for (debug_search = 0; debug_search < clen; debug_search++) \
            { \
                _ASSERTE( context->enc_MemWindow[ptr+debug_search] == context->enc_MemWindow[BufPos+debug_search]); \
                _ASSERTE( left[ptr+debug_search] < ptr+debug_search ); \
                _ASSERTE( right[ptr+debug_search] < ptr+debug_search ); \
            } \
    }


    #define VERIFY_MULTI_TREE_SEARCH_CODE(routine_name) \
    _ASSERTE (context->enc_MemWindow[BufPos] == context->enc_MemWindow[ptr]); \
    _ASSERTE (context->enc_MemWindow[BufPos+1] == context->enc_MemWindow[ptr+1]);


    #define VERIFY_BUFPOS(bp) \
            { \
                _ASSERTE((bp) > context->enc_last_bsearch_bufpos );     \
                context->enc_last_bsearch_bufpos = (bp);                \
            }

    #define BACKUP_BUFPOS(bp) \
            { \
                _ASSERTE((bp) >= context->enc_last_bsearch_bufpos );    \
                if ((bp) == context->enc_last_bsearch_bufpos )          \
                {                                                       \
                    context->enc_last_bsearch_bufpos = (bp) - 1;        \
                }                                                       \
            }

#endif

/*
 * Finds the closest matches of all possible lengths, MIN_MATCH <= x <= MAX_MATCH,
 * at position BufPos.
 *
 * The positions of each match location are stored in context->enc_matchpos_table[]
 *
 * Returns the longest such match length found, or zero if no matches found.
 */

#ifndef ASM_BSEARCH_FINDMATCH
long binary_search_findmatch(t_encoder_context *context, ulong BufPos)
{
    ulong       ptr;
    ulong       a, b;
    ulong       *small_ptr, *big_ptr;
    ulong       end_pos;
    int         val; /* must be signed */
    int         clen;
    int         same;
    int         match_length;
    int         small_len, big_len;
    int         i, best_repeated_offset;
    #ifdef MULTIPLE_SEARCH_TREES
    ushort      tree_to_use;

#ifdef VERIFY_SEARCHES
    VERIFY_BUFPOS( BufPos );
#endif

    /*
     * Retrieve root node of tree to search, and insert current node at
     * the root.
     */
    tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);

    ptr        = context->enc_tree_root[tree_to_use];
    context->enc_tree_root[tree_to_use] = BufPos;
    #else
    ptr = context->enc_single_tree_root;
    context->enc_single_tree_root = BufPos;
    #endif
    /*
     * end_pos is the furthest location back we will search for matches
     *
     * Remember that our window size is reduced by 3 bytes because of
     * our repeated offset codes.
     *
     * Since BufPos starts at context->enc_window_size when compression begins,
     * end_pos will never become negative.
     */
    end_pos = BufPos - (context->enc_window_size-4);

    /*
     * Root node is either NULL, or points to a really distant position.
     */
    if (ptr <= end_pos)
        {
        left[BufPos] = right[BufPos] = 0;
        return 0;
        }

//    fprintf( stderr, "F:%08X\n", BufPos );

    _ASSERTE( ptr < BufPos );
    _ASSERTE( left[BufPos]  < BufPos );
    _ASSERTE( right[BufPos] < BufPos );

    #ifdef MULTIPLE_SEARCH_TREES
    /*
     * confirmed length (no need to check the first clen chars in a search)
     *
     * note: clen is always equal to min(small_len, big_len)
     */
    clen            = 2;

    /*
     * current best match length
     */
    match_length    = 2;

    /*
     * longest match which is < our string
     */
    small_len       = 2;

    /*
     * longest match which is > our string
     */
    big_len         = 2;

    /*
     * record match position for match length 2
     */
    context->enc_matchpos_table[2] = BufPos - ptr + 2;

#ifdef VERIFY_SEARCHES
    VERIFY_MULTI_TREE_SEARCH_CODE("binary_search_findmatch()");
#endif

    #else /* !MULTIPLE_SEARCH_TREES */

    clen            = 0;
    match_length    = 0;
    small_len       = 0;
    big_len         = 0;

    #endif /* MULTIPLE_SEARCH_TREES */

    /*
     * pointers to nodes to check
     */

    small_ptr             = &left[BufPos];
    big_ptr               = &right[BufPos];

    do
        {
        /* compare bytes at current node */
        same = clen;

    #ifdef VERIFY_SEARCHES
        VERIFY_SEARCH_CODE("binary_search_findmatch()")
    #endif

        _ASSERTE( left[ptr] < ptr );
        _ASSERTE( right[ptr] < ptr );

        /* don't need to check first clen characters */
        a    = ptr + clen;
        b    = BufPos + clen;

        while ((val = ((int) context->enc_MemWindow[a++]) - ((int) context->enc_MemWindow[b++])) == 0)
            {
            /* don't exceed MAX_MATCH */
            if (++same >= MAX_MATCH)
                goto long_match;
            }

        if (val < 0)
            {
            if (same > big_len)
                {
                if (same > match_length)
                    {
                    long_match:
                    do
                        {
                        context->enc_matchpos_table[++match_length] = BufPos-ptr+(NUM_REPEATED_OFFSETS-1);
                        } while (match_length < same);

                    if (same >= BREAK_LENGTH)
                        {
                        *small_ptr = left[ptr];
                        *big_ptr   = right[ptr];
                        goto end_bsearch;
                        }
                    }

                big_len = same;
                clen = min(small_len, big_len);
                }

            *big_ptr = ptr;

            _ASSERTE( left[ptr] < ptr );
            _ASSERTE( right[ptr] < ptr );

            big_ptr  = &left[ptr];
            ptr      = *big_ptr;
            }
        else
            {
            if (same > small_len)
                {
                if (same > match_length)
                    {
                    do
                        {
                        context->enc_matchpos_table[++match_length] = BufPos-ptr+(NUM_REPEATED_OFFSETS-1);
                        } while (match_length < same);

                    if (same >= BREAK_LENGTH)
                        {
                        *small_ptr = left[ptr];
                        *big_ptr   = right[ptr];
                        goto end_bsearch;
                        }
                    }

                small_len = same;
                clen = min(small_len, big_len);
                }

            *small_ptr = ptr;

            _ASSERTE( left[ptr] < ptr );
            _ASSERTE( right[ptr] < ptr );

            small_ptr  = &right[ptr];
            ptr        = *small_ptr;
            }
        } while (ptr > end_pos); /* while we don't go too far backwards */

    *small_ptr = 0;
    *big_ptr   = 0;


    end_bsearch:

    /*
     * If we have multiple search trees, we are already guaranteed
     * a minimum match length of 2 when we reach here.
     *
     * If we only have one tree, then we're not guaranteed anything.
     */
    #ifndef MULTIPLE_SEARCH_TREES
    if (match_length < MIN_MATCH)
        return 0;
    #endif

    /*
     * Check to see if any of our match lengths can
     * use repeated offsets.
     */

    /*
     * repeated offset 1
     */
    for (i = 0; i < match_length; i++)
        {
        if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[0]+i])
            break;
        }

    /*
     * the longest repeated offset
     */
    best_repeated_offset = i;

    if (i >= MIN_MATCH)
        {
        /*
         * Yes, we can do a repeated offset for some match lengths; replace
         * their positions with the repeated offset position
         */
        do
            {
            context->enc_matchpos_table[i] = 0; /* first repeated offset position */
            } while (--i >= MIN_MATCH);

        /* A speed optimization to cope with long runs of bytes */
        if (best_repeated_offset > BREAK_LENGTH)
            goto quick_return;
        }

    /*
     * repeated offset 2
     */
    for (i = 0; i < match_length; i++)
        {
        if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[1]+i])
            break;
        }

    /*
     * Does the second repeated offset provide a longer match?
     *
     * If so, leave the first repeated offset alone, but fill out the
     * difference in match lengths in the table with repeated offset 1.
     */
    if (i > best_repeated_offset)
        {
        do
            {
            context->enc_matchpos_table[++best_repeated_offset] = 1;
            } while (best_repeated_offset < i);
        }

    /*
     * repeated offset 3
     */
    for (i = 0; i < match_length; i++)
        {
        if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[2]+i])
            break;
        }

    /*
     * Does the third repeated offset provide a longer match?
     */
    if (i > best_repeated_offset)
        {
        do
            {
            context->enc_matchpos_table[++best_repeated_offset] = 2;
            } while (best_repeated_offset < i);
        }

    quick_return:

    return (long) match_length;
}
#endif


/*
 * Inserts the string at the current BufPos into the tree.
 *
 * Does not record all the best match lengths or otherwise attempt
 * to search for matches
 *
 * Similar to the above function.
 */
#ifndef ASM_QUICK_INSERT_BSEARCH_FINDMATCH
void quick_insert_bsearch_findmatch(t_encoder_context *context, ulong BufPos, ulong end_pos)
{
    ulong       ptr;
    ulong       a,b;
    ulong       *small_ptr, *big_ptr;
    int         val;
    int         small_len, big_len;
    int         same;
    int         clen;
    #ifdef MULTIPLE_SEARCH_TREES
    ushort      tree_to_use;

#ifdef VERIFY_SEARCHES
    VERIFY_BUFPOS( BufPos );
#endif

    tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);
    ptr        = context->enc_tree_root[tree_to_use];
    context->enc_tree_root[tree_to_use] = BufPos;
    #else
    ptr = context->enc_single_tree_root;
    context->enc_single_tree_root = BufPos;
    #endif

    if (ptr <= end_pos)
        {
        left[BufPos] = right[BufPos] = 0;
        return;
        }

//    fprintf( stderr, "I:%08X\n", BufPos );

    _ASSERTE( ptr < BufPos );
    _ASSERTE( left[BufPos]  < BufPos );
    _ASSERTE( right[BufPos] < BufPos );

    #ifdef MULTIPLE_SEARCH_TREES
    clen            = 2;
    small_len       = 2;
    big_len         = 2;

        #ifdef VERIFY_SEARCHES
    VERIFY_MULTI_TREE_SEARCH_CODE("quick_insert_bsearch_findmatch()");
        #endif

    #else
    clen            = 0;
    small_len       = 0;
    big_len         = 0;
    #endif

    small_ptr       = &left[BufPos];
    big_ptr         = &right[BufPos];

    do
        {
        _ASSERTE ((ulong) ptr >= (ulong) (context->enc_RealLeft - context->enc_Left));

        _ASSERTE( left[ptr] < ptr );
        _ASSERTE( right[ptr] < ptr );

        same = clen;

        a    = ptr+clen;
        b    = BufPos+clen;

    #ifdef VERIFY_SEARCHES
        VERIFY_SEARCH_CODE("quick_insert_bsearch_findmatch()")
    #endif

        while ((val = ((int) context->enc_MemWindow[a++]) - ((int) context->enc_MemWindow[b++])) == 0)
            {
            /*
             * Here we break on BREAK_LENGTH, not MAX_MATCH
             */
            if (++same >= BREAK_LENGTH)
                break;
            }

        if (val < 0)
            {
            if (same > big_len)
                {
                if (same >= BREAK_LENGTH)
                    {
                    *small_ptr = left[ptr];
                    *big_ptr = right[ptr];

                    _ASSERTE( left[ptr] < ptr );
                    _ASSERTE( right[ptr] < ptr );

                    return;
                    }

                big_len = same;
                clen = min(small_len, big_len);
                }

            *big_ptr = ptr;

            _ASSERTE( left[ptr] < ptr );
            _ASSERTE( right[ptr] < ptr );

            big_ptr  = &left[ptr];
            ptr      = *big_ptr;
            }
        else
            {
            if (same > small_len)
                {
                if (same >= BREAK_LENGTH)
                    {
                    *small_ptr = left[ptr];
                    *big_ptr = right[ptr];

                    _ASSERTE( left[ptr] < ptr );
                    _ASSERTE( right[ptr] < ptr );

                    return;
                    }

                small_len = same;
                clen = min(small_len, big_len);
                }

            *small_ptr = ptr;

            _ASSERTE( left[ptr] < ptr );
            _ASSERTE( right[ptr] < ptr );

            small_ptr  = &right[ptr];
            ptr        = *small_ptr;
            }
        } while (ptr > end_pos);

    *small_ptr = 0;
    *big_ptr   = 0;
}
#endif


/*
 * Remove a node from the search tree; this is ONLY done for the last
 * BREAK_LENGTH symbols (see optenc.c).  This is because we will have
 * inserted strings that contain undefined data (e.g. we're at the 4th
 * last byte from the file and binary_search_findmatch() a string into
 * the tree - everything from the 4th symbol onwards is invalid, and
 * would cause problems if it remained in the tree, so we have to
 * remove it).
 */
void binary_search_remove_node(t_encoder_context *context, ulong BufPos, ulong end_pos)
{
    ulong   ptr;
    ulong   left_node_pos;
    ulong   right_node_pos;
    ulong   *link;
#ifdef MULTIPLE_SEARCH_TREES
    ushort  tree_to_use;

#ifdef VERIFY_SEARCHES
    BACKUP_BUFPOS( BufPos );
#endif

//    fprintf( stderr, "D:%08X\n", BufPos );

    /*
     * The root node of tree_to_use should equal BufPos, since that is
     * the most recent insertion into that tree - but if we never
     * inserted this string (because it was a near match or a long
     * string of zeroes), then we can't remove it.
     */
    tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);


    /*
     * If we never inserted this string, do not attempt to remove it
     */

    if (context->enc_tree_root[tree_to_use] != (ulong) BufPos)
        return;

    link = &context->enc_tree_root[tree_to_use];
#else
    if (context->enc_single_tree_root != (ulong) BufPos)
        return;

    link = &context->enc_single_tree_root;
#endif

    /*
     * If the last occurence was too far away
     */
    if (*link <= end_pos)
        {
        *link = 0;
        left[BufPos] = right[BufPos] = 0;
        return;
        }

    /*
     * Most recent location of these chars
     */
    ptr             = BufPos;

    /*
     * Most recent location of a string which is "less than" it
     */
    left_node_pos   = left[ptr];

    if (left_node_pos <= end_pos)
        left_node_pos = left[ptr] = 0;

    /*
     * Most recent location of a string which is "greater than" it
     */
    right_node_pos  = right[ptr];

    if (right_node_pos <= end_pos)
        right_node_pos = right[ptr] = 0;

    while (1)
        {
#ifdef VERIFY_SEARCHES
        _ASSERTE (left_node_pos < (ulong) BufPos);
        _ASSERTE (right_node_pos < (ulong) BufPos);
#endif

        /*
         * If left node position is greater than right node position
         * then follow the left node, since that is the more recent
         * insertion into the tree.  Otherwise follow the right node.
         */
        if (left_node_pos > right_node_pos)
            {
            /*
             * If it's too far away, then store that it never happened
             */
            if (left_node_pos <= end_pos)
                left_node_pos = 0;

            ptr = *link = left_node_pos;

            if (!ptr)
                break;

            left_node_pos   = right[ptr];
            link            = &right[ptr];
            }
        else
            {
            /*
             * If it's too far away, then store that it never happened
             */
            if (right_node_pos <= end_pos)
                right_node_pos = 0;

            ptr = *link = right_node_pos;

            if (!ptr)
                break;

            right_node_pos  = left[ptr];
            link            = &left[ptr];
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\block.c ===
/*
 * block.c
 *
 * LZX block outputting
 */

#include "encoder.h"


/*
 * Internal function definitions
 */
static void do_block_output(
                           t_encoder_context *context,
                           long literal_to_end_at,
                           long distance_to_end_at
                           );


static void do_block_output(
                           t_encoder_context *context,
                           long literal_to_end_at,
                           long distance_to_end_at
                           )
{
    ulong                   bytes_compressed;
    lzx_block_type  block_type;
    ulong                   estimated_block_size;

    /*
     * Calculate frequencies for all tree elements.
     *
     * How many uncompressed bytes does this account for?
     */
    bytes_compressed = get_block_stats(
                                      context,
                                      0,
                                      0,
                                      literal_to_end_at
                                      );

    /*
     * Determine whether we wish to output a verbatim block or an
     * aligned offset block
     */
    block_type = get_aligned_stats(context, distance_to_end_at);

    /*
     * Create trees from the frequency data
     */
    create_trees(context, true); /* we want to generate the codes too */

    /*
     * Determine whether the block should be output as uncompressed
     */
    estimated_block_size = estimate_compressed_block_size(context);

    if (estimated_block_size >= bytes_compressed)
        {
        if (context->enc_bufpos_at_last_block >= context->enc_earliest_window_data_remaining)
            block_type = BLOCKTYPE_UNCOMPRESSED;
        }

    output_bits(context, 3, (byte) block_type);

    /* output 24 bit number, number of bytes compressed here */
    output_bits(context, 8,  (bytes_compressed >> 16) & 255);
    output_bits(context, 8,  ((bytes_compressed >> 8) & 255));
    output_bits(context, 8,  (bytes_compressed & 255));

    if (block_type == BLOCKTYPE_VERBATIM)
        {
        encode_trees(context);
        encode_verbatim_block(context, literal_to_end_at);
        get_final_repeated_offset_states(context, distance_to_end_at);
        }
    else if (block_type == BLOCKTYPE_ALIGNED)
        {
        encode_aligned_tree(context);
        encode_trees(context);
        encode_aligned_block(context, literal_to_end_at);
        get_final_repeated_offset_states(context, distance_to_end_at);
        }
    else if (block_type == BLOCKTYPE_UNCOMPRESSED)
        {
        get_final_repeated_offset_states(context, distance_to_end_at);
        encode_uncompressed_block(context, context->enc_bufpos_at_last_block, bytes_compressed);
        }

    context->enc_bufpos_at_last_block += bytes_compressed;
}


/*
 * Returns the number of distances which correspond
 * to this number of literals
 */
ulong get_distances_from_literals(t_encoder_context *context, ulong literals)
{
    ulong   d = 0;
    ulong   i;

    for (i = 0; i < (literals >> 3); i++)
        d += context->enc_ones[ context->enc_ItemType[i] ];

    /*
     * Handle remaining 0...7
     */
    for (i = (literals & (~7)); i < literals; i++)
        {
        if (IsMatch(i))
            d++;
        }

    return d;
}


/*
 * Output a block
 *
 * If trees_only is true, then only the tree statistics are updated.
 */
void output_block(t_encoder_context *context)
{
    ulong   where_to_split;
    ulong   distances;

    //
    // We have now output a block.
    //
    // We set this here in case someone calls LCIFlushOutput, so that
    // we don't try to redo the first chunk of bytes in the file
    // (since we've been forced to output them)
    //
    context->enc_first_block = 0;

    split_block(
               context,
               0,
               context->enc_literals,
               context->enc_distances,
               &where_to_split,
               &distances /* distances @ literal == where_to_split */
               );

    do_block_output(context, where_to_split, distances);

    if (where_to_split == context->enc_literals)
        {
        /*
         * If we've output ALL of our literals, then clear the itemtype array
         */
        memset(context->enc_ItemType, 0, MAX_LITERAL_ITEMS/8);

        context->enc_literals   = 0;
        context->enc_distances  = 0;
        }
    else
        {
        /*
         * If we didn't output all of our literals, then move the literals
         * and distances we didn't use, to the beginning of the list
         */
        memcpy(
              &context->enc_ItemType[0],
              &context->enc_ItemType[where_to_split/8],
              &context->enc_ItemType[1+(context->enc_literals/8)] - &context->enc_ItemType[where_to_split/8]
              );

        memset(
              &context->enc_ItemType[1+(context->enc_literals-where_to_split)/8],
              0,
              &context->enc_ItemType[MAX_LITERAL_ITEMS/8] - &context->enc_ItemType[1+(context->enc_literals-where_to_split)/8]
              );

        memcpy(
              &context->enc_LitData[0],
              &context->enc_LitData[where_to_split],
              sizeof( context->enc_LitData[0] ) * ( context->enc_literals-where_to_split )
              );

#ifdef EXTRALONGMATCHES

        memcpy(
              &context->enc_ExtraLength[0],
              &context->enc_ExtraLength[where_to_split],
              sizeof( context->enc_ExtraLength[0] ) * ( context->enc_literals-where_to_split )
              );

#endif

        memcpy(
              &context->enc_DistData[0],
              &context->enc_DistData[distances],
              sizeof(ulong)*(context->enc_distances-distances)
              );

        context->enc_literals  -= where_to_split;
        context->enc_distances -= distances;
        }

    fix_tree_cost_estimates(context);
}


void flush_output_bit_buffer(t_encoder_context *context)
{
    byte temp;

    if (context->enc_bitcount < 32)
        {
        temp = context->enc_bitcount-16;

        output_bits(context, temp, 0);
        }
}


/*
 * Estimate how much it would take to output the compressed
 * data left in the buffer
 */
long estimate_buffer_contents(t_encoder_context *context)
{
    long                    estimated_block_size;

    /*
     * Use frequency data sitting around from last tree creation
     */
    create_trees(context, false); /* don't generate codes */

    estimated_block_size = estimate_compressed_block_size(context);

    /* so the optimal parser doesn't get confused */
    fix_tree_cost_estimates(context);

    return estimated_block_size;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\encdata.c ===
/*
 * encdata.c
 *
 * Encode a block into the output stream
 */

#include "encoder.h"

/*
 * Macro to output bits into the encoding stream
 */

#define OUTPUT_BITS(N,X) output_bits( context, (N), (X))

void output_bits( t_encoder_context *context, ulong numbits, ulong value ) {

    context->enc_bitbuf   |= ( value << ( context->enc_bitcount - numbits ));
    context->enc_bitcount -= (char)numbits;

    while ( context->enc_bitcount <= 16 ) {

        if ( context->enc_output_buffer_curpos >= context->enc_output_buffer_end ) {
             context->enc_output_buffer_curpos = context->enc_output_buffer_start;
             context->enc_output_overflow = true;
             }

        *context->enc_output_buffer_curpos++ = (byte)( context->enc_bitbuf >> 16 );
        *context->enc_output_buffer_curpos++ = (byte)( context->enc_bitbuf >> 24 );

        context->enc_bitbuf  <<= 16;
        context->enc_bitcount += 16;
        }
    }


#ifdef EXTRALONGMATCHES

#define OUTPUT_EXTRA_LENGTH(X) output_extra_length( context, (X))

void output_extra_length( t_encoder_context *context, ulong ExtraLength ) {

    //
    //  Extra match length is encoded like this:
    //
    //      0xxxxxxxx          (8-bit value)
    //      10xxxxxxxxxx       (10-bit value plus 2^8)
    //      110xxxxxxxxxxxx    (12-bit value plus 2^8 plus 2^10)
    //      111xxxxxxxxxxxxxxx (15-bit value)
    //
    //  15 bits is the largest possible because a match cannot
    //  span a 32K boundary.
    //

    ulong EncodingValue = ExtraLength;

    ASSERT( ExtraLength < 32768 );

    if ( EncodingValue < ( 1 << 8 )) {
        OUTPUT_BITS( 9, EncodingValue );
        }
    else {

        EncodingValue -= ( 1 << 8 );

        if ( EncodingValue < ( 1 << 10 )) {
            OUTPUT_BITS( 12, (( 1 << 11 ) | EncodingValue ));
            }

        else {

            EncodingValue -= ( 1 << 10 );

            if ( EncodingValue < ( 1 << 12 )) {
                OUTPUT_BITS( 15, (( 1 << 14 ) | ( 1 << 13 ) | EncodingValue ));
                }

            else {
                OUTPUT_BITS( 3, 7 );    // can't OUTPUT_BITS more than 16 per call
                OUTPUT_BITS( 15, ExtraLength );
                }
            }
        }
    }

#endif /* EXTRALONGMATCHES */


/*
 * Given the initial state of the repeated offset buffers at
 * the beginning of this block, calculate the final state of the
 * repeated offset buffers after outputting this block as if it
 * were compressed data.
 *
 * First try to do it the quick way, by starting at the last
 * match and working backwards, to find three consecutive matches
 * which don't use repeated offsets.  If this fails, we'll have
 * to take the initial state of the three offsets at the beginning
 * of the block, and evolve them to the end of the block.
 */
void get_final_repeated_offset_states(t_encoder_context *context, ulong distances)
{
    ulong                   MatchPos;
    signed long             d; /* must be signed */
    byte                    consecutive;

    consecutive = 0;

    for (d = distances-1; d >= 0; d--)
        {
        if (context->enc_DistData[d] > 2)
            {
            /* NOT a repeated offset */
            consecutive++;

            /* do we have three consecutive non-repeated-offsets? */
            if (consecutive >= 3)
                break;
            }
        else
            {
            consecutive = 0;
            }
        }

    /*
     * If we didn't find three consecutive matches which
     * don't use repeated offsets, then we have to start
     * from the beginning and evolve the repeated offsets.
     *
     * Otherwise, we start at the first of the consecutive
     * matches.
     */
    if (consecutive < 3)
        {
        d = 0;
        }

    for (; d < (signed long) distances; d++)
        {
        MatchPos = context->enc_DistData[d];

        if (MatchPos == 0)
            {
            }
        else if (MatchPos <= 2)
            {
            ulong   temp;

            temp = context->enc_repeated_offset_at_literal_zero[MatchPos];
            context->enc_repeated_offset_at_literal_zero[MatchPos] = context->enc_repeated_offset_at_literal_zero[0];
            context->enc_repeated_offset_at_literal_zero[0] = temp;
            }
        else
            {
            context->enc_repeated_offset_at_literal_zero[2] = context->enc_repeated_offset_at_literal_zero[1];
            context->enc_repeated_offset_at_literal_zero[1] = context->enc_repeated_offset_at_literal_zero[0];
            context->enc_repeated_offset_at_literal_zero[0] = MatchPos-2;
            }
        }
}


/*
 * Encode a block with no compression
 *
 * bufpos is the position in the file from which the first
 * literal in this block starts.  To reference memory, we will
 * use enc_MemWindow[bufpos] (remember that enc_MemWindow is
 * moved backwards every time we copymem).
 *
 * Since this data was originally matched into the compressor,
 * our recent match offsets will have been changed; however,
 * since this is an uncompressed block, the decoder won't be
 * updating them.  Therefore, we need to tell the decoder
 * the state of the match offsets after it has finished
 * decoding the uncompressed data - we store these in this
 * block.
 */
void encode_uncompressed_block(t_encoder_context *context, ulong bufpos, ulong block_size)
{
    int     i;
    int     j;
    bool    block_size_odd;
    ulong   val;

    /*
     * Align on a byte boundary
     */
    output_bits(context, context->enc_bitcount-16, 0);

    /*
     * Now output the contents of the repeated offset
     * buffers, since we need to preserve the state of
     * the encoder
     */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
        {
        val = context->enc_repeated_offset_at_literal_zero[i];

        for (j = 0; j < sizeof(long); j++)
            {
            *context->enc_output_buffer_curpos++ = (byte) val;
            val >>= 8;
            }
        }

    block_size_odd = block_size & 1;

    /*
     * Write out uncompressed data
     */
    while (block_size > 0)
        {
        *context->enc_output_buffer_curpos++ = context->enc_MemWindow[bufpos];

        bufpos++;
        block_size--;
        context->enc_input_running_total++;

        if (context->enc_input_running_total == CHUNK_SIZE)
            {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
            }
        }

    /*
     * Add pad byte to keep the output word-aligned
     */
    if (block_size_odd)
        {
        *context->enc_output_buffer_curpos++ = 0;
        }

    context->enc_bitcount   = 32;
    context->enc_bitbuf     = 0;
}


/*
 * Estimate the size of the data in the buffer, in bytes
 */
ulong estimate_compressed_block_size(t_encoder_context *context)
{
    ulong                   block_size = 0; /* output size in bits */
    ulong                   i;
    ulong                   mpslot;

    /* Estimation of tree size */
    block_size = 150*8;

    /* Tally bits to output characters */
    for (i = 0; i < NUM_CHARS; i++)
        block_size += (context->enc_main_tree_len[i]*context->enc_main_tree_freq[i]);

    /* Tally bits to output matches */
    for (mpslot = 0; mpslot < context->enc_num_position_slots; mpslot++)
        {
        long    element;
        int             primary;

        element = NUM_CHARS + (mpslot << NL_SHIFT);

        /* For primary == NUM_PRIMARY_LENGTHS we have secondary lengths */
        for (primary = 0; primary <= NUM_PRIMARY_LENGTHS; primary++)
            {
            block_size += ((context->enc_main_tree_len[element] + enc_extra_bits[mpslot]) *
                           context->enc_main_tree_freq[element]);
            element++;
            }
        }

    for (i = 0; i < NUM_SECONDARY_LENGTHS; i++)
        block_size += (context->enc_secondary_tree_freq[i] * context->enc_secondary_tree_len[i]);

    /* round up */
    return (block_size+7) >> 3;
}

/*
 * Encode block with NO special encoding of the lower 3
 * position bits
 */
void encode_verbatim_block(t_encoder_context *context, ulong literal_to_end_at)
{
    ulong           MatchPos;
    ulong           d = 0;
    ulong           l = 0;
    ulong           MatchLength;
    byte            c;
    ulong           mpSlot;

    for ( l = 0; l < literal_to_end_at; l++ ) {

        if (!IsMatch(l))
            {
            c = context->enc_LitData[l];
            OUTPUT_BITS(context->enc_main_tree_len[c], context->enc_main_tree_code[c]);
            context->enc_input_running_total++;
            }
        else
            {
            /* Note, 0 means MatchLen=3, 1 means MatchLen=4, ... */
            MatchLength = context->enc_LitData[l];

            /* Delta match pos */
            MatchPos = context->enc_DistData[d++];

            mpSlot = MP_SLOT(MatchPos);

            if (MatchLength < NUM_PRIMARY_LENGTHS)
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len[ NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength],
                           context->enc_main_tree_code[NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength]
                           );
                }
            else
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len [(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)],
                           context->enc_main_tree_code[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)]
                           );

                OUTPUT_BITS(
                           context->enc_secondary_tree_len[ MatchLength - NUM_PRIMARY_LENGTHS],
                           context->enc_secondary_tree_code[MatchLength - NUM_PRIMARY_LENGTHS]
                           );
                }

            if (enc_extra_bits[ mpSlot ])
                {
                OUTPUT_BITS(
                           enc_extra_bits[mpSlot],
                           MatchPos & enc_slot_mask[mpSlot]
                           );
                }

#ifdef EXTRALONGMATCHES

            if ( MatchLength == ( MAX_MATCH - MIN_MATCH )) {
                MatchLength += context->enc_ExtraLength[ l ];
                OUTPUT_EXTRA_LENGTH( context->enc_ExtraLength[ l ] );
                }
#endif

            context->enc_input_running_total += (MatchLength+MIN_MATCH);
            }

        _ASSERTE (context->enc_input_running_total <= CHUNK_SIZE);

        if (context->enc_input_running_total == CHUNK_SIZE)
            {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
            }

        _ASSERTE (context->enc_input_running_total < CHUNK_SIZE);
        }
}


/*
 * aligned block encoding
 */
void encode_aligned_block(t_encoder_context *context, ulong literal_to_end_at)
{
    ulong   MatchPos;
    ulong   MatchLength;
    byte    c;
    ulong   mpSlot;
    byte    Lower;
    ulong   l = 0;
    ulong   d = 0;

    for ( l = 0; l < literal_to_end_at; l++ ) {

        if (!IsMatch(l))
            {
            c = context->enc_LitData[l];
            OUTPUT_BITS(context->enc_main_tree_len[c], context->enc_main_tree_code[c]);
            context->enc_input_running_total++;
            }
        else
            {
            /* Note, 0 means MatchLen=3, 1 means MatchLen=4, ... */
            MatchLength = context->enc_LitData[l];

            /* Delta match pos */
            MatchPos = context->enc_DistData[d++];

            mpSlot = MP_SLOT(MatchPos);

            if (MatchLength < NUM_PRIMARY_LENGTHS)
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len[ NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength],
                           context->enc_main_tree_code[NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength]
                           );
                }
            else
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len[ (NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)],
                           context->enc_main_tree_code[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)]
                           );

                OUTPUT_BITS(
                           context->enc_secondary_tree_len[ MatchLength - NUM_PRIMARY_LENGTHS],
                           context->enc_secondary_tree_code[MatchLength - NUM_PRIMARY_LENGTHS]
                           );
                }

            if (enc_extra_bits[ mpSlot ] >= 3)
                {
                if (enc_extra_bits[ mpSlot ] > 3)
                    {
                    OUTPUT_BITS(
                               enc_extra_bits[mpSlot] - 3,
                               (MatchPos >> 3) & ( (1 << (enc_extra_bits[mpSlot]-3)) -1)
                               );
                    }

                Lower = (byte) (MatchPos & 7);

                OUTPUT_BITS(
                           context->enc_aligned_tree_len[Lower],
                           context->enc_aligned_tree_code[Lower]
                           );
                }
            else if (enc_extra_bits[ mpSlot ])
                {
                OUTPUT_BITS(
                           enc_extra_bits[mpSlot],
                           MatchPos & enc_slot_mask[ mpSlot ]
                           );
                }

#ifdef EXTRALONGMATCHES

            if ( MatchLength == ( MAX_MATCH - MIN_MATCH )) {
                MatchLength += context->enc_ExtraLength[ l ];
                OUTPUT_EXTRA_LENGTH( context->enc_ExtraLength[ l ] );
                }
#endif

            context->enc_input_running_total += (MatchLength+MIN_MATCH);
            }

        _ASSERTE (context->enc_input_running_total <= CHUNK_SIZE);

        if (context->enc_input_running_total == CHUNK_SIZE)
            {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
            }

        _ASSERTE (context->enc_input_running_total < CHUNK_SIZE);
        }
}


void perform_flush_output_callback(t_encoder_context *context)
{
    long    output_size;

    /*
     * Do this only if there is any input to account for, so we don't
     * end up outputting blocks where comp_size > 0 and uncmp_size = 0.
     */
    if (context->enc_input_running_total > 0)
        {
        flush_output_bit_buffer(context);

        output_size = context->enc_output_buffer_curpos - context->enc_output_buffer_start;

        if (output_size > 0)
            {
            (*context->enc_output_callback_function)(
                                                    context->enc_fci_data,
                                                    context->enc_output_buffer_start,
                                                    context->enc_output_buffer_curpos - context->enc_output_buffer_start,
                                                    context->enc_input_running_total
                                                    );
            }
        }

    context->enc_input_running_total = 0;
    context->enc_output_buffer_curpos = context->enc_output_buffer_start;

    /* initialise bit buffer */
    context->enc_bitcount = 32;
    context->enc_bitbuf   = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\encapi.h ===
/*
 * encapi.h
 *
 * Definitions for calling LZX apis (encapi.c)
 */

/*
 * Return codes for LZX_Encode()
 */
#define ENCODER_SUCCESS         0
#define ENCODER_READ_FAILURE    1
#define ENCODER_WRITE_FAILURE   2
#define ENCODER_CONSOLE_FAILURE 3

bool
__fastcall
LZX_EncodeInit(
    t_encoder_context **  enc_context,
    long                  compression_window_size,
    long                  second_partition_size,
    PFNALLOC              pfnma,
    HANDLE                hAllocator,
    int (__stdcall * pfnlzx_output_callback)(
        void *            pfol,
        unsigned char *   compressed_data,
        long              compressed_size,
        long              uncompressed_size
        ),
    void *                fci_data
    );

void __fastcall LZX_EncodeNewGroup(t_encoder_context *context);

long __fastcall LZX_Encode(
        t_encoder_context *     context,
        byte *                  input_data,
        long                    input_size,
        long *                  bytes_compressed,
        long                    file_size_for_translation
);

bool __fastcall LZX_EncodeFlush(t_encoder_context *context);

bool __fastcall LZX_EncodeResetState(t_encoder_context *context);

unsigned char * __fastcall LZX_GetInputData(
    t_encoder_context *context,
    unsigned long *input_position,
    unsigned long *bytes_available
);

bool __fastcall LZX_EncodeInsertDictionary(
                       t_encoder_context *context,
                       byte *             input_data,
                       unsigned long      input_size
                       );


#ifdef TRACING

#include <stdio.h>

void
__stdcall
EncTracingMatch(
    unsigned long BufPos,
    unsigned long MatchLength,
    unsigned long MatchPos,
    unsigned long MatchOff
    );

void
__stdcall
EncTracingLiteral(
    unsigned long BufPos,
    unsigned long ch
    );

void
__stdcall
EncTracingDefineOffsets(
    unsigned long WindowSize,
    unsigned long InterFileBytes,
    unsigned long OldFileSize
    );

#endif /* TRACING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\enctree.c ===
/*
 * enctree.c
 *
 * Encode trees into output data
 */

#define EXT extern
#include "encoder.h"

/*
 * Encode a tree
 */
static void WriteRepTree(
	t_encoder_context *context,
	byte    *pLen,
	byte    *pLastLen, 
	int		Num
)
{
	int			i;
	int			j;
	int			Same;
	ushort		SmallFreq[2*24];
	ushort		MiniCode[24];
	char		MiniLen[24];
	char		k;
	byte		temp_store;
    byte * z=context->enc_output_buffer_curpos;

	static const byte Modulo17Lookup[] =
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
	};

	memset(SmallFreq, 0, sizeof(SmallFreq));

	temp_store	= pLen[Num];
	pLen[Num]	= 123; 

	for (i = 0; i < Num; i++)
	{
		Same = 0;

		/* Count the number of consecutive elements which have the same length */
		/* No need to check against array boundary, because the last element has */
		/* a nonsense value */
		for (j = i+1; pLen[j] == pLen[i]; j++)
	 		Same++;

		/* If more than 3, compress this information */
		if (Same >= TREE_ENC_REP_MIN)
		{
	 		/* Special case if they're zeroes */
	 		if (!pLen[i])
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1)
	       		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1;

	    		if (Same <= TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST - 1)
	       			SmallFreq[17]++;
	    		else
	       			SmallFreq[18]++;
	 		}
		 	else
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1)
	       			Same = TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1;

				SmallFreq[ Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ] ]++;
	    		SmallFreq[19]++;
	 		}

	 		i += Same-1;
      }
      else
			SmallFreq[ Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ] ]++;
	}

	make_tree(
		context,
		20, 
		SmallFreq, 
		(byte *) MiniLen, 
		MiniCode, 
		true
	);

	/* max 10 byte output overrun */
	for (i = 0; i < 20; i++)
	{
		output_bits(context, 4, MiniLen[i]);
	}

	/* Output original tree with new code */
	for (i = 0; i < Num; i++)
	{
		Same = 0;

		/* Count the number of consecutive elements which have the same length */
		/* No need to check against array boundary, because the last element has */
		/* a nonsense value */
		for (j = i+1; pLen[j] == pLen[i]; j++)
	 		Same++;

		/* If more than 3, we can do something */
		if (Same >= TREE_ENC_REP_MIN)
		{
	 		if (!pLen[i]) /* Zeroes */
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1)
		       		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1;

	    		if (Same <= TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST - 1)
	       			k = 17;
	    		else
		       		k = 18;
	 		}
	 		else
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1)
			   		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1;

	    		k = 19;
	 		}
		}
		else
	 		k = Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ];

		output_bits(context, MiniLen[k], MiniCode[k]);

		if (k == 17)
		{
	 		output_bits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS, Same-TREE_ENC_REP_MIN);
	 		i += Same-1;
		}
		else if (k == 18)
		{
	 		output_bits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS, Same-(TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST));
	 		i += Same-1;
		}
		else if (k == 19)
		{
	 		output_bits(context, TREE_ENC_REP_SAME_EXTRA_BITS, Same-TREE_ENC_REP_MIN);

	 		k = Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ];
			output_bits(context, MiniLen[k], MiniCode[k]);

	 		i += Same-1;
		}
	}

	pLen[Num] = temp_store;

	memcpy(pLastLen, pLen, Num);
}


void create_trees(t_encoder_context *context, bool generate_codes)
{
	/*
	 * Assumption: We can trash PtrLen[NUM_CHARS+(NUM_POSITION_SLOTS*NUM_LENGTHS))], since
	 *             we allocated space for it earlier
	 */
	make_tree(
		context,
		NUM_CHARS+(context->enc_num_position_slots*(NUM_PRIMARY_LENGTHS+1)),
		context->enc_main_tree_freq, 
		context->enc_main_tree_len,  
		context->enc_main_tree_code,
		generate_codes
	);

	make_tree(
		context,
		NUM_SECONDARY_LENGTHS, 
		context->enc_secondary_tree_freq,
		context->enc_secondary_tree_len,
		context->enc_secondary_tree_code,
		generate_codes
	);

	make_tree(
		context,
		ALIGNED_NUM_ELEMENTS, 
		context->enc_aligned_tree_freq, 
		context->enc_aligned_tree_len, 
		context->enc_aligned_tree_code, 
		true
	);
}


void fix_tree_cost_estimates(t_encoder_context *context)
{
	/*
	 *  We're only creating trees for estimation purposes and we do not 
	 *  want to encode the tree.  However, the following loops will set
	 *  the frequency zero tree element lengths to values other than 
	 *  zero, so that the optimal encoder won't get confused when it
	 *  tries to estimate the number of bits it would take to output an
	 *  element.
     *
     *  We also set the bit lengths of match length 2's further away
     *  than MAX_LENGTH_TWO_OFFSET to a large number, so that the
     *  optimal parser will never select such matches.
	 */
	ulong  i;

	/* Set zero lengths to some value */
	for (i = 0; i< NUM_CHARS; i++)
	{
		if (context->enc_main_tree_len[i] == 0)
			context->enc_main_tree_len[i] = 11;
	}

	for (; i < NUM_CHARS+(context->enc_num_position_slots*(NUM_PRIMARY_LENGTHS+1)); i++)
	{
		if (context->enc_main_tree_len[i] == 0)
			context->enc_main_tree_len[i] = 12;
	}		

	for (i = 0; i < NUM_SECONDARY_LENGTHS; i++)
	{
		if (context->enc_secondary_tree_len[i] == 0)
			context->enc_secondary_tree_len[i] = 8; 
	}

    prevent_far_matches(context);
}


void prevent_far_matches(t_encoder_context *context)
{
    ulong i;

    /*
     * Set far match length 2's to a high value so they will never
     * be chosen.
     *
     * See description of MAX_GROWTH in encdefs.h
     */
    for (   i = MP_SLOT(MAX_LENGTH_TWO_OFFSET);
            i < context->enc_num_position_slots;
            i++
        )
	{
        context->enc_main_tree_len[NUM_CHARS + (i << NL_SHIFT)] = 100;
	}		
}


/*
 * Encode the trees
 *
 * Assumes trees have already been created with create_trees().
 *
 * Warning, do not call update_tree_cost_estimates() before encoding
 * the trees, since that routine trashes some of the tree elements.
 */
void encode_trees(t_encoder_context *context)
{
	WriteRepTree(
		context,
		context->enc_main_tree_len, 
		context->enc_main_tree_prev_len,
		NUM_CHARS
	);

	WriteRepTree(
		context,
		&context->enc_main_tree_len[NUM_CHARS], 
		&context->enc_main_tree_prev_len[NUM_CHARS], 
		context->enc_num_position_slots * (NUM_PRIMARY_LENGTHS+1)
	);

	WriteRepTree(
		context,
		context->enc_secondary_tree_len,
		context->enc_secondary_tree_prev_len,
		NUM_SECONDARY_LENGTHS
	);
}


void encode_aligned_tree(t_encoder_context *context)
{
	int i;

	make_tree(
		context,
		ALIGNED_NUM_ELEMENTS, 
		context->enc_aligned_tree_freq, 
		context->enc_aligned_tree_len, 
		context->enc_aligned_tree_code, 
		true
	);

	/* Output original tree with new code */
	for (i = 0; i < 8; i++)
	{
		output_bits(context, 3, context->enc_aligned_tree_len[i]);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\encdefs.h ===
/*
 * encdefs.h
 *
 * Encoder #define's and structure definitions.
 */

/*
 * NOTES:
 *
 * To maximise compression one can set both BREAK_LENGTH
 * and FAST_DECISION_THRESHOLD to 250, define
 * INSERT_NEAR_LONG_MATCHES, and crank up EXTRA_SIZE to
 * a larger value (don't get too large, otherwise we
 * might overflow our ushort cumbits[]), but the improvement
 * is really  marginal; e.g. 3600 bytes on winword.exe
 * (3.9 MB compressed).  It really hurts performance too.
 */

#ifdef MULTIPLE_SEARCH_TREES
#undef MULTIPLE_SEARCH_TREES
#endif

#define MULTIPLE_SEARCH_TREES 1     // always define this for patching

/*
 * See optenc.c
 *
 * EXTRA_SIZE is the amount of extra data we allocate in addition
 * to the window, and LOOK is the amount of data the optimal
 * parser will look ahead.  LOOK is dependent on EXTRA_SIZE.
 *
 * Changing EXTRA_SIZE to 8K doesn't really do anything for
 * compression.  4K is a fairly optimal value.
 *
 */
#define EXTRA_SIZE   16384
#define LOOK         (EXTRA_SIZE-MAX_MATCH-2)


/*
 * Number of search trees used (for storing root nodes)
 */
#define NUM_SEARCH_TREES 65536


/*
 * Chunk size required by FCI
 */
#define CHUNK_SIZE 32768


/*
 * The maximum amount of data we will allow in our output buffer before
 * calling lzx_output_callback() to get rid of it.  Since we do this
 * for every 32K of input data, the output buffer only has to be able
 * to contain 32K + some spillover, which won't be much, because we
 * output uncompressed blocks if we determine a block is going to be
 * too large.
 */
#define OUTPUT_BUFFER_SIZE (CHUNK_SIZE+MAX_GROWTH)


/*
 * Maximum allowable number of block splits per 32K of uncompressed
 * data; if increased, then MAX_GROWTH will have to be increased also.
 */
#define MAX_BLOCK_SPLITS    4


/*
 * Max growth is calculated as follows:
 *
 * TREE AND BLOCK INFO
 * ===================
 *
 * The very first time the encoder is run, it outputs a 32 bit
 * file translation size.
 *
 * 3 bits to output block type
 * 24 bits for block size in uncompressed bytes.
 *
 * Max size of a tree of n elements is 20*4 + 5*n bits
 *
 * There is a main tree of max 700 elements which is really encoded
 * as two separate trees of 256 and 444(max).  There is also a
 * secondary length tree of 249 elements.
 *
 * That is 1360 bits, plus 2300 bits, plus 1325 bits.
 *
 * There may also be an aligned offset tree, which is 24 bits.
 *
 * Flushing output bit buffer; max 16 bits.
 *
 * Grand total: 5084 bits/block.
 *
 *
 * PARSER INFO
 * ===========
 *
 * Parser worst case scenario is with 2 MB buffer (50 position slots),
 * all matches of length 2, distributed over slots 32 and 33 (since
 * matches of length 2 further away than 128K are prohibited).  These
 * slots have 15 verbatim bits.  Maximum size per code is then
 * 2 bits to say which slot (taking into account that there will be
 * at least another code in the tree) plus 15 verbatim bits, for a
 * total of 17 bits.  Max growth on 32K of input data is therefore
 * 1/16 * 32K, or 2K bytes.
 *
 * Alternatively, if there is only one match and everything else
 * is a character, then 255 characters will be length 8, and one
 * character and the match will be length 9.  Assume the true
 * frequency of the demoted character is almost a 1 in 2^7
 * probability (it got remoted from a 2^8, but it was fairly
 * close to being 2^7).  If there are 32768/256, or 128, occurrences
 * of each character, but, say, almost 256 for the demoted character,
 * then the demoted character will expand the data by less than
 * 1 bit * 256, or 256 bits.  The match will take a little to
 * output, but max growth for "all characters" is about 256 bits.
 *
 *
 * END RESULT
 * ==========
 *
 * The maximum number of blocks which can be output is limited to
 * 4 per 32K of uncompressed data.
 *
 * Therefore, max growth is 4*5084 bits, plus 2K bytes, or 4590
 * bytes.
 */
#define     MAX_GROWTH          6144

/*
 * Don't allow match length 2's which are further away than this
 * (see above)
 */
#define     MAX_LENGTH_TWO_OFFSET (128*1024)


/*
 * When we find a match which is at least this long, prematurely
 * exit the binary search.
 *
 * This avoids us inserting huge match lengths of 257 zeroes, for
 * example.  Compression will improve very *very* marginally by
 * increasing this figure, but it will seriously impact
 * performance.
 *
 * Don't make this number >= (MAX_MATCH-2); see bsearch.c.
 */
#define BREAK_LENGTH 100


/*
 * If this option is defined, the parser will insert all bytes of
 * matches with lengths >= 16 with a distance of 1; this is a bad
 * idea, since matches like that are generally zeroes, which we
 * want to avoid inserting into the search tree.
 */

//#define INSERT_NEAR_LONG_MATCHES


/*
 * If the optimal parser finds a match which is this long or
 * longer, it will take it automatically.  The compression
 * penalty is basically zero, and it helps performance.
 */
#define FAST_DECISION_THRESHOLD 100


/*
 * Every TREE_CREATE_INTERVAL items, recreate the trees from
 * the literals we've encountered so far, to update our cost
 * estimations.
 *
 * 4K seems pretty optimal.
 */
#define TREE_CREATE_INTERVAL 4096


/*
 * When we're forced to break in our parsing (we exceed
 * our span), don't output a match length 2 if it is
 * further away than this.
 *
 * Could make this a variable rather than a constant
 *
 * On a bad binary file, two chars    = 18 bits
 * On a good text file, two chars     = 12 bits
 *
 * But match length two's are very uncommon on text files.
 */
#define BREAK_MAX_LENGTH_TWO_OFFSET 2048


/*
 * When MatchPos >= MPSLOT3_CUTOFF, extra_bits[MP_SLOT(MatchPos)] >= 3
 *
 * matchpos:  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
 * extrabits: 0,0,0,0,1,1,1,1,2,2, 2, 2, 2, 2, 2, 2, 3, ...
 *
 * Used for aligned offset blocks and statistics.
 */
#define MPSLOT3_CUTOFF 16


/*
 * Number of elements in the main tree
 */
#define MAIN_TREE_ELEMENTS                      (NUM_CHARS+(((long) context->enc_num_position_slots) << NL_SHIFT))


/*
 * Max number of literals to hold.
 *
 * Memory required is MAX_LITERAL_ITEMS for enc_LitData[] array,
 * plus MAX_LITERAL_ITEMS/8 for enc_ItemType[] array.
 *
 * Must not exceed 64K, since that will cause our ushort
 * frequencies to overflow.
 */
#define MAX_LITERAL_ITEMS  65536


/*
 * Max number of distances to hold
 *
 * Memory required is MAX_DIST_ITEMS*4 for enc_DistData[] array
 *
 * MAX_DIST_ITEMS should never be greater than MAX_LITERAL_ITEMS,
 * since that just wastes space.
 *
 * However, it's extremely unlikely that one will get 65536 match
 * length 2's!  In any case, the literal and distance buffers
 * are checked independently, and a block is output if either
 * overflows.
 *
 * Bitmaps are highly redundant, though; lots of matches.
 */
#define MAX_DIST_ITEMS     32768
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\encapi.c ===
/*
 * encapi.c
 *
 * Encoder API entrypoints.
 */

#define ALLOC_VARS
#include "encoder.h"


bool
__fastcall
LZX_EncodeInit(
    t_encoder_context **  enc_context,
    long                  compression_window_size,
    long                  second_partition_size,
    PFNALLOC              pfnma,
    HANDLE                hAllocator,
    int (__stdcall * pfnlzx_output_callback)(
        void *            pfol,
        unsigned char *   compressed_data,
        long              compressed_size,
        long              uncompressed_size
        ),
    void *                fci_data
    )
{

    t_encoder_context *context = pfnma( hAllocator, sizeof( t_encoder_context ));

    if ( context == NULL ) {
        return false;
        }

    *enc_context = context;

    /* to pass back in lzx_output_callback() */
    context->enc_fci_data = fci_data;

    context->enc_window_size = compression_window_size;

    /*
     * The second partition size must be a multiple of 32K
     */
    if (second_partition_size & (CHUNK_SIZE-1))
        second_partition_size &= (~(CHUNK_SIZE-1));

    /*
     * The minimum allowed is 32K because of the way that
     * our translation works.
     */
    if (second_partition_size < CHUNK_SIZE)
        second_partition_size = CHUNK_SIZE;

    /*
     * Our window size must be at least 32K
     */
    if (compression_window_size < CHUNK_SIZE)
        return false;

    context->enc_encoder_second_partition_size = second_partition_size;
    context->enc_output_callback_function = pfnlzx_output_callback;

    context->enc_malloc       = pfnma;
    context->enc_mallochandle = hAllocator;

    /* Error allocating memory? */
    if (comp_alloc_compress_memory(context) == false)
        return false;

    LZX_EncodeNewGroup(context);

    return true;
}


/*
 * Sets up the encoder for a new group of files.
 *
 * All this does is reset the lookup table, re-initialise to the
 * default match estimation tables for the optimal parser, and
 * reset a few variables.
 */
void __fastcall LZX_EncodeNewGroup(t_encoder_context *context)
{
    init_compression_memory(context);
}


long __fastcall LZX_Encode(
               t_encoder_context *context,
               byte *             input_data,
               long               input_size,
               long *             estimated_bytes_compressed,
               long               file_size_for_translation
               )
{
    context->enc_input_ptr  = input_data;
    context->enc_input_left = input_size;

    context->enc_file_size_for_translation = file_size_for_translation;

    /* perform the encoding */
    encoder_start(context);

    if (context->enc_output_overflow)
        {
        *estimated_bytes_compressed = 0;
        return ENCODER_WRITE_FAILURE;
        }

    *estimated_bytes_compressed = estimate_buffer_contents(context);

    return ENCODER_SUCCESS;
}


bool __fastcall LZX_EncodeFlush(t_encoder_context *context)
{
    flush_all_pending_blocks(context);

    if (context->enc_output_overflow)
        return false;

    return true;
}


//
// But doesn't remove history data
//
bool __fastcall LZX_EncodeResetState(t_encoder_context *context)
{
    /*
     * Most of this copied from init.c
     */

    /*
     * Clear item array and reset literal and distance
     * counters
     */
    memset(context->enc_ItemType, 0, (MAX_LITERAL_ITEMS/8));

    context->enc_literals      = 0;
    context->enc_distances     = 0;

    /*
     * Reset encoder state
     */
    context->enc_last_matchpos_offset[0] = 1;
    context->enc_last_matchpos_offset[1] = 1;
    context->enc_last_matchpos_offset[2] = 1;

    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    context->enc_input_running_total = 0;

    /*
     * The last lengths are zeroed in both the encoder and decoder,
     * since our tree representation is delta format.
     */
    memset(context->enc_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);
    memset(context->enc_secondary_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);

    /* reset bit buffer */
    context->enc_bitcount = 32;
    context->enc_bitbuf   = 0;
    context->enc_output_overflow = false;

    /* need to recalculate stats soon */
    context->enc_need_to_recalc_stats = true;
    context->enc_next_tree_create = TREE_CREATE_INTERVAL;

    /* pretend we just output everything up to now as a block */
    context->enc_bufpos_last_output_block = context->enc_BufPos;

    /* don't allow re-doing */
    context->enc_first_block = false;

    /* reset instruction pointer (for translation) to zero */
    reset_translation(context);

    /* so we output the file xlat header */
    context->enc_first_time_this_group = true;

    /* reset frame counter */
    context->enc_num_cfdata_frames = 0;

    /* haven't split the block */
    context->enc_num_block_splits = 0;

    return true;
}


unsigned char * __fastcall LZX_GetInputData(
                               t_encoder_context *context,
                               unsigned long *input_position,
                               unsigned long *bytes_available
                               )
{
    unsigned long filepos;

    // note that BufPos-window_size is the real position in the file
    filepos = context->enc_BufPos - context->enc_window_size;

    if (filepos < context->enc_window_size)
        {
        *input_position = 0;
        *bytes_available = filepos;
        return &context->enc_MemWindow[context->enc_window_size];
        }
    else
        {
        *input_position = filepos - context->enc_window_size;
        *bytes_available = context->enc_window_size;
        return &context->enc_MemWindow[context->enc_BufPos - context->enc_window_size];
        }
}


//
// This is used to quickly insert the old file into the history.
//

bool __fastcall LZX_EncodeInsertDictionary(
                       t_encoder_context *context,
                       byte *             input_data,
                       ulong              input_size
                       )
{
    ulong   BufPos;
    ulong   RealBufPos;
    ulong   BufPosEnd;
    ulong   BytesRead;
    ulong   i;
    ulong   end_pos;

    context->enc_input_ptr  = input_data;
    context->enc_input_left = input_size;

    context->enc_file_size_for_translation = 0;
    context->enc_first_time_this_group = false;

    RealBufPos = context->enc_BufPos - (context->enc_RealMemWindow - context->enc_MemWindow);

    BytesRead = comp_read_input(context, RealBufPos, input_size);

    context->enc_inserted_dict_size = BytesRead;

    BufPos    = context->enc_BufPos;
    BufPosEnd = context->enc_BufPos + BytesRead;

    while (BufPos < BufPosEnd)
    {
        quick_insert_bsearch_findmatch(
            context,
            BufPos,
            BufPos - context->enc_window_size+4
        );

        BufPos++;
    }

    context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

    end_pos = BufPos - (context->enc_window_size-4-BREAK_LENGTH);

    for (i = 1; (i <= BREAK_LENGTH); i++)
        binary_search_remove_node(context, BufPos-i, end_pos);

    context->enc_BufPos = BufPos;
    context->enc_bufpos_at_last_block = BufPos;

#ifdef DONTCOMPILE

    //
    //  BUGBUG: following attempt at letting insertion slide the window
    //          does not appear useful, and sliding does not appear to
    //          work correctly if second_partition_size is larger than 32K.
    //

    RealBufPos = BufPos - (context->enc_RealMemWindow - context->enc_MemWindow);

    if (RealBufPos < context->enc_window_size + context->enc_encoder_second_partition_size)
        return true;

    //
    //  Otherwise, we need to slide the window contents.  See optenc.c for
    //  the comments describing the sliding process.
    //

#ifdef TESTCODE
    printf( "\rLZX sliding window during insert, BufPos=0x%08X\n", BufPos );
#endif

    memcpy(
        &context->enc_RealMemWindow[0],
        &context->enc_RealMemWindow[context->enc_encoder_second_partition_size],
        context->enc_window_size
        );

    memcpy(
        &context->enc_RealLeft[0],
        &context->enc_RealLeft[context->enc_encoder_second_partition_size],
        sizeof(ulong)*context->enc_window_size
        );

    memcpy(
        &context->enc_RealRight[0],
        &context->enc_RealRight[context->enc_encoder_second_partition_size],
        sizeof(ulong)*context->enc_window_size
        );

    context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

    context->enc_MemWindow -= context->enc_encoder_second_partition_size;
    context->enc_Left      -= context->enc_encoder_second_partition_size;
    context->enc_Right     -= context->enc_encoder_second_partition_size;

#endif /* DONTCOMPILE */

    return true;
}


#ifdef TRACING

ULONG TracingRunningTotal;
ULONG TracingPrevPos;

void
__stdcall
EncTracingMatch(
    ulong BufPos,
    ulong MatchLength,
    ulong MatchPos,
    ulong MatchOff
    )
    {

    if ( BufPos < TracingPrevPos ) {
        printf( "REWIND to %08X\n", BufPos );
        TracingRunningTotal -= ( TracingPrevPos - BufPos );
        }

    TracingPrevPos = BufPos;

    TracingRunningTotal += MatchLength;
#ifdef TRACING2
    printf(
        "MATCH: At %08X, %c%c Off %08X (%08X), Length %5d, Total %08X\n",
        BufPos,
        MatchPos < 3 ? 'R' : ' ',
        MatchPos < 3 ? MatchPos + '0' : ' ',
        MatchOff,
        BufPos - MatchOff,
        MatchLength,
        TracingRunningTotal
        );
#else
    printf(
        "MATCH: At %08X, From %08X, Length %5d\n",
        BufPos,
        BufPos - MatchOff,
        MatchLength
        );
#endif
    }


void
__stdcall
EncTracingLiteral(
    ulong BufPos,
    ulong ch
    )
    {

    if ( BufPos < TracingPrevPos ) {
        printf( "REWIND to %08X\n", BufPos );
        TracingRunningTotal -= ( TracingPrevPos - BufPos );
        }

    TracingPrevPos = BufPos;

    ++TracingRunningTotal;

#ifdef TRACING2
    printf(
        "LITER: At %08X, 0x%02X                                      Total %08X\n",
        BufPos,
        ch,
        TracingRunningTotal
        );
#else
    printf(
        "LITER: At %08X, 0x%02X\n",
        BufPos,
        ch
        );
#endif
    }

void
__stdcall
EncTracingDefineOffsets(
    unsigned long WindowSize,
    unsigned long InterFileBytes,
    unsigned long OldFileSize
    )
{
}

#endif /* TRACING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\encstats.c ===
/*
 * encstats.c
 *
 * Routines for calculating statistics on a block of data which
 * has been compressed, but not yet output.
 *
 * These routines are used to determine which encoding method to use
 * to output the block.
 */

#include "encoder.h"



static void tally_aligned_bits(t_encoder_context *context, ulong dist_to_end_at)
{
        ulong   *dist_ptr;
        ulong   i;
        ulong   match_pos;

        /*
     * Tally the lower 3 bits
     */
        dist_ptr = context->enc_DistData;

        for (i = dist_to_end_at; i > 0; i--)
        {
                match_pos = *dist_ptr++;

                /*
                 * Only for matches which have >= 3 extra bits
                 */
                if (match_pos >= MPSLOT3_CUTOFF)
                        context->enc_aligned_tree_freq[match_pos & 7]++;
        }
}


/*
 * Determine whether it is advantageous to use aligned block
 * encoding on the block.
 */
lzx_block_type get_aligned_stats(t_encoder_context *context, ulong dist_to_end_at)
{
        byte            i;
        ulong           total_L3 = 0;
        ulong           largest_L3 = 0;

        memset(
                context->enc_aligned_tree_freq,
                0,
                sizeof(context->enc_aligned_tree_freq)
        );

        tally_aligned_bits(context, dist_to_end_at);

        for (i = 0; i < ALIGNED_NUM_ELEMENTS; i++)
        {
                if (context->enc_aligned_tree_freq[i] > largest_L3)
                        largest_L3 = context->enc_aligned_tree_freq[i];

                total_L3 += context->enc_aligned_tree_freq[i];
        }

        /*
         * Do aligned offsets if the largest frequency accounts for 20%
         * or more (as opposed to 12.5% for non-aligned offset blocks).
         *
         * Not worthwhile to do aligned offsets if we have < 100 matches
         */
        if ((largest_L3 > total_L3/5) && dist_to_end_at >= 100)
                return BLOCKTYPE_ALIGNED;
        else
                return BLOCKTYPE_VERBATIM;
}


/*
 * Calculates the frequency of each literal, and returns the total
 * number of uncompressed bytes compressed in the block.
 */
static ulong tally_frequency(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
)
{
        ulong   i;
        ulong   d;
        ulong   compressed_bytes = 0;

        d = distance_to_start_at;

        for (i = literal_to_start_at; i < literal_to_end_at; i++)
        {
                if (!IsMatch(i))
                {
                        /* Uncompressed symbol */
                        context->enc_main_tree_freq[context->enc_LitData[i]]++;
                        compressed_bytes++;
                }
                else
                {
                        /* Match */
                        if (context->enc_LitData[i] < NUM_PRIMARY_LENGTHS)
                        {
                                context->enc_main_tree_freq[ NUM_CHARS + (MP_SLOT(context->enc_DistData[d])<<NL_SHIFT) + context->enc_LitData[i]] ++;
                        }
                        else
                        {
                                context->enc_main_tree_freq[ (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[d])<<NL_SHIFT)] ++;
                                context->enc_secondary_tree_freq[context->enc_LitData[i] - NUM_PRIMARY_LENGTHS] ++;
                        }

                        compressed_bytes += context->enc_LitData[i]+MIN_MATCH;

#ifdef EXTRALONGMATCHES
                        if (( context->enc_LitData[ i ] + MIN_MATCH ) == MAX_MATCH ) {
                            compressed_bytes += context->enc_ExtraLength[ i ];
                            }
#endif

                        d++;
                }
        }

        return compressed_bytes;
}


/*
 * Get statistics
 */
ulong get_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
)
{
        memset(
                context->enc_main_tree_freq,
                0,
                sizeof(context->enc_main_tree_freq)
        );

        memset(
                context->enc_secondary_tree_freq,
                0,
                sizeof(context->enc_secondary_tree_freq)
        );

        return tally_frequency(
                context,
                literal_to_start_at,
                distance_to_start_at,
                literal_to_end_at
        );
}


/*
 * Update cumulative statistics
 */
ulong update_cumulative_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
)
{
        return tally_frequency(
                context,
                literal_to_start_at,
                distance_to_start_at,
                literal_to_end_at
        );
}



/*
 * Used in block splitting
 *
 * This routine calculates the "difference in composition" between
 * two different sections of compressed data.
 *
 * Resolution must be evenly divisible by STEP_SIZE, and must be
 * a power of 2.
 */
#define RESOLUTION                              1024

/*
 * Threshold for determining if two blocks are different
 *
 * If enough consecutive blocks are this different, the block
 * splitter will start investigating, narrowing down the
 * area where the change occurs.
 *
 * It will then look for two areas which are
 * EARLY_BREAK_THRESHOLD (or more) different.
 *
 * If THRESHOLD is too small, it will force examination
 * of a lot of blocks, slowing down the compressor.
 *
 * The EARLY_BREAK_THRESHOLD is the more important value.
 */
#define THRESHOLD                               1400

/*
 * Threshold for determining if two blocks are REALLY different
 */
#define EARLY_BREAK_THRESHOLD   1700

/*
 * Must be >= 8 because ItemType[] array is in bits
 *
 * Must be a power of 2.
 *
 * This is the step size used to narrow down the exact
 * best point to split the block.
 */
#define STEP_SIZE               64

/*
 * Minimum # literals required to perform block
 * splitting at all.
 */
#define MIN_LITERALS_REQUIRED   6144

/*
 * Minimum # literals we will allow to be its own block.
 *
 * We don't want to create blocks with too small numbers
 * of literals, otherwise the static tree output will
 * take up too much space.
 */
#define MIN_LITERALS_IN_BLOCK   4096


static const long square_table[17] =
{
        0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256
};


/*
 * log2(x) = x < 256 ? log2_table[x] : 8 + log2_table[(x >> 8)]
 *
 * log2(0)   = 0
 * log2(1)   = 1
 * log2(2)   = 2
 * log2(3)   = 2
 * log2(4)   = 3
 * log2(255) = 8
 * log2(256) = 9
 * log2(511) = 9
 * log2(512) = 10
 *
 * It's not a real log2; it's off by one because we have
 * log2(0) = 0.
 */
static const byte log2_table[256] =
{
        0,1,2,2,3,3,3,3,
        4,4,4,4,4,4,4,4,
        5,5,5,5,5,5,5,5,
        5,5,5,5,5,5,5,5,
        6,6,6,6,6,6,6,6,
        6,6,6,6,6,6,6,6,
        6,6,6,6,6,6,6,6,
        6,6,6,6,6,6,6,6,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8
};


/*
 * Return the difference between two sets of matches/distances
 */
static ulong return_difference(
        t_encoder_context *context,
        ulong item_start1,
        ulong item_start2,
        ulong dist_at_1,
        ulong dist_at_2,
        ulong size
)
{
        ushort  freq1[800];
        ushort  freq2[800];
        ulong   i;
        ulong   cum_diff;
        int             element;

        /*
         * Error!  Too many main tree elements
         */
        if (MAIN_TREE_ELEMENTS >= (sizeof(freq1)/sizeof(freq1[0])))
                return 0;

        memset(freq1, 0, sizeof(freq1[0])*MAIN_TREE_ELEMENTS);
        memset(freq2, 0, sizeof(freq2[0])*MAIN_TREE_ELEMENTS);

        for (i = 0; i < size; i++)
        {
                if (!IsMatch(item_start1))
                {
                        element = context->enc_LitData[item_start1];
                }
                else
                {
                        if (context->enc_LitData[item_start1] < NUM_PRIMARY_LENGTHS)
                                element = NUM_CHARS + (MP_SLOT(context->enc_DistData[dist_at_1])<<NL_SHIFT) + context->enc_LitData[item_start1];
                        else
                                element = (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[dist_at_1]) << NL_SHIFT);

                        dist_at_1++;
                }

                item_start1++;
                freq1[element]++;

                if (!IsMatch(item_start2))
                {
                        element = context->enc_LitData[item_start2];
                }
                else
                {
                        if (context->enc_LitData[item_start2] < NUM_PRIMARY_LENGTHS)
                                element = NUM_CHARS + (MP_SLOT(context->enc_DistData[dist_at_2])<<NL_SHIFT) + context->enc_LitData[item_start2];
                        else
                                element = (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[dist_at_2]) << NL_SHIFT);

                        dist_at_2++;
                }

                item_start2++;
                freq2[element]++;
        }

        cum_diff = 0;

        for (i = 0; i < (ulong) MAIN_TREE_ELEMENTS; i++)
        {
                ulong log2a, log2b, diff;

#define log2(x) ((x) < 256 ? log2_table[(x)] : 8+log2_table[(x) >> 8])

                log2a = (ulong) log2(freq1[i]);
                log2b = (ulong) log2(freq2[i]);

                /* diff = (log2a*log2a) - (log2b*log2b); */
                diff = square_table[log2a] - square_table[log2b];

                cum_diff += abs(diff);
        }

        return cum_diff;
}


/*
 * Calculates where and if a block of compressed data should be split.
 *
 * For example, if we have just compressed text data, audio data, and
 * more text data, then the composition of matches and unmatched
 * symbols will be different between the text data and audio data.
 * Therefore we force an end of block whenever the compressed data
 * looks like it's changing in composition.
 *
 * This routine currently cannot tell the difference between blocks
 * which should use aligned offsets, and blocks which should not.
 * However, there is little to be gained from looking for this change,
 * since it the match finder doesn't make an effort to look for
 * aligned offsets either.
 *
 * Returns whether we split the block or not.
 */
bool split_block(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong literal_to_end_at,
        ulong distance_to_end_at,       /* corresponds to # distances at literal_to_end_at */
        ulong *split_at_literal,
        ulong *split_at_distance        /* optional parameter (may be NULL) */
)
{
        ulong   i, j, d;
        int             nd;

        /*
         * num_dist_at_item[n] equals the cumulative number of matches
         * at literal "n / STEP_SIZE".
         */
        ushort  num_dist_at_item[(MAX_LITERAL_ITEMS/STEP_SIZE)+8]; /* +8 is slop */

        /*
         * default return
         */
        *split_at_literal       = literal_to_end_at;

        if (split_at_distance)
                *split_at_distance      = distance_to_end_at;

        /* Not worth doing if we don't have many literals */
        if (literal_to_end_at - literal_to_start_at < MIN_LITERALS_REQUIRED)
                return false;

    /* Not allowed to split blocks any more, so we don't overflow MAX_GROWTH? */
    if (context->enc_num_block_splits >= MAX_BLOCK_SPLITS)
        return false;

        /*
         * Keep track of the number of distances (matches) we've had,
         * at each step of STEP_SIZE literals.
         *
         * Look at 8 items at a time, and ignore the last
         * 0..7 items if they exist.
         */
        nd = 0;
        d = 0;

        for (i = 0; i < (literal_to_end_at >> 3); i++)
        {
                /*
                 * if (i % (STEP_SIZE >> 3)) == 0
                 */
                if ((i & ((STEP_SIZE >> 3)-1)) == 0)
                        num_dist_at_item[nd++] = (ushort) d;

                d += context->enc_ones[ context->enc_ItemType[i] ];
        }

        /*
         * Must be a multiple of STEP_SIZE
         */
        literal_to_start_at = (literal_to_start_at + (STEP_SIZE-1)) & (~(STEP_SIZE-1));

        /*
         * See where the change in composition occurs
         */
        for (   i = literal_to_start_at + 2*RESOLUTION;
                        i < literal_to_end_at - 4*RESOLUTION;
                        i += RESOLUTION)
        {
                /*
                 * If there appears to be a significant variance in composition
                 * between
                 *                    ___________
                 *                   /           \
                 *                A  B  i     X  Y  Z
                 *                \      \___/      /
                 *                 \_______________/
                 */
                if (
                        return_difference(
                                context,
                                i,
                                i+1*RESOLUTION,
                                (ulong) num_dist_at_item[i/STEP_SIZE],
                                (ulong) num_dist_at_item[(i+1*RESOLUTION)/STEP_SIZE],
                                RESOLUTION) > THRESHOLD
                        &&

                        return_difference(
                                context,
                                i-RESOLUTION,
                                i+2*RESOLUTION,
                                (ulong) num_dist_at_item[(i-RESOLUTION)/STEP_SIZE],
                                (ulong) num_dist_at_item[(i+2*RESOLUTION)/STEP_SIZE],
                                RESOLUTION) > THRESHOLD

                        &&

                        return_difference(
                                context,
                                i-2*RESOLUTION,
                                i+3*RESOLUTION,
                                (ulong) num_dist_at_item[(i-2*RESOLUTION)/STEP_SIZE],
                                (ulong) num_dist_at_item[(i+3*RESOLUTION)/STEP_SIZE],
                                RESOLUTION) > THRESHOLD
                        )
                {
                        ulong max_diff = 0;
                        ulong literal_split = 0;

                        /*
                         * Narrow down the best place to split block
                         *
                         * This really could be done much better; we could end up
                         * doing a lot of stepping;
                         *
                         * basically ((5/2 - 1/2) * RESOLUTION) / STEP_SIZE
                         *
                         * which is (2 * RESOLUTION) / STEP_SIZE,
                         * which with RESOLUTION = 1024 and STEP_SIZE = 32,
                         * equals 2048/32 = 64 steps.
                         */
                        for (j = i+RESOLUTION/2; j<i+(5*RESOLUTION)/2; j += STEP_SIZE)
                        {
                                ulong   diff;

                                diff = return_difference(
                                        context,
                                        j - RESOLUTION,
                                        j,
                                        (ulong) num_dist_at_item[(j-RESOLUTION)/STEP_SIZE],
                                        (ulong) num_dist_at_item[j/STEP_SIZE],
                                        RESOLUTION
                                );

                                /* Get largest difference */
                                if (diff > max_diff)
                                {
                                        /*
                                         * j should not be too small, otherwise we'll be outputting
                                         * a very small block
                                         */
                                        max_diff = diff;
                                        literal_split = j;
                                }
                        }

                        /*
                         * There could be multiple changes in the data in our literals,
                         * so if we find something really weird, make sure we break the
                         * block now, and not on some later change.
                         */
                        if (max_diff >= EARLY_BREAK_THRESHOLD &&
                                (literal_split-literal_to_start_at) >= MIN_LITERALS_IN_BLOCK)
                        {
                context->enc_num_block_splits++;

                                *split_at_literal = literal_split;

                                /*
                                 * Return the associated # distances, if required.
                                 * Since we split on a literal which is % STEP_SIZE, we
                                 * can read the # distances right off
                                 */
                                if (split_at_distance)
                                        *split_at_distance = num_dist_at_item[literal_split/STEP_SIZE];

                                return true;
                        }
                }
        }

        /*
         * No good place found to split
         */
        return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\encmacro.h ===
/*
 * encmacro.h
 *
 * Encoder macros
 */


/*
 * Returns the slot number of a match position (uses table lookup) 
 */
#define MP_SLOT(matchpos) \
   ((matchpos) < 1024 ?										\
		context->enc_slot_table[(matchpos)] :					\
			( (matchpos) < 524288L ?						\
				(18 + context->enc_slot_table[(matchpos) >> 9]) :   \
				(34 + ((matchpos) >> 17))		\
		)													\
   )


/*
 * Is a given literal a match or an unmatched symbol?
 */
#define IsMatch(literal) (context->enc_ItemType[(literal) >> 3] & (1 << ((literal) & 7)))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\encproto.h ===
/*
 * encproto.h
 *
 * Encoder function prototypes
 */

/* blkinit.c */
void create_slot_lookup_table(t_encoder_context *context);
void create_ones_table(t_encoder_context *context);

/* block.c */
void output_block(t_encoder_context *context);
void flush_output_bit_buffer(t_encoder_context *context);
long estimate_buffer_contents(t_encoder_context *context);
ulong get_distances_from_literals(t_encoder_context *context, ulong literals);

/* bsearch.c */
long binary_search_findmatch(t_encoder_context *context, ulong BufPos);
void quick_insert_bsearch_findmatch(t_encoder_context *context, ulong BufPos, ulong endpos);
void binary_search_remove_node(t_encoder_context *context, ulong BufPos, ulong end_pos);

/* encdata.c */
void output_bits( t_encoder_context *context, ulong numbits, ulong value );
void encode_verbatim_block(t_encoder_context *context, ulong literal_to_end_at);
void encode_aligned_block(t_encoder_context *context, ulong literal_to_end_at);
void encode_uncompressed_block(t_encoder_context *context, ulong bufpos, ulong block_size);
void perform_flush_output_callback(t_encoder_context *context);
ulong estimate_compressed_block_size(t_encoder_context *context);
void get_final_repeated_offset_states(t_encoder_context *context, ulong distances);

/* encstats.c */
lzx_block_type get_aligned_stats(t_encoder_context *context, ulong dist_to_end_at);

ulong get_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
);

ulong update_cumulative_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
);

bool split_block(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong literal_to_end_at,
        ulong distance_to_end_at,
        ulong *split_at_literal,
        ulong *split_at_distance
);

/* enctree.c */
void create_trees(t_encoder_context *context, bool generate_codes);
void fix_tree_cost_estimates(t_encoder_context *context);
void encode_trees(t_encoder_context *context);
void encode_aligned_tree(t_encoder_context *context);
void prevent_far_matches(t_encoder_context *context);

/* init.c */
void init_compression_memory(t_encoder_context *context);
bool comp_alloc_compress_memory(t_encoder_context *context);

/* io.c */
bool init_compressed_output_buffer(t_encoder_context *context);
void flush_compressed_output_buffer(t_encoder_context *context);
void reset_translation(t_encoder_context *context);
long comp_read_input(t_encoder_context *context, ulong BufPos, long Size);

/* optenc.c */
void opt_encode_top(t_encoder_context *context, long BytesRead);
void reset_encoder_variables(t_encoder_context *context);
void flush_all_pending_blocks(t_encoder_context *context);
void encoder_start(t_encoder_context *context);

void make_tree(
        t_encoder_context *context,
        int             nparm,
        ushort  *freqparm,
        byte    *lenparm,
        ushort  *codeparm,
        bool    make_codes
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\encoder.h ===
/*
 * encoder.h
 *
 * Main header file; includes everything else
 */

#ifndef ENCODER_H
#define ENCODER_H


#ifdef USE_ASSEMBLY
#   define ASM_BSEARCH_FINDMATCH
//#   define ASM_QUICK_INSERT_BSEARCH_FINDMATCH
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#ifndef ASSERT

    #if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )

        int
        __stdcall
        Assert(
            const char *szText,
            const char *szFile,
            unsigned    uLine
            );

        #define ASSERT( a ) (( a ) ? 1 : Assert( #a, __FILE__, __LINE__ ))

    #else

        #define ASSERT( a )

    #endif

#endif // ASSERT

#ifndef _ASSERTE

    #define _ASSERTE( a ) ASSERT( a )

#endif

#include "../common/typedefs.h"
#include "../common/compdefs.h"
#include "encdefs.h"
#include "encvars.h"
#include "encmacro.h"
#include "encapi.h"
#include "encproto.h"


#endif  /* ENCODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\encvars.h ===
/*
 * encvars.h
 *
 * Variables for the compressor
 */

#ifdef ALLOC_VARS
    #undef EXT
    #define EXT
#else
    #undef EXT
    #define EXT extern
#endif


/*
 * For the optimal parser
 *
 * Uses less memory if it's ushort, but then we're forcing the CPU
 * to do 16 bit operations.
 *
 * Change this to ulong if you don't mind a small memory hit.
 * Also, if you make LOOK too large, this number may cause the
 * cost estimation to overflow; e.g. 10000 uncompressed symbols
 * @ 8 bits each > 65535 bits.
 */
typedef ulong           numbits_t;


/*
 * For the optimal parser
 */
typedef struct
{
    ulong                   link;
    ulong                   path;
    ulong                   repeated_offset[NUM_REPEATED_OFFSETS];
    numbits_t               numbits;
#ifdef TRACING
    ulong                   matchoff;
#endif
} decision_node;


/*
 * 256 + 8 * max_position_slots
 */
#define MAX_MAIN_TREE_ELEMENTS (256 + (8 * 291))   // 32MB

typedef struct
{
    /* "fake" window pointer, based on enc_RealMemWindow */
    byte               *enc_MemWindow;

    ulong               enc_window_size;

#ifdef MULTIPLE_SEARCH_TREES

    /* root node pointers for our search trees */
    ulong              *enc_tree_root;
#else /* !MULTIPLE_SEARCH_TREES */
    ulong               enc_single_tree_root;
#endif /* MULTIPLE_SEARCH_TREES */


    /* "fake" start of left nodes */
    ulong              *enc_Left;

    /* "fake" start of right nodes */
    ulong              *enc_Right;

    /* bitwise outputting */
    ulong               enc_bitbuf;
    signed char         enc_bitcount;
    bool                enc_output_overflow;
    char                pad1[2];

    /* used to record literals and displacements */
    ulong               enc_literals;    /* current number of literals */
    ulong               enc_distances;   /* current number of displacements */
    ulong              *enc_DistData;               /* match displacement array */
    byte               *enc_LitData;     /* contains a character or a matchlength */

#ifdef EXTRALONGMATCHES
    ushort             *enc_ExtraLength;    /* parallel to enc_LitData */
#endif

    byte               *enc_ItemType;  /* bitmap for whether it's a character or matchlength */
    ulong               enc_repeated_offset_at_literal_zero[NUM_REPEATED_OFFSETS];

    /*
     * the last three match offsets (displacements) encoded, the most recent
     * one being enc_last_matchpos_offset[0].
     */
    ulong               enc_last_matchpos_offset[NUM_REPEATED_OFFSETS];

    /* used for optimal parsing */
    ulong               enc_matchpos_table[MAX_MATCH+1];

    /* current encoding position in data */
    ulong               enc_BufPos;

    /* lookup table for converting a match position into a slot */
    ushort              enc_slot_table[1024];

    /* buffering the output data */
    byte               *enc_output_buffer_start;
    byte               *enc_output_buffer_curpos;
    byte               *enc_output_buffer_end;
    ulong               enc_input_running_total;
    ulong               enc_bufpos_last_output_block;

    /* number of distinct position slots */
    ulong               enc_num_position_slots;

    /* misc */
    ulong               enc_file_size_for_translation;

    /* number of block splits for this 32K of uncompressed data */
    byte                enc_num_block_splits;

    /* the number of 1 bits in any given integer */
    byte                enc_ones[256];

    /* compression parameters */
    byte                enc_first_block;
    bool                enc_need_to_recalc_stats;
    bool                enc_first_time_this_group;
    ulong               enc_encoder_second_partition_size;
    ulong               enc_earliest_window_data_remaining;
    ulong               enc_bufpos_at_last_block;
    byte               *enc_input_ptr;
    long                enc_input_left;
    ulong               enc_instr_pos;

    /* for tree.c */
    ushort             *enc_tree_freq;
    ushort             *enc_tree_sortptr;
    byte               *enc_len;
    short               enc_tree_heap[MAX_MAIN_TREE_ELEMENTS + 2];
    ushort              enc_tree_leftright[2*(2*MAX_MAIN_TREE_ELEMENTS-1)];
    ushort              enc_tree_len_cnt[17];
    int                 enc_tree_n;
    short               enc_tree_heapsize;
    char                enc_depth;

    ulong               enc_next_tree_create;
    ulong               enc_last_literals;
    ulong               enc_last_distances;
    decision_node      *enc_decision_node;

    /* trees */
    byte                enc_main_tree_len[MAX_MAIN_TREE_ELEMENTS+1];
    byte                enc_secondary_tree_len[NUM_SECONDARY_LENGTHS+1];

    ushort              enc_main_tree_freq[MAX_MAIN_TREE_ELEMENTS*2];
    ushort              enc_main_tree_code[MAX_MAIN_TREE_ELEMENTS];
    byte                enc_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS+1];

    ushort              enc_secondary_tree_freq[NUM_SECONDARY_LENGTHS*2];
    ushort              enc_secondary_tree_code[NUM_SECONDARY_LENGTHS];
    byte                enc_secondary_tree_prev_len[NUM_SECONDARY_LENGTHS+1];

    ushort              enc_aligned_tree_freq[ALIGNED_NUM_ELEMENTS*2];
    ushort              enc_aligned_tree_code[ALIGNED_NUM_ELEMENTS];
    byte                enc_aligned_tree_len[ALIGNED_NUM_ELEMENTS];
    byte                enc_aligned_tree_prev_len[ALIGNED_NUM_ELEMENTS];

    /* start of allocated window memory */
    byte               *enc_RealMemWindow;

    /* start of allocated left nodes */
    ulong              *enc_RealLeft;

    /* start of allocated right nodes */
    ulong              *enc_RealRight;

    /* # cfdata frames this folder */
    ulong               enc_num_cfdata_frames;

    /* misc */
    void               *enc_fci_data;

    PFNALLOC            enc_malloc;
    HANDLE              enc_mallochandle;

    ulong               enc_inserted_dict_size;

    ulong               enc_last_bsearch_bufpos;

    int (__stdcall *enc_output_callback_function)(
                         void *          pfol,
                         unsigned char * compressed_data,
                         long            compressed_size,
                         long            uncompressed_size
                         );


} t_encoder_context;


/*
 * Declare arrays?
 */

#ifdef ALLOC_VARS


/*
 * (1 << extra_bits[n])-1
 */
const ulong enc_slot_mask[] =
{
    0,      0,      0,      0,     1,       1,      3,      3,
    7,      7,     15,     15,    31,      31,     63,     63,
    127,    127,    255,    255,   511,     511,   1023,   1023,
    2047,   2047,   4095,   4095,  8191,    8191,  16383,  16383,
    32767,  32767,  65535,  65535, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
    131071, 131071, 131071
};

const byte enc_extra_bits[] =
{
    0,0,0,0,1,1,2,2,
    3,3,4,4,5,5,6,6,
    7,7,8,8,9,9,10,10,
    11,11,12,12,13,13,14,14,
    15,15,16,16,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17,
    17,17,17
};

#else

extern const ulong enc_slot_mask[];
extern const byte enc_extra_bits[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\init.c ===
/*
 * init.c
 *
 * Initialise encoder
 */
#include "encoder.h"


#define MEM_WINDOW_ALLOC_SIZE   \
        (context->enc_window_size+(MAX_MATCH+EXTRA_SIZE)+context->enc_encoder_second_partition_size)

/*
 * Initialise encoder
 */
void init_compression_memory(t_encoder_context *context)
{
    /* set all root pointers to NULL */
#ifdef MULTIPLE_SEARCH_TREES
    memset(
          context->enc_tree_root,
          0,
          NUM_SEARCH_TREES * sizeof(context->enc_tree_root[0])
          );
#else
    context->enc_single_tree_root = 0;
#endif

    context->enc_MemWindow  = context->enc_RealMemWindow - context->enc_window_size;
    context->enc_Left       = context->enc_RealLeft      - context->enc_window_size;
    context->enc_Right      = context->enc_RealRight     - context->enc_window_size;
    context->enc_BufPos     = context->enc_window_size;

    /*
     * Set initial state of repeated match offsets
     */
    context->enc_last_matchpos_offset[0] = 1;
    context->enc_last_matchpos_offset[1] = 1;
    context->enc_last_matchpos_offset[2] = 1;

    /*
     * repeated offset states the last time we output a block
     * see block.c/encdata.c
     */
    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    /* this is the first compressed block in the file */
    context->enc_first_block = true;

    /* we don't have any cumulative stats yet */
    context->enc_need_to_recalc_stats = true;

    /* bufpos @ last time we output a block */
    context->enc_bufpos_last_output_block = context->enc_BufPos;

    /* initialise bit buffer */
    context->enc_bitcount = 32;
    context->enc_bitbuf   = 0;
    context->enc_output_overflow = false;

    /*
     * The last lengths are zeroed in both the encoder and decoder,
     * since our tree representation is delta format.
     */
    memset(context->enc_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);
    memset(context->enc_secondary_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);

    /*
     * Set the default last tree lengths for cost estimation
     */
    memset(context->enc_main_tree_len, 8, NUM_CHARS);
    memset(&context->enc_main_tree_len[NUM_CHARS], 9, MAIN_TREE_ELEMENTS-NUM_CHARS);
    memset(context->enc_secondary_tree_len, 6, NUM_SECONDARY_LENGTHS);
    memset(context->enc_aligned_tree_len, 3, ALIGNED_NUM_ELEMENTS);
    prevent_far_matches(context); /* prevent far match 2's from being taken */

    context->enc_bufpos_at_last_block           = context->enc_BufPos;
    context->enc_earliest_window_data_remaining = context->enc_BufPos;
    context->enc_input_running_total            = 0;
    context->enc_first_time_this_group          = true;

    /* Clear the literal types array */
    memset(context->enc_ItemType, 0, MAX_LITERAL_ITEMS/8);

    /* No literals or distances encoded yet */
    context->enc_literals      = 0;
    context->enc_distances     = 0;

    /* No block splits yet */
    context->enc_num_block_splits = 0;

    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    /* reset instruction pointer (for translation) to zero */
    reset_translation(context);

    context->enc_num_cfdata_frames = 0;
    context->enc_last_bsearch_bufpos = 0;
}


/*
 * Allocate memory for the compressor
 *
 * Returns true if successful, false otherwise
 */
bool comp_alloc_compress_memory(t_encoder_context *context)
{
    ulong   pos_start;

#ifdef MULTIPLE_SEARCH_TREES
    context->enc_tree_root          = NULL;
#endif
    context->enc_RealLeft           = NULL;
    context->enc_RealRight          = NULL;
    context->enc_MemWindow          = NULL;
    context->enc_decision_node      = NULL;
    context->enc_LitData            = NULL;
#ifdef EXTRALONGMATCHES
    context->enc_ExtraLength        = NULL;
#endif
    context->enc_DistData           = NULL;
    context->enc_ItemType           = NULL;
    context->enc_output_buffer_start = NULL;

    /* ALSO NULLIFY BUFFERS! */

    /*
     * Determine the number of position slots in the main tree
     */
    context->enc_num_position_slots = 4;
    pos_start                       = 4;

    while (1)
        {
        pos_start += 1 << enc_extra_bits[context->enc_num_position_slots];

        context->enc_num_position_slots++;

        if (pos_start >= context->enc_window_size)
            break;
        }

#ifdef MULTIPLE_SEARCH_TREES
    context->enc_tree_root = (ulong *) context->enc_malloc(
                                                          context->enc_mallochandle,
                                                          sizeof(context->enc_tree_root[0]) * NUM_SEARCH_TREES
                                                          );

    if (context->enc_tree_root == NULL)
        {
        return false;
        }
#endif

    context->enc_RealLeft = (ulong *) context->enc_malloc(
                                                         context->enc_mallochandle,
                                                         sizeof(ulong) * MEM_WINDOW_ALLOC_SIZE
                                                         );

    if (context->enc_RealLeft == NULL)
        {
        return false;
        }

    context->enc_RealRight = (ulong *) context->enc_malloc(
                                                          context->enc_mallochandle,
                                                          sizeof(ulong) * MEM_WINDOW_ALLOC_SIZE
                                                          );

    if (context->enc_RealRight == NULL)
        {
        return false;
        }

    context->enc_RealMemWindow = (byte *) context->enc_malloc(
                                                             context->enc_mallochandle,
                                                             MEM_WINDOW_ALLOC_SIZE
                                                             );

    if (context->enc_RealMemWindow == NULL)
        {
        return false;
        }

    context->enc_MemWindow = context->enc_RealMemWindow;

    context->enc_LitData = (byte *) context->enc_malloc(
                                                       context->enc_mallochandle,
                                                       MAX_LITERAL_ITEMS * sizeof(*context->enc_LitData)
                                                       );

    if (context->enc_LitData == NULL)
        {
        return false;
        }

#ifdef EXTRALONGMATCHES

    context->enc_ExtraLength = (ushort *) context->enc_malloc(
                                                             context->enc_mallochandle,
                                                             MAX_LITERAL_ITEMS * sizeof(*context->enc_ExtraLength)
                                                             );

    if (context->enc_ExtraLength == NULL)
        {
        return false;
        }

#endif

    context->enc_DistData = (ulong *) context->enc_malloc(
                                                         context->enc_mallochandle,
                                                         MAX_DIST_ITEMS * sizeof(*context->enc_DistData)
                                                         );

    if (context->enc_DistData == NULL)
        {
        return false;
        }

    context->enc_ItemType = (byte *) context->enc_malloc(
                                                        context->enc_mallochandle,
                                                        MAX_LITERAL_ITEMS/8
                                                        );

    if (context->enc_ItemType == NULL)
        {
        return false;
        }

    create_slot_lookup_table(context);
    create_ones_table(context);

    if (init_compressed_output_buffer(context) == false)
        {
        return false;
        }

    context->enc_decision_node = context->enc_malloc(
                                                    context->enc_mallochandle,
                                                    sizeof(decision_node) * (LOOK+MAX_MATCH+16)
                                                    );

    if (context->enc_decision_node == NULL)
        {
        return false;
        }

    /* success */
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\mztoggle\mztoggle.c ===
#include <stdio.h>

int __cdecl main( int argc, char * argv[] )
{
    FILE * file;
    int c1, c2;

    if ( argc != 2 )
    {
        printf( "MZTOGGLE: swap the first two bytes of an MZ file\n"
                "\n"
                "Usage: MZTOGGLE {file}\n" );

        return( 1 );
    }

    file = fopen( argv[ 1 ], "r+b" );
    if ( file == NULL )
    {
        printf( "MZTOGGLE: unable to open %s for update\n", argv[ 1 ] );
        return( 1 );
    }

    c1 = fgetc( file );
    c2 = fgetc( file );

    if ((( c1 != 'M' ) || ( c2 != 'Z' )) &&
        (( c2 != 'M' ) || ( c1 != 'Z' )))
    {
        printf( "MZTOGGLE: not an MZ file\n" );
        return( 1 );
    }

    fseek( file, 0, SEEK_SET );

    fputc( c2, file );
    fputc( c1, file );

    fclose( file );

    printf( "MZTOGGLE: swapped %c%c to %c%c\n", c1, c2, c2, c1 );

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\io.c ===
/*
 * io.c
 */
#include "encoder.h"

/*
 * Similar to the optimisation we have for the decoder.
 *
 * Allow the encoder to "overrun" output buffer by up to X bytes
 * so that we don't have to check for the end of the buffer every
 * single time we call outbits() in encdata.c
 */

#define OUTPUT_EXTRA_BYTES 64


static void encoder_translate_e8(t_encoder_context *context, byte *mem, long bytes);


/*
 * Initialises output buffering
 */
bool init_compressed_output_buffer(t_encoder_context *context)
{
        if (!(context->enc_output_buffer_start = (byte *) context->enc_malloc(
                                                                             context->enc_mallochandle,
                                                                             OUTPUT_BUFFER_SIZE)
                                                                             ))
            {
            return false;
            }

        context->enc_output_buffer_curpos = context->enc_output_buffer_start;

        context->enc_output_buffer_end =
                context->enc_output_buffer_start+(OUTPUT_BUFFER_SIZE-OUTPUT_EXTRA_BYTES);

        return true;
}


void reset_translation(t_encoder_context *context)
{
        context->enc_instr_pos = 0;
}


static long read_input_data(t_encoder_context *context, byte *mem, long amount)
{
        if (amount <= context->enc_input_left)
        {
                memcpy(mem, context->enc_input_ptr, amount);
                context->enc_input_left -= amount;
                context->enc_input_ptr += amount;

                return amount;
        }
        else
        {
                long bytes_read;

                if (context->enc_input_left <= 0)
                        return 0;

                bytes_read = context->enc_input_left;

                memcpy(mem, context->enc_input_ptr, context->enc_input_left);
                context->enc_input_ptr += context->enc_input_left;
                context->enc_input_left = 0;

                return bytes_read;
        }
}


long comp_read_input(t_encoder_context *context, ulong BufPos, long Size)
{
        long    bytes_read;

        if (Size <= 0)
                return 0;

        bytes_read = read_input_data(
                context,
                &context->enc_RealMemWindow[BufPos],
                Size
        );

        if (bytes_read < 0)
        return 0;

        /*
         * If no translation being performed for this file
         */
    if (context->enc_file_size_for_translation == 0 ||
        context->enc_num_cfdata_frames >= E8_CFDATA_FRAME_THRESHOLD)
    {
        context->enc_num_cfdata_frames++;
                return bytes_read;
    }

        encoder_translate_e8(
                context,
                &context->enc_RealMemWindow[BufPos],
                bytes_read
        );

    context->enc_num_cfdata_frames++;

        return bytes_read;
}


static void encoder_translate_e8(t_encoder_context *context, byte *mem, long bytes)
{
        long    offset;
        long    absolute;
        ulong   end_instr_pos;
        byte    temp[6];
        byte    *mem_backup;

        if (bytes <= 6)
        {
                context->enc_instr_pos += bytes;
                return;
        }

        mem_backup = mem;

        /* backup these bytes */
        memcpy(temp, &mem[bytes-6], 6);

        /* overwrite them with 0xE8 */
        memset(&mem[bytes-6], 0xE8, 6);

        end_instr_pos = context->enc_instr_pos + bytes - 6;

        while (1)
        {
                while (*mem++ != 0xE8)
                        context->enc_instr_pos++;

                if (context->enc_instr_pos >= end_instr_pos)
                        break;

                offset = *(UNALIGNED long *) mem;

                absolute = context->enc_instr_pos + offset;

                if (absolute >= 0)
                {
                        if ((ulong) absolute < context->enc_file_size_for_translation+context->enc_instr_pos)
                        {
                                if ((ulong) absolute >= context->enc_file_size_for_translation)
                                        absolute = offset - context->enc_file_size_for_translation;

                                *(UNALIGNED ulong *) mem = (ulong) absolute;
                        }
                }

                mem += 4;
                context->enc_instr_pos += 5;
        }

        /* restore the bytes */
        memcpy(&mem_backup[bytes-6], temp, 6);

        context->enc_instr_pos = end_instr_pos + 6;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\optenc.c ===
/*
 * optenc.c
 *
 * Encoder for optimal parser
 *
 *
 * Future Improvements:
 *
 * When two estimations are equal, for example, "should I output a
 * character or a match?" there should be some way of deciding
 * which to take.  Right now we force it to output a match, but
 * for text files, outputting a character results in a small
 * savings.  Even when comparing two matches, we might want to
 * force it to take one type of match over another.
 */

#include "encoder.h"

#define copymem(src,dst,size) memcpy(dst,src,size)


static bool redo_first_block(t_encoder_context *context, long *bufpos_ptr);
static void block_end(t_encoder_context *context, long BufPos);


/*
 * encode a match of length <len> (where <len> >=2), and position <pos>
 */

#ifdef EXTRALONGMATCHES

#define OUT_MATCH(len,pos) \
{ \
   ULONG enclen = (len);                                                                        \
   ULONG extlen = 0;                                                                            \
   if ( enclen > MAX_MATCH ) {                                                                  \
        extlen = enclen - MAX_MATCH;                                                            \
        enclen = MAX_MATCH;                                                                     \
        }                                                                                       \
   context->enc_ItemType   [context->enc_literals >> 3] |= (1 << (context->enc_literals & 7));  \
   context->enc_LitData    [context->enc_literals     ]  = (byte)(enclen-MIN_MATCH);            \
   context->enc_ExtraLength[context->enc_literals++   ]  = (ushort)(extlen);                    \
   context->enc_DistData   [context->enc_distances++  ]  = (pos);                               \
}

#else

#define OUT_MATCH(len,pos) \
{ \
   context->enc_ItemType[(context->enc_literals >> 3)] |= (1 << (context->enc_literals & 7));   \
   context->enc_LitData [context->enc_literals++]  = (byte)(len-2);                             \
   context->enc_DistData[context->enc_distances++] = pos;                                       \
}

#endif

/* encode a character */
#define OUT_CHAR(ch) \
        context->enc_LitData [context->enc_literals++] = ch;


#define TREE_CREATE_CHECK()                                             \
if (context->enc_literals >= context->enc_next_tree_create)                     \
{                                                                                               \
        update_tree_estimates(context);\
        context->enc_next_tree_create += TREE_CREATE_INTERVAL;  \
}


/*
 * Returns an estimation of how many bits it would take to output
 * a given character
 */
#define CHAR_EST(c) (numbits_t) (context->enc_main_tree_len[(c)])


/*
 * Returns an estimation of how many bits it would take to output
 * a given match.
 *
 * <ml> is the match length, where ml >= 2
 * <mp> is the match position
 *
 * The result is stored in <result>
 */
#define MATCH_EST(ml,mp,result) \
{ \
        ulong mp_slot;                                                                                                           \
        mp_slot = MP_SLOT(mp);                                                                           \
        if (ml < (NUM_PRIMARY_LENGTHS+2))                                                                       \
        {                                                                                                                                       \
                result = (numbits_t)                                                                                    \
                        (context->enc_main_tree_len[(NUM_CHARS-2)+(mp_slot<<NL_SHIFT)+ml] +     \
                        enc_extra_bits[mp_slot]);                                                                       \
        }                                                                                                                                       \
        else                                                                                                                            \
        {                                                                                                                                       \
                result = (numbits_t)                                                                                    \
                        (context->enc_main_tree_len[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mp_slot<<NL_SHIFT)] + \
                        context->enc_secondary_tree_len[ml-(NUM_PRIMARY_LENGTHS+2)] +   \
                        enc_extra_bits[mp_slot]);                                                                       \
        }                                                                                                                                       \
}


#ifdef _DEBUG
static void VERIFY_MATCH(
                        t_encoder_context   *context,
                        long                bufpos,
                        int                 largest_match_len
                        )
{
    int     i, j;
    ulong   match_pos;

    /*
     * Ensure match does not cross boundary
     */
    _ASSERTE(
            largest_match_len <=
            (CHUNK_SIZE-1) - (bufpos & (CHUNK_SIZE-1))
            );

    for (i = MIN_MATCH; i <= largest_match_len; i++)
        {
        match_pos = context->enc_matchpos_table[i];

        if (match_pos < NUM_REPEATED_OFFSETS)
            match_pos = context->enc_last_matchpos_offset[match_pos];
        else
            match_pos -= (NUM_REPEATED_OFFSETS-1);

        _ASSERTE (match_pos <= context->enc_window_size-4);

        for (j = 0; j < i; j++)
            {
            _ASSERTE (
                     context->enc_MemWindow[bufpos+j] ==
                     context->enc_MemWindow[bufpos-match_pos+j]
                     );
            }
        }
}
#else
    #define VERIFY_MATCH(a,b,c) ;
#endif


void flush_all_pending_blocks(t_encoder_context *context)
{
    /*
     * Force all blocks to be output
     */
    while (context->enc_literals > 0)
        output_block(context);

    /*
     * Flush compressed data out to the caller
     */
    perform_flush_output_callback(context);
}


void encoder_start(t_encoder_context *context)
{
    long BytesRead, RealBufPos;

    /*
     * RealBufPos is our position in the window,
     * and equals [0...window_size + second_partition_size - 1]
     */
    RealBufPos = context->enc_BufPos - (context->enc_RealMemWindow - context->enc_MemWindow);

    BytesRead = comp_read_input(context, RealBufPos, CHUNK_SIZE);

    if (BytesRead > 0)
        opt_encode_top(context, BytesRead);
}


static void update_tree_estimates(t_encoder_context *context)
{
    if (context->enc_literals)
        {
        /*
         * Get stats on literals from 0...context->enc_literals
         */
        if (context->enc_need_to_recalc_stats)
            {
            /*
             * Cumulative total was destroyed, so need to
             * recalculate
             */
            get_block_stats(
                           context,
                           0,
                           0,
                           context->enc_literals
                           );

            context->enc_need_to_recalc_stats = false;
            }
        else
            {
            /*
             * Add stats from last_literals...context->enc_literals
             * to cumulative total
             */
            update_cumulative_block_stats(
                                         context,
                                         context->enc_last_literals,
                                         context->enc_last_distances,
                                         context->enc_literals
                                         );
            }

        create_trees(context, false); /* don't generate codes */

        fix_tree_cost_estimates(context);

        /*
         * For cumulative total
         */
        context->enc_last_literals = context->enc_literals;
        context->enc_last_distances = context->enc_distances;
        }
}


void opt_encode_top(t_encoder_context *context, long BytesRead)
{
    ulong   BufPos;
    ulong   RealBufPos;
    ulong   BufPosEnd;
    ulong   BufPosEndThisChunk;
    ulong   MatchPos;
    ulong   i;
    ulong   end_pos;
    long    EncMatchLength;  /* must be a signed number */
    long    ExMatchOff = -1; /* initialize to prevent compiler warning */

    /*
     * Current position in encoding window
     */
    BufPos          = context->enc_BufPos;

    /*
     * Stop encoding when we reach here
     */
    BufPosEnd       = context->enc_BufPos + BytesRead;

    /*
     * If this is our first time in here (since a new group), then
     * when we reach this many literals, update our tree cost
     * estimates.
     *
     * Also, output the file size we're using for translation
     * (0 means no translation at all, which will speed things up
     * for the decoder).
     */
    if (context->enc_first_time_this_group)
        {
        context->enc_first_time_this_group = false;

        /*
         * Recreate trees when we reach this many literals
         */
        context->enc_next_tree_create = 10000;

        if (context->enc_file_size_for_translation)
            {
            output_bits(context, 1, 1); /* translation */

            output_bits(context, 16, context->enc_file_size_for_translation >> 16);
            output_bits(context, 16, context->enc_file_size_for_translation & 65535);
            }
        else
            {
            output_bits(context, 1, 0); /* no translation */
            }
        }
    else
        {
        /*
         * If this is our second or later time in here, then add in the
         * strings we removed last time.
         *
 * We have to be careful here, though, because end_pos is
 * equal to our current BufPos - window_size, not
 * BufPos - i - window_size; we don't have that much history
 * around.
         */
        for (i = BREAK_LENGTH; i > 0; i--)
            quick_insert_bsearch_findmatch(
                                          context,
                                          BufPos - (long) i,
                                          BufPos - context->enc_window_size+4
                                          );
        }

    while (1)
        {

        top_of_main_loop:

        /*
         * While we haven't reached the end of the data
         */
        while (BufPos < BufPosEnd)
            {

            BufPosEndThisChunk = ( BufPos + CHUNK_SIZE ) & ~( CHUNK_SIZE - 1 );

            if ( BufPosEndThisChunk > BufPosEnd ) {
                 BufPosEndThisChunk = BufPosEnd;
                 }

            /*
             * Search for matches of all different possible lengths, at BufPos
             */
            EncMatchLength = binary_search_findmatch(context, BufPos);

            /*
             * Found a match.
             *
             * Make sure it cannot exceed the end of the buffer.
             */

            if (( BufPos + EncMatchLength ) > BufPosEndThisChunk ) {

                end_pos = BufPos - (context->enc_window_size-4-BREAK_LENGTH);

                do  {
                    --EncMatchLength;
                    binary_search_remove_node( context, ( BufPos + EncMatchLength ), end_pos );
                    }
                while (( BufPos + EncMatchLength ) > BufPosEndThisChunk );
                }

            if (EncMatchLength < MIN_MATCH) {

                /*
                 * No match longer than 1 character exists in the history
                 * window, so output the character at BufPos as a symbol.
                 */
                OUT_CHAR(context->enc_MemWindow[BufPos]);

#ifdef TRACING
                EncTracingLiteral( BufPos, context->enc_MemWindow[BufPos] );
#endif
                BufPos++;

                /*
                 * Check for exceeding literal buffer
                 */
                if (context->enc_literals >= (MAX_LITERAL_ITEMS-8))
                    block_end(context, BufPos);

                continue;
                }

            VERIFY_MATCH(context, BufPos, EncMatchLength);

            if (EncMatchLength < FAST_DECISION_THRESHOLD)
                {
                /*
                 *  A match has been found that is between MIN_MATCH and
                 *  FAST_DECISION_THRESHOLD bytes in length.  The following
                 *  algorithm is the optimal encoder that will determine the
                 *  most efficient order of matches and unmatched characters
                 *  over a span area defined by LOOK.
                 *
                 *  The code is essentially a shortest path determination
                 *  algorithm.  A stream of data can be encoded in a vast number
                 *  of different ways depending on the match lengths and offsets
                 *  chosen.  The key to good compression ratios is to chose the
                 *  least expensive path.
                 */
                ulong           span;
                ulong           epos, bpos, NextPrevPos, MatchPos;
                decision_node *decision_node_ptr;
                long            iterations;

                /*
                 * Points to the end of the area covered by this match; the span
                 * will continually be extended whenever we find more matches
                 * later on.  It will stop being extended when we reach a spot
                 * where there are no matches, which is when we decide which
                 * path to take to output the matches.
                 */
                span = BufPos + EncMatchLength;

                /*
                 * The furthest position into which we will do our lookahead parsing
                 */
                epos = BufPos + LOOK;

                /*
                 * Temporary BufPos variable
                 */
                bpos = BufPos;


                /*
                 * Calculate the path to the next character if we output
                 * an unmatched symbol.
                 */

                /* bits required to get here */
                context->enc_decision_node[1].numbits = CHAR_EST(context->enc_MemWindow[BufPos]);

                /* where we came from */
                context->enc_decision_node[1].path    = BufPos;


                /*
                 * For the match found, estimate the cost of encoding the match
                 * for each possible match length, shortest offset combination.
                 *
                 * The cost, path and offset is stored at BufPos + Length.
                 */
                for (i = MIN_MATCH; i <= (ulong)EncMatchLength; i++)
                    {
                    /*
                     * Get estimation of match cost given match length = i,
                     * match position = context->enc_matchpos_table[i], and store
                     * the result in context->enc_numbits[i]
                     */
                    MATCH_EST(i, context->enc_matchpos_table[i], context->enc_decision_node[i].numbits);

                    /*
                     * Where we came from
                     */
                    context->enc_decision_node[i].path = BufPos;

                    /*
                     * Associated match position with this path
                     */
                    context->enc_decision_node[i].link = context->enc_matchpos_table[i];

#ifdef TRACING
                        {
                        ULONG TrMatchPos = context->enc_matchpos_table[i];
                        ULONG TrMatchOff;

                        if ( TrMatchPos < NUM_REPEATED_OFFSETS ) {
                            TrMatchOff = context->enc_last_matchpos_offset[ TrMatchPos ];
                            }
                        else {
                            TrMatchOff = TrMatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                            }

                        context->enc_decision_node[i].matchoff = TrMatchOff;
                        }
#endif
                    }

                /*
                 * Set bit counter to zero at the start
                 */
                context->enc_decision_node[0].numbits = 0;

                /*
                 * Initialise relative match position tables
                 *
                 * Really context->enc_repeated_offset_table[BufPos-bpos][x], but here
                 * BufPos == bpos
                 */
                context->enc_decision_node[0].repeated_offset[0] = context->enc_last_matchpos_offset[0];
                context->enc_decision_node[0].repeated_offset[1] = context->enc_last_matchpos_offset[1];
                context->enc_decision_node[0].repeated_offset[2] = context->enc_last_matchpos_offset[2];

                decision_node_ptr = &context->enc_decision_node[-(long) bpos];

#define rpt_offset_ptr(where,which_offset) decision_node_ptr[(where)].repeated_offset[(which_offset)]

                while (1)
                    {
                    numbits_t est, cum_numbits;

                    BufPos++;


                    /*
                     *  Set the proper repeated offset locations depending on the
                     *  shortest path to the location prior to searching for a
                     *  match.
                     */


                    /*
                     * If this is a match (i.e. path skips over more
                     * than one character).
                     */
                    if (decision_node_ptr[BufPos].path != (ulong) (BufPos-1))
                        {
                        ulong LastPos = decision_node_ptr[BufPos].path;

                        /*
                         * link_ptr[BufPos] is the match position for this
                         * location
                         */
                        if (decision_node_ptr[BufPos].link >= NUM_REPEATED_OFFSETS)
                            {
                            context->enc_last_matchpos_offset[0] = decision_node_ptr[BufPos].link-(NUM_REPEATED_OFFSETS-1);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,0);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,1);
                            }
                        else if (decision_node_ptr[BufPos].link == 0)
                            {
                            context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,0);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,1);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,2);
                            }
                        else if (decision_node_ptr[BufPos].link == 1)
                            {
                            context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,1);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,0);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,2);
                            }
                        else /* == 2 */
                            {
                            context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,2);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,1);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,0);
                            }
                        }

                    rpt_offset_ptr(BufPos,0) = context->enc_last_matchpos_offset[0];
                    rpt_offset_ptr(BufPos,1) = context->enc_last_matchpos_offset[1];
                    rpt_offset_ptr(BufPos,2) = context->enc_last_matchpos_offset[2];

                    /*
                     * The following is one of the two possible break points from
                     * the inner encoding loop.  This break will exit the loop if
                     * a point is reached that no match can incorporate; i.e. a
                     * character that does not match back to anything is a point
                     * where all possible paths will converge and the longest one
                     * can be chosen.
                     */
                    if (span == BufPos)
                        break;

                    /*
                     * Search for matches at BufPos
                     */
                    EncMatchLength = binary_search_findmatch(context, BufPos);

                    /*
                     * Make sure that the match does not exceed the stop point
                     */

                    if (( BufPos + EncMatchLength ) > BufPosEndThisChunk ) {

                        end_pos = BufPos - (context->enc_window_size-4-BREAK_LENGTH);

                        do  {
                            --EncMatchLength;
                            binary_search_remove_node( context, ( BufPos + EncMatchLength ), end_pos );
                            }
                        while (( BufPos + EncMatchLength ) > BufPosEndThisChunk );
                        }

                    if (EncMatchLength < MIN_MATCH) {
                        EncMatchLength = 0;
                        }

                    VERIFY_MATCH(context, BufPos, EncMatchLength);

                    /*
                     * If the match is very long or it exceeds epos (either
                     * surpassing the LOOK area, or exceeding past the end of the
                     * input buffer), then break the loop and output the path.
                     */
                    if (EncMatchLength > FAST_DECISION_THRESHOLD ||
                        BufPos + (ulong) EncMatchLength >= epos)
                        {
                        MatchPos = context->enc_matchpos_table[EncMatchLength];

#ifdef EXTRALONGMATCHES
                        if ( EncMatchLength == MAX_MATCH ) {
                            if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                                ExMatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                                }
                            else {
                                ExMatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                                }
                            }
#endif

#ifdef TRACING
                            {
                            ULONG TrMatchOff;

                            if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                                TrMatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                                }
                            else {
                                TrMatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                                }

                            decision_node_ptr[BufPos+EncMatchLength].matchoff = TrMatchOff;
                            }
#endif

                        decision_node_ptr[BufPos+EncMatchLength].link = MatchPos;
                        decision_node_ptr[BufPos+EncMatchLength].path = BufPos;

                        /*
                         * Quickly insert data into the search tree without
                         * returning match positions/lengths
                         */
#ifndef INSERT_NEAR_LONG_MATCHES
                        if (MatchPos == 3 && EncMatchLength > 16)
                            {
                            /*
                             * If we found a match 1 character away and it's
                             * length 16 or more, it's probably a string of
                             * zeroes, so don't insert that into the search
                             * engine, since doing so can slow things down
                             * significantly!
                             */
                            quick_insert_bsearch_findmatch(
                                                          context,
                                                          BufPos + 1,
                                                          BufPos - context->enc_window_size + (1 + 4) /* bp+1 -(ws-4) */
                                                          );
                            }
                        else
#endif
                            {
                            for (i = 1; i < (ulong) EncMatchLength; i++)
                                quick_insert_bsearch_findmatch(
                                                              context,
                                                              BufPos + i,
                                                              BufPos + i - context->enc_window_size + 4
                                                              );
                            }

                        BufPos += EncMatchLength;

                        /*
                         * Update the relative match positions
                         */
                        if (MatchPos >= NUM_REPEATED_OFFSETS)
                            {
                            context->enc_last_matchpos_offset[2] = context->enc_last_matchpos_offset[1];
                            context->enc_last_matchpos_offset[1] = context->enc_last_matchpos_offset[0];
                            context->enc_last_matchpos_offset[0] = MatchPos-(NUM_REPEATED_OFFSETS-1);
                            }
                        else if (MatchPos)
                            {
                            ulong t = context->enc_last_matchpos_offset[0];
                            context->enc_last_matchpos_offset[0] = context->enc_last_matchpos_offset[MatchPos];
                            context->enc_last_matchpos_offset[MatchPos] = t;
                            }

                        break;
                        }


                    /*
                     * The following code will extend the area spanned by the
                     * set of matches if the current match surpasses the end of
                     * the span.  A match of length two that is far is not
                     * accepted, since it would normally be encoded as characters,
                     * thus allowing the paths to converge.
                     */
                    if (EncMatchLength > 2 ||
                        (EncMatchLength == 2 && context->enc_matchpos_table[2] < BREAK_MAX_LENGTH_TWO_OFFSET))
                        {
                        if (span < (ulong) (BufPos + EncMatchLength))
                            {
                            long end;
                            long i;

                            end = min(BufPos+EncMatchLength-bpos, LOOK-1);

                            /*
                             * These new positions are undefined for now, since we haven't
                             * gone there yet, so put in the costliest value
                             */
                            for (i = span-bpos+1; i <= end; i++)
                                context->enc_decision_node[i].numbits = (numbits_t) -1;

                            span = BufPos + EncMatchLength;
                            }
                        }


                    /*
                     *  The following code will iterate through all combinations
                     *  of match lengths for the current match.  It will estimate
                     *  the cost of the path from the beginning of LOOK to
                     *  BufPos and to every locations spanned by the current
                     *  match.  If the path through BufPos with the found matches
                     *  is estimated to take fewer number of bits to encode than
                     *  the previously found match, then the path to the location
                     *  is altered.
                     *
                     *  The code relies on accurate estimation of the cost of
                     *  encoding a character or a match.  Furthermore, it requires
                     *  a search engine that will store the smallest match offset
                     *  of each possible match length.
                     *
                     *  A match of length one is simply treated as an unmatched
                     *  character.
                     */

                    /*
                     *  Get the estimated number of bits required to encode the
                     *  path leading up to BufPos.
                     */
                    cum_numbits = decision_node_ptr[BufPos].numbits;


                    /*
                     *  Calculate the estimated cost of outputting the path through
                     *  BufPos and outputting the next character as an unmatched byte
                     */
                    est = cum_numbits + CHAR_EST(context->enc_MemWindow[BufPos]);


                    /*
                     *  Check if it is more efficient to encode the next character
                     *  as an unmatched character rather than the previously found
                     *  match.  If so, then update the cheapest path to BufPos + 1.
                     *
                     *  What happens if est == numbits[BufPos-bpos+1]; i.e. it
                     *  works out as well to output a character as to output a
                     *  match?  It's a tough call; however, we will push the
                     *  encoder to use matches where possible.
                     */
                    if (est < decision_node_ptr[BufPos+1].numbits)
                        {
                        decision_node_ptr[BufPos+1].numbits = est;
                        decision_node_ptr[BufPos+1].path    = BufPos;
                        }


                    /*
                     *      Now, iterate through the remaining match lengths and
                     *  compare the new path to the existing.  Change the path
                     *  if it is found to be more cost effective to go through
                     *  BufPos.
                     */
                    for (i = MIN_MATCH; i <= (ulong) EncMatchLength; i++)
                        {
                        MATCH_EST(i, context->enc_matchpos_table[i], est);
                        est += cum_numbits;

                        /*
                         * If est == numbits[BufPos+i] we want to leave things
                         * alone, since this will tend to force the matches
                         * to be smaller in size, which is beneficial for most
                         * data.
                         */
                        if (est < decision_node_ptr[BufPos+i].numbits)
                            {
                            decision_node_ptr[BufPos+i].numbits     = est;
                            decision_node_ptr[BufPos+i].path        = BufPos;
                            decision_node_ptr[BufPos+i].link        = context->enc_matchpos_table[i];

#ifdef TRACING
                                {
                                ULONG TrMatchPos = context->enc_matchpos_table[i];
                                ULONG TrMatchOff;

                                if ( TrMatchPos < NUM_REPEATED_OFFSETS ) {
                                    TrMatchOff = context->enc_last_matchpos_offset[ TrMatchPos ];
                                    }
                                else {
                                    TrMatchOff = TrMatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                                    }

                                decision_node_ptr[BufPos+i].matchoff = TrMatchOff;
                                }
#endif
                            }
                        }
                    } /* continue to loop through span of matches */


                /*
                 *  Here BufPos == span, ie. a non-matchable character found.  The
                 *  following code will output the path properly.
                 */


                /*
                 *  Unfortunately the path is stored in reverse; how to get from
                 *  where we are now, to get back to where it all started.
                 *
                 *  Traverse the path back to the original starting position
                 *  of the LOOK span.  Invert the path pointers in order to be
                 *  able to traverse back to the current position from the start.
                 */

                /*
                 * Count the number of iterations we did, so when we go forwards
                 * we'll do the same amount
                 */
                iterations = 0;

                NextPrevPos = decision_node_ptr[BufPos].path;

                do
                    {
                    ulong   PrevPos;

                    PrevPos = NextPrevPos;

                    NextPrevPos = decision_node_ptr[PrevPos].path;
                    decision_node_ptr[PrevPos].path = BufPos;

                    BufPos = PrevPos;

                    iterations++;
                    } while (BufPos != bpos);


                if (context->enc_literals + iterations >= (MAX_LITERAL_ITEMS-8) ||
                    context->enc_distances + iterations >= (MAX_DIST_ITEMS-8))
                    {
                    block_end(context, BufPos);
                    }

                /*
                 * Traverse from the beginning of the LOOK span to the end of
                 * the span along the stored path, outputting matches and
                 * characters appropriately.
                 */
                do
                    {
                    if (decision_node_ptr[BufPos].path > BufPos+1)
                        {
                        /*
                         * Path skips over more than 1 character; therefore it's a match
                         */

#ifdef EXTRALONGMATCHES

                        //
                        //  If the match length to output here is MAX_MATCH,
                        //  this must be the last entry in the decision chain,
                        //  and we can extend the match as far as it will go.
                        //

                        long ExMatchPos    = decision_node_ptr[ decision_node_ptr[BufPos].path ].link;
                        long ExMatchLength = decision_node_ptr[BufPos].path - BufPos;

                        if ( ExMatchLength == MAX_MATCH ) {

                            ulong ExBufPtr = BufPos + MAX_MATCH;

                            ASSERT( iterations == 1 );  // last node

#ifdef TRACING
                            ASSERT( ExMatchOff == (long)decision_node_ptr[ decision_node_ptr[BufPos].path ].matchoff );
#endif

                            while (( ExBufPtr < BufPosEndThisChunk ) &&
                                   ( context->enc_MemWindow[ ExBufPtr ] == context->enc_MemWindow[ ExBufPtr - ExMatchOff ] )) {

                                ++ExBufPtr;
                                ++ExMatchLength;
                                }

                            //
                            //  BUGFIX:
                            //
                            //  Decompressor incorrectly handles long matches
                            //  that wrap around its history window, sort of.
                            //  The decompressor replicates the first 257 bytes
                            //  of its window onto the tail of the window so
                            //  a normal match can start near the end of the
                            //  window and proceed forward without wrapping.
                            //  But the long match code can produce matches
                            //  longer than this 257 replicated tail and cause
                            //  the decompressor to walk off the end of its
                            //  replicated tail buffer.  To avoid this, we keep
                            //  track of where the decompressor's window bounds
                            //  will be and break any match that would walk
                            //  beyond the 257 byte replicated tail buffer.
                            //
                            //  This should also be fixed in the decompressor,
                            //  but this fix in the compressor will prevent new
                            //  compressed streams from breaking on existing
                            //  decompressors.
                            //

                            ASSERT( BufPos >= context->enc_inserted_dict_size );

                            if ( true ) {   // always do this for now

                                ulong DecWinPos   = ( BufPos - context->enc_inserted_dict_size );
                                ulong DecMatchOff = ( DecWinPos - ExMatchOff ) & ( context->enc_window_size - 1 );
                                ulong DecMatchEnd = ( DecMatchOff + ExMatchLength );

                                if ( DecMatchEnd > ( context->enc_window_size + MAX_MATCH )) {

                                    ExMatchLength = ( context->enc_window_size + MAX_MATCH ) - DecMatchOff;

                                    ASSERT( ExMatchLength < CHUNK_SIZE );
                                    ASSERT( ExMatchLength >= MAX_MATCH );

                                    }
                                }

                            //
                            //  Now insert extended part of match in search tree.
                            //

#ifndef INSERT_NEAR_LONG_MATCHES
                            if (ExMatchPos != 3)
#endif
                                {
                                for (i = MAX_MATCH; i < (ulong) ExMatchLength; i++)
                                    quick_insert_bsearch_findmatch(
                                                                  context,
                                                                  BufPos + i,
                                                                  BufPos + i - context->enc_window_size + 4
                                                                  );
                                }
                            }


                        OUT_MATCH( ExMatchLength, ExMatchPos );

#ifdef TRACING
                        EncTracingMatch(
                            BufPos,
                            ExMatchLength,
                            ExMatchPos,
                            decision_node_ptr[ decision_node_ptr[BufPos].path ].matchoff
                            );
#endif // TRACING

                        BufPos += ExMatchLength;

#else  /* ! EXTRALONGMATCHES */

                        OUT_MATCH(
                                 decision_node_ptr[BufPos].path - BufPos,
                                 decision_node_ptr[ decision_node_ptr[BufPos].path ].link
                                 );

#ifdef TRACING
                        EncTracingMatch(
                            BufPos,
                            decision_node_ptr[BufPos].path - BufPos,
                            decision_node_ptr[ decision_node_ptr[BufPos].path ].link,
                            decision_node_ptr[ decision_node_ptr[BufPos].path ].matchpos
                            );
#endif // TRACING

                        BufPos = decision_node_ptr[BufPos].path;

#endif /* ! EXTRALONGMATCHES */

                        }
                    else
                        {
                        /*
                         * Path goes to the next character; therefore it's a symbol
                         */
                        OUT_CHAR(context->enc_MemWindow[BufPos]);

#ifdef TRACING
                        EncTracingLiteral( BufPos, context->enc_MemWindow[BufPos] );
#endif

                        BufPos++;
                        }
                    } while (--iterations != 0);

                TREE_CREATE_CHECK();

                /*
                 * If we're filling up, and are close to outputting a block,
                 * and it's the first block, then recompress the first N
                 * literals using our accumulated stats.
                 */
                if (context->enc_first_block &&
                    (context->enc_literals >= (MAX_LITERAL_ITEMS-512)
                     || context->enc_distances >= (MAX_DIST_ITEMS-512)))
                    {
                    if (redo_first_block(context, &BufPos))
                        goto top_of_main_loop;

                    /*
                     * Unable to redo, so output the block
                     */
                    block_end(context, BufPos);
                    }
                }
            else  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
                {
                /*
                 *  This code reflects a speed optimization that will always take
                 *  a match of length >= FAST_DECISION_THRESHOLD characters.
                 */

                /*
                 * The position associated with the match we found
                 */

                MatchPos = context->enc_matchpos_table[EncMatchLength];

#ifdef EXTRALONGMATCHES

                if ( EncMatchLength == MAX_MATCH ) {

                    //
                    //  Extend the match length up to end of input buffer
                    //  or the current position in the history buffer.
                    //

                    ulong BufPtr = BufPos + MAX_MATCH;
                    long MatchOff;

                    if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                        MatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                        }
                    else {
                        MatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                        }

                    while (( BufPtr < BufPosEndThisChunk ) &&
                           ( context->enc_MemWindow[ BufPtr ] == context->enc_MemWindow[ BufPtr - MatchOff ] )) {

                        ++BufPtr;
                        ++EncMatchLength;
                        }

                    //
                    //  BUGFIX:  see comments above
                    //

                    ASSERT( BufPos >= context->enc_inserted_dict_size );

                    if ( true ) {   // always do this for now

                        ulong DecWinPos   = ( BufPos - context->enc_inserted_dict_size );
                        ulong DecMatchOff = ( DecWinPos - MatchOff ) & ( context->enc_window_size - 1 );
                        ulong DecMatchEnd = ( DecMatchOff + EncMatchLength );

                        if ( DecMatchEnd > ( context->enc_window_size + MAX_MATCH )) {

                            EncMatchLength = ( context->enc_window_size + MAX_MATCH ) - DecMatchOff;

                            ASSERT( EncMatchLength < CHUNK_SIZE );
                            ASSERT( EncMatchLength >= MAX_MATCH );

                            }
                        }
                    }

#endif

                /*
                 * Quickly insert match substrings into search tree
                 * (don't look for new matches; just insert the strings)
                 */
#ifndef INSERT_NEAR_LONG_MATCHES
                if (MatchPos == 3 && EncMatchLength > 16)
                    {
                    quick_insert_bsearch_findmatch(
                                                  context,
                                                  BufPos + 1,
                                                  BufPos - context->enc_window_size + 5 /* bp+1 -(ws-4) */
                                                  );
                    }
                else
#endif
                    {
                    for (i = 1; i < (ulong) EncMatchLength; i++)
                        quick_insert_bsearch_findmatch(
                                                      context,
                                                      BufPos + i,
                                                      BufPos + i - context->enc_window_size + 4
                                                      );
                    }

                /*
                 * Output the match
                 */
                OUT_MATCH(EncMatchLength, MatchPos);

#ifdef TRACING

                {
                ULONG TrMatchOff;

                if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                    TrMatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                    }
                else {
                    TrMatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                    }

                EncTracingMatch(
                    BufPos,
                    EncMatchLength,
                    MatchPos,
                    TrMatchOff
                    );
                }

#endif // TRACING


                /*
                 * Advance our position in the window
                 */
                BufPos += EncMatchLength;

                if (MatchPos >= NUM_REPEATED_OFFSETS)
                    {
                    context->enc_last_matchpos_offset[2] = context->enc_last_matchpos_offset[1];
                    context->enc_last_matchpos_offset[1] = context->enc_last_matchpos_offset[0];
                    context->enc_last_matchpos_offset[0] = MatchPos-(NUM_REPEATED_OFFSETS-1);
                    }
                else if (MatchPos)
                    {
                    ulong t = context->enc_last_matchpos_offset[0];
                    context->enc_last_matchpos_offset[0] = context->enc_last_matchpos_offset[MatchPos];
                    context->enc_last_matchpos_offset[MatchPos] = t;
                    }

                /*
                 * Check to see if we're close to overflowing our output arrays, and
                 * output a block if this is the case
                 */
                if (context->enc_literals >= (MAX_LITERAL_ITEMS-8) ||
                    context->enc_distances >= (MAX_DIST_ITEMS-8))
                    block_end(context, BufPos);

                }  /* EncMatchLength >= FAST_DECISION_THRESHOLD */

            } /* end while ... BufPos < BufPosEnd */

        /*
 * Value of BufPos corresponding to earliest window data
         */
        context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

        /*
         * We didn't read 32K, so we know for sure that
         * this was our last block of data.
         */
        if (BytesRead < CHUNK_SIZE)
            {
            /*
             * If we have never output a block, and we haven't
             * recalculated the stats already, then recalculate
             * the stats and recompress.
             */
            if (context->enc_first_block)
                {
                if (redo_first_block(context, &BufPos))
                    goto top_of_main_loop;
                }

            break;
            }

        /*
         * Remove the last BREAK_LENGTH nodes from the binary search tree,
         * since we have been inserting strings which contain undefined
         * data at the end.
         */
        end_pos = BufPos - (context->enc_window_size-4-BREAK_LENGTH);

        for (i = 1; (i <= BREAK_LENGTH); i++)
            binary_search_remove_node(context, BufPos-i, end_pos);

        /*
         * If we're still in the first window_size + second partition size
         * bytes in the file then we don't need to copymem() yet.
         *
         * RealBufPos is the real position in the file.
         */
        RealBufPos = BufPos - (context->enc_RealMemWindow - context->enc_MemWindow);

        if (RealBufPos < context->enc_window_size + context->enc_encoder_second_partition_size)
            break;

        /*
         * We're about to trash a whole bunch of history with our copymem,
         * so we'd better redo the first block now if we are ever going to.
         */
        if (context->enc_first_block)
            {
            if (redo_first_block(context, &BufPos))
                goto top_of_main_loop;
            }

        /*
         *  We're about to remove a large number of symbols from the window.
         *  Test to see whether, if we were to output a block now, our compressed
         *  output size would be larger than our uncompressed data.  If so, then
         *  we will output an uncompressed block.
         *
         *  The reason we have to do this check here, is that data in the
         *  window is about to be destroyed.  We can't simply put this check in
         *  the block outputting code, since there is no guarantee that the
         *  memory window contents corresponding to everything in that block,
         *  are still around - all we'd have would be a set of literals and
         *  distances, when we need all the uncompressed literals to output
         *  an uncompressed block.
         */

        /*
         *  What value of bufpos corresponds to the oldest data we have in the
         *  buffer?
         *
         *  After the memory copy, that will be the current buffer position,
         *  minus window_size.
         */

        /*
         * The end of the data buffer is reached, more data needs to be read
         * and the existing data must be shifted into the history window.
         *
         * MSVC 4.x generates code which does REP MOVSD so no need to
         * write this in assembly.
         */

#ifdef TESTCODE
        printf( "\rLZX sliding window during compression, BufPos=0x%08X\n", BufPos );
#endif

        copymem(
               &context->enc_RealMemWindow[context->enc_encoder_second_partition_size],
               &context->enc_RealMemWindow[0],
               context->enc_window_size
               );

        copymem(
               &context->enc_RealLeft[context->enc_encoder_second_partition_size],
               &context->enc_RealLeft[0],
               sizeof(ulong)*context->enc_window_size
               );

        copymem(
               &context->enc_RealRight[context->enc_encoder_second_partition_size],
               &context->enc_RealRight[0],
               sizeof(ulong)*context->enc_window_size
               );

        context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

        /*
         *   The following bit of code is CRUCIAL yet unorthodox in function
         *   and serves as a speed and syntax optimization and makes the code
         *   easier to understand once grasped.
         *
         *   The three main buffers, context->enc_MemWindow, context->enc_Left and context->enc_Right,
         *   are referensed by BufPos and SearchPos relative to the current
         *   compression window locations.  When the encoder reaches the end
         *   of its block of input memory, the data in the input buffer is
         *   shifted into the compression history window and the new input
         *   stream is loaded.  Typically the BufPos pointer would be reduced
         *   to signify the replaced data.  However, this code reduces the
         *   base pointers to reflect the shift of data, and leaves the BufPos
         *   pointer in its current state.  Therefore, the BufPos pointer is
         *   an absolute pointer reflecting the position in the input stream,
         *   and NOT the position in the buffer.  The base pointers will point
         *   to invalid memory locations with addresses smaller than the
         *   actual array base pointers.  However, when the two pointers are
         *   added together, &(context->enc_MemWindow+BufPos), it will point to the
         *   correct and valid position in the buffer.
         */

        context->enc_MemWindow -= context->enc_encoder_second_partition_size;
        context->enc_Left      -= context->enc_encoder_second_partition_size;
        context->enc_Right     -= context->enc_encoder_second_partition_size;

        break;
        }

    /*
     * Store BufPos in global variable
     */
    context->enc_BufPos = BufPos;
}


static void block_end(t_encoder_context *context, long BufPos)
{
    context->enc_first_block                        = false;
    context->enc_need_to_recalc_stats       = true;

    output_block(context);

    if (context->enc_literals < TREE_CREATE_INTERVAL)
        {
        context->enc_next_tree_create = TREE_CREATE_INTERVAL;
        }
    else
        {
        context->enc_next_tree_create = context->enc_literals + TREE_CREATE_INTERVAL; /* recreate right away */
        }

    context->enc_bufpos_last_output_block = BufPos;
}


static bool redo_first_block(t_encoder_context *context, long *bufpos_ptr)
{
    long    start_at;
    long    earliest_can_start_at;
    long    pos_in_file;
    long    history_needed;
    long    history_avail;
    long    BufPos;
    long    split_at_literal;

    context->enc_first_block = false;

    BufPos = *bufpos_ptr;

    /*
     * For the first context->enc_window size bytes in the file, we don't
     * need to have context->enc_window size bytes around.
     *
     * For anything after that, though, we do need to have window_size
     * previous bytes to look into.
     */

    /*
     * How many bytes are we into the file?
     */
    pos_in_file = BufPos - context->enc_window_size;

    /*
     * First let's figure out the total history required from
     * BufPos backwards.  For starters, we need all the bytes
     * we're going to recompress.  We get that by seeing the
     * last time we output a block.
     */
    history_needed = BufPos - context->enc_bufpos_last_output_block;

    /*
     * Plus we will need window_size bytes before that (for matching
     * into) unless we're looking within the first window_size
     * bytes of the file.
     */
    if (context->enc_bufpos_last_output_block-context->enc_window_size < context->enc_window_size)
        history_needed += context->enc_bufpos_last_output_block - context->enc_window_size;
    else
        history_needed += context->enc_window_size;

    history_avail = &context->enc_MemWindow[BufPos] - &context->enc_RealMemWindow[0];

    if (history_needed <= history_avail)
        {
        earliest_can_start_at = context->enc_bufpos_last_output_block;
        }
    else
        {
        /*
         * Not enough history available
         */
        return false;
        }

    start_at = earliest_can_start_at;

    split_block(
               context,
               0,
               context->enc_literals,
               context->enc_distances,
               &split_at_literal,
               NULL /* don't need # distances returned */
               );

    get_block_stats(
                   context,
                   0,
                   0,
                   split_at_literal
                   );

    create_trees(context, false); /* don't generate codes */
    fix_tree_cost_estimates(context);

#ifdef MULTIPLE_SEARCH_TREES
    /*
     * Now set all the tree root pointers to NULL
     * (don't need to reset the left/right pointers).
     */
    memset(context->enc_tree_root, 0, NUM_SEARCH_TREES * sizeof(ulong));
#else
    context->enc_single_tree_root = 0;
#endif

    /*
     * Clear item array and reset literal and distance
     * counters
     */
    memset(context->enc_ItemType, 0, (MAX_LITERAL_ITEMS/8));

    /*
     * Reset encoder state
     */
    context->enc_last_matchpos_offset[0] = 1;
    context->enc_last_matchpos_offset[1] = 1;
    context->enc_last_matchpos_offset[2] = 1;

    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    context->enc_input_running_total = 0;

    context->enc_literals      = 0;
    context->enc_distances     = 0;

    context->enc_need_to_recalc_stats = true;

    context->enc_next_tree_create = split_at_literal;

    *bufpos_ptr = start_at;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\pecomp\pecomp.cpp ===
#include <stdlib.h>
#include <stdio.h>

#define WIN32_LEAN_AND_MEAN 1
#define STRICT
#include <windows.h>


typedef unsigned __int64 QWORD;
typedef unsigned __int32 RVA;

#ifndef ROUNDUP
#define ROUNDUP( x, n ) ((((x) + ((n) - 1 )) / (n)) * (n))
#endif

#ifndef ROUNDUP2
#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))
#endif

#ifndef MIN
#define MIN( a, b ) (((a)<(b))?(a):(b))
#endif

#ifndef MAX
#define MAX( a, b ) (((a)>(b))?(a):(b))
#endif

#ifndef countof
#define countof( array ) (sizeof(array)/sizeof(array[0]))
#endif


#define MAX_DIFFS_DISPLAYED 25



#define PECOMP_IGNORE_TIMESTAMPS    0x0000000000000001
#define PECOMP_IGNORE_BINDING_INFO  0x0000000000000002
#define PECOMP_IGNORE_VERSION_INFO  0x0000000000000004
#define PECOMP_IGNORE_BASE_ADDRESS  0x0000000000000008
#define PECOMP_IGNORE_IMAGE_SIZE    0x0000000000000010
#define PECOMP_IGNORE_DOS_HEADER    0x0000000000000020

//      PECOMP_IGNORE_IMPORT_ORDER  0x0000000000000040  (this is difficult because IAT slots move around)

#define PECOMP_IGNORE_LOCALIZATION  0x0000000100000000
#define PECOMP_IGNORE_ALL_RESOURCES 0x0000000200000000

#define PECOMP_SHOW_PRIMARY_DIFFS   0x8000000000000000
#define PECOMP_SHOW_IGNORED_DIFFS   0x4000000000000000

#define PECOMP_SILENT               0x1000000000000000

#define PECOMP_ONLY_PE              0x0800000000000000
#define PECOMP_PE_AS_RAW            0x0400000000000000

#define PECOMP_DEFAULT_FLAGS        0x00000000FFFFFFFF


#define GLE ((DWORD) -1)

#define NORETURN __declspec( noreturn )


QWORD gCompFlags = PECOMP_DEFAULT_FLAGS;

ULONG gDiffSectionCount;

enum IGNORE_TYPE
{
    IgnoreQWORD,
    IgnoreDWORD,
    IgnoreWORD,
    IgnoreBYTE,
    IgnoreTEXT,
};


struct IGNORE_VALUE
{
    PBYTE pbIgnore;
    ULONG cbIgnore;
};


IGNORE_VALUE* gIgnoreArray;
ULONG         gIgnoreCount;


void
AddIgnoreValue(
    IGNORE_TYPE eType,
    QWORD       qwValue
    );


void
ZeroIgnoreValuesInBufferPair(
    PBYTE pbBuffer1,
    PBYTE pbBuffer2,
    ULONG cbBuffer1,
    ULONG cbBuffer2
    );


VOID
NORETURN
ErrorExit(
    DWORD  dwGLE,
    LPCSTR pszFormat,
    ...
    );


VOID __inline ReportDiffNewSection( VOID )
{
    gDiffSectionCount = 0;
}


VOID
ReportDiff(
    LPCSTR pszFormat,
    ...
    );


BOOL
MyMapViewOfFileA(
    IN  LPCSTR  FileName,
    OUT SIZE_T *FileSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    );

ULONG
CompareRawBytes(
    PBYTE  pbData1,
    PBYTE  pbData2,
    ULONG  cbData1,
    ULONG  cbData2,
    LPCSTR SectName
    );

ULONG
CompareFields32(
    DWORD  Value1,
    DWORD  Value2,
    LPCSTR FieldName,
    LPCSTR SectName
    );

PIMAGE_NT_HEADERS
__fastcall
GetNtHeader(
    IN PVOID  MappedFile,
    IN SIZE_T MappedFileSize
    );

SIZE_T
PeCompareMappedFiles32(
    PVOID  MappedFile1,     // destructive!
    SIZE_T FileSize1,
    PVOID  MappedFile2,     // destructive!
    SIZE_T FileSize2
    );

BOOL
RebaseMappedImage32(
    IN PBYTE               MappedFile,
    IN ULONG               FileSize,
    IN PIMAGE_NT_HEADERS32 NtHeader,
    IN ULONG               NewBase
    );

BOOL
UnbindMappedImage(
    IN PVOID MappedFile,
    IN ULONG FileSize,
    IN PIMAGE_NT_HEADERS NtHeader
    );

BOOL
SmashLockPrefixesInMappedImage(
    IN PVOID             MappedFile,
    IN ULONG             FileSize,
    IN PIMAGE_NT_HEADERS NtHeader
    );

VOID
NormalizePe32FileForComparison(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    );

VOID
NormalizePe32Header(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    );

VOID
NormalizePe32Imports(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    );

VOID
NormalizePe32Exports(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    );

VOID
NormalizePe32DebugInfo(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    );

VOID
NormalizePe32Resources(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    );


struct _RESINFO
{
    PIMAGE_NT_HEADERS32 NtHeader;
    PVOID MappedFile;
    ULONG FileSize;
    ULONG ResourceBaseRva;
    PBYTE ResourceBaseMapped;
    ULONG Depth;
    BOOL  VersionTree;
};

typedef struct _RESINFO RESINFO;


struct _RESINFO2
{
    PIMAGE_NT_HEADERS32 NtHeader1;
    PIMAGE_NT_HEADERS32 NtHeader2;
    PVOID MappedFile1;
    PVOID MappedFile2;
    ULONG FileSize1;
    ULONG FileSize2;
    ULONG ResourceBaseRva1;
    ULONG ResourceBaseRva2;
    PBYTE ResourceBaseMapped1;
    PBYTE ResourceBaseMapped2;
    ULONG Depth;
    LPSTR DisplayBuffer;
};

typedef struct _RESINFO2 RESINFO2;


VOID
__fastcall
NormalizePe32ResourceDirectoryTree(
    PIMAGE_RESOURCE_DIRECTORY ResourceDir,
    RESINFO* ResInfo
    );

ULONG
__fastcall
ComparePe32ResourceDirectoryTree(
    PIMAGE_RESOURCE_DIRECTORY ResourceDir1,
    PIMAGE_RESOURCE_DIRECTORY ResourceDir2,
    RESINFO2* ResInfo
    );


VOID __fastcall StripTrailingSpaces( LPSTR String );

VOID
NORETURN
Usage( void )
{
    fprintf(
        stdout,
        "\n"
        "Usage: PECOMP [Options] ExeFile1 ExeFile2\n"
        "\n"
        "\tOptions:\n"
        "\n"
        "\t\t/OnlyPE                (indicate error if files are not PE)\n"
        "\t\t/PeIgnoreAllResources  (versus layout-independent comparison)\n"
        "\t\t/PeIgnoreLocalization  (compare resource structure, not data)\n"
        "\t\t/PeCompareAsRaw        (compare PE files as raw versus PE smart)\n"
        "\t\t/ShowDiffs             (verbose mode displays each difference)\n"
        "\t\t/Silent                (only set return code for batch mode)\n"
//      "\t\t/ShowIgnoredDiffs      (not yet implemented)\n"
        "\t\t/IgnoreQWORD:hexval    (ignore 8-byte QWORDs of given value)\n"
        "\t\t/IgnoreDWORD:hexval    (ignore 4-byte DWORDs of given value)\n"
        "\t\t/IgnoreWORD:hexval     (ignore 2-byte WORDs of given value)\n"
        "\t\t/IgnoreBYTE:hexval     (ignore single BYTEs of given value)\n"
        "\t\t/IgnoreTEXT:abcdefg    (ignore specific text, ascii and unicode)\n"
        "\n"
        "\tReturn codes:\n"
        "\n"
        "\t\t     zero: identical or equivalent files\n"
        "\t\t non-zero: number of differences between files\n"
        "\t\t999999999: error occurred, comparison not performed\n"
        "\n"
        );

    exit( 999999999 );
}


__declspec( noreturn ) void __cdecl main( int argc, char** argv )
{
    LPSTR  FileName1    = NULL;
    SIZE_T FileSize1    = 0;
    HANDLE FileHandle1  = NULL;
    PVOID  MappedFile1  = NULL;

    LPSTR  FileName2    = NULL;
    SIZE_T FileSize2    = 0;
    HANDLE FileHandle2  = NULL;
    PVOID  MappedFile2  = NULL;


    for ( int arg = 1; arg < argc; arg++ )
    {
        char* p = argv[ arg ];

        if ( strchr( p, '?' ))
        {
            Usage();
        }

        if (( *p == '/' ) || ( *p == '-' ))
        {
            ++p;

            if ( ! _stricmp( p, "OnlyPE" ))
            {
                gCompFlags |= PECOMP_ONLY_PE;
            }
            else if ( ! _stricmp( p, "PeOnly" ))
            {
                gCompFlags |= PECOMP_ONLY_PE;
            }
            else if ( ! _stricmp( p, "PeCompareAsRaw" ))
            {
                gCompFlags |= PECOMP_PE_AS_RAW;
            }
            else if ( ! _stricmp( p, "Silent" ))
            {
                gCompFlags |= PECOMP_SILENT;
            }
            else if ( ! _stricmp( p, "ShowDiffs" ))
            {
                gCompFlags |= PECOMP_SHOW_PRIMARY_DIFFS;
            }
            else if ( ! _stricmp( p, "ShowPrimaryDiffs" ))
            {
                gCompFlags |= PECOMP_SHOW_PRIMARY_DIFFS;
            }
            else if ( ! _stricmp( p, "ShowIgnoredDiffs" ))
            {
                gCompFlags |= PECOMP_SHOW_IGNORED_DIFFS;
            }
            else if ( ! _stricmp( p, "PeIgnoreAllResources" ))
            {
                gCompFlags |= PECOMP_IGNORE_ALL_RESOURCES;
            }
            else if ( ! _stricmp( p, "IgnoreAllResources" ))
            {
                gCompFlags |= PECOMP_IGNORE_ALL_RESOURCES;
            }
            else if ( ! _stricmp( p, "PeIgnoreLocalization" ))
            {
                gCompFlags |= PECOMP_IGNORE_LOCALIZATION;
            }
            else if ( ! _stricmp( p, "IgnoreLocalization" ))
            {
                gCompFlags |= PECOMP_IGNORE_LOCALIZATION;
            }
            else if ( ! _strnicmp( p, "IgnoreQWORD:", 12 ))
            {
                AddIgnoreValue( IgnoreQWORD, _strtoui64( p + 12, NULL, 16 ));
            }
            else if ( ! _strnicmp( p, "IgnoreDWORD:", 12 ))
            {
                AddIgnoreValue( IgnoreDWORD, _strtoui64( p + 12, NULL, 16 ));
            }
            else if ( ! _strnicmp( p, "IgnoreWORD:", 11 ))
            {
                AddIgnoreValue( IgnoreWORD, _strtoui64( p + 11, NULL, 16 ));
            }
            else if ( ! _strnicmp( p, "IgnoreBYTE:", 11 ))
            {
                AddIgnoreValue( IgnoreBYTE, _strtoui64( p + 11, NULL, 16 ));
            }
            else if ( ! _strnicmp( p, "IgnoreTEXT:", 11 ))
            {
                AddIgnoreValue( IgnoreTEXT, (QWORD)( p + 11 ));
            }
            else
            {
                Usage();
            }
        }
        else if ( FileName1 == NULL )
        {
            FileName1 = p;
        }
        else if ( FileName2 == NULL )
        {
            FileName2 = p;
        }
        else
        {
            Usage();
        }
    }

    if ( FileName2 == NULL )
    {
        Usage();
    }

    if ( gCompFlags & PECOMP_SILENT )
    {
        gCompFlags &= ~PECOMP_SHOW_PRIMARY_DIFFS;
        gCompFlags &= ~PECOMP_SHOW_IGNORED_DIFFS;
    }

    BOOL Success;

    Success = MyMapViewOfFileA(
                  FileName1,
                  &FileSize1,
                  &FileHandle1,
                  &MappedFile1
                  );

    if ( ! Success )
    {
        ErrorExit( GLE, "Failed to open file %s.\n", FileName1 );
    }

    Success = MyMapViewOfFileA(
                  FileName2,
                  &FileSize2,
                  &FileHandle2,
                  &MappedFile2
                  );

    if ( ! Success )
    {
        ErrorExit( GLE, "Failed to open file %s.\n", FileName2 );
    }

    SIZE_T DiffCount = MAX( FileSize1, FileSize2 );

    LPCSTR FileType = "Raw";

    __try
    {
        PIMAGE_NT_HEADERS NtHeader1 = GetNtHeader( MappedFile1, FileSize1 );
        PIMAGE_NT_HEADERS NtHeader2 = GetNtHeader( MappedFile2, FileSize2 );

        if ( NtHeader1 && NtHeader2 )
        {
            if ( gCompFlags & PECOMP_PE_AS_RAW )
            {
                NtHeader1 = NULL;   // force RAW comparison
                NtHeader2 = NULL;
            }
        }
        else
        {
            if ( gCompFlags & PECOMP_ONLY_PE )
            {
                ErrorExit( 0, "File %s is not a PE file.\n", ( NtHeader1 ? FileName2 : FileName1 ));
            }
        }

        if ( FileSize1 == FileSize2 )   // quick test for identical files
        {
            if ( memcmp( MappedFile1, MappedFile2, FileSize1 ) == 0 )
            {
                if ( ! ( gCompFlags & PECOMP_SILENT ))
                {
                    fprintf( stdout, "IDENTICAL\n" );
                }

                exit( 0 );
            }
        }

        if ( NtHeader1 && NtHeader2 )   // pe comparsion
        {
            FileType = "PE";

            if ( NtHeader1->OptionalHeader.Magic != NtHeader2->OptionalHeader.Magic )
            {
                ErrorExit( 0, "Mismatched PE header magic types.\n" );
            }

            if ( NtHeader1->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC )
            {
                FileType = "PE32";

                DiffCount = PeCompareMappedFiles32(
                                MappedFile1,
                                FileSize1,
                                MappedFile2,
                                FileSize2
                                );
            }
            else if ( NtHeader1->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC )
            {
                FileType = "PE64";

                ErrorExit( 0, "PE64 file comparison is not yet supported.\n" );
            }
            else
            {
                ErrorExit( 0, "Unrecognized PE header magic type.\n" );
            }
        }
        else    // raw comparsion
        {

            ZeroIgnoreValuesInBufferPair(
                (PBYTE) MappedFile1,
                (PBYTE) MappedFile2,
                FileSize1,
                FileSize2
                );

            DiffCount = CompareRawBytes(
                            (PBYTE) MappedFile1,
                            (PBYTE) MappedFile2,
                            FileSize1,
                            FileSize2,
                            "RawFile"
                            );

            ReportDiffNewSection();

            DiffCount += CompareFields32(
                            FileSize1,
                            FileSize2,
                            "FileSize",
                            "RawFile"
                            );
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        ErrorExit( GetExceptionCode(), "Exception occurred while comparing files.\n" );
    }

    if ( ! ( gCompFlags & PECOMP_SILENT ))
    {
        if ( DiffCount != 0 )
        {
            if ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS )
            {
                fprintf( stderr, "\n" );
                fflush( stderr );
            }
        }

        if ( DiffCount == 0 )
        {
            fprintf( stdout, "EQUIVALENT (%s)\n", FileType );
        }
        else if ( DiffCount <= 100 )
        {
            fprintf( stdout, "DIFFERENT (%s): %u or more differences.\n", FileType, DiffCount );
        }
        else
        {
            fprintf( stdout, "DIFFERENT (%s): more than 100 differences.\n", FileType, DiffCount );
        }
    }

    exit( DiffCount );
}


void
AddIgnoreValue(
    IGNORE_TYPE eType,
    QWORD       qwValue
    )
{
    gIgnoreArray = (IGNORE_VALUE*) realloc( gIgnoreArray, (( gIgnoreCount + 2 ) * sizeof( gIgnoreArray[0] )));

    if ( gIgnoreArray == NULL )
    {
        ErrorExit( ERROR_OUTOFMEMORY, "Failed allocating memory for ignore array.\n" );
    }

    if ( eType == IgnoreTEXT )
    {
        if ( qwValue == 0 )
        {
            ErrorExit( 0, "Invalid /IgnoreTEXT.\n" );
        }

        LPCSTR pbTextA = (LPCSTR) qwValue;
        ULONG  cbTextA = strlen( pbTextA );

        if ( cbTextA == 0 )
        {
            ErrorExit( 0, "Invalid /IgnoreTEXT (must be at least one character)\n." );
        }

        gIgnoreArray[ gIgnoreCount ].pbIgnore = (PBYTE) malloc( cbTextA + 1 );

        if ( gIgnoreArray[ gIgnoreCount ].pbIgnore == NULL )
        {
            ErrorExit( ERROR_OUTOFMEMORY, "Failed allocating memory for ignore string.\n" );
        }

        memcpy( gIgnoreArray[ gIgnoreCount ].pbIgnore, pbTextA, cbTextA + 1 );
        gIgnoreArray[ gIgnoreCount ].cbIgnore = cbTextA;
        gIgnoreCount++;

        gIgnoreArray[ gIgnoreCount ].pbIgnore = (PBYTE) malloc(( cbTextA + 1 ) * 2 );

        if ( gIgnoreArray[ gIgnoreCount ].pbIgnore == NULL )
        {
            ErrorExit( ERROR_OUTOFMEMORY, "Failed allocating memory for ignore string.\n" );
        }

        LPWSTR pbTextU = (LPWSTR) gIgnoreArray[ gIgnoreCount ].pbIgnore;
        mbstowcs( pbTextU, pbTextA, cbTextA + 1 );
        ULONG cnTextU = wcslen( pbTextU );

        if ( cnTextU > 0 )
        {
            gIgnoreArray[ gIgnoreCount ].cbIgnore = cnTextU * 2;
            gIgnoreCount++;
        }
    }
    else
    {
        if ( qwValue == 0 )
        {
            ErrorExit( 0, "Invalid /Ignore value (must be non-zero).\n" );
        }

        ULONG cb = 0;

        switch ( eType )
        {
            case IgnoreQWORD: cb = 8; break;
            case IgnoreDWORD: cb = 4; break;
            case IgnoreWORD:  cb = 2; break;
            case IgnoreBYTE:  cb = 1; break;
        }

        if ( cb == 0 )
        {
            ErrorExit( 0, "Invalid /Ignore type.\n" );
        }

        gIgnoreArray[ gIgnoreCount ].pbIgnore = (PBYTE) malloc( cb );

        if ( gIgnoreArray[ gIgnoreCount ].pbIgnore == NULL )
        {
            ErrorExit( ERROR_OUTOFMEMORY, "Failed allocating memory for ignore value.\n" );
        }

        memcpy( gIgnoreArray[ gIgnoreCount ].pbIgnore, &qwValue, cb );
        gIgnoreArray[ gIgnoreCount ].cbIgnore = cb;
        gIgnoreCount++;
    }
}


void
ZeroIgnoreValuesInBufferPair(
    PBYTE pbBuffer1,
    PBYTE pbBuffer2,
    ULONG cbBuffer1,
    ULONG cbBuffer2
    )
{
    for ( unsigned i = 0; i < gIgnoreCount; i++ )
    {
        PBYTE pbIgnore = gIgnoreArray[ i ].pbIgnore;
        ULONG cbIgnore = gIgnoreArray[ i ].cbIgnore;

        if ( cbIgnore > 0 )
        {
            if ( cbIgnore <= cbBuffer1 )
            {
                for ( unsigned j = 0; j < (( cbBuffer1 - cbIgnore ) + 1 ); j++ )
                {
                    if ( pbBuffer1[ j ] == *pbIgnore )
                    {
                        if ( memcmp( pbBuffer1 + j + 1, pbIgnore + 1, cbIgnore - 1 ) == 0 )
                        {
                            memset( pbBuffer1 + j, 0, cbIgnore );

                            for ( unsigned k = 0; ( k < cbIgnore ) && (( j + k ) < cbBuffer2 ); k++ )
                            {
                                pbBuffer2[ j + k ] = 0;
                            }
                        }
                    }
                }
            }

            if ( cbIgnore <= cbBuffer2 )
            {
                for ( unsigned j = 0; j < (( cbBuffer2 - cbIgnore ) + 1 ); j++ )
                {
                    if ( pbBuffer2[ j ] == *pbIgnore )
                    {
                        if ( memcmp( pbBuffer2 + j + 1, pbIgnore + 1, cbIgnore - 1 ) == 0 )
                        {
                            memset( pbBuffer2 + j, 0, cbIgnore );

                            for ( unsigned k = 0; ( k < cbIgnore ) && (( j + k ) < cbBuffer1 ); k++ )
                            {
                                pbBuffer1[ j + k ] = 0;
                            }
                        }
                    }
                }
            }
        }
    }
}


BOOL
MyMapViewOfFileByHandle(
    IN  HANDLE  FileHandle,
    OUT SIZE_T *FileSize,
    OUT PVOID  *MapBase
    )
    {
    ULONG  InternalFileSizeLow;
    ULONG  InternalFileSizeHigh;
    SIZE_T InternalFileSize;
    HANDLE InternalMapHandle;
    PVOID  InternalMapBase;

    InternalFileSizeLow = GetFileSize( FileHandle, &InternalFileSizeHigh );

    InternalFileSize = ((SIZE_T)( InternalFileSizeHigh ) << 32 ) | InternalFileSizeLow;

    if ( InternalFileSize == 0 ) {
        *MapBase  = NULL;
        *FileSize = 0;
        return TRUE;
        }

    InternalMapHandle = CreateFileMapping(
                            FileHandle,
                            NULL,
                            PAGE_WRITECOPY,
                            0,
                            0,
                            NULL
                            );

    if ( InternalMapHandle != NULL ) {

        InternalMapBase = MapViewOfFile(
                              InternalMapHandle,
                              FILE_MAP_COPY,
                              0,
                              0,
                              0
                              );

        CloseHandle( InternalMapHandle );

        if ( InternalMapBase != NULL ) {

            *MapBase  = InternalMapBase;
            *FileSize = InternalFileSize;

            return TRUE;
            }
        }

    return FALSE;
    }


BOOL
MyMapViewOfFileA(
    IN  LPCSTR  FileName,
    OUT SIZE_T *FileSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    )
    {
    HANDLE InternalFileHandle;
    BOOL   Success;

    InternalFileHandle = CreateFileA(
                             FileName,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_SEQUENTIAL_SCAN,
                             NULL
                             );

    if ( InternalFileHandle != INVALID_HANDLE_VALUE ) {

        Success = MyMapViewOfFileByHandle(
                      InternalFileHandle,
                      FileSize,
                      MapBase
                      );

        if ( Success ) {

            *FileHandle = InternalFileHandle;

            return TRUE;
            }

        CloseHandle( InternalFileHandle );
        }

    return FALSE;
    }


PIMAGE_NT_HEADERS
__fastcall
GetNtHeader(
    IN PVOID  MappedFile,
    IN SIZE_T MappedFileSize
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS RetHeader;
    PIMAGE_NT_HEADERS NtHeader;

    RetHeader = NULL;

    __try
    {
        if ( MappedFileSize >= 0x200 )
        {
            DosHeader = (PIMAGE_DOS_HEADER) MappedFile;

            if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE )
            {
                NtHeader = (PIMAGE_NT_HEADERS)((PBYTE) MappedFile + DosHeader->e_lfanew );

                if (((PBYTE) NtHeader + sizeof( IMAGE_NT_HEADERS )) <= ((PBYTE) MappedFile + MappedFileSize ))
                {
                    if ( NtHeader->Signature == IMAGE_NT_SIGNATURE )
                    {
                        RetHeader = NtHeader;
                    }
                }
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {}

    return RetHeader;
}


ULONG
__fastcall
ImageRvaToFileOffset(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG Rva
    )
    {
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG i;

    if ( Rva < NtHeader->OptionalHeader.SizeOfHeaders ) {
        return Rva;
        }

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if (( Rva >= SectionHeader[ i ].VirtualAddress ) &&
            ( Rva <  SectionHeader[ i ].VirtualAddress + SectionHeader[ i ].SizeOfRawData )) {

            return ( SectionHeader[ i ].PointerToRawData + ( Rva - SectionHeader[ i ].VirtualAddress ));
            }
        }

    return 0;
    }


PVOID
__fastcall
ImageRvaToMappedAddress(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG             Rva,
    IN PVOID             MappedBase,
    IN ULONG             MappedSize
    )
    {
    ULONG MappedOffset = ImageRvaToFileOffset( NtHeader, Rva );

    if (( MappedOffset ) && ( MappedOffset < MappedSize )) {
        return ( (PBYTE) MappedBase + MappedOffset );
        }

    return NULL;
    }


ULONG
__fastcall
ImageVaToFileOffset(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG             Va
    )
    {
    return ImageRvaToFileOffset( NtHeader, Va - NtHeader->OptionalHeader.ImageBase );
    }


PVOID
__fastcall
ImageVaToMappedAddress(
    IN PIMAGE_NT_HEADERS NtHeader,
    IN ULONG             Va,
    IN PVOID             MappedBase,
    IN ULONG             MappedSize
    )
    {
    return ImageRvaToMappedAddress( NtHeader, Va - NtHeader->OptionalHeader.ImageBase, MappedBase, MappedSize );
    }


ULONG
__fastcall
ImageDirectoryRvaAndSize(
    IN  PIMAGE_NT_HEADERS NtHeader,
    IN  ULONG             DirectoryIndex,
    OUT PULONG OPTIONAL   DirectorySize
    )
    {
    if ( DirectoryIndex < NtHeader->OptionalHeader.NumberOfRvaAndSizes ) {

        if ( DirectorySize ) {
            *DirectorySize = NtHeader->OptionalHeader.DataDirectory[ DirectoryIndex ].Size;
            }

        return NtHeader->OptionalHeader.DataDirectory[ DirectoryIndex ].VirtualAddress;
        }

    return 0;
    }


ULONG
__fastcall
ImageDirectoryOffsetAndSize(
    IN  PIMAGE_NT_HEADERS NtHeader,
    IN  ULONG             DirectoryIndex,
    OUT PULONG OPTIONAL   DirectorySize
    )
    {
    ULONG Rva = ImageDirectoryRvaAndSize( NtHeader, DirectoryIndex, DirectorySize );

    if ( Rva ) {
        return ImageRvaToFileOffset( NtHeader, Rva );
        }

    return 0;
    }


PVOID
__fastcall
ImageDirectoryMappedAddress(
    IN  PIMAGE_NT_HEADERS NtHeader,
    IN  ULONG             DirectoryIndex,
    OUT PULONG OPTIONAL   DirectorySize,
    IN  PVOID             MappedBase,
    IN  ULONG             MappedSize
    )
{
    PVOID Directory;
    ULONG LocalSize;
    ULONG Rva;

    Rva = ImageDirectoryRvaAndSize( NtHeader, DirectoryIndex, &LocalSize );

    Directory = ImageRvaToMappedAddress( NtHeader, Rva, MappedBase, MappedSize );

    if ( ( Directory ) && (((PBYTE) Directory + LocalSize ) <= ((PBYTE) MappedBase + MappedSize )) )
    {
        if ( DirectorySize )
        {
            *DirectorySize = LocalSize;
        }

        return Directory;
    }

    return NULL;
}


SIZE_T
PeCompareMappedFiles32(
    PVOID  MappedFile1,     // destructive!
    SIZE_T FileSize1,
    PVOID  MappedFile2,     // destructive!
    SIZE_T FileSize2
    )
{
    SIZE_T MaxFileSize = MAX( FileSize1, FileSize2 );
    SIZE_T ReturnValue = MaxFileSize;

    __try
    {
        PIMAGE_NT_HEADERS32 NtHeader1 = GetNtHeader( MappedFile1, FileSize1 );
        PIMAGE_NT_HEADERS32 NtHeader2 = GetNtHeader( MappedFile2, FileSize2 );
        BOOL Success;

        if (( NtHeader1 == NULL ) || ( NtHeader2 == NULL ))
        {
            __leave;
        }

        if ( NtHeader1->OptionalHeader.Magic != NtHeader2->OptionalHeader.Magic )
        {
            __leave;
        }

        if ( NtHeader1->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC )
        {
            __leave;
        }

        ULONG BaseAddress1 = NtHeader1->OptionalHeader.ImageBase;
        ULONG BaseAddress2 = NtHeader2->OptionalHeader.ImageBase;

        if ( BaseAddress2 != BaseAddress1 )
        {
            if ( gCompFlags & PECOMP_IGNORE_BASE_ADDRESS )
            {
                Success = RebaseMappedImage32(
                                   (PBYTE) MappedFile2,
                                   FileSize2,
                                   NtHeader2,
                                   BaseAddress1
                                   );

                if ( ! Success )
                {
                    Success = RebaseMappedImage32(
                                       (PBYTE) MappedFile1,
                                       FileSize1,
                                       NtHeader1,
                                       BaseAddress2
                                       );
                }

                if ( ! Success )
                {
                    ErrorExit( 0, "Failed to rebase PE files to same base address for comparison.\n" );
                }
            }
        }

        //
        //  BUGBUG: If want to display ignored errors, must do it before
        //          overwrite ignored regions with zeros.
        //

        NormalizePe32FileForComparison( MappedFile1, FileSize1, NtHeader1 );

        NormalizePe32FileForComparison( MappedFile2, FileSize2, NtHeader2 );

        //
        //  Now compare section by section, header to header, and
        //  slack space before and after header.
        //

        SIZE_T DiffCount = 0;

        ReportDiffNewSection();

        if ( ! ( gCompFlags & PECOMP_IGNORE_DOS_HEADER ))
        {
            PIMAGE_DOS_HEADER DosHeader1 = (PIMAGE_DOS_HEADER) MappedFile1;
            PIMAGE_DOS_HEADER DosHeader2 = (PIMAGE_DOS_HEADER) MappedFile2;

            ULONG cbData1 = DosHeader1->e_lfanew;
            ULONG cbData2 = DosHeader2->e_lfanew;

            ZeroIgnoreValuesInBufferPair(
                (PBYTE) DosHeader1,
                (PBYTE) DosHeader2,
                cbData1,
                cbData2
                );

            DiffCount += CompareRawBytes( (PBYTE) DosHeader1, (PBYTE) DosHeader2, cbData1, cbData2, "MzHeader" );
        }

        ReportDiffNewSection();

        #define COMPARE_FIELDS( p1, p2, field ) \
            CompareFields32( (p1)->field, (p2)->field, #field, SectName );

        #define SectName "PeHeader"

        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, Signature );

        ReportDiffNewSection();

        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, FileHeader.Machine );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, FileHeader.NumberOfSections );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, FileHeader.TimeDateStamp );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, FileHeader.PointerToSymbolTable );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, FileHeader.NumberOfSymbols );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, FileHeader.SizeOfOptionalHeader );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, FileHeader.Characteristics );

        ReportDiffNewSection();

        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.Magic );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.MajorLinkerVersion );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.MinorLinkerVersion );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.SizeOfCode );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.SizeOfInitializedData );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.SizeOfUninitializedData );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.AddressOfEntryPoint );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.BaseOfCode );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.BaseOfData );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.ImageBase );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.SectionAlignment );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.FileAlignment );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.MajorOperatingSystemVersion );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.MinorOperatingSystemVersion );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.MajorImageVersion );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.MinorImageVersion );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.MajorSubsystemVersion );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.MinorSubsystemVersion );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.Win32VersionValue );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.SizeOfImage );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.SizeOfHeaders );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.CheckSum );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.Subsystem );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.DllCharacteristics );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.SizeOfStackReserve );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.SizeOfStackCommit );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.SizeOfHeapReserve );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.SizeOfHeapCommit );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.LoaderFlags );
        DiffCount += COMPARE_FIELDS( NtHeader1, NtHeader2, OptionalHeader.NumberOfRvaAndSizes );

        ReportDiffNewSection();

        static const LPCSTR PeDirNameAddr[ IMAGE_NUMBEROF_DIRECTORY_ENTRIES ] =
        {
            "Directory[ EXPORT      ].Address",
            "Directory[ IMPORT      ].Address",
            "Directory[ RESOURCE    ].Address",
            "Directory[ EXCEPTION   ].Address",
            "Directory[ SECURITY    ].Address",
            "Directory[ BASERELOC   ].Address",
            "Directory[ DEBUG       ].Address",
            "Directory[ ARCH        ].Address",
            "Directory[ GLOBALPTR   ].Address",
            "Directory[ TLS         ].Address",
            "Directory[ LOAD_CONFIG ].Address",
            "Directory[ BOUNDIMPORT ].Address",
            "Directory[ IAT         ].Address",
            "Directory[ DELAYIMPORT ].Address",
            "Directory[ COMDESC     ].Address",
            "Directory[ 15          ].Address"
        };

        static const LPCSTR PeDirNameSize[ IMAGE_NUMBEROF_DIRECTORY_ENTRIES ] =
        {
            "Directory[ EXPORT      ].Size",
            "Directory[ IMPORT      ].Size",
            "Directory[ RESOURCE    ].Size",
            "Directory[ EXCEPTION   ].Size",
            "Directory[ SECURITY    ].Size",
            "Directory[ BASERELOC   ].Size",
            "Directory[ DEBUG       ].Size",
            "Directory[ ARCH        ].Size",
            "Directory[ GLOBALPTR   ].Size",
            "Directory[ TLS         ].Size",
            "Directory[ LOAD_CONFIG ].Size",
            "Directory[ BOUNDIMPORT ].Size",
            "Directory[ IAT         ].Size",
            "Directory[ DELAYIMPORT ].Size",
            "Directory[ COMDESC     ].Size",
            "Directory[ 15          ].Size"
        };

        for ( unsigned i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++ )
        {
            if ( i != IMAGE_DIRECTORY_ENTRY_BASERELOC )
            {
                DiffCount += CompareFields32(
                                 NtHeader1->OptionalHeader.DataDirectory[ i ].VirtualAddress,
                                 NtHeader2->OptionalHeader.DataDirectory[ i ].VirtualAddress,
                                 PeDirNameAddr[ i ],
                                 SectName
                                 );
            }

            if ( i != IMAGE_DIRECTORY_ENTRY_RESOURCE )
            {
                DiffCount += CompareFields32(
                                 NtHeader1->OptionalHeader.DataDirectory[ i ].Size,
                                 NtHeader2->OptionalHeader.DataDirectory[ i ].Size,
                                 PeDirNameSize[ i ],
                                 SectName
                                 );
            }
        }

        #undef SectName

        ReportDiffNewSection();

        ULONG ResourceDirRva1  = NtHeader1->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].VirtualAddress;
        ULONG ResourceDirSize1 = NtHeader1->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].Size;
        PVOID ResourceDirPtr1  = ImageRvaToMappedAddress( NtHeader1, ResourceDirRva1, MappedFile1, FileSize1 );

        ULONG ResourceDirRva2  = NtHeader2->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].VirtualAddress;
        ULONG ResourceDirSize2 = NtHeader2->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].Size;
        PVOID ResourceDirPtr2  = ImageRvaToMappedAddress( NtHeader2, ResourceDirRva2, MappedFile2, FileSize2 );

        if ( ! ( gCompFlags & PECOMP_IGNORE_ALL_RESOURCES ))
        {
            if (( ResourceDirPtr1 ) && ( ResourceDirPtr2 ))
            {
                RESINFO2 ResInfo;

                ResInfo.NtHeader1           = NtHeader1;
                ResInfo.NtHeader2           = NtHeader2;
                ResInfo.MappedFile1         = MappedFile1;
                ResInfo.MappedFile2         = MappedFile2;
                ResInfo.FileSize1           = FileSize1;
                ResInfo.FileSize2           = FileSize2;
                ResInfo.ResourceBaseRva1    = ResourceDirRva1;
                ResInfo.ResourceBaseRva2    = ResourceDirRva2;
                ResInfo.ResourceBaseMapped1 = (PBYTE) ResourceDirPtr1;
                ResInfo.ResourceBaseMapped2 = (PBYTE) ResourceDirPtr2;
                ResInfo.Depth               = 0;
                ResInfo.DisplayBuffer       = NULL;

                if ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS )
                {
                    ResInfo.DisplayBuffer = (LPSTR) VirtualAlloc( NULL, 0x10000, MEM_COMMIT, PAGE_READWRITE );
                    strcpy( ResInfo.DisplayBuffer, "Resource" );
                }

                DiffCount += ComparePe32ResourceDirectoryTree(
                                 (PIMAGE_RESOURCE_DIRECTORY) ResourceDirPtr1,
                                 (PIMAGE_RESOURCE_DIRECTORY) ResourceDirPtr2,
                                 &ResInfo
                                 );

                if ( ResInfo.DisplayBuffer )
                {
                    VirtualFree( ResInfo.DisplayBuffer, 0, MEM_RELEASE );
                }

                memset( ResourceDirPtr1, 0, ResourceDirSize1 );
                memset( ResourceDirPtr2, 0, ResourceDirSize2 );
            }
        }

        ReportDiffNewSection();

        ULONG RelocDirRva1 = NtHeader1->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ].VirtualAddress;

        PIMAGE_SECTION_HEADER RsrcSection1  = NULL;
        PIMAGE_SECTION_HEADER RelocSection1 = NULL;

        {
            PIMAGE_SECTION_HEADER SectionHeader1 = IMAGE_FIRST_SECTION( NtHeader1 );
            ULONG SectionCount1 = NtHeader1->FileHeader.NumberOfSections;

            while ( SectionCount1-- )
            {
                if (( ResourceDirRva1 >= SectionHeader1->VirtualAddress ) &&
                    ( ResourceDirRva1 <  SectionHeader1->VirtualAddress + SectionHeader1->SizeOfRawData ))
                {
                    RsrcSection1 = SectionHeader1;
                }

                else if (( RelocDirRva1 >= SectionHeader1->VirtualAddress ) &&
                         ( RelocDirRva1 <  SectionHeader1->VirtualAddress + SectionHeader1->SizeOfRawData ))
                {
                    RelocSection1 = SectionHeader1;
                }

                SectionHeader1++;
            }
        }

        PIMAGE_SECTION_HEADER SectionHeader1 = IMAGE_FIRST_SECTION( NtHeader1 );
        PIMAGE_SECTION_HEADER SectionHeader2 = IMAGE_FIRST_SECTION( NtHeader2 );
        ULONG                 SectionCount1  = NtHeader1->FileHeader.NumberOfSections;
        ULONG                 SectionCount2  = NtHeader2->FileHeader.NumberOfSections;
        ULONG                 SectionCountM  = MIN( SectionCount1, SectionCount2 );

        while ( SectionCountM-- )
        {
            CHAR SectName1[ sizeof( SectionHeader1->Name ) + 1 ];
            CHAR SectName2[ sizeof( SectionHeader2->Name ) + 1 ];

            memcpy( SectName1, SectionHeader1->Name, sizeof( SectionHeader1->Name ));
            SectName1[ sizeof( SectionHeader1->Name ) ] = 0;

            memcpy( SectName2, SectionHeader2->Name, sizeof( SectionHeader2->Name ));
            SectName2[ sizeof( SectionHeader2->Name ) ] = 0;

            StripTrailingSpaces( SectName1 );
            StripTrailingSpaces( SectName2 );

            if ( _stricmp( SectName1, SectName2 ) == 0 )
            {
                #define SectName SectName1

                DiffCount += COMPARE_FIELDS( SectionHeader1, SectionHeader2, Characteristics );

                if ( SectionHeader1 != RelocSection1 )  // reloc section might move
                {
                    DiffCount += COMPARE_FIELDS( SectionHeader1, SectionHeader2, VirtualAddress );
                }

                if ( SectionHeader1 != RsrcSection1 )   // resource section might grow
                {
                    DiffCount += COMPARE_FIELDS( SectionHeader1, SectionHeader2, Misc.VirtualSize );
                    DiffCount += COMPARE_FIELDS( SectionHeader1, SectionHeader2, SizeOfRawData );
                }

                #undef SectName

            }
            else
            {
                DiffCount++;

                if ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS )
                {
                    ReportDiffNewSection();

                    ReportDiff(
                        "Section %s does not correspond to section %s at same index\n",
                        SectName1,
                        SectName2
                        );
                }
            }

            SectionHeader1++;
            SectionHeader2++;
        }

        SectionHeader1 = IMAGE_FIRST_SECTION( NtHeader1 );
        SectionHeader2 = IMAGE_FIRST_SECTION( NtHeader2 );
        SectionCountM  = MIN( SectionCount1, SectionCount2 );

        PBYTE pbData1 = (PBYTE)( SectionHeader1 + SectionCount1 );
        PBYTE pbData2 = (PBYTE)( SectionHeader2 + SectionCount2 );
        PBYTE pbStop1 = (PBYTE) MappedFile1 + NtHeader1->OptionalHeader.SizeOfHeaders;
        PBYTE pbStop2 = (PBYTE) MappedFile2 + NtHeader2->OptionalHeader.SizeOfHeaders;
        ULONG cbData1 = ( pbStop1 > pbData1 ) ? ( pbStop1 - pbData1 ) : 0;
        ULONG cbData2 = ( pbStop2 > pbData2 ) ? ( pbStop2 - pbData2 ) : 0;

        DiffCount += CompareRawBytes( pbData1, pbData2, cbData1, cbData2, "PeHeader" );

        while ( SectionCountM-- )
        {
            CHAR SectName1[ sizeof( SectionHeader1->Name ) + 1 ];
            CHAR SectName2[ sizeof( SectionHeader2->Name ) + 1 ];

            memcpy( SectName1, SectionHeader1->Name, sizeof( SectionHeader1->Name ));
            SectName1[ sizeof( SectionHeader1->Name ) ] = 0;

            memcpy( SectName2, SectionHeader2->Name, sizeof( SectionHeader2->Name ));
            SectName2[ sizeof( SectionHeader2->Name ) ] = 0;

            StripTrailingSpaces( SectName1 );
            StripTrailingSpaces( SectName2 );

            if ( _stricmp( SectName1, SectName2 ) == 0 )
            {
                ZeroIgnoreValuesInBufferPair(
                    (PBYTE) MappedFile1 + SectionHeader1->PointerToRawData,
                    (PBYTE) MappedFile2 + SectionHeader2->PointerToRawData,
                    SectionHeader1->SizeOfRawData,
                    SectionHeader2->SizeOfRawData
                    );

                DiffCount += CompareRawBytes(
                                 (PBYTE) MappedFile1 + SectionHeader1->PointerToRawData,
                                 (PBYTE) MappedFile2 + SectionHeader2->PointerToRawData,
                                 SectionHeader1->SizeOfRawData,
                                 SectionHeader2->SizeOfRawData,
                                 SectName1
                                 );
            }
            else
            {
                DiffCount += MAX( SectionHeader1->SizeOfRawData, SectionHeader2->SizeOfRawData );
            }

            SectionHeader1++;
            SectionHeader2++;
        }

        if ( SectionCount1 != SectionCount2 )
        {
            DiffCount++;    // already reported in PE header diffs
        }

        ReturnValue = DiffCount;

        #undef COMPARE_FIELDS
    }

    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        ErrorExit( GetExceptionCode(), "Exception occurred while comparing PE32 files.\n" );
    }

    return ReturnValue;
}



BOOL
RebaseMappedImage32(
    IN PBYTE               MappedFile,
    IN ULONG               FileSize,
    IN PIMAGE_NT_HEADERS32 NtHeader,
    IN ULONG               NewBase
    )
{
    PIMAGE_BASE_RELOCATION RelocBlock;
    LONG    RelocAmount;
    LONG    RelocDirRemaining;
    ULONG   RelocDirSize;
    PBYTE   RelocBlockMa;
    PBYTE   RelocFixupMa;
    ULONG   RelocCount;
    PUSHORT RelocEntry;
    ULONG   RelocType;
    ULONG   RelocOffset;
    PBYTE   MappedFileEnd;

    MappedFileEnd = MappedFile + FileSize;
    RelocAmount   = NewBase - NtHeader->OptionalHeader.ImageBase;

    if ( RelocAmount == 0 )
    {
        return TRUE;    // same address
    }

    if ( NtHeader->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED )
    {
        return FALSE;       // not relocatable
    }

    NtHeader->OptionalHeader.ImageBase = NewBase;

    RelocBlock = (PIMAGE_BASE_RELOCATION) ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_BASERELOC, &RelocDirSize, MappedFile, FileSize );

    //
    //  If no reloc data, but no RELOCS_STRIPPED flag, this indicates
    //  a resource-only or forwarder-only dll that does not require
    //  any relocations to be mapped at other than preferred address.
    //

    if ( RelocBlock )
    {
        RelocDirRemaining = (LONG)RelocDirSize;

        while ( RelocDirRemaining > 0 )
        {
            if ( ( RelocBlock->SizeOfBlock <= (ULONG)RelocDirRemaining ) &&
                 ( RelocBlock->SizeOfBlock > sizeof( IMAGE_BASE_RELOCATION )) )
            {
                RelocBlockMa = MappedFile + ImageRvaToFileOffset( NtHeader, RelocBlock->VirtualAddress );
                RelocEntry   = (PUSHORT)((ULONG)RelocBlock + sizeof( IMAGE_BASE_RELOCATION ));
                RelocCount   = ( RelocBlock->SizeOfBlock - sizeof( IMAGE_BASE_RELOCATION )) / sizeof( USHORT );

                while ( RelocCount-- )
                {
                    RelocOffset  = *RelocEntry & 0x0FFF;
                    RelocType    = *RelocEntry >> 12;
                    RelocFixupMa = RelocBlockMa + RelocOffset;

                    if ( RelocFixupMa < MappedFileEnd )
                    {
                        switch ( RelocType )
                        {
                            case IMAGE_REL_BASED_HIGHLOW:

                                *(LONG UNALIGNED*)RelocFixupMa += RelocAmount;
                                break;

                            case IMAGE_REL_BASED_LOW:

                                *(USHORT UNALIGNED*)RelocFixupMa = (USHORT)( *(SHORT UNALIGNED*)RelocFixupMa + RelocAmount );
                                break;

                            case IMAGE_REL_BASED_HIGH:

                                *(USHORT UNALIGNED*)RelocFixupMa = (USHORT)((( *(USHORT UNALIGNED*)RelocFixupMa << 16 ) + RelocAmount ) >> 16 );
                                break;

                            case IMAGE_REL_BASED_HIGHADJ:

                                ++RelocEntry;
                                --RelocCount;

                                *(USHORT UNALIGNED*)RelocFixupMa = (USHORT)((( *(USHORT UNALIGNED*)RelocFixupMa << 16 ) +
                                                                               *(SHORT UNALIGNED*)RelocEntry + RelocAmount + 0x8000 ) >> 16 );
                                break;

                            case IMAGE_REL_BASED_ABSOLUTE:

                                break;

                            default:

                                ReportDiff(
                                       "Skipping unrecognized relocation type %u for RVA 0x%08X in second file\n",
                                       RelocType,
                                       RelocBlock->VirtualAddress + RelocOffset
                                       );

                                break;

                        }
                    }

                    ++RelocEntry;
                }
            }

            RelocDirRemaining -= RelocBlock->SizeOfBlock;
            RelocBlock = (PIMAGE_BASE_RELOCATION)((ULONG)RelocBlock + RelocBlock->SizeOfBlock );
        }
    }

    return TRUE;
}


VOID
NormalizePe32FileForComparison(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    )
{
    if ( gCompFlags & PECOMP_IGNORE_BINDING_INFO )
    {
        UnbindMappedImage(
            MappedFile,
            FileSize,
            NtHeader
            );

        //
        //  BUGBUG: Not dealing with bound delay imports here because there
        //          is currently no tool that actually binds delay imports.
        //
    }

    SmashLockPrefixesInMappedImage( MappedFile, FileSize, NtHeader );

    NormalizePe32Exports( MappedFile, FileSize, NtHeader );

    NormalizePe32Imports( MappedFile, FileSize, NtHeader );

    NormalizePe32DebugInfo( MappedFile, FileSize, NtHeader );

    NormalizePe32Resources( MappedFile, FileSize, NtHeader );

    NormalizePe32Header( MappedFile, FileSize, NtHeader );
}


VOID
NormalizePe32Header(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    )
{
    FileSize = FileSize;

    PIMAGE_SECTION_HEADER SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    ULONG SectionCount = NtHeader->FileHeader.NumberOfSections;

    while ( SectionCount-- )
    {
        SectionHeader->SizeOfRawData    = ROUNDUP2( SectionHeader->SizeOfRawData,    NtHeader->OptionalHeader.FileAlignment );
        SectionHeader->Misc.VirtualSize = ROUNDUP2( SectionHeader->Misc.VirtualSize, NtHeader->OptionalHeader.SectionAlignment );
        SectionHeader++;
    }

    NtHeader->OptionalHeader.SizeOfHeaders = ROUNDUP2( NtHeader->OptionalHeader.SizeOfHeaders, NtHeader->OptionalHeader.FileAlignment );

    NtHeader->OptionalHeader.CheckSum = 0;

    if ( gCompFlags & PECOMP_IGNORE_TIMESTAMPS )
    {
        NtHeader->FileHeader.TimeDateStamp = 0;
    }

    if ( gCompFlags & PECOMP_IGNORE_VERSION_INFO )
    {
        NtHeader->OptionalHeader.MajorLinkerVersion = 0;
        NtHeader->OptionalHeader.MinorLinkerVersion = 0;
        NtHeader->OptionalHeader.MajorOperatingSystemVersion = 0;
        NtHeader->OptionalHeader.MinorOperatingSystemVersion = 0;
        NtHeader->OptionalHeader.MajorImageVersion = 0;
        NtHeader->OptionalHeader.MinorImageVersion = 0;
        NtHeader->OptionalHeader.MajorSubsystemVersion = 0;
        NtHeader->OptionalHeader.MinorSubsystemVersion = 0;
        NtHeader->OptionalHeader.Win32VersionValue = 0;
    }

    if ( gCompFlags & PECOMP_IGNORE_DOS_HEADER )
    {
        PBYTE pbDosHeader = (PBYTE) MappedFile;
        PBYTE pbNtHeader  = (PBYTE) NtHeader;

        memset( pbDosHeader, 0, ( pbNtHeader - pbDosHeader ));
    }

    if ( gCompFlags & PECOMP_IGNORE_IMAGE_SIZE )
    {
        NtHeader->OptionalHeader.SizeOfCode = 0;
        NtHeader->OptionalHeader.SizeOfInitializedData = 0;
        NtHeader->OptionalHeader.SizeOfUninitializedData = 0;
        NtHeader->OptionalHeader.SizeOfImage = 0;
        NtHeader->OptionalHeader.SizeOfHeaders = 0;
    }
}


BOOL
UnbindMappedImage(
    IN PVOID MappedFile,
    IN ULONG FileSize,
    IN PIMAGE_NT_HEADERS NtHeader
    )
{
    PIMAGE_SECTION_HEADER    SectionHeader;
    ULONG                    SectionCount;
    QWORD                    SectionName;
    PIMAGE_IMPORT_DESCRIPTOR ImportDesc;
    PVOID                    BoundImportDir;
    ULONG                    BoundImportSize;
    PULONG                   OriginalIat;
    PULONG                   BoundIat;
    PBYTE                    MappedFileEnd;
    ULONG                    i;

    MappedFileEnd  = (PBYTE) MappedFile + FileSize;
    BoundImportDir = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT, &BoundImportSize, MappedFile, FileSize );

    if ( BoundImportDir )
    {
        //
        //  Zero the bound import directory and pointers to bound
        //  import directory.
        //

        ZeroMemory( BoundImportDir, BoundImportSize );

        NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress = 0;
        NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size           = 0;
    }

    //
    //  Now walk imports and zero the TimeDate and
    //  ForwarderChain fields.
    //

    ImportDesc = (PIMAGE_IMPORT_DESCRIPTOR) ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_IMPORT, NULL, MappedFile, FileSize );

    if ( ImportDesc )
    {
        while ( ((ULONG)ImportDesc < ((ULONG)MappedFileEnd - sizeof( IMAGE_IMPORT_DESCRIPTOR ))) &&
                ( ImportDesc->Characteristics ) )
        {
            if ( ImportDesc->TimeDateStamp )
            {
                //
                //  This is a bound import.  Copy the unbound
                //  IAT over the bound IAT to restore.
                //

                ImportDesc->TimeDateStamp = 0;

                OriginalIat = (PULONG) ImageRvaToMappedAddress( NtHeader, (ULONG)ImportDesc->OriginalFirstThunk, MappedFile, FileSize );
                BoundIat    = (PULONG) ImageRvaToMappedAddress( NtHeader, (ULONG)ImportDesc->FirstThunk,         MappedFile, FileSize );

                if (( OriginalIat ) && ( BoundIat ))
                {
                    while ( ((PBYTE)OriginalIat < MappedFileEnd ) &&
                            ((PBYTE)BoundIat    < MappedFileEnd ) &&
                            ( *OriginalIat ) )
                    {
                        *BoundIat++ = *OriginalIat++;
                    }
                }
            }

            if ( ImportDesc->ForwarderChain )
            {
                ImportDesc->ForwarderChain = 0;
            }

            ++ImportDesc;
        }
    }

    //
    //  The bind utility marks the .idata section as read-only so we want to
    //  change it back to read-write if a separate .idata section exists.
    //

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ )
    {
        SectionName  = *(QWORD UNALIGNED*)( &SectionHeader[ i ].Name );
        SectionName |= 0x2020202020202020;          // fast lower case

        if ( SectionName == 0x202061746164692E )    // ".idata  "
        {
            if ( ! ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_WRITE ) )
            {
                SectionHeader[ i ].Characteristics |= ( IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE );
            }

            break;
        }
    }

    return TRUE;
}


BOOL
SmashLockPrefixesInMappedImage(
    IN PVOID             MappedFile,
    IN ULONG             FileSize,
    IN PIMAGE_NT_HEADERS NtHeader
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY LoadConfig;
    PBYTE* LockPrefixEntry;
    PBYTE  LockPrefixInstruction;

    LoadConfig = (PIMAGE_LOAD_CONFIG_DIRECTORY) ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, NULL, MappedFile, FileSize );

    if (( LoadConfig ) && ( LoadConfig->LockPrefixTable ))
    {
        //
        //  The LoadConfig->LockPrefixTable field and
        //  the lock prefix addresses are stored in the
        //  image as image VA, not RVA values.
        //

        LockPrefixEntry = (PBYTE*) ImageVaToMappedAddress( NtHeader, (ULONG)( LoadConfig->LockPrefixTable ), MappedFile, FileSize );

        if ( LockPrefixEntry )
        {
            while ( *LockPrefixEntry )
            {
                LockPrefixInstruction = (PBYTE) ImageVaToMappedAddress( NtHeader, (ULONG)( *LockPrefixEntry ), MappedFile, FileSize );

                if ( LockPrefixInstruction )
                {
                    if ( *LockPrefixInstruction != 0x90 )
                    {
                         *LockPrefixInstruction  = 0x90;
                    }
                }

                ++LockPrefixEntry;
            }
        }
    }

    return TRUE;
}


VOID
NormalizePe32Exports(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    )
{
    ULONG ExportDirRva  = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ].VirtualAddress;

    PIMAGE_EXPORT_DIRECTORY ExportDir = (PIMAGE_EXPORT_DIRECTORY) ImageRvaToMappedAddress( NtHeader, ExportDirRva, MappedFile, FileSize );

    if ( ExportDir )
    {
        if ( gCompFlags & PECOMP_IGNORE_TIMESTAMPS )
        {
            ExportDir->TimeDateStamp = 0;
        }

        if ( gCompFlags & PECOMP_IGNORE_VERSION_INFO )
        {
            ExportDir->MajorVersion = 0;
            ExportDir->MinorVersion = 0;
        }

        if ( ExportDir->Name != 0 )
        {
            LPSTR MappedName = (LPSTR) ImageRvaToMappedAddress( NtHeader, ExportDir->Name, MappedFile, FileSize );

            if ( MappedName )
            {
                _strlwr( MappedName );
            }
        }
    }
}


VOID
NormalizePe32Imports(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    )
{
    ULONG ImportDescRva = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ].VirtualAddress;

    PIMAGE_IMPORT_DESCRIPTOR ImportDesc = (PIMAGE_IMPORT_DESCRIPTOR) ImageRvaToMappedAddress( NtHeader, ImportDescRva, MappedFile, FileSize );

    if ( ImportDesc )
    {
        while ( ImportDesc->Characteristics != 0 )
        {
            LPSTR ImportDllName = (LPSTR) ImageRvaToMappedAddress( NtHeader, ImportDesc->Name, MappedFile, FileSize );

            if ( ImportDllName )
            {
                _strlwr( ImportDllName );
            }

            if ( gCompFlags & PECOMP_IGNORE_BINDING_INFO )
            {
                ImportDesc->TimeDateStamp = 0;
            }

            PIMAGE_THUNK_DATA OrgThunk = (PIMAGE_THUNK_DATA) ImageRvaToMappedAddress( NtHeader, ImportDesc->OriginalFirstThunk, MappedFile, FileSize );

            if (( OrgThunk == NULL ) && ( ImportDesc->TimeDateStamp == 0 ))
            {
                // not bound, use IAT
                OrgThunk = (PIMAGE_THUNK_DATA) ImageRvaToMappedAddress( NtHeader, ImportDesc->FirstThunk, MappedFile, FileSize );
            }

            if ( OrgThunk )
            {
                for ( unsigned i = 0; OrgThunk[ i ].u1.Ordinal != 0; i++ )
                {
                    if ( ! IMAGE_SNAP_BY_ORDINAL( OrgThunk[ i ].u1.Ordinal ))
                    {
                        PIMAGE_IMPORT_BY_NAME ImportByName = (PIMAGE_IMPORT_BY_NAME) ImageRvaToMappedAddress( NtHeader, OrgThunk[ i ].u1.AddressOfData, MappedFile, FileSize );

                        if ( ImportByName )
                        {
                            ImportByName->Hint = 0;
                        }
                    }
                }
            }

            ImportDesc++;
        }
    }
}


VOID
NormalizePe32DebugInfo(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    )
{
    ULONG DebugDirectoryRva   = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_DEBUG ].VirtualAddress;
    ULONG DebugDirectorySize  = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_DEBUG ].Size;
    ULONG DebugDirectoryCount = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

    PIMAGE_DEBUG_DIRECTORY DebugDirectory = (PIMAGE_DEBUG_DIRECTORY) ImageRvaToMappedAddress( NtHeader, DebugDirectoryRva, MappedFile, FileSize );

    if ( DebugDirectory )
    {
        for ( unsigned j = 0; j < DebugDirectoryCount; j++ )
        {
            if ( gCompFlags & PECOMP_IGNORE_TIMESTAMPS )
            {
                DebugDirectory[ j ].TimeDateStamp = 0;
            }

            if ( gCompFlags & PECOMP_IGNORE_VERSION_INFO )
            {
                DebugDirectory[ j ].MajorVersion = 0;
                DebugDirectory[ j ].MinorVersion = 0;
            }

            DebugDirectory[ j ].PointerToRawData = 0;

            PBYTE pbData = (PBYTE) ImageRvaToMappedAddress( NtHeader, DebugDirectory[ j ].AddressOfRawData, MappedFile, FileSize );
            ULONG cbData = DebugDirectory[ j ].SizeOfData;

            if (( pbData ) && ( cbData ))
            {
                memset( pbData, 0, cbData );
            }
        }
    }
}


VOID
NormalizePe32Resources(
    PVOID MappedFile,
    ULONG FileSize,
    PIMAGE_NT_HEADERS32 NtHeader
    )
{
    ULONG ResourceBaseRva    = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].VirtualAddress;
    ULONG ResourceTotalSize  = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].Size;
    PBYTE ResourceBaseMapped = (PBYTE) ImageRvaToMappedAddress( NtHeader, ResourceBaseRva, MappedFile, FileSize );

    if ( ResourceBaseMapped )
    {
        PIMAGE_SECTION_HEADER ResourceSection = NULL;
        PIMAGE_SECTION_HEADER SectionHeader   = IMAGE_FIRST_SECTION( NtHeader );
        ULONG                 SectionCount    = NtHeader->FileHeader.NumberOfSections;

        while ( SectionCount-- )
        {
            if (( ResourceBaseRva >= SectionHeader->VirtualAddress ) &&
                ( ResourceBaseRva <  SectionHeader->VirtualAddress + SectionHeader->SizeOfRawData ))
            {
                ResourceSection = SectionHeader;
                break;
            }

            SectionHeader++;
        }

        if ( gCompFlags & PECOMP_IGNORE_ALL_RESOURCES )
        {
            if ( ResourceSection )
            {
                PBYTE pbData = (PBYTE)MappedFile + ResourceSection->PointerToRawData;
                ULONG cbData = ResourceSection->SizeOfRawData;

                memset( pbData, 0, cbData );
            }
            else
            {
                memset( ResourceBaseMapped, 0, ResourceTotalSize );
            }
        }
        else
        {
            RESINFO ResInfo;

            ResInfo.ResourceBaseRva    = ResourceBaseRva;
            ResInfo.ResourceBaseMapped = ResourceBaseMapped;
            ResInfo.NtHeader           = NtHeader;
            ResInfo.MappedFile         = MappedFile;
            ResInfo.FileSize           = FileSize;
            ResInfo.Depth              = 0;
            ResInfo.VersionTree        = FALSE;

            PIMAGE_RESOURCE_DIRECTORY RootDir = (PIMAGE_RESOURCE_DIRECTORY) ResourceBaseMapped;

            NormalizePe32ResourceDirectoryTree( RootDir, &ResInfo );

            if ( ResourceSection )
            {
                if ( ResourceSection->SizeOfRawData > ResourceTotalSize )
                {
                    //
                    //  The stupid localization tool inserts non-zero padding
                    //  bytes to fill-out the resource section to FileAlignment
                    //  boundary.  The pattern looks like "PADDINGXXPADDING".
                    //

                    ULONG cbPadding = ResourceSection->SizeOfRawData - ResourceTotalSize;
                    PBYTE pbPadding = (PBYTE)MappedFile + ResourceSection->PointerToRawData + ResourceTotalSize;

                    memset( pbPadding, 0, cbPadding );
                }
            }
        }
    }
}


VOID
__fastcall
NormalizePe32ResourceDirectoryTree(
    PIMAGE_RESOURCE_DIRECTORY ResourceDir,
    RESINFO* ResInfo
    )
{
    ResInfo->Depth++;

    if ( gCompFlags & PECOMP_IGNORE_TIMESTAMPS )
    {
        ResourceDir->TimeDateStamp = 0;
    }

    if ( gCompFlags & PECOMP_IGNORE_VERSION_INFO )
    {
        ResourceDir->MajorVersion = 0;
        ResourceDir->MinorVersion = 0;
    }

    ULONG ResourceCount = ResourceDir->NumberOfNamedEntries
                        + ResourceDir->NumberOfIdEntries;

    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( ResourceDir + 1 );

    while ( ResourceCount-- )
    {
        ULONG OffsetToData = ResourceEntry->OffsetToData & 0x7FFFFFFF;

        if ( ResourceEntry->DataIsDirectory )
        {
            if (( ResourceEntry->Name == (DWORD) RT_VERSION ) && ( ResInfo->Depth == 1  ))
            {
                ResInfo->VersionTree = TRUE;
            }

            NormalizePe32ResourceDirectoryTree(
                (PIMAGE_RESOURCE_DIRECTORY)( ResInfo->ResourceBaseMapped + OffsetToData ),
                ResInfo
                );

            if (( ResourceEntry->Name == (DWORD) RT_VERSION ) && ( ResInfo->Depth == 1  ))
            {
                ResInfo->VersionTree = FALSE;
            }
        }
        else
        {
            PIMAGE_RESOURCE_DATA_ENTRY ResourceData = (PIMAGE_RESOURCE_DATA_ENTRY)( ResInfo->ResourceBaseMapped + OffsetToData );

            if ( gCompFlags & PECOMP_IGNORE_LOCALIZATION )
            {
                ResourceData->CodePage = 0;

                if (( ResInfo->Depth == 3 ) &&
                    ( ! ResourceEntry->NameIsString ) &&
                    ( ResourceEntry->Id >= 0x400 ))
                {
                    ResourceEntry->Id = 0;
                }
            }

            if (( ResInfo->VersionTree ) && ( gCompFlags & PECOMP_IGNORE_VERSION_INFO ))
            {
                //
                //  BUGBUG:  Contrary to what the winnt.h header file says, the
                //           IMAGE_RESOURCE_DATA_ENTRY.OffsetToData field appears
                //           to be an RVA, not offset from beginning of directory.
                //

                ULONG rvaData = ResourceData->OffsetToData;
                PBYTE pbData  = (PBYTE) ImageRvaToMappedAddress( ResInfo->NtHeader, rvaData, ResInfo->MappedFile, ResInfo->FileSize );
                ULONG cbData  = ResourceData->Size;

                if (( pbData ) && ( cbData ))
                {
                    memset( pbData, 0, cbData );
                }

                ResourceData->OffsetToData = 0;
                ResourceData->Size = 0;
            }
        }

        ResourceEntry++;
    }

    ResInfo->Depth--;
}


ULONG
CompareRawBytes(
    PBYTE  pbData1,
    PBYTE  pbData2,
    ULONG  cbData1,
    ULONG  cbData2,
    LPCSTR SectName
    )
{
    ULONG cbDataM = MIN( cbData1, cbData2 );
    ULONG DiffCount = 0;
    ULONG i;

    for ( i = 0; i < cbDataM; i++ )
    {
        if ( pbData1[ i ] != pbData2[ i ] )
        {
            ++DiffCount;
        }
    }

    for ( ; i < cbData1; i++ )
    {
        if ( pbData1[ i ] != 0 )
        {
            ++DiffCount;
        }
    }

    for ( ; i < cbData2; i++ )
    {
        if ( pbData2[ i ] != 0 )
        {
            ++DiffCount;
        }
    }

    if (( DiffCount != 0 ) && ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS ))
    {
        ULONG DisplayCount = 0;

        ReportDiffNewSection();

        for ( i = 0; i < cbDataM; i++ )
        {
            if ( pbData1[ i ] != pbData2[ i ] )
            {
                if ( DisplayCount > MAX_DIFFS_DISPLAYED )
                {
                    break;
                }

                DisplayCount++;

                ReportDiff(
                    "%-8s (%05X):  %02X %02X  %c %c\n",
                    SectName,
                    i,
                    pbData1[ i ],
                    pbData2[ i ],
                    ((signed char)pbData1[ i ] > 0x20 ) ? pbData1[ i ] : ' ',
                    ((signed char)pbData2[ i ] > 0x20 ) ? pbData2[ i ] : ' '
                    );
            }
        }

        for ( ; i < cbData1; i++ )
        {
            if ( pbData1[ i ] != 0 )
            {
                if ( DisplayCount > MAX_DIFFS_DISPLAYED )
                {
                    break;
                }

                DisplayCount++;

                ReportDiff(
                    "%-8s (%05X):  %02X %02X  %c %c\n",
                    SectName,
                    i,
                    pbData1[ i ],
                    0,
                    ((signed char)pbData1[ i ] > 0x20 ) ? pbData1[ i ] : ' ',
                    ' '
                    );

            }
        }

        for ( ; i < cbData2; i++ )
        {
            if ( pbData2[ i ] != 0 )
            {
                if ( DisplayCount > MAX_DIFFS_DISPLAYED )
                {
                    break;
                }

                DisplayCount++;

                ReportDiff(
                    "%-8s (%05X):  %02X %02X  %c %c\n",
                    SectName,
                    i,
                    0,
                    pbData2[ i ],
                    ' ',
                    ((signed char)pbData2[ i ] > 0x20 ) ? pbData2[ i ] : ' '
                    );
            }
        }

        if ( DiffCount > DisplayCount )
        {
            ReportDiffNewSection();

            ReportDiff(
                "%-8s %u more differences not shown\n",
                SectName,
                DiffCount - DisplayCount
                );
        }
    }

    if ( DiffCount != 0 )
    {
        ReportDiffNewSection();
    }

    return DiffCount;
}


ULONG
CompareFields32(
    DWORD  Value1,
    DWORD  Value2,
    LPCSTR FieldName,
    LPCSTR SectName
    )
{
    if ( Value1 != Value2 )
    {
        if ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS )
        {
            ReportDiff(
                "%-8s->%-45s %08X != %08X\n",
                SectName,
                FieldName,
                Value1,
                Value2
                );
        }

        return 1;
    }

    return 0;
}


VOID __fastcall StripTrailingSpaces( LPSTR String )
{
    LPSTR p = String + strlen( String ) - 1;

    while (( p >= String ) && ( *p == ' ' ))
    {
        *p-- = 0;
    }
}


BOOL
__fastcall
IsMatchingResourceString(
    const IMAGE_RESOURCE_DIR_STRING_U *String1,
    const IMAGE_RESOURCE_DIR_STRING_U *String2
    )
{
    if ( String1->Length != String2->Length )
    {
        return FALSE;
    }

    unsigned Length = String1->Length;

    for ( unsigned i = 0; i < Length; i++ )
    {
        if ( String1->NameString[ i ] != String2->NameString[ i ] )
        {
            return FALSE;
        }

    }

    return TRUE;
}


const LPCSTR ResTypeToName[] =                  //  taken from winuser.h
                {
                    NULL,                       //  0
                    "RT_CURSOR",                //  1
                    "RT_BITMAP",                //  2
                    "RT_ICON",                  //  3
                    "RT_MENU",                  //  4
                    "RT_DIALOG",                //  5
                    "RT_STRING",                //  6
                    "RT_FONTDIR",               //  7
                    "RT_FONT",                  //  8
                    "RT_ACCELERATOR",           //  9
                    "RT_RCDATA",                // 10
                    "RT_MESSAGETABLE",          // 11
                    "RT_GROUP_CURSOR",          // 12
                    NULL,                       // 13
                    "RT_GROUP_ICON",            // 14
                    NULL,                       // 15
                    "RT_VERSION",               // 16
                    "RT_DLGINCLUDE",            // 17
                    NULL,                       // 18
                    "RT_PLUGPLAY",              // 19
                    "RT_VXD",                   // 20
                    "RT_ANICURSOR",             // 21
                    "RT_ANIICON",               // 22
                    "RT_HTML",                  // 23
                    "RT_MANIFEST",              // 24
                    NULL                        // 25
                };


LPSTR
GetResourceEntryName(
    IN  PIMAGE_RESOURCE_DIRECTORY_ENTRY ResEntry,
    IN  PBYTE ResBase,
    IN  ULONG Depth,
    OUT LPSTR Buffer
    )
{
    if ( ResEntry->NameIsString )
    {
        PIMAGE_RESOURCE_DIR_STRING_U ResNameU = (PIMAGE_RESOURCE_DIR_STRING_U)( ResBase + ResEntry->NameOffset );

        strcpy( Buffer, "???" );    // in case translation failure

        int cbActual = WideCharToMultiByte(
                           CP_OEMCP,
                           0,
                           ResNameU->NameString,
                           ResNameU->Length,
                           Buffer,
                           0xFFFF,
                           NULL,
                           NULL
                           );

        Buffer[ cbActual ] = 0;     // force termination
    }
    else
    {
        if (( Depth == 1 ) &&
            ( ResEntry->Id < countof( ResTypeToName )) &&
            ( ResTypeToName[ ResEntry->Id ] != NULL ))
        {
            strcpy( Buffer, ResTypeToName[ ResEntry->Id ] );
        }
        else if (( Depth == 3 ) &&
                 ( ! ResEntry->DataIsDirectory ) &&
                 ( ResEntry->Id >= 0x400 ))
        {
            DWORD n = VerLanguageName( ResEntry->Id, Buffer + 1, 0xFFFF );
            Buffer[ 0     ] = '[';
            Buffer[ n + 1 ] = ']';
            Buffer[ n + 2 ] = 0;
        }
        else
        {
            sprintf( Buffer, "#%u", ResEntry->Id );
        }
    }

    return Buffer;
}





ULONG
__fastcall
ComparePe32ResourceDirectoryTree(
    PIMAGE_RESOURCE_DIRECTORY ResourceDir1,
    PIMAGE_RESOURCE_DIRECTORY ResourceDir2,
    RESINFO2* ResInfo
    )
{
    ResInfo->Depth++;

    ULONG DiffCount = 0;
    LPSTR DisplayBufPtr = NULL;

    if ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS )
    {
        DisplayBufPtr = ResInfo->DisplayBuffer + strlen( ResInfo->DisplayBuffer );
    }

    #define COMPARE_FIELDS( p1, p2, field ) \
        CompareFields32( (p1)->field, (p2)->field, #field, ResInfo->DisplayBuffer );

    DiffCount += COMPARE_FIELDS( ResourceDir1, ResourceDir2, Characteristics );
    DiffCount += COMPARE_FIELDS( ResourceDir1, ResourceDir2, TimeDateStamp );
    DiffCount += COMPARE_FIELDS( ResourceDir1, ResourceDir2, MajorVersion );
    DiffCount += COMPARE_FIELDS( ResourceDir1, ResourceDir2, MinorVersion );
    DiffCount += COMPARE_FIELDS( ResourceDir1, ResourceDir2, NumberOfNamedEntries );
    DiffCount += COMPARE_FIELDS( ResourceDir1, ResourceDir2, NumberOfIdEntries );

    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceEntry1 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( ResourceDir1 + 1 );
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceEntry2 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( ResourceDir2 + 1 );

    ULONG ResourceCount1 = ResourceDir1->NumberOfNamedEntries
                         + ResourceDir1->NumberOfIdEntries;

    ULONG ResourceCount2 = ResourceDir2->NumberOfNamedEntries
                         + ResourceDir2->NumberOfIdEntries;

    for ( unsigned i = 0; i < ResourceCount1; i++ )
    {
        PIMAGE_RESOURCE_DIR_STRING_U ResName1 = NULL;

        if ( ResourceEntry1[ i ].NameIsString )
        {
            ResName1 = (PIMAGE_RESOURCE_DIR_STRING_U)( ResInfo->ResourceBaseMapped1 + ResourceEntry1[ i ].NameOffset );
        }

        if ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS )
        {
            DisplayBufPtr[ 0 ] = '\\';
            DisplayBufPtr[ 1 ] = '\0';

            GetResourceEntryName( &ResourceEntry1[ i ], ResInfo->ResourceBaseMapped1, ResInfo->Depth, DisplayBufPtr + 1 );
        }

        bool Match = false;

        for ( unsigned j = 0; j < ResourceCount2; j++ )
        {
            if ( ResourceEntry2[ j ].Name != 0xFFFFFFFF )
            {
                if ( ResourceEntry2[ j ].NameIsString )
                {
                    if ( ResName1 != NULL )
                    {
                        PIMAGE_RESOURCE_DIR_STRING_U ResName2 = (PIMAGE_RESOURCE_DIR_STRING_U)( ResInfo->ResourceBaseMapped2 + ResourceEntry2[ j ].NameOffset );

                        if ( IsMatchingResourceString( ResName1, ResName2 ))
                        {
                            Match = true;
                            break;
                        }
                    }
                }
                else
                {
                    if ( ResName1 == NULL )
                    {
                        if ( ResourceEntry1[ i ].Id == ResourceEntry2[ j ].Id )
                        {
                            Match = true;
                            break;
                        }
                    }
                }
            }
        }

        if ( Match )
        {
            DiffCount += COMPARE_FIELDS( &ResourceEntry1[ i ], &ResourceEntry2[ j ], DataIsDirectory );

            if (( ResourceEntry1[ i ].DataIsDirectory ) &&
                ( ResourceEntry2[ j ].DataIsDirectory ))
            {
                PIMAGE_RESOURCE_DIRECTORY ChildDir1 = (PIMAGE_RESOURCE_DIRECTORY)( ResInfo->ResourceBaseMapped1 + ResourceEntry1[ i ].OffsetToDirectory );
                PIMAGE_RESOURCE_DIRECTORY ChildDir2 = (PIMAGE_RESOURCE_DIRECTORY)( ResInfo->ResourceBaseMapped2 + ResourceEntry2[ j ].OffsetToDirectory );

                DiffCount += ComparePe32ResourceDirectoryTree(
                                 ChildDir1,
                                 ChildDir2,
                                 ResInfo
                                 );
            }

            else if (( ! ResourceEntry1[ i ].DataIsDirectory ) &&
                     ( ! ResourceEntry2[ j ].DataIsDirectory ))
            {
                if ( ! ( gCompFlags & PECOMP_IGNORE_LOCALIZATION ))
                {
                    PIMAGE_RESOURCE_DATA_ENTRY ResData1 = (PIMAGE_RESOURCE_DATA_ENTRY)( ResInfo->ResourceBaseMapped1 + ResourceEntry1[ i ].OffsetToData );
                    PIMAGE_RESOURCE_DATA_ENTRY ResData2 = (PIMAGE_RESOURCE_DATA_ENTRY)( ResInfo->ResourceBaseMapped2 + ResourceEntry2[ j ].OffsetToData );

                    DiffCount += COMPARE_FIELDS( ResData1, ResData2, Size );
                    DiffCount += COMPARE_FIELDS( ResData1, ResData2, CodePage );
                    DiffCount += COMPARE_FIELDS( ResData1, ResData2, Reserved );

                    ULONG rvaData1 = ResData1->OffsetToData;
                    ULONG  cbData1 = ResData1->Size;
                    PBYTE  pbData1 = (PBYTE) ImageRvaToMappedAddress( ResInfo->NtHeader1, rvaData1, ResInfo->MappedFile1, ResInfo->FileSize1 );

                    ULONG rvaData2 = ResData2->OffsetToData;
                    ULONG  cbData2 = ResData2->Size;
                    PBYTE  pbData2 = (PBYTE) ImageRvaToMappedAddress( ResInfo->NtHeader2, rvaData2, ResInfo->MappedFile2, ResInfo->FileSize2 );

                    ZeroIgnoreValuesInBufferPair( pbData1, pbData2, cbData1, cbData2 );

                    DiffCount += CompareRawBytes( pbData1, pbData2, cbData1, cbData2, ResInfo->DisplayBuffer );
                }
            }

            ResourceEntry2[ j ].Name = 0xFFFFFFFF;
        }
        else    // no match
        {
            ++DiffCount;

            if ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS )
            {
                ReportDiff( "%-8s: left only\n", ResInfo->DisplayBuffer );
            }
        }
    }

    for ( unsigned j = 0; j < ResourceCount2; j++ )
    {
        if ( ResourceEntry2[ j ].Name != 0xFFFFFFFF )
        {
            ++DiffCount;

            if ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS )
            {
                DisplayBufPtr[ 0 ] = '\\';
                DisplayBufPtr[ 1 ] = '\0';

                GetResourceEntryName( &ResourceEntry2[ j ], ResInfo->ResourceBaseMapped2, ResInfo->Depth, DisplayBufPtr + 1 );

                ReportDiff( "%-8s: right only\n", ResInfo->DisplayBuffer );
            }
        }
    }

    if ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS )
    {
        *DisplayBufPtr = 0;     // restore display name for parent directory
    }

    #undef COMPARE_FIELDS

    ResInfo->Depth--;

    return DiffCount;
}


LPSTR
ErrorTextFromErrorCode(
    IN  DWORD ErrorCode,
    OUT LPSTR ErrorText
    )
{
    ULONG n = sprintf( ErrorText, ((LONG)ErrorCode > 0 ) ? "(%u) " : "(%X) ", ErrorCode );

    FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        ErrorCode,
        0,
        ErrorText + n,
        0xFFFF,
        NULL
        );

    for ( PBYTE p = (PBYTE) ErrorText; *p; p++ )
    {
        if ( *p < ' ' )
        {
             *p = ' ';
        }
    }

    StripTrailingSpaces( ErrorText );

    return ErrorText;
}


VOID
NORETURN
ErrorExitV(
    DWORD   dwGLE,
    LPCSTR  pszFormat,
    va_list vaArgs
    )
{
    if ( ! ( gCompFlags & PECOMP_SILENT ))
    {
        if ( dwGLE == GLE )
        {
             dwGLE = GetLastError();
        }

        fprintf( stdout, "ERROR: Unable to perform comparison.\n" );
        fflush( stdout );

        vfprintf( stderr, pszFormat, vaArgs );

        if ( dwGLE != 0 )
        {
            CHAR Buffer[ 1024 ];
            fprintf( stderr, "%s\n", ErrorTextFromErrorCode( dwGLE, Buffer ));
        }

        fflush( stderr );
    }

    exit( 999999999 );
}


VOID
NORETURN
ErrorExit(
    DWORD  dwGLE,
    LPCSTR pszFormat,
    ...
    )
{
    va_list vaArgs;
    va_start( vaArgs, pszFormat );
    ErrorExitV( dwGLE, pszFormat, vaArgs );
    //va_end( vaArgs );
}


VOID
ReportDiffV(
    LPCSTR  pszFormat,
    va_list vaArgs
    )
{
    if (( gCompFlags & PECOMP_SILENT ) ||
        ( ! ( gCompFlags & PECOMP_SHOW_PRIMARY_DIFFS )))
    {
        return;
    }

    if ( ! gDiffSectionCount++ )
    {
        fprintf( stderr, "\n" );
    }

    vfprintf( stderr, pszFormat, vaArgs );
}


VOID
ReportDiff(
    LPCSTR pszFormat,
    ...
    )
{
    va_list vaArgs;
    va_start( vaArgs, pszFormat );
    ReportDiffV( pszFormat, vaArgs );
    va_end( vaArgs );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\lzx\encoder\tree.c ===
/*
 * tree.c
 *
 * Tree building routines.
 *
 * These routines are originally from the Public Domain source "AR001".
 *
 * However, they have been modified for use in LZX.
 */

#include "encoder.h"


/* Function prototypes */
static void downheap(t_encoder_context *context, short i);
static void make_tree2(t_encoder_context *context, short avail, ushort freqparm[], ushort codeparm[]);
static void make_len(t_encoder_context *context, short root);
static void make_code(t_encoder_context *context, int n, char len[], ushort code[]);


static void count_len(t_encoder_context *context, short i)  /* call with i = root */
{
	if (i < context->enc_tree_n)
		context->enc_tree_len_cnt[(context->enc_depth < 16) ? context->enc_depth : 16]++; /* NOTE: 16 is max len allowed */
	else
	{
		context->enc_depth++;
		count_len(context, context->enc_tree_leftright[i*2]);
		count_len(context, context->enc_tree_leftright[i*2+1]);
		context->enc_depth--;
	}
}


static void make_len(t_encoder_context *context, short root)
{
	signed short	k;
	ushort			cum;
	byte			i;

	for (i = 0; i <= 16; i++)
		context->enc_tree_len_cnt[i] = 0;

	count_len(context, root);

	cum = 0;

	for (i = 16; i > 0; i--)
		cum += (ushort) (context->enc_tree_len_cnt[i] << (16 - i));

	/* cum should equal 1<<16, which is 0 since cum is a ushort */
	while (cum)
	{
		context->enc_tree_len_cnt[16]--;

		for (i = 15; i > 0; i--)
		{
			if (context->enc_tree_len_cnt[i])
			{
				context->enc_tree_len_cnt[i]--;
				context->enc_tree_len_cnt[i+1] += 2;
				break;
			}
		}

		cum--;
	}

	for (i = 16; i > 0; i--)
	{
		k = context->enc_tree_len_cnt[i];

		while (--k >= 0)
			context->enc_len[*context->enc_tree_sortptr++] = (byte) i;
	}
}


static void __inline downheap(t_encoder_context *context, short i)
	/* priority queue; send i-th entry down heap */
{
	short  j, k;

	k = context->enc_tree_heap[i];

	while ((j = (i<<1)) <= context->enc_tree_heapsize)
	{
		if (j < context->enc_tree_heapsize &&
			context->enc_tree_freq[context->enc_tree_heap[j]] > context->enc_tree_freq[context->enc_tree_heap[j + 1]])
		 	j++;

		if (context->enc_tree_freq[k] <= context->enc_tree_freq[context->enc_tree_heap[j]])
			break;

		context->enc_tree_heap[i] = context->enc_tree_heap[j];
		i = j;
	}

	context->enc_tree_heap[i] = k;
}


static void make_code(t_encoder_context *context, int n, char len[], ushort code[])
{
    int    i;
	ushort start[18];

	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = (start[i] + context->enc_tree_len_cnt[i]) << 1;

	for (i = 0; i < n; i++)
	{
		code[i] = start[len[i]]++;
	}
}


void make_tree(
	t_encoder_context *context,
	int		nparm,
	ushort	*freqparm,
	byte	*lenparm,
	ushort	*codeparm,
	bool	make_codes	/* for estimations, we only want the lengths */
)
{
	short i, avail;

REDO_TREE:
	context->enc_tree_n			= nparm;
	context->enc_tree_freq		= freqparm;
	context->enc_len			= lenparm;
	avail				        = (short) context->enc_tree_n;
    context->enc_depth          = 0;
	context->enc_tree_heapsize	= 0;
	context->enc_tree_heap[1]	= 0;

	for (i = 0; i < nparm; i++)
	{
		context->enc_len[i] = 0;

		if (freqparm[i])
            context->enc_tree_heap[++context->enc_tree_heapsize] = i;
	}

	if (context->enc_tree_heapsize < 2)
	{
		if (!context->enc_tree_heapsize)
		{
			codeparm[context->enc_tree_heap[1]] = 0;
			return;
		}

		if (!context->enc_tree_heap[1])
			freqparm[1] = 1;
		else
			freqparm[0] = 1;

		goto REDO_TREE;
	}

	make_tree2(context, avail, freqparm, codeparm);

	if (make_codes)
		make_code(context, nparm, lenparm, codeparm);
}


static void make_tree2(
	t_encoder_context *context,
	short avail,
	ushort freqparm[],
	ushort codeparm[]
)
{
	short i, j, k;

	for (i = context->enc_tree_heapsize >> 1; i >= 1; i--)
		downheap(context, i);  /* make priority queue */

	context->enc_tree_sortptr = codeparm;

	do
	{	/* while queue has at least two entries */
		i = context->enc_tree_heap[1];  /* take out least-freq entry */

		if (i < context->enc_tree_n)
			*context->enc_tree_sortptr++ = i;

		context->enc_tree_heap[1] = context->enc_tree_heap[context->enc_tree_heapsize--];
		downheap(context, 1);

		j = context->enc_tree_heap[1];  /* next least-freq entry */

		if (j < context->enc_tree_n)
			*context->enc_tree_sortptr++ = j;

		k = avail++;  /* generate new node */

		freqparm[k] = freqparm[i] + freqparm[j];
		context->enc_tree_heap[1] = k;
		downheap(context, 1);  /* put into queue */

		context->enc_tree_leftright[k*2] = i;
		context->enc_tree_leftright[k*2+1] = j;

	} while (context->enc_tree_heapsize > 1);

	context->enc_tree_sortptr = codeparm;
	make_len(context, k);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\sym7\nametable.h ===
//
//  nametable.h
//
//  Author: Tom McGuire (tommcg)
//
//  Copyright (C) Microsoft, 1997-2000.
//

#ifndef _NAMETABL_H_
#define _NAMETABL_H_

#pragma warning( push )
#pragma warning( disable: 4200 )    // zero-sized array in struct/union

#ifndef ASSERT
#define ASSERT(x)
#endif

#ifdef _M_IX86
#pragma intrinsic( memcpy )
#pragma intrinsic( memcmp )
#pragma intrinsic( strlen )
#pragma intrinsic( _rotl )
#endif

//
//  Each hash table entry is the root of a btree, so it contains a single
//  pointer.  On x86 this is 4 bytes per entry.  On 64-bit systems, this is
//  8 bytes per entry.  Allocating 64K of memory to the hash table sounds
//  reasonable for large datasets.  For 64-bit systems this is 128K.
//
//  NOTE:  Caller must maintain case consistency ("Foo" != "FOO")
//

#define HASH_TABLE_COUNT 16384

struct NAMENODE
{
    NAMENODE* Left;
    NAMENODE* Right;
    unsigned  Hash;
    unsigned  Length;
    char      Name[ 0 ];
};


class NAMETABLE
{

public:

    NAMENODE* __fastcall InsertName( const char *Name );
    NAMENODE* __fastcall LookupName( const char *Name );
    NAMENODE* __fastcall LocateNode( const char *Name, bool Insert );

    NAMETABLE();
   ~NAMETABLE();

private:

    NAMENODE** HashTable;

};


NAMETABLE::NAMETABLE()
{
    HashTable = (NAMENODE**) VirtualAlloc(
                                 NULL,
                                 sizeof(PVOID) * HASH_TABLE_COUNT,
                                 MEM_COMMIT,
                                 PAGE_READWRITE
                                 );
}


NAMETABLE::~NAMETABLE()
{
    if ( HashTable )
    {
        VirtualFree( HashTable, 0, MEM_RELEASE );
    }
}


NAMENODE* __fastcall NAMETABLE::LookupName( const char *Name )
{
    return LocateNode( Name, false );
}


NAMENODE* __fastcall NAMETABLE::InsertName( const char *Name )
{
    return LocateNode( Name, true );
}


NAMENODE* __fastcall NAMETABLE::LocateNode( const char *Name, bool Insert )
{
    ASSERT( HashTable != NULL );

    unsigned Length = strlen( Name );
    unsigned Hash   = ~Length;

    for ( unsigned i = 0; i < Length; i++ )
    {
        Hash = _rotl( Hash, 3 ) ^ (unsigned char) Name[ i ];
    }

    NAMENODE** Link = &HashTable[ Hash % HASH_TABLE_COUNT ];
    NAMENODE*  Node = *Link;

    while ( Node != NULL )
    {
        Link = &Node->Right;

        if ( Hash == Node->Hash )
        {
            if ( Length == Node->Length )
            {
                long Compare = memcmp( Name, Node->Name, Length );

                if ( Compare == 0 )
                {
                    return Node;
                }
                else if ( Compare < 0 )
                {
                    Link = &Node->Left;
                }
            }
            else if ( Length < Node->Length )
            {
                Link = &Node->Left;
            }
        }
        else if ( Hash < Node->Hash )
        {
            Link = &Node->Left;
        }

        Node = *Link;
    }

    if ( Insert )
    {
        Node = (NAMENODE*) new BYTE[ sizeof( NAMENODE ) + Length + 1 ];

        if ( Node != NULL )
        {
            Node->Left   = NULL;
            Node->Right  = NULL;
            Node->Hash   = Hash;
            Node->Length = Length;

            memcpy( Node->Name, Name, Length + 1 );

            *Link = Node;
        }
    }

    return Node;
}


#pragma warning( pop )

#endif // _NAMETABL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\sym7\md5.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved

//
//  This copy of md5.c modified and adapted for my purposes, tommcg 6/28/96
//  Copyright (C) 1996-1999, Microsoft Corporation.
//


typedef struct _MD5_HASH MD5_HASH, *PMD5_HASH;

struct _MD5_HASH {
    union {
        ULONG Word32[  4 ];
        BYTE Byte  [ 16 ];
        };
    };

#define MD5_INITIAL_VALUE { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476 }



/* Constants for Transform routine. */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


/* F, G and H are basic MD5 functions */
#define F(x, y, z) ((x & y) | (~x & z))
#define G(x, y, z) ((x & z) | (y & ~z))
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))


/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
   a += F(b, c, d) + x + ac; \
   a = _rotl(a, s); \
   a += b;

#define GG(a, b, c, d, x, s, ac) \
   a += G(b, c, d) + x + ac; \
   a = _rotl(a, s); \
   a += b;

#define HH(a, b, c, d, x, s, ac) \
   a += H(b, c, d) + x + ac; \
   a = _rotl(a, s); \
   a += b;

#define II(a, b, c, d, x, s, ac) \
   a += I(b, c, d) + x + ac; \
   a = _rotl(a, s); \
   a += b;


VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    )
    {
    HashValue->Word32[ 0 ] = 0x67452301;
    HashValue->Word32[ 1 ] = 0xefcdab89;
    HashValue->Word32[ 2 ] = 0x98badcfe;
    HashValue->Word32[ 3 ] = 0x10325476;
    }

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCBYTE    DataChunk          // pointer to 64-byte message chunk
    )
    {
    const UNALIGNED ULONG * MessageWord32 = (const UNALIGNED ULONG *) DataChunk;

    ULONG a = HashValue->Word32[ 0 ];
    ULONG b = HashValue->Word32[ 1 ];
    ULONG c = HashValue->Word32[ 2 ];
    ULONG d = HashValue->Word32[ 3 ];

    /* Round 1 */
    FF ( a, b, c, d, MessageWord32[  0 ], S11, 0xd76aa478 ) /* 1 */
    FF ( d, a, b, c, MessageWord32[  1 ], S12, 0xe8c7b756 ) /* 2 */
    FF ( c, d, a, b, MessageWord32[  2 ], S13, 0x242070db ) /* 3 */
    FF ( b, c, d, a, MessageWord32[  3 ], S14, 0xc1bdceee ) /* 4 */
    FF ( a, b, c, d, MessageWord32[  4 ], S11, 0xf57c0faf ) /* 5 */
    FF ( d, a, b, c, MessageWord32[  5 ], S12, 0x4787c62a ) /* 6 */
    FF ( c, d, a, b, MessageWord32[  6 ], S13, 0xa8304613 ) /* 7 */
    FF ( b, c, d, a, MessageWord32[  7 ], S14, 0xfd469501 ) /* 8 */
    FF ( a, b, c, d, MessageWord32[  8 ], S11, 0x698098d8 ) /* 9 */
    FF ( d, a, b, c, MessageWord32[  9 ], S12, 0x8b44f7af ) /* 10 */
    FF ( c, d, a, b, MessageWord32[ 10 ], S13, 0xffff5bb1 ) /* 11 */
    FF ( b, c, d, a, MessageWord32[ 11 ], S14, 0x895cd7be ) /* 12 */
    FF ( a, b, c, d, MessageWord32[ 12 ], S11, 0x6b901122 ) /* 13 */
    FF ( d, a, b, c, MessageWord32[ 13 ], S12, 0xfd987193 ) /* 14 */
    FF ( c, d, a, b, MessageWord32[ 14 ], S13, 0xa679438e ) /* 15 */
    FF ( b, c, d, a, MessageWord32[ 15 ], S14, 0x49b40821 ) /* 16 */

    /* Round 2 */
    GG ( a, b, c, d, MessageWord32[  1 ], S21, 0xf61e2562 ) /* 17 */
    GG ( d, a, b, c, MessageWord32[  6 ], S22, 0xc040b340 ) /* 18 */
    GG ( c, d, a, b, MessageWord32[ 11 ], S23, 0x265e5a51 ) /* 19 */
    GG ( b, c, d, a, MessageWord32[  0 ], S24, 0xe9b6c7aa ) /* 20 */
    GG ( a, b, c, d, MessageWord32[  5 ], S21, 0xd62f105d ) /* 21 */
    GG ( d, a, b, c, MessageWord32[ 10 ], S22, 0x02441453 ) /* 22 */
    GG ( c, d, a, b, MessageWord32[ 15 ], S23, 0xd8a1e681 ) /* 23 */
    GG ( b, c, d, a, MessageWord32[  4 ], S24, 0xe7d3fbc8 ) /* 24 */
    GG ( a, b, c, d, MessageWord32[  9 ], S21, 0x21e1cde6 ) /* 25 */
    GG ( d, a, b, c, MessageWord32[ 14 ], S22, 0xc33707d6 ) /* 26 */
    GG ( c, d, a, b, MessageWord32[  3 ], S23, 0xf4d50d87 ) /* 27 */
    GG ( b, c, d, a, MessageWord32[  8 ], S24, 0x455a14ed ) /* 28 */
    GG ( a, b, c, d, MessageWord32[ 13 ], S21, 0xa9e3e905 ) /* 29 */
    GG ( d, a, b, c, MessageWord32[  2 ], S22, 0xfcefa3f8 ) /* 30 */
    GG ( c, d, a, b, MessageWord32[  7 ], S23, 0x676f02d9 ) /* 31 */
    GG ( b, c, d, a, MessageWord32[ 12 ], S24, 0x8d2a4c8a ) /* 32 */

    /* Round 3 */
    HH ( a, b, c, d, MessageWord32[  5 ], S31, 0xfffa3942 ) /* 33 */
    HH ( d, a, b, c, MessageWord32[  8 ], S32, 0x8771f681 ) /* 34 */
    HH ( c, d, a, b, MessageWord32[ 11 ], S33, 0x6d9d6122 ) /* 35 */
    HH ( b, c, d, a, MessageWord32[ 14 ], S34, 0xfde5380c ) /* 36 */
    HH ( a, b, c, d, MessageWord32[  1 ], S31, 0xa4beea44 ) /* 37 */
    HH ( d, a, b, c, MessageWord32[  4 ], S32, 0x4bdecfa9 ) /* 38 */
    HH ( c, d, a, b, MessageWord32[  7 ], S33, 0xf6bb4b60 ) /* 39 */
    HH ( b, c, d, a, MessageWord32[ 10 ], S34, 0xbebfbc70 ) /* 40 */
    HH ( a, b, c, d, MessageWord32[ 13 ], S31, 0x289b7ec6 ) /* 41 */
    HH ( d, a, b, c, MessageWord32[  0 ], S32, 0xeaa127fa ) /* 42 */
    HH ( c, d, a, b, MessageWord32[  3 ], S33, 0xd4ef3085 ) /* 43 */
    HH ( b, c, d, a, MessageWord32[  6 ], S34, 0x04881d05 ) /* 44 */
    HH ( a, b, c, d, MessageWord32[  9 ], S31, 0xd9d4d039 ) /* 45 */
    HH ( d, a, b, c, MessageWord32[ 12 ], S32, 0xe6db99e5 ) /* 46 */
    HH ( c, d, a, b, MessageWord32[ 15 ], S33, 0x1fa27cf8 ) /* 47 */
    HH ( b, c, d, a, MessageWord32[  2 ], S34, 0xc4ac5665 ) /* 48 */

    /* Round 4 */
    II ( a, b, c, d, MessageWord32[  0 ], S41, 0xf4292244 ) /* 49 */
    II ( d, a, b, c, MessageWord32[  7 ], S42, 0x432aff97 ) /* 50 */
    II ( c, d, a, b, MessageWord32[ 14 ], S43, 0xab9423a7 ) /* 51 */
    II ( b, c, d, a, MessageWord32[  5 ], S44, 0xfc93a039 ) /* 52 */
    II ( a, b, c, d, MessageWord32[ 12 ], S41, 0x655b59c3 ) /* 53 */
    II ( d, a, b, c, MessageWord32[  3 ], S42, 0x8f0ccc92 ) /* 54 */
    II ( c, d, a, b, MessageWord32[ 10 ], S43, 0xffeff47d ) /* 55 */
    II ( b, c, d, a, MessageWord32[  1 ], S44, 0x85845dd1 ) /* 56 */
    II ( a, b, c, d, MessageWord32[  8 ], S41, 0x6fa87e4f ) /* 57 */
    II ( d, a, b, c, MessageWord32[ 15 ], S42, 0xfe2ce6e0 ) /* 58 */
    II ( c, d, a, b, MessageWord32[  6 ], S43, 0xa3014314 ) /* 59 */
    II ( b, c, d, a, MessageWord32[ 13 ], S44, 0x4e0811a1 ) /* 60 */
    II ( a, b, c, d, MessageWord32[  4 ], S41, 0xf7537e82 ) /* 61 */
    II ( d, a, b, c, MessageWord32[ 11 ], S42, 0xbd3af235 ) /* 62 */
    II ( c, d, a, b, MessageWord32[  2 ], S43, 0x2ad7d2bb ) /* 63 */
    II ( b, c, d, a, MessageWord32[  9 ], S44, 0xeb86d391 ) /* 64 */

    HashValue->Word32[ 0 ] += a;
    HashValue->Word32[ 1 ] += b;
    HashValue->Word32[ 2 ] += c;
    HashValue->Word32[ 3 ] += d;
    }


VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,
    IN     PCBYTE    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     QWORD     TotalBytesHashed   // total bytes hashed
    )
    {
    union {
        QWORD Qword[  8 ];
        BYTE  Byte [ 64 ];
        } LocalBuffer;

    //
    //  Always append a pad byte of 0x80 to the message.
    //
    //  If RemainingBytes is less than (but not equal to) 56 bytes, then
    //  the final bits hashed count will be stored in the last 8 bytes of
    //  this 64 byte hash chunk.
    //
    //  If RemainingBytes is exactly 56 bytes, the appended 0x80 pad byte
    //  will force an extra chunk.
    //
    //  If RemainingBytes is greater than or equal to 56 bytes, then the
    //  final bits hashed count will be stored in the last 8 bytes of the
    //  NEXT 64 byte chunk that is otherwise zeroed, so THIS chunk needs to
    //  be zero-padded beyond the first pad byte and then hashed, then zero
    //  the first 56 bytes of the LocalBuffer for the NEXT chunk hash.
    //

    RemainingBytes &= 63;           // prevent stupidity (no error return)

    //
    //  Zero init local buffer.
    //

    memset( &LocalBuffer, 0, 64 );

    //
    //  Append 0x80 pad byte to message.
    //

    LocalBuffer.Byte[ RemainingBytes ] = 0x80;

    if ( RemainingBytes > 0 ) {

        //
        //  Copy remaining data bytes (0 < RemainingBytes < 64) to LocalBuffer
        //  (remainder of LocalBuffer already zeroed except for pad byte).
        //

        memcpy( &LocalBuffer, RemainingData, RemainingBytes );

        if ( RemainingBytes >= 56 ) {

            UpdateMD5_64ByteChunk( HashValue, (PCBYTE) &LocalBuffer );

            memset( &LocalBuffer, 0, 56 );

            }
        }

    //
    //  Number of BITS hashed goes into last 8 bytes of last chunk.  This
    //  is a 64-bit value.  Note that if the number of BITS exceeds 2^64
    //  then this number is the low order 64 bits of the result.
    ///

    LocalBuffer.Qword[ 7 ] = ( TotalBytesHashed * 8 );      // number of BITS

    UpdateMD5_64ByteChunk( HashValue, (PCBYTE) &LocalBuffer );

    }


VOID
ComputeCompleteMD5(
    IN  PCBYTE    DataBuffer,
    IN  QWORD     DataLength,
    OUT PMD5_HASH HashValue
    )
    {
    PCBYTE DataPointer = DataBuffer;
    QWORD  ChunkCount  = DataLength / 64;
    ULONG  OddBytes    = (ULONG)DataLength & 63;

    InitMD5( HashValue );

    while ( ChunkCount-- ) {
        UpdateMD5_64ByteChunk( HashValue, DataPointer );
        DataPointer += 64;
        }

    FinalizeMD5( HashValue, DataPointer, OddBytes, DataLength );
    }


VOID
Md5ToHexStr(
    IN  PMD5_HASH HashValue,
    OUT LPSTR     Buffer      // writes exactly 33 bytes including terminator
    )
    {
    static const char HexDigitTable[ 16 ] =
        { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };

    LPSTR p = Buffer;
    ULONG i;

    for ( i = 0; i < sizeof( MD5_HASH ); i++ ) {

        *p++ = HexDigitTable[ HashValue->Byte[ i ] >> 4  ];
        *p++ = HexDigitTable[ HashValue->Byte[ i ] & 0xF ];
        }

    *p = 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\sym7\inc\cv.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#pragma once

#pragma pack(push, 1)

struct CVSEG
{
   struct
   {
      WORD  fRead    : 1;	       // Segment is readable
      WORD  fWrite   : 1;	       // Segment is writable
      WORD  fExecute : 1;	       // Segment is executable
      WORD  f32Bit   : 1;	       // Segment is 32 bit
      WORD	     : 4;
      WORD  fSel     : 1;	       //
      WORD  fAbs     : 1;	       // Segment is absolute
      WORD	     : 2;
      WORD  fGroup   : 1;	       // This is a group (not a segment)
      WORD	     : 3;
   }	    wFlags;
   WORD     iovl;		       // Overlay index
   WORD     igr;		       // Group index
   WORD     isegPhysical;	       // Physical segment index
   WORD     ichName;		       // Offset of segment name or 0xFFFF
   WORD     ichClassName;	       // Offset of class name or 0xFFFF
   DWORD    ib; 		       // Offset within physical segment
   DWORD    cb; 		       // Size
};


struct CVSEGMAP
{
   WORD     ccvsegMax;
   WORD     ccvsegLogical;
   CVSEG    rgcvseg[1];
};


/**	CodeView Symbol and Type OMF type information is broken up into two
 *	ranges.  Type indices less than 0x1000 describe type information
 *	that is frequently used.  Type indices above 0x1000 are used to
 *	describe more complex features such as functions, arrays and
 *	structures.
 */

/**	Primitive types have predefined meaning that is encoded in the
 *	values of the various bit fields in the value.
 *
 *	A CodeView primitive type is defined as:
 *
 *	1 1
 *	1 089  7654  3	210
 *	r mode type  r	sub
 *
 *	Where
 *	    mode is the pointer mode
 *	    type is a type indicator
 *	    sub  is a subtype enumeration
 *	    r	 is a reserved field
 *
 *	See Microsoft Symbol and Type OMF (Version 4.0) for more
 *	information.
 */


// --------------------------------------------------------------------
// Encoded Values
// --------------------------------------------------------------------

   // In type descriptions, there are sometimes embedded values.  Where
   // these occur, the next 16 bit word is examined.  If the value of this
   // word is less than 0x8000, then the word contains the desired value.
   // Otherwise, the word contains a value type and the desired value
   // follows this word.

enum CVVALT			       // CodeView Value Type
{
   cvvaltInt8		= 0x8000,      // 8 bit signed integer
   cvvaltInt16		= 0x8001,      // 16 bit signed integer
   cvvaltUInt16 	= 0x8002,      // 16 bit unsigned integer
   cvvaltInt32		= 0x8003,      // 32 bit signed integer
   cvvaltUInt32 	= 0x8004,      // 32 bit unsigned integer
   cvvaltReal32 	= 0x8005,      // 32 bit IEEE floating point
   cvvaltReal64 	= 0x8006,      // 64 bit IEEE floating point
   cvvaltReal80 	= 0x8007,      // 80 bit Intel x87 floating point
   cvvaltReal128	= 0x8008,
   cvvaltInt64		= 0x8009,      // 64 bit signed integer
   cvvaltUInt64 	= 0x800a,      // 64 bit unsigned integer
   cvvaltReal48 	= 0x800b,
   cvvaltComplex32	= 0x800c,      // 32 bit IEEE floating point complex
   cvvaltComplex64	= 0x800d,      // 64 bit IEEE floating point complex
   cvvaltComplex80	= 0x800e,      // 80 bit Intel x87 floating point complex
   cvvaltComplex128	= 0x800f,
   cvvaltString 	= 0x8010,      // Variable length string
};

struct CVVAL
{
   WORD  cvvalt;
};


struct CVVALINT8 : public CVVAL
{
   BYTE  ch;			       // Signed 8-bit integer
};


struct CVVALINT16 : public CVVAL
{
   WORD  w;			       // Signed 16-bit integer
};


struct CVVALUINT16 : public CVVAL
{
   WORD  w;			       // Unsigned 16-bit integer
};


struct CVVALINT32 : public CVVAL
{
   DWORD dw;			       // Signed 32-bit integer
};


struct CVVALUINT32 : public CVVAL
{
   DWORD dw;			       // Unsigned 32-bit integer
};


struct CVVALREAL32 : public CVVAL
{
   DWORD dw;			       // 32 bit IEEE floating point
};


struct CVVALREAL64 : public CVVAL
{
   BYTE  rgb[8];		       // 64 bit IEEE floating point
};


struct CVVALREAL80 : public CVVAL
{
   BYTE  rgb[10];		       // 80 bit Intel x87 floating point
};


struct CVVALREAL128 : public CVVAL
{
   BYTE  rgb[16];		       //
};


struct CVVALINT64 : public CVVAL
{
   BYTE  rgb[8];		       // 64 bit signed integer
};


struct CVVALUINT64 : public CVVAL
{
   BYTE  rgb[8];		       // 64 bit unsigned integer
};


struct CVVALREAL48 : public CVVAL
{
   BYTE  rgb[6];		       // 64 bit unsigned integer
};


struct CVVALCOMPLEX32 : public CVVAL
{
   DWORD dwReal;		       // 32 bit IEEE floating point
   DWORD dwImaginary;		       // "
};


struct CVVALCOMPLEX64 : public CVVAL
{
   BYTE  rgbReal[8];		       // 64 bit IEEE floating point
   BYTE  rgbImaginary[8];	       // "
};


struct CVVALCOMPLEX80 : public CVVAL
{
   BYTE  rgbReal[10];		       // 80 bit Intel x87 floating point
   BYTE  rgbImaginary[10];	       // "
};


struct CVVALCOMPLEX128 : public CVVAL
{
   BYTE  rgbReal[16];		       //
   BYTE  rgbImaginary[16];	       //
};


struct CVVALSTRING : public CVVAL
{
   WORD  cch;			       // Length of value in characters
   char  rgch[1];		       // Value
};


// --------------------------------------------------------------------
// Type Indices
// --------------------------------------------------------------------

   // A CodeView type index is a sixteen bit value.  Values < 0x1000 identify
   // reserved types.  Values 0x1000 and above are used indices into a list
   // of programmer defined types located in the GlobalTypes subsection of
   // a CVPACKed executable or a PreComp or Types subsection of an unpacked
   // executable.

typedef DWORD CVTI32;		       // CodeView Type Index (32 bit)


enum CVTM			       // CodeView Type Mode
{
   cvtmDirect		= 0,	       // Not a pointer
   cvtmNPtr		= 1,	       // Near pointer (0:16)
   cvtmFPtr		= 2,	       // Far pointer (16:16)
   cvtmHPtr		= 3,	       // Huge pointer (16:16)
   cvtmNPtr32		= 4,	       // Near pointer (0:32)
   cvtmFPtr32		= 5,	       // Far pointer (16:32)
   cvtmNPtr64		= 6,	       // Near pointer (0:64)
};


enum CVPT			       // CodeView Primitive Type
{
   // Special Types

   cvptNoType		= 0x0000,      // No type assigned
   cvptAbs		= 0x0001,      // Absolute symbol
   cvptSegment		= 0x0002,      // Segment type
   cvptVoid		= 0x0003,      // void
   cvptCurrency 	= 0x0004,      // BASIC Currency (64 bit integer scaled by 10000)
   cvptNBasicStr	= 0x0005,      // Near BASIC string
   cvptFBasicStr	= 0x0006,      // Far BASIC string
   cvptNotTrans 	= 0x0007,      // Type not translated by cvpack
   cvptHresult		= 0x0008,      // OLE/COM HRESULT

   // Signed integral types

   cvptChar		= 0x0010,      // Signed character
   cvptShort		= 0x0011,      // Signed short
   cvptLong		= 0x0012,      // Signed long
   cvptLongLong 	= 0x0013,      // Signed long long

   // Unsigned integral types

   cvptUChar		= 0x0020,      // Unsigned character
   cvptUShort		= 0x0021,      // Unsigned short
   cvptULong		= 0x0022,      // Unsigned long
   cvptULongLong	= 0x0023,      // Unsigned long long

   // Boolean types

   cvptBool8		= 0x0030,      // 8 bit boolean
   cvptBool16		= 0x0031,      // 16 bit boolean
   cvptBool32		= 0x0032,      // 32 bit boolean
   cvptBool64		= 0x0033,      // 64 bit boolean

   // Floating point types

   cvptReal32		= 0x0040,      // 32 bit real
   cvptReal64		= 0x0041,      // 64 bit real
   cvptReal80		= 0x0042,      // 80 bit real
   cvptReal128		= 0x0043,      // 128 bit real
   cvptReal48		= 0x0044,      // 48 bit real

   // Floating point complex types

   cvptCplx32		= 0x0050,      // 32 bit complex
   cvptCplx64		= 0x0051,      // 64 bit complex
   cvptCplx80		= 0x0052,      // 80 bit complex
   cvptCplx128		= 0x0053,      // 128 bit complex

   // MOre special types

   cvptBit		= 0x0060,      // Bit
   cvptPasChar		= 0x0061,      // Pascal CHAR

   // Integral types

   cvptRChar		= 0x0070,      // Char
   cvptWChar		= 0x0071,      // Wide char
   cvptInt16		= 0x0072,      // 16 bit signed int
   cvptUInt16		= 0x0073,      // 16 bit unsigned int
   cvptInt32		= 0x0074,      // 32 bit signed int
   cvptUInt32		= 0x0075,      // 32 bit unsigned int
   cvptInt64		= 0x0076,      // 64 bit signed int
   cvptUInt64		= 0x0077,      // 64 bit unsigned int

   // CodeView internal types

   cvptCvPtr		= 0x00f0,      // Internal type for created pointers
};


inline CVTM CvtmFromCvti(CVTI32 cvti)
{
   return((CVTM) ((cvti & 0x0F00) >> 8));
}


inline CVPT CvptFromCvti(CVTI32 cvti)
{
   return((CVPT) (cvti & 0x00FF));
}


// --------------------------------------------------------------------
// Type Definition Leaves
// --------------------------------------------------------------------

enum CVLFT			       // CodeView Leaf Type
{
   // Leaf types that start records referenced from symbol records

   cvlftCOBOL1		= 0x000c,
   cvlftLabel		= 0x000e,
   cvlftNull		= 0x000f,
   cvlftNotTran 	= 0x0010,
   cvlftEndPrecomp	= 0x0014,      // Not referenced from symbol records
   cvlftTypeServer	= 0x0016,      // Not referenced from symbol records

   // Leaf types used to indicate pading for alignment

   cvlftPad0		= 0x00f0,
   cvlftPad1		= 0x00f1,
   cvlftPad2		= 0x00f2,
   cvlftPad3		= 0x00f3,
   cvlftPad4		= 0x00f4,
   cvlftPad5		= 0x00f5,
   cvlftPad6		= 0x00f6,
   cvlftPad7		= 0x00f7,
   cvlftPad8		= 0x00f8,
   cvlftPad9		= 0x00f9,
   cvlftPad10		= 0x00fa,
   cvlftPad11		= 0x00fb,
   cvlftPad12		= 0x00fc,
   cvlftPad13		= 0x00fd,
   cvlftPad14		= 0x00fe,
   cvlftPad15		= 0x00ff,

   // Leaf types that start records referenced from other type records

   cvlftList		= 0x0203,
   cvlftRefSym		= 0x020c,

   // Leaf types used in lists

   cvlftEnumerate	= 0x0403,

   cvlftModifier32	= 0x1001,
   cvlftPointer32	= 0x1002,
   cvlftArray32 	= 0x1003,
   cvlftClass32 	= 0x1004,
   cvlftStructure32	= 0x1005,
   cvlftUnion32 	= 0x1006,
   cvlftEnum32		= 0x1007,
   cvlftProcedure32	= 0x1008,
   cvlftMFunction32	= 0x1009,
   cvlftVtShape32	= 0x100a,
   cvlftCOBOL032	= 0x100b,
   cvlftBArray32	= 0x100d,
   cvlftAlias32 	= 0x1010,      // Alias (typedef) type
   cvlftDimArray32	= 0x1011,
   cvlftVftPath32	= 0x1012,
   cvlftPrecomp32	= 0x1013,      // Not referenced from symbol records
   cvlftOEM32		= 0x1015,      // OEM definable type string

   // Leaf types that start records referenced from other type records

   cvlftSkip32		= 0x1200,
   cvlftArgList32	= 0x1201,
   cvlftDefArg32	= 0x1202,
   cvlftFieldList32	= 0x1203,
   cvlftDerived32	= 0x1204,
   cvlftBitField32	= 0x1205,
   cvlftMethodList32	= 0x1206,
   cvlftDimConU32	= 0x1207,
   cvlftDimConLU32	= 0x1208,
   cvlftDimVarU32	= 0x1209,
   cvlftDimVarLU32	= 0x120a,

   // Leaf types used in lists

   cvlftBClass32	= 0x1400,
   cvlftVBClass32	= 0x1401,
   cvlftIVBClass32	= 0x1402,
   cvlftFriendFcn32	= 0x1403,
   cvlftIndex32 	= 0x1404,
   cvlftMember32	= 0x1405,
   cvlftStMember32	= 0x1406,
   cvlftMethod32	= 0x1407,
   cvlftNestType32	= 0x1408,
   cvlftVFuncTab32	= 0x1409,
   cvlftFriendCls32	= 0x140a,
   cvlftOneMethod32	= 0x140b,
   cvlftVFuncOff32	= 0x140c,
   cvlftNestTypeEx32	= 0x140d,
   cvlftMemberModify32	= 0x140e,

   // Leaf types w/zero terminated names

   cvlftTypeServer_Sz	= 0x1501,      // Not referenced from symbol
   cvlftEnumerate_Sz	= 0x1502,
   cvlftArray		= 0x1503,
   cvlftClass		= 0x1504,
   cvlftStructure	= 0x1505,
   cvlftUnion		= 0x1506,
   cvlftEnum		= 0x1507,
   cvlftDimArray	= 0x1508,
   cvlftPrecomp 	= 0x1509,      // Not referenced from symbol
   cvlftAlias		= 0x150a,      // alias (typedef) type
   cvlftDefArg		= 0x150b,
   cvlftFriendFcn	= 0x150c,
   cvlftMember		= 0x150d,
   cvlftStMember	= 0x150e,
   cvlftMethod		= 0x150f,
   cvlftNestType	= 0x1510,
   cvlftOneMethod	= 0x1511,
   cvlftNestTypeEx	= 0x1512,
   cvlftMemberModify	= 0x1513,
   cvlftManaged 	= 0x1514,
};


enum CVLABT			       // CodeView Label Type
{
   cvlabtNear		= 0,
   cvlabtFar		= 4,
};


//  Structures to access to the type records

enum CVPMT			       // CodeView Pointer to Member Type
{
   cvpmtFnNoVirtSA32	= 0x0B,        // 16:32 method nonvirtual single address point
   cvpmtFnNoVirtMA32	= 0x0C,        // 16:32 method nonvirtual multiple address point
   cvpmtFnVirtBase32	= 0x0D,        // 16:32 method virtual bases
};



// --------------------------------------------------------------------
// Types used in CodeView Leaf Definitions
// --------------------------------------------------------------------

   // CVCP is used by CVLFCLASS, CVLFUNION, and CVLFENUM

struct CVCP			       // CodeView Class Properties
{
   WORD fPacked 	: 1;	       // Structure is packed
   WORD fHasConstructor : 1;	       // Constructors or destructors present
   WORD fOverloadedOps	: 1;	       // Overloaded operators present
   WORD fNested 	: 1;	       // This is a nested class
   WORD fHasNestedTypes : 1;	       // Contains nested types
   WORD fOverloadedAsgn : 1;	       // Overloaded assignment (=)
   WORD fCastOps	: 1;	       // Casting methods
   WORD fForwardRef	: 1;	       // Forward reference (incomplete defn)
   WORD fScoped 	: 1;	       // Scoped definition
   WORD 		: 7;
};


   // CVCALLT is used by CVLFPROC and CVLFMFUNC

enum CVCALLT			       // CodeView Call Type
{
   cvcalltC		= 0x00,        // __cdecl
   cvcalltCFar		= 0x01,        // __cdecl __far
   cvcalltPascal	= 0x02,        // __pascal/__fortran
   cvcalltPascalFar	= 0x03,        // __pascal/__fortran __far
   cvcalltFastcall	= 0x04,        // __fastcall
   cvcalltFastcallFar	= 0x05,        // __fastcall __far

   cvcalltStdcall	= 0x07,        // __stdcall
   cvcalltStdcallFar	= 0x08,        // __stdcall __far
   cvcalltSyscall	= 0x09,        // __syscall
   cvcalltSyscallFar	= 0x0a,        // __syscall __far
   cvcalltThis		= 0x0b,        // Used for member functions
   cvcalltMips		= 0x0c,        // MS MIPS compiler
   cvcalltGeneric	= 0x0d,        // Generic call sequence
   cvcalltAlpha 	= 0x0e,        // MS Alpha compiler
};


   // CVAP is used in CVFP

enum CVAP			       // CodeView Access Protection
{
   cvapPrivate		= 1,
   cvapProtected	= 2,
   cvapPublic		= 3,
};


   // CVMP is used in CVFP

enum CVMP			       // CodeView Method Property
{
   cvmpVanilla		= 0x00,
   cvmpVirtual		= 0x01,
   cvmpStatic		= 0x02,
   cvmpFriend		= 0x03,
   cvmpIntro		= 0x04,
   cvmpPureVirtual	= 0x05,
   cvmpPureIntro	= 0x06,
};


   // CVFP is used in

struct CVFP			       // CodeView Field Properties
{
   WORD cvap		:  2;	       // Access protection (CVAP)
   WORD cvmp		:  3;	       // Method properties (CVMP)
   WORD fPseudo 	:  1;	       // compiler generated fcn and does not exist
   WORD fNoInherit	:  1;	       // Class cannot be inherited
   WORD fNoConstruct	:  1;	       // Class cannot be constructed
   WORD 		:  8;
};


// --------------------------------------------------------------------
// CodeView Leaf Definitions
// --------------------------------------------------------------------

struct CVLF			       // CodeView Leaf
{
   WORD  cvlft; 		       // Leaf type
};


struct CVLFMODIFIER32 : public CVLF
{
   CVTI32 cvti; 		       // Modified type
   WORD   fConst	: 1;
   WORD   fVolatile	: 1;
   WORD   fUnaligned	: 1;
   WORD 		: 13;
};


//	type record for LF_POINTER

//	Type enum for pointer records
//	Pointers can be one of the following types

enum CV_ptrtype_e
{
   CV_PTR_NEAR	       = 0x00, // near pointer
   CV_PTR_FAR	       = 0x01, // far pointer
   CV_PTR_HUGE	       = 0x02, // huge pointer
   CV_PTR_BASE_SEG     = 0x03, // based on segment
   CV_PTR_BASE_VAL     = 0x04, // based on value of base
   CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
   CV_PTR_BASE_ADDR    = 0x06, // based on address of base
   CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
   CV_PTR_BASE_TYPE    = 0x08, // based on type
   CV_PTR_BASE_SELF    = 0x09, // based on self
   CV_PTR_NEAR32       = 0x0a, // 16:32 near pointer
   CV_PTR_FAR32        = 0x0b, // 16:32 far pointer
   CV_PTR_64	       = 0x0c, // 64 bit pointer
   CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
};


//	Mode enum for pointers
//	Pointers can have one of the following modes

enum CV_ptrmode_e
{
   CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
   CV_PTR_MODE_REF     = 0x01, // reference
   CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
   CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
   CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
};


struct CVLFPOINTERBODY32 : public CVLF
{
   CVTI32 cvti; 		       // Type index of the base type

   struct lfPointerAttr32
   {
      DWORD  ptrtype	 :5;	       // ordinal specifying pointer type (ptrtype-t)
      DWORD  ptrmode	 :3;	       // ordinal specifying pointer mode (ptrmode_t)
      DWORD  fFlat32	 :1;	       // true if 0:32 pointer
      DWORD  fVolatile	 :1;	       // TRUE if volatile pointer
      DWORD  fConst	 :1;	       // TRUE if const pointer
      DWORD  fUnaligned  :1;	       // TRUE if unaligned pointer
      DWORD  fRestricted :1;	       // TRUE if restricted pointer
      DWORD		 :4;
   } attr;
};

struct CVLFPOINTER32 : public CVLFPOINTERBODY32
{
   union
   {
      struct
      {
	 CVTI32 pmclass;	       // index of containing class for pointer to member
	 WORD	pmenum; 	       // enumeration specifying pm format
      } pm;

      WORD  bseg;		       // base segment if PTR_BASE_SEG

      BYTE  rgbSym[1];		       // copy of base symbol record (including length)

      struct
      {
	 CVTI32 cvti;		       // type index if CV_PTR_BASE_TYPE
	 char	rgch[1];	       // name of base type
      } btype;
   };
};


struct CVLFARRAY32 : public CVLF
{
   CVTI32 cvti; 		       // Type index of element type
   CVTI32 cvtiIndex;		       // Type index of indexing type
   BYTE   rgb[1];		       // Array size and name (variable length)
};


struct CVLFCLASS32 : public CVLF
{
   WORD   cField;		       // Number of fields
   CVCP   cvcp; 		       // Class properties
   CVTI32 cvtiField;		       // Type index of field list (CVLFFIELD)
   CVTI32 cvtiDerived;		       // Type index of derived from list (or 0)
   CVTI32 cvtiVtShape;		       // Type index of vshape table
   BYTE   rgb[1];		       // Variable length data
};


struct CVLFUNION32 : public CVLF
{
   WORD   cField;		       // Number of fields
   CVCP   cvcp; 		       // Class properties
   CVTI32 cvtiField;		       // Type index of field list (CVLFFIELD)
   BYTE   rgb[1];		       // Variable length data
};


struct CVLFENUM32 : public CVLF
{
   WORD   cField;		       // Number of fields
   CVCP   cvcp; 		       // Class properties
   CVTI32 cvti; 		       // Base type
   CVTI32 cvtiField;		       // Type index of field list (CVLFFIELD)
   char   rgch[1];		       // Length prefixed name
};


struct CVLFPROC32 : public CVLF
{
   CVTI32 cvtiReturn;		       // Type index of return value
   BYTE   cvcallt;		       // Calling convention
   BYTE   bReserved;		       // Reserved
   WORD   cArg; 		       // Number of arguments
   CVTI32 cvtiArg;		       // Type index of arg list (CVLFARG)
};


struct CVLFMFUNC32 : public CVLF
{
   CVTI32 cvtiReturn;		       // Type index of return value
   CVTI32 cvtiClass;		       // Type index of containing class
   CVTI32 cvtiThis;		       // Type index of this pointer
   BYTE   cvcallt;		       // Calling convention
   BYTE   bReserved;		       // Reserved
   WORD   cArg; 		       // Number of arguments
   CVTI32 cvtiArg;		       // Type index of arg list (CVLFARG)
   DWORD  thisadjust;		       // this adjuster (long because pad required anyway)
};


enum CV_VTS_desc_e
{
   CV_VTS_near		= 0x00,
   CV_VTS_far		= 0x01,
   CV_VTS_thin		= 0x02,
   CV_VTS_outer 	= 0x03,
   CV_VTS_meta		= 0x04,
   CV_VTS_near32	= 0x05,
   CV_VTS_far32 	= 0x06,
   CV_VTS_unused	= 0x07,
};

struct CVLFVTSHAPE : public CVLF
{
   WORD  cFunc; 		       // Number of entries in vfunctable
   BYTE  rgb[1];		       // 4 bit (CV_VTS_desc) descriptors
};


struct CVLFCOBOL0_32 : public CVLF
{
   CVTI32 cvti; 		       // Parent type record index
   BYTE   rgb[1];
};


struct CVLFCOBOL1 : public CVLF
{
   BYTE  rgb[1];
};


struct CVLFBARRAY32 : public CVLF
{
   CVTI32 cvti; 		       // Type index of underlying type
};


struct CVLFLABEL : public CVLF
{
   WORD  mode;			       // Addressing mode of label (UNDONE)
};


struct CVLFDIMARRAY32 : public CVLF
{
   CVTI32 cvti; 		       // Type index of array element
   CVTI32 cvtiDim;		       // Type index of dimension (CVLFDIMCON/CVLFDIMVAR)
   char   rgch[1];		       // Length prefixed name
};


struct CVLFCVFPATH32 : public CVLF
{
   WORD   ccvti;		       // Count of number of bases in path
   CVTI32 rgcvtiBase[1];	       // Type index of bases from root to leaf
};


struct CVLFPRECOMP32 : public CVLF
{
   DWORD cvtiStart;		       // Starting type index included
   DWORD ccvti; 		       // Number of types in inclusion
   DWORD dwSignature;		       // Signature
   char  rgch[1];		       // Length prefixed name of header file
};


struct LFENDPRECOMP : public CVLF
{
   DWORD dwSignature;		       // signature
};


struct CVLFOEM32 : public CVLF
{
   WORD   wOEMID;		       // MS assigned OEM identified
   WORD   wOEMTYPE;		       // OEM assigned type identifier
   WORD   ccvti;		       // count of type indices to follow
   CVTI32 rgcvti[1];		       // array of type indices followed
				       // by OEM defined data
};


struct CVLFTYPESERVER : public CVLF
{
   DWORD dwSignature;		       // Signature
   DWORD dwAge; 		       // Age of database used by this module
   char  rgch[1];		       // Length prefixed name of .PDB file
};


struct CVLFSKIP32 : public CVLF
{
   CVTI32 cvti; 		       // Next valid type index
   BYTE   rgb[1];		       // Padding
};


struct CVLFARGLIST32 : public CVLF
{
   WORD   cArg; 		       // Number of arguments
   CVTI32 rgcvti[1];		       // Type index of each argument
};


struct CVLFDERIVED32 : public CVLF
{
   WORD   cClass;		       // Number of derived classes
   CVTI32 rgcvti[1];		       // Type indices of derived classes
};


struct CVLFDEFARG32 : public CVLF
{
   CVTI32 cvti; 		       // Type of resulting expression
   char   rgchExpr[1];		       // Length prefixed expression string
};


struct CVLFFIELDLIST : public CVLF
{
   CVLF  rgcvlf[1];		       // Variable number of leaves
};


//  type record for non-static methods and friends in overloaded method list

struct mlMethod32
{
   CVFP   cvfp; 		       // Field properties
   WORD   wPad;
   CVTI32 cvti; 		       // Index to type record for procedure
   DWORD  vbaseoff[1];		       // Offset in vfunctable if intro virtual
};


struct CVLFMETHODLIST : public CVLF
{
   WORD  cvlft;
   BYTE  mList[1];		       // Variable number of mlMethods
};


struct CVLFBITFIELD32 : public CVLF
{
   CVTI32 cvti; 		       // Base type
   BYTE   cbit; 		       // Number of bits in field
   BYTE   position;		       // Position of field (LSB == 0?)
};


struct CVLFDIMCON32 : public CVLF
{
   CVTI32 cvti; 		       // Type of index
   WORD   rank; 		       // Number of dimensions
   BYTE   rgb[1];		       // array of dimension information with
				       // either upper bounds or lower/upper bound
};


struct CVLFDIMVAR32 : public CVLF
{
   DWORD  rank; 		       // Number of dimensions
   CVTI32 cvti; 		       // Type of index
   CVTI32 rgcvti[1];		       // array of type indices for either
				       // variable upper bound or variable
				       // lower/upper bound.  The referenced
				       // types must be LF_REFSYM or T_VOID
};


struct CVLFREFSYM : public CVLF
{
   BYTE  rgb[1];		       // Copy of referenced symbol record
};



//***********************************************************************


//	index leaf - contains type index of another leaf
//	a major use of this leaf is to allow the compilers to emit a
//	long complex list (LF_FIELD) in smaller pieces.

struct CVLFINDEX32 : public CVLF
{
   WORD   wPad;
   CVTI32 cvti; 		       // Type index of referenced leaf
};


struct CVLFBCLASS32 : public CVLF      // Base Class
{
   CVFP   cvfp; 		       // Field properties
   CVTI32 cvti32;		       // Type index of base class
   CVVAL  cvval;		       // Offset of base within class (CVVAL)
};


struct CVLFVBCLASS32 : public CVLF     // Virtual Base Class
{
   CVFP   cvfp; 		       // Field properties
   CVTI32 cvti; 		       // Type index of direct virtual base class
   CVTI32 cvtiVbptr;		       // Type index of virtual base pointer
   CVVAL  cvval;		       // Virtual base pointer offset from address point
				       // followed by virtual base offset from vbtable
};


struct CVLFFRIENDCLS32 : public CVLF   // Friend Class
{
   WORD   wPad;
   CVTI32 cvti; 		       // Type index of friend class record
};


struct CVLFFRIENDFCN32 : public CVLF   // Friend Function
{
   WORD   wPad;
   CVTI32 cvti; 		       // Type index
   char   rgchName[1];		       // Length prefixed name
};


struct CVLFMEMBER32 : public CVLF      // Member Function
{
   CVFP   cvfp; 		       // Field properties
   CVTI32 cvti; 		       // Type index of member function
   CVVAL  cvval;		       // Offset of field (CVVAL) followed by name
};


struct CVLFSTMEMBER32 : public CVLF    // Static Member Function
{
   CVFP   cvfp; 		       // Field properties
   CVTI32 cvti; 		       // Type index of member function
   char   rgchName[1];		       // Length prefixed name
};


struct CVLFVFUNCTAB32 : public CVLF    // Virtual Function Table
{
   WORD   wPad;
   CVTI32 cvti; 		       // Type index of pointer
};


struct CVLFVFUNCOFF32 : public CVLF
{
   WORD   wPad;
   CVTI32 cvti; 		       // type index of pointer
   DWORD  ib;			       // offset of virtual function table pointer
};


struct CVLFMETHOD32 : public CVLF
{
   WORD   count;		       // number of occurances of function
   CVTI32 mList;		       // index to LF_METHODLIST record
   char   rgchName[1];		       // Length prefixed name
};


struct CVLFONEMETHOD32 : public CVLF
{
   CVFP   cvfp; 		       // Field properties
   CVTI32 cvti; 		       // index to type record for procedure
   DWORD  vbaseoff[1];		       // offset in vfunctable if
				       // intro virtual followed by
				       // length prefixed name of method
};


struct CVLFENUMERATE : public CVLF
{
   CVFP  cvfp;			       // Field properties
   CVVAL cvval; 		       // Value
// char  rgchName[1];		       // Length prefixed name
};


struct CVLFNESTTYPE32 : public CVLF    // Nested Type
{
   WORD   wPad;
   CVTI32 index;		       // Type index
   char   rgchName[1];		       // Length prefixed name
};


struct CVLFNESTTYPEEX : public CVLF    // Nested Type
{
   CVFP   cvfp; 		       // Field properties
   CVTI32 index;		       // Type index
   char   rgchName[1];		       // Length prefixed name
};


struct CVLFMEMBERMODIFY : public CVLF
{
   CVFP   cvfp; 		       // Field properties
   CVTI32 index;		       // Type index
   char   rgchName[1];		       // Length prefixed name
};


struct CVTYP
{
   WORD  cb;			       // Record size excluding this word
   CVLF  cvlf;			       // Leaf record (variable sized)
};


// --------------------------------------------------------------------
//
// --------------------------------------------------------------------

enum CVSYMT
{
   cvsymtCompile	= 0x0001,      // Compile flags symbol
   cvsymtSSearch	= 0x0005,      // Start Search
   cvsymtEnd		= 0x0006,      // Block, procedure, "with" or thunk end
   cvsymtSkip		= 0x0007,      // Reserve symbol space in $$Symbols table
   cvsymtCvReserved	= 0x0008,      // Reserved symbol for CV internal use
   cvsymtObjName	= 0x0009,      // path to object file name
   cvsymtEndArg 	= 0x000a,      // end of argument/return list
   cvsymtReturn 	= 0x000d,      // return description symbol
   cvsymtEntryThis	= 0x000e,      // description of this pointer on entry

   cvsymtThunk32	= 0x0206,      // Thunk Start
   cvsymtBlock32	= 0x0207,      // block start
   cvsymtWith32 	= 0x0208,      // with start
   cvsymtLabel32	= 0x0209,      // code label
   cvsymtCExModel32	= 0x020a,      // change execution model

   cvsymtProcRef	= 0x0400,      // Reference to a procedure
   cvsymtDataRef	= 0x0401,      // Reference to data
   cvsymtAlign		= 0x0402,      // Used for page alignment of symbols
   cvsymtLProcRef	= 0x0403,      // Local Reference to a procedure

   cvsymtRegister_32	= 0x1001,      // Register variable (32 bit type index)
   cvsymtConstant_32	= 0x1002,      // constant symbol (32 bit type index)
   cvsymtUDT_32 	= 0x1003,      // User defined type (32 bit type index)
   cvsymtCOBOLUDT_32	= 0x1004,      // special UDT for cobol that does not symbol pack (32 bit type index)
   cvsymtManyReg_32	= 0x1005,      // multiple register variable (32 bit type index)
   cvsymtBPRel32_32	= 0x1006,      // BP-relative (32 bit type index)
   cvsymtLData32_32	= 0x1007,      // Module-local symbol (32 bit type index)
   cvsymtGData32_32	= 0x1008,      // Global data symbol (32 bit type index)
   cvsymtPub32_32	= 0x1009,      // A public symbol (CV internal reserved) (32 bit type index)
   cvsymtLProc32_32	= 0x100a,      // Local procedure start (32 bit type index)
   cvsymtGProc32_32	= 0x100b,      // Global procedure start (32 bit type index)
   cvsymtVFTable32_32	= 0x100c,      // address of virtual function table (32 bit type index)
   cvsymtRegRel32_32	= 0x100d,      // register relative address (32 bit type index)
   cvsymtLThread32_32	= 0x100e,      // local thread storage (32 bit type index)
   cvsymtGThread32_32	= 0x100f,      // global thread storage (32 bit type index)
   cvsymtLProcMips_32	= 0x1010,      // Local procedure start (32 bit type index)
   cvsymtGProcMips_32	= 0x1011,      // Global procedure start (32 bit type index)
   cvsymtFrameInfo	= 0x1012,      // Information regarding stack frame
   cvsymtCompile2	= 0x1013,      // Extended compile flags and info
   cvsymtManyReg2	= 0x1014,      // Compiler dependent per-procedure information
   cvsymtLProcIa64	= 0x1015,      // Local procedure start (32 bit type index)
   cvsymtGProcIa64	= 0x1016,      // Global procedure start (32 bit type index)
   cvsymtLocalSlot	= 0x1017,      // local IL sym with field for local slot index
   cvsymtParamSlot	= 0x1018,      // local IL sym with field for parameter slot index
   cvsymtAnnotation	= 0x1019,      // Annotation string literals
   cvsymtGManProc	= 0x101a,      // Global proc
   cvsymtLManProc	= 0x101b,      // Local proc
   cvsymtLManData	= 0x1020,      // Static data
   cvsymtGManData	= 0x1021,      // Global data
   cvsymtManFrameRel	= 0x1022,      // Frame relative local var or param
   cvsymtManRegister	= 0x1023,      // Register local var or param
   cvsymtManSlot	= 0x1024,      // Slot local var or param
   cvsymtManManyReg	= 0x1025,      // Multiple register local var or param
   cvsymtManRegRel	= 0x1026,      // Register relative local var or param
   cvsymtManManyReg2	= 0x1027,      // Multiple register local var or param
   cvsymtManTypRef	= 0x1028,      // Index for type referenced by name from metadata
   cvsymtUNamespace	= 0x1029,      // Using namespace

   cvsymtObjName_Sz	= 0x1101,      // path to object file name
   cvsymtThunk32_Sz	= 0x1102,      // Thunk Start
   cvsymtBlock32_Sz	= 0x1103,      // block start
   cvsymtWith32_Sz	= 0x1104,      // with start
   cvsymtLabel32_Sz	= 0x1105,      // code label
   cvsymtRegister_Sz	= 0x1106,      // Register variable
   cvsymtConstant_Sz	= 0x1107,      // constant symbol
   cvsymtUDT_Sz 	= 0x1108,      // User defined type
   cvsymtCOBOLUDT_Sz	= 0x1109,      // special UDT for cobol that does not symbol pack
   cvsymtManyReg_Sz	= 0x110a,      // multiple register variable
   cvsymtBPRel32_Sz	= 0x110b,      // BP-relative
   cvsymtLData32_Sz	= 0x110c,      // Module-local symbol
   cvsymtGData32_Sz	= 0x110d,      // Global data symbol
   cvsymtPub32_Sz	= 0x110e,      // a public symbol (CV internal reserved)
   cvsymtLProc32_Sz	= 0x110f,      // Local procedure start
   cvsymtGProc32_Sz	= 0x1110,      // Global procedure start
   cvsymtRegRel32_Sz	= 0x1111,      // register relative address
   cvsymtLThread32_Sz	= 0x1112,      // local thread storage
   cvsymtGThread32_Sz	= 0x1113,      // global thread storage
   cvsymtLProcMips_Sz	= 0x1114,      // Local procedure start
   cvsymtGProcMips_Sz	= 0x1115,      // Global procedure start
   cvsymtCompile2_Sz	= 0x1116,      // extended compile flags and info
   cvsymtManyReg2_Sz	= 0x1117,      // multiple register variable
   cvsymtLProcIa64_Sz	= 0x1118,      // Local procedure start (IA64)
   cvsymtGProcIa64_Sz	= 0x1119,      // Global procedure start (IA64)
   cvsymtLocalSlot_Sz	= 0x111a,      // local IL sym with field for local slot index
   cvsymtParamSlot_Sz	= 0x111b,      // local IL sym with field for parameter slot index
   cvsymtLManData_Sz	= 0x111c,
   cvsymtGManData_Sz	= 0x111d,
   cvsymtManFrameRel_Sz = 0x111e,
   cvsymtManRegister_Sz = 0x111f,
   cvsymtManSlot_Sz	= 0x1120,
   cvsymtManManyReg_Sz	= 0x1121,
   cvsymtManRegRel_Sz	= 0x1122,
   cvsymtManManyReg2_Sz = 0x1123,
   cvsymtUNamespace_Sz	= 0x1124,      // Using namespace
   cvsymtProcRef_Sz	= 0x1125,      // Reference to a procedure
   cvsymtDataRef_Sz	= 0x1126,      // Reference to data
   cvsymtLProcRef_Sz	= 0x1127,      // Local Reference to a procedure
   cvsymtAnnotationRef	= 0x1128,      // Reference to an S_ANNOTATION symbol
   cvsymtTokenRef	= 0x1129,      // Reference to one of the many MANPROCSYM's
   cvsymtGManProc_Sz	= 0x112a,      // Global proc
   cvsymtLManProc_Sz	= 0x112b,      // Local proc
   cvsymtTrampoline	= 0x112c,      // Trampoline thunks
   cvsymtManConstant	= 0x112d,      // Constants with metadata type info
};


enum CVLANG			       // CodeView Language
{
   cvlangC		= 0x00,
   cvlangCxx		= 0x01,
   cvlangFORTRAN	= 0x02,
   cvlangMasm		= 0x03,
   cvlangPascal 	= 0x04,
   cvlangBasic		= 0x05,
   cvlangCOBOL		= 0x06,
   cvlangLink		= 0x07,
   cvlangCvtres 	= 0x08,
};


enum CVCPU			       // CodeView CPU
{
   cvcpu8080		= 0x00,
   cvcpu8086		= 0x01,
   cvcpu80286		= 0x02,
   cvcpu80386		= 0x03,
   cvcpu80486		= 0x04,
   cvcpuPentium 	= 0x05,
   cvcpuPentiumII	= 0x06,
   cvcpuPentiumIII	= 0x07,
   cvcpuMips		= 0x10,
   cvcpuMips16		= 0x11,
   cvcpuMips32		= 0x12,
   cvcpuMips64		= 0x13,
   cvcpuMipsI		= 0x14,
   cvcpuMipsII		= 0x15,
   cvcpuMipsIII 	= 0x16,
   cvcpuMipsIV		= 0x17,
   cvcpuMipsV		= 0x18,
   cvcpuM68000		= 0x20,
   cvcpuM68010		= 0x21,
   cvcpuM68020		= 0x22,
   cvcpuM68030		= 0x23,
   cvcpuM68040		= 0x24,
   cvcpuAlpha21064	= 0x30,
   cvcpuAlpha21164	= 0x31,
   cvcpuAlpha21164A	= 0x32,
   cvcpuAlpha21264	= 0x33,
   cvcpuAlpha21364	= 0x34,
   cvcpuPpc601		= 0x40,
   cvcpuPpc603		= 0x41,
   cvcpuPpc604		= 0x42,
   cvcpuPpc620		= 0x43,
   cvcpuSh3		= 0x50,
   cvcpuSh3E		= 0x51,
   cvcpuSh3Dsp		= 0x52,
   cvcpuSh4		= 0x53,
   cvcpuArm3		= 0x60,
   cvcpuArm4		= 0x61,
   cvcpuArm4T		= 0x62,
   cvcpuIA64		= 0x80,
   cvcpuCee		= 0x90,
   cvcpuAM33		= 0xA0,
   cvcpuM32R		= 0xB0,
   cvcpuTriCore 	= 0xC0,
   cvcpuX86_64		= 0xD0,
};


//  enum describing compile flag ambiant data model

enum CV_CFL_DATA
{
   CV_CFL_DNEAR 	= 0x00,
   CV_CFL_DFAR		= 0x01,
   CV_CFL_DHUGE 	= 0x02,
};


// enum describing compile flag ambiant code model

enum CV_CFL_CODE_e
{
   CV_CFL_CNEAR 	= 0x00,
   CV_CFL_CFAR		= 0x01,
   CV_CFL_CHUGE 	= 0x02,
};


// enum describing compile flag target floating point package

enum CV_CFL_FPKG_e
{
   CV_CFL_NDP		= 0x00,
   CV_CFL_EMU		= 0x01,
   CV_CFL_ALT		= 0x02,
};


// enum describing function return method


struct CV_PROCFLAGS
{
   BYTE  fFPO		: 1;	    // Frame pointer omitted
   BYTE  fInterrupt	: 1;	    // Interrupt return
   BYTE  fFar		: 1;	    // Far return
   BYTE  fNoReturn	: 1;	    // Function does not return
   BYTE  fNoFallThrough : 1;	    // Label isn't fallen into
   BYTE 		: 3;	    // Unused
};


// enum describing function data return method

enum CV_GENERIC_STYLE_e
{
   CV_GENERIC_VOID   = 0x00,	   // void return type
   CV_GENERIC_REG    = 0x01,	   // return data is in registers
   CV_GENERIC_ICAN   = 0x02,	   // indirect caller allocated near
   CV_GENERIC_ICAF   = 0x03,	   // indirect caller allocated far
   CV_GENERIC_IRAN   = 0x04,	   // indirect returnee allocated near
   CV_GENERIC_IRAF   = 0x05,	   // indirect returnee allocated far
   CV_GENERIC_UNUSED = 0x06	   // first unused
};


struct CV_GENERIC_FLAG
{
   WORD  cstyle  :1;	 // true push varargs right to left
   WORD  rsclean :1;	 // true if returnee stack cleanup
   WORD  unused  :14;	 // unused
};





struct CVSYM
{
   WORD  cb;			       // Record size excluding this word
   WORD  cvsymt;		       // Symbol type
};


struct CVSYMSEARCH : public CVSYM
{
   DWORD startsym;		       // Offset of the procedure
   WORD  lsn;			       // Logical segment/section number
};


struct CVSYMCFLAG : public CVSYM
{
   unsigned char   machine;    // target processor
   struct CVSYM
   {
      unsigned char   language	  :8; // language index
      unsigned char   pcode	  :1; // true if pcode present
      unsigned char   floatprec   :2; // floating precision
      unsigned char   floatpkg	  :2; // float package
      unsigned char   ambdata	  :3; // ambiant data model
      unsigned char   ambcode	  :3; // ambiant code model
      unsigned char   mode32	  :1; // true if compiled 32 bit mode
      unsigned char   pad	  :4; // reserved
   } flags;
   unsigned char       ver[1];	   // Length-prefixed compiler version string
};


struct CVSYMOBJNAME : public CVSYM
{
   DWORD dwSignature;		       // signature
   char  rgchName[1];		       // Length prefixed name
};


struct CVSYMENDARG : public CVSYM
{
};


struct CVSYMRETURN : public CVSYM
{
   CV_GENERIC_FLAG flags;      // flags
   CV_GENERIC_STYLE_e style;   // return style
			       // followed by return method data
};


struct CVSYMENTRYTHIS : public CVSYM
{
   unsigned char   thissym;    // symbol describing this pointer on entry
};


enum THUNK_ORDINAL
{
   THUNK_ORDINAL_NOTYPE,
   THUNK_ORDINAL_ADJUSTOR,
   THUNK_ORDINAL_VCALL,
   THUNK_ORDINAL_PCODE
};


enum CEXM_MODEL_e
{
   CEXM_MDL_table	  = 0x00,      // not executable
   CEXM_MDL_jumptable	  = 0x01,      // Compiler generated jump table
   CEXM_MDL_datapad	  = 0x02,      // Data padding for alignment
   CEXM_MDL_native	  = 0x20,      // native (actually not-pcode)
   CEXM_MDL_cobol	  = 0x21,      // cobol
   CEXM_MDL_codepad	  = 0x22,      // Code padding for alignment
   CEXM_MDL_code	  = 0x23,      // code
   CEXM_MDL_pcode	  = 0x40,      // pcode
   CEXM_MDL_pcode32Mac	  = 0x41,      // pcode 32-bit
   CEXM_MDL_pcode32MacNep = 0x42       // pcode 32-bit Native Entry Point
};


enum CV_COBOL_e
{
   CV_COBOL_dontstop,
   CV_COBOL_pfm,
   CV_COBOL_false,
   CV_COBOL_extcall
};


enum CV_PUBSYMFLAGS_e
{
   cvpsfNone	  = 0x00000000,
   cvpsfCode	  = 0x00000001,
   cvpsfFunction  = 0x00000002,
   cvpsfManaged   = 0x00000004,
};


struct CV_PUBSYMFLAGS
{
   DWORD fCode	     : 1;	       // Set if public symbol refers to a code address
   DWORD fFunction   : 1;	       // Set if public symbol is a function
   DWORD fManaged    : 1;	       // Set if managed code
   DWORD	     : 29;	       // Must be zero
};


struct CVSYMPUB32 : public CVSYM
{
   CV_PUBSYMFLAGS  flags;
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMTHUNK32 : public CVSYM
{
   DWORD    pParent;		       // pointer to the parent
   DWORD    pEnd;		       // pointer to this blocks end
   DWORD    pNext;		       // pointer to next symbol
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   WORD     cb; 		       // length of thunk
   BYTE     ord;		       // ordinal specifying type of thunk
   char     rgchName[1];	       // Length prefixed name
   BYTE     variant[1]; 	       // variant portion of thunk
};


struct CVSYMLABEL32 : public CVSYM
{
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   CV_PROCFLAGS    flags;	       // flags
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMBLOCK32 : public CVSYM
{
   DWORD    pParent;		       // pointer to the parent
   DWORD    pEnd;		       // pointer to this blocks end
   DWORD    cb; 		       // Block length
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMWITH32 : public CVSYM
{
   DWORD    pParent;		       // pointer to the parent
   DWORD    pEnd;		       // pointer to this blocks end
   DWORD    cb; 		       // Block length
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   char     rgchExpr[1];	       // Length prefixed expression string
};


struct CVSYMCEXM32 : public CVSYM
{
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   WORD     model;		       // execution model
   union var32
   {
      struct _PCODE
      {
	 DWORD pcdtable;	       // Offset to pcode function table
	 DWORD pcdspi;		       // Offset to segment pcode information
      } pcode;

      struct _PCODE32MAC
      {
	  DWORD calltableOff;	       // offset to function table
	  unsigned short calltableSeg; // segment of function table
      } pcode32Mac;

      struct _COBOL
      {
	 WORD  subtype; 	       // See CV_COBOL_e
	 WORD  flag;
      } cobol;
   };
};


struct CVSYMREG_32 : public CVSYM
{
   CVTI32   cvti;		       // Type index
   WORD     wReg;		       // Register enumerate
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMCONST_32 : public CVSYM
{
   CVTI32   cvti;		       // Type index
   CVVAL    cvval;		       // Value
// char     rgchName[1];	       // Length prefixed name
};


struct CVSYMUDT_32 : public CVSYM
{
   CVTI32   cvti;		       // Type index
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMMANYREG_32 : public CVSYM
{
   CVTI32   cvti;		       // Type index
   BYTE     creg;		       // Count of number of registers
   BYTE     rgbReg[1];		       // Register enumerates
				       // Registers are most significant first.
// char     rgchName[1];	       // Length prefixed name
};


struct CVSYMBPREL32_32 : public CVSYM
{
   DWORD    ib; 		       // BP-relative offset
   CVTI32   cvti;		       // Type index (32 bit)
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMDATA32_32 : public CVSYM
{
   CVTI32   cvti;		       // Type index (32 bit)
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMPROC32_32 : public CVSYM
{
   DWORD    pParent;		       // pointer to the parent
   DWORD    pEnd;		       // pointer to this blocks end
   DWORD    pNext;		       // pointer to next symbol
   DWORD    cb; 		       // Proc length
   DWORD    DbgStart;		       // Debug start offset
   DWORD    DbgEnd;		       // Debug end offset
   CVTI32   cvti;		       // Type index (32 bit)
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   CV_PROCFLAGS    flags;	       // Proc flags
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMREGREL32_32 : public CVSYM
{
   DWORD    ib; 		       // Offset of symbol
   CVTI32   cvti;		       // Type index (32 bit)
   WORD     wReg;		       // Register enumerate
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMTHREAD32_32 : public CVSYM
{
   CVTI32   cvti;		       // Type index (32 bit)
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMPROCMIPS_32 : public CVSYM
{
   DWORD    pParent;		       // pointer to the parent
   DWORD    pEnd;		       // pointer to this blocks end
   DWORD    pNext;		       // pointer to next symbol
   DWORD    cb; 		       // Proc length
   DWORD    DbgStart;		       // Debug start offset
   DWORD    DbgEnd;		       // Debug end offset
   DWORD    regSave;		       // int register save mask
   DWORD    fpSave;		       // fp register save mask
   DWORD    intib;		       // int register save offset
   DWORD    fpib;		       // fp register save offset
   CVTI32   cvti;		       // Type index (32 bit)
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   BYTE     retReg;		       // Register return value is in
   BYTE     frameReg;		       // Frame pointer register
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMFRAMEINFO : public CVSYM
{
   DWORD    cbFrame;		       // Count of bytes of total frame of procedure
   DWORD    cbPad;		       // Count of bytes of padding in the frame
   DWORD    ibPad;		       // Offset in the frame of start of the padding
   DWORD    cbSaveRegs;
   DWORD    ibHandler;		       // Segment/section relative offset of handler
   WORD     lsnHandler; 	       // Logical segment/section number of handler
   union
   {
      struct
      {
	 DWORD	  fHasAlloca  : 1;     // Function uses _alloca()
	 DWORD	  fHasSetJmp  : 1;     // Function uses setjmp()
	 DWORD	  fHasLongJmp : 1;     // Function uses longjmp()
	 DWORD	  fHasInlAsm  : 1;     // Function uses inline asm
	 DWORD	  fHasEH      : 1;     // Function has EH states
	 DWORD	  fInlSpec    : 1;     // Function has declated as inline
	 DWORD	  fHasSEH     : 1;     // Function has SEH
	 DWORD	  Reserved    : 25;    // Must be zero
      } s;

      DWORD	  dwFlags;
   } u;
};


struct CVSYMCOMPILE2  : public CVSYM
{
   union
   {
      struct
      {
	 DWORD	  iLanguage	  : 8;
	 DWORD	  fEC		  : 1; // Compiled for edit and continue
	 DWORD	  fNoDbgInfo	  : 1; // not compiled with debug info
	 DWORD	  fLTCG 	  : 1; // compiled with LTCG
	 DWORD	  fNoDataAlign	  : 1; // compiled with -Bzalign
	 DWORD	  fManagedPresent : 1; // managed code/data present
	 DWORD	  Reserved : 19;       // Must be zero
      } s;

      DWORD	  dwFlags;
   } u;
   WORD     wMachine;		       // Target processor (same as COFF/PE machine type)
   WORD     verFEMajor; 	       // Front end major version #
   WORD     verFEMinor; 	       // Front end minor version #
   WORD     verFEBuild; 	       // Front end build version #
   WORD     verMajor;		       // Back end major version #
   WORD     verMinor;		       // Back end minor version #
   WORD     verBuild;		       // Back end build version #
   char     rgchVer[1]; 	       // Length-prefixed compiler version string

   // What follows is an optional block of zero terminated strings terminated by two zeros
};


struct CVSYMPROCIA64 : public CVSYM
{
   DWORD    pParent;		       // pointer to the parent
   DWORD    pEnd;		       // pointer to this blocks end
   DWORD    pNext;		       // pointer to next symbol
   DWORD    cb; 		       // Proc length
   DWORD    DbgStart;		       // Debug start offset
   DWORD    DbgEnd;		       // Debug end offset
   CVTI32   cvti;		       // Type index (32 bit)
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   WORD     retReg;		       // Register return value is in
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMREF : public CVSYM
{
   DWORD    sumName;		       // SUC of the name
   DWORD    ibSym;		       // Offset of actual symbol in $$Symbols
   WORD     imod;		       // Module containing the actual symbol
   WORD     usFill;		       // align this record
};


struct CVSYMALIGN : public CVSYM
{
};


struct CVSYMSLOT : public CVSYM
{
   DWORD    iSlot;		       // slot index
   CVTI32   cvti;		       // Type index (32 bit)
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMMANPROC : public CVSYM
{
   DWORD    pParent;		       // pointer to the parent
   DWORD    pEnd;		       // pointer to this blocks end
   DWORD    pNext;		       // pointer to next symbol
   DWORD    cb; 		       // Proc length
   DWORD    DbgStart;		       // Debug start offset
   DWORD    DbgEnd;		       // Debug end offset
   DWORD    token;		       // COM+ metadata token for method
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   CV_PROCFLAGS    flags;	       // Proc flags
   WORD     retReg;		       // Register return value is in
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMMANPROCMIPS : public CVSYM
{
   DWORD    pParent;		       // pointer to the parent
   DWORD    pEnd;		       // pointer to this blocks end
   DWORD    pNext;		       // pointer to next symbol
   DWORD    cb; 		       // Proc length
   DWORD    DbgStart;		       // Debug start offset
   DWORD    DbgEnd;		       // Debug end offset
   DWORD    regSave;		       // int register save mask
   DWORD    fpSave;		       // fp register save mask
   DWORD    intib;		       // int register save offset
   DWORD    fpib;		       // fp register save offset
   DWORD    token;		       // COM+ metadata token for method
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   BYTE     retReg;		       // Register return value is in
   BYTE     frameReg;		       // Frame pointer register
   char     rgchName[1];	       // Length prefixed name
};


struct CVSYMANNOTATION : public CVSYM
{
   DWORD    ib; 		       // Segment/section relative offset
   WORD     lsn;		       // Logical segment/section number
   WORD     csz;		       // Count of zero terminated annotation strings
   char     rgsz[1];		       // Sequence of zero terminated annotation strings
};


struct CVSYMUNAMESPACE : public CVSYM
{
   char     rgchName[1];	       // Length prefixed name
};


enum CVTRAMPT			       // Trampoline subtype
{
   cvtramptIncremental, 	       // Incremental thunks
   cvtramptBranchIsland,	       // Branch island thunks
};


struct CVSYMTRAMPOLINE : public CVSYM
{
   WORD     cvtrampt;		       // Trampoline sym subtype
   WORD     cb; 		       // Trampoline length
   DWORD    ib; 		       // Segment/section relative offset
   DWORD    ibTarget;		       // Segment/section relative offset of target
   WORD     lsn;		       // Logical segment/section number
   WORD     lsnTarget;		       // Logical segment/section number of target
};

// UNDONE: For srcline stuff - will turn them into CVSYM later.


   // Source line to address mapping table.
   // This table is generated by the link/ilink utility from line number
   // information contained in the object file OMF data.  This table contains
   // only the code contribution for one segment from one source file.

struct CVSRCLINE
{
   WORD     Seg;		       // linker segment index
   WORD     cLnOff;		       // count of line/offset pairs
   DWORD    offset[1];		       // array of offsets in segment
   WORD     lineNbr[1]; 	       // array of line lumber in source
};


   // Source file description
   // This table is generated by the linker

struct CVSRCFILE
{
   WORD     cSeg;		       // number of segments from source file
   WORD     reserved;		       // reserved
   DWORD    baseSrcLn[1];	       // base of OMFSourceLine tables
				       // this array is followed by array
				       // of segment start/end pairs followed by
				       // an array of linker indices
				       // for each segment in the file
   WORD     cFName;		       // length of source file name
   char     Name;		       // name of file padded to long boundary
};


   // Source line to address mapping header structure
   // This structure describes the number and location of the
   // OMFAddrLine tables for a module.	The offSrcLine entries are
   // relative to the beginning of this structure.

struct CVSRC
{
   WORD     cFile;		    // number of OMFSourceTables
   WORD     cSeg;		    // number of segments in module
   DWORD    baseSrcFile[1];	    // base of OMFSourceFile table
                                    // this array is followed by array
                                    // of segment start/end pairs followed
                                    // by an array of linker indices
                                    // for each segment in the module
};

// UNDONE: End


enum CV_HREG_e
{
   // Register subset shared by all processor types,
   // must not overlap with any of the ranges below and yet must fit
   // in a byte

   CV_ALLREG_ERR     = 250,
   CV_ALLREG_TEB     = 251,

   // Register set for the x86 processor series (plus PCODE registers)

   CV_REG_NONE	     =	 0,
   CV_REG_AL	     =	 1,
   CV_REG_CL	     =	 2,
   CV_REG_DL	     =	 3,
   CV_REG_BL	     =	 4,
   CV_REG_AH	     =	 5,
   CV_REG_CH	     =	 6,
   CV_REG_DH	     =	 7,
   CV_REG_BH	     =	 8,
   CV_REG_AX	     =	 9,
   CV_REG_CX	     =	10,
   CV_REG_DX	     =	11,
   CV_REG_BX	     =	12,
   CV_REG_SP	     =	13,
   CV_REG_BP	     =	14,
   CV_REG_SI	     =	15,
   CV_REG_DI	     =	16,
   CV_REG_EAX	     =	17,
   CV_REG_ECX	     =	18,
   CV_REG_EDX	     =	19,
   CV_REG_EBX	     =	20,
   CV_REG_ESP	     =	21,
   CV_REG_EBP	     =	22,
   CV_REG_ESI	     =	23,
   CV_REG_EDI	     =	24,
   CV_REG_ES	     =	25,
   CV_REG_CS	     =	26,
   CV_REG_SS	     =	27,
   CV_REG_DS	     =	28,
   CV_REG_FS	     =	29,
   CV_REG_GS	     =	30,
   CV_REG_IP	     =	31,
   CV_REG_FLAGS      =	32,
   CV_REG_EIP	     =	33,
   CV_REG_EFLAGS     =	34,
   CV_REG_TEMP	     =	40,	       // PCODE Temp
   CV_REG_TEMPH      =	41,	       // PCODE TempH
   CV_REG_QUOTE      =	42,	       // PCODE Quote
   CV_REG_PCDR3      =	43,	       // PCODE reserved
   CV_REG_PCDR4      =	44,	       // PCODE reserved
   CV_REG_PCDR5      =	45,	       // PCODE reserved
   CV_REG_PCDR6      =	46,	       // PCODE reserved
   CV_REG_PCDR7      =	47,	       // PCODE reserved
   CV_REG_CR0	     =	80,	       // CR0 -- control registers
   CV_REG_CR1	     =	81,
   CV_REG_CR2	     =	82,
   CV_REG_CR3	     =	83,
   CV_REG_DR0	     =	90,	       // Debug register
   CV_REG_DR1	     =	91,
   CV_REG_DR2	     =	92,
   CV_REG_DR3	     =	93,
   CV_REG_DR4	     =	94,
   CV_REG_DR5	     =	95,
   CV_REG_DR6	     =	96,
   CV_REG_DR7	     =	97,
   CV_REG_ST0	     = 128,
   CV_REG_ST1	     = 129,
   CV_REG_ST2	     = 130,
   CV_REG_ST3	     = 131,
   CV_REG_ST4	     = 132,
   CV_REG_ST5	     = 133,
   CV_REG_ST6	     = 134,
   CV_REG_ST7	     = 135,
   CV_REG_CTRL	     = 136,
   CV_REG_STAT	     = 137,
   CV_REG_TAG	     = 138,
   CV_REG_FPIP	     = 139,
   CV_REG_FPCS	     = 140,
   CV_REG_FPDO	     = 141,
   CV_REG_FPDS	     = 142,
   CV_REG_ISEM	     = 143,
   CV_REG_FPEIP      = 144,
   CV_REG_FPEDO      = 145,
   CV_REG_MM0	     = 146,
   CV_REG_MM1	     = 147,
   CV_REG_MM2	     = 148,
   CV_REG_MM3	     = 149,
   CV_REG_MM4	     = 150,
   CV_REG_MM5	     = 151,
   CV_REG_MM6	     = 152,
   CV_REG_MM7	     = 153,

   // Registers for the 68K processors

   CV_R68_D0	     =	0,
   CV_R68_D1	     =	1,
   CV_R68_D2	     =	2,
   CV_R68_D3	     =	3,
   CV_R68_D4	     =	4,
   CV_R68_D5	     =	5,
   CV_R68_D6	     =	6,
   CV_R68_D7	     =	7,
   CV_R68_A0	     =	8,
   CV_R68_A1	     =	9,
   CV_R68_A2	     = 10,
   CV_R68_A3	     = 11,
   CV_R68_A4	     = 12,
   CV_R68_A5	     = 13,
   CV_R68_A6	     = 14,
   CV_R68_A7	     = 15,
   CV_R68_CCR	     = 16,
   CV_R68_SR	     = 17,
   CV_R68_USP	     = 18,
   CV_R68_MSP	     = 19,
   CV_R68_SFC	     = 20,
   CV_R68_DFC	     = 21,
   CV_R68_CACR	     = 22,
   CV_R68_VBR	     = 23,
   CV_R68_CAAR	     = 24,
   CV_R68_ISP	     = 25,
   CV_R68_PC	     = 26,

   // Reserved 27

   CV_R68_FPCR	     = 28,
   CV_R68_FPSR	     = 29,
   CV_R68_FPIAR      = 30,

   // Reserved 31

   CV_R68_FP0	     = 32,
   CV_R68_FP1	     = 33,
   CV_R68_FP2	     = 34,
   CV_R68_FP3	     = 35,
   CV_R68_FP4	     = 36,
   CV_R68_FP5	     = 37,
   CV_R68_FP6	     = 38,
   CV_R68_FP7	     = 39,

   // Reserved 40-50

   CV_R68_PSR	     = 51,
   CV_R68_PCSR	     = 52,
   CV_R68_VAL	     = 53,
   CV_R68_CRP	     = 54,
   CV_R68_SRP	     = 55,
   CV_R68_DRP	     = 56,
   CV_R68_TC	     = 57,
   CV_R68_AC	     = 58,
   CV_R68_SCC	     = 59,
   CV_R68_CAL	     = 60,
   CV_R68_TT0	     = 61,
   CV_R68_TT1	     = 62,

   // Reserved 63

   CV_R68_BAD0	     = 64,
   CV_R68_BAD1	     = 65,
   CV_R68_BAD2	     = 66,
   CV_R68_BAD3	     = 67,
   CV_R68_BAD4	     = 68,
   CV_R68_BAD5	     = 69,
   CV_R68_BAD6	     = 70,
   CV_R68_BAD7	     = 71,
   CV_R68_BAC0	     = 72,
   CV_R68_BAC1	     = 73,
   CV_R68_BAC2	     = 74,
   CV_R68_BAC3	     = 75,
   CV_R68_BAC4	     = 76,
   CV_R68_BAC5	     = 77,
   CV_R68_BAC6	     = 78,
   CV_R68_BAC7	     = 79,

   // Register set for the MIPS R4000

   CV_M4_NOREG	     = CV_REG_NONE,

   CV_M4_IntZERO     = 10,	       // General purpose registers
   CV_M4_IntAT	     = 11,
   CV_M4_IntV0	     = 12,
   CV_M4_IntV1	     = 13,
   CV_M4_IntA0	     = 14,
   CV_M4_IntA1	     = 15,
   CV_M4_IntA2	     = 16,
   CV_M4_IntA3	     = 17,
   CV_M4_IntT0	     = 18,
   CV_M4_IntT1	     = 19,
   CV_M4_IntT2	     = 20,
   CV_M4_IntT3	     = 21,
   CV_M4_IntT4	     = 22,
   CV_M4_IntT5	     = 23,
   CV_M4_IntT6	     = 24,
   CV_M4_IntT7	     = 25,
   CV_M4_IntS0	     = 26,
   CV_M4_IntS1	     = 27,
   CV_M4_IntS2	     = 28,
   CV_M4_IntS3	     = 29,
   CV_M4_IntS4	     = 30,
   CV_M4_IntS5	     = 31,
   CV_M4_IntS6	     = 32,
   CV_M4_IntS7	     = 33,
   CV_M4_IntT8	     = 34,
   CV_M4_IntT9	     = 35,
   CV_M4_IntKT0      = 36,
   CV_M4_IntKT1      = 37,
   CV_M4_IntGP	     = 38,
   CV_M4_IntSP	     = 39,
   CV_M4_IntS8	     = 40,
   CV_M4_IntRA	     = 41,
   CV_M4_IntLO	     = 42,
   CV_M4_IntHI	     = 43,

   CV_M4_Fir	     = 50,
   CV_M4_Psr	     = 51,

   CV_M4_FltF0	     = 60,	       // Floating point registers
   CV_M4_FltF1	     = 61,
   CV_M4_FltF2	     = 62,
   CV_M4_FltF3	     = 63,
   CV_M4_FltF4	     = 64,
   CV_M4_FltF5	     = 65,
   CV_M4_FltF6	     = 66,
   CV_M4_FltF7	     = 67,
   CV_M4_FltF8	     = 68,
   CV_M4_FltF9	     = 69,
   CV_M4_FltF10      = 70,
   CV_M4_FltF11      = 71,
   CV_M4_FltF12      = 72,
   CV_M4_FltF13      = 73,
   CV_M4_FltF14      = 74,
   CV_M4_FltF15      = 75,
   CV_M4_FltF16      = 76,
   CV_M4_FltF17      = 77,
   CV_M4_FltF18      = 78,
   CV_M4_FltF19      = 79,
   CV_M4_FltF20      = 80,
   CV_M4_FltF21      = 81,
   CV_M4_FltF22      = 82,
   CV_M4_FltF23      = 83,
   CV_M4_FltF24      = 84,
   CV_M4_FltF25      = 85,
   CV_M4_FltF26      = 86,
   CV_M4_FltF27      = 87,
   CV_M4_FltF28      = 88,
   CV_M4_FltF29      = 89,
   CV_M4_FltF30      = 90,
   CV_M4_FltF31      = 91,
   CV_M4_FltFsr      = 92,

   // Register set for the ALPHA AXP

   CV_ALPHA_NOREG    = CV_REG_NONE,

   CV_ALPHA_FltF0 = 10, 	       // Floating point registers
   CV_ALPHA_FltF1,     // 11
   CV_ALPHA_FltF2,     // 12
   CV_ALPHA_FltF3,     // 13
   CV_ALPHA_FltF4,     // 14
   CV_ALPHA_FltF5,     // 15
   CV_ALPHA_FltF6,     // 16
   CV_ALPHA_FltF7,     // 17
   CV_ALPHA_FltF8,     // 18
   CV_ALPHA_FltF9,     // 19
   CV_ALPHA_FltF10,    // 20
   CV_ALPHA_FltF11,    // 21
   CV_ALPHA_FltF12,    // 22
   CV_ALPHA_FltF13,    // 23
   CV_ALPHA_FltF14,    // 24
   CV_ALPHA_FltF15,    // 25
   CV_ALPHA_FltF16,    // 26
   CV_ALPHA_FltF17,    // 27
   CV_ALPHA_FltF18,    // 28
   CV_ALPHA_FltF19,    // 29
   CV_ALPHA_FltF20,    // 30
   CV_ALPHA_FltF21,    // 31
   CV_ALPHA_FltF22,    // 32
   CV_ALPHA_FltF23,    // 33
   CV_ALPHA_FltF24,    // 34
   CV_ALPHA_FltF25,    // 35
   CV_ALPHA_FltF26,    // 36
   CV_ALPHA_FltF27,    // 37
   CV_ALPHA_FltF28,    // 38
   CV_ALPHA_FltF29,    // 39
   CV_ALPHA_FltF30,    // 30
   CV_ALPHA_FltF31,    // 41

   CV_ALPHA_IntV0,     // 42   Integer registers
   CV_ALPHA_IntT0,     // 43
   CV_ALPHA_IntT1,     // 44
   CV_ALPHA_IntT2,     // 45
   CV_ALPHA_IntT3,     // 46
   CV_ALPHA_IntT4,     // 47
   CV_ALPHA_IntT5,     // 48
   CV_ALPHA_IntT6,     // 49
   CV_ALPHA_IntT7,     // 50
   CV_ALPHA_IntS0,     // 51
   CV_ALPHA_IntS1,     // 52
   CV_ALPHA_IntS2,     // 53
   CV_ALPHA_IntS3,     // 54
   CV_ALPHA_IntS4,     // 55
   CV_ALPHA_IntS5,     // 56
   CV_ALPHA_IntFP,     // 57
   CV_ALPHA_IntA0,     // 58
   CV_ALPHA_IntA1,     // 59
   CV_ALPHA_IntA2,     // 60
   CV_ALPHA_IntA3,     // 61
   CV_ALPHA_IntA4,     // 62
   CV_ALPHA_IntA5,     // 63
   CV_ALPHA_IntT8,     // 64
   CV_ALPHA_IntT9,     // 65
   CV_ALPHA_IntT10,    // 66
   CV_ALPHA_IntT11,    // 67
   CV_ALPHA_IntRA,     // 68
   CV_ALPHA_IntT12,    // 69
   CV_ALPHA_IntAT,     // 70
   CV_ALPHA_IntGP,     // 71
   CV_ALPHA_IntSP,     // 72
   CV_ALPHA_IntZERO,   // 73

   CV_ALPHA_Fpcr,      // 74   Control registers
   CV_ALPHA_Fir,       // 75
   CV_ALPHA_Psr,       // 76
   CV_ALPHA_FltFsr,    // 77
   CV_ALPHA_SoftFpcr,  // 78

   // Register set for the PowerPC

   CV_PPC_GPR0	     =	1,	       // General Registers ( User Level )
   CV_PPC_GPR1	     =	2,
   CV_PPC_GPR2	     =	3,
   CV_PPC_GPR3	     =	4,
   CV_PPC_GPR4	     =	5,
   CV_PPC_GPR5	     =	6,
   CV_PPC_GPR6	     =	7,
   CV_PPC_GPR7	     =	8,
   CV_PPC_GPR8	     =	9,
   CV_PPC_GPR9	     = 10,
   CV_PPC_GPR10      = 11,
   CV_PPC_GPR11      = 12,
   CV_PPC_GPR12      = 13,
   CV_PPC_GPR13      = 14,
   CV_PPC_GPR14      = 15,
   CV_PPC_GPR15      = 16,
   CV_PPC_GPR16      = 17,
   CV_PPC_GPR17      = 18,
   CV_PPC_GPR18      = 19,
   CV_PPC_GPR19      = 20,
   CV_PPC_GPR20      = 21,
   CV_PPC_GPR21      = 22,
   CV_PPC_GPR22      = 23,
   CV_PPC_GPR23      = 24,
   CV_PPC_GPR24      = 25,
   CV_PPC_GPR25      = 26,
   CV_PPC_GPR26      = 27,
   CV_PPC_GPR27      = 28,
   CV_PPC_GPR28      = 29,
   CV_PPC_GPR29      = 30,
   CV_PPC_GPR30      = 31,
   CV_PPC_GPR31      = 32,

   CV_PPC_CR	     = 33,	       // Condition Register ( User Level )
   CV_PPC_CR0	     = 34,
   CV_PPC_CR1	     = 35,
   CV_PPC_CR2	     = 36,
   CV_PPC_CR3	     = 37,
   CV_PPC_CR4	     = 38,
   CV_PPC_CR5	     = 39,
   CV_PPC_CR6	     = 40,
   CV_PPC_CR7	     = 41,

   CV_PPC_FPR0	     = 42,	       // Floating Point Registers ( User Level )
   CV_PPC_FPR1	     = 43,
   CV_PPC_FPR2	     = 44,
   CV_PPC_FPR3	     = 45,
   CV_PPC_FPR4	     = 46,
   CV_PPC_FPR5	     = 47,
   CV_PPC_FPR6	     = 48,
   CV_PPC_FPR7	     = 49,
   CV_PPC_FPR8	     = 50,
   CV_PPC_FPR9	     = 51,
   CV_PPC_FPR10      = 52,
   CV_PPC_FPR11      = 53,
   CV_PPC_FPR12      = 54,
   CV_PPC_FPR13      = 55,
   CV_PPC_FPR14      = 56,
   CV_PPC_FPR15      = 57,
   CV_PPC_FPR16      = 58,
   CV_PPC_FPR17      = 59,
   CV_PPC_FPR18      = 60,
   CV_PPC_FPR19      = 61,
   CV_PPC_FPR20      = 62,
   CV_PPC_FPR21      = 63,
   CV_PPC_FPR22      = 64,
   CV_PPC_FPR23      = 65,
   CV_PPC_FPR24      = 66,
   CV_PPC_FPR25      = 67,
   CV_PPC_FPR26      = 68,
   CV_PPC_FPR27      = 69,
   CV_PPC_FPR28      = 70,
   CV_PPC_FPR29      = 71,
   CV_PPC_FPR30      = 72,
   CV_PPC_FPR31      = 73,

   CV_PPC_FPSCR      = 74,	       // Floating Point Status and Control Register ( User Level )

   CV_PPC_MSR	     = 75,	       // Machine State Register ( Supervisor Level )

   CV_PPC_SR0	     = 76,	       // Segment Registers ( Supervisor Level )
   CV_PPC_SR1	     = 77,
   CV_PPC_SR2	     = 78,
   CV_PPC_SR3	     = 79,
   CV_PPC_SR4	     = 80,
   CV_PPC_SR5	     = 81,
   CV_PPC_SR6	     = 82,
   CV_PPC_SR7	     = 83,
   CV_PPC_SR8	     = 84,
   CV_PPC_SR9	     = 85,
   CV_PPC_SR10	     = 86,
   CV_PPC_SR11	     = 87,
   CV_PPC_SR12	     = 88,
   CV_PPC_SR13	     = 89,
   CV_PPC_SR14	     = 90,
   CV_PPC_SR15	     = 91,

   /*
   ** For all of the special purpose registers add 100 to the SPR# that the
   ** Motorola/IBM documentation gives with the exception of any imaginary
   ** registers.
   */

   CV_PPC_PC	     = 99,	       // PC (imaginary register)

   CV_PPC_MQ	     = 100,	       // MPC601
   CV_PPC_XER	     = 101,
   CV_PPC_RTCU	     = 104,	       // MPC601
   CV_PPC_RTCL	     = 105,	       // MPC601
   CV_PPC_LR	     = 108,
   CV_PPC_CTR	     = 109,

   CV_PPC_COMPARE    = 110,	       // part of XER (internal to the debugger only)
   CV_PPC_COUNT      = 111,	       // part of XER (internal to the debugger only)

   CV_PPC_DSISR      = 118,	       // Special Purpose Registers ( Supervisor Level )
   CV_PPC_DAR	     = 119,
   CV_PPC_DEC	     = 122,
   CV_PPC_SDR1	     = 125,
   CV_PPC_SRR0	     = 126,
   CV_PPC_SRR1	     = 127,
   CV_PPC_SPRG0      = 372,
   CV_PPC_SPRG1      = 373,
   CV_PPC_SPRG2      = 374,
   CV_PPC_SPRG3      = 375,
   CV_PPC_ASR	     = 280,	       // 64-bit implementations only
   CV_PPC_EAR	     = 382,
   CV_PPC_PVR	     = 287,
   CV_PPC_BAT0U      = 628,
   CV_PPC_BAT0L      = 629,
   CV_PPC_BAT1U      = 630,
   CV_PPC_BAT1L      = 631,
   CV_PPC_BAT2U      = 632,
   CV_PPC_BAT2L      = 633,
   CV_PPC_BAT3U      = 634,
   CV_PPC_BAT3L      = 635,
   CV_PPC_DBAT0U     = 636,
   CV_PPC_DBAT0L     = 637,
   CV_PPC_DBAT1U     = 638,
   CV_PPC_DBAT1L     = 639,
   CV_PPC_DBAT2U     = 640,
   CV_PPC_DBAT2L     = 641,
   CV_PPC_DBAT3U     = 642,
   CV_PPC_DBAT3L     = 643,

   CV_PPC_PMR0	     = 1044,	       // MPC620,
   CV_PPC_PMR1	     = 1045,	       // MPC620,
   CV_PPC_PMR2	     = 1046,	       // MPC620,
   CV_PPC_PMR3	     = 1047,	       // MPC620,
   CV_PPC_PMR4	     = 1048,	       // MPC620,
   CV_PPC_PMR5	     = 1049,	       // MPC620,
   CV_PPC_PMR6	     = 1050,	       // MPC620,
   CV_PPC_PMR7	     = 1051,	       // MPC620,
   CV_PPC_PMR8	     = 1052,	       // MPC620,
   CV_PPC_PMR9	     = 1053,	       // MPC620,
   CV_PPC_PMR10      = 1054,	       // MPC620,
   CV_PPC_PMR11      = 1055,	       // MPC620,
   CV_PPC_PMR12      = 1056,	       // MPC620,
   CV_PPC_PMR13      = 1057,	       // MPC620,
   CV_PPC_PMR14      = 1058,	       // MPC620,
   CV_PPC_PMR15      = 1059,	       // MPC620,

   CV_PPC_DMISS      = 1076,	       // MPC603
   CV_PPC_DCMP	     = 1077,	       // MPC603
   CV_PPC_HASH1      = 1078,	       // MPC603
   CV_PPC_HASH2      = 1079,	       // MPC603
   CV_PPC_IMISS      = 1080,	       // MPC603
   CV_PPC_ICMP	     = 1081,	       // MPC603
   CV_PPC_RPA	     = 1082,	       // MPC603

   CV_PPC_HID0	     = 1108,	       // MPC601, MPC603, MPC620
   CV_PPC_HID1	     = 1109,	       // MPC601
   CV_PPC_HID2	     = 1110,	       // MPC601, MPC603, MPC620 ( IABR )
   CV_PPC_HID3	     = 1111,	       // Not Defined
   CV_PPC_HID4	     = 1112,	       // Not Defined
   CV_PPC_HID5	     = 1113,	       // MPC601, MPC604, MPC620 ( DABR )
   CV_PPC_HID6	     = 1114,	       // Not Defined
   CV_PPC_HID7	     = 1115,	       // Not Defined
   CV_PPC_HID8	     = 1116,	       // MPC620 ( BUSCSR )
   CV_PPC_HID9	     = 1117,	       // MPC620 ( L2CSR )
   CV_PPC_HID10      = 1118,	       // Not Defined
   CV_PPC_HID11      = 1119,	       // Not Defined
   CV_PPC_HID12      = 1120,	       // Not Defined
   CV_PPC_HID13      = 1121,	       // MPC604 ( HCR )
   CV_PPC_HID14      = 1122,	       // Not Defined
   CV_PPC_HID15      = 1123,	       // MPC601, MPC604, MPC620 ( PIR )

   // JAVA VM registers

   CV_JAVA_PC	     =	1,

   // Register set for the Hitachi SH3/SH4

   CV_SH3_NOREG      = CV_REG_NONE,

   CV_SH3_IntR0      = 10,	       // CPU REGISTER
   CV_SH3_IntR1      = 11,
   CV_SH3_IntR2      = 12,
   CV_SH3_IntR3      = 13,
   CV_SH3_IntR4      = 14,
   CV_SH3_IntR5      = 15,
   CV_SH3_IntR6      = 16,
   CV_SH3_IntR7      = 17,
   CV_SH3_IntR8      = 18,
   CV_SH3_IntR9      = 19,
   CV_SH3_IntR10     = 20,
   CV_SH3_IntR11     = 21,
   CV_SH3_IntR12     = 22,
   CV_SH3_IntR13     = 23,
   CV_SH3_IntFp      = 24,
   CV_SH3_IntSp      = 25,
   CV_SH3_Gbr	     = 38,
   CV_SH3_Pr	     = 39,
   CV_SH3_Mach	     = 40,
   CV_SH3_Macl	     = 41,

   CV_SH3_Pc	     = 50,
   CV_SH3_Sr	     = 51,

   CV_SH3_BarA	     = 60,
   CV_SH3_BasrA      = 61,
   CV_SH3_BamrA      = 62,
   CV_SH3_BbrA	     = 63,
   CV_SH3_BarB	     = 64,
   CV_SH3_BasrB      = 65,
   CV_SH3_BamrB      = 66,
   CV_SH3_BbrB	     = 67,
   CV_SH3_BdrB	     = 68,
   CV_SH3_BdmrB      = 69,
   CV_SH3_Brcr	     = 70,

   // Register set for the ARM processor.

   CV_ARM_NOREG      = CV_REG_NONE,

   CV_ARM_R0	     = 10,
   CV_ARM_R1	     = 11,
   CV_ARM_R2	     = 12,
   CV_ARM_R3	     = 13,
   CV_ARM_R4	     = 14,
   CV_ARM_R5	     = 15,
   CV_ARM_R6	     = 16,
   CV_ARM_R7	     = 17,
   CV_ARM_R8	     = 18,
   CV_ARM_R9	     = 19,
   CV_ARM_R10	     = 20,
   CV_ARM_R11	     = 21,	       // Frame pointer, if allocated
   CV_ARM_R12	     = 22,
   CV_ARM_SP	     = 23,	       // Stack pointer
   CV_ARM_LR	     = 24,	       // Link Register
   CV_ARM_PC	     = 25,	       // Program counter
   CV_ARM_CPSR	     = 26,	       // Current program status register

   // Register set for Intel IA64

   // Branch Registers

   CV_IA64_Br0	     = 512,
   CV_IA64_Br1	     = 513,
   CV_IA64_Br2	     = 514,
   CV_IA64_Br3	     = 515,
   CV_IA64_Br4	     = 516,
   CV_IA64_Br5	     = 517,
   CV_IA64_Br6	     = 518,
   CV_IA64_Br7	     = 519,

    // Predicate Registers

   CV_IA64_P0	     = 704,
   CV_IA64_P1	     = 705,
   CV_IA64_P2	     = 706,
   CV_IA64_P3	     = 707,
   CV_IA64_P4	     = 708,
   CV_IA64_P5	     = 709,
   CV_IA64_P6	     = 710,
   CV_IA64_P7	     = 711,
   CV_IA64_P8	     = 712,
   CV_IA64_P9	     = 713,
   CV_IA64_P10	     = 714,
   CV_IA64_P11	     = 715,
   CV_IA64_P12	     = 716,
   CV_IA64_P13	     = 717,
   CV_IA64_P14	     = 718,
   CV_IA64_P15	     = 719,
   CV_IA64_P16	     = 720,
   CV_IA64_P17	     = 721,
   CV_IA64_P18	     = 722,
   CV_IA64_P19	     = 723,
   CV_IA64_P20	     = 724,
   CV_IA64_P21	     = 725,
   CV_IA64_P22	     = 726,
   CV_IA64_P23	     = 727,
   CV_IA64_P24	     = 728,
   CV_IA64_P25	     = 729,
   CV_IA64_P26	     = 730,
   CV_IA64_P27	     = 731,
   CV_IA64_P28	     = 732,
   CV_IA64_P29	     = 733,
   CV_IA64_P30	     = 734,
   CV_IA64_P31	     = 735,
   CV_IA64_P32	     = 736,
   CV_IA64_P33	     = 737,
   CV_IA64_P34	     = 738,
   CV_IA64_P35	     = 739,
   CV_IA64_P36	     = 740,
   CV_IA64_P37	     = 741,
   CV_IA64_P38	     = 742,
   CV_IA64_P39	     = 743,
   CV_IA64_P40	     = 744,
   CV_IA64_P41	     = 745,
   CV_IA64_P42	     = 746,
   CV_IA64_P43	     = 747,
   CV_IA64_P44	     = 748,
   CV_IA64_P45	     = 749,
   CV_IA64_P46	     = 750,
   CV_IA64_P47	     = 751,
   CV_IA64_P48	     = 752,
   CV_IA64_P49	     = 753,
   CV_IA64_P50	     = 754,
   CV_IA64_P51	     = 755,
   CV_IA64_P52	     = 756,
   CV_IA64_P53	     = 757,
   CV_IA64_P54	     = 758,
   CV_IA64_P55	     = 759,
   CV_IA64_P56	     = 760,
   CV_IA64_P57	     = 761,
   CV_IA64_P58	     = 762,
   CV_IA64_P59	     = 763,
   CV_IA64_P60	     = 764,
   CV_IA64_P61	     = 765,
   CV_IA64_P62	     = 766,
   CV_IA64_P63	     = 767,

   // Predicate Registers

   CV_IA64_Preds     = 768,

   // Banked General Registers

   CV_IA64_IntH0     = 832,
   CV_IA64_IntH1     = 833,
   CV_IA64_IntH2     = 834,
   CV_IA64_IntH3     = 835,
   CV_IA64_IntH4     = 836,
   CV_IA64_IntH5     = 837,
   CV_IA64_IntH6     = 838,
   CV_IA64_IntH7     = 839,
   CV_IA64_IntH8     = 840,
   CV_IA64_IntH9     = 841,
   CV_IA64_IntH10    = 842,
   CV_IA64_IntH11    = 843,
   CV_IA64_IntH12    = 844,
   CV_IA64_IntH13    = 845,
   CV_IA64_IntH14    = 846,
   CV_IA64_IntH15    = 847,

   // Special Registers

   CV_IA64_Ip	     = 1016,
   CV_IA64_Umask     = 1017,
   CV_IA64_Cfm	     = 1018,
   CV_IA64_Psr	     = 1019,

   // Banked General Registers

   CV_IA64_Nats      = 1020,
   CV_IA64_Nats2     = 1021,
   CV_IA64_Nats3     = 1022,

   // General-Purpose Registers

   // Integer Registers

   CV_IA64_IntR0     = 1024,
   CV_IA64_IntR1     = 1025,
   CV_IA64_IntR2     = 1026,
   CV_IA64_IntR3     = 1027,
   CV_IA64_IntR4     = 1028,
   CV_IA64_IntR5     = 1029,
   CV_IA64_IntR6     = 1030,
   CV_IA64_IntR7     = 1031,
   CV_IA64_IntR8     = 1032,
   CV_IA64_IntR9     = 1033,
   CV_IA64_IntR10    = 1034,
   CV_IA64_IntR11    = 1035,
   CV_IA64_IntR12    = 1036,
   CV_IA64_IntR13    = 1037,
   CV_IA64_IntR14    = 1038,
   CV_IA64_IntR15    = 1039,
   CV_IA64_IntR16    = 1040,
   CV_IA64_IntR17    = 1041,
   CV_IA64_IntR18    = 1042,
   CV_IA64_IntR19    = 1043,
   CV_IA64_IntR20    = 1044,
   CV_IA64_IntR21    = 1045,
   CV_IA64_IntR22    = 1046,
   CV_IA64_IntR23    = 1047,
   CV_IA64_IntR24    = 1048,
   CV_IA64_IntR25    = 1049,
   CV_IA64_IntR26    = 1050,
   CV_IA64_IntR27    = 1051,
   CV_IA64_IntR28    = 1052,
   CV_IA64_IntR29    = 1053,
   CV_IA64_IntR30    = 1054,
   CV_IA64_IntR31    = 1055,

   // Register Stack

   CV_IA64_IntR32    = 1056,
   CV_IA64_IntR33    = 1057,
   CV_IA64_IntR34    = 1058,
   CV_IA64_IntR35    = 1059,
   CV_IA64_IntR36    = 1060,
   CV_IA64_IntR37    = 1061,
   CV_IA64_IntR38    = 1062,
   CV_IA64_IntR39    = 1063,
   CV_IA64_IntR40    = 1064,
   CV_IA64_IntR41    = 1065,
   CV_IA64_IntR42    = 1066,
   CV_IA64_IntR43    = 1067,
   CV_IA64_IntR44    = 1068,
   CV_IA64_IntR45    = 1069,
   CV_IA64_IntR46    = 1070,
   CV_IA64_IntR47    = 1071,
   CV_IA64_IntR48    = 1072,
   CV_IA64_IntR49    = 1073,
   CV_IA64_IntR50    = 1074,
   CV_IA64_IntR51    = 1075,
   CV_IA64_IntR52    = 1076,
   CV_IA64_IntR53    = 1077,
   CV_IA64_IntR54    = 1078,
   CV_IA64_IntR55    = 1079,
   CV_IA64_IntR56    = 1080,
   CV_IA64_IntR57    = 1081,
   CV_IA64_IntR58    = 1082,
   CV_IA64_IntR59    = 1083,
   CV_IA64_IntR60    = 1084,
   CV_IA64_IntR61    = 1085,
   CV_IA64_IntR62    = 1086,
   CV_IA64_IntR63    = 1087,
   CV_IA64_IntR64    = 1088,
   CV_IA64_IntR65    = 1089,
   CV_IA64_IntR66    = 1090,
   CV_IA64_IntR67    = 1091,
   CV_IA64_IntR68    = 1092,
   CV_IA64_IntR69    = 1093,
   CV_IA64_IntR70    = 1094,
   CV_IA64_IntR71    = 1095,
   CV_IA64_IntR72    = 1096,
   CV_IA64_IntR73    = 1097,
   CV_IA64_IntR74    = 1098,
   CV_IA64_IntR75    = 1099,
   CV_IA64_IntR76    = 1100,
   CV_IA64_IntR77    = 1101,
   CV_IA64_IntR78    = 1102,
   CV_IA64_IntR79    = 1103,
   CV_IA64_IntR80    = 1104,
   CV_IA64_IntR81    = 1105,
   CV_IA64_IntR82    = 1106,
   CV_IA64_IntR83    = 1107,
   CV_IA64_IntR84    = 1108,
   CV_IA64_IntR85    = 1109,
   CV_IA64_IntR86    = 1110,
   CV_IA64_IntR87    = 1111,
   CV_IA64_IntR88    = 1112,
   CV_IA64_IntR89    = 1113,
   CV_IA64_IntR90    = 1114,
   CV_IA64_IntR91    = 1115,
   CV_IA64_IntR92    = 1116,
   CV_IA64_IntR93    = 1117,
   CV_IA64_IntR94    = 1118,
   CV_IA64_IntR95    = 1119,
   CV_IA64_IntR96    = 1120,
   CV_IA64_IntR97    = 1121,
   CV_IA64_IntR98    = 1122,
   CV_IA64_IntR99    = 1123,
   CV_IA64_IntR100   = 1124,
   CV_IA64_IntR101   = 1125,
   CV_IA64_IntR102   = 1126,
   CV_IA64_IntR103   = 1127,
   CV_IA64_IntR104   = 1128,
   CV_IA64_IntR105   = 1129,
   CV_IA64_IntR106   = 1130,
   CV_IA64_IntR107   = 1131,
   CV_IA64_IntR108   = 1132,
   CV_IA64_IntR109   = 1133,
   CV_IA64_IntR110   = 1134,
   CV_IA64_IntR111   = 1135,
   CV_IA64_IntR112   = 1136,
   CV_IA64_IntR113   = 1137,
   CV_IA64_IntR114   = 1138,
   CV_IA64_IntR115   = 1139,
   CV_IA64_IntR116   = 1140,
   CV_IA64_IntR117   = 1141,
   CV_IA64_IntR118   = 1142,
   CV_IA64_IntR119   = 1143,
   CV_IA64_IntR120   = 1144,
   CV_IA64_IntR121   = 1145,
   CV_IA64_IntR122   = 1146,
   CV_IA64_IntR123   = 1147,
   CV_IA64_IntR124   = 1148,
   CV_IA64_IntR125   = 1149,
   CV_IA64_IntR126   = 1150,
   CV_IA64_IntR127   = 1151,

   // Floating-Point Registers

   // Low Floating Point Registers

   CV_IA64_FltF0     = 2048,
   CV_IA64_FltF1     = 2049,
   CV_IA64_FltF2     = 2050,
   CV_IA64_FltF3     = 2051,
   CV_IA64_FltF4     = 2052,
   CV_IA64_FltF5     = 2053,
   CV_IA64_FltF6     = 2054,
   CV_IA64_FltF7     = 2055,
   CV_IA64_FltF8     = 2056,
   CV_IA64_FltF9     = 2057,
   CV_IA64_FltF10    = 2058,
   CV_IA64_FltF11    = 2059,
   CV_IA64_FltF12    = 2060,
   CV_IA64_FltF13    = 2061,
   CV_IA64_FltF14    = 2062,
   CV_IA64_FltF15    = 2063,
   CV_IA64_FltF16    = 2064,
   CV_IA64_FltF17    = 2065,
   CV_IA64_FltF18    = 2066,
   CV_IA64_FltF19    = 2067,
   CV_IA64_FltF20    = 2068,
   CV_IA64_FltF21    = 2069,
   CV_IA64_FltF22    = 2070,
   CV_IA64_FltF23    = 2071,
   CV_IA64_FltF24    = 2072,
   CV_IA64_FltF25    = 2073,
   CV_IA64_FltF26    = 2074,
   CV_IA64_FltF27    = 2075,
   CV_IA64_FltF28    = 2076,
   CV_IA64_FltF29    = 2077,
   CV_IA64_FltF30    = 2078,
   CV_IA64_FltF31    = 2079,

   // High Floating Point Registers

   CV_IA64_FltF32    = 2080,
   CV_IA64_FltF33    = 2081,
   CV_IA64_FltF34    = 2082,
   CV_IA64_FltF35    = 2083,
   CV_IA64_FltF36    = 2084,
   CV_IA64_FltF37    = 2085,
   CV_IA64_FltF38    = 2086,
   CV_IA64_FltF39    = 2087,
   CV_IA64_FltF40    = 2088,
   CV_IA64_FltF41    = 2089,
   CV_IA64_FltF42    = 2090,
   CV_IA64_FltF43    = 2091,
   CV_IA64_FltF44    = 2092,
   CV_IA64_FltF45    = 2093,
   CV_IA64_FltF46    = 2094,
   CV_IA64_FltF47    = 2095,
   CV_IA64_FltF48    = 2096,
   CV_IA64_FltF49    = 2097,
   CV_IA64_FltF50    = 2098,
   CV_IA64_FltF51    = 2099,
   CV_IA64_FltF52    = 2100,
   CV_IA64_FltF53    = 2101,
   CV_IA64_FltF54    = 2102,
   CV_IA64_FltF55    = 2103,
   CV_IA64_FltF56    = 2104,
   CV_IA64_FltF57    = 2105,
   CV_IA64_FltF58    = 2106,
   CV_IA64_FltF59    = 2107,
   CV_IA64_FltF60    = 2108,
   CV_IA64_FltF61    = 2109,
   CV_IA64_FltF62    = 2110,
   CV_IA64_FltF63    = 2111,
   CV_IA64_FltF64    = 2112,
   CV_IA64_FltF65    = 2113,
   CV_IA64_FltF66    = 2114,
   CV_IA64_FltF67    = 2115,
   CV_IA64_FltF68    = 2116,
   CV_IA64_FltF69    = 2117,
   CV_IA64_FltF70    = 2118,
   CV_IA64_FltF71    = 2119,
   CV_IA64_FltF72    = 2120,
   CV_IA64_FltF73    = 2121,
   CV_IA64_FltF74    = 2122,
   CV_IA64_FltF75    = 2123,
   CV_IA64_FltF76    = 2124,
   CV_IA64_FltF77    = 2125,
   CV_IA64_FltF78    = 2126,
   CV_IA64_FltF79    = 2127,
   CV_IA64_FltF80    = 2128,
   CV_IA64_FltF81    = 2129,
   CV_IA64_FltF82    = 2130,
   CV_IA64_FltF83    = 2131,
   CV_IA64_FltF84    = 2132,
   CV_IA64_FltF85    = 2133,
   CV_IA64_FltF86    = 2134,
   CV_IA64_FltF87    = 2135,
   CV_IA64_FltF88    = 2136,
   CV_IA64_FltF89    = 2137,
   CV_IA64_FltF90    = 2138,
   CV_IA64_FltF91    = 2139,
   CV_IA64_FltF92    = 2140,
   CV_IA64_FltF93    = 2141,
   CV_IA64_FltF94    = 2142,
   CV_IA64_FltF95    = 2143,
   CV_IA64_FltF96    = 2144,
   CV_IA64_FltF97    = 2145,
   CV_IA64_FltF98    = 2146,
   CV_IA64_FltF99    = 2147,
   CV_IA64_FltF100   = 2148,
   CV_IA64_FltF101   = 2149,
   CV_IA64_FltF102   = 2150,
   CV_IA64_FltF103   = 2151,
   CV_IA64_FltF104   = 2152,
   CV_IA64_FltF105   = 2153,
   CV_IA64_FltF106   = 2154,
   CV_IA64_FltF107   = 2155,
   CV_IA64_FltF108   = 2156,
   CV_IA64_FltF109   = 2157,
   CV_IA64_FltF110   = 2158,
   CV_IA64_FltF111   = 2159,
   CV_IA64_FltF112   = 2160,
   CV_IA64_FltF113   = 2161,
   CV_IA64_FltF114   = 2162,
   CV_IA64_FltF115   = 2163,
   CV_IA64_FltF116   = 2164,
   CV_IA64_FltF117   = 2165,
   CV_IA64_FltF118   = 2166,
   CV_IA64_FltF119   = 2167,
   CV_IA64_FltF120   = 2168,
   CV_IA64_FltF121   = 2169,
   CV_IA64_FltF122   = 2170,
   CV_IA64_FltF123   = 2171,
   CV_IA64_FltF124   = 2172,
   CV_IA64_FltF125   = 2173,
   CV_IA64_FltF126   = 2174,
   CV_IA64_FltF127   = 2175,

   // Application Registers

   CV_IA64_ApKR0     = 3072,
   CV_IA64_ApKR1     = 3073,
   CV_IA64_ApKR2     = 3074,
   CV_IA64_ApKR3     = 3075,
   CV_IA64_ApKR4     = 3076,
   CV_IA64_ApKR5     = 3077,
   CV_IA64_ApKR6     = 3078,
   CV_IA64_ApKR7     = 3079,
   CV_IA64_AR8	     = 3080,
   CV_IA64_AR9	     = 3081,
   CV_IA64_AR10      = 3082,
   CV_IA64_AR11      = 3083,
   CV_IA64_AR12      = 3084,
   CV_IA64_AR13      = 3085,
   CV_IA64_AR14      = 3086,
   CV_IA64_AR15      = 3087,
   CV_IA64_RsRSC     = 3088,
   CV_IA64_RsBSP     = 3089,
   CV_IA64_RsBSPSTORE = 3090,
   CV_IA64_RsRNAT    = 3091,
   CV_IA64_AR20      = 3092,
   CV_IA64_AR21      = 3093,
   CV_IA64_AR22      = 3094,
   CV_IA64_AR23      = 3095,
   CV_IA64_AR24      = 3096,
   CV_IA64_AR25      = 3097,
   CV_IA64_AR26      = 3098,
   CV_IA64_AR27      = 3099,
   CV_IA64_AR28      = 3100,
   CV_IA64_AR29      = 3101,
   CV_IA64_AR30      = 3102,
   CV_IA64_AR31      = 3103,
   CV_IA64_ApCCV     = 3104,
   CV_IA64_AR33      = 3105,
   CV_IA64_AR34      = 3106,
   CV_IA64_AR35      = 3107,
   CV_IA64_ApUNAT    = 3108,
   CV_IA64_AR37      = 3109,
   CV_IA64_AR38      = 3110,
   CV_IA64_AR39      = 3111,
   CV_IA64_StFPSR    = 3112,
   CV_IA64_AR41      = 3113,
   CV_IA64_AR42      = 3114,
   CV_IA64_AR43      = 3115,
   CV_IA64_ApITC     = 3116,
   CV_IA64_AR45      = 3117,
   CV_IA64_AR46      = 3118,
   CV_IA64_AR47      = 3119,
   CV_IA64_AR48      = 3120,
   CV_IA64_AR49      = 3121,
   CV_IA64_AR50      = 3122,
   CV_IA64_AR51      = 3123,
   CV_IA64_AR52      = 3124,
   CV_IA64_AR53      = 3125,
   CV_IA64_AR54      = 3126,
   CV_IA64_AR55      = 3127,
   CV_IA64_AR56      = 3128,
   CV_IA64_AR57      = 3129,
   CV_IA64_AR58      = 3130,
   CV_IA64_AR59      = 3131,
   CV_IA64_AR60      = 3132,
   CV_IA64_AR61      = 3133,
   CV_IA64_AR62      = 3134,
   CV_IA64_AR63      = 3135,
   CV_IA64_RsPFS     = 3136,
   CV_IA64_ApLC      = 3137,
   CV_IA64_ApEC      = 3138,
   CV_IA64_AR67      = 3139,
   CV_IA64_AR68      = 3140,
   CV_IA64_AR69      = 3141,
   CV_IA64_AR70      = 3142,
   CV_IA64_AR71      = 3143,
   CV_IA64_AR72      = 3144,
   CV_IA64_AR73      = 3145,
   CV_IA64_AR74      = 3146,
   CV_IA64_AR75      = 3147,
   CV_IA64_AR76      = 3148,
   CV_IA64_AR77      = 3149,
   CV_IA64_AR78      = 3150,
   CV_IA64_AR79      = 3151,
   CV_IA64_AR80      = 3152,
   CV_IA64_AR81      = 3153,
   CV_IA64_AR82      = 3154,
   CV_IA64_AR83      = 3155,
   CV_IA64_AR84      = 3156,
   CV_IA64_AR85      = 3157,
   CV_IA64_AR86      = 3158,
   CV_IA64_AR87      = 3159,
   CV_IA64_AR88      = 3160,
   CV_IA64_AR89      = 3161,
   CV_IA64_AR90      = 3162,
   CV_IA64_AR91      = 3163,
   CV_IA64_AR92      = 3164,
   CV_IA64_AR93      = 3165,
   CV_IA64_AR94      = 3166,
   CV_IA64_AR95      = 3167,
   CV_IA64_AR96      = 3168,
   CV_IA64_AR97      = 3169,
   CV_IA64_AR98      = 3170,
   CV_IA64_AR99      = 3171,
   CV_IA64_AR100     = 3172,
   CV_IA64_AR101     = 3173,
   CV_IA64_AR102     = 3174,
   CV_IA64_AR103     = 3175,
   CV_IA64_AR104     = 3176,
   CV_IA64_AR105     = 3177,
   CV_IA64_AR106     = 3178,
   CV_IA64_AR107     = 3179,
   CV_IA64_AR108     = 3180,
   CV_IA64_AR109     = 3181,
   CV_IA64_AR110     = 3182,
   CV_IA64_AR111     = 3183,
   CV_IA64_AR112     = 3184,
   CV_IA64_AR113     = 3185,
   CV_IA64_AR114     = 3186,
   CV_IA64_AR115     = 3187,
   CV_IA64_AR116     = 3188,
   CV_IA64_AR117     = 3189,
   CV_IA64_AR118     = 3190,
   CV_IA64_AR119     = 3191,
   CV_IA64_AR120     = 3192,
   CV_IA64_AR121     = 3193,
   CV_IA64_AR122     = 3194,
   CV_IA64_AR123     = 3195,
   CV_IA64_AR124     = 3196,
   CV_IA64_AR125     = 3197,
   CV_IA64_AR126     = 3198,
   CV_IA64_AR127     = 3199,

   // Control Registers

   CV_IA64_ApDCR     = 4096,
   CV_IA64_ApITM     = 4097,
   CV_IA64_ApIVA     = 4098,
   CV_IA64_CR3	     = 4099,
   CV_IA64_CR4	     = 4100,
   CV_IA64_CR5	     = 4101,
   CV_IA64_CR6	     = 4102,
   CV_IA64_CR7	     = 4103,
   CV_IA64_ApPTA     = 4104,
   CV_IA64_CR9	     = 4105,
   CV_IA64_CR10      = 4106,
   CV_IA64_CR11      = 4107,
   CV_IA64_CR12      = 4108,
   CV_IA64_CR13      = 4109,
   CV_IA64_CR14      = 4110,
   CV_IA64_CR15      = 4111,
   CV_IA64_StIPSR    = 4112,
   CV_IA64_StISR     = 4113,
   CV_IA64_StIDA     = 4114,
   CV_IA64_StIIP     = 4115,
   CV_IA64_StIDTR    = 4116,
   CV_IA64_StIITR    = 4117,
   CV_IA64_StIIPA    = 4118,
   CV_IA64_StIFS     = 4119,
   CV_IA64_StIIM     = 4120,
   CV_IA64_StIHA     = 4121,
   CV_IA64_CR26      = 4122,
   CV_IA64_CR27      = 4123,
   CV_IA64_CR28      = 4124,
   CV_IA64_CR29      = 4125,
   CV_IA64_CR30      = 4126,
   CV_IA64_CR31      = 4127,
   CV_IA64_CR32      = 4128,
   CV_IA64_CR33      = 4129,
   CV_IA64_CR34      = 4130,
   CV_IA64_CR35      = 4131,
   CV_IA64_CR36      = 4132,
   CV_IA64_CR37      = 4133,
   CV_IA64_CR38      = 4134,
   CV_IA64_CR39      = 4135,
   CV_IA64_CR40      = 4136,
   CV_IA64_CR41      = 4137,
   CV_IA64_CR42      = 4138,
   CV_IA64_CR43      = 4139,
   CV_IA64_CR44      = 4140,
   CV_IA64_CR45      = 4141,
   CV_IA64_CR46      = 4142,
   CV_IA64_CR47      = 4143,
   CV_IA64_CR48      = 4144,
   CV_IA64_CR49      = 4145,
   CV_IA64_CR50      = 4146,
   CV_IA64_CR51      = 4147,
   CV_IA64_CR52      = 4148,
   CV_IA64_CR53      = 4149,
   CV_IA64_CR54      = 4150,
   CV_IA64_CR55      = 4151,
   CV_IA64_CR56      = 4152,
   CV_IA64_CR57      = 4153,
   CV_IA64_CR58      = 4154,
   CV_IA64_CR59      = 4155,
   CV_IA64_CR60      = 4156,
   CV_IA64_CR61      = 4157,
   CV_IA64_CR62      = 4158,
   CV_IA64_CR63      = 4159,
   CV_IA64_CR64      = 4160,
   CV_IA64_CR65      = 4161,
   CV_IA64_SaLID     = 4162,
   CV_IA64_CR67      = 4163,
   CV_IA64_CR68      = 4164,
   CV_IA64_CR69      = 4165,
   CV_IA64_CR70      = 4166,
   CV_IA64_SaIVR     = 4167,
   CV_IA64_SaTPR     = 4168,
   CV_IA64_CR73      = 4169,
   CV_IA64_CR74      = 4170,
   CV_IA64_SaEOI     = 4171,
   CV_IA64_CR76      = 4172,
   CV_IA64_CR77      = 4173,
   CV_IA64_CR78      = 4174,
   CV_IA64_CR79      = 4175,
   CV_IA64_CR80      = 4176,
   CV_IA64_CR81      = 4177,
   CV_IA64_CR82      = 4178,
   CV_IA64_CR83      = 4179,
   CV_IA64_CR84      = 4180,
   CV_IA64_CR85      = 4181,
   CV_IA64_CR86      = 4182,
   CV_IA64_CR87      = 4183,
   CV_IA64_CR88      = 4184,
   CV_IA64_CR89      = 4185,
   CV_IA64_CR90      = 4186,
   CV_IA64_CR91      = 4187,
   CV_IA64_CR92      = 4188,
   CV_IA64_CR93      = 4189,
   CV_IA64_CR94      = 4190,
   CV_IA64_CR95      = 4191,
   CV_IA64_SaIRR0    = 4192,
   CV_IA64_CR97      = 4193,
   CV_IA64_SaIRR1    = 4194,
   CV_IA64_CR99      = 4195,
   CV_IA64_SaIRR2    = 4196,
   CV_IA64_CR101     = 4197,
   CV_IA64_SaIRR3    = 4198,
   CV_IA64_CR103     = 4199,
   CV_IA64_CR104     = 4200,
   CV_IA64_CR105     = 4201,
   CV_IA64_CR106     = 4202,
   CV_IA64_CR107     = 4203,
   CV_IA64_CR108     = 4204,
   CV_IA64_CR109     = 4205,
   CV_IA64_CR110     = 4206,
   CV_IA64_CR111     = 4207,
   CV_IA64_CR112     = 4208,
   CV_IA64_CR113     = 4209,
   CV_IA64_SaITV     = 4210,
   CV_IA64_CR115     = 4211,
   CV_IA64_SaPMV     = 4212,
   CV_IA64_SaLRR0    = 4213,
   CV_IA64_SaLRR1    = 4214,
   CV_IA64_SaCMCV    = 4215,
   CV_IA64_CR120     = 4216,
   CV_IA64_CR121     = 4217,
   CV_IA64_CR122     = 4218,
   CV_IA64_CR123     = 4219,
   CV_IA64_CR124     = 4220,
   CV_IA64_CR125     = 4221,
   CV_IA64_CR126     = 4222,
   CV_IA64_CR127     = 4223,

   // Protection Key Registers

   CV_IA64_Pkr0      = 5120,
   CV_IA64_Pkr1      = 5121,
   CV_IA64_Pkr2      = 5122,
   CV_IA64_Pkr3      = 5123,
   CV_IA64_Pkr4      = 5124,
   CV_IA64_Pkr5      = 5125,
   CV_IA64_Pkr6      = 5126,
   CV_IA64_Pkr7      = 5127,
   CV_IA64_Pkr8      = 5128,
   CV_IA64_Pkr9      = 5129,
   CV_IA64_Pkr10     = 5130,
   CV_IA64_Pkr11     = 5131,
   CV_IA64_Pkr12     = 5132,
   CV_IA64_Pkr13     = 5133,
   CV_IA64_Pkr14     = 5134,
   CV_IA64_Pkr15     = 5135,

   // Region Registers

   CV_IA64_Rr0	     = 6144,
   CV_IA64_Rr1	     = 6145,
   CV_IA64_Rr2	     = 6146,
   CV_IA64_Rr3	     = 6147,
   CV_IA64_Rr4	     = 6148,
   CV_IA64_Rr5	     = 6149,
   CV_IA64_Rr6	     = 6150,
   CV_IA64_Rr7	     = 6151,

   // Performance Monitor Data Registers

   CV_IA64_PFD0      = 7168,
   CV_IA64_PFD1      = 7169,
   CV_IA64_PFD2      = 7170,
   CV_IA64_PFD3      = 7171,
   CV_IA64_PFD4      = 7172,
   CV_IA64_PFD5      = 7173,
   CV_IA64_PFD6      = 7174,
   CV_IA64_PFD7      = 7175,

   // Performance Monitor Config Registers

   CV_IA64_PFC0      = 7424,
   CV_IA64_PFC1      = 7425,
   CV_IA64_PFC2      = 7426,
   CV_IA64_PFC3      = 7427,
   CV_IA64_PFC4      = 7428,
   CV_IA64_PFC5      = 7429,
   CV_IA64_PFC6      = 7430,
   CV_IA64_PFC7      = 7431,

   // Instruction Translation Registers

   CV_IA64_TrI0      = 8192,
   CV_IA64_TrI1      = 8193,
   CV_IA64_TrI2      = 8194,
   CV_IA64_TrI3      = 8195,
   CV_IA64_TrI4      = 8196,
   CV_IA64_TrI5      = 8197,
   CV_IA64_TrI6      = 8198,
   CV_IA64_TrI7      = 8199,

   // Data Translation Registers

   CV_IA64_TrD0      = 8320,
   CV_IA64_TrD1      = 8321,
   CV_IA64_TrD2      = 8322,
   CV_IA64_TrD3      = 8323,
   CV_IA64_TrD4      = 8324,
   CV_IA64_TrD5      = 8325,
   CV_IA64_TrD6      = 8326,
   CV_IA64_TrD7      = 8327,

   // Instruction Breakpoint Registers

   CV_IA64_DbI0      = 8448,
   CV_IA64_DbI1      = 8449,
   CV_IA64_DbI2      = 8450,
   CV_IA64_DbI3      = 8451,
   CV_IA64_DbI4      = 8452,
   CV_IA64_DbI5      = 8453,
   CV_IA64_DbI6      = 8454,
   CV_IA64_DbI7      = 8455,

   // Data Breakpoint Registers

   CV_IA64_DbD0      = 8576,
   CV_IA64_DbD1      = 8577,
   CV_IA64_DbD2      = 8578,
   CV_IA64_DbD3      = 8579,
   CV_IA64_DbD4      = 8580,
   CV_IA64_DbD5      = 8581,
   CV_IA64_DbD6      = 8582,
   CV_IA64_DbD7      = 8583,
};



// --------------------------------------------------------------------
// Pointer to Member Representations
// --------------------------------------------------------------------

//  representation of a 16:32 near pointer to data for a class with
//  or without virtual functions and no virtual bases

struct CV_PDMR32_NVVFCN
{
   // NULL = (0x00000000)

   DWORD ibData;		       // Displacement to data
};


//  representation of a 16:32 near pointer to data for a class
//  with virtual bases

struct CV_PDMR32_VBASE
{
   // NULL = (?, ?, 0xFFFFFFFF)

   DWORD  ibData;		       // Displacement to data
   DWORD  ibThis;		       // This pointer displacement to vbptr
   DWORD  ibVbase;		       // Displacement within vbase table
};


//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and a single address point

struct CV_PMFR32_NVSA
{
   // NULL = (0x00000000)

   DWORD pfn;			       // Address of function
};


//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and multiple address points

struct CV_PMFR32_NVMA
{
   // NULL = (0x00000000, ?)

   DWORD pfn;			       // Address of function
   DWORD disp;			       // UNDONE: ?
};


//  representation of a 16:32 near pointer to member function for a
//  class with virtual bases

struct CV_PMFR32_VBASE
{
   // NULL = (0x00000000, ?, ?, ?)

   DWORD pfn;			       // Address of function
   WORD  ibData;		       // Displacement to data
   WORD  ibThis;		       // This pointer displacement to vbptr
   WORD  ibVbase;		       // Displacement within vbase table
};


#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\sym7\inc\undname.h ===
#if !defined(_M_I86)
    //  The 32-bit compiler

    #define __far
    #define __near
    #define __pascal
    #define __loadds
#endif


typedef char *        pchar_t;
typedef const char *  pcchar_t;

typedef void * ( __cdecl * Alloc_t )( size_t );
typedef void   ( __cdecl * Free_t  )( void * );
typedef char * ( __cdecl * GetParameter_t  )( long );


#ifdef  __cplusplus
extern "C"
#endif


#ifdef _CRTBLD
_CRTIMP pchar_t __cdecl __unDName (
#else
pchar_t __cdecl unDName (
#endif
                            pchar_t,		// User supplied buffer (or NULL)
                            pcchar_t,		// Input decorated name
                            int,			// Maximum length of user buffer
                            Alloc_t,		// Address of heap allocator
                            Free_t,			// Address of heap deallocator
                            unsigned short	// Feature disable flags
                        );

#ifdef  __cplusplus
extern "C"
#endif

#ifdef _CRTBLD
_CRTIMP pchar_t __cdecl __unDNameEx (
#else
pchar_t __cdecl unDNameEx (
#endif
                            pchar_t,		// User supplied buffer (or NULL)
                            pcchar_t,		// Input decorated name
                            int,			// Maximum length of user buffer
                            Alloc_t,		// Address of heap allocator
                            Free_t,			// Address of heap deallocator
							GetParameter_t,	// Function to get any template parameters
                            unsigned long	// Feature disable flags
                        );
/*
 *  The user may provide a buffer into which the undecorated declaration
 *  is to be placed, in which case, the length field must be specified.
 *  The length is the maximum number of characters (including the terminating
 *  NULL character) which may be written into the user buffer.
 *
 *  If the output buffer is NULL, the length field is ignored, and the
 *  undecorator will allocate a buffer exactly large enough to hold the
 *  resulting declaration.  It is the users responsibility to deallocate
 *  this buffer.
 *
 *  The user may also supply the allocator and deallocator functions if
 *  they wish.  If they do, then all heap actions performed by the routine
 *  will use the provided heap functions.
 *
 *  If the allocator address is NULL, then the routine will default to using
 *  the standard allocator and deallocator functions, 'malloc' and 'free'.
 *
 *  If an error occurs internally, then the routine will return NULL.  If
 *  it was successful, it will return the buffer address provided by the
 *  user, or the address of the buffer allocated on their behalf, if they
 *  specified a NULL buffer address.
 *
 *  If a given name does not have a valid undecoration, the original name
 *  is returned in the output buffer.
 *
 *  Fine selection of a number of undecorator attributes is possible, by
 *  specifying flags (bit-fields) to disable the production of parts of the
 *  complete declaration.  The flags may be OR'ed together to select multiple
 *  disabling of selected fields.  The fields and flags are as follows :-
 */

#define UNDNAME_COMPLETE                (0x0000)    // Enable full undecoration

#define UNDNAME_NO_LEADING_UNDERSCORES  (0x0001)    // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS          (0x0002)    // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS     (0x0004)    // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL     (0x0008)    // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE  (0x0010)    // Disable expansion of the declaration language specifier
  #define   UNDNAME_NO_MS_THISTYPE          (0x0020)    /* NYI */   // Disable expansion of MS keywords on the 'this' type for primary declaration
  #define   UNDNAME_NO_CV_THISTYPE          (0x0040)    /* NYI */   // Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE             (0x0060)    // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS    (0x0080)    // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES     (0x0100)    // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE          (0x0200)    // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL     (0x0400)    // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE           (0x0800)    // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY               (0x1000)    // Crack only the name for primary declaration;
                                                    //  return just [scope::]name.  Does expand template params
#define UNDNAME_TYPE_ONLY               (0x2000)    // Input is just a type encoding; compose an abstract declarator
#define UNDNAME_HAVE_PARAMETERS         (0x4000)    // The real templates parameters are available
#define UNDNAME_NO_ECSU                 (0x8000)    // Suppress enum/class/struct/union
#define UNDNAME_NO_IDENT_CHAR_CHECK     (0x10000)   // Suppress check for IsValidIdentChar
#define UNDNAME_NO_PTR64				(0x20000)	// disable just ptr64 in output
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\sym7\inc\pdb.h ===
// Debug Information API
// Copyright (C) 1993-1996, Microsoft Corp.  All Rights Reserved.

#pragma once

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __PDB_INCLUDED__
#define __PDB_INCLUDED__

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned __int64 DWORDLONG;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef ULONG   INTV;       // interface version number
typedef ULONG   IMPV;       // implementation version number
typedef ULONG   SIG;        // unique (across PDB instances) signature
typedef ULONG   AGE;        // no. of times this instance has been updated
typedef const char*     SZ_CONST;   // const string
typedef void *          PV;
typedef const void *    PCV;

#ifdef  LNGNM
#define LNGNM_CONST	const
#else   // LNGNM
#define LNGNM_CONST
#endif  // LNGNM

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE    Data4[8];
} GUID;

#endif // !GUID_DEFINED

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef long HRESULT;

#endif // !_HRESULT_DEFINED


typedef GUID            SIG70;      // new to 7.0 are 16-byte guid-like signatures
typedef SIG70 *         PSIG70;
typedef const SIG70 *   PCSIG70;

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

enum {
#ifdef LNGNM
    PDBIntv70   = 20001102,
    PDBIntv70Dep = 20000406,
#else
    PDBIntv70   = 20000301,
#endif
    PDBIntv69   = 19990511,
    PDBIntv61   = 19980914,
    PDBIntv50a  = 19970116,
    PDBIntv60   = PDBIntv50a,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
#ifdef LNGNM
    PDBIntv     = PDBIntv70,   // Now we support both 50 & 60, 69 is only an intermediate version
    PDBIntvAlt  = PDBIntv50,   
    PDBIntvAlt2 = PDBIntv60,   
    PDBIntvAlt3 = PDBIntv69,
#else
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntvAlt2 = PDBIntv60,   // Alternate (backward compatible) supported interface
    PDBIntvAlt3 = PDBIntv61,
    PDBIntv     = PDBIntv69,
#endif  
};

enum {
    PDBImpvVC2  = 19941610,
    PDBImpvVC4  = 19950623,
    PDBImpvVC41 = 19950814,
    PDBImpvVC50 = 19960307,
    PDBImpvVC98 = 19970604,
    PDBImpvVC70 = 20000404,
    PDBImpvVC70Dep = 19990604,  // deprecated vc70 implementation version
#ifdef LNGNM
    PDBImpv     = PDBImpvVC70,
#else
    PDBImpv     = PDBImpvVC98,
#endif
};


enum {
    niNil        = 0,
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,
};

// cvinfo.h type index, intentionally typedef'ed here to check equivalence.
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned long   CV_pubsymflag_t;    // must be same as CV_typ_t.

typedef CV_typ_t        TI;     // PDB name for type index
typedef CV_typ16_t      TI16;   // 16-bit version
typedef unsigned long   NI;     // name index
typedef TI *            PTi;
typedef TI16 *          PTi16;

typedef BYTE            ITSM;   // type server map index
typedef ITSM*           PITSM;

typedef BOOL    (__stdcall *PFNVALIDATEDEBUGINFOFILE) (const char * szFile, ULONG * errcode );

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancilliary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    char *  szMod;                      // exe/dll
    char *  szLib;                      // lib if appropriate
    char *  szObj;                      // object file
    char * *rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    char  szValidatedFile[PDB_MAX_PATH];// output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
    char *  szExe;                      // exe/dll
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;

typedef BOOL ( __stdcall * PfnFindDebugInfoFile) ( PSEARCHDEBUGINFO );

#define PdbInterface struct

PdbInterface PDB;                   // program database
PdbInterface DBI;                   // debug information within the PDB
PdbInterface Mod;                   // a module within the DBI
PdbInterface TPI;                   // type info within the DBI
PdbInterface GSI;                   // global symbol info
PdbInterface SO;                    
PdbInterface Stream;                // some named bytestream in the PDB
PdbInterface StreamImage;           // some memory mapped stream
PdbInterface NameMap;              // name mapping
PdbInterface Enum;                 // generic enumerator
PdbInterface EnumNameMap;          // enumerate names within a NameMap
PdbInterface EnumContrib;          // enumerate contributions
PdbInterface Dbg;                   // misc debug data (FPO, OMAP, etc)
PdbInterface Src;                   // Src file data
PdbInterface EnumSrc;               // Src file enumerator
PdbInterface SrcHash;               // Src file hasher
PdbInterface EnumLines;

typedef PdbInterface PDB PDB;
typedef PdbInterface DBI DBI;
typedef PdbInterface Mod Mod;
typedef PdbInterface TPI TPI;
typedef PdbInterface GSI GSI;
typedef PdbInterface SO SO;
typedef PdbInterface Stream Stream;
typedef PdbInterface StreamImage StreamImage;
typedef PdbInterface NameMap NameMap;
typedef PdbInterface Enum Enum;
typedef PdbInterface EnumStreamNames EnumStreamNames;
typedef PdbInterface EnumNameMap EnumNameMap;
typedef PdbInterface EnumContrib EnumContrib;
typedef PdbInterface EnumSyms EnumSyms;
typedef PdbInterface WidenTi WidenTi;
typedef PdbInterface Dbg Dbg;
typedef PdbInterface EnumThunk EnumThunk;
typedef PdbInterface Src Src;
typedef PdbInterface EnumSrc EnumSrc;
typedef PdbInterface SrcHash SrcHash;

typedef SrcHash *   PSrcHash;

typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_ILLEGAL_TYPE_EDIT,   // trying to edit types in read-only mode
    EC_INVALID_EXECUTABLE,  // not recogized as a valid executable
    EC_DBG_NOT_FOUND,       // A required .DBG file was not found
    EC_NO_DEBUG_INFO,       // No recognized debug info found
    EC_INVALID_EXE_TIMESTAMP, // Invalid timestamp on Openvalidate of exe
    EC_RESERVED, // RESERVED for future use
    EC_DEBUG_INFO_NOT_IN_PDB, // returned by OpenValidateX
    EC_MAX
};

#if !defined(pure)
#define  pure = 0
#endif

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#ifdef PDB_SERVER
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllexport) RTYPE PDBCALL
#elif   defined(PDB_LIBRARY)
#define PDB_IMPORT_EXPORT(RTYPE)    RTYPE PDBCALL
#else
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL
#endif

#define PDBAPI PDB_IMPORT_EXPORT

#ifndef IN
#define IN                  /* in parameter, parameters are IN by default */
#endif
#ifndef OUT
#define OUT                 /* out parameter */
#endif

// Type of callback arg to PDB::OpenValidate5

enum POVC
{
    povcNotifyDebugDir,
    povcNotifyOpenDBG,
    povcNotifyOpenPDB,
    povcReserved,
    povcReadExecutableAt,
    povcReadExecutableAtRVA,
    povcRestrictRegistry,
    povcRestrictSymsrv,
    povcRestrictSystemRoot,
    povcNotifyMiscPath,
};

typedef int (PDBCALL *PDBCALLBACK)();

typedef PDBCALLBACK (PDBCALL *PfnPDBQueryCallback)(void *pvClient, enum POVC povc);

typedef void (PDBCALL *PfnPDBNotifyDebugDir)(void *pvClient, BOOL fExecutable, const struct _IMAGE_DEBUG_DIRECTORY *pdbgdir);
typedef void (PDBCALL *PfnPDBNotifyOpenDBG)(void *pvClient, const wchar_t *wszDbgPath, enum PDBErrors ec, const wchar_t *wszError);
typedef void (PDBCALL *PfnPDBNotifyOpenPDB)(void *pvClient, const wchar_t *wszPdbPath, enum PDBErrors ec, const wchar_t *wszError);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAt)(void *pvClient, DWORDLONG fo, DWORD cb, void *pv);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAtRVA)(void *pvClient, DWORD rva, DWORD cb, void *pv);
typedef HRESULT (PDBCALL *PfnPDBRestrictRegistry)(void *pvClient);
typedef HRESULT (PDBCALL *PfnPDBRestrictSymsrv)(void *pvClient);
typedef HRESULT (PDBCALL *PfnPDBRestrictSystemRoot)(void *pvClient);
typedef void (PDBCALL *PfnPDBNotifyMiscPath)(void *pvClient, const wchar_t *wszMiscPath);

// type of callback arg to PDB::GetRawBytes
typedef BOOL (PDBCALL *PFNfReadPDBRawBytes)(const void *, long);

// WidenTi interface needs a couple of structures to communicate info back
// and forth.
struct OffMap {
    ULONG       offOld;
    ULONG       offNew;
};
typedef struct OffMap   OffMap;
typedef OffMap *        POffMap;

struct SymConvertInfo {
    ULONG       cbSyms;             // size necessary for converting a block
    ULONG       cSyms;              // count of symbols, necessary to allocate
                                    // mpoffOldoffNew array.
    BYTE *      pbSyms;             // block of symbols (output side)
    OffMap *    rgOffMap;           // OffMap rgOffMap[cSyms]
};
typedef struct SymConvertInfo   SymConvertInfo;
enum { wtiSymsNB09 = 0, wtiSymsNB10 = 1 };

// Filter values for PDBCopyTo
enum { 
    copyRemovePrivate       = 0x00000001,   // remove private debug information
    copyCreateNewSig        = 0x00000002,   // create new signature for target pdb
};

// PDBCopy callback signatures and function pointer types for PDB::CopyTo2 and CopyToW2
//
enum PCC {
    pccFilterPublics,
};

#if !defined(__cplusplus)
typedef enum PCC    PCC;
#endif  // __cplusplus

typedef BOOL (PDBCALL *PDBCOPYCALLBACK)();
typedef PDBCOPYCALLBACK (PDBCALL *PfnPDBCopyQueryCallback)(void *pvClientContext, PCC pcc);

// Return (true, pszNewPublic==NULL) to keep the name as is,
// (true, pszNewPublic!=NULL) changes name to pszNewPublic,
// false to discard public entirely.
//
typedef BOOL (PDBCALL *PfnPDBCopyFilterPublics)(
    void *          pvClientContext,
    DWORD           dwFilterFlags,
    unsigned int    offPublic,
    unsigned int    sectPublic,
    unsigned int    grfPublic,      // see cvinfo.h, definition of CV_PUBSYMFLAGS_e and
                                    // CV_PUBSYMFLAGS give the format of this bitfield.
    const wchar_t * szPublic,
    wchar_t **      pszNewPublic
    );

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,   // deprecated
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
#if !defined(VER60)
    dbgtypeTokenRidMap,
    dbgtypeXdata,
    dbgtypePdata,
    dbgtypeNewFPO,
    dbgtypeSectionHdrOrig,
#endif
    dbgtypeMax          // must be last!
};

typedef enum DBGTYPE DBGTYPE;

// We add a slight bit of structure to dbg blobs so we can record extra
// relevant information there.  Generally, the blobs are lifted right out
// of an image, and need some extra info anyway.  In the case of Xdata, we
// store RVA base of the Xdata there.  This is used to interpret the
// UnwindInfoAddress RVA in the IA64 Pdata entries.
//
enum VerDataBlob {
    vdbOne = 1,
    vdbXdataCur = vdbOne,
    vdbPdataCur = vdbOne,
};

// default blob header
//
typedef struct DbgBlob {
    ULONG   ver;
    ULONG   cbHdr;
    ULONG   cbData;
    //BYTE    rgbDataBlob[];    // Data follows, but to enable simple embedding,
                                // don't use a zero-sized array here.
} DbgBlob;

// "store rva of the base and va of image base" blob header
//
typedef struct DbgRvaVaBlob {
    ULONG       ver;
    ULONG       cbHdr;
    ULONG       cbData;
    ULONG       rvaDataBase;
    DWORDLONG   vaImageBase;
    ULONG       ulReserved1;    // reserved, must be 0
    ULONG       ulReserved2;    // reserved, must be 0
    //BYTE      rgbDataBlob[];  // Data follows, but to enable simple embedding,
                                // don't use a zero-sized array here.
} DbgRvaVaBlob;

// Linker data necessary for relinking an image.  Record contains two SZ strings
// off of the end of the record with two offsets from the base 
//
enum VerLinkInfo {
    vliOne = 1,
    vliTwo = 2,
    vliCur = vliTwo,
};

struct LinkInfo {
    ULONG           cb;             // size of the whole record.  computed as
                                    //  sizeof(LinkInfo) + strlen(szCwd) + 1 +
                                    //  strlen(szCommand) + 1
    ULONG           ver;            // version of this record (VerLinkInfo)
    ULONG           offszCwd;       // offset from base of this record to szCwd
    ULONG           offszCommand;   // offset from base of this record
    ULONG           ichOutfile;     // index of start of output file in szCommand
    ULONG           offszLibs;      // offset from base of this record to szLibs

    // The command includes the full path to the linker, the -re and -out:...
    // swithches.
    // A sample might look like the following:
    // "c:\program files\msdev\bin\link.exe -re -out:debug\foo.exe"
    // with ichOutfile being 48.
    // the -out switch is guaranteed to be the last item in the command line.
#ifdef __cplusplus
    VerLinkInfo Ver() const {
        return VerLinkInfo(ver);
    }
    long Cb() const {
        return cb;
    }
    char *     SzCwd() const {
        return (char *)((char *)(this) + offszCwd);
    }
    char *    SzCommand() const {
        return (char *)((char *)(this) + offszCommand);
    }
    char *    SzOutFile() const {
        return SzCommand() + ichOutfile;
    }
    LinkInfo() :
        cb(0), ver(vliCur), offszCwd(0), offszCommand(0), ichOutfile(0)
    {
    }
    char *    SzLibs() const {
        return (char *)((char *)(this) + offszLibs);
    }

#endif
};

#ifdef LNGNM
#ifdef __cplusplus
struct LinkInfoW : public LinkInfo
{
    wchar_t* SzCwdW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCwd);
    }
    wchar_t* SzCommandW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCommand);
    }
    wchar_t* SzOutFileW() const {
        return SzCommandW() + ichOutfile;
    }
    wchar_t* SzLibsW() const {
        return (wchar_t *)((wchar_t *)(this) + offszLibs);
    }
};
#else
typedef struct LinkInfo LinkInfoW;
#endif  // __cplusplus

typedef LinkInfoW * PLinkInfoW;

#endif  // LNGNM

typedef struct LinkInfo LinkInfo;
typedef LinkInfo *      PLinkInfo;


//
// Source (Src) info
//
// This is the source file server for virtual and real source code.
// It is structured as an index on the object file name concatenated
// with 
enum SrcVer {
    srcverOne = 19980827,
};

enum SrcCompress {
    srccompressNone,
    srccompressRLE,
    srccompressHuffman,
    srccompressLZ,
};

#ifdef LNGNM
struct tagSrcHeader {
#else
struct SrcHeader {
#endif
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
#ifndef LNGNM
    unsigned char   szNames[1]; // file names (szFile "\0" szObj "\0" szVirtual,
                                //  as in: "f.cpp" "\0" "f.obj" "\0" "*inj:1:f.obj")
                                // in the case of non-virtual files, szVirtual is
                                // the same as szFile.
#endif
};

#ifdef LNGNM
struct SrcHeader : public tagSrcHeader
{
    unsigned char szNames[1];   // see comment above
};

struct SrcHeaderW : public tagSrcHeader
{
    wchar_t szNames[1];   // see comment above
};

typedef struct SrcHeaderW    SrcHeaderW;
typedef SrcHeaderW *         PSrcHeaderW;
typedef const SrcHeaderW *   PCSrcHeaderW;

//cassert(offsetof(SrcHeader,szNames) == sizeof(tagSrcHeader));
//cassert(offsetof(SrcHeaderW,szNames) == sizeof(tagSrcHeader));

#endif      // LNGNM

typedef struct SrcHeader    SrcHeader;
typedef SrcHeader *         PSrcHeader;
typedef const SrcHeader *   PCSrcHeader;

// header used for storing the info and for output to clients who are reading
//
struct SrcHeaderOut {
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned long   niFile;
    unsigned long   niObj;
    unsigned long   niVirt;
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
    short           sPad;
    union {
        void *      pvReserved1;
        __int64     pv64Reserved2;
    };
};

typedef struct SrcHeaderOut SrcHeaderOut;
typedef SrcHeaderOut *      PSrcHeaderOut;
typedef const SrcHeaderOut *PCSrcHeaderOut;

struct SrcHeaderBlock {
    __int32     ver;
    __int32     cb;
    struct {
        DWORD   dwLowDateTime;
        DWORD   dwHighDateTime;
    } ft;
    __int32     age;
    BYTE        rgbPad[44];
};

typedef struct SrcHeaderBlock   SrcHeaderBlock;


#ifdef __cplusplus

struct IStream;

// C++ Binding

PdbInterface PDB {                 // program database
    enum {
        intv  = PDBIntv,
#if defined(LNGNM)
        intvVC70Dep = PDBIntv70Dep,     // deprecated
#endif
        intvAlt = PDBIntvAlt,
        intvAlt2 = PDBIntvAlt2,
        intvAlt3 = PDBIntvAlt3,
    };

    static PDBAPI(BOOL)
           OpenValidate(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           Open(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate3(
               const char *szExecutable,
               const char *szSearchPath,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT char szDbgPath[PDB_MAX_PATH],
               OUT DWORD *pfo,
               OUT DWORD *pcb,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate4(
               const wchar_t *wszPDB,
               const char *szMode,
               PCSIG70 pcsig70,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) OpenInStream(
               IStream *pIStream,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) ExportValidateInterface(INTV intv);
    static PDBAPI(BOOL) ExportValidateImplementation(IMPV impv);

    static PDBAPI(IMPV) QueryImplementationVersionStatic();
    static PDBAPI(INTV) QueryInterfaceVersionStatic();

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual EC   QueryLastError(OUT char szError[cbErrMax]) pure;
    virtual char*QueryPDBName(OUT char szPDB[PDB_MAX_PATH]) pure;
    virtual SIG  QuerySignature() pure;
    virtual AGE  QueryAge() pure;
    virtual BOOL CreateDBI(const char* szTarget, OUT DBI** ppdbi) pure;
    virtual BOOL OpenDBI(const char* szTarget, const char* szMode, OUT DBI** ppdbi ) pure;
    virtual BOOL OpenTpi(const char* szMode, OUT TPI** pptpi) pure;

    virtual BOOL Commit() pure;
    virtual BOOL Close() pure;
    virtual BOOL OpenStream(const char* szStream, OUT Stream** ppstream) pure;
    virtual BOOL GetEnumStreamNameMap(OUT Enum** ppenum) pure;
    virtual BOOL GetRawBytes(PFNfReadPDBRawBytes pfnfSnarfRawBytes) pure;
    virtual IMPV QueryPdbImplementationVersion() pure;

    virtual BOOL OpenDBIEx(const char* szTarget, const char* szMode, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn=0) pure;

    virtual BOOL CopyTo(const char *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;

    //
    // support for source file data
    //
    virtual BOOL OpenSrc(OUT Src** ppsrc) pure;

    virtual EC   QueryLastErrorExW(OUT wchar_t *wszError, size_t cchMax) pure;
    virtual wchar_t *QueryPDBNameExW(OUT wchar_t *wszPDB, size_t cchMax) pure;
    virtual BOOL QuerySignature2(PSIG70 psig70) pure;
    virtual BOOL CopyToW(const wchar_t *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;
    virtual BOOL fIsSZPDB() const pure;

    // Implemented only on 7.0 and above versions.
    //
    virtual BOOL OpenStreamW(const wchar_t * szStream, OUT Stream** ppstream) pure;

	// Implemented in both 6.0 and 7.0 builds

    virtual BOOL CopyToW2(
        const wchar_t *         szDst,
        DWORD                   dwCopyFilter,
        PfnPDBCopyQueryCallback pfnCallBack,
        void *                  pvClientContext
        ) pure;


    inline BOOL ValidateInterface()
    {
        return ExportValidateInterface(intv);
    }

    static PDBAPI(BOOL)
           Open2W(
               const wchar_t *wszPDB,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx2W(
               const wchar_t *wszPDB,
               const char *szMode,
               long cbPage,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate5(
               const wchar_t *wszExecutable,
               const wchar_t *wszSearchPath,
               void *pvClient,
               PfnPDBQueryCallback pfnQueryCallback,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);


};


// Review: a stream directory service would be more appropriate
// than Stream::Delete, ...

PdbInterface Stream {
    virtual long QueryCb() pure;
    virtual BOOL Read(long off, void* pvBuf, long* pcbBuf) pure;
    virtual BOOL Write(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Replace(void* pvBuf, long cbBuf) pure;
    virtual BOOL Append(void* pvBuf, long cbBuf) pure;
    virtual BOOL Delete() pure;
    virtual BOOL Release() pure;
    virtual BOOL Read2(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Truncate(long cb) pure;
};

PdbInterface StreamImage {
    static PDBAPI(BOOL) open(Stream* pstream, long cb, OUT StreamImage** ppsi);
    virtual long size() pure;
    virtual void* base() pure;
    virtual BOOL noteRead(long off, long cb, OUT void** ppv) pure;
    virtual BOOL noteWrite(long off, long cb, OUT void** ppv) pure;
    virtual BOOL writeBack() pure;
    virtual BOOL release() pure;
};

PdbInterface DBI {             // debug information
    enum { intv = PDBIntv };
    virtual IMPV QueryImplementationVersion() pure;
    virtual INTV QueryInterfaceVersion() pure;
    virtual BOOL OpenMod(const char* szModule, const char* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteMod(const char* szModule) pure;
    virtual BOOL QueryNextMod(Mod* pmod, Mod** ppmodNext) pure;
    virtual BOOL OpenGlobals(OUT GSI **ppgsi) pure;
    virtual BOOL OpenPublics(OUT GSI **ppgsi) pure;
    virtual BOOL AddSec(USHORT isect, USHORT flags, long off, long cb) pure;
#if defined(LNGNM) && (_MSC_VER >= 1300)
    //__declspec(deprecated)
#endif
    virtual BOOL QueryModFromAddr(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb) pure;
    virtual BOOL QuerySecMap(OUT BYTE* pb, long* pcb) pure;
    virtual BOOL QueryFileInfo(OUT BYTE* pb, long* pcb) pure;
    virtual void DumpMods() pure;
    virtual void DumpSecContribs() pure;
    virtual void DumpSecMap() pure;

    virtual BOOL Close() pure;
    virtual BOOL AddThunkMap(long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                    struct SO* psoSectMap, unsigned nSects,
                    USHORT isectThunkTable, long offThunkTable) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL getEnumContrib(OUT Enum** ppenum) pure;
    virtual BOOL QueryTypeServer( ITSM itsm, OUT TPI** pptpi ) pure;
    virtual BOOL QueryItsmForTi( TI ti, OUT ITSM* pitsm ) pure;
    virtual BOOL QueryNextItsm( ITSM itsm, OUT ITSM *inext ) pure;
    virtual BOOL QueryLazyTypes() pure;
    virtual BOOL SetLazyTypes( BOOL fLazy ) pure;   // lazy is default and can only be turned off
    virtual BOOL FindTypeServers( OUT EC* pec, OUT char szError[cbErrMax] ) pure;
    virtual void DumpTypeServers() pure;
    virtual BOOL OpenDbg(DBGTYPE dbgtype, OUT Dbg **ppdbg) pure;
    virtual BOOL QueryDbgTypes(OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype) pure;
    // apis to support EnC work
    virtual BOOL QueryAddrForSec(OUT USHORT* pisect, OUT long* poff, 
            USHORT imod, long cb, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdb( OUT PDB** pppdb ) pure;
    virtual BOOL AddLinkInfo(IN PLinkInfo ) pure;
    virtual BOOL QueryLinkInfo(PLinkInfo, OUT long * pcb) pure;
    // new to vc6
    virtual AGE  QueryAge() const pure;
    virtual void * QueryHeader() const pure;
    virtual void FlushTypeServers() pure;
    virtual BOOL QueryTypeServerByPdb(const char* szPdb, OUT ITSM* pitsm) pure;

#ifdef LNGNM        // Long filename support
    virtual BOOL OpenModW(const wchar_t* szModule, const wchar_t* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteModW(const wchar_t* szModule) pure;
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL QueryTypeServerByPdbW( const wchar_t* szPdb, OUT ITSM* pitsm ) pure;
    virtual BOOL AddLinkInfoW(IN PLinkInfoW ) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual USHORT QueryMachineType() const pure;
    virtual void SetMachineType(USHORT wMachine) pure;
    virtual void RemoveDataForRva( ULONG rva, ULONG cb ) pure;
    virtual bool FStripped() const pure;
    virtual BOOL QueryModFromAddr2(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb,
                    OUT ULONG * pdwCharacteristics) pure;
#else
    virtual bool FStripped() const pure;
#endif
};

PdbInterface Mod {             // info for one module within DBI
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BOOL AddTypes(BYTE* pbTypes, long cb) pure;
    virtual BOOL AddSymbols(BYTE* pbSym, long cb) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL AddLines(const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          USHORT lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL AddSecContrib(USHORT isect, long off, long cb, ULONG dwCharacteristics) pure;
    virtual BOOL QueryCBName(OUT long* pcb) pure;
    virtual BOOL QueryName(OUT char szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySymbols(BYTE* pbSym, long* pcb) pure;
    virtual BOOL QueryLines(BYTE* pbLines, long* pcb) pure;

    virtual BOOL SetPvClient(void *pvClient) pure;
    virtual BOOL GetPvClient(OUT void** ppvClient) pure;
    virtual BOOL QueryFirstCodeSecContrib(OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
//
// Make all users of this api use the real one, as this is exactly what it was
// supposed to query in the first place
//
#define QuerySecContrib QueryFirstCodeSecContrib

    virtual BOOL QueryImod(OUT USHORT* pimod) pure;
    virtual BOOL QueryDBI(OUT DBI** ppdbi) pure;
    virtual BOOL Close() pure;
    virtual BOOL QueryCBFile(OUT long* pcb) pure;
    virtual BOOL QueryFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryTpi(OUT TPI** pptpi) pure; // return this Mod's Tpi
    // apis to support EnC work
    virtual BOOL AddSecContribEx(USHORT isect, long off, long cb, ULONG dwCharacteristics, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QueryItsm(OUT USHORT* pitsm) pure;
    virtual BOOL QuerySrcFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdbFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL ReplaceLines(BYTE* pbLines, long cb) pure;
#ifdef LNGNM
    // V7 line number support
	virtual bool GetEnumLines( EnumLines** ppenum ) pure;
	virtual bool QueryLineFlags( OUT DWORD* pdwFlags ) pure;	// what data is present?
	virtual bool QueryFileNameInfo( 
                    IN DWORD        fileId,                 // source file identifier
                    OUT wchar_t*    szFilename,             // file name string 
                    IN OUT DWORD*   pccFilename,            // length of string
                    OUT DWORD*      pChksumType,            // type of chksum
                    OUT BYTE*       pbChksum,   	        // pointer to buffer for chksum data
                    IN OUT DWORD*   pcbChksum		        // number of bytes of chksum (in/out)
                    ) pure; 	    
    // Long filenames support
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL AddLinesW(const wchar_t* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          ULONG lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL QueryNameW(OUT wchar_t szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySrcFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryPdbFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL InsertLines(BYTE* pbLines, long cb) pure;
#endif
};

PdbInterface TPI {             // type info

    enum { intv = PDBIntv };

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;

    virtual BOOL QueryTi16ForCVRecord(BYTE* pb, OUT TI16* pti) pure;
    virtual BOOL QueryCVRecordForTi16(TI16 ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi16(TI16 ti, OUT BYTE** ppb) pure;
    virtual TI16 QueryTi16Min() pure;
    virtual TI16 QueryTi16Mac() pure;

    virtual long QueryCb() pure;
    virtual BOOL Close() pure;
    virtual BOOL Commit() pure;

    virtual BOOL QueryTi16ForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI16* pti) pure;
    virtual BOOL SupportQueryTiForUDT() pure;

    // the new versions that truly take 32-bit types
    virtual BOOL fIs16bitTypePool() pure;
    virtual BOOL QueryTiForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti) pure;
    virtual BOOL QueryTiForCVRecord(BYTE* pb, OUT TI* pti) pure;
    virtual BOOL QueryCVRecordForTi(TI ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi(TI ti, OUT BYTE** ppb) pure;
    virtual TI   QueryTiMin() pure;
    virtual TI   QueryTiMac() pure;
    virtual BOOL AreTypesEqual( TI ti1, TI ti2 ) pure;
    virtual BOOL IsTypeServed( TI ti ) pure;
#ifdef LNGNM
    virtual BOOL QueryTiForUDTW(const wchar_t *wcs, BOOL fCase, OUT TI* pti) pure;
#endif
};

PdbInterface GSI {
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BYTE* NextSym(BYTE* pbSym) pure;
    virtual BYTE* HashSym(const char* szName, BYTE* pbSym) pure;
    virtual BYTE* NearestSym(USHORT isect, long off, OUT long* pdisp) pure;      //currently only supported for publics
    virtual BOOL Close() pure;
    virtual BOOL getEnumThunk(USHORT isect, long off, OUT EnumThunk** ppenum) pure;
    virtual unsigned long OffForSym(BYTE *pbSym) pure;
    virtual BYTE* SymForOff(unsigned long off) pure;
#ifdef LNGNM
    virtual BYTE* HashSymW(const wchar_t *wcsName, BYTE* pbSym) pure;
#endif
    virtual BOOL getEnumByAddr(EnumSyms **ppEnum) pure;
};


PdbInterface NameMap {
    static PDBAPI(BOOL) open(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
    virtual BOOL close() pure;
    virtual BOOL reinitialize() pure;
    virtual BOOL getNi(const char* sz, OUT NI* pni) pure;
    virtual BOOL getName(NI ni, OUT const char** psz) pure;
    virtual BOOL getEnumNameMap(OUT Enum** ppenum) pure;
    virtual BOOL contains(const char* sz, OUT NI* pni) pure;
    virtual BOOL commit() pure;
    virtual BOOL isValidNi(NI ni) pure;
#ifdef LNGNM
    virtual BOOL getNiW(const wchar_t* sz, OUT NI* pni) pure;
    virtual BOOL getNameW(NI ni, OUT wchar_t* szName, IN OUT size_t * pcch) pure;
    virtual BOOL containsW(const wchar_t *sz, OUT NI* pni) pure;
    virtual BOOL containsUTF8(const char* sz, OUT NI* pni) pure;
    virtual BOOL getNiUTF8(const char *sz, OUT NI* pni) pure;
    virtual BOOL getNameA(NI ni, OUT const char ** psz) pure;
    virtual BOOL getNameW2(NI ni, OUT const wchar_t ** pwsz) pure;
#endif
};

#define __ENUM_INCLUDED__
PdbInterface Enum {
    virtual void release() pure;
    virtual void reset() pure;
    virtual BOOL next() pure;
};

PdbInterface EnumNameMap : Enum {
    virtual void get(OUT const char** psz, OUT NI* pni) pure;
};

PdbInterface EnumContrib : Enum {
    virtual void get(OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
    virtual void getCrcs(OUT DWORD* pcrcData, OUT DWORD* pcrcReloc ) pure;
    virtual bool fUpdate(IN long off, IN long cb) pure;
    virtual BOOL prev() pure;
    virtual BOOL clone( OUT EnumContrib **ppEnum ) pure;
    virtual BOOL locate( IN long isect, IN long off ) pure;
};

PdbInterface EnumThunk: Enum {
	virtual void get( OUT USHORT* pisect, OUT long* poff, OUT long* pcb ) pure;
};

PdbInterface EnumSyms : Enum {
    virtual void get( BYTE** ppbSym ) pure;
    virtual BOOL prev() pure;
    virtual BOOL clone( OUT EnumSyms **ppEnum ) pure;
    virtual BOOL locate( IN long isect, IN long off ) pure;
};
struct CV_Line_t;
struct CV_Column_t;
PdbInterface EnumLines: public Enum
{
    // 
    // Blocks of lines are always in offset order, lines within blocks are also ordered by offset
    //
    virtual bool getLines( 	
        OUT DWORD*      fileId, 	// id for the filename
        OUT DWORD*      poffset,	// offset part of address
        OUT WORD*	    pseg, 		// segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines, 	// number of lines (in/out)
        OUT CV_Line_t*  pLines		// pointer to buffer for line info
        ) = 0;
    virtual bool getLinesColumns( 	
        OUT DWORD*      fileId,     // id for the filename	    
        OUT DWORD*      poffset, 	// offset part of address
        OUT WORD*	    pseg, 		// segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines,    // number of lines (in/out)
        OUT CV_Line_t*  pLines,		// pointer to buffer for line info
        OUT CV_Column_t*pColumns	// pointer to buffer for column info
        ) = 0;
    virtual bool clone( 
        OUT EnumLines **ppEnum      // return pointer to the clone
        ) = 0;
};

//
// interface to use to widen type indices from 16 to 32 bits
// and store the results in a new location.
//
PdbInterface WidenTi {
public:
    static PDBAPI(BOOL)
    fCreate (
        WidenTi *&,
        unsigned cTypeInitialCache =256,
        BOOL fNB10Syms =wtiSymsNB09
        );

    virtual void
    release() pure;

    virtual BYTE /* TYPTYPE */ *
    pTypeWidenTi ( TI ti16, BYTE /* TYPTYPE */ * ) pure;

    virtual BYTE /* SYMTYPE */ *
    pSymWidenTi ( BYTE /* SYMTYPE */ * ) pure;

    virtual BOOL
    fTypeWidenTiNoCache ( BYTE * pbTypeDst, BYTE * pbTypeSrc, long & cbDst ) pure;

    virtual BOOL
    fSymWidenTiNoCache ( BYTE * pbSymDst, BYTE * pbSymSrc, long & cbDst ) pure;

    virtual BOOL
    fTypeNeedsWidening ( BYTE * pbType ) pure;

    virtual BOOL
    fSymNeedsWidening ( BYTE * pbSym ) pure;

    virtual BOOL
    freeRecord ( void * ) pure;

    // symbol block converters/query.  symbols start at doff from pbSymIn,
    // converted symbols will go at sci.pbSyms + doff, cbSyms are all including
    // doff.
    virtual BOOL
        fQuerySymConvertInfo (
        SymConvertInfo &    sciOut,
        BYTE *              pbSym,
        long                cbSym,
        int                 doff =0
        ) pure;

    virtual BOOL
    fConvertSymbolBlock (
        SymConvertInfo &    sciOut,
        BYTE *              pbSymIn,
        long                cbSymIn,
        int                 doff =0
        ) pure;
};

// interface for managing Dbg data
PdbInterface Dbg {
   // close Dbg Interface
   virtual BOOL Close() pure;
   // return number of elements (NOT bytes)
   virtual long QuerySize() pure;
   // reset enumeration index
   virtual void Reset() pure;
   // skip next celt elements (move enumeration index)
   virtual BOOL Skip(ULONG celt) pure;
   // query next celt elements into user-supplied buffer
   virtual BOOL QueryNext(ULONG celt, OUT void *rgelt) pure;
   // search for an element and fill in the entire struct given a field.
   // Only supported for the following debug types and fields:
   // DBG_FPO              'ulOffStart' field of FPO_DATA
   // DBG_FUNC             'StartingAddress' field of IMAGE_FUNCTION_ENTRY
   // DBG_OMAP             'rva' field of OMAP
   virtual BOOL Find(IN OUT void *pelt) pure;
   // remove debug data
   virtual BOOL Clear() pure;
   // append celt elements
   virtual BOOL Append(ULONG celt, const void *rgelt) pure;
   // replace next celt elements
   virtual BOOL ReplaceNext(ULONG celt, const void *rgelt) pure;
   // create a clone of this interface
   virtual BOOL Clone( Dbg** ppDbg ) pure;
};

PdbInterface Src {
    // close and commit the changes (when open for write)
    virtual bool
    Close() pure;

    // add a source file or file-ette
    virtual bool
    Add(IN PCSrcHeader psrcheader, IN const void * pvData) pure;

    // remove a file or file-ette or all of the injected code for
    // one particular compiland (using the object file name)
    virtual bool
    Remove(IN SZ_CONST szFile) pure;

    // query and copy the header/control data to the output buffer
    virtual bool
    QueryByName(IN SZ_CONST szFile, OUT PSrcHeaderOut psrcheaderOut) const pure;

    // copy the file data (the size of the buffer is in the SrcHeaderOut
    // structure) to the output buffer.
    virtual bool
    GetData(IN PCSrcHeaderOut pcsrcheader, OUT void * pvData) const pure;

    // create an enumerator to traverse all of the files included
    // in the mapping.
    virtual bool
    GetEnum(OUT EnumSrc ** ppenum) const pure;

    // Get the header block (master header) of the Src data.
    // Includes age, time stamp, version, and size of the master stream
    virtual bool
    GetHeaderBlock(SrcHeaderBlock & shb) const pure;
#ifdef LNGNM
    virtual bool RemoveW(IN wchar_t *wcsFile) pure;
    virtual bool QueryByNameW(IN wchar_t *wcsFile, OUT PSrcHeaderOut psrcheaderOut) const pure;
    virtual bool AddW(IN PCSrcHeaderW psrcheader, IN const void * pvData) pure;
#endif
};

PdbInterface EnumSrc : Enum {
    virtual void get(OUT PCSrcHeaderOut * ppcsrcheader) pure;
};


PdbInterface SrcHash {

    // Various types we need
    //
    
    // Tri-state return type
    //
    enum TriState {
        tsYes,
        tsNo,
        tsMaybe,
    };

    // Hash identifier
    //
    enum HID {
        hidNone,
        hidMD5,
        hidMax,
    };

    // Define machine independent types for storage of HashID and size_t
    //
    typedef __int32 HashID_t;
    typedef unsigned __int32 CbHash_t;

    // Create a SrcHash object with the usual two-stage construction technique
    //
    static PDBAPI(bool)
    FCreateSrcHash(OUT PSrcHash &);

    // Accumulate more bytes into the hash
    //
    virtual bool
    FHashBuffer(IN PCV pvBuf, IN size_t cbBuf) pure;

    // Query the hash id
    //
    virtual HashID_t
    HashID() const pure;

    // Query the size of the hash 
    //
    virtual CbHash_t
    CbHash() const pure;

    // Copy the hash bytes to the client buffer
    //
    virtual void
    GetHash(OUT PV pvHash, IN CbHash_t cbHash) const pure;

    // Verify the incoming hash against a target buffer of bytes
    // returning a yes it matches, no it doesn't, or indeterminate.
    //
    virtual TriState
    TsVerifyHash(
        IN HID,
        IN CbHash_t cbHash,
        IN PCV pvHash,
        IN size_t cbBuf,
        IN PCV pvBuf
        ) pure;

    // Reset this object to pristine condition
    //
    virtual bool
    FReset() pure;

    // Close off and release this object
    //
    virtual void
    Close() pure;
};

#endif  // __cplusplus

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

typedef BOOL (PDBCALL *PfnPDBOpen)(
    LNGNM_CONST char *,
    LNGNM_CONST char *,
    SIG,
    EC *,
    char [cbErrMax],
    PDB **);

PDBAPI(BOOL)
PDBOpen(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpen2W(
    const wchar_t *wszPDB,
    const char *szMode,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx2W(
    const wchar_t *wszPDB,
    const char *szMode,
    long cbPage,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate3(
    const char *szExecutable,
    const char *szSearchPath,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT char szDbgPath[PDB_MAX_PATH],
    OUT DWORD *pfo,
    OUT DWORD *pcb,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate4(
    const wchar_t *wszPDB,
    const char *szMode,
    PCSIG70 pcsig70,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate5(
    const wchar_t *wszExecutable,
    const wchar_t *wszSearchPath,
    void *pvClient,
    PfnPDBQueryCallback pfnQueryCallback,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI(BOOL)
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface(void)
{
    return PDBExportValidateInterface(PDBIntv);
}

typedef BOOL (PDBCALL *PfnPDBExportValidateInterface)(INTV);

__inline BOOL PDBValidateInterfacePfn(PfnPDBExportValidateInterface pfn)
{
    return (*pfn)(PDBIntv);
}

PDBAPI(EC)     PDBQueryLastError(PDB *ppdb, OUT char szError[cbErrMax]);
PDBAPI(INTV)   PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI(IMPV)   PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI(char*)  PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI(SIG)    PDBQuerySignature(PDB* ppdb);
PDBAPI(BOOL)   PDBQuerySignature2(PDB* ppdb, PSIG70 psig70);
PDBAPI(AGE)    PDBQueryAge(PDB* ppdb);
PDBAPI(BOOL)   PDBCreateDBI(PDB* ppdb, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenDBIEx(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn);
PDBAPI(BOOL)   PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenTpi(PDB* ppdb, const char* szMode, OUT TPI** pptpi);
PDBAPI(BOOL)   PDBCommit(PDB* ppdb);
PDBAPI(BOOL)   PDBClose(PDB* ppdb);
PDBAPI(BOOL)   PDBOpenStream(PDB* ppdb, const char* szStream, OUT Stream** ppstream);
PDBAPI(BOOL)   PDBCopyTo(PDB *ppdb, const char *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBCopyToW(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBfIsSZPDB(PDB *ppdb);
PDBAPI(BOOL)   PDBCopyToW2(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, PfnPDBCopyQueryCallback pfnCallBack, void * pvClientContext);

PDBAPI(INTV)   DBIQueryInterfaceVersion(DBI* pdbi);
PDBAPI(IMPV)   DBIQueryImplementationVersion(DBI* pdbi);
PDBAPI(BOOL)   DBIOpenMod(DBI* pdbi, const char* szModule, const char* szFile, OUT Mod** ppmod);
PDBAPI(BOOL)   DBIDeleteMod(DBI* pdbi, const char* szModule);
PDBAPI(BOOL)   DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI(BOOL)   DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIAddSec(DBI* pdbi, USHORT isect, USHORT flags, long off, long cb);
PDBAPI(BOOL)   DBIAddPublic(DBI* pdbi, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb);
#ifdef LNGNM
PDBAPI(BOOL)   DBIQueryModFromAddr2(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG *pdwCharacteristics);
#endif
PDBAPI(BOOL)   DBIQuerySecMap(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQueryFileInfo(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQuerySupportsEC(DBI* pdbi);
PDBAPI(void)   DBIDumpMods(DBI* pdbi);
PDBAPI(void)   DBIDumpSecContribs(DBI* pdbi);
PDBAPI(void)   DBIDumpSecMap(DBI* pdbi);
PDBAPI(BOOL)   DBIClose(DBI* pdbi);
PDBAPI(BOOL)   DBIAddThunkMap(DBI* pdbi, long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                              struct SO* psoSectMap, unsigned nSects, USHORT isectThunkTable, long offThunkTable);
PDBAPI(BOOL)   DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI(BOOL)   DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI(BOOL)   DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI(BOOL)   DBIQueryNextItsm(DBI* pdbi, ITSM itsm, OUT ITSM *inext );
PDBAPI(BOOL)   DBIQueryLazyTypes(DBI* pdbi);
PDBAPI(BOOL)   DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI(BOOL)   DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI(BOOL)   DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);
PDBAPI(BOOL)   DBIAddLinkInfo(DBI* pdbi, IN PLinkInfo);
PDBAPI(BOOL)   DBIQueryLinkInfo(DBI* pdbi, PLinkInfo, IN OUT long * pcb);
PDBAPI(BOOL)   DBIFStripped(DBI* pdbi);

PDBAPI(INTV)   ModQueryInterfaceVersion(Mod* pmod);
PDBAPI(IMPV)   ModQueryImplementationVersion(Mod* pmod);
PDBAPI(BOOL)   ModAddTypes(Mod* pmod, BYTE* pbTypes, long cb);
PDBAPI(BOOL)   ModAddSymbols(Mod* pmod, BYTE* pbSym, long cb);
PDBAPI(BOOL)   ModAddPublic(Mod* pmod, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   ModAddLines(Mod* pmod, const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                           USHORT lineStart, BYTE* pbCoff, long cbCoff);
PDBAPI(BOOL)   ModAddSecContrib(Mod * pmod, USHORT isect, long off, long cb, ULONG dwCharacteristics);
PDBAPI(BOOL)   ModQueryCBName(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySymbols(Mod* pmod, BYTE* pbSym, long* pcb);
PDBAPI(BOOL)   ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb);
PDBAPI(BOOL)   ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI(BOOL)   ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI(BOOL)   ModQuerySecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryFirstCodeSecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryImod(Mod* pmod, OUT USHORT* pimod);
PDBAPI(BOOL)   ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI(BOOL)   ModClose(Mod* pmod);
PDBAPI(BOOL)   ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySrcFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQueryPdbFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySupportsEC(Mod* pmod);
PDBAPI(BOOL)   ModQueryTpi(Mod* pmod, OUT TPI** pptpi);
PDBAPI(BOOL)   ModReplaceLines(Mod* pmod, BYTE* pbLines, long cb);

PDBAPI(INTV)   TypesQueryInterfaceVersion(TPI* ptpi);
PDBAPI(IMPV)   TypesQueryImplementationVersion(TPI* ptpi);
// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)   TypesQueryTiForCVRecordEx(TPI* ptpi, BYTE* pb, OUT TI* pti);
PDBAPI(BOOL)   TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE* pb, IN OUT long* pcb);
PDBAPI(BOOL)   TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE** ppb);
PDBAPI(TI)     TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)     TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(long)   TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)   TypesClose(TPI* ptpi);
PDBAPI(BOOL)   TypesCommit(TPI* ptpi);
PDBAPI(BOOL)   TypesQueryTiForUDTEx(TPI* ptpi, LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)   TypesSupportQueryTiForUDT(TPI*);
PDBAPI(BOOL)   TypesfIs16bitTypePool(TPI*);
// Map all old ones to new ones for new compilands.
#define TypesQueryTiForCVRecord     TypesQueryTiForCVRecordEx
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx
#define TypesQueryTiForUDT          TypesQueryTiForUDTEx
PDBAPI(BOOL)    TypesAreTypesEqual( TPI* ptpi, TI ti1, TI ti2 );
PDBAPI(BOOL)    TypesIsTypeServed( TPI* ptpi, TI ti );

PDBAPI(BYTE*)  GSINextSym (GSI* pgsi, BYTE* pbSym);
PDBAPI(BYTE*)  GSIHashSym (GSI* pgsi, const char* szName, BYTE* pbSym);
PDBAPI(BYTE*)  GSINearestSym (GSI* pgsi, USHORT isect, long off,OUT long* pdisp);//currently only supported for publics
PDBAPI(BOOL)   GSIClose(GSI* pgsi);
PDBAPI(unsigned long)   GSIOffForSym( GSI* pgsi, BYTE* pbSym );
PDBAPI(BYTE*)   GSISymForOff( GSI* pgsi, unsigned long off );

PDBAPI(long)   StreamQueryCb(Stream* pstream);
PDBAPI(BOOL)   StreamRead(Stream* pstream, long off, void* pvBuf, long* pcbBuf);
PDBAPI(BOOL)   StreamWrite(Stream* pstream, long off, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamReplace(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamAppend(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamDelete(Stream* pstream);
PDBAPI(BOOL)   StreamTruncate(Stream* pstream, long cb);
PDBAPI(BOOL)   StreamRelease(Stream* pstream);

PDBAPI(BOOL)   StreamImageOpen(Stream* pstream, long cb, OUT StreamImage** ppsi);
PDBAPI(void*)  StreamImageBase(StreamImage* psi);
PDBAPI(long)   StreamImageSize(StreamImage* psi);
PDBAPI(BOOL)   StreamImageNoteRead(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageNoteWrite(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageWriteBack(StreamImage* psi);
PDBAPI(BOOL)   StreamImageRelease(StreamImage* psi);

PDBAPI(BOOL)   NameMapOpen(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
PDBAPI(BOOL)   NameMapClose(NameMap* pnm);
PDBAPI(BOOL)   NameMapReinitialize(NameMap* pnm);
PDBAPI(BOOL)   NameMapGetNi(NameMap* pnm, const char* sz, OUT NI* pni);
PDBAPI(BOOL)   NameMapGetName(NameMap* pnm, NI ni, OUT const char** psz);
PDBAPI(BOOL)   NameMapGetEnumNameMap(NameMap* pnm, OUT Enum** ppenum);
PDBAPI(BOOL)   NameMapCommit(NameMap* pnm);

PDBAPI(void)   EnumNameMapRelease(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapReset(EnumNameMap* penum);
PDBAPI(BOOL)   EnumNameMapNext(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapGet(EnumNameMap* penum, OUT const char** psz, OUT NI* pni);

PDBAPI(void)   EnumContribRelease(EnumContrib* penum);
PDBAPI(void)   EnumContribReset(EnumContrib* penum);
PDBAPI(BOOL)   EnumContribNext(EnumContrib* penum);
PDBAPI(void)   EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(void)   EnumContribGetCrcs(EnumContrib* penum, OUT DWORD* pcrcData, OUT DWORD* pcrcReloc);
PDBAPI(BOOL)   EnumContribfUpdate(EnumContrib* penum, IN long off, IN long cb);

PDBAPI(SIG)    SigForPbCb(BYTE* pb, size_t cb, SIG sig);
PDBAPI(void)   TruncStFromSz(char *stDst, const char *szSrc, size_t cbSrc);

PDBAPI(BOOL)   DbgClose(Dbg *pdbg);
PDBAPI(long)   DbgQuerySize(Dbg *pdbg);
PDBAPI(void)   DbgReset(Dbg *pdbg);
PDBAPI(BOOL)   DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI(BOOL)   DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI(BOOL)   DbgFind(Dbg *pdbg, IN OUT void *pelt);
PDBAPI(BOOL)   DbgClear(Dbg *pdbg);
PDBAPI(BOOL)   DbgAppend(Dbg *pdbg, ULONG celt, const void *rgelt);
PDBAPI(BOOL)   DbgReplaceNext(Dbg *pdbg, ULONG celt, const void *rgelt);

#if __cplusplus
};
#endif

struct SO {
    long off;
    USHORT isect;
    unsigned short pad;
};

#ifndef cbNil
#define cbNil   ((long)-1)
#endif
#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((USHORT)(-1))

#define pdbWrite                "w"
#define pdbRead                 "r"
#define pdbGetTiOnly            "i"
#define pdbGetRecordsOnly       "c"
#define pdbFullBuild            "f"
#define pdbTypeAppend           "a"
#define pdbRepro                "z"
#define pdbFSCompress           "C"

#endif // __PDB_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\sym7\inc\vcver.h ===
#ifndef _VC_VER_INC
#define _VC_VER_INC
#ifndef _VC_VER
#define _VC_VER 550
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\bldrbld\bldrbld.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    bldrbld.c

Abstract:

    This module implements a utility program to combine the 16-bit boot loader
    and the 32-bit boot loader into a single loader image.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <bldr.h>

ULONG
xxxLdrRelocateImage (
    IN PVOID ImageToRelocate,
    IN PVOID LoadAddress,
    IN PUCHAR LoaderName,
    IN ULONG Success,
    IN ULONG Conflict,
    IN ULONG Invalid
    );

VOID
ReadFileIntoMemory(
    LPCSTR lpFileName,
    LPVOID *ppvFileContents,
    DWORD *pdwFileSize
    )
{
    HANDLE hFile;
    DWORD dwBytesRead;

    hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "BLDRBLD: error: unable to open %s\n", lpFileName);
        exit(1);
    }

    *pdwFileSize = GetFileSize(hFile, NULL);
    *ppvFileContents = LocalAlloc(LMEM_FIXED, *pdwFileSize);

    if (*ppvFileContents == NULL) {
        fprintf(stderr, "BLDRBLD: error: cannot allocate buffer for %s\n", lpFileName);
        exit(1);
    }

    if (!ReadFile(hFile, *ppvFileContents, *pdwFileSize, &dwBytesRead, NULL) ||
        (dwBytesRead != *pdwFileSize)) {
        fprintf(stderr, "BLDRBLD: error: cannot read from %s\n", lpFileName);
        exit(1);
    }

    CloseHandle(hFile);
}


typedef struct _BOOTLDRPARAM {
    DWORD Bldr32EntryPoint;
    CHAR  CommandLine[64];
} BOOTLDRPARAM, *PBOOTLDRPARAM;


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    LPVOID Bldr32FileContents;
    DWORD Bldr32FileSize;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG Bldr32BootBaseAddress;
    ULONG Bldr32BaseAddress;
    NTSTATUS status;
    ULONG Bldr32EntryPoint;
    HANDLE hOutputFile;
    DWORD dwBytesWritten;
    BOOL fPreloader = FALSE;

    BOOTLDRPARAM BootLdrParam;
    DWORD PreloaderPreface[4];
    DWORD cbParams;

    //
    // Look for -p to see if we're doing the preloader
    //
    if(argc >= 2 && 0 == _stricmp(argv[1], "-p")) {
        --argc;
        ++argv;
        fPreloader = TRUE;
    }

    //
    // Verify that we have the correct number of command line arguments.
    //
    if (argc != 3) {
        fprintf(stderr, "BLDRBLD: error: invalid command line\n");
        exit(1);
    }

    //
    // Read the input boot loader images into memory.
    //

    ReadFileIntoMemory(argv[1], &Bldr32FileContents, &Bldr32FileSize);

    //
    // Go find the NT header.
    //

    NtHeader = RtlImageNtHeader(Bldr32FileContents);

    if (NtHeader == NULL) {
        fprintf(stderr, "BLDRBLD: error: corrupt 32-bit boot loader\n");
        exit(1);
    }

    //
    // Go find the .text section header.  For now, we assume this is the first
    // section in the image.
    //

    SectionHeader = IMAGE_FIRST_SECTION(NtHeader);

    if (strcmp(SectionHeader->Name, ".text") != 0) {
        fprintf(stderr, "BLDRBLD: error: .text section isn't first section\n");
        exit(1);
    }

    //
    // Compute the base address for the 32-bit boot loader:
    //    Bldr32EntryPoint (4 bytes)
    //    ROMImagePhysicalAddress (4 bytes)
    //    CommandLine (80 bytes)
    //    .text section

    if(fPreloader) {
        Bldr32BootBaseAddress = 0 - ROM_DEC_SIZE - PRELDR_BLOCK_SIZE + 16;
        Bldr32BaseAddress = Bldr32BootBaseAddress;
    } else {
        Bldr32BootBaseAddress = BLDR_BOOT_ORIGIN + sizeof(BootLdrParam);
        Bldr32BaseAddress = BLDR_RELOCATED_ORIGIN + sizeof(BootLdrParam);
    }
    Bldr32BootBaseAddress -= SectionHeader->VirtualAddress;
    Bldr32BaseAddress -= SectionHeader->VirtualAddress;

    //
    // Relocate the 32-bit boot loader.
    //

    printf("BLDRBLD: Relocating to %08x\n", Bldr32BaseAddress);

    __try {
        status = (NTSTATUS)xxxLdrRelocateImage((PVOID)Bldr32FileContents,
            (PVOID)Bldr32BaseAddress, "BLDRBLD", (ULONG)STATUS_SUCCESS,
            (ULONG)STATUS_CONFLICTING_ADDRESSES, (ULONG)STATUS_INVALID_IMAGE_FORMAT);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "BLDRBLD: error: error %08x while relocating 32-bit image\n",
            status);
        exit(1);
    }

    //
    // Fixup the 16-bit boot loader with the entry point of the 32-bit boot
    // loader.  This needs to be relative to BLDR_BOOT_ORIGIN since at the point
    // this is invoked, the image hasn't been relocated to BLDR_RELOCATED_ORIGIN.
    //

    Bldr32EntryPoint = Bldr32BootBaseAddress +
        NtHeader->OptionalHeader.AddressOfEntryPoint;

    printf("BLDRBLD: Entry point=%08x\n", Bldr32EntryPoint);

    //
    // Create the output file.
    //

    hOutputFile = CreateFile(argv[2], GENERIC_WRITE, FILE_SHARE_READ, NULL,
        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hOutputFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "BLDRBLD: error: cannot write to %s\n", argv[2]);
        exit(1);
    }

    //
    // Write out boot loader parameters
    //
    if(fPreloader) {
        memset(PreloaderPreface, 0, sizeof PreloaderPreface);
        // Start with a 32-bit-rel JMP instruction
        PreloaderPreface[0] = ((Bldr32EntryPoint -
            (0xFFFFFE00 - PRELDR_BLOCK_SIZE) - 5) << 8) | 0xE9;
        // Fetch the SHA function block pointer from the DWORD before the
        // entry point and insert it at an 8-byte offset
        PreloaderPreface[2] = ((PULONG)((PUCHAR)Bldr32FileContents +
            Bldr32EntryPoint - Bldr32BaseAddress))[-1];
        // Fetch the public key pointer from the 2 DWORDs before the
        // entry point and insert it at a 12-byte offset
        PreloaderPreface[3] = ((PULONG)((PUCHAR)Bldr32FileContents +
            Bldr32EntryPoint - Bldr32BaseAddress))[-2];
        if (!WriteFile(hOutputFile, PreloaderPreface, sizeof(PreloaderPreface),
            &dwBytesWritten, NULL) || (sizeof(PreloaderPreface) !=
            dwBytesWritten))
        {
            fprintf(stderr, "BLDRBLD: error: cannot write to %s\n", argv[2]);
            exit(1);
        }
    } else {
        memset(&BootLdrParam, 0, sizeof(BootLdrParam));
        BootLdrParam.Bldr32EntryPoint = Bldr32EntryPoint;

        if (!WriteFile(hOutputFile, &BootLdrParam, sizeof(BootLdrParam),
            &dwBytesWritten, NULL) || (sizeof(BootLdrParam) != dwBytesWritten))
        {
            fprintf(stderr, "BLDRBLD: error: cannot write to %s\n", argv[2]);
            exit(1);
        }
    }

    //
    // Write out the 32-bit boot loader's .text section.
    //

    if (!WriteFile(hOutputFile, (PUCHAR)Bldr32FileContents +
        SectionHeader->PointerToRawData, SectionHeader->SizeOfRawData,
        &dwBytesWritten, NULL) || (SectionHeader->SizeOfRawData != dwBytesWritten)) {
        fprintf(stderr, "BLDRBLD: error: cannot write to %s\n", argv[2]);
        exit(1);
    }

    CloseHandle(hOutputFile);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\sym7\sym7.cpp ===
/*

    sym7.cpp  - Pdb symbol extractor including BBT OMAP translation and
                layout of common PE structures.  Primarily designed for
                MS patch engine, but can also be used to examine image
                layout since the output representation is fully expanded
                flat text.

    Author: Tom McGuire (tommcg)

    Original version written November-December 2000.

    Copyright (C) Microsoft, 2000-2001.  All rights reserved.

*/


#pragma warning( disable: 4201 )    // nameless struct/union
#pragma warning( disable: 4214 )    // bitfields other than int

#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>

typedef unsigned __int64 QWORD;
typedef const BYTE * PCBYTE;

#include <vcver.h>
#include <pdb.h>
#include <cv.h>
#include <undname.h>

#include <delayimp.h>
#include <stdlib.h>
#include <stdio.h>

const unsigned PsymMajorVersion = 1;
const unsigned PsymMinorVersion = 1;


#ifndef ROUNDUP2
#define ROUNDUP2( x, n ) (((x) + ((n) - 1 )) & ~((n) - 1 ))
#endif

#ifndef MIN
#define MIN( a, b ) (((a)<(b))?(a):(b))
#endif

#ifndef MAX
#define MAX( a, b ) (((a)>(b))?(a):(b))
#endif

#ifndef countof
#define countof( array ) ( sizeof( array ) / sizeof( array[ 0 ] ))
#endif

#ifdef DEBUG

#define DEBUGCODE( x ) x
#define ASSERT( x ) ((x)?(1):AssertionFailure( #x, __FILE__, __LINE__ ))

void
__stdcall
AssertionFailure(
    const char *Expression,
    const char *SourceFile,
    unsigned    SourceLine
)
{
    fflush( stdout );
    fprintf( stderr, "SYM7: ASSERTION FAILED: %s (%u)\n%s\n", SourceFile, SourceLine, Expression );
    fflush( stderr );
    __debugbreak();
    exit( 1 );
}

#endif /* DEBUG */


#ifndef ASSERT
#define ASSERT( x )
#endif

#ifndef DEBUGCODE
#define DEBUGCODE( x )
#endif

#include "nametable.h"

#include "md5.c"


PVOID
MapViewOfFileReadOnly(
    IN  LPCSTR FileName,
    OUT ULONG *FileSize
    );



struct OMAP
{
    ULONG Rva1;
    ULONG Rva2;
};


struct SYMNODE
{
    ULONG     RvaInImg;
    ULONG     RvaOrig;
    ULONG     SymSize;
    WORD      SymType;
    WORD      SymSort;
    NAMENODE* SymNameId;
    NAMENODE* OrgNameId;
    SYMNODE*  ParentSym;
    SYMNODE*  FirstChild;
    SYMNODE*  NextSibling;
};


VOID
__fastcall
QsortSymTableByRvaInImg(
    SYMNODE** LowerBound,
    SYMNODE** UpperBound
    );

VOID
__fastcall
QsortSymTableByRvaInSrc(
    SYMNODE** LowerBound,
    SYMNODE** UpperBound
    );

unsigned
__fastcall
FirstSrcSymTableIndexForRva(
    SYMNODE** SymTableSortedByOrig,
    ULONG     SymTableCount,
    ULONG     RvaInSrc
    );


#ifdef SYMCOUNTER

ULONG SymTypeCounter[ 0x4000 ];

#endif


class PdbSymbolHandler {

public:

    NAMETABLE   NameTable;

    SYMNODE**   PrimarySymTable;
    ULONG       PrimarySymTableCount;

    SYMNODE**   FragmentSymTable;
    ULONG       FragmentSymTableCount;
    ULONG       FragmentSymTableMax;

    #define     SymTableMax 0x400000        // 4 million entries, 16MB alloc

    PBYTE       ExeFileMapped;
    ULONG       ExeFileSize;

    PBYTE       ResourceBaseMapped;
    ULONG       ResourceBaseRva;
    SYMNODE*    ResourceRootSym;

    PIMAGE_NT_HEADERS     NtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG                 SectionCount;

    PDB*        pdb;                        // PDB handle
    DBI*        dbi;                        // DBI handle

    CVSEGMAP*   cvSegMap;
    ULONG       nSegMap;

    ULONG*      pImgSegToRvaMap;
    ULONG       nImgSegToRvaMap;

    ULONG*      pSrcSegToRvaMap;
    ULONG       nSrcSegToRvaMap;

    OMAP*       pOmapToSrc;                 // map from img address to symbol
    OMAP*       pOmapToImg;                 // map from symbol address to img

    ULONG       nOmapToSrc;                 // count of pOmapToSrc entries
    ULONG       nOmapToImg;                 // count of pOmapToImg entries

    BOOL        DbgOmap;
    BOOL        PdbOmap;

    BOOL        AnyExecutableSections;
    BOOL        AnyWritableSections;
    BOOL        AnyDebugDirectories;

    ULONG       CountOfModSyms;
    ULONG       CountOfPublics;
    ULONG       CountOfGlobals;

    ULONG       ExeTime;
    QWORD       ExeVersion;

    MD5_HASH    ExeFileMD5;
    MD5_HASH    DbgFileMD5;
    MD5_HASH    PdbFileMD5;

    ULONG       PdbFileSize;
    ULONG       PdbTime;

    ULONG       DbgFileSize;
    ULONG       DbgTime;

    ULONG       SymConfidence;              // 0..100
    ULONG       SymConfThreshold;
    ULONG       SymsMatched;
    ULONG       SymsUnmatch;
    ULONG       TranslationCount;
    DWORD*      TranslationArray;

    LPSTR       ExeName;                    // points to filename in ExePath
    LPSTR       PdbName;                    // points to filename in PdbPath
    LPSTR       DbgName;                    // points to filename in DbgPath
    LPSTR       DbgNameInExe;               // if not null, "dll\foo.dbg"

    CHAR        ExePath[ PDB_MAX_PATH ];
    CHAR        PdbPath[ PDB_MAX_PATH ];
    CHAR        DbgPath[ PDB_MAX_PATH ];

    CHAR        szNewSymName[ 16 ];

    BOOL OpenExe( LPCSTR ExeFile );
    BOOL OpenPdb( LPCSTR ExeFile, LPCSTR SymbolPath );
    BOOL LoadSymbols( ULONG ConfidenceThreshold = 50  );

    ULONG TranslateOmapFromSrcToImg( ULONG Rva );
    ULONG TranslateOmapFromImgToSrc( ULONG Rva );

    PdbSymbolHandler()
    {
        ExeFileMapped   = NULL;
        ExeFileSize     = 0;
        ResourceBaseMapped = NULL;
        ResourceBaseRva = 0;
        ResourceRootSym = NULL;
        PrimarySymTable = NULL;
        PrimarySymTableCount = 0;
        FragmentSymTable = NULL;
        FragmentSymTableCount = 0;
        FragmentSymTableMax = 0;
        pdb             = NULL;
        dbi             = NULL;
        cvSegMap        = NULL;
        nSegMap         = 0;
        pImgSegToRvaMap = NULL;
        nImgSegToRvaMap = 0;
        pSrcSegToRvaMap = NULL;
        nSrcSegToRvaMap = 0;
        pOmapToSrc      = NULL;
        pOmapToImg      = NULL;
        nOmapToSrc      = 0;
        nOmapToImg      = 0;
        DbgOmap         = FALSE;
        PdbOmap         = FALSE;
        AnyExecutableSections = FALSE;
        AnyWritableSections   = FALSE;
        AnyDebugDirectories   = FALSE;
        CountOfModSyms  = 0;
        CountOfPublics  = 0;
        CountOfGlobals  = 0;
        ExeTime         = 0;
        ExeVersion      = 0;
        ExeFileMD5.Word32[ 0 ] = 0;
        PdbFileMD5.Word32[ 0 ] = 0;
        DbgFileMD5.Word32[ 0 ] = 0;
        PdbTime         = 0;
        PdbFileSize     = 0;
        DbgTime         = 0;
        DbgFileSize     = 0;
        TranslationCount = 0;
        TranslationArray = NULL;
        ExeName         = NULL;
        PdbName         = NULL;
        DbgName         = NULL;
        DbgNameInExe    = NULL;
        *ExePath        = 0;
        *PdbPath        = 0;
        *DbgPath        = 0;
        RootPublicSym   = NULL;
        RootGlobalSym   = NULL;
        RootModuleSym   = NULL;
        RootPeSym       = NULL;
        SymConfidence   = 0;
        SymConfThreshold = 0;
        SymsMatched = 0;
        SymsUnmatch = 0;

    };

#ifdef DONTCOMPILE  // BUGBUG: Lot of stuff to tear down not implemented here

   ~PdbSymbolHandler()
    {
        //
        //  BUGBUG: Incomplete.
        //

        delete cvSegMap;

        if ( dbi )
        {
            dbi->Close();
        }

        if ( pdb )
        {
            pdb->Close();
        }

        if ( PrimarySymTable )
        {
            VirtualFree( PrimarySymTable, 0, MEM_RELEASE );
        }

        if ( ExeFileMapped )
        {
            UnmapViewOfFile( ExeFileMapped );
        }

        if ( TranslationArray )
        {
            delete TranslationArray;
        }

    };

#endif

    ULONG BuildScopedSymbolName( LPSTR Buffer, SYMNODE* Sym )
    {
        if ( Sym )
        {
            ULONG Offset = BuildScopedSymbolName( Buffer, Sym->ParentSym );

            memcpy( Buffer + Offset, Sym->SymNameId->Name, Sym->SymNameId->Length );
            Offset += Sym->SymNameId->Length;
            Buffer[ Offset++ ] = '\\';
            Buffer[ Offset ] = 0;

            return Offset;
        }

        return 0;
    }


    VOID DumpSym( SYMNODE* SymNode )
    {
        CHAR szParentName[ 1024 ];

        *szParentName = 0;

        BuildScopedSymbolName( szParentName, SymNode->ParentSym );

        printf(
            "%06X (orig=%06X) (size=%4u) (type=%04X) %s%s\n",
            SymNode->RvaInImg,
            SymNode->RvaOrig,
            SymNode->SymSize,
            SymNode->SymType,
            szParentName,
            SymNode->SymNameId->Name
            );
    }


    VOID DumpSyms( VOID )
    {
        printf( "Symbols (%u):\n", PrimarySymTableCount );

        for ( unsigned i = 0; i < PrimarySymTableCount; i++ )
        {
            DumpSym( PrimarySymTable[ i ] );
        }

        printf( "\n" );

    }


    VOID DumpOmapToImg( VOID )
    {
        printf( "\nOmapToImg:\n" );

        for ( unsigned i = 0; i < nOmapToImg; i++ )
        {
            printf(
                "%08X %08X\n",
                pOmapToImg[ i ].Rva1,
                pOmapToImg[ i ].Rva2
                );
        }

        printf( "\n" );
    }


    VOID DumpOmapToSrc( VOID )
    {
        printf( "\nOmapToSrc:\n" );

        for ( unsigned i = 0; i < nOmapToSrc; i++ )
        {
            printf(
                "%08X %08X\n",
                pOmapToSrc[ i ].Rva1,
                pOmapToSrc[ i ].Rva2
                );
        }

        printf( "\n" );
    }



//private:

    VOID MyGetFileVersionInfo( void );
    BOOL LoadOmapFromDbg( void );
    BOOL ValidateOmap( void );
    VOID LoadModuleSymbols( void );
    VOID LoadImageDerivedSymbols( void );
    ULONG __fastcall ImageRvaToFileOffset( ULONG RvaInImg );
    PVOID __fastcall ImageRvaToMappedAddress( ULONG RvaInImg );
    VOID __fastcall ProcessCvSym( CVSYM* pcvsym );
    VOID BubbleSortPrimarySymTable( void );
    SYMNODE*      CreateSymbol( SYMNODE* ParentSym, LPCSTR SymName, ULONG SymSort, ULONG SymType, ULONG SymSize, ULONG RvaInImg, ULONG RvaOrig );
    SYMNODE*  AddPrimarySymbol( SYMNODE* ParentSym, LPCSTR SymName, ULONG SymSort, ULONG SymType, ULONG SymSize, ULONG RvaInImg, ULONG RvaOrig );
    SYMNODE*  AddPrimarySymbol( SYMNODE* ParentSym, LPCSTR SymName, ULONG SymSort, ULONG SymType, ULONG SymSize, ULONG RvaInImg );
    SYMNODE* AddFragmentSymbol( SYMNODE* ParentSym, LPCSTR SymName, ULONG SymSort, ULONG SymType, ULONG SymSize, ULONG RvaInImg, ULONG RvaOrig );

    VOID
    __fastcall
    LoadResourceSymsRecursive(
        IN PIMAGE_RESOURCE_DIRECTORY ResourceDir,
        IN SYMNODE* ParentSym,
        IN LPSTR    pszBuffer
        );

    VOID
    __fastcall
    ConvertDollarSymbols(
        SYMNODE* ParentSym
        );

    VOID
    DetermineSymbolConfidence(
        VOID
        );


    SYMNODE* NestedScopeParentSym;

    SYMNODE* RootPublicSym;
    SYMNODE* RootGlobalSym;
    SYMNODE* RootModuleSym;
    SYMNODE* RootPeSym;

};


VOID PdbSymbolHandler::MyGetFileVersionInfo( void )
{
    DWORD Blah;
    DWORD Size = GetFileVersionInfoSize( ExePath, &Blah );

    if ( Size )
    {
        PBYTE Buffer = new BYTE[ Size ];

        if ( Buffer )
        {
            if ( GetFileVersionInfo( ExePath, 0, Size, Buffer ))
            {
                VS_FIXEDFILEINFO* VersionInfo;

                if ( VerQueryValue( Buffer, "\\", (PVOID*)&VersionInfo, (PUINT)&Blah ))
                {
                    ExeVersion = ((((QWORD) VersionInfo->dwFileVersionMS ) << 32 ) |
                                   ((QWORD) VersionInfo->dwFileVersionLS ));
                }

                DWORD* Translation;

                if ( VerQueryValue( Buffer, "\\VarFileInfo\\Translation", (PVOID*)&Translation, (PUINT)&Size ))
                {
                    TranslationCount = ( Size / sizeof( DWORD ));
                    TranslationArray = new DWORD[ TranslationCount ];

                    memcpy( TranslationArray, Translation, TranslationCount * sizeof( DWORD ));
                }
            }

            delete Buffer;
        }
    }

}


BOOL
PdbSymbolHandler::OpenExe(
    LPCSTR ExeFile
    )
{
    GetFullPathName( ExeFile, PDB_MAX_PATH, ExePath, &ExeName );

    ExeFileMapped = (PBYTE) MapViewOfFileReadOnly( ExeFile, &ExeFileSize );

    if ( ExeFileMapped == NULL )
    {
        SetLastError( ERROR_FILE_NOT_FOUND );
        return FALSE;
    }

    BOOL Success = FALSE;

    __try
    {
        PIMAGE_DOS_HEADER DosHeader;

        DosHeader = (PIMAGE_DOS_HEADER) ExeFileMapped;
        NtHeader  = (PIMAGE_NT_HEADERS) ExeFileMapped;

        if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE )
        {
            NtHeader = (PIMAGE_NT_HEADERS)( ExeFileMapped + DosHeader->e_lfanew );
        }

        if ( NtHeader->Signature != IMAGE_NT_SIGNATURE )
        {
            __leave;
        }

        ExeTime          = NtHeader->FileHeader.TimeDateStamp;
        SectionHeader    = IMAGE_FIRST_SECTION( NtHeader );
        SectionCount     = NtHeader->FileHeader.NumberOfSections;
        nImgSegToRvaMap  = SectionCount;
        pImgSegToRvaMap  = new ULONG[ nImgSegToRvaMap ];

        for ( unsigned i = 0; i < SectionCount; i++ )
        {
            pImgSegToRvaMap[ i ] = SectionHeader[ i ].VirtualAddress;

            if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE )
            {
                AnyExecutableSections = TRUE;
            }

            if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_WRITE )
            {
                AnyWritableSections = TRUE;
            }
        }

        __try
        {

            ULONG DebugDirectoryRva   = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_DEBUG ].VirtualAddress;
            ULONG DebugDirectorySize  = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_DEBUG ].Size;
            ULONG DebugDirectoryCount = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

            if (( DebugDirectoryRva ) && ( DebugDirectoryCount )) {

                AnyDebugDirectories = TRUE;

                for ( unsigned i = 0; i < SectionCount; i++ )
                {
                    if (( DebugDirectoryRva >= SectionHeader[ i ].VirtualAddress ) &&
                        ( DebugDirectoryRva <  SectionHeader[ i ].VirtualAddress + SectionHeader[ i ].SizeOfRawData ))
                    {
                        ULONG OffsetInSection = DebugDirectoryRva - SectionHeader[ i ].VirtualAddress;

                        PIMAGE_DEBUG_DIRECTORY DebugDirectory;

                        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
                                         ( ExeFileMapped
                                           + SectionHeader[ i ].PointerToRawData
                                           + OffsetInSection
                                         );

                        for ( unsigned j = 0; j < DebugDirectoryCount; j++ )
                        {
                            if ( DebugDirectory[ j ].Type == IMAGE_DEBUG_TYPE_MISC )
                            {
                                PIMAGE_DEBUG_MISC DebugMiscData = (PIMAGE_DEBUG_MISC)( ExeFileMapped + DebugDirectory[ j ].PointerToRawData );

                                if ( DebugMiscData->DataType == IMAGE_DEBUG_MISC_EXENAME )
                                {
                                    if ( ! DebugMiscData->Unicode )
                                    {
                                        DbgNameInExe = _strdup( (LPCSTR) DebugMiscData->Data );

                                        if ( DbgNameInExe )
                                        {
                                            _strlwr( DbgNameInExe );
                                        }

                                        break;
                                    }
                                }
                            }
                        }

                        break;
                    }
                }
            }
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) {}

        MyGetFileVersionInfo();

        ComputeCompleteMD5( ExeFileMapped, ExeFileSize, &ExeFileMD5 );

        Success = TRUE;
    }

    __except( EXCEPTION_EXECUTE_HANDLER ) {}

    if ( ! Success )
    {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        return FALSE;
    }

    return TRUE;
}


BOOL
PdbSymbolHandler::OpenPdb(
    LPCSTR ExeFile,
    LPCSTR SymbolPath
    )
{
    CHAR TmpPath[ PDB_MAX_PATH ];
    CHAR ErrText[ cbErrMax ];

    *TmpPath = 0;
    *ErrText = 0;

    EC ec = 0;

    BOOL Success = PDBOpenValidate3(
                      ExeFile,
                      SymbolPath,
                      &ec,
                      ErrText,
                      TmpPath,
                      NULL,
                      NULL,
                      &pdb
                      );

    if ( ! Success )
    {
        SetLastError( ERROR_FILE_NOT_FOUND );
        return FALSE;
    }

    if ( *TmpPath )
    {
        GetFullPathName( TmpPath, PDB_MAX_PATH, DbgPath, &DbgName );
    }

    pdb->QueryPDBName( TmpPath );
    GetFullPathName( TmpPath, PDB_MAX_PATH, PdbPath, &PdbName );

    PdbFileSize = 0;

    PBYTE PdbFileMapped = (PBYTE) MapViewOfFileReadOnly( PdbPath, &PdbFileSize );

    if ( PdbFileMapped )
    {
        __try
        {
            ComputeCompleteMD5( PdbFileMapped, PdbFileSize, &PdbFileMD5 );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            ZeroMemory( &PdbFileMD5, sizeof( PdbFileMD5 ));
        }

        UnmapViewOfFile( PdbFileMapped );
    }

    PdbTime = pdb->QuerySignature();    // BUGBUG: assuming this is timestamp

    Success = pdb->OpenDBI( NULL, pdbRead, &dbi );

    if ( ! Success )
    {
        SetLastError( ERROR_OPEN_FAILED );
        return FALSE;
    }

    Dbg* dbg;

    if ( dbi->OpenDbg( dbgtypeOmapToSrc, &dbg ))
    {
        nOmapToSrc = dbg->QuerySize();

        if ( nOmapToSrc )
        {
            pOmapToSrc = new OMAP[ nOmapToSrc ];
            dbg->QueryNext( nOmapToSrc, pOmapToSrc );
        }

        dbg->Close();
    }

    if ( dbi->OpenDbg( dbgtypeOmapFromSrc, &dbg ))
    {
        nOmapToImg = dbg->QuerySize();

        if ( nOmapToImg )
        {
            pOmapToImg = new OMAP[ nOmapToImg ];
            dbg->QueryNext( nOmapToImg, pOmapToImg );
        }

        dbg->Close();
    }

    PdbOmap = nOmapToSrc || nOmapToImg;

    if ((( nOmapToSrc == 0 ) || ( nOmapToImg == 0 )) && ( *DbgPath != 0 ))
    {
        //
        //  No OMAP in .pdb, attempt to find OMAP in .dbg
        //

        LoadOmapFromDbg();
    }

    if ( nOmapToImg != 0 )
    {
        //
        //  Need original section map.  The original section headers might
        //  be in the .pdb as dbgtypeSectionHdrOrig, otherwise reconstruct
        //  from QuerySecMap section sizes and section alignment.
        //

        if ( dbi->OpenDbg( dbgtypeSectionHdrOrig, &dbg ))
        {
            ULONG nSrcSectHdr = dbg->QuerySize();

            if ( nSrcSectHdr != 0 )
            {
                PIMAGE_SECTION_HEADER pSrcSectHdr = new IMAGE_SECTION_HEADER[ nSrcSectHdr ];

                pSrcSegToRvaMap = new ULONG[ nSrcSectHdr ];
                nSrcSegToRvaMap = nSrcSectHdr;

                dbg->QueryNext( nSrcSectHdr, pSrcSectHdr );

                for ( unsigned i = 0; i < nSrcSectHdr; i++ )
                {
                    pSrcSegToRvaMap[ i ] = pSrcSectHdr[ i ].VirtualAddress;
                }

                DEBUGCODE( printf( "Loaded dbgtypeSectionHdrOrig from .pdb (%u sections)\n", nSrcSectHdr ));
            }

            dbg->Close();
        }

        if ( nSrcSegToRvaMap == 0 )
        {
            //
            //  Must reconstruct original segment addresses.
            //

            long cbSegMap = 0;

            dbi->QuerySecMap( NULL, &cbSegMap );

            ASSERT( cbSegMap != 0 );

            if ( cbSegMap != 0 )
            {
                CVSEGMAP* cvSegMap = (CVSEGMAP*) new BYTE[ cbSegMap ];

                dbi->QuerySecMap( (PBYTE) cvSegMap, &cbSegMap );

                ULONG nSegMap = ( cbSegMap - sizeof( DWORD )) / sizeof( CVSEG );

                pSrcSegToRvaMap = new ULONG[ nSegMap ];

                ULONG RvaOfNextSection = pOmapToImg[ 0 ].Rva1;

                ASSERT( NtHeader->OptionalHeader.SectionAlignment != 0 );
                ASSERT(( NtHeader->OptionalHeader.SectionAlignment & ( NtHeader->OptionalHeader.SectionAlignment - 1 )) == 0 );
                ASSERT(( RvaOfNextSection & ( NtHeader->OptionalHeader.SectionAlignment - 1 )) == 0 );

                for ( nSrcSegToRvaMap = 0; nSrcSegToRvaMap < nSegMap; nSrcSegToRvaMap++ )
                {
                    if ( cvSegMap->rgcvseg[ nSrcSegToRvaMap ].wFlags.fAbs )
                    {
                        break;
                    }

                    ASSERT( cvSegMap->rgcvseg[ nSrcSegToRvaMap ].isegPhysical == nSrcSegToRvaMap + 1 );
                    ASSERT( cvSegMap->rgcvseg[ nSrcSegToRvaMap ].ib == 0 );

                    pSrcSegToRvaMap[ nSrcSegToRvaMap ] = RvaOfNextSection;

                    RvaOfNextSection += ROUNDUP2( cvSegMap->rgcvseg[ nSrcSegToRvaMap ].cb, NtHeader->OptionalHeader.SectionAlignment );
                }
            }
        }
    }

    if ( nSrcSegToRvaMap == 0 )
    {
        nSrcSegToRvaMap = nImgSegToRvaMap;
        pSrcSegToRvaMap = pImgSegToRvaMap;
    }

    ValidateOmap();

    return TRUE;
}


BOOL
PdbSymbolHandler::LoadOmapFromDbg( void )
{
    PBYTE DbgFileMapped = (PBYTE) MapViewOfFileReadOnly( DbgPath, &DbgFileSize );
    BOOL  Success = FALSE;

    __try {

        PIMAGE_SEPARATE_DEBUG_HEADER DebugFileHeader;
        PIMAGE_DEBUG_DIRECTORY       DebugDirectory;
        ULONG                        DebugDirectoryCount;

        DebugFileHeader = (PIMAGE_SEPARATE_DEBUG_HEADER) DbgFileMapped;

        if ( DebugFileHeader->Signature != IMAGE_SEPARATE_DEBUG_SIGNATURE ) {
            __leave;
            }

        DbgTime = DebugFileHeader->TimeDateStamp;

        __try
        {
            ComputeCompleteMD5( DbgFileMapped, DbgFileSize, &DbgFileMD5 );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            ZeroMemory( &DbgFileMD5, sizeof( DbgFileMD5 ));
        }

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)(
                            DbgFileMapped
                              + sizeof( IMAGE_SEPARATE_DEBUG_HEADER )
                              + DebugFileHeader->NumberOfSections * sizeof( IMAGE_SECTION_HEADER )
                              + DebugFileHeader->ExportedNamesSize
                            );

        DebugDirectoryCount = DebugFileHeader->DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

        while ( DebugDirectoryCount-- ) {

            switch ( DebugDirectory->Type )
            {
                case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:

                    Success = TRUE;
                    DbgOmap = TRUE;

                    PBYTE p = new BYTE[ DebugDirectory->SizeOfData ];
                    ULONG n = DebugDirectory->SizeOfData / sizeof( OMAP );

                    CopyMemory(
                        p,
                        DebugDirectory->PointerToRawData + DbgFileMapped,
                        DebugDirectory->SizeOfData
                        );

                    if ( DebugDirectory->Type == IMAGE_DEBUG_TYPE_OMAP_TO_SRC )
                    {
                        pOmapToSrc = (OMAP*)p;
                        nOmapToSrc = n;
                    }
                    else
                    {
                        pOmapToImg = (OMAP*)p;
                        nOmapToImg = n;
                    }
            }

            DebugDirectory++;
        }
    }

    __except( EXCEPTION_EXECUTE_HANDLER ) {}

    UnmapViewOfFile( DbgFileMapped );

    return Success;
}


PVOID
MapViewOfFileReadOnly(
    IN  LPCSTR FileName,
    OUT ULONG *FileSize
    )
{
    HANDLE FileHandle;
    HANDLE MapHandle;
    PVOID  MapBase = NULL;
    ULONG  LocalSize = 0;

    FileHandle = CreateFile(
                     FileName,
                     GENERIC_READ,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     FILE_FLAG_RANDOM_ACCESS,
                     NULL
                     );

    if ( FileHandle != INVALID_HANDLE_VALUE )
    {

        LocalSize = GetFileSize( FileHandle, NULL );

        MapHandle = CreateFileMapping(
                        FileHandle,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

        CloseHandle( FileHandle );

        if ( MapHandle != NULL )
        {
            MapBase = MapViewOfFile(
                          MapHandle,
                          FILE_MAP_READ,
                          0,
                          0,
                          0
                          );

            CloseHandle( MapHandle );
        }
    }

    if (( MapBase ) && ( FileSize ))
    {
        *FileSize = LocalSize;
    }

    return MapBase;
}


BOOL
PdbSymbolHandler::LoadSymbols(
    ULONG ConfidenceThreshold
    )
{
    SymConfThreshold = ConfidenceThreshold;

    ASSERT( PrimarySymTable == NULL );

    PrimarySymTable = (SYMNODE**) VirtualAlloc(
                                      NULL,
                                      SymTableMax * sizeof( PVOID ),   // 4MB!!!
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                      );

    if ( PrimarySymTable == NULL )
    {
        return FALSE;
    }

    LoadImageDerivedSymbols();

    SymConfidence = 100;

    if ( dbi )
    {

        ULONG StartingCount;
        GSI* gsi;

        if ( dbi->OpenPublics( &gsi ))
        {
            RootPublicSym = CreateSymbol( NULL, "Public", 2000, 0, 0, 0, 0 );

            NestedScopeParentSym = RootPublicSym;

            StartingCount = PrimarySymTableCount;

            PBYTE pbSym = NULL;

            while (( pbSym = gsi->NextSym( pbSym )) != NULL )
            {
                ProcessCvSym( (CVSYM*) pbSym );
            }

            gsi->Close();

            CountOfPublics = PrimarySymTableCount - StartingCount;
        }

        if ( dbi->OpenGlobals( &gsi ))
        {
            RootGlobalSym = CreateSymbol( NULL, "Global", 3000, 0, 0, 0, 0 );

            NestedScopeParentSym = RootGlobalSym;

            StartingCount = PrimarySymTableCount;

            PBYTE pbSym = NULL;

            while (( pbSym = gsi->NextSym( pbSym )) != NULL )
            {
                ProcessCvSym( (CVSYM*) pbSym );
            }

            gsi->Close();

            CountOfGlobals = PrimarySymTableCount - StartingCount;
        }

        RootModuleSym = CreateSymbol( NULL, "Module", 4000, 0, 0, 0, 0 );

        NestedScopeParentSym = RootModuleSym;

        StartingCount = PrimarySymTableCount;

        LoadModuleSymbols();

        CountOfModSyms = PrimarySymTableCount - StartingCount;

        //
        //  Now that we have pdb basic symbols and image derived symbols loaded,
        //  we can compare import and export names to their pdb symbol names
        //  to determine if the symbol names appear to match.
        //

        DetermineSymbolConfidence();

        if ( SymConfidence < SymConfThreshold )
        {
            fprintf( stderr, "SYM7: Symbol confidence failure (%u%%)\n", SymConfidence );
            return FALSE;
        }

        if ( SymConfidence < 50 )
        {
            fprintf( stderr, "SYM7: Warning: symbol confidence only %u%%\n", SymConfidence );
        }

        //
        //  Special consideration for $-prefixed symbols here with respect to
        //  symbols use for patching.  Since the compiler generates $xxx labels
        //  at compile time that are not symbolic with respect to source, they
        //  can actually cause the patch matcher to match the wrong things since
        //  the same $-symbol can reference different things in two different
        //  versions of same binary.  The problem is that the $E and $L symbols
        //  have globally incremental values as part of the label.  We've asked
        //  the compiler team to produce "real" symbols for these, but in the
        //  meantime we convert $Exxx symbols to $EE_yyy where yyy is a counter
        //  based on the parent scope symbol.  This will hopefully match up the
        //  $E and $L symbols for modules where no new $E or $L symbols have been
        //  introduced or deleted, but will cause the matches to be wrong when
        //  new $E or $L symbols have been introduced or deleted.
        //
        //  Now we want to convert symbols named $L12345 to $LL_1 etc within each
        //  parent symbol scope ascending by original RVA.
        //

        ConvertDollarSymbols( RootGlobalSym );
        ConvertDollarSymbols( RootModuleSym );

        if ( nOmapToSrc )
        {
            //
            //  Create symbols for separated BBT fragments.
            //
            //  Both the pOmapToSrc and SymTable are sorted by image RVA ascending,
            //  but we want to be careful to stop at the end of the original sym
            //  table "primary" entries so we don't attempt to name fragments as
            //  children of other fragments.
            //

            FragmentSymTable = PrimarySymTable + PrimarySymTableCount;
            FragmentSymTableCount = 0;
            FragmentSymTableMax = SymTableMax - PrimarySymTableCount;

            //
            //  Need primary sym table sorted by original address at this point
            //  so we can lookup symbols by original address.  We don't need to
            //  fine-tune bubble-sort the names within matching RVAs for these
            //  lookups.
            //

            ASSERT( PrimarySymTableCount > 1 );

            QsortSymTableByRvaInSrc(
                &PrimarySymTable[ 0 ],
                &PrimarySymTable[ PrimarySymTableCount - 1 ]
                );

            for ( unsigned i = 0; i < nOmapToSrc; i++ )
            {
                ULONG RvaInImg = pOmapToSrc[ i ].Rva1;
                ULONG RvaInSrc = pOmapToSrc[ i ].Rva2;

                if (( RvaInImg != 0 ) && ( RvaInSrc != 0 ))
                {
                    unsigned TableIndex = FirstSrcSymTableIndexForRva(
                                              PrimarySymTable,
                                              PrimarySymTableCount,
                                              RvaInSrc
                                              );

                    while ( TableIndex < PrimarySymTableCount ) {

                        SYMNODE* SymNode = PrimarySymTable[ TableIndex++ ];

                        if ( SymNode->RvaOrig >= RvaInSrc )
                        {
                            break;
                        }

                        if (( SymNode->RvaInImg != 0 ) &&
                            ( SymNode->SymType & 0xFF00 ) != 0xAA00 )
                        {
                            int SrcOffset = RvaInSrc - SymNode->RvaOrig;

                            ASSERT( SrcOffset > 0 );

                            if ( SrcOffset > 0 )
                            {
                                CHAR szSymNameExtension[ 16 ];

                                sprintf( szSymNameExtension, "$BB+%u", SrcOffset );

                                AddFragmentSymbol( SymNode, szSymNameExtension, 0, 0xBB01, 0, RvaInImg, RvaInSrc );
                            }
                        }
                    }
                }
            }

            //
            //  Now we can combine the fragment symbols into the primary sym table.
            //

            PrimarySymTableCount += FragmentSymTableCount;

            FragmentSymTable = NULL;

        }
    }

    //
    //  Now sort the sym table by image RVA ascending.  We use quick sort on
    //  the RVAs, then we go back with bubble sort for the names within each
    //  equivalent RVA.
    //

    ASSERT( PrimarySymTableCount > 1 );

    QsortSymTableByRvaInImg(
        &PrimarySymTable[ 0 ],
        &PrimarySymTable[ PrimarySymTableCount - 1 ]
        );

    BubbleSortPrimarySymTable();

    //
    //  BUGBUG:  Delete consequtive duplicates.
    //

    return TRUE;
}


ULONG
__fastcall
PdbSymbolHandler::ImageRvaToFileOffset( ULONG RvaInImg )
{
    if ( RvaInImg < NtHeader->OptionalHeader.SizeOfHeaders )
    {
        return RvaInImg;
    }

    for ( unsigned i = 0; i < SectionCount; i++ )
    {
        if ( RvaInImg >= SectionHeader[ i ].VirtualAddress )
        {
            ULONG OffsetInSection = RvaInImg - SectionHeader[ i ].VirtualAddress;
            ULONG SectionFileSize = ROUNDUP2( SectionHeader[ i ].SizeOfRawData, NtHeader->OptionalHeader.FileAlignment );

            if ( OffsetInSection < SectionFileSize )
            {
                return SectionHeader[ i ].PointerToRawData + OffsetInSection;
            }
        }
    }

    return 0;
}


PVOID
__fastcall
PdbSymbolHandler::ImageRvaToMappedAddress( ULONG RvaInImg )
{
    ULONG MappedOffset = ImageRvaToFileOffset( RvaInImg );

    if (( MappedOffset != 0 ) && ( MappedOffset < ExeFileSize ))
    {
        return (PVOID)( ExeFileMapped + MappedOffset );
    }

    return NULL;
}



VOID PdbSymbolHandler::LoadImageDerivedSymbols( VOID )
{
    __try
    {
        CHAR szSymbolName[ 2048 ];

        ASSERT( NtHeader->Signature == IMAGE_NT_SIGNATURE );

        RootPeSym = CreateSymbol( NULL, "PE", 100, 0, 0, 0, 0 );

        SYMNODE* PeHeaderSym = AddPrimarySymbol(
                                   RootPeSym,
                                   "Header",
                                   0,
                                   0xAA01,
                                   NtHeader->OptionalHeader.SizeOfHeaders,
                                   0,
                                   0
                                   );

        AddPrimarySymbol(
            PeHeaderSym,
            "NT",
            0,
            0xAA02,
            0,
            (PBYTE)( NtHeader ) - ExeFileMapped,
            0
            );

        AddPrimarySymbol(
            RootPeSym,
            "End",
            0xFFFF,
            0xAAFF,
            0,
            NtHeader->OptionalHeader.SizeOfImage - 1,
            0
            );

        //
        //  Create symbols for start of each section.
        //
        //  NOTE: When matching symbols, these should be lower
        //        priority than "real" symbols because a "real"
        //        symbol at the start of a section could have
        //        moved for purposes of patch matching.
        //

        SYMNODE* RootSectionSym = CreateSymbol( RootPeSym, "Section", 100, 0, 0, 0, 0 );

        #define SECT_NAME_SIZE  sizeof( SectionHeader[ 0 ].Name )

        for ( unsigned i = 0; i < SectionCount; i++ )
        {
            memcpy( szSymbolName, SectionHeader[ i ].Name, SECT_NAME_SIZE );

            char *p = szSymbolName + SECT_NAME_SIZE;

            do
            {
                *p-- = 0;
            }
            while (( p >= szSymbolName ) && ( *p == ' ' ));

            AddPrimarySymbol(
                RootSectionSym,
                szSymbolName,
                i + 1,
                0xAA03,
                SectionHeader[ i ].Misc.VirtualSize,
                SectionHeader[ i ].VirtualAddress,
                0
                );
        }

        //
        //  Create symbols for location of each PE data directory.
        //

        const static char* DirectoryName[ 16 ] = {
            "Export",
            "Import",
            "Resource",
            "Exception",
            "Security",
            "Relocation",
            "Debug",
            "Architecture",
            "GlobalPtr",
            "TLS",
            "LoadConfig",
            "BoundImport",
            "IAT",
            "DelayImport",
            "COM",
            "15"
        };

        SYMNODE* DirectorySymNode[ 16 ];

        ZeroMemory( &DirectorySymNode, sizeof( DirectorySymNode ));

        SYMNODE* RootPeDirSym = CreateSymbol( RootPeSym, "Directory", 200, 0, 0, 0, 0 );

        unsigned nDirectories = NtHeader->OptionalHeader.NumberOfRvaAndSizes;

        if ( nDirectories > 16 )
        {
             nDirectories = 16;
        }

        for ( unsigned i = 0; i < nDirectories; i++ )
        {
            if ( NtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress )
            {
                DirectorySymNode[ i ] = AddPrimarySymbol(
                                            RootPeDirSym,
                                            DirectoryName[ i ],
                                            i + 1,
                                            0xAA04,
                                            NtHeader->OptionalHeader.DataDirectory[ i ].Size,
                                            NtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress
                                            );
            }
        }

        //
        //  Create symbol for entry point (DllMain or MainCrtStartup):
        //
        //      PE\EntryPoint
        //

        if ( NtHeader->OptionalHeader.AddressOfEntryPoint )
        {
            AddPrimarySymbol(
                RootPeSym,
                "EntryPoint",
                1,
                0xAA02,
                0,
                NtHeader->OptionalHeader.AddressOfEntryPoint
                );
        }

        //
        //  Create symbols for exports:
        //
        //      PE\Directory\Export\NameOfDll               (name of this dll)
        //      PE\Directory\Export\AddressOfFunctions
        //      PE\Directory\Export\AddressOfNames
        //      PE\Directory\Export\AddressOfNameOrdinals
        //
        //      for each entry in AddressOfNames:
        //
        //         PE\Directory\Export\AddressOfName\Foo    (pointer to "Foo")
        //         PE\Export\Foo                            (actual function)
        //
        //      for each entry in AddressOfFunctions that doesn't have a name
        //
        //         PE\Export\Ordinal\123                    (actual function)
        //
        //      for each entry in AddressOfFunctions that is a forwarder
        //
        //         PE\Export\Forward\ntdll.ForwardName
        //

        __try
        {
            ULONG ExportDirRva  = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ].VirtualAddress;
            ULONG ExportDirSize = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ].Size;
            ULONG ExportDirEnd  = ExportDirRva + ExportDirSize;

            PIMAGE_EXPORT_DIRECTORY ExportDir = (PIMAGE_EXPORT_DIRECTORY) ImageRvaToMappedAddress( ExportDirRva );

            if ( ExportDir )
            {
                SYMNODE* DirExportSym = DirectorySymNode[ IMAGE_DIRECTORY_ENTRY_EXPORT ];

                SYMNODE* RootExportSym = CreateSymbol( RootPeSym, "Export", 300, 0, 0, 0, 0 );

                if ( ExportDir->Name != 0 )
                {
                    LPSTR MappedName = (LPSTR)ImageRvaToMappedAddress( ExportDir->Name );
                    ULONG NameLength = MappedName ? strlen( MappedName ) + 1 : 0;

                    AddPrimarySymbol(
                        DirExportSym,
                        "DllName",
                        1,
                        0xAA05,
                        NameLength,
                        ExportDir->Name
                        );
                }

                if ( ExportDir->AddressOfFunctions != 0 )
                {
                    AddPrimarySymbol(
                        DirExportSym,
                        "AddressOfFunctions",
                        2,
                        0xAA05,
                        ExportDir->NumberOfFunctions * sizeof( ULONG ),
                        ExportDir->AddressOfFunctions
                        );
                }

                if ( ExportDir->AddressOfNames != 0 )
                {
                    AddPrimarySymbol(
                        DirExportSym,
                        "AddressOfNames",
                        3,
                        0xAA05,
                        ExportDir->NumberOfNames * sizeof( ULONG ),
                        ExportDir->AddressOfNames
                        );
                }

                if ( ExportDir->AddressOfNameOrdinals != 0 )
                {
                    AddPrimarySymbol(
                        DirExportSym,
                        "AddressOfNameOrdinals",
                        4,
                        0xAA05,
                        ExportDir->NumberOfNames * sizeof( USHORT ),
                        ExportDir->AddressOfNameOrdinals
                        );
                }

                PULONG  ExportFunctionArray      = (PULONG) ImageRvaToMappedAddress( ExportDir->AddressOfFunctions );
                PULONG  ExportNameArray          = (PULONG) ImageRvaToMappedAddress( ExportDir->AddressOfNames );
                PUSHORT ExportNameToOrdinalArray = (PUSHORT)ImageRvaToMappedAddress( ExportDir->AddressOfNameOrdinals );

                if ( ExportFunctionArray )
                {
                    PBYTE ExportOrdinalHasName = new BYTE[ ExportDir->NumberOfFunctions ];

                    ZeroMemory( ExportOrdinalHasName, ExportDir->NumberOfFunctions );

                    if (( ExportNameArray ) && ( ExportNameToOrdinalArray ))
                    {
                        SYMNODE* AddressOfNameSym = CreateSymbol( DirExportSym, "AddressOfName", 1, 0, 0, 0, 0 );

                        for ( unsigned i = 0; i < ExportDir->NumberOfNames; i++ )
                        {
                            ULONG RvaOfNameInImg    = ExportNameArray[ i ];
                            LPSTR MappedNameInImage = (LPSTR)ImageRvaToMappedAddress( RvaOfNameInImg );

                            if ( MappedNameInImage != 0 )
                            {
                                AddPrimarySymbol(
                                    AddressOfNameSym,
                                    MappedNameInImage,
                                    1,
                                    0xAA05,
                                    strlen( MappedNameInImage ) + 1,
                                    RvaOfNameInImg
                                    );

                                ULONG Ordinal = ExportNameToOrdinalArray[ i ];

                                if ( Ordinal < ExportDir->NumberOfFunctions )
                                {
                                    ExportOrdinalHasName[ Ordinal ] = TRUE;

                                    AddPrimarySymbol(
                                        RootExportSym,
                                        MappedNameInImage,
                                        1,
                                        0xAA85,
                                        0,
                                        ExportFunctionArray[ Ordinal ]
                                        );
                                }
                            }
                        }
                    }

                    SYMNODE* ExportOrdinalSym = NULL;
                    SYMNODE* ExportForwardSym = NULL;

                    for ( unsigned i = 0; i < ExportDir->NumberOfFunctions; i++ )
                    {
                        ULONG FunctionRva = ExportFunctionArray[ i ];

                        if ( ! ExportOrdinalHasName[ i ] )
                        {
                            if ( ExportOrdinalSym == NULL )
                            {
                                ExportOrdinalSym = CreateSymbol( RootExportSym, "Ordinal", 2, 0, 0, 0, 0 );
                            }

                            ULONG Ordinal = ExportDir->Base + i;

                            sprintf( szSymbolName, "%u", Ordinal );

                            AddPrimarySymbol(
                                ExportOrdinalSym,
                                szSymbolName,
                                2,
                                0xAA05,
                                0,
                                FunctionRva
                                );
                        }

                        if (( FunctionRva > ExportDirRva ) &&
                            ( FunctionRva < ExportDirEnd ))
                        {
                            if ( ExportForwardSym == NULL )
                            {
                                ExportForwardSym = CreateSymbol( RootExportSym, "Forward", 3, 0, 0, 0, 0 );
                            }

                            LPSTR MappedName = (LPSTR)ImageRvaToMappedAddress( FunctionRva );

                            AddPrimarySymbol(
                                ExportForwardSym,
                                MappedName,
                                3,
                                0xAA95,
                                0,
                                FunctionRva
                                );
                        }
                    }

                    delete ExportOrdinalHasName;
                }
            }
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            fprintf( stderr, "SYM7: Exception %08X processing PE export info\n", GetExceptionCode() );
        }

        //
        //  for each dll import descriptor:
        //
        //     PE\Directory\Import\Descriptor\foo.dll
        //     PE\Directory\Import\Descriptor\foo.dll\AddressOfName
        //     PE\Directory\Import\Descriptor\foo.dll\NameTable
        //
        //     for each import entry in this dll:
        //
        //        PE\Import\foo.dll\FooBar
        //        PE\Directory\Import\Descriptor\foo.dll\NameTable\HintAndName\FooBar
        //
        //        ...or...
        //
        //        PE\Import\foo.dll\Ordinal\123
        //

        __try
        {
            ULONG ImportDescRva = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ].VirtualAddress;

            PIMAGE_IMPORT_DESCRIPTOR ImportDesc = (PIMAGE_IMPORT_DESCRIPTOR) ImageRvaToMappedAddress( ImportDescRva );

            if ( ImportDesc )
            {
                SYMNODE* DirImportSym = DirectorySymNode[ IMAGE_DIRECTORY_ENTRY_IMPORT ];

                SYMNODE* RootImportSym = CreateSymbol( RootPeSym, "Import", 400, 0, 0, 0, 0 );

                SYMNODE* ImpDescSym = CreateSymbol( DirImportSym, "Descriptor", 1, 0, 0, 0, 0 );

                while ( ImportDesc->Characteristics != 0 )
                {
                    LPSTR ImportDllName = (LPSTR) ImageRvaToMappedAddress( ImportDesc->Name );

                    if ( ImportDllName )
                    {
                        strcpy( szSymbolName, ImportDllName );
                       _strlwr( szSymbolName );

                        SYMNODE* DllImpSym = CreateSymbol( RootImportSym, szSymbolName, 50, 0, 0, 0, 0 );
                        SYMNODE* NameTableSym = NULL;

                        SYMNODE* DescriptorSym = AddPrimarySymbol(
                            ImpDescSym,
                            szSymbolName,
                            1,
                            0xAA06,
                            sizeof( IMAGE_IMPORT_DESCRIPTOR ),
                            ImportDescRva
                            );

                        AddPrimarySymbol(
                            DescriptorSym,
                            "AddressOfDllName",
                            1,
                            0xAA06,
                            strlen( ImportDllName ) + 1,
                            ImportDesc->Name
                            );

                        PIMAGE_THUNK_DATA NameTable = (PIMAGE_THUNK_DATA) ImageRvaToMappedAddress( ImportDesc->OriginalFirstThunk );

                        if ( NameTable )
                        {
                            unsigned Count = 0;

                            while ( NameTable[ Count ].u1.Ordinal != 0 )
                            {
                                Count++;
                            }

                            unsigned Size = ( Count + 1 ) * sizeof( NameTable[ 0 ] );

                            NameTableSym = AddPrimarySymbol(
                                                DescriptorSym,
                                                "NameTable",
                                                1,
                                                0xAA06,
                                                Size,
                                                ImportDesc->OriginalFirstThunk
                                                );

                            SYMNODE* DllOrdinalSym = NULL;
                            SYMNODE* HintAndNameSym = NULL;

                            for ( unsigned i = 0; i < Count; i++ )
                            {
                                PIMAGE_THUNK_DATA Thunk = &NameTable[ i ];

                                ULONG RvaInIat = ImportDesc->FirstThunk + ( i * sizeof( IMAGE_THUNK_DATA ));

                                if ( IMAGE_SNAP_BY_ORDINAL( Thunk->u1.Ordinal ))
                                {
                                    if ( DllOrdinalSym == NULL )
                                    {
                                        DllOrdinalSym = CreateSymbol( DllImpSym, "Ordinal", 2, 0, 0, 0, 0 );
                                    }

                                    sprintf( szSymbolName, "%u", IMAGE_ORDINAL( Thunk->u1.Ordinal ));

                                    AddPrimarySymbol(
                                        DllOrdinalSym,
                                        szSymbolName,
                                        1,
                                        0xAA06,
                                        0,
                                        RvaInIat
                                        );
                                }
                                else    // import by name
                                {
                                    PIMAGE_IMPORT_BY_NAME ImportByName = (PIMAGE_IMPORT_BY_NAME) ImageRvaToMappedAddress( Thunk->u1.AddressOfData );

                                    if ( ImportByName )
                                    {
                                        if ( HintAndNameSym == NULL )
                                        {
                                            HintAndNameSym = CreateSymbol( NameTableSym, "HintAndName", 2, 0, 0, 0, 0 );
                                        }

                                        AddPrimarySymbol(
                                            DllImpSym,
                                            (LPSTR) ImportByName->Name,
                                            1,
                                            0xAA86,
                                            sizeof( PVOID ),
                                            RvaInIat
                                            );

                                        AddPrimarySymbol(
                                            HintAndNameSym,
                                            (LPSTR) ImportByName->Name,
                                            1,
                                            0xAA06,
                                            sizeof( ImportByName->Hint ) + strlen( (LPSTR) ImportByName->Name ) + 1,
                                            Thunk->u1.AddressOfData
                                            );
                                    }
                                }
                            }
                        }
                    }

                    ImportDescRva += sizeof( *ImportDesc );
                    ImportDesc++;
                }
                while ( ImportDesc->Characteristics != 0 );

            }
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            fprintf( stderr, "SYM7: Exception %08X processing PE import info\n", GetExceptionCode() );
        }

        __try
        {
            //
            //  for each delay load dll import descriptor:
            //
            //     PE\Directory\DelayImport\Descriptor\foo.dll
            //     PE\Directory\DelayImport\Descriptor\foo.dll\AddressOfDllName
            //     PE\Directory\DelayImport\Descriptor\foo.dll\NameTable
            //     PE\Directory\DelayImport\Descriptor\foo.dll\BoundTable
            //     PE\Directory\DelayImport\Descriptor\foo.dll\UnloadTable
            //     PE\DelayImport\foo.dll\HMODULE
            //
            //     for each delay load import entry in this dll:
            //
            //        PE\DelayImport\foo.dll\FooBar
            //        PE\Directory\DelayImport\Descriptor\foo.dll\NameTable\HintAndName\FooBar
            //
            //        ...or...
            //
            //        PE\DelayImport\foo.dll\Ordinal\123  ...etc...
            //

            ULONG DelayImportDescRva = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT ].VirtualAddress;

            PImgDelayDescr DelayImportDesc = (PImgDelayDescr) ImageRvaToMappedAddress( DelayImportDescRva );

            if ( DelayImportDesc )
            {
                SYMNODE* DirDelaySym = DirectorySymNode[ IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT ];

                SYMNODE* RootDelaySym = CreateSymbol( RootPeSym, "DelayImport", 500, 0, 0, 0, 0 );

                SYMNODE* DelayDescSym = CreateSymbol( DirDelaySym, "Descriptor", 1, 0, 0, 0, 0 );

                while (( DelayImportDesc->rvaDLLName ) &&
                       ( DelayImportDesc->rvaINT ))
                {
                    ImgDelayDescr DelayDesc;

                    memcpy( &DelayDesc, DelayImportDesc, sizeof( DelayDesc ));

                    if ( ! ( DelayDesc.grAttrs & dlattrRva ))
                    {
                        ULONG ImageBase = NtHeader->OptionalHeader.ImageBase;

                        if ( DelayDesc.rvaDLLName >= ImageBase )
                        {
                             DelayDesc.rvaDLLName -= ImageBase;
                        }

                        if ( DelayDesc.rvaHmod >= ImageBase )
                        {
                             DelayDesc.rvaHmod -= ImageBase;
                        }

                        if ( DelayDesc.rvaIAT >= ImageBase )
                        {
                             DelayDesc.rvaIAT -= ImageBase;
                        }

                        if ( DelayDesc.rvaINT >= ImageBase )
                        {
                             DelayDesc.rvaINT -= ImageBase;
                        }

                        if ( DelayDesc.rvaBoundIAT >= ImageBase )
                        {
                             DelayDesc.rvaBoundIAT -= ImageBase;
                        }

                        if ( DelayDesc.rvaUnloadIAT >= ImageBase )
                        {
                             DelayDesc.rvaUnloadIAT -= ImageBase;
                        }
                    }

                    ASSERT( DelayDesc.rvaDLLName   < NtHeader->OptionalHeader.SizeOfImage );
                    ASSERT( DelayDesc.rvaHmod      < NtHeader->OptionalHeader.SizeOfImage );
                    ASSERT( DelayDesc.rvaIAT       < NtHeader->OptionalHeader.SizeOfImage );
                    ASSERT( DelayDesc.rvaINT       < NtHeader->OptionalHeader.SizeOfImage );
                    ASSERT( DelayDesc.rvaBoundIAT  < NtHeader->OptionalHeader.SizeOfImage );
                    ASSERT( DelayDesc.rvaUnloadIAT < NtHeader->OptionalHeader.SizeOfImage );

                    LPSTR DelayDllName = (LPSTR) ImageRvaToMappedAddress( DelayDesc.rvaDLLName );

                    if ( DelayDllName )
                    {
                        strcpy( szSymbolName, DelayDllName );
                       _strlwr( szSymbolName );

                        SYMNODE* DelayDllSym = CreateSymbol( RootDelaySym, szSymbolName, 50, 0, 0, 0, 0 );
                        SYMNODE* NameTableSym = NULL;

                        SYMNODE* DescriptorSym = AddPrimarySymbol(
                            DelayDescSym,
                            szSymbolName,
                            1,
                            0xAA07,
                            sizeof( IMAGE_IMPORT_DESCRIPTOR ),
                            DelayImportDescRva
                            );

                        AddPrimarySymbol(
                            DescriptorSym,
                            "AddressOfDllName",
                            1,
                            0xAA07,
                            strlen( DelayDllName ) + 1,
                            DelayDesc.rvaDLLName
                            );

                        AddPrimarySymbol(
                            DelayDllSym,
                            "HMODULE",
                            1,
                            0xAA07,
                            0,
                            DelayDesc.rvaHmod
                            );

                        unsigned TableSize = 0;

                        PIMAGE_THUNK_DATA NameTable = (PIMAGE_THUNK_DATA) ImageRvaToMappedAddress( DelayDesc.rvaINT );

                        if ( NameTable )
                        {
                            unsigned Count = 0;

                            while ( NameTable[ Count ].u1.Ordinal != 0 )
                            {
                                Count++;
                            }

                            TableSize = ( Count + 1 ) * sizeof( NameTable[ 0 ] );
                        }

                        NameTableSym = AddPrimarySymbol(
                                           DescriptorSym,
                                           "NameTable",
                                           1,
                                           0xAA07,
                                           TableSize,
                                           DelayDesc.rvaINT
                                           );

                        if ( DelayDesc.rvaBoundIAT )
                        {
                            AddPrimarySymbol(
                                DescriptorSym,
                                "BoundTable",
                                1,
                                0xAA07,
                                TableSize,
                                DelayDesc.rvaBoundIAT
                                );
                        }

                        if ( DelayDesc.rvaUnloadIAT )
                        {
                            AddPrimarySymbol(
                                DescriptorSym,
                                "UnloadTable",
                                1,
                                0xAA07,
                                TableSize,
                                DelayDesc.rvaUnloadIAT
                                );
                        }

                        SYMNODE* DllOrdinalSym = NULL;
                        SYMNODE* HintAndNameSym = NULL;

                        if ( NameTable )
                        {
                            for ( unsigned ThunkIndex = 0;; ThunkIndex++ )
                            {
                                PIMAGE_THUNK_DATA Thunk = &NameTable[ ThunkIndex ];

                                if ( Thunk->u1.Ordinal == 0 )
                                {
                                    break;
                                }

                                ULONG RvaInIat = DelayDesc.rvaIAT + ( ThunkIndex * sizeof( IMAGE_THUNK_DATA ));

                                if ( IMAGE_SNAP_BY_ORDINAL( Thunk->u1.Ordinal ))
                                {
                                    if ( DllOrdinalSym == NULL )
                                    {
                                        DllOrdinalSym = CreateSymbol( DelayDllSym, "Ordinal", 2, 0, 0, 0, 0 );
                                    }

                                    sprintf( szSymbolName, "%u", IMAGE_ORDINAL( Thunk->u1.Ordinal ));

                                    AddPrimarySymbol(
                                        DllOrdinalSym,
                                        szSymbolName,
                                        1,
                                        0xAA07,
                                        0,
                                        RvaInIat
                                        );
                                }
                                else    // import by name
                                {
                                    PIMAGE_IMPORT_BY_NAME ImportByName = (PIMAGE_IMPORT_BY_NAME) ImageRvaToMappedAddress( Thunk->u1.AddressOfData );

                                    if ( ImportByName )
                                    {
                                        if ( HintAndNameSym == NULL )
                                        {
                                            HintAndNameSym = CreateSymbol( NameTableSym, "HintAndName", 2, 0, 0, 0, 0 );
                                        }

                                        AddPrimarySymbol(
                                            DelayDllSym,
                                            (LPSTR) ImportByName->Name,
                                            1,
                                            0xAA07,
                                            0,
                                            RvaInIat
                                            );

                                        AddPrimarySymbol(
                                            HintAndNameSym,
                                            (LPSTR) ImportByName->Name,
                                            1,
                                            0xAA07,
                                            sizeof( ImportByName->Hint ) + strlen( (LPSTR) ImportByName->Name ) + 1,
                                            Thunk->u1.AddressOfData
                                            );
                                    }
                                }
                            }
                        }
                    }

                    DelayImportDescRva += sizeof( *DelayImportDesc );
                    DelayImportDesc++;
                }
            }
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            fprintf( stderr, "SYM7: Exception %08X processing PE delay-import info\n", GetExceptionCode() );
        }

        //
        //  for each resource entry
        //
        //      PE\Resource\Root\#RT_BITMAP\#2502
        //      PE\Resource\Root\#RT_BITMAP\#2502\#Lang0409
        //      PE\Resource\Root\#RT_BITMAP\#2502\#Lang0409\Data
        //      PE\Resource\Root\#RT_HTML\BLANK.HTM
        //      PE\Resource\Root\#RT_HTML\BLANK.HTM\AddressOfName
        //      PE\Resource\Root\#RT_HTML\BLANK.HTM\#Lang0409
        //      PE\Resource\Root\#RT_HTML\BLANK.HTM\#Lang0409\Data
        //

        __try
        {
            // resource info

            ResourceBaseRva    = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].VirtualAddress;
            ResourceBaseMapped = (PBYTE) ImageRvaToMappedAddress( ResourceBaseRva );

            if ( ResourceBaseMapped )
            {
                ResourceRootSym = CreateSymbol( RootPeSym, "Resource", 800, 0, 0, 0, 0 );

                PIMAGE_RESOURCE_DIRECTORY RootDir = (PIMAGE_RESOURCE_DIRECTORY) ResourceBaseMapped;

                ULONG SizeOfData = sizeof( IMAGE_RESOURCE_DIRECTORY );

                ULONG Entries = RootDir->NumberOfNamedEntries
                              + RootDir->NumberOfIdEntries;

                SizeOfData += Entries * sizeof( IMAGE_RESOURCE_DIRECTORY_ENTRY );

                AddPrimarySymbol(
                    ResourceRootSym,
                    "Root",
                    1,
                    0xAA08,
                    SizeOfData,
                    ResourceBaseRva
                    );

                LoadResourceSymsRecursive(
                    RootDir,
                    ResourceRootSym,
                    szSymbolName
                    );
            }
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            fprintf( stderr, "SYM7: Exception %08X processing PE resource info\n", GetExceptionCode() );
        }

        //
        //  for each debug directory entry
        //
        //      PE\Directory\Debug\Misc
        //      PE\Directory\Debug\NB10
        //

        __try
        {
            // debug directories

            ULONG DebugDirectoryRva   = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_DEBUG ].VirtualAddress;
            ULONG DebugDirectorySize  = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_DEBUG ].Size;
            ULONG DebugDirectoryCount = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

            PIMAGE_DEBUG_DIRECTORY DebugDirectory = (PIMAGE_DEBUG_DIRECTORY) ImageRvaToMappedAddress( DebugDirectoryRva );

            if (( DebugDirectory ) && ( DebugDirectoryCount )) {

                SYMNODE* DebugDirSym = DirectorySymNode[ IMAGE_DIRECTORY_ENTRY_DEBUG ];

                for ( unsigned j = 0; j < DebugDirectoryCount; j++ )
                {
                    ULONG rvaData = DebugDirectory[ j ].AddressOfRawData;
                    PBYTE pbData  = (PBYTE) ImageRvaToMappedAddress( rvaData );
                    ULONG cbData  = DebugDirectory[ j ].SizeOfData;
                    LPSTR pszName = NULL;

                    if (( pbData ) && ( cbData ))
                    {
                        switch ( DebugDirectory[ j ].Type )
                        {
                            case IMAGE_DEBUG_TYPE_COFF:          pszName = "COFF";          break;
                            case IMAGE_DEBUG_TYPE_FPO:           pszName = "FPO";           break;
                            case IMAGE_DEBUG_TYPE_MISC:          pszName = "Misc";          break;
                            case IMAGE_DEBUG_TYPE_EXCEPTION:     pszName = "Exception";     break;
                            case IMAGE_DEBUG_TYPE_FIXUP:         pszName = "Fixup";         break;
                            case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:   pszName = "OmapImgToSrc";  break;
                            case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC: pszName = "OmapSrcToImg";  break;
                            case IMAGE_DEBUG_TYPE_CLSID:         pszName = "CLSID";         break;

                            case IMAGE_DEBUG_TYPE_CODEVIEW:

                                pszName = "Codeview";

                                if (( pbData[ 0 ] > 0x22 ) && ( pbData[ 0 ] < 127 ) &&
                                    ( pbData[ 1 ] > 0x22 ) && ( pbData[ 1 ] < 127 ) &&
                                    ( pbData[ 2 ] > 0x22 ) && ( pbData[ 2 ] < 127 ) &&
                                    ( pbData[ 3 ] > 0x22 ) && ( pbData[ 3 ] < 127 ))
                                {
                                    memcpy( szSymbolName, pbData, 4 );  // NB10, RSDS, etc.
                                    szSymbolName[ 4 ] = 0;
                                    pszName = szSymbolName;
                                }

                                break;

                            default:

                                sprintf( szSymbolName, "Type_%X", DebugDirectory[ j ].Type );
                                pszName = szSymbolName;
                                break;
                        }

                        AddPrimarySymbol(
                            DebugDirSym,
                            pszName,
                            1,
                            0xAA09,
                            cbData,
                            rvaData
                            );
                    }
                }
            }
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            fprintf( stderr, "SYM7: Exception %08X processing PE debug info\n", GetExceptionCode() );
        }

        //
        //  for LoadConfig directory:
        //
        //      PE\Directory\LoadConfig\LockPrefixTable
        //      PE\Directory\LoadConfig\EditList
        //

        __try
        {
            // LoadConfig directory

            ULONG LoadConfigRva = NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG ].VirtualAddress;

            if ( LoadConfigRva != 0 )
            {
                PIMAGE_LOAD_CONFIG_DIRECTORY LoadConfig = (PIMAGE_LOAD_CONFIG_DIRECTORY) ImageRvaToMappedAddress( LoadConfigRva );

                if ( LoadConfig )
                {
                    //
                    //  The LockPrefixTable and EditList fields are stored
                    //  as full pointers, not RVAs, so we subtract the image
                    //  base address to convert them to RVAs.
                    //

                    ULONG ImageBase = NtHeader->OptionalHeader.ImageBase;

                    if ( LoadConfig->LockPrefixTable > ImageBase )
                    {
                        ULONG  LockPrefixTableSize = 0;
                        ULONG  LockPrefixTableRva  = LoadConfig->LockPrefixTable - ImageBase;
                        PVOID* LockPrefixTablePtr  = (PVOID*) ImageRvaToMappedAddress( LockPrefixTableRva );

                        if ( LockPrefixTablePtr )
                        {
                            for ( unsigned Count = 0; LockPrefixTablePtr[ Count ] != NULL; Count++ );

                            LockPrefixTableSize = ( Count + 1 ) * sizeof( LockPrefixTablePtr[ 0 ] );
                        }

                        AddPrimarySymbol(
                            DirectorySymNode[ IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG ],
                            "LockPrefixTable",
                            1,
                            0xAA09,
                            LockPrefixTableSize,
                            LockPrefixTableRva
                            );

                        //
                        //  Note that we don't create symbols for all the
                        //  actual lock prefix instruction locations.  We
                        //  could, but they would all be ambiguous because
                        //  we don't know what function name scope each one
                        //  is under, and their order is not significant.
                        //  At this point in time we don't have the pdb
                        //  info loaded yet to determine function scope.
                        //
                    }

                    if ( LoadConfig->EditList > ImageBase )
                    {
                        ULONG EditListRva = LoadConfig->EditList - ImageBase;

                        //
                        //  I can find no reference to LoadConfig EditList
                        //  usage anywhere in the WinXP sources.
                        //

                        AddPrimarySymbol(
                            DirectorySymNode[ IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG ],
                            "EditList",
                            1,
                            0xAA09,
                            0,
                            EditListRva
                            );
                    }
                }
            }
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            fprintf( stderr, "SYM7: Exception %08X processing PE load config info\n", GetExceptionCode() );
        }


    }

    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        fprintf( stderr, "SYM7: Exception %08X processing PE info\n", GetExceptionCode() );
    }

}

const LPCSTR ResTypeToName[] =                  //  taken from winuser.h
                {
                    NULL,                       //  0
                    "RT_CURSOR",                //  1
                    "RT_BITMAP",                //  2
                    "RT_ICON",                  //  3
                    "RT_MENU",                  //  4
                    "RT_DIALOG",                //  5
                    "RT_STRING",                //  6
                    "RT_FONTDIR",               //  7
                    "RT_FONT",                  //  8
                    "RT_ACCELERATOR",           //  9
                    "RT_RCDATA",                // 10
                    "RT_MESSAGETABLE",          // 11
                    "RT_GROUP_CURSOR",          // 12
                    NULL,                       // 13
                    "RT_GROUP_ICON",            // 14
                    NULL,                       // 15
                    "RT_VERSION",               // 16
                    "RT_DLGINCLUDE",            // 17
                    NULL,                       // 18
                    "RT_PLUGPLAY",              // 19
                    "RT_VXD",                   // 20
                    "RT_ANICURSOR",             // 21
                    "RT_ANIICON",               // 22
                    "RT_HTML",                  // 23
                    "RT_MANIFEST",              // 24
                    NULL                        // 25
                };


VOID
__fastcall
PdbSymbolHandler::LoadResourceSymsRecursive(
    IN PIMAGE_RESOURCE_DIRECTORY ResourceDir,
    IN SYMNODE* ParentSym,
    IN LPSTR    pszBuffer
    )
{
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceEntry;
    PIMAGE_RESOURCE_DATA_ENTRY      ResourceData;
    PIMAGE_RESOURCE_DIR_STRING_U    ResourceNameU;
    ULONG                           ResourceCount;

    ResourceCount = ResourceDir->NumberOfNamedEntries
                  + ResourceDir->NumberOfIdEntries;

    ResourceEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( ResourceDir + 1 );

    while ( ResourceCount-- )
    {
        ULONG OffsetToData = ResourceEntry->OffsetToData & 0x7FFFFFFF;
        ULONG RvaOfData    = ResourceBaseRva + OffsetToData;
        ULONG SizeOfData;

        if ( ResourceEntry->NameIsString )
        {
            ResourceNameU = (PIMAGE_RESOURCE_DIR_STRING_U)( ResourceBaseMapped + ResourceEntry->NameOffset );

            //
            //  BUGBUG:  I see an alternate IMAGE_RESOURCE_DIRECTORY_STRING
            //           representation alongside the unicode version in the
            //           Win32 header, but no mention of when to use it.
            //           For now we will just assume the names are unicode.
            //

            int ActualSize = WideCharToMultiByte(
                                 CP_OEMCP,
                                 0,
                                 ResourceNameU->NameString,
                                 ResourceNameU->Length,
                                 pszBuffer,
                                 2048 - 1,
                                 NULL,
                                 NULL
                                 );

            pszBuffer[ ActualSize ] = 0;    // force termination
        }
        else
        {
            sprintf( pszBuffer, "#%u", ResourceEntry->Id );

            if ( ResourceEntry->DataIsDirectory )
            {
                if (( ParentSym == ResourceRootSym ) &&
                    ( ResourceEntry->Id > 0 ) &&
                    ( ResourceEntry->Id < countof( ResTypeToName )) &&
                    ( ResTypeToName[ ResourceEntry->Id ] != NULL ))
                {
                    sprintf( pszBuffer, "#%s", ResTypeToName[ ResourceEntry->Id ] );
                }
            }
            else    // child is data
            {
                if ( ResourceEntry->Id > 0x400 )
                {
                    sprintf( pszBuffer, "#Lang%04X", ResourceEntry->Id );
                }
            }
        }

        if ( ResourceEntry->DataIsDirectory )
        {
            SizeOfData = sizeof( IMAGE_RESOURCE_DIRECTORY );

            PIMAGE_RESOURCE_DIRECTORY ChildDir = (PIMAGE_RESOURCE_DIRECTORY)( ResourceBaseMapped + OffsetToData );

            if ( ChildDir )
            {
                ULONG Entries = ChildDir->NumberOfNamedEntries
                              + ChildDir->NumberOfIdEntries;

                SizeOfData += Entries * sizeof( IMAGE_RESOURCE_DIRECTORY_ENTRY );
            }
        }
        else
        {
            SizeOfData = sizeof( IMAGE_RESOURCE_DATA_ENTRY );
        }

        SYMNODE* ResourceSym = AddPrimarySymbol(
                                   ParentSym,
                                   pszBuffer,
                                   1,
                                   ResourceEntry->DataIsDirectory ? 0xAA08 : 0xAA09,
                                   SizeOfData,
                                   RvaOfData
                                   );

        if ( ResourceEntry->NameIsString )
        {
            ResourceNameU   = (PIMAGE_RESOURCE_DIR_STRING_U)( ResourceBaseMapped + ResourceEntry->NameOffset );
            ULONG NameSize  = ( ResourceNameU->Length * sizeof( WCHAR )) + sizeof( WORD );
            ULONG RvaOfName = ResourceBaseRva + ResourceEntry->NameOffset;

            AddPrimarySymbol(
                ResourceSym,
                "AddressOfName",
                2,
                0xAA08,
                NameSize,
                RvaOfName
                );
        }

        if ( ResourceEntry->DataIsDirectory )
        {
            LoadResourceSymsRecursive(
                (PIMAGE_RESOURCE_DIRECTORY)( ResourceBaseMapped + OffsetToData ),
                ResourceSym,
                pszBuffer
                );
        }
        else
        {
            ResourceData = (PIMAGE_RESOURCE_DATA_ENTRY)( ResourceBaseMapped + OffsetToData );

            //
            //  BUGBUG:  Contrary to what the winnt.h header file says, the
            //           IMAGE_RESOURCE_DATA_ENTRY.OffsetToData field appears
            //           to be an RVA, not offset from beginning of directory.
            //

            unsigned n = sprintf( pszBuffer, "Data" );

            if ( ResourceData->CodePage != 0 )
            {
                sprintf( pszBuffer + n, "%u", ResourceData->CodePage );
            }

            AddPrimarySymbol(
                ResourceSym,
                pszBuffer,
                3,
                0xAA0A,
                ResourceData->Size,
                ResourceData->OffsetToData
                );
        }

        ResourceEntry++;
    }
}


VOID PdbSymbolHandler::LoadModuleSymbols( VOID )
{
    Mod* ThisMod = NULL;

    for (;;)
    {
        Mod* LastMod = ThisMod;

        if ( ! dbi->QueryNextMod( LastMod, &ThisMod ))
        {
            ThisMod = NULL;
        }

        if ( LastMod != NULL )
        {
            LastMod->Close();
        }

        if ( ThisMod == NULL )
        {
            break;
        }

        char szModName[ PDB_MAX_PATH ];
        long cbModName = PDB_MAX_PATH;

        *szModName = 0;

        ThisMod->QueryName( szModName, &cbModName );

        _strlwr( szModName );

        //
        //  Sometimes szModName contains relative path or absolute path,
        //  so we strip that to just the filename.  This may leave us with
        //  two or more modules of the same name that had different paths,
        //  but that is preferable to leaving paths in symbols that may
        //  vary by different build machine root enlistments.
        //

        char* pszLastBackslash = strrchr( szModName, '\\' );
        char* pszLastForeslash = strrchr( szModName, '/'  );
        char* pszLastSlash     = MAX( pszLastBackslash, pszLastForeslash );
        char* pszModNameNoPath = pszLastSlash ? pszLastSlash + 1 : szModName;

#ifdef DONTCOMPILE  // code to uniquify duplicate module names

        if ( NameTable.LookupName( pszModNameNoPath ))
        {
            char* pszModNameEnd = pszModNameNoPath + strlen( pszModNameNoPath );
            ULONG nExtender = 2;

            do
            {
                sprintf( pszModNameEnd, "[%u]", nExtender++ );
            }
            while ( NameTable.LookupName( pszModNameNoPath ));
        }

#endif

        NestedScopeParentSym = CreateSymbol( RootModuleSym, pszModNameNoPath, 0, 0, 0, 0, 0 );

        long cbMem = 0;

        ThisMod->QuerySymbols( NULL, &cbMem );

        if ( cbMem > 0 )
        {
            PBYTE pbMem = new BYTE[ cbMem ];
            PBYTE pbEnd = pbMem + cbMem;
            PBYTE pbSym = pbMem + sizeof( DWORD );

            ThisMod->QuerySymbols( pbMem, &cbMem );

            while ( pbSym < pbEnd )
            {
                CVSYM* pcvsym = (CVSYM*)pbSym;

                ProcessCvSym( pcvsym );

                pbSym += pcvsym->cb + sizeof( WORD );
            }

            delete pbMem;
        }
    }
}


VOID __fastcall PdbSymbolHandler::ProcessCvSym( CVSYM* pcvsym )
{
    LPCSTR pszName = NULL;
    ULONG  SegNum  = 0;
    ULONG  SegOff  = 0;
    ULONG  SymSize = 0;
    BOOL   Nesting = FALSE;

#ifdef SYMCOUNTER

    if ( pcvsym->cvsymt < 0x4000 )
    {
        SymTypeCounter[ pcvsym->cvsymt ]++;
    }

#endif

    switch ( (CVSYMT) pcvsym->cvsymt )
    {
        case cvsymtEnd:

            //
            //  End of scope, pop to higher scope
            //

            ASSERT( NestedScopeParentSym != NULL );

            if ( NestedScopeParentSym != NULL )
            {
                NestedScopeParentSym = NestedScopeParentSym->ParentSym;
            }

            return;

        case cvsymtLData32_Sz:
        case cvsymtGData32_Sz:

            pszName = ((CVSYMDATA32_32*) pcvsym )->rgchName;
            SegNum  = ((CVSYMDATA32_32*) pcvsym )->lsn;
            SegOff  = ((CVSYMDATA32_32*) pcvsym )->ib;
            /* no size data */
            break;

        case cvsymtPub32_Sz:

            pszName = ((CVSYMDATA32_32*) pcvsym )->rgchName;
            SegNum  = ((CVSYMDATA32_32*) pcvsym )->lsn;
            SegOff  = ((CVSYMDATA32_32*) pcvsym )->ib;
            /* no size data */

            //
            //  Ignore public symbols containing "NULL_IMPORT_DESCRIPTOR" and
            //  "NULL_THUNK_DATA" since BBT does not have proper OMAP for them.
            //

            if (( strstr( pszName, "NULL_IMPORT_DESCRIPTOR" )) ||
                ( strstr( pszName, "NULL_THUNK_DATA"        )))
            {
                return;
            }

            break;

        case cvsymtLProc32_Sz:
        case cvsymtGProc32_Sz:

            Nesting = TRUE;
            pszName = ((CVSYMPROC32_32*) pcvsym )->rgchName;
            SegNum  = ((CVSYMPROC32_32*) pcvsym )->lsn;
            SegOff  = ((CVSYMPROC32_32*) pcvsym )->ib;
            SymSize = ((CVSYMPROC32_32*) pcvsym )->cb;
            break;

        case cvsymtLabel32_Sz:

            pszName = ((CVSYMLABEL32*) pcvsym )->rgchName;
            SegNum  = ((CVSYMLABEL32*) pcvsym )->lsn;
            SegOff  = ((CVSYMLABEL32*) pcvsym )->ib;
            /* no size data */
            break;

        case cvsymtLThread32_Sz:
        case cvsymtGThread32_Sz:

            pszName = ((CVSYMTHREAD32_32*) pcvsym )->rgchName;
            SegNum  = ((CVSYMTHREAD32_32*) pcvsym )->lsn;
            SegOff  = ((CVSYMTHREAD32_32*) pcvsym )->ib;
            /* no size data */
            break;

        case cvsymtThunk32_Sz:

            Nesting = TRUE;
            pszName = ((CVSYMTHUNK32*) pcvsym )->rgchName;
            SegNum  = ((CVSYMTHUNK32*) pcvsym )->lsn;
            SegOff  = ((CVSYMTHUNK32*) pcvsym )->ib;
            SymSize = ((CVSYMTHUNK32*) pcvsym )->cb;
            break;

        case cvsymtBlock32_Sz:

            Nesting = TRUE;
            pszName = ((CVSYMBLOCK32*) pcvsym )->rgchName;
            SegNum  = ((CVSYMBLOCK32*) pcvsym )->lsn;
            SegOff  = ((CVSYMBLOCK32*) pcvsym )->ib;
            SymSize = ((CVSYMBLOCK32*) pcvsym )->cb;
            break;

        case cvsymtWith32_Sz:

            Nesting = TRUE;
            pszName = ((CVSYMWITH32*) pcvsym )->rgchExpr;
            SegNum  = ((CVSYMWITH32*) pcvsym )->lsn;
            SegOff  = ((CVSYMWITH32*) pcvsym )->ib;
            SymSize = ((CVSYMWITH32*) pcvsym )->cb;
            break;

        case cvsymtLProcIa64_Sz:
        case cvsymtGProcIa64_Sz:

            Nesting = TRUE;
            pszName = ((CVSYMPROCIA64*) pcvsym )->rgchName;
            SegNum  = ((CVSYMPROCIA64*) pcvsym )->lsn;
            SegOff  = ((CVSYMPROCIA64*) pcvsym )->ib;
            SymSize = ((CVSYMPROCIA64*) pcvsym )->cb;
            break;

        case cvsymtLProcMips_Sz:
        case cvsymtGProcMips_Sz:

            Nesting = TRUE;
            pszName = ((CVSYMPROCMIPS_32*) pcvsym )->rgchName;
            SegNum  = ((CVSYMPROCMIPS_32*) pcvsym )->lsn;
            SegOff  = ((CVSYMPROCMIPS_32*) pcvsym )->ib;
            SymSize = ((CVSYMPROCMIPS_32*) pcvsym )->cb;
            break;

        case cvsymtAnnotation:

            //
            //  BUGBUG:  CVSYMANNOTATION rgsz field is a double-null
            //           terminated sequence of single-null terminated
            //           strings.  We'll only pick up the first name
            //           for this record here.
            //

            pszName = ((CVSYMANNOTATION*) pcvsym )->rgsz;
            SegNum  = ((CVSYMANNOTATION*) pcvsym )->lsn;
            SegOff  = ((CVSYMANNOTATION*) pcvsym )->ib;
            /* no size data */
            break;

        case cvsymtGManProc_Sz:
        case cvsymtLManProc_Sz:

            Nesting = TRUE;     // BUGBUG: we don't know this for sure
            pszName = ((CVSYMMANPROC*) pcvsym )->rgchName;
            SegNum  = ((CVSYMMANPROC*) pcvsym )->lsn;
            SegOff  = ((CVSYMMANPROC*) pcvsym )->ib;
            SymSize = ((CVSYMMANPROC*) pcvsym )->cb;
            break;

        case cvsymtLManData_Sz:
        case cvsymtGManData_Sz:

            //
            //  BUGBUG:  Don't know what struct to use for these.
            //

            ASSERT( ! "encountered cvsymtGManData_Sz" );
            return;

        //
        //  The following set of sym types do not represent unique defined
        //  objects with image addresses, but they might be useful for future
        //  patch transformations because they can still be used as markers
        //  if they are properly scoped.
        //

        case cvsymtObjName_Sz:      // object file name, already have it
        case cvsymtCompile2_Sz:     // compiler/linker id string
        case cvsymtCompile:         // compiler id string
        case cvsymtUDT_Sz:          // user defined type
        case cvsymtConstant_Sz:     // constant #define
        case cvsymtRegister_Sz:     // register variable
        case cvsymtManyReg_Sz:      // multi-register variable
        case cvsymtManyReg2_Sz:     // multi-register variable
        case cvsymtRegRel32_Sz:     // register-relative address
        case cvsymtBPRel32_Sz:      // BP-relative variable

            return;

        case cvsymtDataRef_Sz:      // call or address of global data object
        case cvsymtProcRef_Sz:      // call or address of another procedure
        case cvsymtLProcRef_Sz:     // call of address of "local" procedure

            return;

        default:

            DEBUGCODE( printf( "\nIgnored cvsymt 0x%x:\n", pcvsym->cvsymt ));

            return;

    }

    //
    //  Some symbols appear to have no names, so we ignore those unless
    //  they are the start of a new scope.
    //

    if ( pszName == NULL )
    {
        pszName = "";
    }

    if (( *pszName != 0 ) || ( Nesting ))
    {
        SYMNODE* SymNode = NULL;

        if ( SegNum != 0 )
        {
            if ( SegNum <= nSrcSegToRvaMap )
            {
                ULONG RvaInSrc = pSrcSegToRvaMap[ SegNum - 1 ] + SegOff;
                ULONG RvaInImg = TranslateOmapFromSrcToImg( RvaInSrc );

                SymNode = AddPrimarySymbol(
                              NestedScopeParentSym,
                              pszName,
                              1,
                              pcvsym->cvsymt,
                              SymSize,
                              RvaInImg,
                              RvaInSrc
                              );
            }
        }

        if ( Nesting )
        {
            NestedScopeParentSym = SymNode;
        }
    }
}


ULONG PdbSymbolHandler::TranslateOmapFromSrcToImg( ULONG Rva )
{
    if ( nOmapToImg == 0 )
    {
        return Rva;
    }

    unsigned Lo = 0;
    unsigned Hi = nOmapToImg;

    while ( Lo < Hi )
    {
        unsigned Mi = ( Lo + Hi ) / 2;

        if ( pOmapToImg[ Mi ].Rva1 == Rva )
        {
            return pOmapToImg[ Mi ].Rva2;
        }
        else if ( pOmapToImg[ Mi ].Rva1 < Rva )
        {
            Lo = Mi + 1;
        }
        else
        {
            Hi = Mi;
        }
    }

    if (( Lo == 0 ) || ( Lo == nOmapToImg ))
    {
        return 0;       // outside translation entry range
    }

    unsigned Index = Lo - 1;

    //
    //  Now pOmapToImg[ Index ] is the nearest preceding omap entry.
    //

    ASSERT( pOmapToImg[ Index ].Rva1 <= Rva );

    if (( Index + 1 ) < nOmapToImg )
    {
        ASSERT( pOmapToImg[ Index + 1 ].Rva1 > Rva );
    }

    if ( pOmapToImg[ Index ].Rva2 == 0 )
    {
        return 0;
    }

    unsigned Offset = Rva - pOmapToImg[ Index ].Rva1;

    return pOmapToImg[ Index ].Rva2 + Offset;
}


ULONG PdbSymbolHandler::TranslateOmapFromImgToSrc( ULONG Rva )
{
    if ( nOmapToSrc == 0 )
    {
        return Rva;
    }

    unsigned Lo = 0;
    unsigned Hi = nOmapToSrc;

    while ( Lo < Hi )
    {
        unsigned Mi = ( Lo + Hi ) / 2;

        if ( pOmapToSrc[ Mi ].Rva1 == Rva )
        {
            return pOmapToSrc[ Mi ].Rva2;
        }
        else if ( pOmapToSrc[ Mi ].Rva1 < Rva )
        {
            Lo = Mi + 1;
        }
        else
        {
            Hi = Mi;
        }
    }

    if (( Lo == 0 ) || ( Lo == nOmapToSrc ))
    {
        return 0;       // outside translation entry range
    }

    unsigned Index = Lo - 1;

    //
    //  Now pOmapToSrc[ Index ] is the nearest preceding omap entry.
    //

    ASSERT( pOmapToSrc[ Index ].Rva1 <= Rva );

    if (( Index + 1 ) < nOmapToSrc )
    {
        ASSERT( pOmapToSrc[ Index + 1 ].Rva1 > Rva );
    }

    if ( pOmapToSrc[ Index ].Rva2 == 0 )
    {
        return 0;
    }

    unsigned Offset = Rva - pOmapToSrc[ Index ].Rva1;

    return pOmapToSrc[ Index ].Rva2 + Offset;
}



SYMNODE*
PdbSymbolHandler::AddPrimarySymbol(
    SYMNODE*  ParentSym,
    LPCSTR    SymName,
    ULONG     SymSort,
    ULONG     SymType,
    ULONG     SymSize,
    ULONG     RvaInImg,
    ULONG     RvaOrig
    )
{
    SYMNODE* SymNode = CreateSymbol( ParentSym, SymName, SymSort, SymType, SymSize, RvaInImg, RvaOrig );

    if ( SymNode != NULL )
    {
        if ( PrimarySymTableCount < SymTableMax )
        {
            PrimarySymTable[ PrimarySymTableCount++ ] = SymNode;
        }
    }

    return SymNode;
}


SYMNODE*
PdbSymbolHandler::AddPrimarySymbol(
    SYMNODE*  ParentSym,
    LPCSTR    SymName,
    ULONG     SymSort,
    ULONG     SymType,
    ULONG     SymSize,
    ULONG     RvaInImg
    )
{
    ULONG RvaOrig = TranslateOmapFromImgToSrc( RvaInImg );

    return AddPrimarySymbol( ParentSym, SymName, SymSort, SymType, SymSize, RvaInImg, RvaOrig );
}


SYMNODE*
PdbSymbolHandler::AddFragmentSymbol(
    SYMNODE*  ParentSym,
    LPCSTR    SymName,
    ULONG     SymSort,
    ULONG     SymType,
    ULONG     SymSize,
    ULONG     RvaInImg,
    ULONG     RvaOrig
    )
{
    SYMNODE* SymNode = CreateSymbol( ParentSym, SymName, SymSort, SymType, SymSize, RvaInImg, RvaOrig );

    if ( SymNode != NULL )
    {
        if ( FragmentSymTableCount < FragmentSymTableMax )
        {
            FragmentSymTable[ FragmentSymTableCount++ ] = SymNode;
        }
    }

    return SymNode;
}



SYMNODE*
PdbSymbolHandler::CreateSymbol(
    SYMNODE*  ParentSym,
    LPCSTR    SymName,
    ULONG     SymSort,
    ULONG     SymType,
    ULONG     SymSize,
    ULONG     RvaInImg,
    ULONG     RvaOrig
    )
{
    //
    //  BUGBUG: Deal with duplicate symbols (maybe their type index was
    //          different, but that still leaves us with two identical
    //          addr/symname/symtype objects).
    //

    ASSERT( RvaInImg < 0x80000000 );
    ASSERT(( SymSort >> 16 ) == 0 );
    ASSERT(( SymType >> 16 ) == 0 );

    if ( RvaInImg < 0x80000000 )
    {
        NAMENODE* NameId = NameTable.InsertName( SymName );

        if ( NameId != NULL )
        {
            SYMNODE* SymNode = new SYMNODE;

            if ( SymNode != NULL )
            {
                SymNode->NextSibling = NULL;
                SymNode->FirstChild  = NULL;
                SymNode->OrgNameId   = NULL;
                SymNode->SymNameId   = NameId;
                SymNode->SymSort     = (WORD) SymSort;
                SymNode->SymType     = (WORD) SymType;
                SymNode->SymSize     = SymSize;
                SymNode->RvaInImg    = RvaInImg;
                SymNode->RvaOrig     = RvaOrig;
                SymNode->ParentSym   = ParentSym;

                if ( ParentSym )
                {
                    SymNode->SymSort = (WORD) MIN(( SymSort + ParentSym->SymSort ), 0xFFFF );

                    SYMNODE** Link = &ParentSym->FirstChild;
                    SYMNODE*  Next =  ParentSym->FirstChild;

                    while (( Next ) && ( Next->RvaOrig < RvaOrig ))
                    {
                        Link = &Next->NextSibling;
                        Next =  Next->NextSibling;
                    }

                    SymNode->NextSibling = Next;
                    *Link = SymNode;
                }

                return SymNode;
            }
        }
    }

    return NULL;
}


VOID
__fastcall
PdbSymbolHandler::ConvertDollarSymbols(
    SYMNODE* ParentSym
    )
{
    //
    //  For each child of this parent that is named $L, $S, or $E, change
    //  the name to ascending sequential value.  The sibling list should be
    //  in original RVA ascending order.
    //

    ULONG LastL = 0;
    ULONG LastE = 0;
    ULONG LastS = 0;

    ULONG LastRvaL = 0;
    ULONG LastRvaE = 0;
    ULONG LastRvaS = 0;

    for ( SYMNODE* Child = ParentSym->FirstChild; Child; Child = Child->NextSibling )
    {
        LPCSTR pszName = Child->SymNameId->Name;

        if (( pszName ) && ( pszName[ 0 ] == '$' ))
        {
            switch ( pszName[ 1 ] )
            {
                case 'L':

                    ASSERT( Child->RvaInImg >= LastRvaL );

                    if ( Child->RvaInImg != LastRvaL )
                    {
                        LastRvaL = Child->RvaInImg;
                        ++LastL;
                    }

                    sprintf( szNewSymName, "$LL_%u", LastL );
                    Child->OrgNameId = Child->SymNameId;
                    Child->SymNameId = NameTable.InsertName( szNewSymName );
                    break;

                case 'E':

                    ASSERT( Child->RvaInImg >= LastRvaE );

                    if ( Child->RvaInImg != LastRvaE )
                    {
                        LastRvaE = Child->RvaInImg;
                        ++LastE;
                    }

                    sprintf( szNewSymName, "$EE_%u", LastE );
                    Child->OrgNameId = Child->SymNameId;
                    Child->SymNameId = NameTable.InsertName( szNewSymName );
                    break;

                case 'S':

                    ASSERT( Child->RvaInImg >= LastRvaS );

                    if ( Child->RvaInImg != LastRvaS )
                    {
                        LastRvaS = Child->RvaInImg;
                        ++LastS;
                    }

                    sprintf( szNewSymName, "$SS_%u", LastS );
                    Child->OrgNameId = Child->SymNameId;
                    Child->SymNameId = NameTable.InsertName( szNewSymName );
                    break;

                case '$':

                    break;      // Module\chkstk.obj\$$$00001

                default:

                    DEBUGCODE( printf( "\nUnrecognized $-prefixed symbol %s\n", pszName ));
                    break;

            }
        }

        ConvertDollarSymbols( Child );
    }
}



void
__forceinline
SwapSymTableEntries(
    SYMNODE** One,
    SYMNODE** Two
    )
{
    SYMNODE *Tmp = *One;
            *One = *Two;
            *Two =  Tmp;
}


VOID
__fastcall
QsortSymTableByRvaInImg(
    SYMNODE** LowerBound,
    SYMNODE** UpperBound
    )
{
    SYMNODE** Lower = LowerBound;
    SYMNODE** Upper = UpperBound;
    SYMNODE** Pivot = Lower + (( Upper - Lower ) / 2 );
    ULONG  PivotRva = (*Pivot)->RvaInImg;

    do
    {
        while (( Lower <= Upper ) && ( (*Lower)->RvaInImg <= PivotRva ))
        {
            ++Lower;
        }

        while (( Upper >= Lower ) && ( (*Upper)->RvaInImg >= PivotRva ))
        {
            --Upper;
        }

        if ( Lower < Upper )
        {
            SwapSymTableEntries( Lower++, Upper-- );
        }
    }
    while ( Lower <= Upper );

    if ( Lower < Pivot )
    {
        SwapSymTableEntries( Lower, Pivot );
        Pivot = Lower;
    }
    else if ( Upper > Pivot )
    {
        SwapSymTableEntries( Upper, Pivot );
        Pivot = Upper;
    }

    if ( LowerBound < ( Pivot - 1 ))
    {
        QsortSymTableByRvaInImg( LowerBound, Pivot - 1 );
    }

    if (( Pivot + 1 ) < UpperBound )
    {
        QsortSymTableByRvaInImg( Pivot + 1, UpperBound );
    }
}


VOID
__fastcall
QsortSymTableByRvaInSrc(
    SYMNODE** LowerBound,
    SYMNODE** UpperBound
    )
{
    SYMNODE** Lower = LowerBound;
    SYMNODE** Upper = UpperBound;
    SYMNODE** Pivot = Lower + (( Upper - Lower ) / 2 );
    ULONG  PivotRva = (*Pivot)->RvaOrig;

    do
    {
        while (( Lower <= Upper ) && ( (*Lower)->RvaOrig <= PivotRva ))
        {
            ++Lower;
        }

        while (( Upper >= Lower ) && ( (*Upper)->RvaOrig >= PivotRva ))
        {
            --Upper;
        }

        if ( Lower < Upper )
        {
            SwapSymTableEntries( Lower++, Upper-- );
        }
    }
    while ( Lower <= Upper );

    if ( Lower < Pivot )
    {
        SwapSymTableEntries( Lower, Pivot );
        Pivot = Lower;
    }
    else if ( Upper > Pivot )
    {
        SwapSymTableEntries( Upper, Pivot );
        Pivot = Upper;
    }

    if ( LowerBound < ( Pivot - 1 ))
    {
        QsortSymTableByRvaInSrc( LowerBound, Pivot - 1 );
    }

    if (( Pivot + 1 ) < UpperBound )
    {
        QsortSymTableByRvaInSrc( Pivot + 1, UpperBound );
    }
}


int
__forceinline
__fastcall
MyStrCmp(
    const char* One,
    const char* Two
    )
{
    const unsigned char *p = (const unsigned char*) One;
    const unsigned char *q = (const unsigned char*) Two;

    while (( *p == *q ) && ( *p != 0 ))
    {
        ++p;
        ++q;
    }

    return ( *p - *q );
}


int
__forceinline
__fastcall
SymNodeCompareNames(
    SYMNODE* One,
    SYMNODE* Two
    )
{
    if (( One->SymSort - Two->SymSort ) != 0 )
    {
        return ( One->SymSort - Two->SymSort );
    }

    return strcmp( One->SymNameId->Name, Two->SymNameId->Name );
}


void PdbSymbolHandler::BubbleSortPrimarySymTable( void )
{
    //
    //  Already qsorted by RvaInImg, now fine tune it by name
    //  within each RvaInImg.
    //

    for ( unsigned i = 0; i < PrimarySymTableCount - 1; i++ )
    {
        ULONG RvaInImg = PrimarySymTable[ i ]->RvaInImg;

        for ( unsigned e = i + 1; e < PrimarySymTableCount; e++ )
        {
            if ( PrimarySymTable[ e ]->RvaInImg != RvaInImg )
            {
                break;
            }
        }

        bool Changes = true;

        while (( i < --e ) && ( Changes ))
        {
            Changes = false;

            for ( unsigned j = i; j < e; j++ )
            {
                SYMNODE* p = PrimarySymTable[ j ];
                SYMNODE* q = PrimarySymTable[ j + 1 ];

                ASSERT( p->RvaInImg == q->RvaInImg );

                if ( SymNodeCompareNames( p,  q ) > 0 )
                {
                    SwapSymTableEntries( &PrimarySymTable[ j ], &PrimarySymTable[ j + 1 ] );
                    Changes = true;
                }
            }
        }
    }
}


unsigned
__fastcall
FirstSrcSymTableIndexForRva(
    SYMNODE** SymTableSortedByOrig,
    ULONG     SymTableCount,
    ULONG     RvaInSrc
    )
{
    unsigned Lo = 0;
    unsigned Hi = SymTableCount;

    while ( Lo < Hi )
    {
        unsigned Mi = ( Lo + Hi ) / 2;

        if ( SymTableSortedByOrig[ Mi ]->RvaOrig == RvaInSrc )
        {
            while (( Mi > 0 ) && ( SymTableSortedByOrig[ Mi - 1 ]->RvaOrig == RvaInSrc ))
            {
                --Mi;
            }

            return Mi;
        }
        else if ( SymTableSortedByOrig[ Mi ]->RvaOrig < RvaInSrc )
        {
            Lo = Mi + 1;
        }
        else
        {
            Hi = Mi;
        }
    }

    ASSERT(( Lo == SymTableCount ) || ( SymTableSortedByOrig[ Lo ]->RvaOrig > RvaInSrc ));
    ASSERT(( Lo == 0 ) || ( SymTableSortedByOrig[ Lo - 1 ]->RvaOrig < RvaInSrc ));

    if ( Lo != 0 )
    {
        unsigned NearestRva = SymTableSortedByOrig[ --Lo ]->RvaOrig;

        while (( Lo > 0 ) && ( SymTableSortedByOrig[ Lo - 1 ]->RvaOrig == NearestRva ))
        {
            --Lo;
        }
    }

    ASSERT( Lo < SymTableCount );
    ASSERT( SymTableSortedByOrig[ Lo ]->RvaOrig < RvaInSrc );
    ASSERT(( Lo == 0 ) || ( SymTableSortedByOrig[ Lo - 1 ]->RvaOrig < SymTableSortedByOrig[ Lo ]->RvaOrig ));

    return Lo;
}


extern "C"
LPSTR
__cdecl
__unDName(
    LPSTR  OutputBuffer,
    LPCSTR InputName,
    INT    OutputBufferSize,
    PVOID,
    PVOID,
    USHORT Flags
    );


void
UndecNameForRoughComparison(
    LPCSTR DecoratedName,
    LPSTR  Undecorated
    )
{
    LPCSTR p = DecoratedName;

    *Undecorated = 0;

    while ( *p == '_' )
    {
        ++p;
    }

    if (( p[ 0 ] == 'i' ) &&
        ( p[ 1 ] == 'm' ) &&
        ( p[ 2 ] == 'p' ) &&
        ( p[ 3 ] == '_' ))
    {
        p += 4;

        while ( *p == '_' )
        {
            ++p;
        }
    }

    if ( *p == '?' )
    {
        __unDName( Undecorated, p, 0x10000, malloc, free, UNDNAME_NAME_ONLY );
    }
    else
    {
        //
        //  Strip any preceding '_' or '@'.
        //

        while (( *p == '@' ) || ( *p == '_' ))
        {
            ++p;
        }

        strcpy( Undecorated, p );

        //
        //  Strip any trailing @nnn.
        //

        for ( LPSTR q = Undecorated; *q; q++ )
        {
            if ( *q == '@' )
            {
                 *q = 0;
                 break;
            }
        }
    }
}


VOID
PdbSymbolHandler::DetermineSymbolConfidence(
    VOID
    )
{
    //
    //  At this point the public and image symbols should be loaded.
    //

    PCHAR PeUndecName = (PCHAR) malloc( 0x10000 );
    PCHAR CvUndecName = (PCHAR) malloc( 0x10000 );

    SymsMatched = 0;
    SymsUnmatch = 0;

    ASSERT( PrimarySymTableCount > 1 );

    QsortSymTableByRvaInImg(
        &PrimarySymTable[ 0 ],
        &PrimarySymTable[ PrimarySymTableCount - 1 ]
        );

#if 0
    printf( "\nSyms loaded before DetermineSymbolConfidence:\n" );
    DumpSyms();
    printf( "\n" );
#endif

    for ( unsigned i = 0; i < PrimarySymTableCount; i++ )
    {
        if (( PrimarySymTable[ i ]->SymType == 0xAA85 ) ||   // export by name
            ( PrimarySymTable[ i ]->SymType == 0xAA86 ))     // import by name
        {
            SYMNODE* PeSym = PrimarySymTable[ i ];

            UndecNameForRoughComparison( PeSym->SymNameId->Name, PeUndecName );

            ULONG RvaInImg = PeSym->RvaInImg;

            bool CvSymMatch = false;
            bool Forwarder  = false;

            unsigned j = i;

            while (( j > 0 ) && ( PrimarySymTable[ j - 1 ]->RvaInImg == RvaInImg ))
            {
                --j;
            }

            do
            {
                switch ( PrimarySymTable[ j ]->SymType )
                {
                    case 0xAA95:        // forwarder

                        Forwarder = true;
                        break;

                    case cvsymtLData32_Sz:
                    case cvsymtGData32_Sz:
                    case cvsymtPub32_Sz:
                    case cvsymtLProc32_Sz:
                    case cvsymtGProc32_Sz:

                        UndecNameForRoughComparison( PrimarySymTable[ j ]->SymNameId->Name, CvUndecName );

                        if ( strcmp( PeUndecName, CvUndecName ) == 0 )
                        {
                            CvSymMatch = true;
                            ++SymsMatched;
                        }

                        break;
                }
            }
            while (( ++j < PrimarySymTableCount ) &&
                   ( PrimarySymTable[ j ]->RvaInImg == RvaInImg ));

            if (( ! CvSymMatch ) && ( ! Forwarder ))
            {
                ++SymsUnmatch;

#ifdef DEBUG
                printf( "No pdb symbol name or forwarder for PE import/export:\n" );
                DumpSym( PeSym );

                unsigned j = i;

                while (( j > 0 ) && ( PrimarySymTable[ j - 1 ]->RvaInImg == RvaInImg ))
                {
                    --j;
                }

                do
                {
                    if ( PrimarySymTable[ j ] != PeSym )
                    {
                        printf( "\t" );
                        DumpSym( PrimarySymTable[ j ] );
                    }
                }
                while (( ++j < PrimarySymTableCount ) &&
                       ( PrimarySymTable[ j ]->RvaInImg == RvaInImg ));

                printf( "\n" );
#endif
            }
        }
    }

    free( PeUndecName );
    free( CvUndecName );

    if (( SymsMatched + SymsUnmatch ) != 0 )
    {
        SymConfidence = ( SymsMatched * 100 ) / ( SymsMatched + SymsUnmatch );
    }
    else
    {
        SymConfidence = 100;    // pure forwarder or resource dll
    }
}



BOOL PdbSymbolHandler::ValidateOmap( void )
{
    if (( nOmapToImg == 0 ) && ( nOmapToSrc == 0 ))
    {
        return TRUE;     // no omap to verify
    }

    BOOL Success = TRUE;

    //
    //  Verify both from and to omaps are loaded.
    //

    if ( nOmapToImg == 0 )
    {
        fprintf( stderr, "SYM7: No SrcToImg OMAP table!\n" );
        Success = FALSE;
    }

    if ( nOmapToSrc == 0 )
    {
        fprintf( stderr, "SYM7: No ImgToSrc OMAP table!\n" );
        Success = FALSE;
    }

    //
    //  Verify each omap is sorted ascending by Rva1.
    //

    for ( unsigned i = 0; i < nOmapToImg - 1; i++ )
    {
        if ( pOmapToImg[ i ].Rva1 > pOmapToImg[ i + 1 ].Rva1 )
        {
            fprintf(
                stderr,
                "SYM7: SrcToImg OMAP not sorted ascending: [%u]=%u, [%u]=%u\n",
                i,
                pOmapToImg[ i ].Rva1,
                i + 1,
                pOmapToImg[ i + 1 ].Rva1
                );

            Success = FALSE;
        }
    }

    for ( unsigned i = 0; i < nOmapToSrc - 1; i++ )
    {
        if ( pOmapToSrc[ i ].Rva1 > pOmapToSrc[ i + 1 ].Rva1 )
        {
            fprintf(
                stderr,
                "SYM7: ImgToSrc OMAP not sorted ascending: [%u]=%u, [%u]=%u\n",
                i,
                pOmapToSrc[ i ].Rva1,
                i + 1,
                pOmapToSrc[ i + 1 ].Rva1
                );

            Success = FALSE;
        }
    }

    //
    //  For each Omap entry in ImgToSrc that is nonzero, verify that
    //  SrcToImg entry produces correct round trip value.
    //

    for ( unsigned i = 0; i < nOmapToSrc; i++ )
    {
        if (( pOmapToSrc[ i ].Rva1 != 0 ) &&
            ( pOmapToSrc[ i ].Rva2 != 0 ))
        {
            ULONG RvaInImg1 = pOmapToSrc[ i ].Rva1;
            ULONG RvaInSrc1 = pOmapToSrc[ i ].Rva2;

            ULONG RvaInImg2 = TranslateOmapFromSrcToImg( RvaInSrc1 );

            if ( RvaInImg1 != RvaInImg2 )
            {
                fprintf(
                    stderr,
                    "SYM7: OMAP round trip failed: img %06X -> src %06X\n"
                    "                          but src %06X -> img %06X\n",
                    RvaInImg1,
                    RvaInSrc1,
                    RvaInSrc1,
                    RvaInImg2
                    );

                Success = FALSE;
            }
        }
    }

    //
    //  For each Omap entry in SrcToImg that is nonzero, verify that
    //  ImgToSrc entry produces correct round trip value.
    //

    for ( unsigned i = 0; i < nOmapToImg; i++ )
    {
        if (( pOmapToImg[ i ].Rva1 != 0 ) &&
            ( pOmapToImg[ i ].Rva2 != 0 ))
        {
            ULONG RvaInSrc1 = pOmapToImg[ i ].Rva1;
            ULONG RvaInImg1 = pOmapToImg[ i ].Rva2;

            ULONG RvaInSrc2 = TranslateOmapFromImgToSrc( RvaInImg1 );

            if ( RvaInSrc1 != RvaInSrc2 )
            {
                fprintf(
                    stderr,
                    "SYM7: OMAP round trip failed: src %06X -> img %06X\n"
                    "                          but img %06X -> src %06X\n",
                    RvaInSrc1,
                    RvaInImg1,
                    RvaInImg1,
                    RvaInSrc2
                    );

                Success = FALSE;
            }
        }
    }

    return Success;
}


ULONG
__fastcall
DecimalStrToUnsigned32(
    IN LPCSTR Text
    )
    {
    LPCSTR p = Text;
    ULONG  n = 0;

    //
    //  Very simplistic conversion stops at first non digit character, does
    //  not require null-terminated string, and does not skip any whitespace
    //  or commas.
    //

    while (( *p >= '0' ) && ( *p <= '9' )) {
        n = ( n * 10 ) + ( *p++ - '0' );
        }

    return n;
    }


ULONG
__fastcall
HexStrToUnsigned32(
    IN LPCSTR HexStr
    )
    {
    LPCSTR p = HexStr;
    ULONG  Value = 0;
    ULONG  NewValue;
    ULONG  Digit;

    for (;;) {

        Digit = ( *p++ ) - 0x30;

        NewValue = Value << 4;

        if ( Digit > 9 ) {

            Digit = ( Digit & 0x1F ) - 7;

            if (( Digit > 15 ) || ( Digit < 10 )) {

                return Value;
                }
            }

        Value = NewValue | Digit;

        }
    }


char* __fastcall TimeText( ULONG TimeValue, char* pszBuffer )
{
    //
    //  FILETIME units are 100ns intervals from 01/01/1601.
    //
    //  ULONG units are seconds from 01/01/1970.
    //
    //  There are 10,000,000 FILETIME units in one second.
    //
    //  There are 11,644,473,600 seconds from 01/01/1601 to 01/01/1970.
    //

    #define FILETIME_UNITS_PER_SECOND      10000000
    #define FILETIME_TO_ULONG_OFFSET    11644473600

    SYSTEMTIME SysTime;

    memset( &SysTime, 0, sizeof( SysTime ));

    union
    {
        FILETIME ft;
        QWORD    qw;
    } FileTime;

    FileTime.qw = ( TimeValue + FILETIME_TO_ULONG_OFFSET ) * FILETIME_UNITS_PER_SECOND;

    FileTimeToSystemTime( &FileTime.ft, &SysTime );

    sprintf(
        pszBuffer,
        "%04u/%02u/%02u %02u:%02u:%02u UTC",
        SysTime.wYear,
        SysTime.wMonth,
        SysTime.wDay,
        SysTime.wHour,
        SysTime.wMinute,
        SysTime.wSecond
        );

    return pszBuffer;
}


const struct { unsigned cp; const char* text; } CodePageName[] = {
        {    0,  "ASCII"                     },
        {  874,  "Windows, Thai"             },
        {  932,  "Windows, Japan"            },
        {  936,  "Windows, Chinese"          },
        {  949,  "Windows, Korean"           },
        {  950,  "Windows, Taiwan"           },
        { 1200,  "Unicode"                   },
        { 1250,  "Windows, Eastern European" },
        { 1251,  "Windows, Cyrillic"         },
        { 1252,  "Windows, ANSI"             },
        { 1253,  "Windows, Greek"            },
        { 1254,  "Windows, Turkish"          },
        { 1255,  "Windows, Hebrew"           },
        { 1256,  "Windows, Arabic"           },
        { 1257,  "Windows, Baltic"           },
        { 1361,  "Windows, Korean (Johab)"   }
};



char* __fastcall LangText( ULONG LangValue, char* pszBuffer )
{
    //
    //  Following table was taken from filever.exe sources and updated
    //  from Win32 help files.
    //

    CHAR szLanguage[ 256 ];

    *szLanguage = 0;

    VerLanguageName( LangValue >> 16, szLanguage, sizeof( szLanguage ));

    LangValue &= 0xFFFF;

    CHAR szCpDefault[ 8 ];

    sprintf( szCpDefault, "%u", LangValue );

    const char* pszCodePage = szCpDefault;

    for ( unsigned i = 0; i < ( sizeof( CodePageName ) / sizeof( CodePageName[ 0 ] )); i++ )
    {
        if ( CodePageName[ i ].cp == LangValue )
        {
            pszCodePage = CodePageName[ i ].text;
            break;
        }
    }

    sprintf(
        pszBuffer,
        "%s%s%s",
        szLanguage,
        ( *szLanguage && *pszCodePage ) ? ", " : "",
        pszCodePage
        );

    return pszBuffer;
}


void __declspec( noreturn ) Usage( void )
{
    printf(
        "\n"
        "Usage: sym7 [options] exefile sympath [outfile]\n"
        "\n"
        "            /sizes          show symbol sizes where available\n"
        "            /zeros          show symbols deleted by optimization\n"
        "            /originalrvas   show original pre-optimized addresses\n"
        "            /originalnames  show original symbol names if converted\n"
        "            /confidence:nn  reject if confidence below nn%% (default 50%)\n"
        "            /nopdb          show PE symbols only, don't open pdb file\n"
        "            /nosymfail      if can't open pdb, still show PE symbols\n"
        "\n"
        );
    exit( 1 );
}


void __cdecl main( int argc, char *argv[] )
{
    LPSTR ExeName = NULL;
    LPSTR PdbPath = NULL;
    LPSTR OutName = NULL;
    BOOL  SizeComments = FALSE;
    BOOL  ZeroSymbols  = FALSE;
    BOOL  OriginalRva  = FALSE;
    BOOL  OriginalName = FALSE;
    BOOL  NoPdb        = FALSE;
    BOOL  NoSymFail    = FALSE;
    ULONG Confidence   = 50;

    for ( int arg = 1; arg < argc; arg++ )
    {
        LPSTR p = argv[ arg ];

        if ( strchr( p, '?' ))
        {
            Usage();
        }

        if (( *p == '/' ) || ( *p == '-' ))
        {
            ++p;

            if (( _stricmp( p, "sizes" ) == 0 ) ||
                ( _stricmp( p, "size"  ) == 0 ))
            {
                SizeComments = TRUE;
            }
            else if (( _stricmp( p, "zeros" ) == 0 ) ||
                     ( _stricmp( p, "zero"  ) == 0 ))
            {
                ZeroSymbols = TRUE;
            }
            else if (( _stricmp( p, "originalrva"  ) == 0 ) ||
                     ( _stricmp( p, "originalrvas" ) == 0 ))
            {
                OriginalRva = TRUE;
            }
            else if (( _stricmp( p, "originalname"  ) == 0 ) ||
                     ( _stricmp( p, "originalnames" ) == 0 ))
            {
                OriginalName = TRUE;
            }
            else if (( _stricmp( p, "nopdb" ) == 0 ) ||
                     ( _stricmp( p, "nodbg" ) == 0 ))
            {
                NoPdb     = TRUE;
                NoSymFail = TRUE;
            }
            else if (( _stricmp( p, "nosymfail" ) == 0 ) ||
                     ( _stricmp( p, "nodbgfail" ) == 0 ) ||
                     ( _stricmp( p, "nopdbfail" ) == 0 ))
            {
                NoSymFail = TRUE;
            }
            else if (( _memicmp( p, "confidence:", strlen( "confidence:" )) == 0 ) ||
                     ( _memicmp( p, "conf:",       strlen( "conf:"       )) == 0 ))
            {
                Confidence = strtoul( strchr( p, ':' ) + 1, 0, 10 );
            }
            else
            {
                Usage();
            }
        }
        else if ( ExeName == NULL )
        {
            ExeName = p;
        }
        else if ( PdbPath == NULL )
        {
            PdbPath = p;
        }
        else if ( OutName == NULL )
        {
            OutName = p;
        }
        else
        {
            Usage();
        }
    }

    if ( ExeName == NULL )
    {
        Usage();
    }

    if ( PdbPath == NULL )
    {
        PdbPath = ".";
    }

    PdbSymbolHandler PdbHandler;

    BOOL Success = PdbHandler.OpenExe( ExeName );

    if ( ! Success )
    {
        switch ( GetLastError() )
        {
            case ERROR_FILE_NOT_FOUND:

                fprintf( stderr, "SYM7: Failed to find/open exe %s\n", ExeName );
                break;

            case ERROR_BAD_EXE_FORMAT:

                fprintf( stderr, "SYM7: File %s not a valid Win32 executable image\n", ExeName );
                break;

            default:

                fprintf( stderr, "SYM7: Error %u trying to open %s\n", GetLastError(), ExeName );
                break;
        }

        exit( 1 );
    }

    if (( ! PdbHandler.AnyDebugDirectories   ) &&
        ( ! PdbHandler.AnyExecutableSections ) &&
        ( ! PdbHandler.AnyWritableSections   ))
    {
        //
        //  Usually a resource-only DLL, just generate a PE map.
        //

        NoPdb = TRUE;
    }

    if ( ! NoPdb )
    {
        Success = PdbHandler.OpenPdb( ExeName, PdbPath );

        if ( ! Success )
        {
            if ( NoSymFail )
            {
                fprintf( stderr, "SYM7: WARNING: Could not find/open pdb file for %s\n", ExeName );
            }
            else
            {
                switch ( GetLastError() )
                {
                    case ERROR_FILE_NOT_FOUND:

                        fprintf( stderr, "SYM7: Could not find/open pdb file for %s\n", ExeName );
                        break;

                    case ERROR_OPEN_FAILED:

                        fprintf( stderr, "SYM7: %s %s appears to be corrupt\n", ExeName, PdbHandler.PdbPath );
                        break;

                    default:

                        fprintf( stderr, "SYM7: Error %u trying to find/open pdb file\n", GetLastError() );
                        break;
                }

                exit( 1 );
            }
        }
    }

    Success = PdbHandler.LoadSymbols( Confidence );

    if ( ! Success )
    {
        fprintf( stderr, "SYM7: Failed loading symbols for %s\n", ExeName );
        exit( 1 );
    }

    FILE* outfile = stdout;

    if ( OutName )
    {
        outfile = fopen( OutName, "wt" );

        if ( outfile == NULL )
        {
            fprintf( stderr, "SYM7: Failed to open output file %s\n", OutName );
            exit( 1 );
        }
    }

    static CHAR szBuffer[ 4096 ];

    _strlwr( PdbHandler.ExePath );
    _strlwr( PdbHandler.DbgPath );
    _strlwr( PdbHandler.PdbPath );

    fprintf( outfile, "\n" );
    fprintf( outfile, "[PsymInfo]\n" );
    fprintf( outfile, "\n" );
    fprintf( outfile, "PsymVer=%u.%u\n\n", PsymMajorVersion, PsymMinorVersion );

    if (( PdbHandler.ExeName ) && ( *PdbHandler.ExeName ))
    {
        fprintf( outfile, "ExeName=\"%s\"\n", PdbHandler.ExeName );
    }

    if ( *PdbHandler.ExePath )
    {
        fprintf( outfile, "ExePath=\"%s\"\n", PdbHandler.ExePath );
    }

    if ( PdbHandler.ExeFileMD5.Word32[ 0 ] != 0 )
    {
        Md5ToHexStr( &PdbHandler.ExeFileMD5, szBuffer );
        fprintf( outfile, "ExeHash=%s\n", szBuffer );
    }

    fprintf( outfile, "ExeSize=%08X          ; (%u)\n", PdbHandler.ExeFileSize, PdbHandler.ExeFileSize );

    fprintf( outfile, "ExeTime=%08X          ; (%s)\n", PdbHandler.ExeTime, TimeText( PdbHandler.ExeTime, szBuffer ));

    for ( unsigned i = 0; i < PdbHandler.TranslationCount; i++ )
    {
        DWORD DisplayLang = ( PdbHandler.TranslationArray[ i ] >> 16 ) |
                            ( PdbHandler.TranslationArray[ i ] << 16 );

        fprintf( outfile, "ExeLang=%08X          ; (%s)\n", DisplayLang, LangText( DisplayLang, szBuffer ));
    }

    if ( PdbHandler.ExeVersion != 0 )
    {
        fprintf( outfile, "ExeVer =%016I64X  ; (%u.%u.%u.%u)\n",
            PdbHandler.ExeVersion,
            (WORD)( PdbHandler.ExeVersion >> 48 ),
            (WORD)( PdbHandler.ExeVersion >> 32 ),
            (WORD)( PdbHandler.ExeVersion >> 16 ),
            (WORD)( PdbHandler.ExeVersion >> 0  )
            );
    }

    fprintf( outfile, "\n" );

    if ( *PdbHandler.DbgPath )
    {
        if (( PdbHandler.DbgNameInExe ) && ( *PdbHandler.DbgNameInExe ))
        {
            fprintf( outfile, "DbgName=\"%s\"\n", PdbHandler.DbgNameInExe );
        }
        else if (( PdbHandler.DbgName ) && ( *PdbHandler.DbgName ))
        {
            fprintf( outfile, "DbgName=\"%s\"\n", PdbHandler.DbgName );
        }

        fprintf( outfile, "DbgPath=\"%s\"\n", PdbHandler.DbgPath );

        if ( PdbHandler.DbgFileMD5.Word32[ 0 ] != 0 )
        {
            Md5ToHexStr( &PdbHandler.DbgFileMD5, szBuffer );
            fprintf( outfile, "DbgHash=%s\n", szBuffer );
        }

        fprintf( outfile, "DbgSize=%08X          ; (%u)\n", PdbHandler.DbgFileSize, PdbHandler.DbgFileSize );

        fprintf( outfile, "DbgTime=%08X          ; (%s)\n", PdbHandler.DbgTime, TimeText( PdbHandler.DbgTime, szBuffer ));

        if ( PdbHandler.DbgOmap )
        {
            fprintf( outfile, "DbgOmap=1                 ; (%u,%u)\n", PdbHandler.nOmapToSrc, PdbHandler.nOmapToImg );
        }

        fprintf( outfile, "\n" );
    }

    if ( PdbHandler.pdb )
    {
        if (( PdbHandler.PdbName ) && ( *PdbHandler.PdbName ))
        {
            fprintf( outfile, "PdbName=\"%s\"\n", PdbHandler.PdbName );
        }

        if ( *PdbHandler.PdbPath )
        {
            fprintf( outfile, "PdbPath=\"%s\"\n", PdbHandler.PdbPath );
        }

        if ( PdbHandler.PdbFileMD5.Word32[ 0 ] != 0 )
        {
            Md5ToHexStr( &PdbHandler.PdbFileMD5, szBuffer );
            fprintf( outfile, "PdbHash=%s\n", szBuffer );
        }

        if ( PdbHandler.PdbFileSize != 0 )
        {
            fprintf( outfile, "PdbSize=%08X          ; (%u)\n", PdbHandler.PdbFileSize, PdbHandler.PdbFileSize );
        }

        if ( PdbHandler.PdbTime != 0 )
        {
            fprintf( outfile, "PdbTime=%08X          ; (%s)\n", PdbHandler.PdbTime, TimeText( PdbHandler.PdbTime, szBuffer ));
        }

        if ( PdbHandler.PdbOmap )
        {
            fprintf( outfile, "PdbOmap=1                 ; (%u,%u)\n", PdbHandler.nOmapToSrc, PdbHandler.nOmapToImg );
        }

        if ( PdbHandler.CountOfModSyms )
        {
            fprintf( outfile, "PdbPriv=1                 ; (%u,%u)\n", PdbHandler.CountOfModSyms, PdbHandler.CountOfGlobals );
        }

        fprintf( outfile, "PdbConf=" );

        unsigned cbOut = fprintf( outfile, "%u%%", PdbHandler.SymConfidence );

        fprintf( outfile, "%*s              ; (%u:%u)\n", ( 4 - cbOut ), "", PdbHandler.SymsMatched, PdbHandler.SymsUnmatch );

        fprintf( outfile, "\n" );
    }

#ifdef SYMCOUNTER

    for ( unsigned i = 0; i < 0x4000; i++ )
    {
        if ( SymTypeCounter[ i ] )
        {
            printf( "SymTypeCounter[ 0x%X ] = %u\n", i, SymTypeCounter[ i ] );
        }
    }

    printf( "\n" );

#endif

#ifdef DEBUG

    if ( PdbHandler.dbi )
    {
        PdbHandler.dbi->DumpMods();
    }

    PdbHandler.DumpSyms();

    PdbHandler.DumpOmapToImg();

    PdbHandler.DumpOmapToSrc();

#endif

    if (( SizeComments ) && ( PdbHandler.nOmapToSrc ) && ( PdbHandler.CountOfModSyms ))
    {
        fprintf( outfile, "Note: Module symbol sizes represent original contiguous sizes.\n\n" );
    }

    fprintf( outfile, "[Symbols]\n" );
    fprintf( outfile, "\n" );

    SYMNODE*  LastParentSym = NULL;
    NAMENODE* LastSymNameId = NULL;
    ULONG     LastRva       = 0;

    for ( unsigned i = 0; i < PdbHandler.PrimarySymTableCount; i++ )
    {
        *szBuffer = 0;

        SYMNODE* SymNode = PdbHandler.PrimarySymTable[ i ];

        if (( SymNode->RvaInImg  == LastRva       ) &&
            ( SymNode->SymNameId == LastSymNameId ) &&
            ( SymNode->ParentSym == LastParentSym ))
        {
            //
            //  Don't print duplicate symbols (might be different size/type).
            //

            continue;
        }

        if (( SymNode->RvaInImg == 0 ) && ( SymNode->SymType != 0xAA01 ))
        {
            //
            //  Don't print symbols with address zero (BBT-removed symbols)
            //  unless the symbol is the PE header symbol.
            //

            continue;
        }

        if ( SymNode->SymType == 0xAA03 )   // section header
        {
            fprintf( outfile, "\n" );       // blank line before new section
        }

        PdbHandler.BuildScopedSymbolName( szBuffer, SymNode->ParentSym );

        fprintf(
            outfile,
            "%06X=\"%s%s\"",
            SymNode->RvaInImg,
            szBuffer,
            SymNode->SymNameId->Name
            );

        BOOL CommentSeparatorPrinted = FALSE;

        if (( OriginalRva ) &&
            ( SymNode->RvaOrig != SymNode->RvaInImg ) &&
            ( SymNode->RvaOrig != 0 ))
        {
            if ( ! CommentSeparatorPrinted )
            {
                CommentSeparatorPrinted = TRUE;
                fprintf( outfile, " ;" );
            }

            fprintf( outfile, " (orig=%06X)", SymNode->RvaOrig );
        }

        if (( SizeComments ) && ( SymNode->SymSize != 0 ))
        {
            if ( ! CommentSeparatorPrinted )
            {
                CommentSeparatorPrinted = TRUE;
                fprintf( outfile, " ;" );
            }

            fprintf( outfile, " (size=0x%X)", SymNode->SymSize );
        }

        if (( OriginalName ) && ( SymNode->OrgNameId != NULL ))
        {
            if ( ! CommentSeparatorPrinted )
            {
                CommentSeparatorPrinted = TRUE;
                fprintf( outfile, " ;" );
            }

            fprintf( outfile, " (name=\"%s\")", SymNode->OrgNameId->Name );
        }

        fprintf( outfile, "\n" );

        LastRva       = SymNode->RvaInImg;
        LastSymNameId = SymNode->SymNameId;
        LastParentSym = SymNode->ParentSym;
    }

    fprintf( outfile, "\n" );

    if ( ZeroSymbols )
    {
        LastParentSym = NULL;
        LastSymNameId = NULL;
        LastRva       = 0;

        for ( unsigned i = 0; i < PdbHandler.PrimarySymTableCount; i++ )
        {
            *szBuffer = 0;

            SYMNODE* SymNode = PdbHandler.PrimarySymTable[ i ];

            if (( SymNode->RvaInImg  == LastRva       ) &&
                ( SymNode->SymNameId == LastSymNameId ) &&
                ( SymNode->ParentSym == LastParentSym ))
            {
                //
                //  Don't print duplicate symbols (might be different size/type).
                //

                continue;
            }

            if (( SymNode->RvaInImg != 0 ) || ( SymNode->SymType == 0xAA01 ))
            {
                //
                //  Don't print symbols with non-zero address or PE header.
                //

                continue;
            }

            PdbHandler.BuildScopedSymbolName( szBuffer, SymNode->ParentSym );

            fprintf(
                outfile,
                "%06X=\"%s%s\"",
                SymNode->RvaInImg,
                szBuffer,
                SymNode->SymNameId->Name
                );

            BOOL CommentSeparatorPrinted = FALSE;

            if (( OriginalRva ) &&
                ( SymNode->RvaOrig != SymNode->RvaInImg ) &&
                ( SymNode->RvaOrig != 0 ))
            {
                if ( ! CommentSeparatorPrinted )
                {
                    CommentSeparatorPrinted = TRUE;
                    fprintf( outfile, " ;" );
                }

                fprintf( outfile, " (orig=%06X)", SymNode->RvaOrig );
            }

            if (( SizeComments ) && ( SymNode->SymSize != 0 ))
            {
                if ( ! CommentSeparatorPrinted )
                {
                    CommentSeparatorPrinted = TRUE;
                    fprintf( outfile, " ;" );
                }

                fprintf( outfile, " (size=0x%X)", SymNode->SymSize );
            }

            if (( OriginalName ) && ( SymNode->OrgNameId != NULL ))
            {
                if ( ! CommentSeparatorPrinted )
                {
                    CommentSeparatorPrinted = TRUE;
                    fprintf( outfile, " ;" );
                }

                fprintf( outfile, " (name=\"%s\")", SymNode->OrgNameId->Name );
            }

            fprintf( outfile, "\n" );

            LastRva       = SymNode->RvaInImg;
            LastSymNameId = SymNode->SymNameId;
            LastParentSym = SymNode->ParentSym;
        }

        fprintf( outfile, "\n" );
    }

    exit( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\bldrbld\ldrreloc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

   ldrreloc.c

Abstract:

    This module contains the code to relocate an image when
    the preferred base isn't available. This is called by the
    boot loader, device driver loader, and system loader.

Author:

    Mike O'Leary (mikeol) 03-Feb-1992

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

ULONG
xxxLdrRelocateImage (
    IN PVOID ImageToRelocate,
    IN PVOID LoadAddress,
    IN PUCHAR LoaderName,
    IN ULONG Success,
    IN ULONG Conflict,
    IN ULONG Invalid
    )

/*++

Routine Description:

    This routine relocates an image file that was not loaded into memory
    at the preferred address.

Arguments:

    NewBase - Supplies a pointer to the image base.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    LONG_PTR Diff;
    ULONG TotalCountBytes;
    ULONG_PTR VA;
    ULONG_PTR OldBase;
    ULONG SizeOfBlock;
    PUCHAR FixupVA;
    USHORT Offset;
    PUSHORT NextOffset;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;

    NtHeaders = RtlImageNtHeader( ImageToRelocate );
    if ( NtHeaders ) {
        OldBase = NtHeaders->OptionalHeader.ImageBase;
        }
    else {
        return Invalid;
        }

    //
    // Locate the relocation section.
    //

    NextBlock = (PIMAGE_BASE_RELOCATION)RtlImageDirectoryEntryToData(
            ImageToRelocate, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &TotalCountBytes);

    if (!NextBlock || !TotalCountBytes) {

        //
        // The image does not contain a relocation table, and therefore
        // cannot be relocated.
        //
#if DBG
        DbgPrint("%s: Image can't be relocated, no fixup information.\n", LoaderName);
#endif // DBG
        return Conflict;
    }

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //

    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

        VA = (ULONG_PTR)ImageToRelocate + NextBlock->VirtualAddress;
        Diff = (PCHAR)LoadAddress - (PCHAR)OldBase;

        if ( !(NextBlock = LdrProcessRelocationBlock(VA,SizeOfBlock,NextOffset,Diff)) ) {
#if DBG
            DbgPrint("%s: Unknown base relocation type\n", LoaderName);
#endif
            return Invalid;
        }
    }

    return Success;
}

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    )
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;

    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

                Temp = *(PUSHORT)FixupVA << 16;
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)Temp;
                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\build\build.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994.
//
//  File:       build.c
//
//  Contents:   Parameter processing and main entry point for Build.exe
//
//  History:    16-May-89      SteveWo         Created
//              ...   See SLM log
//              26-Jul-94      LyleC           Cleanup/Add Pass0 support
//              05-Dec-00      sbonev          See SD changelist 2317
//
//----------------------------------------------------------------------------

#include "build.h"

//
// Increase critical section timeout so people don't get
// frightened when the CRT takes a long time to acquire
// its critical section.
//
IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // GlobalFlagsClear
    0,                          // GlobalFlagsSet
    1000 * 60 * 60 * 24,        // CriticalSectionTimeout (milliseconds)
    0,                          // DeCommitFreeBlockThreshold
    0,                          // DeCommitTotalFreeThreshold
    0,                          // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0         // Reserved
};

//
// Target machine info:
//
//  SourceSubDirMask, Description, Switch, MakeVariable,
//  SourceVariable, ObjectVariable, AssociateDirectory,
//  SourceDirectory, ObjectDirectory
//

TARGET_MACHINE_INFO AlphaTargetMachine = {
    TMIDIR_ALPHA, "Alpha", "-alpha", "ALPHA=1",
    "ALPHA_SOURCES", "ALPHA_OBJECTS", "alpha",
    "alpha", "alphadirs", { "alpha" },
    DIR_INCLUDE_ALPHA | DIR_INCLUDE_RISC | DIR_INCLUDE_WIN32
};

TARGET_MACHINE_INFO Alpha64TargetMachine = {
    TMIDIR_ALPHA64, "Alpha64", "-alpha64", "ALPHA64=1",
    "ALPHA64_SOURCES", "ALPHA64_OBJECTS", "alpha",
    "alpha64", "alpha64dirs", { "alpha64" },
    DIR_INCLUDE_ALPHA64 | DIR_INCLUDE_RISC | DIR_INCLUDE_WIN64
};

TARGET_MACHINE_INFO i386TargetMachine = {
    TMIDIR_I386, "i386", "-386", "386=1",
    "i386_SOURCES", "386_OBJECTS", "i386",
    "i386", "i386dirs", { "i386" },
    DIR_INCLUDE_X86 | DIR_INCLUDE_WIN32
};

TARGET_MACHINE_INFO ia64TargetMachine = {
    TMIDIR_IA64, "IA64", "-ia64", "IA64=1",
    "IA64_SOURCES", "IA64_OBJECTS", "ia64",
    "ia64", "ia64dirs", { "ia64" },
    DIR_INCLUDE_IA64 | DIR_INCLUDE_RISC | DIR_INCLUDE_WIN64
};

TARGET_MACHINE_INFO *PossibleTargetMachines[MAX_TARGET_MACHINES] = {
    &AlphaTargetMachine,
    &Alpha64TargetMachine,
    &i386TargetMachine,
    &ia64TargetMachine
};

//
// Machine specific target dirs default. If one there is only one build
// target and a target specific dirs file is selected, then this gets
// filled with a pointer to the target specific dirs filename.
//

LPSTR pszTargetDirs = "";

#define AltDirMaxSize 10            // Maximum size for alternate obj dir name

CHAR LogFileName[sizeof("build.log") + AltDirMaxSize] = "build";
CHAR WrnFileName[sizeof("build.wrn") + AltDirMaxSize] = "build";
CHAR ErrFileName[sizeof("build.err") + AltDirMaxSize] = "build";
CHAR IncFileName[sizeof("build.inc") + AltDirMaxSize] = "build";
CHAR XMLFileName[sizeof("build.xml") + AltDirMaxSize] = "build";

CHAR szObjDir[sizeof("obj") + AltDirMaxSize] = "obj";
CHAR szObjDirSlash[sizeof("obj\\") + AltDirMaxSize] = "obj\\";
CHAR szObjDirSlashStar[sizeof("obj\\*") + AltDirMaxSize] = "obj\\*";

CHAR szObjDirD[] = "objd";
CHAR szObjDirSlashD[] = "objd\\";
CHAR szObjDirSlashStarD[] = "objd\\*";

CHAR *pszObjDir = szObjDir;
CHAR *pszObjDirSlash = szObjDirSlash;
CHAR *pszObjDirSlashStar = szObjDirSlashStar;

BOOL fCheckedBuild = TRUE;
ULONG iObjectDir = 0;

ULONG DefaultProcesses = 0;
CHAR *szBuildTag;

#define MAX_ENV_ARG 512

char szNewLine[] = "\n";
char szUsage[] =
    "Usage: BUILD [-?] display this message\n"
    "\t[-0] pass 0 generation only, no compile, no link\n"
    "\t[-3] same as -Z but will add a third pass zero pass\n"
    "\t[-a] allows synchronized blocks and drains during link pass\n"
    "\t[-b] displays full error message text (doesn't truncate)\n"
    "\t[-B [baseline]] Checks the build failures against a baseline\n"
    "\t\tIf there is no baseline,terminates the build on the first error\n"
    "\t[-c] deletes all object files\n"
    "\t[-C] deletes all .lib files only\n"
#if DBG
    "\t[-d] display debug information\n"
#endif
    "\t[-D] Display warnings/errors/summary in color\n"
    "\t[-e] generates build.log, build.wrn & build.err files\n"
    "\t[-E] always keep the log/wrn/err files (use with -z)\n"
    "\t[-f] force rescan of all source and include files\n"
    "\t[-F] when displaying errors/warnings to stdout, print the full path\n"
    "\t[-G] enables target specific dirs files iff one target\n"
    "\t[-i] ignore extraneous dependency warning messages\n"
    "\t[-k] keep (don't delete) out-of-date targets\n"
    "\t[-l] link only, no compiles\n"
    "\t[-L] compile only, no link phase\n"
    "\t[-m] run build in the idle priority class\n"
    "\t[-M [n]] Multiprocessor build (for MP machines)\n"
    "\t[-n] display thread index if multiprocessor build\n"
    "\t[-o] display out-of-date files\n"
    "\t[-O] generate _objects.mac file for current directory\n"
    "\t[-p] pause' before compile and link phases\n"
    "\t[-P] Print elapsed time after every directory\n"
    "\t[-q] query only, don't run NMAKE\n"
    "\t[-r dirPath] restarts clean build at specified directory path\n"
    "\t[-s] display status line at top of display\n"
    "\t[-S] display status line with include file line counts\n"
    "\t[-t] display the first level of the dependency tree\n"
    "\t[-T] display the complete dependency tree\n"
    "\t[-$] display the complete dependency tree hierarchically\n"
    "\t[-u] display unused BUILD_OPTIONS\n"
    "\t[-v] enable include file version checking\n"
    "\t[-w] show warnings on screen\n"
    "\t[-X] generates build.xml file\n"
    "\t[-Xv] generates verbose build.xml file\n"
    "\t[-y] show files scanned\n"
    "\t[-z] no dependency checking or scanning of source files -\n"
        "\t\tone pass compile/link\n"
    "\t[-Z] no dependency checking or scanning of source files -\n"
        "\t\ttwo passes\n"
    "\t[-why] list reasons for building targets\n"
    "\n"
    "\t[-all] same as -386, -alpha64, -alpha, and -ia64\n"
    "\t[-alpha] build targets for alpha\n"
    "\t[-alpha64] build targets for alpha64\n"
    "\t[-386] build targets for i386\n"
    "\t[-ia64] build targets for IA64\n"
    "\n"
    "\t[-x filename] exclude include file from dependency checks\n"
    "\t[-j filename] use 'filename' as the name for log files\n"
    "\t[-nmake arg] argument to pass to NMAKE\n"
    "\t[-clean] equivalent to '-nmake clean'\n"
    "\tNon-switch parameters specify additional source directories\n";


BOOL
ProcessParameters(int argc, LPSTR argv[]);

VOID
GetEnvParameters(
    LPSTR EnvVarName,
    LPSTR DefaultValue,
    int *pargc,
    int maxArgc,
    LPSTR argv[]);

VOID
FreeEnvParameters(int argc, LPSTR argv[]);

VOID
FreeCmdStrings(VOID);

VOID
MungePossibleTarget(
    PTARGET_MACHINE_INFO pti
    );

VOID
GetIncludePatterns(
    LPSTR EnvVarName,
    int maxArgc,
    LPSTR argv[]);

VOID
FreeIncludePatterns(
    int argc,
    LPSTR argv[]);

BOOL
LoadBaselineFile(VOID);

VOID
FreeBaselineFile(VOID);

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//----------------------------------------------------------------------------

int
__cdecl main(
    int argc,
    LPSTR argv[]
    )
{
    char c;
    PDIRREC DirDB;
    UINT i;
    int EnvArgc;
    LPSTR EnvArgv[ MAX_ENV_ARG ];
    LPSTR s, s1;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    time_t ltime;
#if DBG
    BOOL fDebugSave;
#endif
    EnvArgc = 0;

#if DBG

    fDebug = 0;
#endif

    for (i=3; i<_NFILE; i++) {
        _close( i );
    }

    pGetFileAttributesExA = (BOOL (WINAPI *)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID))
                                GetProcAddress(GetModuleHandle("kernel32.dll"), "GetFileAttributesExA");

    if (pGetFileAttributesExA) {
        pDateTimeFile = DateTimeFile2;
    } else {
        pDateTimeFile = DateTimeFile;
    }

    InitializeCriticalSection(&TTYCriticalSection);

    s1 = getenv("COMSPEC");
    if (s1) {
        cmdexe = s1;
    } else {
        cmdexe = ( _osver & 0x8000 ) ? "command.com" : "cmd.exe";
    }

    memset(&RunningTotals, 0, sizeof(RunningTotals));

    MakeParameters[ 0 ] = '\0';
    MakeTargets[ 0 ] = '\0';
    EnvArgv[ 0 ] = "";
    EnvArgc = 1;
    CountExcludeIncs = 0;

    CountTargetMachines = 0;
    CountOptionalDirs = 0;
    CountExcludeDirs = 0;

    CountPassZeroDirs = 0;
    CountCompileDirs = 0;
    CountLinkDirs = 0;
    CountShowDirs = 0;
    CountIncludeDirs = 0;
    CountSystemIncludeDirs = 0;
    IncludeDirs[CountIncludeDirs++] = NULL;     // Placeholder for compiler
                                                // specific include directory
    AllDirs = NULL;

    fPassZeroOnly = FALSE;
    
    fErrorBaseline = FALSE;
    BaselinePathName[0] = '\0';
    bBaselineFailure = FALSE;
    pvBaselineContent = NULL;
    cbBaselineContentSize = 0;

    fXMLOutput = FALSE;
    fXMLVerboseOutput = FALSE;
    NumberPasses = 0;

    fXMLFragment = FALSE;

    memset(&BuildMetrics, 0, sizeof(BuildMetrics));

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    {
        SYSTEMTIME st;
        FILETIME   ft;

        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);

        FileTimeToDosDateTime( &ft,
                               ((LPWORD)&BuildStartTime)+1,
                               (LPWORD)&BuildStartTime
                             );
    }

    BigBufSize = 0xFFF0;
    AllocMem(BigBufSize, &BigBuf, MT_IOBUFFER);

    // All env parsing should happen here (after the cmd line is processed)

    s = getenv("_NTROOT");
    if (!s)
        s = "\\nt";

    s1 = getenv("_NTDRIVE");
    if (!s1)
        s1 = "";

    sprintf(NtRoot, "%s%s", s1, s);
    sprintf(DbMasterName, "%s\\%s", NtRoot, DBMASTER_NAME);

    s = getenv("BUILD_ALT_DIR");
    if (s) {
        if (strlen(s) > sizeof(szObjDir) - strlen(szObjDir) - 1) {
            BuildError("environment variable BUILD_ALT_DIR may not be longer than %d characters.\n",
                    sizeof(szObjDir) - strlen(szObjDir) - 1);
            exit(1);
        }
        strcat(szObjDir, s);
        strcpy(szObjDirSlash, szObjDir);
        strcpy(szObjDirSlashStar, szObjDir);
        strcat(szObjDirSlash, "\\");
        strcat(szObjDirSlashStar, "\\*");
        strcat(LogFileName, s);
        strcat(WrnFileName, s);
        strcat(ErrFileName, s);
        strcat(IncFileName, s);
        strcat(XMLFileName, s);
    }

    s = getenv("NTDEBUG");
    if (!s || *s == '\0' || strcmp(s, "retail") == 0 || strcmp(s, "ntsdnodbg") == 0) {
        fCheckedBuild = FALSE;
    }

    s = getenv("CRT_INC_PATH");
    if (s) {
        MakeString(&pszIncCrt, s, TRUE, MT_DIRSTRING);
    } else {
        MakeString(&pszIncCrt, "%s\\public\\sdk\\inc\\crt", TRUE, MT_DIRSTRING);
    }
    s = getenv("SDK_INC_PATH");
    if (s) {
        MakeString(&pszIncSdk, s, TRUE, MT_DIRSTRING);
    } else {
        MakeString(&pszIncSdk, "%s\\public\\sdk\\inc", TRUE, MT_DIRSTRING);
    }
    s = getenv("OAK_INC_PATH");
    if (s) {
        MakeString(&pszIncOak, s, TRUE, MT_DIRSTRING);
    } else {
        MakeString(&pszIncOak, "%s\\public\\oak\\inc", TRUE, MT_DIRSTRING);
    }
    s = getenv("DDK_INC_PATH");
    if (s) {
        MakeString(&pszIncDdk, s, TRUE, MT_DIRSTRING);
    } else {
        MakeString(&pszIncDdk, "%s\\public\\ddk\\inc", TRUE, MT_DIRSTRING);
    }
    s = getenv("WDM_INC_PATH");
    if (s) {
        MakeString(&pszIncWdm, s, TRUE, MT_DIRSTRING);
    } else {
        MakeString(&pszIncWdm, "%s\\public\\ddk\\inc\\wdm", TRUE, MT_DIRSTRING);
    }
    s = getenv("ATL_INC_PATH");
    if (s) {
        MakeString(&pszIncAtl, s, TRUE, MT_DIRSTRING);
    } else {
        MakeString(&pszIncAtl, "%s\\public\\ddk\\inc\\atl", TRUE, MT_DIRSTRING);
    }
    s = getenv("PRIVATE_INC_PATH");
    if (s) {
        MakeString(&pszIncPri, s, TRUE, MT_DIRSTRING);
    } else {
        MakeString(&pszIncPri, "%s\\private\\inc", TRUE, MT_DIRSTRING);
    }
    s = getenv("MFC_INCLUDES");
    if (s) {
        MakeString(&pszIncMfc, s, TRUE, MT_DIRSTRING);
    } else {
        MakeString(&pszIncMfc, "%s\\public\\sdk\\inc\\mfc42", TRUE, MT_DIRSTRING);
    }

    szBuildTag = getenv("BUILD_TAG");

    strcpy( MakeParameters, "" );
    MakeParametersTail = AppendString( MakeParameters,
                                       "/c BUILDMSG=Stop.",
                                       FALSE);

    CountFullDebugDirs = 0;
    if (s = getenv("BUILD_FULL_DEBUG")) {
        while (*s) {
            while (*s == ' ') {
                s++;
            }
            if (!*s) {
                break;
            }
            if (CountFullDebugDirs >= MAX_FULL_DEBUG_DIRECTORIES) {
                BuildError(
                    "Ignoring BUILD_FULL_DEBUG list after first %u entries\n",
                    CountFullDebugDirs);
                break;
            }

            s1 = s;
            while (*s1 && *s1 != ' ') {
                s1++;
            }

            c = *s1;
            *s1 = '\0';
            MakeString(
                &FullDebugDirectories[CountFullDebugDirs++],
                s,
                TRUE,
                MT_CMDSTRING);

            *s1 = c;
            s = s1;
        }
    }

    RecurseLevel = 0;

#if DBG
    if ((s = getenv("BUILD_DEBUG_FLAG")) != NULL) {
        i = atoi(s);
        if (!isdigit(*s)) {
            i = 1;
        }
        BuildMsg("Debug Output Enabled: %u ==> %u\n", fDebug, fDebug | i);
        fDebug |= i;
    }
#endif

    if (!(MakeProgram = getenv( "BUILD_MAKE_PROGRAM" ))) {
        MakeProgram = "NMAKE.EXE";
    }

    SystemIncludeEnv = getenv( "INCLUDE" );
    GetCurrentDirectory( sizeof( CurrentDirectory ), CurrentDirectory );

    for (i = 0; i < MAX_TARGET_MACHINES; i++) {
        TargetMachines[i] = NULL;
        TargetToPossibleTarget[i] = 0;
        MungePossibleTarget(PossibleTargetMachines[i]);
    }

    // prepare the command line in the XML buffer in case we need it
    strcpy(szXMLBuffer, "CMDLINE=\"");
    XMLEncodeBuiltInEntitiesCopy(GetCommandLine(), szXMLBuffer + strlen(szXMLBuffer));
    strcat(szXMLBuffer, "\"");

    if (!ProcessParameters( argc, argv )) {
        fUsage = TRUE;
    } else {
        int CurrentEnvArgc = EnvArgc;
        GetEnvParameters( "BUILD_DEFAULT", NULL, &EnvArgc, MAX_ENV_ARG, EnvArgv );
        if (CurrentEnvArgc != EnvArgc) {
            strcat(szXMLBuffer, " BUILD_DEFAULT=\"");
            while (CurrentEnvArgc < EnvArgc) {
                XMLEncodeBuiltInEntitiesCopy(EnvArgv[CurrentEnvArgc], szXMLBuffer + strlen(szXMLBuffer));
                strcat(szXMLBuffer, " ");
                CurrentEnvArgc++;
            }
            strcat(szXMLBuffer, "\"");
        }
        CurrentEnvArgc = EnvArgc;
        GetEnvParameters( "BUILD_OPTIONS", NULL, &EnvArgc, MAX_ENV_ARG, EnvArgv );
        if (CurrentEnvArgc != EnvArgc) {
            strcat(szXMLBuffer, " BUILD_OPTIONS=\"");
            while (CurrentEnvArgc < EnvArgc) {
                XMLEncodeBuiltInEntitiesCopy(EnvArgv[CurrentEnvArgc], szXMLBuffer + strlen(szXMLBuffer));
                strcat(szXMLBuffer, " ");
                CurrentEnvArgc++;
            }
            strcat(szXMLBuffer, "\"");
        }
        if (CountTargetMachines == 0) {
            if ( getenv("PROCESSOR_ARCHITECTURE") == NULL ) {
                BuildError("environment variable PROCESSOR_ARCHITECTURE must be defined\n");
                exit(1);
            }

            CurrentEnvArgc = EnvArgc;
            if (!strcmp(getenv("PROCESSOR_ARCHITECTURE"), "ALPHA64"))
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-alpha64", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            else
            if (!strcmp(getenv("PROCESSOR_ARCHITECTURE"), "ALPHA"))
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-alpha", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            else
            if (!strcmp(getenv("PROCESSOR_ARCHITECTURE"), "IA64"))
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-ia64", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            else
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-386", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            if (CurrentEnvArgc != EnvArgc) {
                strcat(szXMLBuffer, " BUILD_DEFAULT_TARGETS=\"");
                while (CurrentEnvArgc < EnvArgc) {
                    XMLEncodeBuiltInEntitiesCopy(EnvArgv[CurrentEnvArgc], szXMLBuffer + strlen(szXMLBuffer));
                    strcat(szXMLBuffer, " ");
                    CurrentEnvArgc++;
                }
                strcat(szXMLBuffer, "\"");
            }
        }
        if (!ProcessParameters( EnvArgc, EnvArgv )) {
            fUsage = TRUE;
        }
    }
    FreeEnvParameters(EnvArgc, EnvArgv);

    GetIncludePatterns( "BUILD_ACCEPTABLE_INCLUDES", MAX_INCLUDE_PATTERNS, AcceptableIncludePatternList );
    GetIncludePatterns( "BUILD_UNACCEPTABLE_INCLUDES", MAX_INCLUDE_PATTERNS, UnacceptableIncludePatternList );

    if (( fCheckIncludePaths ) &&
        ( AcceptableIncludePatternList[ 0 ] == NULL ) &&
        ( UnacceptableIncludePatternList[ 0 ] == NULL )) {

        BuildMsgRaw( "WARNING: -# specified without BUILD_[UN]ACCEPTABLE_INCLUDES set\n" );
    }

    if (fCleanRestart) {
        if (fClean) {
            fClean = FALSE;
            fRestartClean = TRUE;
        }
        else
        if (fCleanLibs) {
            fCleanLibs = FALSE;
            fRestartCleanLibs = TRUE;
        }
        else {
            BuildError("/R switch only valid with /c or /C switch.\n");
            fUsage = TRUE;
        }
    }

    NumberProcesses = 1;
    if (fParallel || getenv("BUILD_MULTIPROCESSOR")) {
        SYSTEM_INFO SystemInfo;

        if (DefaultProcesses == 0) {
            GetSystemInfo(&SystemInfo);
            NumberProcesses = SystemInfo.dwNumberOfProcessors;
        } else {
            NumberProcesses = DefaultProcesses;
        }
        if (NumberProcesses == 1) {
            fParallel = FALSE;
        } else {
            fParallel = TRUE;
            BuildMsg("Using %d child processes\n", NumberProcesses);
        }
    }

    XMLStartTicks = GetTickCount();
    time(&ltime);
    if (fPrintElapsed) {
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN);
        BuildMsg("Start time: %s", ctime(&ltime));
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
    }

    if (fColorConsole)
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN);
    BuildMsg("Object root set to: ==> %s\n", szObjDir);
    if (fColorConsole)
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);

    if (fUsage) {
        BuildMsgRaw(
            "\nBUILD: Version %x.%02x for Xbox. (Based on build 4.20 for Visual Studio)\n\n",
            BUILD_VERSION >> 8,
            BUILD_VERSION & 0xFF);
        BuildMsgRaw(szUsage);
    }
    else
    if (CountTargetMachines != 0) {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN);
        BuildError(
            "%s for ",
            fLinkOnly? "Link" : (fCompileOnly? "Compile" : "Compile and Link"));
        for (i = 0; i < CountTargetMachines; i++) {
            BuildErrorRaw(i==0? "%s" : ", %s", TargetMachines[i]->Description);
            AppendString(
                MakeTargets,
                TargetMachines[i]->MakeVariable,
                TRUE);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        }

        BuildErrorRaw(szNewLine);

        //
        // If there is one and only one build target and target dirs has
        // been enabled, then fill in the appropriate target dirs name.
        //

        if (CountTargetMachines == 1) {
            if (fTargetDirs == TRUE) {
                pszTargetDirs = TargetMachines[0]->TargetDirs;
                FileDesc[0].pszPattern = TargetMachines[0]->TargetDirs;
            }
        }

        if (DEBUG_1) {
            if (CountExcludeIncs) {
                BuildError("Include files that will be excluded:");
                for (i = 0; i < CountExcludeIncs; i++) {
                    BuildErrorRaw(i == 0? " %s" : ", %s", ExcludeIncs[i]);
                }
                BuildErrorRaw(szNewLine);
            }
            if (CountOptionalDirs) {
                BuildError("Optional Directories that will be built:");
                for (i = 0; i < CountOptionalDirs; i++) {
                    BuildErrorRaw(i == 0? " %s" : ", %s", OptionalDirs[i]);
                }
                BuildErrorRaw(szNewLine);
            }
            if (CountExcludeDirs) {
                BuildError("Directories that will be NOT be built:");
                for (i = 0; i < CountExcludeDirs; i++) {
                    BuildErrorRaw(i == 0? " %s" : ", %s", ExcludeDirs[i]);
                }
                BuildErrorRaw(szNewLine);
            }
            BuildMsg("MakeParameters == %s\n", MakeParameters);
            BuildMsg("MakeTargets == %s\n", MakeTargets);
        }

#if DBG
        fDebugSave = fDebug;
        // fDebug = 0;
#endif

        //
        // Generate the _objects.mac file if requested
        //

        if (fGenerateObjectsDotMacOnly) {
            DIRSUP DirSup;
            ULONG DateTimeSources;

            DirDB = ScanDirectory( CurrentDirectory );

            if (DirDB && (DirDB->DirFlags & (DIRDB_DIRS | DIRDB_SOURCES))) {
                FreeBaselineFile();

                if (!ReadSourcesFile(DirDB, &DirSup, &DateTimeSources)) {
                    BuildError("Current directory not a SOURCES directory.\n");
                    return( 1 );
                }

                GenerateObjectsDotMac(DirDB, &DirSup, DateTimeSources);

                FreeDirSupData(&DirSup);
                ReportDirsUsage();
                FreeCmdStrings();
                ReportMemoryUsage();
                return(0);
            }
        }

        if (!fQuery && fErrorLog) {
            strcat(LogFileName, ".log");
            if (!MyOpenFile(".", LogFileName, "wb", &LogFile, TRUE)) {
                BuildError("(Fatal Error) Unable to open log file\n");
                exit( 1 );
            }
            CreatedBuildFile(".", LogFileName);

            strcat(WrnFileName, ".wrn");
            if (!MyOpenFile(".", WrnFileName, "wb", &WrnFile, FALSE)) {
                BuildError("(Fatal Error) Unable to open warning file\n");
                exit( 1 );
            }
            CreatedBuildFile(".", WrnFileName);

            strcat(ErrFileName, ".err");
            if (!MyOpenFile(".", ErrFileName, "wb", &ErrFile, FALSE)) {
                BuildError("(Fatal Error) Unable to open error file\n");
                exit( 1 );
            }
            CreatedBuildFile(".", ErrFileName);
            if ( fCheckIncludePaths ) {

                strcat( IncFileName, ".inc");
                if (!MyOpenFile( ".", IncFileName, "wb", &IncFile, FALSE ) ) {
                    BuildError( "(Fatal Error) Unable to open include log file\n");
                    exit( 1 );
                }
                CreatedBuildFile( ".", IncFileName );
            }
        }
        else {
            LogFile = NULL;
            WrnFile = NULL;
            ErrFile = NULL;
            IncFile = NULL;
        }

        // in case of query only we are not going to produce XML file
        if (fQuery) {
            fXMLOutput = FALSE;
        }

        // set the XML output file
        if (fXMLOutput) {
            strcat(XMLFileName, ".xml");
            if (!MyOpenFile(".", XMLFileName, "wb", &XMLFile, FALSE)) {
                BuildError("(Fatal Error) Unable to open XML file\n");
                exit( 1 );
            }
            CreatedBuildFile(".", XMLFileName);

            if (!XMLInit()) {
                exit( 1 );
            }
        }
        else {
            XMLFile = NULL;
        }

        sprintf(szXMLBuffer + strlen(szXMLBuffer), " TIME=\"%s\" CURRENTDIR=\"%s\"", ctime(&ltime), CurrentDirectory);
        if (fXMLOutput) {
            XMLGlobalWrite("<?xml version=\"1.0\"?>");
            XMLGlobalOpenTag("BUILD",  "xmlns=\"x-schema:buildschema.xml\"");
            XMLGlobalWrite("<START %s/>", szXMLBuffer);
            XMLUpdateEndTag(FALSE);
        }
        if (fXMLFragment) {
            XMLWriteFragmentFile("START", "<BUILD %s/>", szXMLBuffer);
        }

        //
        // The user should not have CHICAGO_PRODUCT in
        // their environment, as it can cause problems on other machines with
        // other users that don't have them set.  The following warning
        // messages are intended to alert the user to the presence of these
        // environment variables.
        //
        if (getenv("CHICAGO_PRODUCT") != NULL) {
            BuildError("CHICAGO_PRODUCT was detected in the environment.\n" );
            BuildMsg("   ALL directories will be built targeting Chicago!\n" );
            fChicagoProduct = TRUE;
        }

        if (!fQuicky) {
            LoadMasterDB();

            BuildError("Computing Include file dependencies:\n");

            ScanIncludeEnv(SystemIncludeEnv);
            ScanIncludeDir(pszIncMfc);
            ScanIncludeDir(pszIncOak);
            ScanIncludeDir(pszIncDdk);
            ScanIncludeDir(pszIncWdm);
            ScanIncludeDir(pszIncSdk);
            ScanIncludeDir(pszIncPri);
            CountSystemIncludeDirs = CountIncludeDirs;
        }

#if DBG
        fDebug = fDebugSave;
#endif
        fFirstScan = TRUE;
        fPassZero  = FALSE;
        ScanSourceDirectories( CurrentDirectory );

        if (!fQuicky) {
            if (SaveMasterDB() == FALSE) {
                BuildError("Unable to save the dependency database: %s\n", DbMasterName);
            }
        }

        c = '\n';
        if (!fLinkOnly && CountPassZeroDirs && !bBaselineFailure) {
            if (!fQuicky) {
                TotalFilesToCompile = 0;
                TotalLinesToCompile = 0L;

                for (i=0; i<CountPassZeroDirs; i++) {
                    DirDB = PassZeroDirs[ i ];

                    TotalFilesToCompile += DirDB->CountOfPassZeroFiles;
                    TotalLinesToCompile += DirDB->PassZeroLines;
                    }

                if (CountPassZeroDirs > 1 &&
                    TotalFilesToCompile != 0 &&
                    TotalLinesToCompile != 0L) {

                    BuildMsgRaw(
                        "Total of %d pass zero files (%s lines) to compile in %d directories\n\n",
                         TotalFilesToCompile,
                         FormatNumber( TotalLinesToCompile ),
                         CountPassZeroDirs);
                }
            }

            TotalFilesCompiled    = 0;
            TotalLinesCompiled    = 0L;
            ElapsedCompileTime    = 0L;

            if (fPause) {
                BuildMsg("Press enter to continue with compilations (or 'q' to quit)...");
                c = (char)getchar();
            }

            if ((CountPassZeroDirs > 0) && (c == '\n') && !bBaselineFailure) {
                DWORD dwStartTime = GetTickCount();
                if (fXMLOutput) {
                    XMLGlobalOpenTag("PASS", "NUMBER=\"0\"");
                }
                if (fXMLFragment) {
                    XMLWriteFragmentFile("PASS0", "<PASS NUMBER=\"0\"/>");
                }
                memset(&PassMetrics, 0, sizeof(PassMetrics));
                CompilePassZeroDirectories();
                WaitForParallelThreads();

                AddBuildMetrics(&BuildMetrics, &PassMetrics);
                if (fXMLOutput || fXMLFragment) {
                    sprintf(szXMLBuffer, "DIRS=\"%d\" ELAPSED=\"%s\" ", CountPassZeroDirs, FormatElapsedTime(dwStartTime));
                    strcat(szXMLBuffer, XMLBuildMetricsString(&PassMetrics));
                    NumberPasses++;
                    if (fXMLOutput) {
                        XMLGlobalWrite("<PASSSUMMARY %s/>", szXMLBuffer);
                        XMLGlobalCloseTag();
                        XMLUpdateEndTag(FALSE);
                    }
                    if (fXMLFragment) {
                        XMLWriteFragmentFile("PASS0SUMMARY", "<PASSSUMMARY %s/>", szXMLBuffer);
                    }
                }

                //
                // Rescan now that we've generated all the generated files
                //
                CountPassZeroDirs = 0;
                CountCompileDirs = 0;
                CountLinkDirs = 0;

                UnsnapAllDirectories();

                fPassZero = FALSE;
                fFirstScan = FALSE;
                RecurseLevel = 0;

                if (!fPassZeroOnly) {
                    ScanSourceDirectories( CurrentDirectory );
                } else {
                    BuildMsg("Pass Zero Completed\n");
                }

                if (!fQuicky) {
                    if (SaveMasterDB() == FALSE) {
                        BuildError("Unable to save the dependency database: %s\n", DbMasterName);
                    }
                }
            }
        }

        if (!fPassZeroOnly && !fLinkOnly && (c == '\n') && !bBaselineFailure) {
            if (!fQuicky) {
                TotalFilesToCompile = 0;
                TotalLinesToCompile = 0L;

                for (i=0; i<CountCompileDirs; i++) {
                    DirDB = CompileDirs[ i ];

                    TotalFilesToCompile += DirDB->CountOfFilesToCompile;
                    TotalLinesToCompile += DirDB->SourceLinesToCompile;
                    }

                if (CountCompileDirs > 1 &&
                    TotalFilesToCompile != 0 &&
                    TotalLinesToCompile != 0L) {

                    BuildMsgRaw(
                        "Total of %d source files (%s lines) to compile in %d directories\n\n",
                         TotalFilesToCompile,
                         FormatNumber( TotalLinesToCompile ),
                         CountCompileDirs);
                }
            }

            TotalFilesCompiled    = 0;
            TotalLinesCompiled    = 0L;
            ElapsedCompileTime    = 0L;

            if (fPause) {
                BuildMsg("Press enter to continue with compilations (or 'q' to quit)...");
                c = (char)getchar();
            }

            if (c == '\n' && !bBaselineFailure) {
                DWORD dwStartTime = GetTickCount();
                if (fXMLOutput) {
                    XMLGlobalOpenTag("PASS", "NUMBER=\"1\"");
                }
                if (fXMLFragment) {
                    XMLWriteFragmentFile("PASS1", "<PASS NUMBER=\"1\"/>");
                }
                memset(&PassMetrics, 0, sizeof(PassMetrics));
                CompileSourceDirectories();
                WaitForParallelThreads();

                AddBuildMetrics(&BuildMetrics, &PassMetrics);
                if (fXMLOutput || fXMLFragment) {
                    sprintf(szXMLBuffer, "DIRS=\"%d\" ELAPSED=\"%s\" ", CountCompileDirs, FormatElapsedTime(dwStartTime));
                    strcat(szXMLBuffer, XMLBuildMetricsString(&PassMetrics));
                    NumberPasses++;
                    if (fXMLOutput) {
                        XMLGlobalWrite("<PASSSUMMARY %s/>", szXMLBuffer);
                        XMLGlobalCloseTag();
                        XMLUpdateEndTag(FALSE);
                    }
                    if (fXMLFragment) {
                        XMLWriteFragmentFile("PASS1SUMMARY", "<PASSSUMMARY %s/>", szXMLBuffer);
                    }
                }
            }
        }

        if (!fPassZeroOnly && !fCompileOnly && (c == '\n') && !bBaselineFailure) {
            DWORD dwStartTime = GetTickCount();
            if (fXMLOutput) {
                XMLGlobalOpenTag("PASS", "NUMBER=\"2\"");
            }
            if (fXMLFragment) {
                XMLWriteFragmentFile("PASS2", "<PASS NUMBER=\"2\"/>");
            }
            memset(&PassMetrics, 0, sizeof(PassMetrics));
            LinkSourceDirectories();
            WaitForParallelThreads();

            AddBuildMetrics(&BuildMetrics, &PassMetrics);
            if (fXMLOutput || fXMLFragment) {
                sprintf(szXMLBuffer, "DIRS=\"%d\" ELAPSED=\"%s\" ", CountLinkDirs, FormatElapsedTime(dwStartTime));
                strcat(szXMLBuffer, XMLBuildMetricsString(&PassMetrics));
                NumberPasses++;
                if (fXMLOutput) {
                    XMLGlobalWrite("<PASSSUMMARY %s/>", szXMLBuffer);
                    XMLGlobalCloseTag();
                    XMLUpdateEndTag(FALSE);
                }
                if (fXMLFragment) {
                    XMLWriteFragmentFile("PASS2SUMMARY", "<PASSSUMMARY %s/>", szXMLBuffer);
                }
            }
        }

        if (fShowTree) {
            for (i = 0; i < CountShowDirs; i++) {
                PrintDirDB(ShowDirs[i], 1|4);
            }
        }
    }
    else {
        BuildError("No target machine specified\n");
    }

    // moved the end time before the log files are closed so we can put it into the XML file
    time(&ltime);

    if (fXMLOutput) {
        XMLUpdateEndTag(TRUE);
        XMLGlobalCloseTag();    // BUILD
    }
    if (fXMLFragment) {
        sprintf(szXMLBuffer, "TIME=\"%s\" ELAPSED=\"%s\" PASSES=\"%d\" COMPLETED=\"1\" ", ctime(&ltime), FormatElapsedTime(XMLStartTicks), NumberPasses);
        strcat(szXMLBuffer, XMLBuildMetricsString(&BuildMetrics));
        XMLWriteFragmentFile("END", "<END %s/>", szXMLBuffer);
    }

    if (!fUsage && !fQuery && fErrorLog) {
        ULONG cbLogMin = 32;
        ULONG cbWarnMin = 0;

        if (!fAlwaysKeepLogfile) {
            if (fQuicky && !fSemiQuicky && ftell(ErrFile) == 0) {
                cbLogMin = cbWarnMin = ULONG_MAX;
            }
        }
        CloseOrDeleteFile(&LogFile, LogFileName, cbLogMin);
        CloseOrDeleteFile(&WrnFile, WrnFileName, cbWarnMin);
        CloseOrDeleteFile(&ErrFile, ErrFileName, 0L);
        if ( fCheckIncludePaths ) {
            CloseOrDeleteFile(&IncFile, IncFileName, cbLogMin);
        }
        CloseOrDeleteFile(&XMLFile, XMLFileName, 0L);
    }

    if (bBaselineFailure) {
        BuildError(BaselinePathName[0] != '\0' ? 
            "Diffs from baseline\n" :
            "Terminated at the first error encountered\n");
    }
    
    if (fPrintElapsed) {
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN);
        BuildMsg("Finish time: %s", ctime(&ltime));
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
    }

    if (fColorConsole)
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN);
    BuildError("Done\n\n");
    if (fColorConsole)
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);

    if (RunningTotals.NumberCompiles) {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);

        BuildMsgRaw("    %d files compiled", RunningTotals.NumberCompiles);
        if (RunningTotals.NumberCompileWarnings) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);
            BuildMsgRaw(" - %d Warnings", RunningTotals.NumberCompileWarnings);
        }
        if (RunningTotals.NumberCompileErrors) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
            BuildMsgRaw(" - %d Errors", RunningTotals.NumberCompileErrors);
        }

        if (ElapsedCompileTime) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);
            BuildMsgRaw(" - %5ld LPS", TotalLinesCompiled / ElapsedCompileTime);
        }

        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        BuildMsgRaw(szNewLine);
    }

    if (RunningTotals.NumberLibraries) {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);

        BuildMsgRaw("    %d libraries built", RunningTotals.NumberLibraries);
        if (RunningTotals.NumberLibraryWarnings) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);
            BuildMsgRaw(" - %d Warnings", RunningTotals.NumberLibraryWarnings);
        }
        if (RunningTotals.NumberLibraryErrors) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
            BuildMsgRaw(" - %d Errors", RunningTotals.NumberLibraryErrors);
        }

        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        BuildMsgRaw(szNewLine);
    }

    if (RunningTotals.NumberLinks) {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);

        BuildMsgRaw("    %d executables built", RunningTotals.NumberLinks);
        if (RunningTotals.NumberLinkWarnings) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);
            BuildMsgRaw(" - %d Warnings", RunningTotals.NumberLinkWarnings);
        }
        if (RunningTotals.NumberLinkErrors) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
            BuildMsgRaw(" - %d Errors", RunningTotals.NumberLinkErrors);
        }

        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        BuildMsgRaw(szNewLine);
    }

    if (RunningTotals.NumberBSCMakes) {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);

        BuildMsgRaw("    %d browse databases built", RunningTotals.NumberBSCMakes);
        if (RunningTotals.NumberBSCWarnings) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);
            BuildMsgRaw(" - %d Warnings", RunningTotals.NumberBSCWarnings);
        }
        if (RunningTotals.NumberBSCErrors) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
            BuildMsgRaw(" - %d Errors", RunningTotals.NumberBSCErrors);
        }

        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        BuildMsgRaw(szNewLine);
    }

    if (RunningTotals.NumberVSToolErrors + RunningTotals.NumberVSToolWarnings > 0)
    {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

        if (RunningTotals.NumberVSToolWarnings) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);
            BuildMsgRaw("    %d VS Tool Warnings\n", RunningTotals.NumberVSToolWarnings);
        }
        if (RunningTotals.NumberVSToolErrors) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
            BuildMsgRaw("    %d VS Tool Errors\n", RunningTotals.NumberVSToolErrors);
        }

        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
    }

    ReportDirsUsage();
    if (fXMLOutput) XMLUnInit();
    FreeBaselineFile();
    FreeCmdStrings();
    FreeIncludePatterns( MAX_INCLUDE_PATTERNS, AcceptableIncludePatternList );
    FreeIncludePatterns( MAX_INCLUDE_PATTERNS, UnacceptableIncludePatternList );
    ReportMemoryUsage();

    if (bBaselineFailure)
        return 2;

    if (RunningTotals.NumberCompileErrors || RunningTotals.NumberLibraryErrors || RunningTotals.NumberLinkErrors || RunningTotals.NumberVSToolErrors) {
        return 1;
    }
    else {
        return( 0 );
    }
}


VOID
ReportDirsUsage( VOID )
{
    ULONG i;
    BOOLEAN fHeaderPrinted;

    if (!fShowUnusedDirs) {
        return;
    }

    fHeaderPrinted = FALSE;
    for (i=0; i<CountOptionalDirs; i++) {
        if (!OptionalDirsUsed[i]) {
            if (!fHeaderPrinted) {
                printf( "Unused BUILD_OPTIONS:" );
                fHeaderPrinted = TRUE;
            }
            printf( " %s", OptionalDirs[i] );
        }
    }

    for (i=0; i<CountExcludeDirs; i++) {
        if (!ExcludeDirsUsed[i]) {
            if (!fHeaderPrinted) {
                printf( "Unused BUILD_OPTIONS:" );
                fHeaderPrinted = TRUE;
            }
            printf( " ~%s", ExcludeDirs[i] );
        }
    }

    if (fHeaderPrinted) {
        printf( "\n" );
    }

    fHeaderPrinted = FALSE;
    for (i = 0; i < CountFullDebugDirs; i++) {
        if (!FullDebugDirsUsed[i]) {
            if (!fHeaderPrinted) {
                printf( "Unused BUILD_FULL_DEBUG:" );
                fHeaderPrinted = TRUE;
            }
            printf( " %s", FullDebugDirectories[i] );
        }
    }
    if (fHeaderPrinted) {
        printf( "\n" );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SetObjDir
//
//----------------------------------------------------------------------------

VOID
SetObjDir(BOOL fAlternate)
{
    iObjectDir = 0;
    if (fCheckedBuild) {
        if (fAlternate) {
            pszObjDir = szObjDirD;
            pszObjDirSlash = szObjDirSlashD;
            pszObjDirSlashStar = szObjDirSlashStarD;
            iObjectDir = 1;
        } else {
            pszObjDir = szObjDir;
            pszObjDirSlash = szObjDirSlash;
            pszObjDirSlashStar = szObjDirSlashStar;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   AddTargetMachine
//
//----------------------------------------------------------------------------

VOID
AddTargetMachine(UINT iTarget)
{
    UINT i;

    for (i = 0; i < CountTargetMachines; i++) {
        if (TargetMachines[i] == PossibleTargetMachines[iTarget]) {
            assert(TargetToPossibleTarget[i] == iTarget);
            return;
        }
    }
    assert(CountTargetMachines < MAX_TARGET_MACHINES);
    TargetToPossibleTarget[CountTargetMachines] = iTarget;
    TargetMachines[CountTargetMachines++] = PossibleTargetMachines[iTarget];
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessParameters
//
//----------------------------------------------------------------------------

BOOL
ProcessParameters(
    int argc,
    LPSTR argv[]
    )
{
    char c, *p;
    int i;
    BOOL Result;

    if (DEBUG_1) {
        BuildMsg("Parsing:");
        for (i=1; i<argc; i++) {
            BuildMsgRaw(" %s", argv[i]);
        }
        BuildMsgRaw(szNewLine);
    }

    Result = TRUE;
    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            if (DEBUG_1) {
                BuildMsg("Processing \"-%s\" switch\n", p+1);
            }

            for (i = 0; i < MAX_TARGET_MACHINES; i++) {
                if (!_stricmp(p, PossibleTargetMachines[i]->Switch)) {
                    AddTargetMachine(i);
                    break;
                }
            }

            if (i < MAX_TARGET_MACHINES) {
            }
            else
            if (!_stricmp(p + 1, "all")) {
                for (i = 0; i < MAX_TARGET_MACHINES; i++) {
                    AddTargetMachine(i);
                }
            }
            else
            if (!_stricmp(p + 1, "why")) {
                fWhyBuild = TRUE;
            }
            else
            while (c = *++p)
                switch (toupper( c )) {
            case '?':
                fUsage = TRUE;
                break;
                
            case '0':
                fPassZeroOnly = TRUE;
                break;
                
            case '3':
                fQuickZero = TRUE;
                fSemiQuicky = TRUE;
                fQuicky = TRUE;
                break;

            case 'A':
                fSyncLink = TRUE;
                break;

            case 'J': {

                argc--, argv++;

                // Clear it out
                memset(LogFileName, 0, sizeof(LogFileName));
                memset(WrnFileName, 0, sizeof(WrnFileName));
                memset(ErrFileName, 0, sizeof(ErrFileName));
                memset(IncFileName, 0, sizeof(IncFileName));
                memset(XMLFileName, 0, sizeof(XMLFileName));

                // And set it to the arg passed in.
                strncpy(LogFileName, *argv, sizeof(LogFileName) - 4);
                strncpy(WrnFileName, *argv, sizeof(WrnFileName) - 4);
                strncpy(ErrFileName, *argv, sizeof(ErrFileName) - 4);
                strncpy(IncFileName, *argv, sizeof(IncFileName) - 4);
                strncpy(XMLFileName, *argv, sizeof(XMLFileName) - 4);

                break;
            }

            case 'E':
                if (c == 'E') {
                    fAlwaysKeepLogfile = TRUE;
                }
                fErrorLog = TRUE;
                break;

            case 'S':
                fStatus = TRUE;
                if (c == 'S') {
                    fStatusTree = TRUE;
                }
                break;

            case 'T':
                fShowTree = TRUE;
                if (c == 'T') {
                    fShowTreeIncludes = TRUE;
                    }
                break;

            case 'U':
                fShowUnusedDirs = TRUE;
                break;

            case 'B':
                if (c == 'b') {
                    fFullErrors = TRUE;
                }
                else {
                    fErrorBaseline = TRUE;

                    if (--argc) {
                        ++argv;

                        if (**argv != '/' && **argv != '-') {   
                            if (ProbeFile(NULL, *argv) != -1) {
                                CanonicalizePathName(*argv, CANONICALIZE_ONLY, BaselinePathName);
                                Result = LoadBaselineFile();
                            }
                            else {
                                BuildError("The specified baseline file doesn't exist\n");
                                Result = FALSE;
                            }
                        }
                        else {
                            // the next parameter is a switch, reprocess it
                            --argv;
                            ++argc;
                        }
                    } else {
                        // no more parameters
                        ++argc;
                    }
                }
                break;

            case 'C':
                if (!_stricmp( p, "clean" )) {
                        MakeParametersTail = AppendString( MakeParametersTail,
                                                           "clean",
                                                           TRUE);
                        *p-- = '\0';
                }
                else
                if (c == 'C') {
                    fCleanLibs = TRUE;
                }
                else {
                    fClean = TRUE;
                }
                break;

            case 'R':
                if (--argc) {
                    fCleanRestart = TRUE;
                    ++argv;
                    CopyString(RestartDir, *argv, TRUE);
                }
                else {
                    argc++;
                    BuildError("Argument to /R switch missing\n");
                    Result = FALSE;
                }
                break;

            case 'D':
                if (c == 'D')
                    fColorConsole = TRUE;
#if DBG
                else
                    fDebug |= 1;
#endif
                break;

            case '$':
                fDebug += 2;    // yes, I want to *add* 2.
                break;

            case '#':
                fCheckIncludePaths = TRUE;
                fForce = TRUE;
                break;

            case 'O':
                if (c == 'O') {
                    fGenerateObjectsDotMacOnly = TRUE;
                }
                else {
                    fShowOutOfDateFiles = TRUE;
                }
                break;

            case 'P':
                if (c == 'P') {
                    fPrintElapsed = TRUE;
                } else {
                    fPause = TRUE;
                }
                break;

            case 'Q':
                fQuery = TRUE;
                break;

            case 'F':
                if (c == 'F') {
                    fAlwaysPrintFullPath = TRUE;
                } else {
                    fForce = TRUE;
                }
                break;

            case 'G':
                fTargetDirs = TRUE;
                break;

            case 'V':
                fEnableVersionCheck = TRUE;
                break;

            case 'I':
                fSilentDependencies = TRUE;
                break;

            case 'K':
                fKeep = TRUE;
                break;

            case 'M':
                if (c == 'M') {
                    fParallel = TRUE;
                    if (--argc) {
                        DefaultProcesses = atoi(*++argv);
                        if (DefaultProcesses == 0) {
                            --argv;
                            ++argc;
                        }
                    } else {
                        ++argc;
                    }
                } else {
                    SetPriorityClass(GetCurrentProcess(),IDLE_PRIORITY_CLASS);
                }
                break;

            case 'L':
                if (c == 'L') {
                    fCompileOnly = TRUE;
                }
                else {
                    fLinkOnly = TRUE;
                }
                break;

            case 'X':
                if (!strcmp(p, "Xf")) {
                    // The Xf switch produces XML fragments in a specified directory
                    if (--argc) {
                        ++argv;
                        if (!CanonicalizePathName(*argv, CANONICALIZE_DIR, XMLFragmentDirectory)) {
                            Result = FALSE;
                        }
                        else {
                            fXMLFragment = TRUE;
                        }
                    } else {
                        ++argc;
                        BuildError("Argument to /Xf switch missing\n");
                        Result = FALSE;
                    }
                }
                else
                if (c == 'X') {
                    fXMLOutput = TRUE;
                    if (p[1] == 'v' ) {
                        ++p;
                        fXMLVerboseOutput = TRUE;
                    }
                }
                else {
                    if (--argc) {
                        ++argv;
                        if (CountExcludeIncs >= MAX_EXCLUDE_INCS) {
                            static BOOL fError = FALSE;

                            if (!fError) {
                                BuildError(
                                    "-x argument table overflow, using first %u entries\n",
                                    MAX_EXCLUDE_INCS);
                                fError = TRUE;
                            }
                        }
                        else {
                            MakeString(
                                &ExcludeIncs[CountExcludeIncs++],
                                *argv,
                                TRUE,
                                MT_CMDSTRING);
                        }
                    }
                    else {
                        argc++;
                        BuildError("Argument to /X switch missing\n");
                        Result = FALSE;
                    }
                }
                break;

            case 'N':
                if (_stricmp( p, "nmake") == 0) {
                    if (--argc) {
                        ++argv;
                        MakeParametersTail = AppendString( MakeParametersTail,
                                                           *argv,
                                                           TRUE);
                    }
                    else {
                        argc++;
                        BuildError("Argument to /NMAKE switch missing\n");
                        Result = FALSE;
                    }
                    *p-- = '\0';
                    break;
                }
                else
                {
                    if (c == 'n') {
                       fThreadIndex = TRUE;
                    }
                }
                break;

            case 'W':
                fShowWarningsOnScreen = TRUE;
                break;

            case 'Y':
                fNoisyScan = TRUE;
                break;

            case 'Z':
                if (c == 'Z') {
                    fSemiQuicky = TRUE;
                }

                fQuicky = TRUE;
                break;

            default:
                BuildError("Invalid switch - /%c\n", c);
                Result = FALSE;
                break;
            }
        }
        else
        if (*p == '~') {
            if (CountExcludeDirs >= MAX_EXCLUDE_DIRECTORIES) {
                static BOOL fError = FALSE;

                if (!fError) {
                    BuildError(
                        "Exclude directory table overflow, using first %u entries\n",
                        MAX_EXCLUDE_DIRECTORIES);
                    fError = TRUE;
                }
            }
            else {
                MakeString(
                    &ExcludeDirs[CountExcludeDirs++],
                    p + 1,
                    TRUE,
                    MT_CMDSTRING);
            }
        }
        else {
            for (i = 0; i < MAX_TARGET_MACHINES; i++) {
                if (!_stricmp(p, PossibleTargetMachines[i]->MakeVariable)) {
                    AddTargetMachine(i);
                    break;
                }
            }
            if (i >= MAX_TARGET_MACHINES) {
                if (iscsym(*p) || *p == '.') {
                    if (CountOptionalDirs >= MAX_OPTIONAL_DIRECTORIES) {
                        static BOOL fError = FALSE;

                        if (!fError) {
                            BuildError(
                                "Optional directory table overflow, using first %u entries\n",
                                MAX_OPTIONAL_DIRECTORIES);
                            fError = TRUE;
                        }
                    }
                    else {
                        MakeString(
                            &OptionalDirs[CountOptionalDirs++],
                            p,
                            TRUE,
                            MT_CMDSTRING);
                    }
                }
                else {
                    MakeParametersTail = AppendString(
                                            MakeParametersTail,
                                            p,
                                            TRUE);
                }
            }
        }
    }
    return(Result);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetEnvParameters
//
//----------------------------------------------------------------------------

VOID
GetEnvParameters(
    LPSTR EnvVarName,
    LPSTR DefaultValue,
    int *pargc,
    int maxArgc,
    LPSTR argv[]
    )
{
    LPSTR p, p1, psz;

    if (!(p = getenv(EnvVarName))) {
        if (DefaultValue == NULL) {
            return;
        }
        else {
            p = DefaultValue;
        }
    }
    else {
        if (DEBUG_1) {
            BuildMsg("Using %s=%s\n", EnvVarName, p);
        }
    }

    MakeString(&psz, p, FALSE, MT_CMDSTRING);
    p1 = psz;
    while (*p1) {
        while (*p1 <= ' ') {
            if (!*p1) {
                break;
            }
            p1++;
        }
        p = p1;
        while (*p > ' ') {
            if (*p == '#') {
                *p = '=';
            }
            p++;
        }
        if (*p) {
            *p++ = '\0';
        }
        MakeString(&argv[*pargc], p1, FALSE, MT_CMDSTRING);
        if ((*pargc += 1) >= maxArgc) {
            BuildError("Too many parameters (> %d)\n", maxArgc);
            exit(1);
        }
        p1 = p;
    }
    FreeMem(&psz, MT_CMDSTRING);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeEnvParameters
//
//----------------------------------------------------------------------------

VOID
FreeEnvParameters(int argc, LPSTR argv[])
{
    while (--argc) {
        FreeMem(&argv[argc], MT_CMDSTRING);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeCmdStrings
//
//----------------------------------------------------------------------------

VOID
FreeCmdStrings(VOID)
{
#if DBG
    UINT i;

    for (i = 0; i < CountExcludeIncs; i++) {
        FreeMem(&ExcludeIncs[i], MT_CMDSTRING);
    }
    for (i = 0; i < CountOptionalDirs; i++) {
        FreeMem(&OptionalDirs[i], MT_CMDSTRING);
    }
    for (i = 0; i < CountExcludeDirs; i++) {
        FreeMem(&ExcludeDirs[i], MT_CMDSTRING);
    }
    FreeMem(&pszIncMfc, MT_DIRSTRING);
    FreeMem(&pszIncSdk, MT_DIRSTRING);
    FreeMem(&pszIncCrt, MT_DIRSTRING);
    FreeMem(&pszIncOak, MT_DIRSTRING);
    FreeMem(&pszIncDdk, MT_DIRSTRING);
    FreeMem(&pszIncWdm, MT_DIRSTRING);
    FreeMem(&pszIncAtl, MT_DIRSTRING);
    FreeMem(&pszIncPri, MT_DIRSTRING);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   MungePossibleTarget
//
//----------------------------------------------------------------------------

VOID
MungePossibleTarget(
    PTARGET_MACHINE_INFO pti
    )
{
    PCHAR s;
    char *pszDir;

    if (!pti) {
        return;
    }

    // save "i386" string

    pszDir = pti->ObjectDirectory[0];

    // Create "$(_OBJ_DIR)\i386" string

    s = malloc(12 + strlen(pszDir) + 1);
    sprintf(s, "$(_OBJ_DIR)\\%s", pszDir);
    pti->ObjectMacro = s;

    // Create "obj$(BUILD_ALT_DIR)\i386" string for default obj dir

    s = malloc(strlen(szObjDir) + 1 + strlen(pszDir) + 1);
    sprintf(s, "%s\\%s", szObjDir, pszDir);
    pti->ObjectDirectory[0] = s;

    // Create "objd\i386" string for alternate checked obj dir

    s = malloc(strlen(szObjDirD) + 1 + strlen(pszDir) + 1);
    sprintf(s, "%s\\%s", szObjDirD, pszDir);
    pti->ObjectDirectory[1] = s;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetIncludePatterns
//
//----------------------------------------------------------------------------

VOID
GetIncludePatterns(
    LPSTR EnvVarName,
    int maxArgc,
    LPSTR argv[]
    )
{
    LPSTR p, p1, psz;
    int argc;

    argc = 0;

    if ( ( p = getenv(EnvVarName ) ) == NULL ) {
        return;
    }

    MakeString( &psz, p, FALSE, MT_DIRSTRING );

    p1 = psz;
    while ( *p1 ) {
        while ( *p1 == ';' || *p1 == ' ' ) {
            p1++;
        }
        p = p1;
        while ( *p && *p != ';' ) {
            p++;
        }
            if ( *p ) {
            *p++ = '\0';
        }
        MakeString( &argv[argc], p1, FALSE, MT_DIRSTRING );
        if ( ( argc += 1 ) == maxArgc ) {
            BuildError( "Too many include patterns ( > %d)\n", maxArgc );
            exit( 1 );
        }

        p1 = p;
    }

    FreeMem(&psz, MT_DIRSTRING);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeIncludePatterns
//
//----------------------------------------------------------------------------

VOID
FreeIncludePatterns(int argc, LPSTR argv[])
{
    while ( argc ) {
        if ( argv[--argc] ) {
            FreeMem( &argv[argc], MT_DIRSTRING );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadBaselineFile
//
//----------------------------------------------------------------------------
BOOL
LoadBaselineFile(VOID)
{
    BOOL Result = FALSE;
    FILE* FBase = NULL;
    long lSize = 0;

    if (BaselinePathName[0] == '\0')
        goto Cleanup;

    if (!MyOpenFile("", BaselinePathName, "rb", &FBase, FALSE))
        goto Cleanup;

    if (fseek(FBase, 0, SEEK_END))
        goto Cleanup;

    if ((lSize = ftell(FBase)) == -1)
        goto Cleanup;

    if (lSize == 0) {
        // if the baseline is zero-length file, do as if it weren't specified
        Result = TRUE;
        BaselinePathName[0] = '\0';
        goto Cleanup;
    }

    if (fseek(FBase, 0, SEEK_SET))
        goto Cleanup;

    if ((pvBaselineContent = malloc(lSize)) == NULL)
        goto Cleanup;

    if ((long) fread(pvBaselineContent, 1, lSize, FBase) != lSize)
    {
        free(pvBaselineContent);
        pvBaselineContent = NULL;
        goto Cleanup;
    }

    cbBaselineContentSize = (DWORD)lSize;
    Result = TRUE;

Cleanup:
    if (FBase != NULL)
        fclose(FBase);
    return Result;
}

VOID
FreeBaselineFile(VOID)
{
    if (NULL != pvBaselineContent)
        free(pvBaselineContent);
    pvBaselineContent = NULL;
    cbBaselineContentSize = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\build\buildinc.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994.
//
//  File:       buildinc.c
//
//  Contents:   This is the checking include module for the NT Build Tool (BUILD.EXE)
//
//              Used for detecting the includes that do not satisfy the acceptable
//              patterns.
//
//  History:    see SLM
//----------------------------------------------------------------------------

#include "build.h"

//+---------------------------------------------------------------------------
//
//  Function:   FoundCountedSequenceInString
//
//  Synopsis:   Roughly equivalent to "strstr" except that the substring doesn't
//              have to be NULL-terminated.
//
//  Arguments:  [String]   -- null-terminated string to search
//              [Sequence] -- string to search for
//              [Length]   -- the length of the sequence
//----------------------------------------------------------------------------

LPCTSTR
FindCountedSequenceInString(
    IN LPCTSTR String,
    IN LPCTSTR Sequence,
    IN DWORD   Length
    )
    {

    assert( Sequence );
    assert( String );

    if ( Length > 0 ) {

        while ( *String ) {

            while (( *String ) && ( *String != *Sequence )) {
                String++;
                }

            if ( *String ) {

                LPCTSTR SubString   = String   + 1;
                LPCTSTR SubSequence = Sequence + 1;
                DWORD   Remaining   = Length   - 1;

                while (( Remaining ) && ( *SubString++ == *SubSequence++ )) {
                    Remaining--;
                    }

                if ( Remaining == 0 ) {
                    return String;
                    }

                String++;
                }
            }

        return NULL;
        }

    return String;
    }


//+---------------------------------------------------------------------------
//
//  Function:   DoesInstanceMatchPattern
//
//  Synopsis:   Returns TRUE if pattern matches instance.
//              Wildcards:
//              * matches any text
//              ? matches any and exactly one character
//              # matches any text up to backslash character or end of string
//
//  Arguments:  [Instance] -- the string to be matched
//              [Pattern]  -- the pattern
//----------------------------------------------------------------------------

BOOL
DoesInstanceMatchPattern(
    IN LPCTSTR Instance,
    IN LPCTSTR Pattern
    )
    {

    assert( Instance );
    assert( Pattern );

    while ( *Pattern ) {

        if ( *Pattern == TEXT('*')) {

            Pattern++;

            while ( *Pattern == TEXT('*')) {    // skip multiple '*' characters
                Pattern++;
                }

            if ( *Pattern == 0 ) {      // '*' at end of pattern matches rest
                return TRUE;
                }

            if ( *Pattern == '?' ) {    // '?' following '*'

                //
                //  Expensive because we have to restart match for every
                //  character position remaining since '?' can match anything.
                //

                while ( *Instance ) {

                    if ( DoesInstanceMatchPattern( Instance, Pattern )) {
                        return TRUE;
                        }

                    Instance++;
                    }

                return FALSE;
                }

            else {

                //
                //  Now we know that next character in pattern is a regular
                //  character to be matched.  Find out the length of that
                //  string to the next wildcard or end of string.
                //

                LPCTSTR NextWildCard = Pattern + 1;
                DWORD   MatchLength;

                while (( *NextWildCard ) && ( *NextWildCard != TEXT('*')) && ( *NextWildCard != TEXT('?')) && ( *NextWildCard != TEXT('#'))) {
                    NextWildCard++;
                    }

                MatchLength = (DWORD)(NextWildCard - Pattern);   // always non-zero

                //
                //  Now try to match with any instance of substring in pattern
                //  found in the instance.
                //

                Instance = FindCountedSequenceInString( Instance, Pattern, MatchLength );

                while ( Instance ) {

                    if ( DoesInstanceMatchPattern( Instance + MatchLength, NextWildCard )) {
                        return TRUE;
                        }

                    Instance = FindCountedSequenceInString( Instance + 1, Pattern, MatchLength );
                    }

                return FALSE;
                }
            }

        else if ( *Pattern == TEXT('#')) {

            //
            //  Match text up to backslash character or end of string
            //

            Pattern++;

            while (( *Instance != 0 ) && ( *Instance != '\\' )) {
                Instance++;
                }

            continue;
            }

        else if ( *Pattern == TEXT('?')) {

            if ( *Instance == 0 ) {
                return FALSE;
                }
            }

        else if ( *Pattern != *Instance ) {

            return FALSE;
            }

        Pattern++;
        Instance++;
        }

    return ( *Instance == 0 );
    }


//+---------------------------------------------------------------------------
//
//  Function:   CombinePaths
//
//  Synopsis:   Combine two strings to get a full path.
//
//  Arguments:  [ParentPath] -- head path
//              [ChildPath]  -- path to be added
//              [TargetPath] -- full path
//----------------------------------------------------------------------------

LPSTR
CombinePaths(
    IN  LPCSTR ParentPath,
    IN  LPCSTR ChildPath,
    OUT LPSTR  TargetPath   // can be same as ParentPath if want to append
    )
    {

    ULONG ParentLength = strlen( ParentPath );
    LPSTR p;

    assert( ParentPath );
    assert( ChildPath );

    if ( ParentPath != TargetPath ) {
        memcpy( TargetPath, ParentPath, ParentLength );
        }

    p = TargetPath + ParentLength;

    if (( ParentLength > 0 )   &&
        ( *( p - 1 ) != '\\' ) &&
        ( *( p - 1 ) != '/'  )) {
        *p++ = '\\';
        }

    strcpy( p, ChildPath );

    return TargetPath;
    }


//+---------------------------------------------------------------------------
//
//  Function:   CreateRelativePath
//
//  Synopsis:   Determine the "canonical" path of one file relative to
//              another file
//
//  Arguments:  [SourceAbsName] -- absolute path of the source file
//              [TargetAbsName] -- absolute path of the target file
//              [RelativePath]  -- resulted relative path
//----------------------------------------------------------------------------

VOID
CreateRelativePath(
    IN  LPCSTR SourceAbsName,    // must be lowercase
    IN  LPCSTR TargetAbsName,    // must be lowercase
    OUT LPSTR  RelativePath      // must be large enough
    )
    {

    //
    //  First, walk through path components that match in Source and Target.
    //  For example:
    //
    //      d:\nt\private\ntos\dd\efs.h
    //      d:\nt\private\windows\base\ntcrypto\des.h
    //                    ^
    //                    This is where the relative path stops going up (..)
    //                    and starts going back down.
    //
    //  So, the "cannonical" relative path generated should look like:
    //
    //      ..\..\..\windows\base\ntcrypto\des.h
    //
    //  For relative includes that are "below" the includer in the path should
    //  look like this:
    //
    //      .\foo\bar\foobar.h
    //

    LPCSTR Source = SourceAbsName;
    LPCSTR Target = TargetAbsName;
    LPSTR Output = RelativePath;
    ULONG PathSeparatorIndex;
    BOOL  AnyParent;
    ULONG i;

    assert( SourceAbsName );
    assert( TargetAbsName );

    PathSeparatorIndex = 0;

    i = 0;

    //
    //  Scan forward to first non-matching character, and keep track of
    //  most recent path separator character.
    //

    while (( Source[ i ] == Target[ i ] ) && ( Source[ i ] != 0 )) {

        if ( Source[ i ] == '\\' ) {
            PathSeparatorIndex = i;
            }

        ++i;
        }

    //
    //  Coming out of this loop, there are 2 possibilities:
    //
    //       1) Found common ancestor path ( *PathSeparatorIndex == '\\' )
    //       2) Don't have common ancestor ( *PathSeparatorIndex != '\\' )
    //

    if ( Source[ PathSeparatorIndex ] != '\\' ) {
        strcpy( RelativePath, TargetAbsName );
        return;
        }

    i = PathSeparatorIndex + 1;

    //
    //  Now continue to walk down source path and insert a "..\" in the result
    //  for each path separator encountered.
    //

    AnyParent = FALSE;

    while ( Source[ i ] != 0 ) {

        if ( Source[ i ] == '\\' ) {

            AnyParent = TRUE;
            *Output++ = '.';
            *Output++ = '.';
            *Output++ = '\\';
            }

        ++i;
        }

    if ( ! AnyParent ) {

        //
        //  Relative path is below current directory.
        //

        *Output++ = '.';
        *Output++ = '\\';
        }


    //
    //  Now we simply append what's remaining of the Target path from the
    //  ancestor match point.
    //

    strcpy( Output, Target + PathSeparatorIndex + 1 );
    }


//+---------------------------------------------------------------------------
//
//  Function:   ShouldWarnInclude
//
//  Synopsis:   Returns true if the name of the included file matches a
//              BUILD_UNACCEPTABLE_INCLUDES pattern or it does not match
//              any of the patterns specified in BUILD_ACCEPTABLE_INCLUDES.
//
//  Arguments:  [CompilandFullName] -- name of the including file
//              [IncludeeFullName]  -- name of the included file
//----------------------------------------------------------------------------

BOOL
ShouldWarnInclude(
    IN LPCSTR CompilandFullName,
    IN LPCSTR IncludeeFullName
    )
    {
    UINT i;
    CHAR IncludeeRelativeName[ MAX_PATH ];


    assert( CompilandFullName );
    assert( IncludeeFullName );

    CreateRelativePath( CompilandFullName, IncludeeFullName, IncludeeRelativeName );

    //
    //  First we check for a match against any unacceptable include path
    //  because we always want to warn about these.
    //

    for ( i = 0; UnacceptableIncludePatternList[ i ] != NULL; i++ ) {

        if ( DoesInstanceMatchPattern( IncludeeFullName, UnacceptableIncludePatternList[ i ] )) {
            return TRUE;
            }

        if ( DoesInstanceMatchPattern( IncludeeRelativeName, UnacceptableIncludePatternList[ i ] )) {
            return TRUE;
            }
        }

    //
    //  If we get to here, the include path was not explicitly unacceptable, so
    //  we now want to see if it matches any acceptable paths.  But, if no
    //  acceptable paths are specified, we don't want to warn.
    //

    if ( AcceptableIncludePatternList[ 0 ] == NULL ) {
        return FALSE;
        }

    for ( i = 0; AcceptableIncludePatternList[ i ] != NULL; i++ ) {

        if ( DoesInstanceMatchPattern( IncludeeFullName, AcceptableIncludePatternList[ i ] )) {
            return FALSE;
            }

        if ( DoesInstanceMatchPattern( IncludeeRelativeName, AcceptableIncludePatternList[ i ] )) {
            return FALSE;
            }
        }

    return TRUE;
    }


//+---------------------------------------------------------------------------
//
//  Function:   CheckIncludeForWarning
//
//  Synopsis:   Warnings if the dependency does not respect the
//              BUILD_UNACCEPTABLE_INCLUDES or BUILD_ACCEPTABLE_INCLUDES
//              restristions. Works with build -#.
//
//  Arguments:  [CompilandDir]
//              [CompilandName]
//              [IncluderDir]
//              [IncluderName]
//              [IncludeeDir]
//              [IncludeeName]
//----------------------------------------------------------------------------

VOID
CheckIncludeForWarning(
    IN LPCSTR CompilandDir,
    IN LPCSTR CompilandName,
    IN LPCSTR IncluderDir,
    IN LPCSTR IncluderName,
    IN LPCSTR IncludeeDir,
    IN LPCSTR IncludeeName
    )
    {

    CHAR CompilandFullName[ MAX_PATH ];
    CHAR IncluderFullName[ MAX_PATH ];
    CHAR IncludeeFullName[ MAX_PATH ];

    assert( CompilandDir );
    assert( CompilandName );
    assert( IncluderDir );
    assert( IncluderName );
    assert( IncludeeDir );
    assert( IncludeeName );

    CombinePaths( CompilandDir, CompilandName, CompilandFullName );
    CombinePaths( IncluderDir,  IncluderName,  IncluderFullName  );
    CombinePaths( IncludeeDir,  IncludeeName,  IncludeeFullName  );

    _strlwr( CompilandFullName );
    _strlwr( IncluderFullName );
    _strlwr( IncludeeFullName );

    if ( IncFile ) {
        fprintf(
             IncFile,
             "%s includes %s\r\n",
             IncluderFullName,
             IncludeeFullName
             );
        }

    if ( ShouldWarnInclude( CompilandFullName, IncludeeFullName )) {

        if ( strcmp( IncluderFullName, CompilandFullName ) == 0 ) {

            if ( WrnFile ) {

                fprintf(
                     WrnFile,
                     "WARNING: %s includes %s\n",
                     CompilandFullName,
                     IncludeeFullName
                     );
                }

            if ( fShowWarningsOnScreen ) {

                BuildMsgRaw(
                    "WARNING: %s includes %s\n",
                    CompilandFullName,
                    IncludeeFullName
                    );
                }
            }

        else {

            if ( WrnFile ) {

                fprintf(
                     WrnFile,
                     "WARNING: %s includes %s through %s\n",
                     CompilandFullName,
                     IncludeeFullName,
                     IncluderFullName
                     );
                }

            if ( fShowWarningsOnScreen ) {

                BuildMsgRaw(
                    "WARNING: %s includes %s through %s\n",
                    CompilandFullName,
                    IncludeeFullName,
                    IncluderFullName
                    );
                }
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\build\buildmak.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994.
//
//  File:       buildmak.c
//
//  Contents:   This is the Make module for the NT Build Tool (BUILD.EXE)
//
//              The Make module scans directories for file names and edits the
//              data base appropriately.
//
//  Functions:
//
//  History:    16-May-89     SteveWo      Created
//                  ... See SLM log
//              26-Jul-94     LyleC        Cleanup/Add Pass0 support
//              05-Dec-00     sbonev       See SD changelist 2317
//
//----------------------------------------------------------------------------

#include "build.h"


#define SCANFLAGS_CHICAGO       0x00000002
#define SCANFLAGS_OS2           0x00000004
#define SCANFLAGS_POSIX         0x00000008
#define SCANFLAGS_CRT           0x00000010

ULONG ScanFlagsLast;
ULONG ScanFlagsCurrent;

USHORT GlobalSequence;
USHORT LocalSequence;
ULONG idFileToCompile = 1;
BOOL fLineCleared = TRUE;

char szRecurse[] = " . . . . . . . . .";
char szAsterisks[] = " ********************";

char *pszIncOak;
char *pszIncDdk;
char *pszIncWdm;
char *pszIncSdk;
char *pszIncCrt;
char *pszIncAtl;
char *pszIncMfc;

char szIncOs2[_MAX_PATH]    = "%s\\public\\sdk\\inc\\os2";
char szIncPosix[_MAX_PATH]  = "%s\\public\\sdk\\inc\\posix";
char szIncChicago[_MAX_PATH]= "%s\\public\\sdk\\inc\\chicago";

char szCheckedAltDir[] = " CHECKED_ALT_DIR=1";

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(array, type) (sizeof(array)/sizeof(type))
#endif

extern CHAR szObjDir[];

//
// The following definitions are for the ObjectDirFlag entry in the TARGETDATA
// struct.
//

//
// TD_OBJECTDIR   maps to ObjectDirectory[iObjectDir]\foobar.tar
// TD_PASS0HDRDIR maps to $(PASS0_HEADERDIR)\foobar.tar
// TD_PASS0DIR1   maps to $(PASS0_SOURCEDIR)\foobar.tar or $(PASS0_CLIENTDIR)\foobar.tar
// TD_PASS0DIR2   maps to $(PASS0_UUIDDIR)\foobar.tar or $(PASS0_SERVERDIR)\foobar.tar
//
// where .tar is the given target extension, ObjectDirectory[iObjectDir] is the
// appropriate object directory for that platform, and the macros are expanded
// to the values given in the sources file.
//
#define TD_OBJECTDIR           1
#define TD_PASS0HDRDIR         2
#define TD_PASS0DIR1           3
#define TD_PASS0DIR2           4

typedef struct _tagTARGETDATA
{
    UCHAR ObjectDirFlag;    // Indicates what object dir should be used.
    LPSTR pszTargetExt;     // Extension of target. (Including '.')
} TARGETDATA, *LPTARGETDATA;

typedef struct _tagOBJECTTARGETINFO
{
    LPSTR        pszSourceExt;  // Extension of source file (including '.').
    UCHAR        NumData;       // Number of entries in [Data].
    LPTARGETDATA Data;          // Pointer to array of TARGETDATAs.
} OBJECTTARGETINFO, *LPOBJECTTARGETINFO;

typedef struct _tagOBJECTTARGETARRAY
{
    int                cTargetInfo;
    OBJECTTARGETINFO **aTargetInfo;
} OBJECTTARGETARRAY;


//
// TARGETDATA information is used by both BuildCompileTarget() and
// WriteObjectsDefinition() via the GetTargetData() function.  Do not put
// extensions in this table whose TARGETDATA consists entirely of
// { TD_OBJECTDIR, ".obj" } because that is the default.  Instead you must
// modify the switch statement in WriteObjectsDefinition.
//
// The first target in each TARGETDATA array is considered the 'rule target'
// because that is the target for which the inference rule in makefile.def is
// written.  The 'rule target' will always be deleted in addition to the
// out-of-date target if *any* of the targets are out of date.
//


//
// The following data defines the *PASS0* mappings of source extensions
// to target files:
//
//              .idl -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_SOURCEDIR)\_p.c,
//                      $(PASS0_UUIDDIR)\_i.c
//              .asn -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_HEADERDIR)\.c
//              .mc  -> $(PASS0_HEADERDIR)\.h, $(PASS0_SOURCEDIR)\.rc
//              .odl -> obj\*\.tlb
//              .tdl -> obj\*\.tlb
//

//              .mc  -> $(PASS0_HEADERDIR)\.h, $(PASS0_HEADERDIR)\.rc
TARGETDATA MCData0[] = {
                        { TD_PASS0HDRDIR, ".h" },
                        { TD_PASS0DIR1, ".rc" }
                      };
OBJECTTARGETINFO MCInfo0 = { ".mc", ARRAY_SIZE(MCData0, TARGETDATA), MCData0 };

//              .asn  -> $(PASS0_HEADERDIR)\.h, $(PASS0_SOURCEDIR)\.c
TARGETDATA AsnData0[] = {
                        { TD_PASS0HDRDIR, ".h" },
                        { TD_PASS0DIR1, ".c" },
                      };
OBJECTTARGETINFO AsnInfo0 =
    { ".asn", ARRAY_SIZE(AsnData0, TARGETDATA), AsnData0 };


//         .odl/.tdl -> obj\*\.tlb
TARGETDATA TLBData0 = { TD_OBJECTDIR, ".tlb" };

OBJECTTARGETINFO TLBInfo0 =
    { ".tdl", ARRAY_SIZE(TLBData0, TARGETDATA), &TLBData0 };

OBJECTTARGETINFO TLB2Info0 =
    { ".odl", ARRAY_SIZE(TLBData0, TARGETDATA), &TLBData0 };

//         .thk -> obj\*\.asm
TARGETDATA THKData0 = { TD_OBJECTDIR, ".asm" };

OBJECTTARGETINFO THKInfo0 =
    { ".thk", ARRAY_SIZE(THKData0, TARGETDATA), &THKData0 };


//              .mof -> obj\*\.bmf
TARGETDATA MOFData0 = {TD_PASS0DIR1, ".bmf" };
OBJECTTARGETINFO MOFInfo0 = { ".mof", ARRAY_SIZE(MOFData0, TARGETDATA),
   &MOFData0 };

//          ------
LPOBJECTTARGETINFO aTargetInfo0[] = {
                                   &MCInfo0,
                                   &AsnInfo0,
                                   &TLBInfo0,
                                   &TLB2Info0,
                                   &THKInfo0,
                                   &MOFInfo0,
                                   };
#define CTARGETINFO0    ARRAY_SIZE(aTargetInfo0, LPOBJECTTARGETINFO)


//
// The following data defines the *PASS1* mappings of source extensions
// to target files:
//
//              .rc  -> obj\*\.res
//              .asn -> obj\*\.obj
//              .thk -> obj\*\.asm,
//              .java -> obj\*\.class,
//                      obj\*\.obj,
//              .vbp -> obj\*\.dll,
//

//              .rc  -> obj\*\.res
TARGETDATA RCData1 = { TD_OBJECTDIR, ".res" };
OBJECTTARGETINFO RCInfo1 = { ".rc", ARRAY_SIZE(RCData1, TARGETDATA), &RCData1 };

//              .thk -> .asm -> .obj
TARGETDATA THKData1[] = {
                        {TD_OBJECTDIR, ".obj" }
                       };
OBJECTTARGETINFO THKInfo1 =
    { ".thk", ARRAY_SIZE(THKData1, TARGETDATA), THKData1 };

//              .java -> .class
TARGETDATA JAVAData1[] = {
                        {TD_OBJECTDIR, ".class" }
                       };
OBJECTTARGETINFO JAVAInfo1 =
    { ".java", ARRAY_SIZE(JAVAData1, TARGETDATA), JAVAData1 };

//              .vbp -> .dll
TARGETDATA VBPData1[] = {
                        {TD_OBJECTDIR, ".dll" }
                       };
OBJECTTARGETINFO VBPInfo1 =
    { ".vbp", ARRAY_SIZE(VBPData1, TARGETDATA), VBPData1 };




//          ------
LPOBJECTTARGETINFO aTargetInfo1[] = {
                                   &RCInfo1,
                                   &THKInfo1,
                                   &JAVAInfo1,
                                   &VBPInfo1,
                                   };
#define CTARGETINFO1    ARRAY_SIZE(aTargetInfo1, LPOBJECTTARGETINFO)


OBJECTTARGETARRAY aTargetArray[] = {
    { CTARGETINFO0, aTargetInfo0 },
    { CTARGETINFO1, aTargetInfo1 },
};


//          ------
//   MIDL stuff -- IDL files have two potential sets of targets, depending
//   on if the IDL_TYPE flag was set to 'ole' in the sources file or not.
//
//         IDL_TYPE = ole
//              .idl -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_SOURCEDIR)\.c
//                      $(PASS0_PROXYDIR)\_p.c,
//                      $(PASS0_DLLDATADIR)\_d.c,
//                      $(PASS0_TLBDIR)\.c,
TARGETDATA IDLDataOle0[] = {
                         { TD_PASS0HDRDIR, ".h" },   // Header File
                         { TD_PASS0DIR2,   ".c" },   // UUID file
//                         { TD_PASS0DIR1,   "_p.c" }, // Proxy Stub File
                       };
OBJECTTARGETINFO IDLInfoOle0 =
    { ".idl", ARRAY_SIZE(IDLDataOle0, TARGETDATA), IDLDataOle0 };

//         IDL_TYPE = rpc
//              .idl -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_CLIENTDIR)\_c.c,
//                      $(PASS0_SERVERDIR)\_s.c,
TARGETDATA IDLDataRpc0[] = {
                         { TD_PASS0HDRDIR, ".h" },   // Header File
                         { TD_PASS0DIR1,   "_c.c" }, // Client Stub File
                         { TD_PASS0DIR2,   "_s.c" }, // Server Stub File
                       };
OBJECTTARGETINFO IDLInfoRpc0 =
    { ".idl", ARRAY_SIZE(IDLDataRpc0, TARGETDATA), IDLDataRpc0 };

//          ------
LPOBJECTTARGETINFO aMidlTargetInfo0[] = {
                                        &IDLInfoOle0,
                                        &IDLInfoRpc0,
                                       };
UCHAR cMidlTargetInfo0 = ARRAY_SIZE(aMidlTargetInfo0, LPOBJECTTARGETINFO);

//          ------
//
// Any extension not given in the above table is assumed to have a target in
// the ObjectDirectory[iObjectDir] (obj\*) & have a target extension of .obj.
//

TARGETDATA DefaultData = { TD_OBJECTDIR, ".obj" };


//*******

TARGET *
BuildCompileTarget(
    FILEREC *pfr,
    LPSTR    pszfile,
    USHORT   TargetIndex,
    LPSTR    pszConditionalIncludes,
    DIRREC  *pdrBuild,
    DIRSUP  *pdsBuild,
    LONG     iPass,
    LPSTR    *ppszObjectDir,
    LPSTR    pszSourceDir);


//+---------------------------------------------------------------------------
//
//  Function:   ExpandObjAsterisk
//
//  Synopsis:   Expand an asterisk in a filename to a platform name
//
//  Arguments:  [pbuf]               -- Output buffer for new filename
//              [pszpath]            -- Input filename w/ asterisk
//              [ppszObjectDirectory] -- String[2] to replace asterisk with
//
//----------------------------------------------------------------------------

VOID
ExpandObjAsterisk(
    LPSTR pbuf,
    LPSTR pszpath,
    LPSTR *ppszObjectDirectory)
{
    SplitToken(pbuf, '*', &pszpath);
    if (*pszpath == '*') {
        assert(strncmp(
                    pszObjDirSlash,
                    ppszObjectDirectory[iObjectDir],
                    strlen(pszObjDirSlash)) == 0);
        strcat(pbuf, ppszObjectDirectory[iObjectDir] + strlen(pszObjDirSlash));
        strcat(pbuf, pszpath + 1);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CountSourceLines
//
//  Synopsis:   Counts the source lines in a given file, including headers if
//              the '-S' option was given.
//
//  Arguments:  [idScan] -- Used to catch multiple inclusions
//              [pfr]    -- File to scan
//
//  Returns:    Number of lines
//
//----------------------------------------------------------------------------

LONG
CountSourceLines(USHORT idScan, FILEREC *pfr)
{
    INCLUDEREC *pir;

    AssertFile(pfr);

    // if we have already seen this file before, then assume
    // that #if guards prevent it's inclusion

    if (pfr->idScan == idScan) {
        return(0L);
    }

    pfr->idScan = idScan;

    //  Start off with the file itself
    pfr->TotalSourceLines = pfr->SourceLines;

    if (fStatusTree) {

        //
        // If the user asked for include file line counts, then walk include
        // tree, accruing nested include file line counts .
        //

        for (pir = pfr->IncludeFilesTree; pir != NULL; pir = pir->NextTree) {
            AssertInclude(pir);
            if (pir->pfrInclude != NULL) {
                AssertFile(pir->pfrInclude);
                pfr->TotalSourceLines +=
                        CountSourceLines(idScan, pir->pfrInclude);
            }
        }
    }
    return(pfr->TotalSourceLines);
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanNTTargetFile0
//
//  Synopsis:   Parses pzFiles and deletes all files listed.
//               pzFile must have been allocated by MakeMacroString.
//               No asterisk expansion performed.
//
//              This is used when fClean is TRUE and SOURCES_OPTIONS
//               includes -c0. See ReadSourcesFile. Note that
//               SOURCES_OPTIONS must be defined before NTTARGETFILE0.
//              This is a mechanism to delete target files not
//               included in _objects.mac.
//
//  Arguments:  [pzFiles] -- List of files
//
//----------------------------------------------------------------------------
VOID
CleanNTTargetFile0 (char * pzFiles)
{
    BOOL fRestoreSep;
    char * pzDelete;

    while (*pzFiles != '\0') {
        pzDelete = pzFiles;

        // Find end of the next file name and NULL terminate it (if needed)
        fRestoreSep = FALSE;
        while (*pzFiles != '\0') {
            if (*pzFiles == ' ') {
                fRestoreSep = TRUE;
                *pzFiles = '\0';
                break;
            } else {
                pzFiles++;
            }
        }

        DeleteSingleFile (NULL, pzDelete, FALSE);

        if (fRestoreSep) {
            *pzFiles++ = ' ';
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessSourceDependencies
//
//  Synopsis:   Scan all source files in a given directory tree to determine
//              which files are out of date and need to be compiled and/or
//              linked.
//
//  Arguments:  [DirDB]           -- Directory to process
//              [pds]             -- Supplementary directory information
//              [DateTimeSources] -- Timestamp of 'sources' file
//
//----------------------------------------------------------------------------

VOID
ProcessSourceDependencies(DIRREC *DirDB, DIRSUP *pds, ULONG DateTimeSources)
{
    TARGET *Target;
    ULONG DateTimePch = 0;    // Actual timestamp of pch preserved here.
    UINT i;
    SOURCEREC *apsr[3];
    SOURCEREC **ppsr;
    char path[DB_MAX_PATH_LENGTH];
    static USHORT idScan = 0;

    AssertDir(DirDB);

    apsr[0] = pds->psrSourcesList[0];
    apsr[2] = NULL;

    //
    // For a clean build, just delete all targets
    //
    if (fFirstScan && fClean && !fKeep) {
        DeleteMultipleFiles(szObjDir, "*.*");    // _objects.mac
        for (i = 0; i < CountTargetMachines; i++) {
            assert(strncmp(
                        pszObjDirSlash,
                        TargetMachines[i]->ObjectDirectory[iObjectDir],
                        strlen(pszObjDirSlash)) == 0);
            DeleteMultipleFiles(TargetMachines[i]->ObjectDirectory[iObjectDir], "*.*");

            apsr[1] = pds->psrSourcesList[TargetToPossibleTarget[i] + 1];

            //
            // Delete the pch file if we have one.
            //
            if (pds->PchTarget != NULL)
            {
                char TargetDir[DB_MAX_PATH_LENGTH];
                ExpandObjAsterisk(TargetDir,
                                  pds->PchTargetDir,
                                  TargetMachines[i]->ObjectDirectory);

                //
                // Kind of a cludgy way to do this, but we must ensure that
                // we don't delete a pch file that was built earlier on during
                // this same build.  We do this by comparing the timestamp of
                // the pch file against the time we started the build.
                //
                if ((*pDateTimeFile)(TargetDir, pds->PchTarget) <= BuildStartTime)
                {
                    DeleteSingleFile(TargetDir, pds->PchTarget, FALSE);
                    if (DirDB->PchObj != NULL) {
                        ExpandObjAsterisk(path,
                                          DirDB->PchObj,
                                          TargetMachines[i]->ObjectDirectory);
                        DeleteSingleFile(NULL, path, FALSE);
                    } else {
                        char *p;
                        strcpy(path, pds->PchTarget);
                        p = strrchr(path, '.');
                        if (p != NULL && strcmp(p, ".pch") == 0) {
                            strcpy(p, ".obj");
                            DeleteSingleFile(TargetDir, path, FALSE);
                        }
                    }
                }
            }

            if (DirDB->DirFlags & DIRDB_PASS0) {
                for (ppsr = apsr; *ppsr != NULL; ppsr++) {
                    SOURCEREC *psr;

                    for (psr = *ppsr; psr != NULL; psr = psr->psrNext) {
                        FILEREC *pfr;

                        AssertSource(psr);

                        pfr = psr->pfrSource;

                        //
                        // Pass Zero files have different target directories.
                        //
                        if (pfr->FileFlags & FILEDB_PASS0)
                        {
                            USHORT j;
                            //
                            // If the file has multiple targets, (e.g. .mc,
                            // .idl or .asn), then loop through all targets.
                            //
                            j = 0;
                            while (Target = BuildCompileTarget(
                                                pfr,
                                                pfr->Name,
                                                j,
                                                pds->ConditionalIncludes,
                                                DirDB,
                                                pds,
                                                0,        // pass 0
                                                TargetMachines[i]->ObjectDirectory,
                                                TargetMachines[i]->SourceDirectory)) {

                                DeleteSingleFile(NULL, Target->Name, FALSE);

                                FreeMem(&Target, MT_TARGET);

                                j++;
                            }
                        }
                    }
                }
            }

            if ((DirDB->DirFlags & DIRDB_TARGETFILE0) && (DirDB->NTTargetFile0 != NULL)) {
                CleanNTTargetFile0 (DirDB->NTTargetFile0);
            }
        }
    }

    if (fFirstScan && (DirDB->DirFlags & DIRDB_TARGETFILE0)) {
        DirDB->DirFlags |= DIRDB_PASS0NEEDED;
    }

    if (!fQuickZero || !fFirstScan || !RecurseLevel)
    {
        GenerateObjectsDotMac(DirDB, pds, DateTimeSources);
    }
    else if (fFirstScan)
    {
        SOURCEREC *psr;
        USHORT i;
        USHORT j;
        BOOL fNeedCompile = FALSE;

        if ( !(DirDB->DirFlags & DIRDB_PASS0NEEDED)) {

            for (i = 0; i < CountTargetMachines; i++) {

                for (psr = pds->psrSourcesList[0]; psr != NULL; psr = psr->psrNext) {
                    FILEREC *pfr;

                    AssertSource(psr);

                    pfr = psr->pfrSource;

                    AssertFile(pfr);

                    if (pfr->FileFlags & FILEDB_PASS0)
                    {

                        for (j = 0;
                            Target = BuildCompileTarget(
                                            pfr,
                                            pfr->Name,
                                            j,
                                            pds->ConditionalIncludes,
                                            DirDB,
                                            pds,
                                            0,
                                            TargetMachines[i]->ObjectDirectory,
                                            TargetMachines[i]->SourceDirectory);
                            j++) {

                            if ((psr->SrcFlags & SOURCEDB_FILE_MISSING) || (Target->DateTime == 0) || ((pfr->FileFlags & FILEDB_C) && Target->DateTime < DateTimePch))
                            {
                                fNeedCompile = TRUE;
                            }
                        }

                        if (fNeedCompile)
                        {
                            DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                        }
                    }
                }
            }
        }

        if (DirDB->DirFlags & DIRDB_PASS0NEEDED)
        {
            GenerateObjectsDotMac(DirDB, pds, DateTimeSources);
        }
    }

    if ((DirDB->TargetExt != NULL) &&
        (DirDB->TargetName != NULL) &&
        (DirDB->TargetPath != NULL) &&
        (fClean && !fKeep))
    {
        // If we haven't already deleted the final target, do so now.
        if (_memicmp(DirDB->TargetPath, pszObjDirSlash, strlen(pszObjDirSlash) -1)) {
            for (i = 0; i < CountTargetMachines; i++) {
                FormatLinkTarget(
                    path,
                    TargetMachines[i]->ObjectDirectory,
                    DirDB->TargetPath,
                    DirDB->TargetName,
                    DirDB->TargetExt);
                DeleteSingleFile(NULL, path, FALSE);
                FormatLinkTarget(
                    path,
                    TargetMachines[i]->ObjectDirectory,
                    DirDB->TargetPath,
                    DirDB->TargetName,
                    ".pdb");
                DeleteSingleFile(NULL, path, FALSE);
            }
        }
    }

    if (pds->fNoTarget) {
        DirDB->DirFlags |= DIRDB_COMPILENEEDED;
        return;
    }

    if (fQuicky) {
        if (fSemiQuicky)
            DirDB->DirFlags |= DIRDB_COMPILENEEDED;
        else
            DirDB->DirFlags |= DIRDB_PASS0NEEDED;
        return;
    }

    //
    // For a DLL or LIB target, ensure that it will be rebuilt
    //
    if (DirDB->TargetPath != NULL &&
        DirDB->TargetName != NULL &&
        ((DirDB->DirFlags & DIRDB_DLLTARGET) ||
         (DirDB->TargetExt != NULL && strcmp(DirDB->TargetExt, ".lib") == 0))) {

        for (i = 0; i < CountTargetMachines; i++) {
            FormatLinkTarget(
                path,
                TargetMachines[i]->ObjectDirectory,
                DirDB->TargetPath,
                DirDB->TargetName,
                ".lib");

            if (ProbeFile(NULL, path) == -1) {
                DirDB->DirFlags |= DIRDB_COMPILENEEDED;
            }
            else
            if (fFirstScan && (fCleanLibs || (fClean && !fKeep))) {
                DeleteSingleFile(NULL, path, FALSE);
                DirDB->DirFlags |= DIRDB_COMPILENEEDED;
            }
        }
    }

    //
    // If the scan flags have changed (or haven't been set), then indicate
    // that we should look for the actual location of global included files
    // instead of assuming it's in the same location as we last knew.  This is
    // because different directories my include the same file from different
    // places.
    //
    if (GlobalSequence == 0 ||
        ScanFlagsLast == 0 ||
        ScanFlagsLast != ScanFlagsCurrent) {

        GlobalSequence++;               // don't reuse snapped global includes
        if (GlobalSequence == 0) {
            GlobalSequence++;
        }
        ScanFlagsLast = ScanFlagsCurrent;
    }

    //
    // Do the same as above for locally included files.
    //
    LocalSequence++;                    // don't reuse snapped local includes
    if (LocalSequence == 0) {
        LocalSequence++;
    }

    for (i = 0; i < CountTargetMachines; i++) {

        //
        // Ensure that precompiled headers are rebuilt as necessary.
        //

        if (!fPassZero && (pds->PchInclude != NULL || pds->PchTarget != NULL)) {
            LPSTR p;

            ExpandObjAsterisk(
                        path,
                        pds->PchTargetDir != NULL?
                            pds->PchTargetDir : pszObjDirSlashStar,
                        TargetMachines[i]->ObjectDirectory);

            if (!CanonicalizePathName(path, CANONICALIZE_DIR, path)) {
                DateTimePch = ULONG_MAX;        // always out of date
                goto ProcessSourceList;
            }
            strcat(path, "\\");

            //
            // If they gave a target directory for the pch file, then use it,
            // otherwise assume it's in the same directory as the .h file.
            //
            if (pds->PchTarget != NULL) {
                strcat(path, pds->PchTarget);
            }
            else {
                assert(pds->PchInclude != NULL);
                p = path + strlen(path);
                if ( DirDB->Pch ) {
                    strcpy(p, DirDB->Pch);
                } else {
                    strcpy(p, pds->PchInclude);
                    if ((p = strrchr(p, '.')) != NULL) {
                        *p = '\0';
                    }
                    strcat(path, ".pch");
                }
            }

            //
            // 'path' now contains the (possibly relative) path name of
            // the PCH target: "..\path\foobar.pch"
            //
            Target = BuildCompileTarget(
                        NULL,
                        path,
                        0,
                        pds->ConditionalIncludes,
                        DirDB,
                        NULL,
                        1,        // pass 1
                        TargetMachines[i]->ObjectDirectory,
                        TargetMachines[i]->SourceDirectory);

            DateTimePch = Target->DateTime;

            if (DateTimePch == 0) {             // Target doesn't exist
                DateTimePch = ULONG_MAX;        // Always out of date
            }

            if (fClean && !fKeep && fFirstScan) {
                // Target will be deleted later if it exists.
            }
            else if (pds->PchInclude == NULL) {

                //
                // The SOURCES file didn't indicate where the source file
                // for the .pch is, so assume the .pch binary is up to date
                // with respect to the source includes and with respect to
                // the pch source file itself.
                //
                // char szFullPath[DB_MAX_PATH_LENGTH];

                // CanonicalizePathName(DirDB->Name, CANONICALIZE_DIR, szFullPath);

                //BuildMsg("SOURCES file in %s gives PRECOMPILED_TARGET but not "
                //         "PRECOMPILED_INCLUDE.\n", szFullPath);
                Target->DateTime = 0;           // Don't delete pch target
            }
            else {
                FILEREC *pfrPch = NULL;

                path[0] = '\0';

                if (pds->PchIncludeDir != NULL) {
                    strcpy(path, pds->PchIncludeDir);
                    strcat(path, "\\");
                }
                strcat(path, pds->PchInclude);

                if ((pds->PchIncludeDir != NULL) &&
                    (IsFullPath(pds->PchIncludeDir))) {
                    DIRREC *DirDBPch;

                    DirDBPch = FindSourceDirDB(pds->PchIncludeDir,
                                               pds->PchInclude, TRUE);

                    if (DirDBPch) {
                        pfrPch = FindSourceFileDB(DirDBPch,
                                                  pds->PchInclude,
                                                  NULL);
                    }
                }
                else {
                    pfrPch = FindSourceFileDB(DirDB, path, NULL);
                }


                if (pfrPch != NULL) {
                    FILEREC *pfrRoot;
                    SOURCEREC *psr = NULL;

                    BOOL fCase1;
                    BOOL fCase2;
                    BOOL fCase3;
                    BOOL fNeedCompile;
                    BOOL fCheckDepends;

                    // Remote directory PCH files can't be found here

                    if (pfrPch->Dir == DirDB) {
                        psr = FindSourceDB(pds->psrSourcesList[0], pfrPch);
                        assert(psr != NULL);
                        psr->SrcFlags |= SOURCEDB_PCH;
                    }

                    Target->pfrCompiland = pfrPch;
                    assert((pfrRoot = NULL) == NULL);   // assign NULL

                    fNeedCompile = FALSE;
                    fCheckDepends = FALSE;

                    switch(0) {
                      default:
                        fCase1 = (fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfrPch, TRUE, &pfrRoot));
                        if ( fCase1 ) {
                            fNeedCompile = TRUE;
                            break;
                        }
                        fCase2 = (Target->DateTime == 0);
                        if ( fCase2 ) {
                            fNeedCompile = TRUE;
                            break;
                        }
                        fCase3 = (!fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfrPch, TRUE, &pfrRoot));
                        if ( fCase3 ) {
                            fNeedCompile = TRUE;
                            break;
                        }
                        break;
                    }

                    if (( fCheckIncludePaths ) && ( ! fCheckDepends )) {
                        CheckDependencies(Target, pfrPch, TRUE, &pfrRoot);
                    }

                    if (fNeedCompile) {

                        if (psr != NULL) {
                            if (fWhyBuild) {
                                BuildMsgRaw("\n");
                                if (fCase1) {
                                    BuildMsgRaw("Compiling %s because (Case 1) *1\n", psr->pfrSource->Name);
                                } else
                                if (fCase2) {
                                    BuildMsgRaw("Compiling %s because Target date == 0 (Target->Compiland=%s) *1\n", psr->pfrSource->Name, Target->pfrCompiland->Name);
                                } else
                                if (fCase3) {
                                    BuildMsgRaw("Compiling %s because (Case 3) *1\n", psr->pfrSource->Name);
                                }
                            }

                            psr->SrcFlags |= SOURCEDB_COMPILE_NEEDED;
                        } else {
                            if (fWhyBuild) {
                                BuildMsgRaw("\n");
                                BuildMsgRaw("Compiling %s because Target date == 0 (Target->Compiland=%s) *1\n", Target->Name, Target->pfrCompiland->Name);
                            }
                        }

                        pfrPch->Dir->DirFlags |= DIRDB_COMPILENEEDED;
                        DateTimePch = ULONG_MAX; // always out of date
                        if (fKeep) {
                            Target->DateTime = 0;  // don't delete pch target
                        }
                    }
                    else {      // else it exists and is up to date...
                        Target->DateTime = 0;   // don't delete pch target
                    }

                    // No cycle possible at the root of the tree.
                    // 14-Jan-2000 Actually not true. See comments dated 22-Dec-1999
                    // by LeoN around line 2800.
                    // assert(pfrRoot == NULL);
                }
                else if (DEBUG_1) {
                    BuildError("Cannot locate precompiled header file: %s.\n",
                                path);
                }
            }

            //
            // Target->DateTime will be zero if the file is up to date (or we
            // don't want to delete it).  If Target->DateTime is non-zero,
            // delete the .pch and corresponding .obj file so they will be
            // rebuilt.
            //
            if (Target->DateTime != 0) {
                DeleteSingleFile(NULL, Target->Name, FALSE);
                if (DirDB->PchObj != NULL) {
                    ExpandObjAsterisk(
                                path,
                                DirDB->PchObj,
                                TargetMachines[i]->ObjectDirectory);
                    DeleteSingleFile(NULL, path, FALSE);
                } else {
                    p = strrchr(Target->Name, '.');
                    if (p != NULL && strcmp(p, ".pch") == 0) {
                        strcpy(p, ".obj");
                        DeleteSingleFile(NULL, Target->Name, FALSE);
                    }
                }
            }
            FreeMem(&Target, MT_TARGET);
        }

        //
        // Check to see which files given in the SOURCES macro need to be
        // rebuilt, and delete their targets (.obj) if they're out of date.
        //

ProcessSourceList:

        apsr[1] = pds->psrSourcesList[TargetToPossibleTarget[i] + 1];

        for (ppsr = apsr; ppsr < apsr + (sizeof(apsr)/sizeof(*apsr)); ppsr++) {
            SOURCEREC *psr;

            if (*ppsr == NULL) {
                continue;
            }


            for (psr = *ppsr; psr != NULL; psr = psr->psrNext) {
                FILEREC *pfr, *pfrRoot;

                AssertSource(psr);

                pfr = psr->pfrSource;

                AssertFile(pfr);

                if ((psr->SrcFlags & SOURCEDB_PCH) == 0) {

                    USHORT j;
                    LONG iPass, iPassEnd;

                    iPass = 1;
                    iPassEnd = 0;

                    if (pfr->FileFlags & FILEDB_PASS0)
                        iPass = 0;

                    if ((pfr->FileFlags & FILEDB_MULTIPLEPASS) ||
                        !(pfr->FileFlags & FILEDB_PASS0))
                        iPassEnd = 1;

                    assert(iPass <= iPassEnd);

                    //
                    // If we're doing a pass zero scan and the file is
                    // not a pass zero file, then continue because we
                    // don't care about it right now.
                    //
                    if (fFirstScan && fPassZero && iPass == 1) {
                        continue;
                    }

                    //
                    // Don't check dependencies of pass zero files on the
                    // second scan, because they're all supposed to be built
                    // by now.
                    //
                    if (!fFirstScan && iPassEnd == 0) {
                        continue;
                    }

                    //
                    // If the file was created during pass zero, then make sure
                    // we don't think it's still missing.
                    //
                    if (!fFirstScan &&
                        (psr->SrcFlags & SOURCEDB_FILE_MISSING) &&
                        !(pfr->FileFlags & FILEDB_FILE_MISSING))
                    {
                        psr->SrcFlags &= ~SOURCEDB_FILE_MISSING;
                    }

                    // If the file is a multiple pass file (e.g. .asn), loop
                    // through both passes.

                    for ( ; iPass <= iPassEnd; iPass++) {

                        //
                        // If the file has multiple targets (e.g. .mc, .idl or
                        // .asn), then loop through all the targets.
                        //
                        for (j = 0;
                            Target = BuildCompileTarget(
                                            pfr,
                                            pfr->Name,
                                            j,
                                            pds->ConditionalIncludes,
                                            DirDB,
                                            pds,
                                            iPass,
                                            TargetMachines[i]->ObjectDirectory,
                                            TargetMachines[i]->SourceDirectory);
                            j++) {

                            BOOL fCase1;
                            BOOL fCase2;
                            BOOL fCase3;
                            BOOL fCase4;
                            BOOL fCase5;
                            BOOL fNeedCompile;
                            BOOL fCheckDepends;

                            if (DEBUG_4) {
                                BuildMsgRaw(szNewLine);
                            }
                            assert((pfrRoot = NULL) == NULL);   // assign NULL

                            //  Decide whether the target needs to be compiled.
                            //  Forcibly examine dependencies to get line count.

                            fNeedCompile = FALSE;
                            fCheckDepends = FALSE;

                            switch(0) {
                              default:
                                fCase1 = (psr->SrcFlags & SOURCEDB_FILE_MISSING);
                                if ( fCase1 ) {
                                    fNeedCompile = TRUE;
                                    break;
                                }
                                fCase2 = (fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfr, TRUE, &pfrRoot));
                                if ( fCase2 ) {
                                    fNeedCompile = TRUE;
                                    break;
                                }
                                fCase3 = (Target->DateTime == 0);
                                if ( fCase3 ) {
                                    fNeedCompile = TRUE;
                                    break;
                                }
                                fCase4 = ((pfr->FileFlags & FILEDB_C) && Target->DateTime < DateTimePch);
                                if ( fCase4 ) {
                                    fNeedCompile = TRUE;
                                    break;
                                }
                                fCase5 = (!fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfr, TRUE, &pfrRoot));
                                if ( fCase5 ) {
                                    fNeedCompile = TRUE;
                                    break;
                                }
                                break;
                            }

                            if (( fCheckIncludePaths ) && ( ! fCheckDepends )) {
                                CheckDependencies(Target, pfr, TRUE, &pfrRoot);
                            }

                            if ( fNeedCompile )
                            {
                                if (fWhyBuild) {
                                    BuildMsgRaw("\n");
                                    if (fCase1) {
                                        BuildMsgRaw("Compiling %s because filename is missing from build database *2\n", psr->pfrSource->Name);
                                    } else
                                    if (fCase2) {
                                        BuildMsgRaw("Compiling %s because (Case 2) *2\n", psr->pfrSource->Name);
                                    } else
                                    if (fCase3) {
                                        BuildMsgRaw("Compiling %s because Target date == 0 *2\n", psr->pfrSource->Name);
                                    } else
                                    if (fCase4) {
                                        BuildMsgRaw("Compiling %s because C file is later earlier than pch *2\n", psr->pfrSource->Name);
                                    } else
                                    if (fCase5) {
                                        BuildMsgRaw("Compiling %s because (Case 5) *2\n", psr->pfrSource->Name);
                                    }
                                }

                                psr->SrcFlags |= SOURCEDB_COMPILE_NEEDED;

                                if (pfr->FileFlags & FILEDB_PASS0) {
                                    DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                                }
                                else
                                    DirDB->DirFlags |= DIRDB_COMPILENEEDED;

                                if (Target->DateTime != 0 && !fKeep)
                                {
                                    DeleteSingleFile(NULL, Target->Name, FALSE);
                                }

                                FreeMem(&Target, MT_TARGET);

                                if (j != 0) {
                                    //
                                    // Delete the 'rule target' so nmake
                                    // doesn't complain about "don't know how
                                    // to make ..."
                                    //
                                    Target = BuildCompileTarget(
                                                 pfr,
                                                 pfr->Name,
                                                 0,
                                                 pds->ConditionalIncludes,
                                                 DirDB,
                                                 pds,
                                                 iPass,
                                                 TargetMachines[i]->ObjectDirectory,
                                                 TargetMachines[i]->SourceDirectory);
                                    if (Target) {
                                        DeleteSingleFile(
                                                NULL,
                                                Target->Name,
                                                FALSE);

                                        FreeMem(&Target, MT_TARGET);
                                    }
                                }

                                // No need to check other targets,
                                // we know they all will be rebuilt.
                                break;
                            }

                            // No cycle possible at the root of the tree.

                            // 14-Jan-2000 Actually not true. See comments dated 22-Dec-1999
                            // by LeoN around line 2800.
                            // assert(pfrRoot == NULL);
                            FreeMem(&Target, MT_TARGET);
                        }
                    }
                }
                if (fClean || (psr->SrcFlags & SOURCEDB_COMPILE_NEEDED)) {
                    ULONG cline;

                    if (++idScan == 0) {
                        ++idScan;               // skip zero
                    }

                    if (fFirstScan && (pfr->FileFlags & FILEDB_PASS0))
                    {
                        cline = CountSourceLines(idScan, pfr);
                        DirDB->PassZeroLines += cline;
                        DirDB->CountOfPassZeroFiles++;
                    }

                    // For a multiple pass file, we really need to count the
                    // lines in the file compiled duing pass1 (and generated
                    // during pass 0).  Instead, we just count the pass 0
                    // source file all over again.  It's cheap, but the line
                    // count is inaccurate.

                    if (!fPassZero &&
                        ((pfr->FileFlags & FILEDB_MULTIPLEPASS) ||
                         !(pfr->FileFlags & FILEDB_PASS0)))
                    {
                        cline = CountSourceLines(idScan, pfr);
                        DirDB->SourceLinesToCompile += cline;
                        DirDB->CountOfFilesToCompile++;
                    }
                }
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanSourceDirectories
//
//  Synopsis:   Scan a source directory to determine what files it
//              contains, whether it should be compiled or linked, and
//              whether it has subdirectories that we should process.
//
//  Arguments:  [DirName] -- Directory to scan
//
//----------------------------------------------------------------------------

VOID
ScanSourceDirectories(LPSTR DirName)
{
    char path[DB_MAX_PATH_LENGTH];
    PDIRREC DirDB;
    DIRSUP *pds = NULL;
    LPSTR SavedCurrentDirectory;
    BOOL DirsPresent;
    ULONG DateTimeSources = 0;
    UINT i;

    if (DEBUG_4) {
        BuildMsgRaw(
            "ScanSourceDirectories(%s) level = %d\n",
            DirName,
            RecurseLevel);
    }

    // Change to the given directory
    SavedCurrentDirectory = PushCurrentDirectory(DirName);

    // Process all the files in this directory
    DirDB = ScanDirectory(DirName);

    AssertOptionalDir(DirDB);
    if (fCleanRestart && DirDB != NULL && !strcmp(DirDB->Name, RestartDir)) {
        fCleanRestart = FALSE;
        fClean = fRestartClean;
        fCleanLibs = fRestartCleanLibs;
    }

    if (!DirDB || !(DirDB->DirFlags & (DIRDB_DIRS | DIRDB_SOURCES))) {
        PopCurrentDirectory(SavedCurrentDirectory);
        return;
    }

    if (fShowTree && !(DirDB->DirFlags & DIRDB_SHOWN)) {
        AddShowDir(DirDB);
    }

    if (DirDB->DirFlags & DIRDB_SOURCES) {
        BOOL fSourcesRead = TRUE;

        SetObjDir((DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) != 0);

        //
        // This directory contains a SOURCES file
        //

        if (fFirstScan)
        {
            AllocMem(sizeof(DIRSUP), &pds, MT_DIRSUP);
            memset(pds, 0, sizeof(*pds));
            fSourcesRead = ReadSourcesFile(DirDB, pds, &DateTimeSources);

            DirDB->pds = pds;
        }
        else
        {
            pds = DirDB->pds;

            assert(pds);

            DateTimeSources = pds->DateTimeSources;

            //
            // We need to rebuild the sources list because
            // the previous scan was probably not complete.
            //
            if (pds)
                PostProcessSources(DirDB, pds);

        }

        assert(pds);

        if (DEBUG_4) {
            BuildMsgRaw("ScanSourceDirectories(%s) SOURCES\n", DirName);
        }

        ScanFlagsCurrent = 0;
        CountIncludeDirs = CountSystemIncludeDirs;

        //  Scan the include environments in the order that MAKEFILE.DEF
        //  processes them.  This order is:
        //
        //  1) Sources variable INCLUDE
        //  2) Cairo/Chicago directories
        //  3) System includes
        //  4) UMTYPE-derived includes
        //
        //  The subtlety is that we must do this in the reverse order
        //  since each of the processing routines pushes search directories
        //  onto the HEAD of the include search list.
        //
        //  BUGBUG - we come in here with the system includes already set.
        //  There's no way to stick the UMTYPE-derived ones ahead of the
        //  system includes

        //  4) UMTYPE-derived includes
        if (pds->TestType != NULL && !strcmp(pds->TestType, "os2")) {
            ScanIncludeDir(pszIncCrt);
            ScanIncludeDir(szIncOs2);
            ScanFlagsCurrent |= SCANFLAGS_OS2;
        }
        else
        if (pds->TestType != NULL && !strcmp(pds->TestType, "posix")) {
            ScanIncludeDir(szIncPosix);
            ScanFlagsCurrent |= SCANFLAGS_POSIX;
        }
        else {
            ScanIncludeDir(pszIncCrt);
            ScanFlagsCurrent |= SCANFLAGS_CRT;
        }

        if (DirDB->DirFlags & DIRDB_CHICAGO_INCLUDES) {
            ScanIncludeDir(szIncChicago);
            ScanFlagsCurrent |= SCANFLAGS_CHICAGO;
        }

        if (pszIncMfc) {
            ScanIncludeDir(pszIncMfc);
        }

        if (pszIncAtl) {
            ScanIncludeDir(pszIncAtl);
        }

        //  Sources variable INCLUDES
        if (pds->LocalIncludePath)
            ScanIncludeEnv(pds->LocalIncludePath);

        //  Sources variable USER_INCLUDES
        if (pds->UserIncludePath)
            ScanIncludeEnv(pds->UserIncludePath);

        //  Sources variable LAST_INCLUDES
        if (pds->LastIncludePath)
            ScanIncludeEnv(pds->LastIncludePath);

        DirsPresent = FALSE;

    }
    else
    if (DirDB->DirFlags & DIRDB_DIRS) {
        //
        // This directory contains a DIRS or MYDIRS file
        //
        DirsPresent = ReadDirsFile(DirDB);

        if (DEBUG_4) {
            BuildMsgRaw("ScanSourceDirectories(%s) DIRS\n", DirName);
        }
    }

    if (!fQuicky || (fQuickZero && fFirstScan)) {
        if (!RecurseLevel) {
            BuildError(
                "Examining %s directory%s for %s.%s\n",
                DirDB->Name,
                DirsPresent? " tree" : "",
                fLinkOnly? "targets to link" : "files to compile",
                fFirstScan ? "" : " (2nd Pass)"
                );
        }
        ClearLine();
        BuildMsgRaw("    %s ", DirDB->Name);
        fLineCleared = FALSE;
        if (fDebug || !(BOOL) _isatty(_fileno(stderr))) {
            BuildMsgRaw(szNewLine);
            fLineCleared = TRUE;
        }
    }

    if (!fLinkOnly) {

        if (DirDB->DirFlags & DIRDB_SOURCESREAD) {
            //
            // Determine what files need to be compiled
            //
            ProcessSourceDependencies(DirDB, pds, DateTimeSources);
        }
        else
        if (fFirstScan && DirsPresent && (DirDB->DirFlags & DIRDB_MAKEFIL0)) {
            DirDB->DirFlags |= ((fSemiQuicky && (!fQuickZero || !fFirstScan)) ? DIRDB_COMPILENEEDED :
                                                                                DIRDB_PASS0NEEDED);
        }
        else
        if (DirsPresent && (DirDB->DirFlags & DIRDB_MAKEFIL1)) {
            DirDB->DirFlags |= DIRDB_COMPILENEEDED;
        }

        if (fFirstScan && (DirDB->DirFlags & DIRDB_PASS0NEEDED))
        {
            if (CountPassZeroDirs >= MAX_BUILD_DIRECTORIES) {
                BuildError(
                    "%s: Ignoring PassZero Directory table overflow, %u "
                    "entries allowed\n",
                    DirDB->Name,
                    MAX_BUILD_DIRECTORIES);
            }
            else {
                //
                // This directory needs to be compiled in pass zero.  Add it
                // to the list.
                //
                PassZeroDirs[CountPassZeroDirs++] = DirDB;
            }

            if (fQuicky && !fQuickZero) {
                if (!fSemiQuicky)  // For -Z let CompileSourceDirectories do it.
                    CompilePassZeroDirectories();
                CountPassZeroDirs = 0;
            }
            else {
                if (fFirstScan) {
                    fPassZero = TRUE;     // Limits scanning during pass zero.
                }

                if (DirDB->CountOfPassZeroFiles) {
                    if (fLineCleared) {
                        BuildMsgRaw("    %s ", DirDB->Name);
                    }
                    BuildMsgRaw(
                        "- %d Pass Zero files (%s lines)\n",
                        DirDB->CountOfPassZeroFiles,
                        FormatNumber(DirDB->PassZeroLines));
                }
            }
        }

        if ((DirDB->DirFlags & DIRDB_COMPILENEEDED) &&
            (!fFirstScan || !fPassZero)) {

            if (CountCompileDirs >= MAX_BUILD_DIRECTORIES) {
                BuildError(
                    "%s: Ignoring Compile Directory table overflow, %u "
                    "entries allowed\n",
                    DirDB->Name,
                    MAX_BUILD_DIRECTORIES);
            }
            else {
                //
                // This directory needs to be compiled.  Add it to the list.
                //
                CompileDirs[CountCompileDirs++] = DirDB;
            }

            if (fQuicky && (!fQuickZero || !fFirstScan)) {
                CompileSourceDirectories();
                CountCompileDirs = 0;
            }
            else
            if (DirDB->CountOfFilesToCompile) {
                if (fLineCleared) {
                    BuildMsgRaw("    %s ", DirDB->Name);
                }
                BuildMsgRaw(
                    "- %d source files (%s lines)\n",
                    DirDB->CountOfFilesToCompile,
                    FormatNumber(DirDB->SourceLinesToCompile));
            }
        }
    }

    if (DirsPresent && (DirDB->DirFlags & DIRDB_MAKEFILE)) {
        DirDB->DirFlags |= DIRDB_LINKNEEDED | DIRDB_FORCELINK;
    }
    else
    if (DirDB->DirFlags & DIRDB_TARGETFILES) {
        DirDB->DirFlags |= DIRDB_LINKNEEDED;
    }

    if ((DirDB->DirFlags & DIRDB_LINKNEEDED) && (!fQuicky || fSemiQuicky)) {
        if (CountLinkDirs >= MAX_BUILD_DIRECTORIES) {
            BuildError(
                "%s: Ignoring Link Directory table overflow, %u entries allowed\n",
                DirDB->Name,
                MAX_BUILD_DIRECTORIES);
        }
        else {
            LinkDirs[CountLinkDirs++] = DirDB;
        }
    }
    if ((DirDB->DirFlags & DIRDB_SOURCESREAD) && !fFirstScan) {
        FreeDirSupData(pds);        // free data that are no longer needed
        FreeMem(&pds, MT_DIRSUP);
        DirDB->pds = NULL;
    }

    //
    // Recurse into subdirectories
    //
    if (DirsPresent && !bBaselineFailure) {
        for (i = 1; i <= DirDB->CountSubDirs; i++) {
            FILEREC *FileDB, **FileDBNext;

            FileDBNext = &DirDB->Files;
            while (FileDB = *FileDBNext) {
                if (FileDB->SubDirIndex == (USHORT) i) {
                    GetCurrentDirectory(DB_MAX_PATH_LENGTH, path);
                    strcat(path, "\\");
                    strcat(path, FileDB->Name);
                    DirDB->RecurseLevel = (USHORT) ++RecurseLevel;
                    ScanSourceDirectories(path);
                    RecurseLevel--;
                    break;
                }
                FileDBNext = &FileDB->Next;
            }
        }
    }

    if (((fQuickZero && fFirstScan) || (!fQuicky)) && !RecurseLevel) {
        ClearLine();
    }

    PopCurrentDirectory(SavedCurrentDirectory);
}


//+---------------------------------------------------------------------------
//
//  Function:   CompilePassZeroDirectories
//
//  Synopsis:   Spawns the compiler on the directories in the PassZeroDirs
//              array.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
CompilePassZeroDirectories(
    VOID
    )
{
    PDIRREC DirDB;
    LPSTR SavedCurrentDirectory;
    UINT i;
    PCHAR s;

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    StartElapsedTime();
    for (i = 0; i < CountPassZeroDirs; i++) {

        DirDB = PassZeroDirs[ i ];
        AssertDir(DirDB);

        if (fQuicky && !fSemiQuicky)
            s = "Compiling and linking";
        else
            s = "Building generated files in";
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN);
        BuildMsg("%s %s directory\n", s, DirDB->Name);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        LogMsg("%s %s%s\n", s, DirDB->Name, szAsterisks);

        if ((fQuickZero && fFirstScan) || !fQuicky) {
            SavedCurrentDirectory = PushCurrentDirectory( DirDB->Name );
        }

        if (DirDB->DirFlags & DIRDB_DIRS) {
            if (DirDB->DirFlags & DIRDB_MAKEFIL0) {
                strcpy( MakeParametersTail, " -f makefil0." );
                strcat( MakeParametersTail, " NOLINK=1" );
                if (fClean) {
                    strcat( MakeParametersTail, " clean" );
                }

                if (fQuery) {
                    BuildErrorRaw("'%s %s'\n", MakeProgram, MakeParameters);
                }
                else {
                    if (DEBUG_1) {
                        BuildMsg(
                            "Executing: %s %s\n",
                            MakeProgram,
                            MakeParameters);
                    }

                    CurrentCompileDirDB = NULL;
                    RecurseLevel = DirDB->RecurseLevel;
                    ExecuteProgram(MakeProgram, MakeParameters, MakeTargets, TRUE, DirDB->Name, s);
                }
            }
        }
        else {
            strcpy(MakeParametersTail, " NTTEST=");
            if (DirDB->KernelTest) {
                strcat(MakeParametersTail, DirDB->KernelTest);
            }

            strcat(MakeParametersTail, " UMTEST=");
            if (DirDB->UserTests) {
                strcat(MakeParametersTail, DirDB->UserTests);
            }

            if (DirDB->DirFlags & DIRDB_FULL_DEBUG) {
                strcat( MakeParametersTail, " NTDEBUG=ntsd" );
            }
            if (DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) {
                strcat(MakeParametersTail, szCheckedAltDir);
            }
            if (fQuicky && !fSemiQuicky) {
                if (DirDB->DirFlags & DIRDB_DLLTARGET) {
                    strcat(MakeParametersTail, " MAKEDLL=1");
                }
                ProcessLinkTargets(DirDB, NULL);
            }
            else {
                strcat( MakeParametersTail, " NOLINK=1 PASS0ONLY=1");
            }

            if (fQuery) {
                BuildErrorRaw(
                         "'%s %s%s'\n",
                         MakeProgram,
                         MakeParameters,
                         MakeTargets);
            }
            else {
                if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                    (fParallel)) {
                    //
                    // Wait for all threads to complete before
                    // trying to compile this directory.
                    //
                    WaitForParallelThreads();
                }
                if (DEBUG_1) {
                    BuildMsg("Executing: %s %s%s\n",
                             MakeProgram,
                             MakeParameters,
                             MakeTargets);
                }
                CurrentCompileDirDB = DirDB;
                RecurseLevel = DirDB->RecurseLevel;
                ExecuteProgram(
                            MakeProgram,
                            MakeParameters,
                            MakeTargets,
                            (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK) != 0, DirDB->Name, s);
            }
        }
        PrintElapsedTime();
        if ((fQuickZero && fFirstScan) || !fQuicky) {
            PopCurrentDirectory(SavedCurrentDirectory);
        }

        DirDB->DirFlags &= ~DIRDB_PASS0NEEDED;
        DirDB->CountOfPassZeroFiles = 0;
        DirDB->PassZeroLines = 0;

        if (bBaselineFailure) {
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CompileSourceDirectories
//
//  Synopsis:   Spawns the compiler on the directories in the CompileDirs
//              array.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
CompileSourceDirectories(
    VOID
    )
{
    PDIRREC DirDB;
    LPSTR SavedCurrentDirectory;
    UINT i,j;
    PCHAR s;
    char path[DB_MAX_PATH_LENGTH];

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    StartElapsedTime();
    for (i = 0; i < CountCompileDirs; i++) {

        DirDB = CompileDirs[ i ];

        AssertDir(DirDB);

        if (fQuicky && !fSemiQuicky) {
            s = "Compiling and linking";
        }
        else {
            s = "Compiling";
        }
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN);
        BuildMsg("%s %s directory\n", s, DirDB->Name);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        LogMsg("%s %s directory%s\n", s, DirDB->Name, szAsterisks);

        if (!fQuicky || (fQuickZero && (!fFirstScan || !RecurseLevel))) {
            SavedCurrentDirectory = PushCurrentDirectory( DirDB->Name );
            if (fQuickZero && !RecurseLevel && fFirstScan)
            {
                GenerateObjectsDotMac(DirDB, DirDB->pds, DirDB->pds->DateTimeSources);
            }
        }

        if (DirDB->DirFlags & DIRDB_DIRS) {
            if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                (fParallel)) {
                //
                // Wait for all threads to complete before
                // trying to compile this directory.
                //
                WaitForParallelThreads();
            }
            if (fSemiQuicky && (DirDB->DirFlags & DIRDB_MAKEFIL0)) {
                strcpy( MakeParametersTail, " -f makefil0." );
                strcat( MakeParametersTail, " NOLINK=1" );
                if (fClean) {
                    strcat( MakeParametersTail, " clean" );
                }

                if (fQuery) {
                    BuildErrorRaw("'%s %s'\n", MakeProgram, MakeParameters);
                }
                else {
                    if (DEBUG_1) {
                        BuildMsg(
                            "Executing: %s %s\n",
                            MakeProgram,
                            MakeParameters);
                    }

                    CurrentCompileDirDB = NULL;
                    RecurseLevel = DirDB->RecurseLevel;
                    ExecuteProgram(MakeProgram, MakeParameters, MakeTargets, TRUE, DirDB->Name, s);
                }
            }

            if (DirDB->DirFlags & DIRDB_MAKEFIL1) {
                strcpy( MakeParametersTail, " -f makefil1." );
                strcat( MakeParametersTail, " NOLINK=1 NOPASS0=1" );
                if (fClean) {
                    strcat( MakeParametersTail, " clean" );
                }

                if (fQuery) {
                    BuildErrorRaw("'%s %s'\n", MakeProgram, MakeParameters);
                }
                else {
                    if (DEBUG_1) {
                        BuildMsg(
                            "Executing: %s %s\n",
                            MakeProgram,
                            MakeParameters);
                    }

                    CurrentCompileDirDB = NULL;
                    RecurseLevel = DirDB->RecurseLevel;
                    ExecuteProgram(MakeProgram, MakeParameters, MakeTargets, TRUE, DirDB->Name, s);
                }
            }
        }
        else {
            strcpy(MakeParametersTail, " NTTEST=");
            if (DirDB->KernelTest) {
                strcat(MakeParametersTail, DirDB->KernelTest);
            }

            strcat(MakeParametersTail, " UMTEST=");
            if (DirDB->UserTests) {
                strcat(MakeParametersTail, DirDB->UserTests);
            }

            if (fQuicky && DirDB->PchObj) {
                for (j = 0; j < CountTargetMachines; j++) {
                    FormatLinkTarget(
                        path,
                        TargetMachines[j]->ObjectDirectory,
                        DirDB->TargetPath,
                        DirDB->PchObj,
                        "");

                    if (ProbeFile( NULL, path ) != -1) {
                        //
                        // the pch.obj file is present so we therefore
                        // must do this incremental build without pch
                        //
                        strcat( MakeParametersTail, " NTNOPCH=yes" );
                        break;
                    }
                }
            }

            if (DirDB->DirFlags & DIRDB_FULL_DEBUG) {
                strcat( MakeParametersTail, " NTDEBUG=ntsd" );
            }
            if (DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) {
                strcat(MakeParametersTail, szCheckedAltDir);
            }
            if (fQuicky && !fSemiQuicky) {
                if (DirDB->DirFlags & DIRDB_DLLTARGET) {
                    strcat(MakeParametersTail, " MAKEDLL=1");
                }
                ProcessLinkTargets(DirDB, NULL);
            }
            else
            if (fQuicky && fSemiQuicky) {
                strcat(MakeParametersTail, " NOLINK=1");
            }
            else {
                strcat(MakeParametersTail, " NOLINK=1 NOPASS0=1");
            }

            if (fQuery) {
                BuildErrorRaw(
                         "'%s %s%s'\n",
                         MakeProgram,
                         MakeParameters,
                         MakeTargets);
            }
            else {
                if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                    (fParallel)) {
                    //
                    // Wait for all threads to complete before
                    // trying to compile this directory.
                    //
                    WaitForParallelThreads();
                }
                if (DEBUG_1) {
                    BuildMsg("Executing: %s %s%s\n",
                             MakeProgram,
                             MakeParameters,
                             MakeTargets);
                }
                CurrentCompileDirDB = DirDB;
                RecurseLevel = DirDB->RecurseLevel;
                ExecuteProgram(
                            MakeProgram,
                            MakeParameters,
                            MakeTargets,
                            (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK) != 0, DirDB->Name, s);
            }
        }
        PrintElapsedTime();
        if (!fQuicky || (fQuickZero && (!fFirstScan || !RecurseLevel))) {
            PopCurrentDirectory(SavedCurrentDirectory);
        }
        if (bBaselineFailure) {
            break;
        }
    }
}

static CountLinkTargets;

//+---------------------------------------------------------------------------
//
//  Function:   LinkSourceDirectories
//
//  Synopsis:   Link the directories given in the LinkDirs array.  This is
//              done by passing LINKONLY=1 to nmake.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
LinkSourceDirectories(VOID)
{
    PDIRREC DirDB;
    LPSTR SavedCurrentDirectory;
    UINT i;

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    CountLinkTargets = 0;
    StartElapsedTime();
    for (i = 0; i < CountLinkDirs; i++) {
        DirDB = LinkDirs[ i ];
        AssertDir(DirDB);
        SavedCurrentDirectory = PushCurrentDirectory(DirDB->Name);

        //
        // Deletes link targets as necessary
        //
        ProcessLinkTargets(DirDB, SavedCurrentDirectory);

        PopCurrentDirectory(SavedCurrentDirectory);
    }

    if (fPause) {
        BuildMsg("Press enter to continue with linking (or 'q' to quit)...");
        if (getchar() == 'q') {
            return;
        }
    }

    for (i = 0; i < CountLinkDirs; i++) {
        DirDB = LinkDirs[i];

        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN);
        BuildMsg("Linking %s directory\n", DirDB->Name);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        LogMsg  ("Linking %s directory%s\n", DirDB->Name, szAsterisks);

        if ((DirDB->DirFlags & DIRDB_COMPILEERRORS) &&
            (DirDB->DirFlags & DIRDB_FORCELINK) == 0) {
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
            BuildMsg("Compile errors: not linking %s directory\n", DirDB->Name);
            if (fColorConsole)
                SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
            LogMsg(
                "Compile errors: not linking %s directory%s\n",
                DirDB->Name,
                szAsterisks);
            PrintElapsedTime();
            continue;
        }

        SavedCurrentDirectory = PushCurrentDirectory(DirDB->Name);

        strcpy(MakeParametersTail, " LINKONLY=1 NOPASS0=1");
        strcat(MakeParametersTail, " NTTEST=");
        if (DirDB->KernelTest) {
            strcat(MakeParametersTail, DirDB->KernelTest);
        }

        strcat(MakeParametersTail, " UMTEST=");
        if (DirDB->UserTests) {
            strcat(MakeParametersTail, DirDB->UserTests);
        }

        if (DirDB->DirFlags & DIRDB_FULL_DEBUG) {
            strcat(MakeParametersTail, " NTDEBUG=ntsd");
        }
        if (DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) {
            strcat(MakeParametersTail, szCheckedAltDir);
        }

        if (DirDB->DirFlags & DIRDB_DLLTARGET) {
            strcat(MakeParametersTail, " MAKEDLL=1");
        }

        if ((DirDB->DirFlags & DIRDB_DIRS) &&
            (DirDB->DirFlags & DIRDB_MAKEFILE) &&
            fClean) {
            strcat(MakeParametersTail, " clean");
        }

        if (fQuery) {
            BuildErrorRaw(
                "'%s %s%s'\n",
                MakeProgram,
                MakeParameters,
                MakeTargets);
        }
        else {
            if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                (fParallel) && (fSyncLink)) {
                //
                // Wait for all threads to complete before
                // trying to compile this directory.
                //
                WaitForParallelThreads();
            }
            if (DEBUG_1) {
                BuildMsg("Executing: %s %s%s\n",
                         MakeProgram,
                         MakeParameters,
                         MakeTargets);
            }

            CurrentCompileDirDB = NULL;
            RecurseLevel = DirDB->RecurseLevel;
            ExecuteProgram(MakeProgram,
                           MakeParameters,
                           MakeTargets,
                           (fSyncLink) && (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK) != 0, DirDB->Name, "Linking");
        }
        PopCurrentDirectory(SavedCurrentDirectory);
        PrintElapsedTime();
        
        if (bBaselineFailure) {
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTargetData
//
//  Synopsis:   Searches aTargetInfo for an entry corresponding to the given
//              extension.
//
//  Arguments:  [ext]        -- Extension to look up (including '.').
//              [iPass]      -- 0 for pass zero; 1 for pass 1
//              [index]      -- Index used to differentiate multiple targets
//              [usMidlFlag] -- Indicates which set of MIDL targets should
//                              be used for MIDL source files.
//
//  Returns:    A TARGETDATA for the given extension and index. NULL if
//              Index is invalid.
//
//  History:    29-Jul-94     LyleC    Created
//
//  Notes:      If ext is not found in the aTargetInfo array, then a default
//              TARGETINFO is used which maps the extension to obj\*\.obj.
//
//----------------------------------------------------------------------------

LPTARGETDATA
GetTargetData(LPSTR ext, LONG iPass, USHORT index, ULONG usMidlIndex)
{
    int i;
    OBJECTTARGETINFO **aTargetInfo;
    int cTargetInfo;

    if (!ext || (ext[0] == '\0') || (ext[1] == '\0'))
        return &DefaultData;

    if ((ext[1] == aMidlTargetInfo0[usMidlIndex]->pszSourceExt[1]) &&
        (strcmp(ext, aMidlTargetInfo0[usMidlIndex]->pszSourceExt) == 0))
    {
        if (index >= aMidlTargetInfo0[usMidlIndex]->NumData)
            return NULL;

        return &(aMidlTargetInfo0[usMidlIndex]->Data[index]);
    }

    assert(iPass == 0 || iPass == 1);
    cTargetInfo = aTargetArray[iPass].cTargetInfo;
    aTargetInfo = aTargetArray[iPass].aTargetInfo;

    for (i = 0; i < cTargetInfo; i++)
    {
        if ((ext[1] == aTargetInfo[i]->pszSourceExt[1]) &&
            (strcmp(ext, aTargetInfo[i]->pszSourceExt) == 0))
        {
            if (index >= aTargetInfo[i]->NumData)
                return NULL;

            return(&aTargetInfo[i]->Data[index]);
        }
    }

    if (index)
        return NULL;

    return &DefaultData;
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildCompileTarget
//
//  Synopsis:   Fills a TARGET struct with data about the target of a given
//              source file.
//
//  Arguments:  [pfr]                    -- FileRec of source file
//              [pszfile]                -- Path of source file (compiland)
//              [TargetIndex]            -- Which target for a source file
//                                          with multiple targets.
//              [pszConditionalIncludes] -- List of conditional includes
//              [pdrBuild]               -- Build directory (with source file)
//              [iPass]                  -- 0 for pass zero; 1 for pass 1
//              [ppszObjectDir]          -- Names of target object directories
//              [pszSourceDir]           -- Name of machine specific source dir
//
//  Returns:    A filled TARGET struct.  NULL if TargetIndex is an invalid
//              value for the given file type.
//
//  Notes:      If [pfr] is NULL, then [pszfile] is not modified and is
//              used as the full pathname of the target file.
//              [pszObjectDir] is ignored in this case.  if [pfr] is not
//              NULL, the filename component of [pszfile] is taken, its
//              extension is modified, and it is appended to [pszObjectDir]
//              to obtain the pathname of the target.  The other data is
//              used to fill in the rest of the TARGET struct in all cases.
//
//              For source files with multiple targets, use the TargetIndex
//              parameter to indicate which target you want the path of.  For
//              instance, .idl files have two targets, so a TargetIndex of 0
//              will return the .h target and TargetIndex=1 will return the
//              .c target.  A TargetIndex of 2 or above in this case will
//              return NULL. TargetIndex is ignored if [pfr] is NULL.
//
//----------------------------------------------------------------------------

TARGET *
BuildCompileTarget(
    FILEREC *pfr,
    LPSTR    pszfile,
    USHORT   TargetIndex,
    LPSTR    pszConditionalIncludes,
    DIRREC  *pdrBuild,
    DIRSUP  *pdsBuild,
    LONG     iPass,
    LPSTR   *ppszObjectDir,
    LPSTR    pszSourceDir)
{
    LPSTR p, p1;
    PTARGET Target;
    char path[DB_MAX_PATH_LENGTH];
    LPTARGETDATA pData;

    p = pszfile;
    if (pfr != NULL) {
        p1 = p;
        while (*p) {
            if (*p++ == '\\') {
                p1 = p;         // point to last component of pathname
            }
        }

        sprintf(path, "%s", p1);

        p = strrchr(path, '.');

        pData = GetTargetData(p, iPass, TargetIndex, pdsBuild->IdlType);

        if (!pData) {
            if (DEBUG_1) {
                BuildMsg(
                    "BuildCompileTarget(\"%s\"[%u][%u], \"%s\") -> NULL\n",
                    pszfile,
                    iPass,
                    TargetIndex,
                    ppszObjectDir[iObjectDir]);
            }
            return NULL;
        }

        assert(pdsBuild);

        switch (pData->ObjectDirFlag)
        {
        case TD_OBJECTDIR:
            p = ppszObjectDir[iObjectDir];
            break;

        case TD_PASS0HDRDIR:
            p = pdsBuild->PassZeroHdrDir;
            break;

        case TD_PASS0DIR1:
            p = pdsBuild->PassZeroSrcDir1;
            break;

        case TD_PASS0DIR2:
            p = pdsBuild->PassZeroSrcDir2;
            break;

        default:
            assert(0 && "Invalid ObjectDirFlag");
            break;
        }
        if (p[0] == '.' && p[1] == '\0') {
            strcpy(path, p1);
        }
        else {
            sprintf(path, "%s\\%s", p, p1);
        }

        p = strrchr(path, '.');
        if (p == NULL)
        {
            BuildError("%s NoExtension specified.\n", pszfile);
            return NULL;
        }


        strcpy(p, pData->pszTargetExt);
        p = path;
    }

    AllocMem(sizeof(TARGET) + strlen(p), &Target, MT_TARGET);
    strcpy(Target->Name, p);
    Target->pdrBuild = pdrBuild;
    Target->DateTime = (*pDateTimeFile)(NULL, p);
    Target->pfrCompiland = pfr;
    Target->pszSourceDirectory = pszSourceDir;
    Target->ConditionalIncludes = pszConditionalIncludes;
    Target->DirFlags = pdrBuild->DirFlags;
    if (DEBUG_1) {
        BuildMsg(
            "BuildCompileTarget(\"%s\"[%u][%u], \"%s\") -> \"%s\"\n",
            pszfile,
            iPass,
            TargetIndex,
            ppszObjectDir[iObjectDir],
            Target->Name);
    }
    if (Target->DateTime == 0) {
        if (fShowOutOfDateFiles) {
            BuildError("%s target is missing.\n", Target->Name);
        }
    }
    return(Target);
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatLinkTarget
//
//  Synopsis:   Builds a link target path name.
//
//  Arguments:  [path]            -- Place to put constructed name
//              [ObjectDirectory] -- e.g. "obj\i386"
//              [TargetPath]      -- Path (w/o platfrom spec. name) for target
//              [TargetName]      -- Base name of target
//              [TargetExt]       -- Extension of target
//
//  Notes:      Sample input: (path, "obj\i386", "..\obj", "foobar", ".dll")
//
//                    output: path = "..\obj\i386\foobar.dll"
//
//----------------------------------------------------------------------------

VOID
FormatLinkTarget(
    LPSTR path,
    LPSTR *ObjectDirectory,
    LPSTR TargetPath,
    LPSTR TargetName,
    LPSTR TargetExt)
{
    LPSTR p, p1;

    p = ObjectDirectory[iObjectDir];
    assert(strncmp(pszObjDirSlash, p, strlen(pszObjDirSlash)) == 0);
    p1 = p + strlen(p);
    while (p1 > p) {
        if (*--p1 == '\\') {
            p1++;
            break;
        }
    }
    sprintf(path, "%s\\%s\\%s%s", TargetPath, p1, TargetName, TargetExt);
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessLinkTargets
//
//  Synopsis:   Deletes link targets for the given directory (.lib & .dll)
//
//  Arguments:  [DirDB]            -- Directory to process
//              [CurrentDirectory] -- Current directory
//
//----------------------------------------------------------------------------

VOID
ProcessLinkTargets(PDIRREC DirDB, LPSTR CurrentDirectory)
{
    UINT i;
    char path[DB_MAX_PATH_LENGTH];

    AssertDir(DirDB);
    for (i = 0; i < CountTargetMachines; i++) {
        //
        // Delete 'special' link targets
        //
        if (DirDB->KernelTest) {
            FormatLinkTarget(
                path,
                TargetMachines[i]->ObjectDirectory,
                pszObjDir,
                DirDB->KernelTest,
                ".exe");
            if (fClean && !fKeep && fFirstScan) {
                DeleteSingleFile(NULL, path, FALSE);
            }
        }
        else {
            UINT j;

            for (j = 0; j < 2; j++) {
                LPSTR pNextName;

                pNextName = j == 0? DirDB->UserAppls : DirDB->UserTests;
                if (pNextName != NULL) {
                    char name[256];

                    while (SplitToken(name, '*', &pNextName)) {
                        FormatLinkTarget(
                            path,
                            TargetMachines[i]->ObjectDirectory,
                            pszObjDir,
                            name,
                            ".exe");

                        if (fClean && !fKeep && fFirstScan) {
                            DeleteSingleFile(NULL, path, FALSE);
                        }
                    }
                }
            }
        }

        if (DirDB->TargetPath != NULL &&
            DirDB->TargetName != NULL &&
            DirDB->TargetExt != NULL &&
            strcmp(DirDB->TargetExt, ".lib")) {

            FormatLinkTarget(
                path,
                TargetMachines[i]->ObjectDirectory,
                DirDB->TargetPath,
                DirDB->TargetName,
                DirDB->TargetExt);

            if (fClean && !fKeep && fFirstScan) {
                DeleteSingleFile(NULL, path, FALSE);
            }
        }
        if (DirDB->DirFlags & DIRDB_DIRS) {
            if (fDebug && (DirDB->DirFlags & DIRDB_MAKEFILE)) {
                BuildError(
                    "%s\\makefile. unexpected in directory with DIRS file\n",
                    DirDB->Name);
            }
            if ((DirDB->DirFlags & DIRDB_SOURCES)) {
                BuildError(
                    "%s\\sources. unexpected in directory with DIRS file\n",
                    DirDB->Name);
                BuildError("Ignoring %s\\sources.\n", DirDB->Name);
                DirDB->DirFlags &= ~DIRDB_SOURCES;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   IncludeError
//
//  Synopsis:   Print out the name of an include file and an error message
//              to the screen.
//
//  Arguments:  [pt]       -- Target of the file which includes the include
//                             file or [pfr].
//              [pfr]      -- File which includes the include file
//              [pir]      -- Include file at issue
//              [pszError] -- Error string
//
//  Notes:      If [pt]->pfrCompiland and [pfr] are different, then the names
//              of both are printed.
//
//----------------------------------------------------------------------------

VOID
IncludeError(TARGET *pt, FILEREC *pfr, INCLUDEREC *pir, LPSTR pszError)
{
    char c1, c2;

    AssertFile(pfr);
    AssertInclude(pir);
    if (pir->IncFlags & INCLUDEDB_LOCAL) {
        c1 = c2 = '"';
    }
    else {
        c1 = '<';
        c2 = '>';
    }
    BuildError("%s\\%s: ", pt->pfrCompiland->Dir->Name, pt->pfrCompiland->Name);
    if (pt->pfrCompiland != pfr) {
        if (pt->pfrCompiland->Dir != pfr->Dir) {
            BuildErrorRaw("%s\\", pfr->Dir->Name);
        }
        BuildErrorRaw("%s: ", pfr->Name);
    }
    BuildErrorRaw("%s %c%s%c\n", pszError, c1, pir->Name, c2);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsConditionalInc
//
//  Synopsis:   Returns TRUE if the given filename is a conditional include
//              for this directory.  (As given by the CONDITIONAL_INCLUDES
//              macro).
//
//  Arguments:  [pszFile] -- Name of file to check
//              [pt]      -- Target struct giving list of conditional includes
//
//  Returns:    TRUE if it's a conditional include
//
//----------------------------------------------------------------------------

BOOL
IsConditionalInc(LPSTR pszFile, TARGET *pt)
{
    AssertPathString(pszFile);

    if (pt->ConditionalIncludes != NULL) {
        LPSTR p;
        char name[DB_MAX_PATH_LENGTH];

        p = pt->ConditionalIncludes;
        while (SplitToken(name, ' ', &p)) {
            if (strcmp(name, pszFile) == 0) {
                return(TRUE);
            }
        }
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsExcludedInc
//
//  Synopsis:   Returns TRUE if the given file is listed in the ExcludeIncs
//              array.
//
//  Arguments:  [pszFile] -- File to check
//
//----------------------------------------------------------------------------

BOOL
IsExcludedInc(LPSTR pszFile)
{
    ULONG i;

    AssertPathString(pszFile);
    for (i = 0; i < CountExcludeIncs; i++) {
        if (!strcmp(pszFile, ExcludeIncs[i])) {
            return(TRUE);
        }
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckDependencies
//
//  Synopsis:   Process dependencies to see if a target is out of date
//
//  Arguments:  [Target]    -- Target to check date on (i.e. foo.obj)
//              [FileDB]    -- File which makes [Target] (i.e. foo.cpp, or bar.h)
//              [CheckDate] -- If FALSE, then the date check is bypassed.
//              [ppfrRoot]  -- Returns a cycle root if a cycle is encountered.
//                               Used only during recursion.
//
//  Returns:    TRUE if [Target] is out of date w/r/t [FileDB]
//
//----------------------------------------------------------------------------

BOOL
CheckDependencies(
    PTARGET Target,
    FILEREC *FileDB,
    BOOL CheckDate,
    FILEREC **ppfrRoot)
{
    BOOL fOutOfDate;
    BOOL CheckVersion;
    static ULONG ChkRecursLevel = 0;

    *ppfrRoot = NULL;
    ChkRecursLevel++;

    assert(FileDB != NULL);     // NULL FileDB should never happen.
    AssertFile(FileDB);

    if (FileDB->fDependActive) {

        // We have detected a loop in the graph of included files.
        // Just return, to terminate the recursion.

        if (DEBUG_1) {
            BuildMsgRaw(
                "ChkDepend-1(%s, %s, %u) %s\n",
                Target->Name,
                FileDB->Name,
                CheckDate,
                "Target Match, *** ASSUME UP TO DATE ***");
        }
        if (DEBUG_4) {
            BuildMsgRaw(
                "%lu-%hu/%hu: ChkDepend-2(%s %x, %4s%.*s%s, %u) %x %s\n",
                ChkRecursLevel,
                LocalSequence,
                GlobalSequence,
                Target->Name,
                Target->DateTime,
                "",
                ChkRecursLevel,
                szRecurse,
                FileDB->Name,
                CheckDate,
                FileDB->DateTime,
                "Target Match (recursive) Assume up to date");
        }

        // return the node at which the recursion begins
        *ppfrRoot = FileDB;
        ChkRecursLevel--;
        // we're "up to date" here, because another instance of the
        // file exists in our graph and dependancy will be checked there.
        return(FALSE);
    }
    if (DEBUG_4) {
        BuildMsgRaw(
            "%lu-%hu/%hu: ChkDepend-3(%s %x, %4s%.*s%s, %u) %x\n",
            ChkRecursLevel,
            LocalSequence,
            GlobalSequence,
            Target->Name,
            Target->DateTime,
            "++",
            ChkRecursLevel,
            szRecurse,
            FileDB->Name,
            CheckDate,
            FileDB->DateTime);
    }

    // We've decided to process this file. Mark it as being scanned.
    FileDB->fDependActive = TRUE;
    CheckVersion = fEnableVersionCheck;
    fOutOfDate = FALSE;

    if (FileDB->GlobalSequence != GlobalSequence ||
        FileDB->LocalSequence != LocalSequence) {
        if (FileDB->GlobalSequence != 0 || FileDB->LocalSequence != 0) {
            if (DEBUG_1) {
                BuildError(
                    "Include Sequence %hu/%hu -> %hu/%hu\n",
                    FileDB->LocalSequence,
                    FileDB->GlobalSequence,
                    LocalSequence,
                    GlobalSequence);
            }
            if (fDebug & 16) {
                PrintFileDB(stderr, FileDB, 0);
            }
            UnsnapIncludeFiles(
                FileDB,
                (FileDB->Dir->DirFlags & DIRDB_GLOBAL_INCLUDES) == 0 ||
                    FileDB->GlobalSequence != GlobalSequence);
        }
        FileDB->GlobalSequence = GlobalSequence;
        FileDB->LocalSequence = LocalSequence;
        FileDB->DateTimeTree = 0;
    }

    if (DEBUG_1) {
        BuildMsgRaw(
            "ChkDepend-4(%s, %s, %u)\n",
            Target->Name,
            FileDB->Name,
            CheckDate);
    }

    if (CheckDate &&
        (FileDB->FileFlags & FILEDB_HEADER) &&
        FileDB->DateTimeTree == 0 &&
        IsExcludedInc(FileDB->Name)) {

        if (DEBUG_1) {
            BuildMsg("Skipping date check for %s\n", FileDB->Name);
        }
        CheckVersion = FALSE;
        FileDB->DateTimeTree = 1;       // never out of date
    }

    if (FileDB->IncludeFiles == NULL && FileDB->DateTimeTree == 0) {
        FileDB->DateTimeTree = FileDB->DateTime;
        if (DEBUG_4) {
            BuildMsgRaw(
                "%lu-%hu/%hu: ChkDepend-5(%s %x, %4s%.*s%s, %u) %x\n",
                ChkRecursLevel,
                LocalSequence,
                GlobalSequence,
                Target->Name,
                Target->DateTime,
                "t<-f",
                ChkRecursLevel,
                szRecurse,
                FileDB->Name,
                CheckDate,
                FileDB->DateTime);
        }
    }
    if (CheckDate &&
        (Target->DateTime < FileDB->DateTime ||
         Target->DateTime < FileDB->DateTimeTree)) {
        if (Target->DateTime != 0) {
            if (DEBUG_1 || fShowOutOfDateFiles) {
                BuildMsg("%s is out of date with respect to %s\\%s.\n",
                         Target->Name,
                         FileDB->NewestDependency->Dir->Name,
                         FileDB->NewestDependency->Name);
            }
        }
        fOutOfDate = TRUE;
    }

    //
    // If FileDB->DateTimeTree is non-zero, then the field is equal to the
    // newest DateTime of this file or any of its dependants, so we don't
    // need to go through the dependency tree again.
    //

    if (FileDB->DateTimeTree == 0) {
        INCLUDEREC *IncludeDB, **IncludeDBNext, **ppirTree;

        //
        // Find the file records for all include files so that after cycles are
        // collapsed, we won't attempt to lookup an include file relative to
        // the wrong directory.
        //

        ppirTree = &FileDB->IncludeFilesTree;
        for (IncludeDBNext = &FileDB->IncludeFiles;
            (IncludeDB = *IncludeDBNext) != NULL;
            IncludeDBNext = &IncludeDB->Next) {

            AssertInclude(IncludeDB);
            AssertCleanTree(IncludeDB, FileDB);
            IncludeDB->IncFlags |= INCLUDEDB_SNAPPED;
            if (IncludeDB->pfrInclude == NULL) {
                IncludeDB->pfrInclude =
                    FindIncludeFileDB(
                        FileDB,
                        Target->pfrCompiland,
                        Target->pdrBuild,
                        Target->pszSourceDirectory,
                        IncludeDB);
                AssertOptionalFile(IncludeDB->pfrInclude);
                if (IncludeDB->pfrInclude != NULL &&
                    (IncludeDB->pfrInclude->Dir->DirFlags & DIRDB_GLOBAL_INCLUDES))
                {
                    IncludeDB->IncFlags |= INCLUDEDB_GLOBAL;
                }

            }
            if (IncludeDB->pfrInclude == NULL) {
                if (!IsConditionalInc(IncludeDB->Name, Target)) {
                    if (DEBUG_1 || !(IncludeDB->IncFlags & INCLUDEDB_MISSING)) {
                      if (!fSilentDependencies)
                      {
                          IncludeError(
                              Target,
                              FileDB,
                              IncludeDB,
                              "cannot find include file");
                      }
                      IncludeDB->IncFlags |= INCLUDEDB_MISSING;
                    }
                } else
                if (DEBUG_1) {
                      if (!fSilentDependencies)
                      {
                        IncludeError(
                            Target,
                            FileDB,
                            IncludeDB,
                            "Skipping missing conditional include file");
                      }
                }
                continue;
            }
            *ppirTree = IncludeDB;
            ppirTree = &IncludeDB->NextTree;
        }
        *ppirTree = NULL;       // truncate any links from previous sequence
        FileDB->DateTimeTree = FileDB->DateTime;

        //
        // Walk through the dynamic list.
        //
rescan:
        for (IncludeDBNext = &FileDB->IncludeFilesTree;
            (IncludeDB = *IncludeDBNext) != NULL;
            IncludeDBNext = &IncludeDB->NextTree) {

            AssertInclude(IncludeDB);
            if (DEBUG_2) {
                BuildMsgRaw(
                    "%lu-%hu/%hu %s  %*s%-10s %*s%s\n",
                    ChkRecursLevel,
                    LocalSequence,
                    GlobalSequence,
                    Target->pfrCompiland->Name,
                    (ChkRecursLevel - 1) * 2,
                    "",
                    IncludeDB->Name,
                    max(0, 12 - (ChkRecursLevel - 1) * 2),
                    "",
                    IncludeDB->pfrInclude != NULL?
                        IncludeDB->pfrInclude->Dir->Name : "not found");
            }

            //
            //  tommcg 5/21/98
            //
            //  If included file is not in "sanctioned" path, warn about it.
            //  Sanctioned paths are set in an environment variable named
            //  BUILD_ACCEPTABLE_INCLUDES which can contain wildcards and look
            //  something like this:
            //
            //  *\nt\public\*;*\nt\private\inc\*;*\..\inc\*;*\..\include\*
            //

            if (( fCheckIncludePaths ) && ( IncludeDB->pfrInclude != NULL )) {

                CheckIncludeForWarning(
                    Target->pfrCompiland->Dir->Name,
                    Target->pfrCompiland->Name,
                    FileDB->Dir->Name,
                    FileDB->Name,
                    IncludeDB->pfrInclude->Dir->Name,
                    IncludeDB->pfrInclude->Name
                    );
                }

            assert(IncludeDB->IncFlags & INCLUDEDB_SNAPPED);
            if (IncludeDB->pfrInclude != NULL) {
                if (fEnableVersionCheck) {
                    CheckDate = (IncludeDB->pfrInclude->Version == 0);
                }

                if (IncludeDB->Version != IncludeDB->pfrInclude->Version) {
                    if (CheckVersion) {
                        if (DEBUG_1 || fShowOutOfDateFiles) {
                            BuildError(
                                 "%s (v%d) is out of date with "
                                         "respect to %s\\%s (v%d).\n",
                                 FileDB->Name,
                                 IncludeDB->Version,
                                 IncludeDB->pfrInclude->Dir->Name,
                                 IncludeDB->pfrInclude->Name,
                                 IncludeDB->pfrInclude->Version);
                         }
                        FileDB->DateTimeTree = ULONG_MAX; // always out of date
                        fOutOfDate = TRUE;
                    }
                    else
                    if (!fClean && fEnableVersionCheck) {
                        BuildError(
                            "%s - #include %s (v%d updated to v%d)\n",
                            FileDB->Name,
                            IncludeDB->pfrInclude->Name,
                            IncludeDB->Version,
                            IncludeDB->pfrInclude->Version);
                    }
                    IncludeDB->Version = IncludeDB->pfrInclude->Version;
                    AllDirsModified = TRUE;
                }
                if (CheckDependencies(Target,
                                      IncludeDB->pfrInclude,
                                      CheckDate,
                                      ppfrRoot)) {
                    fOutOfDate = TRUE;

                    // No cycle possible if recursive call returned TRUE.

                    // 29-Dec-1999 LeoN: commented out. See 22-Dec-1999
                    // comment below.
                    // assert(*ppfrRoot == NULL);
                }

                // if the include file is involved in a cycle, unwind the
                // recursion up to the root of the cycle while collpasing
                // the cycle, then process the tree again from cycle root.

                else if (*ppfrRoot != NULL) {

                    AssertFile(*ppfrRoot);

                    // Don't say the file is out of date, yet.

                    // 22-Dec-1999 LeoN: Why not? If the file we are
                    // processing is out of date with respect to it's parent,
                    // that gets lost here. The sebsequent rescan begins at
                    // this file and below, and the relationship to the parent
                    // is never checked again. Fact is, if a file has been
                    // detected as out of date, it's out of date. I'm only
                    // commenting out this reset of the flag. It's possible
                    // that one could avoid the rest of the include file scan
                    // and rescan, but I'm really concerned that there are
                    // important side effects that would miss.

                    // fOutOfDate = FALSE;

                    // Remove the current include file record from the list,
                    // because it participates in the cycle.

                    *IncludeDBNext = IncludeDB->NextTree;
                    if (IncludeDB->IncFlags & INCLUDEDB_CYCLEROOT) {
                        RemoveFromCycleRoot(IncludeDB, FileDB);
                    }
                    IncludeDB->NextTree = NULL;
                    IncludeDB->IncFlags |= INCLUDEDB_CYCLEORPHAN;

                    // If the included file is not the cycle root, add the
                    // cycle root to the included file's include file list.

                    if (*ppfrRoot != IncludeDB->pfrInclude) {
                        LinkToCycleRoot(IncludeDB, *ppfrRoot);
                    }

                    if (*ppfrRoot == FileDB) {

                        // We're at the cycle root; clear the root pointer.
                        // Then go rescan the list.

                        *ppfrRoot = NULL;
                        if (DEBUG_4) {
                            BuildMsgRaw(
                                "%lu-%hu/%hu: ChkDepend-6(%s %x, %4s%.*s%s, %u) %x %s\n",
                                ChkRecursLevel,
                                LocalSequence,
                                GlobalSequence,
                                Target->Name,
                                Target->DateTime,
                                "^^",
                                ChkRecursLevel,
                                szRecurse,
                                FileDB->Name,
                                CheckDate,
                                FileDB->DateTime,
                                "ReScan");
                            BuildMsgRaw("^^\n");
                        }
                        goto rescan;
                    }

                    // Merge the list for the file involved in the
                    // cycle into the root file's include list.

                    MergeIncludeFiles(
                        *ppfrRoot,
                        FileDB->IncludeFilesTree,
                        FileDB);
                    FileDB->IncludeFilesTree = NULL;

                    // Return immediately and reprocess the flattened
                    // tree, which now excludes the include files
                    // directly involved in the cycle.  First, make
                    // sure the files removed from the cycle have their file
                    // (not tree) time stamps reflected in the cycle root.

                    if ((*ppfrRoot)->DateTimeTree < FileDB->DateTime) {
                        (*ppfrRoot)->DateTimeTree = FileDB->DateTime;
                        (*ppfrRoot)->NewestDependency = FileDB;

                        if (DEBUG_4) {
                            BuildMsgRaw(
                                "%lu-%hu/%hu: ChkDepend-7(%s %x, %4s%.*s%s, %u) %x\n",
                                ChkRecursLevel,
                                LocalSequence,
                                GlobalSequence,
                                Target->Name,
                                Target->DateTime,
                                "t<-c",
                                ChkRecursLevel,
                                szRecurse,
                                (*ppfrRoot)->Name,
                                CheckDate,
                                (*ppfrRoot)->DateTimeTree);
                        }
                    }
                    break;
                }

                //
                // Propagate newest time up through the dependency tree.
                // This way, each parent will have the date of its newest
                // dependent, so we don't have to check through the whole
                // dependency tree for each file more than once.
                //
                // Note that similar behavior has not been enabled for
                // version checking.
                //

                if (FileDB->DateTimeTree < IncludeDB->pfrInclude->DateTimeTree)
                {
                    FileDB->DateTimeTree = IncludeDB->pfrInclude->DateTimeTree;
                    FileDB->NewestDependency =
                        IncludeDB->pfrInclude->NewestDependency;

                    if (DEBUG_4) {
                        BuildMsgRaw(
                            "%lu-%hu/%hu: ChkDepend-8(%s %x, %4s%.*s%s, %u) %x\n",
                            ChkRecursLevel,
                            LocalSequence,
                            GlobalSequence,
                            Target->Name,
                            Target->DateTime,
                            "t<-s",
                            ChkRecursLevel,
                            szRecurse,
                            FileDB->Name,
                            CheckDate,
                            FileDB->DateTimeTree);
                    }
                }
            }
            else
            {
                //
                // Couldn't find the FILEDB for the include file, but this
                // could be because the file is 'rcinclude'd, or 'importlib'd
                // and isn't considered a source file.  In this case, just get
                // the timestamp on the file if possible.
                //
                // Time will be zero if the file is not found.
                //
                ULONG Time = (*pDateTimeFile)(NULL, IncludeDB->Name);
                if (FileDB->DateTimeTree < Time)
                {
                    FileDB->DateTimeTree = Time;
                    //
                    // Since we don't have a FILEDB for this dependency, just
                    // set the pointer to itself and print a message.
                    //
                    FileDB->NewestDependency = FileDB;

                    if (DEBUG_1 || fShowOutOfDateFiles) {
                        BuildError(
                             "%s (v%d) is out of date with respect to %s.\n",
                             FileDB->Name,
                             IncludeDB->Version,
                             IncludeDB->Name);
                    }

                    if (DEBUG_4) {
                        BuildMsgRaw(
                            "%lu-%hu/%hu: ChkDepend-9(%s %x, %4s%.*s%s, %u) %x\n",
                            ChkRecursLevel,
                            LocalSequence,
                            GlobalSequence,
                            Target->Name,
                            Target->DateTime,
                            "t<-s",
                            ChkRecursLevel,
                            szRecurse,
                            FileDB->Name,
                            CheckDate,
                            FileDB->DateTimeTree);
                    }

                }
            }
        }
    }
    if (DEBUG_4) {
        BuildMsgRaw(
            "%lu-%hu/%hu: ChkDepend-A(%s %x, %4s%.*s%s, %u) %x %s\n",
            ChkRecursLevel,
            LocalSequence,
            GlobalSequence,
            Target->Name,
            Target->DateTime,
            "--",
            ChkRecursLevel,
            szRecurse,
            FileDB->Name,
            CheckDate,
            FileDB->DateTimeTree,
            *ppfrRoot != NULL? "Collapse Cycle" :
                fOutOfDate? "OUT OF DATE" : "up-to-date");
    }
    assert(FileDB->fDependActive);
    FileDB->fDependActive = FALSE;
    ChkRecursLevel--;
    return(fOutOfDate);
}



//+---------------------------------------------------------------------------
//
//  Function:   PickFirst
//
//  Synopsis:   When called iteratively, the set of returned values is
//              effectively a merge sort of the two source lists.
//
//  Effects:    The pointers given in [ppsr1] and [ppsr2] are modified to point
//              to the next appropriate item in the list.
//
//  Arguments:  [ppsr1] -- First SOURCEREC list
//              [ppsr2] -- Second SOURCEREC list
//
//  Returns:    The appropriate next item from either [ppsr1] or [ppsr2]
//
//  Notes:      [ppsr1] and [ppsr2] should each be appropriately sorted.
//
// InsertSourceDB maintains a sort order for PickFirst() based first on the
// filename extension, then on the subdirectory mask.  Two exceptions to the
// alphabetic sort are:
//             - No extension sorts last.
//             - .rc extension sorts first.
//
//----------------------------------------------------------------------------

#define PF_FIRST        -1
#define PF_SECOND       1

SOURCEREC *
PickFirst(SOURCEREC **ppsr1, SOURCEREC **ppsr2)
{
    SOURCEREC **ppsr;
    SOURCEREC *psr;
    int r = 0;

    AssertOptionalSource(*ppsr1);
    AssertOptionalSource(*ppsr2);
    if (*ppsr1 == NULL) {
        if (*ppsr2 == NULL) {
            return(NULL);               // both lists NULL -- no more
        }
        r = PF_SECOND;                  // 1st is NULL -- return 2nd
    }
    else if (*ppsr2 == NULL) {
        r = PF_FIRST;                   // 2nd is NULL -- return 1st
    }
    else {
        LPSTR pszext1, pszext2;

        pszext1 = strrchr((*ppsr1)->pfrSource->Name, '.');
        pszext2 = strrchr((*ppsr2)->pfrSource->Name, '.');
        if (pszext1 == NULL) {
            r = PF_SECOND;              // 1st has no extension -- return 2nd
        }
        else if (pszext2 == NULL) {
            r = PF_FIRST;               // 2nd has no extension -- return 1st
        }
        else if (strcmp(pszext1, ".rc") == 0) {
            r = PF_FIRST;               // 1st is .rc -- return 1st
        }
        else if (strcmp(pszext2, ".rc") == 0) {
            r = PF_SECOND;              // 2nd is .rc -- return 2nd
        }
        else {
            r = strcmp(pszext1, pszext2);
            if (r == 0 &&
                (*ppsr1)->SourceSubDirMask != (*ppsr2)->SourceSubDirMask) {
                if ((*ppsr1)->SourceSubDirMask > (*ppsr2)->SourceSubDirMask) {
                    r = PF_FIRST;       // 2nd subdir after 1st -- return 1st
                } else {
                    r = PF_SECOND;      // 1st subdir after 2nd -- return 2nd
                }
            }
        }
    }
    if (r <= 0) {
        ppsr = ppsr1;
    } else {
        ppsr = ppsr2;
    }
    psr = *ppsr;
    *ppsr = psr->psrNext;
    return(psr);
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteObjectsDefinition
//
//  Synopsis:   Writes out a single platform-specific section of the
//              _objects.mac file.
//
//  Arguments:  [OutFileHandle]   -- File handle to write to
//              [psrCommon]       -- List of common source files
//              [psrMachine]      -- List of machine-specific source files
//              [DirDB]           -- directory record
//              [ObjectVariable]  -- e.g.  386_SOURCES
//              [ObjectDirectory] -- name of machine obj dir (e.g. obj\i386)
//
//  Returns:
//
//  History:    26-Jul-94     LyleC    Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
WriteObjectsDefinition(
    FILE *OutFileHandle,
    SOURCEREC *psrMachine,
    DIRSUP *pds,
    LPSTR ObjectVariable,
    LPSTR ObjectDirectory,
    DIRREC *DirDB
    )
{
    LPSTR        pbuf;
    LPSTR        pszextsrc;
    LPSTR        pszextdir;
    LPTARGETDATA pData;
    SOURCEREC   *psrComCopy;
    SOURCEREC   *psrMachCopy;
    SOURCEREC *psrCommon = pds->psrSourcesList[0];
    LPSTR DirName = DirDB->Name;

    SOURCEREC *psr;
    USHORT  i;
    LONG iPass;

    //
    // We loop twice - the first time writing out the non-pass-zero files
    // to the ObjectVariable, the second time writing out pass zero
    // files to the PASS0_ObjectVariable.
    //
    for (iPass = 1; iPass >= 0; iPass--)
    {
        pbuf = BigBuf;

        pbuf[0] = '\0';
        if (iPass == 0) {
            strcpy(pbuf, "PASS0_");
        }
        strcat(pbuf, ObjectVariable);
        strcat(pbuf, "=");
        pbuf += strlen(pbuf);

        psrComCopy = psrCommon;
        psrMachCopy = psrMachine;

        while ((psr = PickFirst(&psrComCopy, &psrMachCopy)) != NULL) {

            AssertSource(psr);
            if ((psr->SrcFlags & SOURCEDB_SOURCES_LIST) == 0) {
                continue;
            }

            // if pass 0 macro and not a pass 0 file, skip it.

            if (iPass == 0 && !(psr->pfrSource->FileFlags & FILEDB_PASS0))
                continue;

            // if pass 1 macro and not a pass 1 file, skip it.

            if (iPass == 1 &&
                (psr->pfrSource->FileFlags & FILEDB_PASS0) &&
                !(psr->pfrSource->FileFlags & FILEDB_MULTIPLEPASS))
                continue;

            pszextsrc = strrchr(psr->pfrSource->Name, '.');

            i = 0;
            while (pData = GetTargetData(pszextsrc, iPass, i, pds->IdlType))
            {
                if (pData == &DefaultData)
                {
                    //
                    // Check for implicitly 'known' extensions...
                    //
                    if (pszextsrc == NULL)
                    {
                        BuildError(
                            "%s: Interesting sources extension: %s\n",
                            DirName,
                            psr->pfrSource->Name);
                    }
                    else 
                    {

                        switch (pszextsrc[1]) {
                        case 'f':      // Fortran
                        case 'h':      // Header file ?
                        case 'p':      // Pascal
                            BuildError(
                                "%s: Interesting sources extension: %s\n",
                                DirName,
                                psr->pfrSource->Name);
                            // FALL THROUGH

                        case 'a':    // Assembly file (.asm)
                        case 'c':    // C file (.c or .cxx)
                        case 's':    // Assembly file (.s)
                            break;

                        default:
                            BuildError("Bad sources extension: %s\n",
                                       psr->pfrSource->Name);
                        }
                    }
                }

                switch (pData->ObjectDirFlag)
                {
                case TD_OBJECTDIR:
                    pszextdir = ObjectDirectory;
                    break;

                case TD_PASS0HDRDIR:
                    pszextdir = "$(PASS0_HEADERDIR)";
                    break;

                case TD_PASS0DIR1:
                  pszextdir = (DirDB->DirFlags & DIRDB_IDLTYPERPC) ? "$(PASS0_CLIENTDIR)" : "$(PASS0_SOURCEDIR)";
                    break;

                case TD_PASS0DIR2:
                  pszextdir = (DirDB->DirFlags & DIRDB_IDLTYPERPC) ? "$(PASS0_SERVERDIR)" : "$(PASS0_UUIDDIR)";
                    break;

                default:
                    assert(0 && "Invalid ObjectDirFlag");
                    break;
                }
                assert(pszextdir);
                assert(pData->pszTargetExt);

                sprintf(
                    pbuf,
                    " \\\r\n    %s\\%.*s%s",
                    pszextdir,
                    pszextsrc - psr->pfrSource->Name,
                    psr->pfrSource->Name,
                    pData->pszTargetExt);
                pbuf += strlen(pbuf);

                i++;
            }
        }
        strcpy(pbuf, "\r\n\r\n");
        pbuf += 4;

        fwrite(BigBuf, 1, (UINT) (pbuf - BigBuf), OutFileHandle);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateBuildDirectory
//
//  Synopsis:   Creates a directory to hold generate object files.  SET the
//              FILE_ATTRIBUTE_ARCHIVE bit for the directory, since there is nothing
//              to backup.  We use SET since the default setting for a new directory
//              is clear.  Go figure.  DOS was such a well planned product.
//
//  Arguments:  [Name]            -- Directory to create
//
//  Returns:    TRUE if directory already exists or was created successfully.
//              FALSE otherwise.
//----------------------------------------------------------------------------

BOOL
CreateBuildDirectory(LPSTR Name)
{
    DWORD Attributes;

    Attributes = GetFileAttributes(Name);
    if (Attributes == -1) {
        CreateDirectory(Name, NULL);
        Attributes = GetFileAttributes(Name);
    }

    if (Attributes != -1 && ((Attributes & FILE_ATTRIBUTE_ARCHIVE) == 0)) {
        SetFileAttributes(Name, Attributes | FILE_ATTRIBUTE_ARCHIVE);
    }

    return((BOOL)(Attributes != -1));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreatedBuildFile
//
//  Synopsis:   Called whenever BUILD creates a file.  Clears the FILE_ATTRIBUTE_ARCHIVE
//              bit for the file, since there is nothing to backup with a generated file.
//
//  Arguments:  [DirName]         -- DIRDB for directory
//              [FileName]        -- file name path relative to DirName
//
//----------------------------------------------------------------------------

VOID
CreatedBuildFile(LPSTR DirName, LPSTR FileName)
{
    char Name[ DB_MAX_PATH_LENGTH ];
    DWORD Attributes;

    strcpy(Name, DirName);
    if (Name[0] != '\0') {
        strcat(Name, "\\");
    }
    strcat(Name, FileName);

    Attributes = GetFileAttributes(Name);
    if (Attributes != -1 && (Attributes & FILE_ATTRIBUTE_ARCHIVE)) {
        SetFileAttributes(Name, Attributes & ~FILE_ATTRIBUTE_ARCHIVE);
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   GenerateObjectsDotMac
//
//  Synopsis:   Creates the _objects.mac file containing info for all platforms
//
//  Arguments:  [DirDB]           -- Directory to create file for
//              [pds]             -- Supplementary information on [DirDB]
//              [DateTimeSources] -- Timestamp of the SOURCES file
//
//----------------------------------------------------------------------------

VOID
GenerateObjectsDotMac(DIRREC *DirDB, DIRSUP *pds, ULONG DateTimeSources)
{
    FILE *OutFileHandle;
    UINT i;
    ULONG ObjectsDateTime;
    char szObjectsMac[_MAX_PATH];

    strcpy(szObjectsMac, szObjDir);
    strcat(szObjectsMac, "\\_objects.mac");

    CreateBuildDirectory(szObjDir);
    for (i = 0; i < CountTargetMachines; i++) {
        assert(strncmp(
                    pszObjDirSlash,
                    TargetMachines[i]->ObjectDirectory[iObjectDir],
                    strlen(pszObjDirSlash)) == 0);
        CreateBuildDirectory(TargetMachines[i]->ObjectDirectory[iObjectDir]);
    }

    if (ObjectsDateTime = (*pDateTimeFile)(DirDB->Name, szObjectsMac)) {

        if (DateTimeSources == 0) {
            BuildError("%s: no sources timestamp\n", DirDB->Name);
        }

        if (ObjectsDateTime >= DateTimeSources) {
            if (!fForce) {
                return;
            }
        }
    }
    if (!MyOpenFile(DirDB->Name, szObjectsMac, "wb", &OutFileHandle, TRUE)) {
        return;
    }

    if ((DirDB->DirFlags & DIRDB_SOURCES_SET) == 0) {
        BuildError("Missing SOURCES= definition in %s\n", DirDB->Name);
    } else {
        for (i = 0; i < MAX_TARGET_MACHINES; i++) {
            WriteObjectsDefinition(
                OutFileHandle,
                pds->psrSourcesList[i + 1],
                pds,
                PossibleTargetMachines[i]->ObjectVariable,
                PossibleTargetMachines[i]->ObjectMacro,
                DirDB);
        }
    }
    fclose(OutFileHandle);
    CreatedBuildFile(DirDB->Name, szObjectsMac);

    //
    // If the _objects.mac file was generated during the first pass, then we
    // want to regenerate it during the second scan because the first scan
    // wasn't complete and _objects.mac may not be correct for non-pass-zero
    // files.  We do this by setting the timestamp back to the old time.
    //
    if (fFirstScan && fPassZero)
    {
        HANDLE hf;
        FILETIME ft;

        hf = CreateFile(szObjectsMac, GENERIC_WRITE, 0,
                (LPSECURITY_ATTRIBUTES)NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
                (HANDLE)NULL);

        if (hf != INVALID_HANDLE_VALUE) {
            ULONG time;

            if (ObjectsDateTime) {
                time = ObjectsDateTime;
            }
            else if (DateTimeSources) {
                //
                // All we care about is that time time stamp on _objects.mac
                // is less than that of the sources file so it will get
                // regenerated during the second scan.
                //
                time = DateTimeSources;
                if (LOWORD(time) != 0)
                    time &= 0xFFFF0000;  // 00:00:00 on the same date
                else
                    time = 0x1421A000;       // 12:00:00 1/1/1990
            }
            else {
                time = 0x1421A000;       // 12:00:00 1/1/1990
            }

            DosDateTimeToFileTime(HIWORD(time), LOWORD(time), &ft);

            SetFileTime(hf, (LPFILETIME)NULL, (LPFILETIME)NULL, &ft);

            CloseHandle(hf);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\build\builddb.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994
//
//  File:       builddb.c
//
//  Contents:   Contains the file and directory database manipulation
//              functions.
//
//  History:    16-May-94     SteveWo  Created
//                 ... see SLM logs
//              26-Jul-94     LyleC    Cleanup/Add Pass0 Support
//
//----------------------------------------------------------------------------

#include "build.h"

BOOL fAssertCleanTree = FALSE;

typedef struct _FLAGSTRINGS {
    ULONG Mask;
    LPSTR pszName;
} FLAGSTRINGS;

FLAGSTRINGS DirFlags[] = {
    { DIRDB_SOURCES,          "Sources" },
    { DIRDB_DIRS,             "Dirs" },
    { DIRDB_MAKEFILE,         "Makefile" },
    { DIRDB_MAKEFIL0,           "Makefil0" },
    { DIRDB_TARGETFILE0,        "Targetfile0" },
    { DIRDB_TARGETFILES,        "Targetfiles" },
    { DIRDB_RESOURCE,           "Resource" },
    { DIRDB_PASS0,              "PassZero" },
    { DIRDB_SOURCES_SET,        "SourcesSet" },
    { DIRDB_FULL_DEBUG,         "FullDebug" },
    { DIRDB_CHICAGO_INCLUDES,   "ChicagoIncludes" },
    { DIRDB_NEW,                "New" },
    { DIRDB_SCANNED,            "Scanned" },
    { DIRDB_SHOWN,              "Shown" },
    { DIRDB_GLOBAL_INCLUDES,    "GlobalIncludes" },
    { DIRDB_SYNCHRONIZE_BLOCK,  "SynchronizeBlock" },
    { DIRDB_SYNCHRONIZE_DRAIN,  "SynchronizeDrain" },
    { DIRDB_COMPILENEEDED,      "CompileNeeded" },
    { DIRDB_COMPILEERRORS,      "CompileErrors" },
    { DIRDB_SOURCESREAD,        "SourcesRead" },
    { DIRDB_DLLTARGET,          "DllTarget" },
    { DIRDB_LINKNEEDED,         "LinkNeeded" },
    { DIRDB_FORCELINK,          "ForceLink" },
    { DIRDB_PASS0NEEDED,        "Pass0Needed" },
    { DIRDB_MAKEFIL1,           "Makefil1" },
    { DIRDB_CHECKED_ALT_DIR,    "CheckedAltDir" },
    { 0,                        NULL },
};

FLAGSTRINGS FileFlags[] = {
    { FILEDB_SOURCE,            "Source" },
    { FILEDB_DIR,               "Dir" },
    { FILEDB_HEADER,            "Header" },
    { FILEDB_ASM,               "Asm" },
    { FILEDB_MASM,              "Masm" },
    { FILEDB_RC,                "Rc" },
    { FILEDB_C,                 "C" },
    { FILEDB_MIDL,              "Midl" },
    { FILEDB_ASN,               "Asn" },
    { FILEDB_JAVA,              "Java" },
    { FILEDB_MOF,               "ManagedObjectFormat" },
    { FILEDB_VBP,               "VB" },
    { FILEDB_SCANNED,           "Scanned" },
    { FILEDB_OBJECTS_LIST,      "ObjectsList" },
    { FILEDB_FILE_MISSING,      "FileMissing" },
    { FILEDB_MKTYPLIB,          "MkTypeLib" },
    { FILEDB_MULTIPLEPASS,      "MultiplePass" },
    { FILEDB_PASS0,             "PassZero" },
    { 0,                        NULL },
};

FLAGSTRINGS IncludeFlags[] = {
    { INCLUDEDB_LOCAL,        "Local" },
    { INCLUDEDB_POST_HDRSTOP,   "PostHdrStop" },
    { INCLUDEDB_MISSING,        "Missing" },
    { INCLUDEDB_GLOBAL,         "Global" },
    { INCLUDEDB_SNAPPED,        "Snapped" },
    { INCLUDEDB_CYCLEALLOC,     "CycleAlloc" },
    { INCLUDEDB_CYCLEROOT,      "CycleRoot" },
    { INCLUDEDB_CYCLEORPHAN,    "CycleOrphan" },
    { 0,                        NULL },
};

FLAGSTRINGS SourceFlags[] = {
    { SOURCEDB_SOURCES_LIST,    "SourcesList" },
    { SOURCEDB_FILE_MISSING,    "FileMissing" },
    { SOURCEDB_PCH,             "Pch" },
    { SOURCEDB_OUT_OF_DATE,     "OutOfDate" },
    { SOURCEDB_COMPILE_NEEDED,  "CompileNeeded" },
    { 0,                        NULL },
};

//
// Function prototypes
//

VOID
FreeFileDB(PFILEREC *FileDB);

VOID
PrintFlags(FILE *pf, ULONG Flags, FLAGSTRINGS *pfs);


//+---------------------------------------------------------------------------
//
//  Function:   CheckSum
//
//  Synopsis:   Returns a checksum value for a string.
//
//----------------------------------------------------------------------------

USHORT
CheckSum(LPSTR psz)
{
    USHORT sum = 0;

    while (*psz != '\0') {
        if (sum & 0x8000) {
            sum = ((sum << 1) | 1) + *psz++;
        }
        else {
            sum = (sum << 1) + *psz++;
        }
    }
    return(sum);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindSourceDirDB
//
//  Synopsis:   Builds a path from the two given components and returns
//              a filled DIRREC structure from it.
//
//  Arguments:  [pszDir]            -- Directory
//              [pszRelPath]        -- Path relative to [pszDir]
//              [fTruncateFileName] -- Remove a filename from [pszRelPath]
//
//  Returns:    A filled DIRREC structure for the given directory.
//
//  Notes:      If the directory does not exist in the data base, then a
//              DIRREC structure will be returned with the DIRDB_NEW flag
//              set and no other data (i.e.  the directory will not have
//              been scanned.)
//
//----------------------------------------------------------------------------

DIRREC *
FindSourceDirDB(
    LPSTR pszDir,               // directory
    LPSTR pszRelPath,           // relative path
    BOOL fTruncateFileName)     // TRUE: drop last component of path
{
    LPSTR pszFile;
    char path[DB_MAX_PATH_LENGTH];

    AssertPathString(pszDir);
    AssertPathString(pszRelPath);
    strcpy(path, pszDir);
    if (path[0] != '\0')
        strcat(path, "\\");
    strcat(path, pszRelPath);

    pszFile = path + strlen(path);
    if (fTruncateFileName) {
        while (pszFile > path) {
            pszFile--;
            if (*pszFile == '\\' || *pszFile == '/') {
                *pszFile = '\0';
                break;
            }
        }
    }
    if (!CanonicalizePathName(path, CANONICALIZE_ONLY, path)) {
        return(NULL);
    }
    if (DEBUG_4) {
        BuildMsgRaw(
            "FindSourceDirDB(%s, %s, %u)\n",
            path,
            pszFile,
            fTruncateFileName);
    }
    AssertPathString(path);
    return(LoadDirDB(path));
}


//+---------------------------------------------------------------------------
//
//  Function:   FindSourceFileDB
//
//  Synopsis:   Returns a FILEREC with information about the given file.
//
//  Arguments:  [pdr]        -- DIRREC giving directory from which to start
//                                looking for [pszRelPath]
//              [pszRelPath] -- Relative path from [pdr] of the file
//              [ppdr]       -- [out] DIRREC of directory actually containing
//                                the file.  Can be NULL.
//
//  Returns:    FILEREC for file of interest.
//
//  Notes:      If the directory containing the file has not yet been scanned,
//              then it will be scanned using ScanDirectory().
//
//----------------------------------------------------------------------------

FILEREC *
FindSourceFileDB(
    DIRREC *pdr,
    LPSTR pszRelPath,
    DIRREC **ppdr)
{
    LPSTR p, pszFile;

    AssertPathString(pszRelPath);

    if (strchr(pszRelPath, '\\') != NULL) {
        // There's a path component in this filename.  Let's see where it points to.
        if ( (pszRelPath[0] == '\\') ||   /* Absolute from root or UNC Path */
             (pszRelPath[1] == ':' ))     /* drive : path  */
        {
            pdr = FindSourceDirDB("", pszRelPath, TRUE);
        } else {
            pdr = FindSourceDirDB(pdr->Name, pszRelPath, TRUE);
        }
    }
    if (ppdr != NULL) {
        *ppdr = pdr;
    }
    if (pdr == NULL ) {
        return(NULL);
    }
    pszFile = pszRelPath;
    for (p = pszFile; *p != '\0'; p++) {
        if (*p == '\\') {
            pszFile = p + 1;
        }
    }
    if (DEBUG_4) {
        BuildMsgRaw("FindSourceFileDB(%s, %s)\n", pdr->Name, pszFile);
    }

    //
    // Scan the directory containing the file if we haven't already.
    //
    if ((pdr->DirFlags & DIRDB_SCANNED) == 0) {
        if (DEBUG_1) {
            BuildMsgRaw(
                "FindSourceFileDB(%s, %s) Delayed scan\n",
                pdr->Name,
                pszFile);
        }
        pdr = ScanDirectory(pdr->Name);
        if (pdr == NULL) {
            return(NULL);
        }
    }

    return(LookupFileDB(pdr, pszFile));
}


//+---------------------------------------------------------------------------
//
//  Function:   InsertSourceDB
//
//  Synopsis:   Insert a file listed in SOURCES= into a list of SOURCEREC
//              structures.
//
//  Arguments:  [ppsrNext]   -- Head of list of sources files to add to.
//              [pfr]        -- File to be inserted.
//              [SubDirMask] -- Indicates what directory the file is in.
//                                 (Current, Parent, or a machine-specific dir)
//              [SrcFlags]   -- SOURCEDB flags appropriate to this file.
//
//  Returns:    SOURCEREC that was inserted. May be ignored.
//
//  Notes:      InsertSourceDB maintains a sort order for PickFirst() based
//              first on the filename extension, then on the subdirectory
//              mask.
//
//              Two exceptions to the alphabetic sort are:
//                   - No extension sorts last.
//                   - .rc extension sorts first.
//
//              If the file is already in the list of sources then this
//              function just updates the flags and returns.
//
//----------------------------------------------------------------------------

SOURCEREC *
InsertSourceDB(
    SOURCEREC **ppsrNext,
    FILEREC *pfr,
    UCHAR SubDirMask,
    UCHAR SrcFlags)
{
    SOURCEREC *psr;
    SOURCEREC **ppsrInsert;
    LPSTR pszext;
    BOOL fRC;

    AssertFile(pfr);

    ppsrInsert = NULL;
    pszext = strrchr(pfr->Name, '.');
    fRC = FALSE;
    if (pszext != NULL && _stricmp(pszext, ".rc") == 0) {
        fRC = TRUE;
    }
    for ( ; (psr = *ppsrNext) != NULL; ppsrNext = &psr->psrNext) {
        LPSTR p;
        int r;

        AssertSource(psr);
        if (psr->pfrSource == pfr) {
            assert(psr->SourceSubDirMask == SubDirMask);
            psr->SrcFlags = SrcFlags;
            return(psr);
        }
        if (ppsrInsert == NULL && pszext != NULL) {
            if ((p = strrchr(psr->pfrSource->Name, '.')) == NULL) {
                r = -1;                 // insert new file here
            }
            else {
                r = strcmp(pszext, p);
                if (r != 0) {
                    if (fRC) {
                        r = -1;         // insert new RC file here
                    }
                    else if (strcmp(p, ".rc") == 0) {
                        r = 1;          // old RC file comes first
                    }
                }
            }
            if (r < 0 || SubDirMask > psr->SourceSubDirMask) {
                ppsrInsert = ppsrNext;
            }
        }
    }
    AllocMem(sizeof(SOURCEREC), &psr, MT_SOURCEDB);
    memset(psr, 0, sizeof(*psr));
    SigCheck(psr->Sig = SIG_SOURCEREC);

    if (ppsrInsert != NULL) {
        ppsrNext = ppsrInsert;
    }
    psr->psrNext = *ppsrNext;
    *ppsrNext = psr;

    psr->pfrSource = pfr;
    psr->SourceSubDirMask = SubDirMask;
    psr->SrcFlags = SrcFlags;
    return(psr);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindSourceDB
//
//  Synopsis:   Finds the SOURCEREC in a list which corresponds to the given
//              FILEREC.
//
//----------------------------------------------------------------------------

SOURCEREC *
FindSourceDB(
    SOURCEREC *psr,
    FILEREC *pfr)
{

    while (psr != NULL) {
        AssertSource(psr);
        if (psr->pfrSource == pfr) {
            return(psr);
        }
        psr = psr->psrNext;
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeSourceDB
//
//  Synopsis:   Frees a list of SOURCERECs
//
//  Arguments:  [ppsr] -- List to free
//
//----------------------------------------------------------------------------

VOID
FreeSourceDB(SOURCEREC **ppsr)
{
    if (*ppsr != NULL) {
        SOURCEREC *psr;
        SOURCEREC *psrNext;

        psr = *ppsr;
        AssertSource(psr);
        psrNext = psr->psrNext;
        SigCheck(psr->Sig = 0);
        FreeMem(ppsr, MT_SOURCEDB);
        *ppsr = psrNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeIncludeDB
//
//----------------------------------------------------------------------------

VOID
FreeIncludeDB(INCLUDEREC **ppir)
{
    if (*ppir != NULL) {
        INCLUDEREC *pir;
        INCLUDEREC *pirNext;

        pir = *ppir;
        AssertInclude(pir);
        AssertCleanTree(pir, NULL);      // Tree must be clean
        pirNext = pir->Next;
        SigCheck(pir->Sig = 0);
        FreeMem(ppir, MT_INCLUDEDB);
        *ppir = pirNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeFileDB
//
//----------------------------------------------------------------------------

VOID
FreeFileDB(FILEREC **ppfr)
{
    if (*ppfr != NULL) {
        FILEREC *pfr;
        FILEREC *pfrNext;

        pfr = *ppfr;
        AssertFile(pfr);
        UnsnapIncludeFiles(pfr, TRUE);
        while (pfr->IncludeFiles) {
            FreeIncludeDB(&pfr->IncludeFiles);
        }
        pfrNext = pfr->Next;
        SigCheck(pfr->Sig = 0);
        FreeMem(ppfr, MT_FILEDB);
        *ppfr = pfrNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeDirDB
//
//----------------------------------------------------------------------------

VOID
FreeDirDB(DIRREC **ppdr)
{
    if (*ppdr != NULL) {
        DIRREC *pdr;
        DIRREC *pdrNext;

        pdr = *ppdr;
        AssertDir(pdr);
        FreeDirData(pdr);
        while (pdr->Files) {
            FreeFileDB(&pdr->Files);
        }
        pdrNext = pdr->Next;
        SigCheck(pdr->Sig = 0);
        FreeMem(ppdr, MT_DIRDB);
        *ppdr = pdrNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeAllDirs
//
//----------------------------------------------------------------------------

VOID
FreeAllDirs(VOID)
{
    while (AllDirs != NULL) {
        FreeDirDB(&AllDirs);
#if DBG
        if (fDebug & 8) {
            BuildMsgRaw("Freed one directory\n");
            PrintAllDirs();
        }
#endif
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupDirDB
//
//  Synopsis:   Searches the database for a given directory.
//
//  Arguments:  [DirName] -- Directory to search for.
//
//  Returns:    DIRREC of the given directory.  NULL if not found.
//
//  Notes:      If the directory is not in the database it will not be added.
//              Use LoadDirDB in this case.
//
//----------------------------------------------------------------------------

PDIRREC
LookupDirDB(
    LPSTR DirName
    )
{
    PDIRREC *DirDBNext = &AllDirs;
    PDIRREC DirDB;
    USHORT sum;

    AssertPathString(DirName);
    sum = CheckSum(DirName);
    while (DirDB = *DirDBNext) {
        if (sum == DirDB->CheckSum && strcmp(DirName, DirDB->Name) == 0) {

            if (DirDB->FindCount == 0 && fForce) {
                FreeDirDB(DirDBNext);
                return(NULL);
            }
            DirDB->FindCount++;

            // Move to head of list to make next lookup faster

            // *DirDBNext = DirDB->Next;
            // DirDB->Next = AllDirs;
            // AllDirs = DirDB;

            return(DirDB);
        }
        DirDBNext = &DirDB->Next;
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadDirDB
//
//  Synopsis:   Searches the database for a directory name, and if not found
//              creates a new DIRREC entry in the database.
//
//  Arguments:  [DirName] -- Directory to search for.
//
//  Returns:    Filled in DIRREC structure for the given directory.
//
//  Notes:      The directory will not be scanned if it wasn't in the
//              database.  Use ScanDirectory to scan the directory,
//              however, note that InsertSourceDB will automatically scan
//              the directory only when necessary.
//
//----------------------------------------------------------------------------

PDIRREC
LoadDirDB(
    LPSTR DirName
    )
{
    UINT i;
    PDIRREC DirDB, *DirDBNext;
    LPSTR s;

    AssertPathString(DirName);
    if (DirDB = LookupDirDB(DirName)) {
        return(DirDB);
    }

    if (ProbeFile(NULL, DirName) == -1) {
        return( NULL );
    }

    DirDBNext = &AllDirs;
    while (DirDB = *DirDBNext) {
        DirDBNext = &DirDB->Next;
    }

    AllDirsModified = TRUE;

    AllocMem(sizeof(DIRREC) + strlen(DirName), &DirDB, MT_DIRDB);
    memset(DirDB, 0, sizeof(*DirDB));
    SigCheck(DirDB->Sig = SIG_DIRREC);

    DirDB->DirFlags = DIRDB_NEW;
    DirDB->FindCount = 1;
    CopyString(DirDB->Name, DirName, TRUE);
    DirDB->CheckSum = CheckSum(DirDB->Name);

    for (i = 0; i < CountFullDebugDirs; i++) {
        if (s = strstr(DirDB->Name, FullDebugDirectories[i])) {
            if (s > DirDB->Name && s[-1] == '\\') {
                s += strlen( FullDebugDirectories[ i ] );
                if (*s == '\0' || *s == '\\') {
                    FullDebugDirsUsed[i] = TRUE;
                    DirDB->DirFlags |= DIRDB_FULL_DEBUG;
                    break;
                }
            }
        }
    }

    if (DEBUG_1) {
        BuildMsgRaw("LoadDirDB creating %s\n", DirDB->Name);
    }

    *DirDBNext = DirDB;
    return( DirDB );
}

//+---------------------------------------------------------------------------
//
//  Debug helper functions to print parts of the database.
//
//----------------------------------------------------------------------------

#if DBG
VOID
PrintAllDirs(VOID)
{
    DIRREC **ppdr, *pdr;

    for (ppdr = &AllDirs; (pdr = *ppdr) != NULL; ppdr = &pdr->Next) {
        PrintDirDB(pdr, 1|2|4);
    }
}
#endif


VOID
PrintFlags(FILE *pf, ULONG Flags, FLAGSTRINGS *pfs)
{
    LPSTR p = ",";

    while (pfs->pszName != NULL) {
        if (pfs->Mask & Flags) {
            fprintf(pf, "%s %s", p, pfs->pszName);
            p = "";
        }
        pfs++;
    }
    fprintf(pf, szNewLine);
}


BOOL
PrintIncludes(FILE *pf, FILEREC *pfr, BOOL fTree)
{
    INCLUDEREC *pir;
    BOOL fMatch = pfr->IncludeFilesTree == pfr->IncludeFiles;

    pir = fTree? pfr->IncludeFilesTree : pfr->IncludeFiles;
    while (pir != NULL) {
        LPSTR pszdir = "<No File Record>";
        char OpenQuote, CloseQuote;

        if (pir->IncFlags & INCLUDEDB_LOCAL) {
            OpenQuote = CloseQuote = '"';
        }
        else {
            OpenQuote = '<';
            CloseQuote = '>';
        }

        fprintf(
            pf,
            "   %c#include %c%s%c",
            fMatch? ' ' : fTree? '+' : '-',
            OpenQuote,
            pir->Name,
            CloseQuote);
        if (pir->Version != 0) {
            fprintf(pf, " (v%d)", pir->Version);
        }
        if (pir->pfrCycleRoot != NULL) {
            fprintf(
                pf,
                " (root=%s\\%s)",
                pir->pfrCycleRoot->Dir->Name,
                pir->pfrCycleRoot->Name);
        }
        if (pir->pfrInclude != NULL) {
            if (pir->pfrInclude->Dir == pfr->Dir) {
                pszdir = ".";
            }
            else {
                pszdir = pir->pfrInclude->Dir->Name;
            }
        }
        fprintf(pf, " %s", pszdir);
        PrintFlags(pf, pir->IncFlags, IncludeFlags);
        if (pir->NextTree != pir->Next) {
            fMatch = FALSE;
        }
        pir = fTree? pir->NextTree : pir->Next;
    }
    return(fMatch);
}


VOID
PrintSourceDBList(SOURCEREC *psr, int i)
{
    TARGET_MACHINE_INFO *pMachine;

    pMachine = i < 0 ? TargetMachines[0] : PossibleTargetMachines[i];

    for ( ; psr != NULL; psr = psr->psrNext) {
        assert(
            (psr->SourceSubDirMask & ~TMIDIR_PARENT) == 0 ||
            pMachine->SourceSubDirMask ==
                (psr->SourceSubDirMask & ~TMIDIR_PARENT));
        BuildMsgRaw(
            "    %s%s%s%s%s",
            (psr->SourceSubDirMask & TMIDIR_PARENT)? "..\\" : "",
            (psr->SourceSubDirMask & ~TMIDIR_PARENT)?
                pMachine->SourceDirectory : "",
            (psr->SourceSubDirMask & ~TMIDIR_PARENT)? "\\" : "",
            psr->pfrSource->Name,
            (psr->SrcFlags & SOURCEDB_PCH)?
                " (pch)" :
                (psr->SrcFlags & SOURCEDB_SOURCES_LIST) == 0?
                    " (From exe list)" : "");
        PrintFlags(stderr, psr->SrcFlags, SourceFlags);
    }
}


VOID
PrintFileDB(FILE *pf, FILEREC *pfr, int DetailLevel)
{
    fprintf(pf, "  File: %s", pfr->Name);
    if (pfr->FileFlags & FILEDB_DIR) {
        fprintf(pf, " (Sub-Directory)");
    }
    else
    if (pfr->FileFlags & (FILEDB_SOURCE | FILEDB_HEADER)) {
        LPSTR pszType = (pfr->FileFlags & FILEDB_SOURCE)? "Source" : "Header";

        if (pfr->FileFlags & FILEDB_ASM) {
            fprintf(pf, " (Assembler (CPP) %s File)", pszType);
        }
        else
        if (pfr->FileFlags & FILEDB_MASM) {
            fprintf(pf, " (Assembler (MASM) %s File)", pszType);
        }
        else
        if (pfr->FileFlags & FILEDB_RC) {
            fprintf(pf, " (Resource Compiler (RC) %s File)", pszType);
        }
        else
        if (pfr->FileFlags & FILEDB_MIDL) {
            fprintf(pf, " (MIDL %s File)", pszType);
        }
        else
        if (pfr->FileFlags & FILEDB_ASN) {
            fprintf(pf, " (ASN %s File)", pszType);
        }
        else
        if (pfr->FileFlags & FILEDB_MKTYPLIB) {
            fprintf(pf, " (Type Library (MkTypLib) %s File)", pszType);
        }
        else {
            fprintf(pf, " (C %s File)", pszType);
        }
        if ((pfr->FileFlags & FILEDB_HEADER) && pfr->Version != 0) {
            fprintf(pf, " (v%d)", pfr->Version);
        }
        if (pfr->GlobalSequence != 0) {
            fprintf(pf, " (GlobalSeq=%d)", pfr->GlobalSequence);
        }
        if (pfr->LocalSequence != 0) {
            fprintf(pf, " (LocalSeq=%d)", pfr->LocalSequence);
        }
        fprintf(pf, " - %u lines", pfr->SourceLines);
    }
    PrintFlags(pf, pfr->FileFlags, FileFlags);

    if (pfr->IncludeFiles != NULL) {
        BOOL fMatch;

        fMatch = PrintIncludes(pf, pfr, FALSE);
        if (pfr->IncludeFilesTree != NULL) {
            fprintf(pf, "   IncludeTree %s\n", fMatch? "matches" : "differs:");
            if (!fMatch) {
                PrintIncludes(pf, pfr, TRUE);
            }
        }
    }
}


VOID
PrintDirDB(DIRREC *pdr, int DetailLevel)
{
    FILE *pf = stderr;
    FILEREC *pfr, **ppfr;

    if (DetailLevel & 1) {
        fprintf(pf, "Directory: %s", pdr->Name);
        if (pdr->DirFlags & DIRDB_DIRS) {
            fprintf(pf, " (Dirs Present)");
        }
        if (pdr->DirFlags & DIRDB_SOURCES) {
            fprintf(pf, " (Sources Present)");
        }
        if (pdr->DirFlags & DIRDB_MAKEFILE) {
            fprintf(pf, " (Makefile Present)");
        }
        PrintFlags(pf, pdr->DirFlags, DirFlags);
    }
    if (DetailLevel & 2) {
        if (pdr->TargetPath != NULL) {
            fprintf(pf, "  TargetPath: %s\n", pdr->TargetPath);
        }
        if (pdr->TargetName != NULL) {
            fprintf(pf, "  TargetName: %s\n", pdr->TargetName);
        }
        if (pdr->TargetExt != NULL) {
            fprintf(pf, "  TargetExt: %s\n", pdr->TargetExt);
        }
        if (pdr->KernelTest != NULL) {
            fprintf(pf, "  KernelTest: %s\n", pdr->KernelTest);
        }
        if (pdr->UserAppls != NULL) {
            fprintf(pf, "  UserAppls: %s\n", pdr->UserAppls);
        }
        if (pdr->UserTests != NULL) {
            fprintf(pf, "  UserTests: %s\n", pdr->UserTests);
        }
        if (pdr->PchObj != NULL) {
            fprintf(pf, "  PchObj: %s\n", pdr->PchObj);
        }
        if (pdr->Pch != NULL) {
            fprintf(pf, "  Pch: %s\n", pdr->Pch);
        }
    }
    if (DetailLevel & 4) {
        for (ppfr = &pdr->Files; (pfr = *ppfr) != NULL; ppfr = &pfr->Next) {
            PrintFileDB(pf, pfr, DetailLevel);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupFileDB
//
//  Synopsis:   Search the database for the given file.
//
//  Arguments:  [DirDB]    -- Directory containing the file
//              [FileName] -- File to look for
//
//  Returns:    FILEREC of file if found, NULL if not.
//
//  Notes:      The file will not be added to the database if not already
//              there.
//
//----------------------------------------------------------------------------

PFILEREC
LookupFileDB(
    PDIRREC DirDB,
    LPSTR FileName
    )
{
    PFILEREC FileDB, *FileDBNext;
    USHORT sum;

    AssertPathString(FileName);
    sum = CheckSum(FileName);
    if (DEBUG_4) {
        BuildMsgRaw("LookupFileDB(%s, %s) - ", DirDB->Name, FileName);
    }
    FileDBNext = &DirDB->Files;
    while (FileDB = *FileDBNext) {
        if (sum == FileDB->CheckSum && strcmp(FileName, FileDB->Name) == 0) {
            if (DEBUG_4) {
                BuildMsgRaw("success\n");
            }
            return(FileDB);
        }
        FileDBNext = &FileDB->Next;
    }

    if (DEBUG_4) {
        BuildMsgRaw("failure\n");
    }
    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  FILEDESC
//
//  FileDesc is a table describing file names and patterns that we recognize
//  and handle specially.  WARNING:  This table is ordered so the patterns
//  at the front are necessarily more specific than those later on.
//
//----------------------------------------------------------------------------

char szMakefile[] = "#";
char szClang[]    = "//";
char szAsn[]      = "--";
char szMasm[]     = ";";

//
// N.B. The first entry in the file descriptor list is an entry that is
//      optionally filled with the name of the target dirs file for the
//      first build target.
//

FILEDESC FileDesc[] =
{   { "/0dirs",       szMakefile,  FALSE, 0,    DIRDB_DIRS },
    { "makefile",     szMakefile,  FALSE, 0,    DIRDB_MAKEFILE },
    { "makefil0",     szMakefile,  FALSE, 0,    DIRDB_MAKEFIL0 | DIRDB_PASS0 },
    { "makefil1",     szMakefile,  FALSE, 0,    DIRDB_MAKEFIL1 },
    { "sources",      szMakefile,  FALSE, 0,    DIRDB_SOURCES },
    { "dirs",         szMakefile,  FALSE, 0,    DIRDB_DIRS },
    { "mydirs",       szMakefile,  FALSE, 0,    DIRDB_DIRS },

    { "makefile.inc", szMakefile,  FALSE, 0,                            0 },
    { "common.ver",   szClang,     TRUE,  FILEDB_HEADER,                0 },

    { ".rc",          szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE },
    { ".rc2",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE },
    { ".rcs",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE },
    { ".rcv",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE },
    { ".ver",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE },
    { ".c",           szClang,     TRUE,  FILEDB_SOURCE | FILEDB_C,     0 },
    { ".cxx",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_C,     0 },
    { ".cpp",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_C,     0 },
    { ".f",           szClang,     TRUE,  FILEDB_SOURCE,                0 },
    { ".p",           szClang,     TRUE,  FILEDB_SOURCE,                0 },
    { ".s",           szClang,     TRUE,  FILEDB_SOURCE | FILEDB_ASM,   0 },
    { ".asm",         szMasm,      TRUE,  FILEDB_SOURCE | FILEDB_MASM,  0 },
    { ".mc",          szMasm,      TRUE,  FILEDB_SOURCE | FILEDB_RC |
                                          FILEDB_PASS0, DIRDB_PASS0 },
    { ".idl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MIDL |
                                          FILEDB_PASS0, DIRDB_PASS0 },
    { ".asn",         szAsn,       TRUE,  FILEDB_SOURCE | FILEDB_ASN |
                                          FILEDB_MULTIPLEPASS | FILEDB_PASS0,
                                          DIRDB_PASS0 },
    { ".tdl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MKTYPLIB | FILEDB_PASS0, 0 },
    { ".odl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MKTYPLIB | FILEDB_PASS0, 0 },
    { ".pdl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_PASS0, 0 },
    { ".h",           szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".hxx",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".hpp",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".hmd",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".hdl",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".inl",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".rh",          szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".dlg",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_RC,    0 },
    { ".inc",         szMasm,      TRUE,  FILEDB_HEADER | FILEDB_MASM,  0 },
    { ".src",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },  // see mvdm\softpc.new\obj.vdm\imlibdep.c
    { ".def",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".thk",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MULTIPLEPASS |
                                          FILEDB_PASS0, DIRDB_PASS0 },
    { ".java",        szClang,     TRUE,  FILEDB_SOURCE | FILEDB_JAVA,  0 },
    { ".mof",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MOF |
                                          FILEDB_PASS0, DIRDB_PASS0 },
    { ".vbp",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_VBP,  0 },

// MUST BE LAST
    { NULL,           "",          FALSE, 0,                            0 }
};


//+---------------------------------------------------------------------------
//
//  Function:   MatchFileDesc
//
//  Synopsis:   Matches the given filename to an entry in FileDesc, if
//              possible.
//
//  Arguments:  [pszFile] -- File to match
//
//  Returns:    A FILEDESC structure.  If a match was not found the data
//              in the FILEDESC will be empty.
//
//----------------------------------------------------------------------------

FILEDESC *
MatchFileDesc(LPSTR pszFile)
{
    LPSTR pszExt = strrchr(pszFile, '.');
    FILEDESC *pfd;

    // treat extensionless file as .h
    // CONSIDER checking exactly for known files, new, memory, algorithm, vector, list, cstdio, cstdlib, etc.
    // CONSIDER also instead doing this where #include is parsed, to avoid doing it in
    // all cases (i.e., not from .rc or .c files). That'd presumably be in ScanFile.
    if (pszExt == NULL)
        pszExt = ".h";

    AssertPathString(pszFile);
    pfd = &FileDesc[0];

    while (pfd->pszPattern != NULL) {
        if (pfd->pszPattern[0] == '.') {
            if (pszExt != NULL && !strcmp(pszExt, pfd->pszPattern))
                break;
        }
        else
        if (!strcmp(pszFile, pfd->pszPattern))
            break;

        pfd++;
    }
    return pfd;
}


//+---------------------------------------------------------------------------
//
//  Function:   InsertFileDB
//
//  Synopsis:   Adds a file to the database.
//
//  Arguments:  [DirDB]     -- Directory containing the file
//              [FileName]  -- File to add
//              [DateTime]  -- Timestamp of file
//              [Attr]      -- File attributes (directory or file)
//              [FileFlags] -- FILEDB flags
//
//  Returns:    New FILEREC of file
//
//----------------------------------------------------------------------------

PFILEREC
InsertFileDB(
    PDIRREC DirDB,
    LPSTR FileName,
    ULONG DateTime,
    USHORT Attr,
    ULONG  FileFlags)
{
    PFILEREC FileDB, *FileDBNext;
    LPSTR pszCommentToEOL = NULL;

    AssertPathString(FileName);
    if (Attr & FILE_ATTRIBUTE_DIRECTORY) {
        if (!strcmp(FileName, ".")) {
            return(NULL);
        }
        if (!strcmp(FileName, "..")) {
            return(NULL);
        }
        assert(FileFlags == 0);
        FileFlags = FILEDB_DIR;
    }
    else {
        FILEDESC *pfd = MatchFileDesc(FileName);

        DirDB->DirFlags |= pfd->DirFlags;
        FileFlags |= pfd->FileFlags;

        if (!pfd->fNeedFileRec) {
            return (NULL);
        }
        pszCommentToEOL = pfd->pszCommentToEOL;
    }

    FileDBNext = &DirDB->Files;

    while ((FileDB = *FileDBNext) != NULL) {
        FileDBNext = &(*FileDBNext)->Next;
        if (strcmp(FileName, FileDB->Name) == 0) {
            BuildError(
                "%s: ignoring second instance of %s\n",
                DirDB->Name,
                FileName);
            return(NULL);
        }
    }

    AllocMem(sizeof(FILEREC) + strlen(FileName), &FileDB, MT_FILEDB);
    memset(FileDB, 0, sizeof(*FileDB));
    SigCheck(FileDB->Sig = SIG_FILEREC);

    CopyString(FileDB->Name, FileName, TRUE);
    FileDB->CheckSum = CheckSum(FileDB->Name);

    FileDB->DateTime = DateTime;
    FileDB->Attr = Attr;
    FileDB->Dir = DirDB;
    FileDB->FileFlags = FileFlags;
    FileDB->NewestDependency = FileDB;
    FileDB->pszCommentToEOL = pszCommentToEOL;

    if ((FileFlags & FILEDB_FILE_MISSING) == 0) {
        AllDirsModified = TRUE;
    }
    *FileDBNext = FileDB;
    return(FileDB);
}



//+---------------------------------------------------------------------------
//
//  Function:   DeleteUnscannedFiles
//
//  Synopsis:   Removes unscanned files (leaving scanned files and directories)
//              from the Files list of the given directory
//
//  Arguments:  [DirDB] -- Directory to clean up
//
//----------------------------------------------------------------------------

VOID
DeleteUnscannedFiles(
    PDIRREC DirDB
    )
{
    PFILEREC FileDB, *FileDBNext;

    FileDBNext = &DirDB->Files;
    while (FileDB = *FileDBNext) {
        //
        // If a file has the missing flag set then it doesn't exist.  But for
        // it to be in the list of files it has to be listed in a SOURCES line
        // (or some equivalent).  This means there is a SOURCEREC somewhere
        // which is pointing to the FILEREC for that file, so we don't want to
        // free its memory.
        //
        if ( (FileDB->FileFlags & (FILEDB_SCANNED | FILEDB_FILE_MISSING)) ||
             (FileDB->Attr & FILE_ATTRIBUTE_DIRECTORY) ) {
            FileDBNext = &FileDB->Next;
            }
        else {
            FreeFileDB( FileDBNext );
            AllDirsModified = TRUE;
            }
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   InsertIncludeDB
//
//  Synopsis:   Inserts an include file into the database
//
//  Arguments:  [FileDB]          -- File which includes this file
//              [IncludeFileName] -- Name of include file
//              [IncFlags]        -- INCLUDEDB flags for this file
//
//  Returns:    INCLUDEREC of previously existing or new entry one.
//
//----------------------------------------------------------------------------

PINCLUDEREC
InsertIncludeDB(
    PFILEREC FileDB,
    LPSTR IncludeFileName,
    USHORT IncFlags
    )
{
    PINCLUDEREC IncludeDB, *IncludeDBNext;

    AssertPathString(IncludeFileName);

    IncludeDBNext = &FileDB->IncludeFiles;

    while (IncludeDB = *IncludeDBNext) {
        AssertCleanTree(IncludeDB, FileDB);      // Tree must be clean
        if (!strcmp(IncludeDB->Name, IncludeFileName)) {
            IncludeDB->IncFlags &= ~INCLUDEDB_GLOBAL;
            IncludeDB->pfrInclude = NULL;
            return(IncludeDB);
        }
        IncludeDBNext = &IncludeDB->Next;
    }

    AllocMem(
        sizeof(INCLUDEREC) + strlen(IncludeFileName),
        IncludeDBNext,
        MT_INCLUDEDB);

    IncludeDB = *IncludeDBNext;

    memset(IncludeDB, 0, sizeof(*IncludeDB));
    SigCheck(IncludeDB->Sig = SIG_INCLUDEREC);

    IncludeDB->IncFlags = IncFlags;
    CopyString(IncludeDB->Name, IncludeFileName, TRUE);

    AllDirsModified = TRUE;

    return(IncludeDB);
}


//+---------------------------------------------------------------------------
//
//  Function:   LinkToCycleRoot
//
//----------------------------------------------------------------------------

VOID
LinkToCycleRoot(INCLUDEREC *pirOrg, FILEREC *pfrCycleRoot)
{
    INCLUDEREC *pir;

    AllocMem(
        sizeof(INCLUDEREC) + strlen(pfrCycleRoot->Name),
        &pir,
        MT_INCLUDEDB);
    memset(pir, 0, sizeof(*pir));
    SigCheck(pir->Sig = SIG_INCLUDEREC);

    pir->IncFlags = INCLUDEDB_SNAPPED | INCLUDEDB_CYCLEALLOC;
    pir->pfrInclude = pfrCycleRoot;

    CopyString(pir->Name, pfrCycleRoot->Name, TRUE);
    if (DEBUG_1) {
        BuildMsgRaw(
            "%x CycleAlloc  %s\\%s <- %s\\%s\n",
            pir,
            pir->pfrInclude->Dir->Name,
            pir->pfrInclude->Name,
            pirOrg->pfrInclude->Dir->Name,
            pirOrg->pfrInclude->Name);
    }

    MergeIncludeFiles(pirOrg->pfrInclude, pir, NULL);

    assert((pir->IncFlags & INCLUDEDB_CYCLEORPHAN) == 0);
    assert(pir->IncFlags & INCLUDEDB_CYCLEROOT);
}


//+---------------------------------------------------------------------------
//
//  Function:   MergeIncludeFiles
//
//----------------------------------------------------------------------------

VOID
MergeIncludeFiles(FILEREC *pfr, INCLUDEREC *pirList, FILEREC *pfrRoot)
{
    INCLUDEREC *pirT;
    INCLUDEREC *pir, **ppir;

    while ((pirT = pirList) != NULL) {
        pirList = pirList->NextTree;
        pirT->NextTree = NULL;
        assert(pirT->pfrInclude != NULL);

        for (ppir = &pfr->IncludeFilesTree;
             (pir = *ppir) != NULL;
             ppir = &pir->NextTree) {

            if (pirT->pfrInclude == pir->pfrInclude) {
                if (pirT->IncFlags & INCLUDEDB_CYCLEROOT) {
                    RemoveFromCycleRoot(pirT, pfrRoot);
                }
                pirT->IncFlags |= INCLUDEDB_CYCLEORPHAN;
                if (DEBUG_1) {
                    BuildMsgRaw(
                        "%x CycleOrphan %s\\%s <- %s\\%s\n",
                        pirT,
                        pirT->pfrInclude->Dir->Name,
                        pirT->pfrInclude->Name,
                        pfr->Dir->Name,
                        pfr->Name);
                }
                break;
            }
        }
        if (*ppir == NULL) {
            *ppir = pirT;
            pirT->pfrCycleRoot = pfr;
            pirT->IncFlags |= INCLUDEDB_CYCLEROOT;
            if (DEBUG_1) {
                BuildMsgRaw(
                    "%x CycleRoot   %s\\%s <- %s\\%s\n",
                    pirT,
                    pirT->pfrInclude->Dir->Name,
                    pirT->pfrInclude->Name,
                    pirT->pfrCycleRoot->Dir->Name,
                    pirT->pfrCycleRoot->Name);
            }
        }
    }
    if (fDebug & 16) {
        PrintFileDB(stderr, pfr, 2);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   RemoveFromCycleRoot
//
//----------------------------------------------------------------------------

VOID
RemoveFromCycleRoot(INCLUDEREC *pir, FILEREC *pfrRoot)
{
    INCLUDEREC **ppir;

    assert(pir->pfrCycleRoot != NULL);

    // if pfrRoot was passed in, the caller knows it's on pfrRoot's list,
    // and is already dealing with the linked list without our help.

    if (pfrRoot != NULL) {
        assert((pir->IncFlags & INCLUDEDB_CYCLEALLOC) == 0);
        assert(pir->pfrCycleRoot == pfrRoot);
        pir->pfrCycleRoot = NULL;
        pir->IncFlags &= ~INCLUDEDB_CYCLEROOT;
        if (DEBUG_1) {
            BuildMsgRaw(
                "%x CycleUnroot %s\\%s <- %s\\%s\n",
                pir,
                pir->pfrInclude->Dir->Name,
                pir->pfrInclude->Name,
                pfrRoot->Dir->Name,
                pfrRoot->Name);
        }
        return;
    }
    ppir = &pir->pfrCycleRoot->IncludeFilesTree;
    while (*ppir != NULL) {
        if (*ppir == pir) {
            *ppir = pir->NextTree;      // remove from tree list
            pir->NextTree = NULL;
            pir->pfrCycleRoot = NULL;
            pir->IncFlags &= ~INCLUDEDB_CYCLEROOT;
            return;
        }
        ppir = &(*ppir)->NextTree;
    }
    BuildError(
        "%s\\%s: %x %s: not on cycle root's list\n",
        pir->pfrCycleRoot->Dir->Name,
        pir->pfrCycleRoot->Name,
        pir,
        pir->Name);

    assert(pir->pfrCycleRoot == NULL);  // always asserts if loop exhausted
}


//+---------------------------------------------------------------------------
//
//  Function:   UnsnapIncludeFiles
//
//  Synopsis:   Removes pointers from INCLUDEREC to the actual FILEREC of
//              the include file so we can 'resnap' them.
//
//  Arguments:  [pfr]           -- FILEREC to unsnap
//              [fUnsnapGlobal] -- If TRUE, global and local includes are
//                                 unsnapped. Otherwise, just local ones are.
//
//----------------------------------------------------------------------------

VOID
UnsnapIncludeFiles(FILEREC *pfr, BOOL fUnsnapGlobal)
{
    INCLUDEREC **ppir;
    INCLUDEREC *pir;

    // Dynamic Tree List:
    //  - no cycle orphans
    //  - cycle roots must belong to current file record
    //  - cycle allocs must be freed

    AssertFile(pfr);
    while (pfr->IncludeFilesTree != NULL) {
        pir = pfr->IncludeFilesTree;            // pick up next entry
        AssertInclude(pir);
        pfr->IncludeFilesTree = pir->NextTree;  // remove from tree list

        assert((pir->IncFlags & INCLUDEDB_CYCLEORPHAN) == 0);

        if (pir->IncFlags & (INCLUDEDB_CYCLEROOT | INCLUDEDB_CYCLEALLOC)) {

            // unsnap the record

            pir->IncFlags &= ~(INCLUDEDB_SNAPPED | INCLUDEDB_GLOBAL);
            pir->pfrInclude = NULL;
            pir->NextTree = NULL;
        }

        if (pir->IncFlags & INCLUDEDB_CYCLEROOT) {
            assert(pir->pfrCycleRoot == pfr);
            pir->pfrCycleRoot = NULL;
            pir->IncFlags &= ~INCLUDEDB_CYCLEROOT;
        }
        assert(pir->pfrCycleRoot == NULL);

        if (pir->IncFlags & INCLUDEDB_CYCLEALLOC) {
            pir->IncFlags &= ~INCLUDEDB_CYCLEALLOC;
            assert(pir->Next == NULL);
            FreeIncludeDB(&pir);
        }
    }

    // Static List:
    //  - no cycle allocs
    //  - cycle roots must be removed from a different file's Dynamic list
    //  - cycle orphans are nops

    for (ppir = &pfr->IncludeFiles; (pir = *ppir) != NULL; ppir = &pir->Next) {
        assert((pir->IncFlags & INCLUDEDB_CYCLEALLOC) == 0);
        if (pir->IncFlags & INCLUDEDB_CYCLEROOT) {
            assert(pir->pfrCycleRoot != pfr);
            RemoveFromCycleRoot(pir, NULL);
        }
        pir->IncFlags &= ~INCLUDEDB_CYCLEORPHAN;

        if (pir->pfrInclude != NULL &&
            (fUnsnapGlobal ||
             (pir->pfrInclude->Dir->DirFlags & DIRDB_GLOBAL_INCLUDES) == 0)) {

            // unsnap the record

            pir->IncFlags &= ~(INCLUDEDB_SNAPPED | INCLUDEDB_GLOBAL);
            pir->pfrInclude = NULL;
        }
        pir->NextTree = NULL;
    }
}

#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   AssertCleanTree
//
//  Synopsis:   Enforce that no include files are snapped.
//
//  Arguments:  [pir] - include record to test
//              [pfr] - optional containing file record
//
//----------------------------------------------------------------------------

VOID
AssertCleanTree(INCLUDEREC *pir, OPTIONAL FILEREC *pfr)
{
    if (IsCleanTree(pir)) {
        return;
    }
    if (fAssertCleanTree) {
        BuildMsgRaw("\n*************************************\n");
        BuildMsgRaw("Persistent Cycle: pir=%x: %s\n", pir, pir->Name);
        if (pfr != NULL) {
            BuildMsgRaw("    pfr=%x: %s\n", pfr, pfr->Name);
            if (pfr->Dir != NULL) {
                BuildMsgRaw("    pdr=%x: %s\n", pfr->Dir, pfr->Dir->Name);
            }
        }
        if (pir->pfrInclude != NULL) {
            BuildMsgRaw("    pfrInclude=%x: %s\n", pir->pfrInclude, pir->pfrInclude->Name);
            if (pir->pfrInclude->Dir != NULL) {
                BuildMsgRaw("    pdrInclude=%x: %s\n", pir->pfrInclude->Dir, pir->pfrInclude->Dir->Name);
            }
        }
        BuildMsgRaw("\n*************************************\n");
        fflush(stdout);
        fflush(stderr);

        PrintAllDirs();
        BuildMsgRaw("\n*************************************\n");
        fflush(stdout);
        fflush(stderr);
    }
    assert(IsCleanTree(pir));
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   UnsnapAllDirectories
//
//  Synopsis:   Removes pointers from all INCLUDERECs to the actual FILERECs
//              of include files so we can 'resnap' them.
//
//  Arguments:  None
//----------------------------------------------------------------------------

VOID
UnsnapAllDirectories(VOID)
{
    DIRREC *pdr;
    UINT   i;

    GlobalSequence = LocalSequence = 0;

    for (pdr = AllDirs; pdr != NULL; pdr = pdr->Next) {
        FILEREC *pfr;

        AssertDir(pdr);

        // Clear unwanted flags on each directory

        pdr->DirFlags &= ~(DIRDB_SCANNED |
                           DIRDB_PASS0NEEDED |
                           DIRDB_COMPILENEEDED |
                           DIRDB_NEW);

        pdr->CountOfFilesToCompile = 0;
        pdr->SourceLinesToCompile  = 0;
        pdr->CountOfPassZeroFiles = 0;
        pdr->PassZeroLines = 0;

        // Free all source records that point to missing files, because the
        // file records may be freed when rescanning directories after pass 0.

        if (pdr->pds != NULL)
        {
            for (i = 0; i < MAX_TARGET_MACHINES + 1; i++) {
                SOURCEREC **ppsr;
                SOURCEREC *psr;

                ppsr = &pdr->pds->psrSourcesList[i];
                while ((psr = *ppsr) != NULL)
                {
                    if (psr->SrcFlags & SOURCEDB_FILE_MISSING)
                    {
                        FreeSourceDB(ppsr);
                    }
                    else
                    {
                        ppsr = &psr->psrNext;
                    }
                }
            }
        }

        // Clear out all snapped include files and sequence numbers

        for (pfr = pdr->Files; pfr != NULL; pfr = pfr->Next) {

            AssertFile(pfr);
            UnsnapIncludeFiles(pfr, TRUE);
            pfr->GlobalSequence = pfr->LocalSequence = 0;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   MarkIncludeFileRecords
//
//----------------------------------------------------------------------------

VOID
MarkIncludeFileRecords(
    PFILEREC FileDB
    )
{
    PINCLUDEREC IncludeDB, *IncludeDBNext;

    IncludeDBNext = &FileDB->IncludeFiles;
    while (IncludeDB = *IncludeDBNext) {
        AssertCleanTree(IncludeDB, FileDB);      // Tree must be clean
        IncludeDB->pfrInclude = (PFILEREC) -1;
        IncludeDBNext = &IncludeDB->Next;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteIncludeFileRecords
//
//----------------------------------------------------------------------------

VOID
DeleteIncludeFileRecords(
    PFILEREC FileDB
    )
{
    PINCLUDEREC IncludeDB, *IncludeDBNext;

    IncludeDBNext = &FileDB->IncludeFiles;
    while (IncludeDB = *IncludeDBNext) {
        AssertCleanTree(IncludeDB, FileDB);      // Tree must be clean
        if (IncludeDB->pfrInclude == (PFILEREC) -1) {
            FreeIncludeDB(IncludeDBNext);
        }
        else {
            IncludeDBNext = &IncludeDB->Next;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FindIncludeFileDB
//
//  Synopsis:   Find the FILEREC for an include file that our compiland
//              includes.
//
//  Arguments:  [pfrSource]          -- FILEREC of file which includes the one
//                                      we're looking for. Might be a header.
//              [pfrCompiland]       -- FILEREC of ultimate source file.
//              [pdrBuild]           -- DIRREC of directory being built
//              [pszSourceDirectory] -- Name of machine-specific dir
//              [IncludeDB]          -- INCLUDEDB of include file we're looking
//                                      for.
//
//  Returns:    FILEREC of include file, if found.
//
//----------------------------------------------------------------------------

PFILEREC
FindIncludeFileDB(
    FILEREC *pfrSource,
    FILEREC *pfrCompiland,
    DIRREC *pdrBuild,
    LPSTR pszSourceDirectory,
    INCLUDEREC *IncludeDB)
{
    DIRREC *pdr;
    DIRREC *pdrMachine;
    FILEREC *pfr;
    UINT n;

    AssertFile(pfrSource);
    AssertFile(pfrCompiland);
    AssertDir(pfrSource->Dir);
    AssertDir(pfrCompiland->Dir);
    AssertDir(pdrBuild);
    assert(pfrSource->Dir->FindCount >= 1);
    assert(pfrCompiland->Dir->FindCount >= 1);
    assert(pdrBuild->FindCount >= 1);
    AssertInclude(IncludeDB);

    // The rules for #include "foo.h" and #include <foo.h> are:
    //  - "foo.h" searches in the directory of the source file that has the
    //    #include statement first, then falls into the INCLUDES= directories
    //  - <foo.h> simply searches the INCLUDES= directories
    //
    //  - since makefile.def *always* passes -I. -ITargetMachines[i] first,
    //    that has to be handled here as well.
    //
    //  - deal with #include <sys\types> and #include "..\foo\bar.h" by
    //    scanning those directories, too.

    n = CountIncludeDirs;
    pdrMachine = FindSourceDirDB(pdrBuild->Name, pszSourceDirectory, FALSE);

    // If local ("foo.h"), search the current file's directory, too.
    // The compiler also will search the directory of each higher level
    // file in the include hierarchy, but we won't get quite so fancy here.
    // Just search the directory of the current file and of the compiland.
    //
    // Skip these directories if they match the current build directory or
    // the machine subdirectory, because that's handled below.

    if (IncludeDB->IncFlags & INCLUDEDB_LOCAL) {
        if (pfrCompiland->Dir != pdrBuild &&
            pfrCompiland->Dir != pdrMachine &&
            pfrCompiland->Dir != pfrSource->Dir) {
            AddIncludeDir(pfrCompiland->Dir, &n);
        }
        if (pfrSource->Dir != pdrBuild && pfrSource->Dir != pdrMachine) {
            AddIncludeDir(pfrSource->Dir, &n);
        }
    }

    // Search the current target machine subdirectory of the build directory
    // -- as per makefile.def

    if (pdrMachine != NULL) {
        AddIncludeDir(pdrMachine, &n);
    }

    // Search the current build directory -- as per makefile.def.

    AddIncludeDir(pdrBuild, &n);

    while (n--) {
        pdr = IncludeDirs[n];
        if (pdr == NULL) {
            continue;
        }
        AssertDir(pdr);
        assert(pdr->FindCount >= 1);
        pfr = FindSourceFileDB(pdr, IncludeDB->Name, NULL);
        if (pfr != NULL) {
            if (DEBUG_1) {
                BuildMsgRaw(
                    "Found include file %s\\%s\n",
                    pfr->Dir->Name,
                    pfr->Name);
            }
            return(pfr);
        }
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveMasterDB
//
//  Synopsis:   Save the database to disk in build.dat
//
//  Arguments:  (none)
//
//  Returns:    TRUE if successful
//
//----------------------------------------------------------------------------

BOOL
SaveMasterDB(VOID)
{
    PDIRREC DirDB, *DirDBNext;
    PFILEREC FileDB, *FileDBNext;
    PINCLUDEREC IncludeDB, *IncludeDBNext;
    FILE *fh;

    if (!AllDirsModified) {
        return(TRUE);
    }

    if (!(fh = fopen(DbMasterName, "wb"))) {
        return( FALSE );
    }

    setvbuf(fh, NULL, _IOFBF, 0x7000);
    BuildMsg("Saving %s...", DbMasterName);

    AllDirsModified = FALSE;
    DirDBNext = &AllDirs;
    fprintf(fh, "V %x\r\n", BUILD_VERSION);
    while (DirDB = *DirDBNext) {
        fprintf(fh, "D \"%s\" %x\r\n", DirDB->Name, DirDB->DirFlags);
        FileDBNext = &DirDB->Files;
        while (FileDB = *FileDBNext) {
            if ((FileDB->FileFlags & FILEDB_FILE_MISSING) == 0) {
                fprintf(
                    fh,
                    " F \"%s\" %x %x %lx %u %u\r\n",
                    FileDB->Name,
                    FileDB->FileFlags,
                    FileDB->Attr,
                    FileDB->DateTime,
                    FileDB->SourceLines,
                    FileDB->Version);
            }
            IncludeDBNext = &FileDB->IncludeFiles;
            while (IncludeDB = *IncludeDBNext) {
                fprintf(
                    fh,
                    "  I \"%s\" %x %u\r\n",
                    IncludeDB->Name,
                    IncludeDB->IncFlags,
                    IncludeDB->Version);

                IncludeDBNext= &IncludeDB->Next;
            }
            FileDBNext = &FileDB->Next;
        }
        fprintf(fh, "\r\n");
        DirDBNext = &DirDB->Next;
    }
    fclose(fh);
    BuildMsgRaw(szNewLine);
    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterDB
//
//  Synopsis:   Load the master database from build.dat
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

void
LoadMasterDB( void )
{
    PDIRREC DirDB, *DirDBNext;
    PFILEREC FileDB, *FileDBNext;
    PINCLUDEREC IncludeDB, *IncludeDBNext;
    FILE *fh;
    LPSTR s;
    char ch, ch2;
    BOOL fFirst = TRUE;
    UINT Version;
    LPSTR pszerr = NULL;

    AllDirs = NULL;
    AllDirsModified = FALSE;
    AllDirsInitialized = FALSE;

    if (!SetupReadFile("", DbMasterName, ";", &fh)) {
        return;
    }
    BuildMsg("Loading %s...", DbMasterName);

    DirDBNext = &AllDirs;
    FileDBNext = NULL;
    IncludeDBNext = NULL;

    while ((s = ReadLine(fh)) != NULL) {
        ch = *s++;
        if (ch == '\0') {
            continue;           // skip empty lines
        }
        ch2 = *s++;             // should be a blank
        if (ch2 == '\0') {
            pszerr = "missing field";
            break;              // fail on single character lines
        }
        if (fFirst) {
            if (ch != 'V' || ch2 != ' ' || !AToX(&s, &Version)) {
                pszerr = "bad version format";
                break;
            }
            if (Version != BUILD_VERSION) {
                break;
            }
            fFirst = FALSE;
            continue;
        }
        if (ch2 != ' ') {
            pszerr = "bad separator";
            break;
        }
        if (ch == 'D') {
            DirDB = LoadMasterDirDB(s);
            if (DirDB == NULL) {
                pszerr = "Directory error";
                break;
            }
            *DirDBNext = DirDB;
            DirDBNext = &DirDB->Next;
            FileDBNext = &DirDB->Files;
            IncludeDBNext = NULL;
        }
        else
        if (ch == 'F' && FileDBNext != NULL) {
            FileDB = LoadMasterFileDB(s);
            if (FileDB == NULL) {
                pszerr = "File error";
                break;
            }
            *FileDBNext = FileDB;
            FileDBNext = &FileDB->Next;
            FileDB->Dir = DirDB;
            IncludeDBNext = &FileDB->IncludeFiles;
        }
        else
        if (ch == 'I' && IncludeDBNext != NULL) {
            IncludeDB = LoadMasterIncludeDB(s);
            if (IncludeDB == NULL) {
                pszerr = "Include error";
                break;
            }
            *IncludeDBNext = IncludeDB;
            IncludeDBNext = &IncludeDB->Next;
        }
        else {
            pszerr = "bad entry type";
            break;
        }
    }

    if (s != NULL) {
        if (pszerr == NULL) {
            BuildMsgRaw(" - old version - recomputing.\n");
        } else {
            BuildMsgRaw(szNewLine);
            BuildError("corrupt database (%s)\n", pszerr);
        }
        FreeAllDirs();
    }
    else {
        BuildMsgRaw(szNewLine);
        AllDirsInitialized = TRUE;
    }
    CloseReadFile(NULL);
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterDirDB
//
//  Synopsis:   Load a directory entry from build.dat
//
//  Arguments:  [s] -- line containing text from file.
//
//  Returns:    DIRRECT
//
//----------------------------------------------------------------------------

PDIRREC
LoadMasterDirDB(
    LPSTR s
    )
{
    PDIRREC DirDB;
    LPSTR DirName;
    ULONG DirFlags;

    if (*s == '"') {
        s++;
        DirName = s;
        while (*s != '"') {
            s++;
        }
        *s++ = '\0';
    }
    else
    {
        DirName = s;
        while (*s > ' ') {
            s++;
        }
    }
    *s++ = '\0';

    if (!AToX(&s, &DirFlags)) {
        return(NULL);
    }
    AllocMem(sizeof(DIRREC) + strlen(DirName), &DirDB, MT_DIRDB);
    memset(DirDB, 0, sizeof(*DirDB));
    SigCheck(DirDB->Sig = SIG_DIRREC);

    DirDB->DirFlags = DirFlags & DIRDB_DBPRESERVE;
    CopyString(DirDB->Name, DirName, TRUE);
    DirDB->CheckSum = CheckSum(DirDB->Name);
    return( DirDB );
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterFileDB
//
//  Synopsis:   Load a file entry from build.dat
//
//  Arguments:  [s] -- line containing text from file
//
//  Returns:    FILEREC
//
//----------------------------------------------------------------------------

PFILEREC
LoadMasterFileDB(
    LPSTR s
    )
{
    PFILEREC FileDB;
    LPSTR FileName;
    ULONG Version;
    ULONG FileFlags;
    ULONG Attr;
    ULONG SourceLines;
    ULONG DateTime;
    FILEDESC *pfd;

    if (*s == '"') {
        s++;
        FileName = s;
        while (*s != '"') {
            s++;
        }
        *s++ = '\0';
    }
    else
    {
        FileName = s;
        while (*s > ' ') {
            s++;
        }
    }
    *s++ = '\0';

    if (!AToX(&s, &FileFlags) ||
        !AToX(&s, &Attr) ||
        !AToX(&s, &DateTime) ||
        !AToD(&s, &SourceLines) ||
        !AToD(&s, &Version) ||
        strchr(FileName, '/') != NULL ||
        strchr(FileName, '\\') != NULL) {
        return(NULL);
    }
    AllocMem(sizeof(FILEREC) + strlen(FileName), &FileDB, MT_FILEDB);
    memset(FileDB, 0, sizeof(*FileDB));
    SigCheck(FileDB->Sig = SIG_FILEREC);

    CopyString(FileDB->Name, FileName, TRUE);
    FileDB->CheckSum = CheckSum(FileDB->Name);

    FileDB->FileFlags = FileFlags & FILEDB_DBPRESERVE;
    FileDB->Attr = (USHORT) Attr;
    FileDB->DateTime = DateTime;
    FileDB->Version = (USHORT) Version;
    FileDB->SourceLines = SourceLines;
    FileDB->NewestDependency = FileDB;

    pfd = MatchFileDesc(FileDB->Name);
    FileDB->pszCommentToEOL = pfd->pszCommentToEOL;
    return(FileDB);
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterIncludeDB
//
//  Synopsis:   Loads an include file entry from build.dat
//
//  Arguments:  [s] -- line containing text from file.
//
//  Returns:    INCLUDEREC
//
//----------------------------------------------------------------------------

PINCLUDEREC
LoadMasterIncludeDB(
    LPSTR s
    )
{
    PINCLUDEREC IncludeDB;
    LPSTR FileName;
    ULONG Version;
    ULONG IncFlags;

    if (*s == '"') {
        s++;
        FileName = s;
        while (*s != '"') {
            s++;
        }
        *s++ = '\0';
    }
    else
    {
        FileName = s;
        while (*s > ' ') {
            s++;
        }
    }
    *s++ = '\0';

    if (!AToX(&s, &IncFlags) || !AToD(&s, &Version)) {
        return(NULL);
    }
    AllocMem(
        sizeof(INCLUDEREC) + strlen(FileName),
        &IncludeDB,
        MT_INCLUDEDB);
    memset(IncludeDB, 0, sizeof(*IncludeDB));
    SigCheck(IncludeDB->Sig = SIG_INCLUDEREC);

    IncludeDB->IncFlags = (USHORT) (IncFlags & INCLUDEDB_DBPRESERVE);
    IncludeDB->Version = (USHORT) Version;
    CopyString(IncludeDB->Name, FileName, TRUE);
    return(IncludeDB);
}

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\build\buildexe.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       buildexe.c
//
//  Contents:   Functions related to spawning processes and processing
//              their output, using pipes and multiple threads.
//
//  History:    22-May-89     SteveWo  Created
//                 ... see SLM logs
//              26-Jul-94     LyleC    Cleanup/Add Pass0 Support
//              05-Dec-00     sbonev   See SD changelist 2317
//
//----------------------------------------------------------------------------

#include "build.h"

#include <fcntl.h>

//+---------------------------------------------------------------------------
//
// Global Data
//
//----------------------------------------------------------------------------

#define DEFAULT_LPS     (fStatusTree? 5000 : 50)

#define LastRow(pts)    ((USHORT) ((pts)->cRowTotal - 1))
#define LastCol(pts)    ((USHORT) ((pts)->cColTotal - 1))

typedef struct _PARALLEL_CHILD {
    PTHREADSTATE ThreadState;
    HANDLE       Event;
    CHAR         ExecuteProgramCmdLine[1024];
} PARALLEL_CHILD, *PPARALLEL_CHILD;

ULONG StartCompileTime;

DWORD OldConsoleMode;
DWORD NewConsoleMode;

HANDLE *WorkerThreads;
HANDLE *WorkerEvents;
ULONG NumberProcesses;
ULONG ThreadsStarted;

BOOLEAN fConsoleInitialized = FALSE;
BYTE ScreenCell[2];
BYTE StatusCell[2];

#define STATE_UNKNOWN       0
#define STATE_COMPILING     1
#define STATE_ASSEMBLING    2
#define STATE_LIBING        3
#define STATE_LINKING       4
#define STATE_C_PREPROC     5
#define STATE_S_PREPROC     6
#define STATE_PRECOMP       7
#define STATE_MKTYPLIB      8
#define STATE_MIDL          9
#define STATE_MC            10
#define STATE_STATUS        11
#define STATE_BINPLACE      12
#define STATE_VSTOOL        13
#define STATE_ASN           14
#define STATE_BATCHCOMPILE  15
#define STATE_BSCMAKING     16
#define STATE_CTCOMPILING   17
#define STATE_AUTODOCING    18
#define STATE_DOCCHECKING   19

#define FLAGS_CXX_FILE              0x0001
#define FLAGS_WARNINGS_ARE_ERRORS   0x0002

LPSTR States[] = {
    "Unknown",                      // 0
    "Compiling",                    // 1
    "Assembling",                   // 2
    "Building Library",             // 3
    "Linking Executable",           // 4
    "Preprocessing",                // 5
    "Assembling",                   // 6
    "Precompiling",                 // 7
    "Building Type Library",        // 8
    "MIDL Compiling",               // 9
    "Compiling error file",         // 10
    "Build Status Line",            // 11
    "Binplacing",                   // 12
    "Processing",                   // 13
    "Running ASN Compiler on",      // 14
    "Compiling",                    // 15
    "Building Browse File",         // 16
    "CTC Compiling",                // 17
    "Generating Documentation",     // 18
    "Checking Doc Comments",        // 19
};

//----------------------------------------------------------------------------
//
// Function prototypes
//
//----------------------------------------------------------------------------

VOID
GetScreenSize(THREADSTATE *ThreadState);

VOID
GetCursorPosition(USHORT *pRow, USHORT *pCol, USHORT *pRowTop);

VOID
SetCursorPosition(USHORT Row, USHORT Col);

VOID
WriteConsoleCells(
    LPSTR String,
    USHORT StringLength,
    USHORT Row,
    USHORT Col,
    BYTE *Attribute);

VOID
MoveRectangleUp (
    USHORT Top,
    USHORT Left,
    USHORT Bottom,
    USHORT Right,
    USHORT NumRow,
    BYTE  *FillCell);

VOID
ReadConsoleCells(
    BYTE *pScreenCell,
    USHORT cb,
    USHORT Row,
    USHORT Column);

VOID
ClearRows(
    PTHREADSTATE ThreadState,
    USHORT Top,
    USHORT NumRows,
    PBYTE  Cell
    );

LPSTR
IsolateFirstToken(
    LPSTR *pp,
    CHAR delim
    );

LPSTR
IsolateLastToken(
    LPSTR p,
    CHAR delim
    );

DWORD
ParallelChildStart(
    PPARALLEL_CHILD Data
    );

DWORD
PipeSpawnClose (
    FILE *pstream
    );

FILE *
PipeSpawn (
    const CHAR *cmdstring
    );


VOID
FormatMsErrorMessage(
    PTHREADSTATE ThreadState,
    LPSTR FileName,
    LPSTR LineNumber,
    LPSTR Message,
    BOOL Warning
    );

//+---------------------------------------------------------------------------
//
//  Function:   RestoreConsoleMode
//
//----------------------------------------------------------------------------

VOID
RestoreConsoleMode(VOID)
{
    SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), OldConsoleMode);
    NewConsoleMode = OldConsoleMode;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsolateFirstToken
//
//  Synopsis:   Returns the first token in a string.
//
//  Arguments:  [pp]    -- String to parse
//              [delim] -- Token delimiter
//
//  Returns:    Pointer to first token
//
//  Notes:      Leading spaces are ignored.
//
//----------------------------------------------------------------------------

LPSTR
IsolateFirstToken(
    LPSTR *pp,
    CHAR delim
    )
{
    LPSTR p, Result;

    p = *pp;
    while (*p <= ' ') {
        if (!*p) {
            *pp = p;
            return( "" );
            }
        else
            p++;
        }

    Result = p;
    while (*p) {
        if (*p == delim) {
            *p++ = '\0';
            break;
            }
        else {
            p++;
            }
        }
    *pp = p;
    if (*Result == '\0')    // don't overrun the buffer
        return( Result );

    if (*Result == '.' && Result[1] == '\\') {
        return( Result+2 );
        }
    else {
        return( Result );
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   IsolateLastToken
//
//  Synopsis:   Return the last token in a string.
//
//  Arguments:  [p]     -- String to parse
//              [delim] -- Token delimiter
//
//  Returns:    Pointer to last token
//
//  Notes:      Trailing spaces are skipped.
//
//----------------------------------------------------------------------------

LPSTR
IsolateLastToken(
    LPSTR p,
    CHAR delim
    )
{
    LPSTR Start;

    Start = p;
    while (*p) {
        p++;
        }

    while (--p > Start) {
        if (*p <= ' ' || *p == ':') {
            *p = '\0';
            }
        else
            break;
        }

    while (p > Start) {
        if (*--p == delim) {
            p++;
            break;
            }
        }

    if (*p == '.' && p[1] == '\\') {
        return( p+2 );
        }
    else {
        return( p );
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   TestPrefix
//
//  Synopsis:   Returns TRUE if [Prefix] is the first part of [pp]
//
//----------------------------------------------------------------------------

BOOL
TestPrefix(
    LPSTR  *pp,
    LPSTR Prefix
    )
{
    LPSTR p = *pp;
    UINT cb;

    if (!_strnicmp( p, Prefix, cb = strlen( Prefix ) )) {
        *pp = p + cb;
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   TestCommandPrefix
//
//  Synopsis:   Returns TRUE if [Prefix] is in the first element of [pp]
//
//----------------------------------------------------------------------------

BOOL
TestCommandPrefix(
    LPSTR  *pp,
    LPSTR Prefix
    )
{
    BOOL fRet = FALSE;
    LPSTR p = *pp, p1, p2;
    LPSTR pDup = _strupr(_strdup(p));
    LPSTR PrefixDup = _strupr(_strdup(Prefix));

    if ((p1 = strstr(pDup, PrefixDup)) < (p2 = strstr( pDup, " ")) &&
        ((p1 == pDup) || ((p1 > pDup) && (*(p1-1) == '\\')))) {
        *pp = p + (p1 - pDup) + strlen(Prefix);
        fRet = TRUE;
        }
    else {
        fRet = FALSE;
        }

    free(pDup);
    free(PrefixDup);
    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   Substr
//
//----------------------------------------------------------------------------

BOOL
Substr(
    LPSTR s,
    LPSTR p
    )
{
    LPSTR x;

    while (*p) {
        x = s;
        while (*p++ == *x) {
            if (*x == '\0') {
                return( TRUE );
                }
            x++;
            }
        if (*x == '\0') {
            return( TRUE );
            }
        }
    return( FALSE );
}



//+---------------------------------------------------------------------------
//
//  Function:   WriteTTY
//
//  Synopsis:   Writes the given string to the output device.
//
//  Arguments:  [ThreadState]   -- Struct containing info about the output dev.
//              [p]             -- String to display
//              [fStatusOutput] -- If TRUE then put on the status line.
//
//----------------------------------------------------------------------------

VOID
WriteTTY (THREADSTATE *ThreadState, LPSTR p, BOOL fStatusOutput)
{
    USHORT SaveRow;
    USHORT SaveCol;
    USHORT SaveRowTop;
    USHORT cb, cbT;
    PBYTE Attribute;
    BOOL ForceNewline;

    //
    // If we're not writing to the screen then don't do anything fancy, just
    // output the string.
    //
    if (!fStatus || !ThreadState->IsStdErrTty) {
        while (TRUE) {
            int cch;

            cch = strcspn(p, "\r");
            if (cch != 0) {
                fwrite(p, 1, cch, stderr);
                p += cch;
            }
            if (*p == '\0') {
                break;
            }
            if (p[1] != '\n') {
                fwrite(p, 1, 1, stderr);
            }
            p++;
        }
        fflush(stderr);
        return;
    }
    assert(ThreadState->cColTotal != 0);
    assert(ThreadState->cRowTotal != 0);

    //
    // Scroll as necessary
    //
    GetCursorPosition(&SaveRow, &SaveCol, &SaveRowTop);

    //  During processing, there might be N threads that are displaying
    //  messages and a single thread displaying directory-level
    //  linking and building messages.  We need to make sure there's room for
    //  the single thread's message as well as ours.  Since that single
    //  thread displays one line at a time (including CRLF) we must make sure
    //  that his display (as well as ours) doesn't inadvertantly scroll
    //  the status line at the top.  We do this by guaranteeing that there is
    //  a blank line at the end.


    //  We are synchronized with the single top-level thread
    //  at a higher level than this routine via TTYCriticalSection.  We
    //  are, thus, assured that we control the cursor completely.


    //  Stay off the LastRow
    if (SaveRow == LastRow(ThreadState)) {
        USHORT RowTop = 2;

        if (fStatus) {
            RowTop += SaveRowTop + (USHORT) NumberProcesses + 1;
        }

        MoveRectangleUp (
            RowTop,                     // Top
            0,                          // Left
            LastRow(ThreadState),       // Bottom
            LastCol(ThreadState),       // Right
            2,                          // NumRow
            ScreenCell);                // FillCell

        SaveRow -= 2;
        SetCursorPosition(SaveRow, SaveCol);
    }

    //
    // Different color for the status line.
    //
    if (fStatusOutput) {
        Attribute = &StatusCell[1];
    }
    else {
        Attribute = &ScreenCell[1];
    }
    cb = (USHORT) strlen(p);

    //
    // Write out the string.
    //
    while (cb > 0) {
        ForceNewline = FALSE;

        if (cb > 1) {
            if (p[cb - 1] == '\n' && p[cb - 2] == '\r') {
                cb -= 2;
                ForceNewline = TRUE;
            }
        }

        if (cb >= ThreadState->cColTotal - SaveCol) {
            cbT = ThreadState->cColTotal - SaveCol;
            if (fFullErrors)
                ForceNewline = TRUE;
        }
        else {
            cbT = cb;
        }

        WriteConsoleCells(p, cbT, SaveRow, SaveCol, Attribute);
        SetCursorPosition(SaveRow, SaveCol);

        if (ForceNewline) {
            SaveCol = 0;
            SaveRow++;
        }
        else {
            SaveCol += cbT;
        }

        if (!fFullErrors) {
            break;
        }

        if (cb > cbT) {
            // we have more to go... do a newline

            //  If we're back at the beginning of the bottom line
            if (SaveRow == LastRow(ThreadState)) {
                USHORT RowTop = 1;

                if (fStatus) {
                    RowTop += SaveRowTop + (USHORT) NumberProcesses + 1;
                }

                // move window up one line (leaving two lines blank at bottom)
                MoveRectangleUp (
                    RowTop,                     // Top
                    0,                          // Left
                    LastRow(ThreadState),       // Bottom
                    LastCol(ThreadState),       // Right
                    1,                          // NumRow
                    ScreenCell);                // FillCell

                SaveRow--;
            }
            SetCursorPosition(SaveRow, SaveCol);
        }

        cb -= cbT;
        p += cbT;
    }

    SetCursorPosition(SaveRow, SaveCol);
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteTTYLoggingErrors
//
//  Synopsis:   Writes a message to the appropriate log file and also the
//              screen if specified.
//
//  Arguments:  [Warning]     -- TRUE if the message is a warning
//              [ThreadState] -- Info about output device
//              [p]           -- String
//
//----------------------------------------------------------------------------

VOID
WriteTTYLoggingErrors(
    BOOL Warning,
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    UINT cb;
    cb = strlen( p );

    // ignore empty strings
    if (0 == cb)
        return;

    if (fErrorLog) {
        fwrite( p, 1, cb, Warning ? WrnFile : ErrFile );
    }
    if (fShowWarningsOnScreen && Warning)
    {
        WriteTTY(ThreadState, p, FALSE);
        return;
    }
    if (!fErrorLog || !Warning) {
        WriteTTY(ThreadState, p, FALSE);
    }

    if (!Warning && fErrorBaseline && !bBaselineFailure) {
        // don't check for a new failure if there is already one

        if (NULL == pvBaselineContent || NULL == memfind(pvBaselineContent, cbBaselineContentSize, p, cb)) {
            // if there is no baseline file, or if the error is not found, we have new failure
            bBaselineFailure = TRUE;
        } 
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   RuntimeErrorFilter
//
//  Synopsis:   Filters output from the compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//                               (compiling, linking, etc...)
//              [p]           -- Message we're trying to parse.
//              [FileName]    -- [out] Filename in message
//              [LineNumber]  -- [out] Line number in message
//              [Message]     -- [out] Message number (for post processing)
//              [Warning]     -- [out] TRUE if message is a warning.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    26-Jul-94     sbonev    Created
//
//  Notes:
//
//      This routine filters strings that are not standard tool output.
//      Any unexpected error checking should go here
//
//----------------------------------------------------------------------------

BOOL
RuntimeErrorFilter(
    PTHREADSTATE ThreadState,
    LPSTR p,
    LPSTR *FileName,
    LPSTR *LineNumber,
    LPSTR *Message,
    BOOL *Warning
    )
{
    if (strstr(p, "Exception occured:"))
    {
        *FileName = NULL;
        *LineNumber = NULL;
        *Message = p;
        *Warning = FALSE;

        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   MsCompilerFilter
//
//  Synopsis:   Filters output from the compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//                               (compiling, linking, etc...)
//              [p]           -- Message we're trying to parse.
//              [FileName]    -- [out] Filename in message
//              [LineNumber]  -- [out] Line number in message
//              [Message]     -- [out] Message number (for post processing)
//              [Warning]     -- [out] TRUE if message is a warning.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    26-Jul-94     LyleC    Created
//
//  Notes:
//
//    This routine filters strings in the MS compiler format.  That is:
//
//       {toolname} : {number}: {text}
//
//    where:
//
//        toolname    If possible, the container and specific module that has
//                    the error.  For instance, the compiler uses
//                    filename(linenum), the linker uses library(objname), etc.
//                    If unable to provide a container, use the tool name.
//        number      A number, prefixed with some tool identifier (C for
//                    compiler, LNK for linker, LIB for librarian, N for nmake,
//                    etc).
//        test        The descriptive text of the message/error.
//
//        Accepted String formats are:
//
//        container(module): error/warning NUM ...
//        container(module) : error/warning NUM ...
//        container (module): error/warning NUM ...
//        container (module) : error/warning NUM ...
//
//----------------------------------------------------------------------------

BOOL
MsCompilerFilter(
    PTHREADSTATE ThreadState,
    LPSTR p,
    LPSTR *FileName,
    LPSTR *LineNumber,
    LPSTR *Message,
    BOOL *Warning
    )
{
    LPSTR p1;

    *Message = NULL;

    p1 = p;

    if (strstr(p, "see declaration of"))
        goto notRecognized;

    if (strstr(p, "see previous definition of"))
        goto notRecognized;

    if (strstr(p, "while compiling class-template member function"))
        goto notRecognized;

    if (strstr(p, "see reference to function template instantiation"))
        goto notRecognized;

    if (!strncmp(p, "Compiler error (", 16)) {
        *Message = p;
        *Warning = FALSE;
        if ((p1 = strstr( p, "source=" )))
            *LineNumber = p1+7;
        else
            *LineNumber = "1";
        *FileName = ThreadState->ChildCurrentFile;
        return TRUE;
    }

    // First look for the " : " or "): " sequence.

    while (*p1) {
        if ((p1[0] == ')') && (p1[1] == ' ')) p1++;

        if ((p1[0] == ' ') || (p1[0] == ')')) {
            if (p1[1] == ':') {
                if (p1[2] == ' ') {
                    *Message = p1 + 3;
                    *p1 = '\0';

                    break;
                }
                else
                    break;   // No sense going any further
            }
            else if ((p1[0] == ' ') && (p1[1] == '('))
                p1++;
            else
                break;   // No sense going any further
        }
        else
            p1++;
    }

    if (*Message != NULL) {
        // then figure out if this is an error or warning.

        *Warning = TRUE;        // Assume the best.

        if (TestPrefix( Message, "error " ) ||
            TestPrefix( Message, "fatal error " ) ||
            TestPrefix( Message, "Compiler error " )) 
            *Warning = FALSE;
        else
        if (TestPrefix( Message, "warning " )) { // This will advance Message
                                                 // past the warning message.           
            *Warning = TRUE;
        }

        if ((ThreadState->ChildFlags & FLAGS_WARNINGS_ARE_ERRORS) != 0) {
            if (Substr( "X0000", *Message )) {
                *Warning = TRUE;   // Special case this one. Never an error
            } else {
                *Warning = FALSE;       // Warnings treated as errors for this compile

            }
        }

        // Set the container name and look for the module paren's

        *FileName = p;
        *LineNumber = NULL;

        p1 = p;

        while (*p1) {
            if (*p1 == '(' && p1[1] != ')') {
                *p1 = '\0';
                p1++;
                *LineNumber = p1;
                while (*p1) {
                    if (*p1 == ')') {
                        *p1 = '\0';
                        break;
                    }
                    p1++;
                }

                break;
            }

            p1++;
        }

        return(TRUE);
    }

notRecognized:
    return RuntimeErrorFilter(ThreadState, p, FileName, LineNumber, Message, Warning);

}

//+---------------------------------------------------------------------------
//
//  Function:   PassThrough
//
//  Synopsis:   Keep track of and print the given message without any
//              filtering.
//
//  Arguments:  [ThreadState] --
//              [p]           -- Message
//              [Warning]     -- TRUE if warning
//
//  Returns:    FALSE
//
//----------------------------------------------------------------------------

BOOL
PassThrough(
    PTHREADSTATE ThreadState,
    LPSTR p,
    BOOL Warning
    )
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
    if (fColorConsole) {
        if (Warning)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);
        else
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
    }

    if (ThreadState->ChildState == STATE_VSTOOL) {
        if (Warning) {
            RunningTotals.NumberVSToolWarnings++;
            ThreadState->BuildMetrics.NumberVSToolWarnings++;
            }
        else {
            RunningTotals.NumberVSToolErrors++;
            ThreadState->BuildMetrics.NumberVSToolErrors++;
            }
        }
    else
    if (ThreadState->ChildState == STATE_LIBING) {
        if (Warning) {
            RunningTotals.NumberLibraryWarnings++;
            ThreadState->BuildMetrics.NumberLibraryWarnings++;
            }
        else {
            RunningTotals.NumberLibraryErrors++;
            ThreadState->BuildMetrics.NumberLibraryErrors++;
            }
        }
    else
    if ((ThreadState->ChildState == STATE_LINKING) ||
        (ThreadState->ChildState == STATE_BINPLACE)) {
        if (Warning) {
            RunningTotals.NumberLinkWarnings++;
            ThreadState->BuildMetrics.NumberLinkWarnings++;
            }
        else {
            RunningTotals.NumberLinkErrors++;
            ThreadState->BuildMetrics.NumberLinkErrors++;
            }
        }
    else {
        if (Warning) {
            RunningTotals.NumberCompileWarnings++;
            ThreadState->BuildMetrics.NumberCompileWarnings++;
            }
        else {
            RunningTotals.NumberCompileErrors++;
            ThreadState->BuildMetrics.NumberCompileErrors++;
            if (ThreadState->CompileDirDB) {
                ThreadState->CompileDirDB->DirFlags |= DIRDB_COMPILEERRORS;
                }
                }
            }

    // safe to use. it is protected by the TTY critical section
    szXMLBuffer[0] = 0;

    if (fParallel && fThreadIndex) {
        sprintf(szXMLBuffer, "%d>", ThreadState->ThreadIndex);
        }

    strcat(szXMLBuffer, p);

    if (Warning) {
        ThreadState->BuildMetrics.NumberActWarnings++;
    }
    else {
        ThreadState->BuildMetrics.NumberActErrors++;
    }

    if (fXMLOutput) {
        XMLThreadWrite(ThreadState, "<%s MESSAGE=\"%s\"/>", Warning ? "WARNING" : "ERROR", XMLEncodeBuiltInEntities(szXMLBuffer, sizeof(szXMLBuffer)));
    }

    WriteTTYLoggingErrors( Warning, ThreadState, szXMLBuffer );
    WriteTTYLoggingErrors( Warning, ThreadState, "\r\n" );

    if (fColorConsole)
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);

    return( FALSE );
}


//+---------------------------------------------------------------------------
//
//  Function:   PassThroughFilter
//
//  Synopsis:   Straight pass-through filter for compiler messages
//
//----------------------------------------------------------------------------

BOOL
PassThroughFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    return PassThrough( ThreadState, p, FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   NMakeFilter
//
//  Synopsis:   Filters output from NMAKE so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the build
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    10-Jun-99     patbr  Created
//
//----------------------------------------------------------------------------

BOOL
NMakeFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, FALSE );
        return( TRUE );
    }
    else {
        return( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   BisonFilter
//
//  Synopsis:   Filters output from the bison compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//                               (compiling, linking, etc...)
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    04-Oct-99     TomSe    Created
//
//  Notes:
//
//    This routine filters strings in the bison compiler format.  That is:
//
//        Accepted String formats are:
//
//        ("myfile.y", line 3) error: unknown character: #
//        "myfile.y", line 83: no input grammar
//        vapi.y contains 1 useless nonterminal and 1 useless rule
//
//----------------------------------------------------------------------------

BOOL
BisonFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName = NULL;
    LPSTR LineNumber = NULL;
    LPSTR Message = NULL;
    BOOL Warning = TRUE;

    // First colon marks beginnning of message.
    LPSTR p1 = strchr(p,':');

    if (p1)
    {
        Message = p1 + 1;
        *p1 = '\0';

        // Get filename, line number.
        p1 = p;

        do
        {
            Warning = FALSE;

            // Skip (.
            if ( '(' == *p1 )
            {
                p1++;
            }

            // Skip over leading quote in filename.
            if ( '"' != *p1 )
            {
                // Unexpected format.
                break;
            }
            p1++;

            FileName = p1;

            // Look for trailing quote in filename.
            p1 = strchr( p1, '"');
            if (NULL==p1)
            {
                // Unexpected format.
                FileName = NULL;
                break;
            }

            *p1 = '\0';

            p1++;

            if (0 !=strncmp( p1, ", line ", 7))
            {
                // Unexpected format.
                FileName = NULL;
                break;
            }
            p1 += 7;

            LineNumber = p1;

            while (isdigit(*p1))
            {
                p1++;
            }

            *p1 = '\0';
        }
        while (0);
    }
    else
    {
        // Take whole string as message if no colon is found.
        Message = p;
    }

    if (NULL==FileName)
    {
        FileName = ThreadState->ChildCurrentFile;
    }

    FormatMsErrorMessage( ThreadState,
                          FileName, LineNumber, Message, Warning );

    // This was a warning or error.
    return TRUE ;
}



//+---------------------------------------------------------------------------
//
//  Function:   C510Filter
//
//  Synopsis:   Compiler filter which strips out unwanted warnings.
//
//  Arguments:  [ThreadState] --
//              [p]           --
//
//----------------------------------------------------------------------------

BOOL
C510Filter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning
                        )
       ) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   MSBCFilter
//
//  Synopsis:   Filters output from the Basic compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    08-Dec-09     marioch  Created
//
//----------------------------------------------------------------------------

BOOL
MSBCFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (!strncmp(p, "BC Compiler error", 17)) {
        FormatMsErrorMessage( ThreadState,
                              ThreadState->ChildCurrentFile, NULL, p, FALSE );
        return TRUE;
    }

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return( TRUE );
    }
    else {
        char *pErrorMsg;
        if (NULL != (pErrorMsg = strstr(p, "error BC"))) {
            FormatMsErrorMessage( ThreadState,
                                  ThreadState->ChildCurrentFile, NULL, pErrorMsg+6, FALSE );
            return TRUE;
        }
        return( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MSJVCFilter
//
//  Synopsis:   Filters output from the JVC compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    24-Mar-99     patbr  Created
//
//----------------------------------------------------------------------------

BOOL
MSJVCFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (!strncmp(p, "fatal error J", 13) || !strncmp(p, "error J", 7)) {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
        WriteTTYLoggingErrors( FALSE, ThreadState, p );
        WriteTTYLoggingErrors( FALSE, ThreadState, "\r\n" );
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        RunningTotals.NumberCompileErrors++;
        ThreadState->BuildMetrics.NumberCompileErrors++;
        return TRUE;
    }

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return( TRUE );
    }
    else {
        return( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MSCoolFilter
//
//  Synopsis:   Filters output from the COOL compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    2-Jun-99     patbr  Created
//
//----------------------------------------------------------------------------

BOOL
MSCoolFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (!strncmp(p, "fatal error SC", 14) || !strncmp(p, "error SC", 8)) {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
        WriteTTYLoggingErrors( FALSE, ThreadState, p );
        WriteTTYLoggingErrors( FALSE, ThreadState, "\r\n" );
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        RunningTotals.NumberCompileErrors++;
        ThreadState->BuildMetrics.NumberCompileErrors++;
        return TRUE;
    }

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return( TRUE );
    }
    else {
        return( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MSCSharpFilter
//
//  Synopsis:   Filters output from the CSharp compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    6-Nov-00     sbonev  Copy of MSCoolFilter
//
//----------------------------------------------------------------------------

BOOL
MSCSharpFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (!strncmp(p, "fatal error CS", 14) || !strncmp(p, "error CS", 8)) {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
        WriteTTYLoggingErrors( FALSE, ThreadState, p );
        WriteTTYLoggingErrors( FALSE, ThreadState, "\r\n" );
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        RunningTotals.NumberCompileErrors++;
        ThreadState->BuildMetrics.NumberCompileErrors++;
        return TRUE;
    }

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return( TRUE );
    }
    else {
        return( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ResGenFilter
//
//  Synopsis:   Filters output from the .NET Resource Generator so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    22-Mar-01     sbonev
//
//----------------------------------------------------------------------------

BOOL
ResGenFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    if (!strncmp(p, "ResGen: Error: ", 15)) {
        LPSTR LineNumber = _strdup(p);
        LPSTR pch = LineNumber;
        LPCSTR Line = strstr(p, ". Line ");
        LPCSTR Pos = strstr(p, ", position ");
        LineNumber[0] = 0;

        // put line,pos info if available
        if (NULL != Line) {
            Line += 7;
            while (isdigit(*Line)) *pch++ = *Line++;

            if (NULL != Pos) {
                Pos += 11;
                *pch++ = ',';
                while (isdigit(*Pos)) *pch++ = *Pos++;
                }
            }

        FormatMsErrorMessage( 
            ThreadState, 
            ThreadState->ChildCurrentFile, 
            LineNumber, 
            strlen(ThreadState->ChildCurrentFile) > 0 ? p + 15 : p, // display full message if there is no filename
            FALSE);

        free(LineNumber);
        return TRUE;
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CScriptFilter
//
//  Synopsis:   Filters output from Windows Script Host so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    22-Mar-01     sbonev
//
//----------------------------------------------------------------------------
BOOL
CScriptFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    if (NULL != strstr(p, "Microsoft JScript runtime error:") ||
        NULL != strstr(p, "Microsoft JScript compilation error:") ||
        NULL != strstr(p, "Microsoft VBScript runtime error:") ||
        NULL != strstr(p, "Microsoft VBScript compilation error:")) {

        // just display the message
        PassThrough( ThreadState, p, FALSE );
        return TRUE;

    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ToolNotFoundFilter
//
//  Synopsis:   Filters output from the build looking for "name not recognized"
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    10-Dec-98     patbr  Created
//
//----------------------------------------------------------------------------

BOOL
ToolNotFoundFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    if ((!strncmp(p, "The name specified is not recognized", 36)) ||
        (!strncmp(p, "internal or external command", 28))) {
        FormatMsErrorMessage( ThreadState,
                              ThreadState->ChildCurrentFile, NULL, p, FALSE );
        return TRUE;
    }

    return (FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   MSToolFilter
//
//----------------------------------------------------------------------------

BOOL
MSToolFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning
                        )
       ) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}


BOOL
LinkFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    );

//+---------------------------------------------------------------------------
//
//  Function:   LinkFilter1
//
//----------------------------------------------------------------------------

BOOL
LinkFilter1(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR p1;
    char buffer[ 256 ];

    if (p[ strlen( p ) - 1 ] == ':') {
        return( LinkFilter( ThreadState, p ) );
        }

    p1 = p;
    while (*p1) {
        if (*p1 == '(') {
            *p1++ = 0;
            if (*p1 == '.' && p1[1] == '\\') {
                p1 += 2;
                }
            FileName = p1;
            while (*p1) {
                if (*p1 == ')') {
                    *p1++ = 0;
                    strcpy( buffer, "L2029: Unresolved external reference to " );
                    strcat( buffer, ThreadState->UndefinedId );
                    FormatMsErrorMessage( ThreadState, FileName, "1",
                                          buffer, FALSE
                                        );
                    return( TRUE );
                    }
                else {
                    p1++;
                    }
                }
            }
        else {
            p1++;
            }
        }

    return( FALSE  );
}


//+---------------------------------------------------------------------------
//
//  Function:   LinkFilter
//
//----------------------------------------------------------------------------

BOOL
LinkFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;
    LPSTR p1;

    p1 = p;
    while (*p1) {
        if (*p1 == ':') {
            if (p1[-1] == ']') {
                return( FALSE );
                }

            if (p1[-1] == ' ' && p1[1] == ' ') {
                if (MsCompilerFilter( ThreadState, p,
                                      &FileName,
                                      &LineNumber,
                                      &Message,
                                      &Warning
                                    )
                   ) {

                    if (!Warning || !(_strnicmp(Message, "L4021", 5) || 
                          _strnicmp(Message, "L4038", 5) ||
                              _strnicmp(Message, "L4046", 5))) {
                        if (LineNumber)
                            FileName = LineNumber;
                        if (FileName[0] == '.' && FileName[1] == '\\') {
                            FileName += 2;
                            }
                        FormatMsErrorMessage( ThreadState, FileName, "1",
                                              Message, FALSE );
                        return( TRUE );
                        }
                    }

                   FormatMsErrorMessage( ThreadState, FileName, "1",
                                           Message, TRUE );                 

  
                return( TRUE );
                }

            if (p1[-1] == ')') {
                p1 -= 11;
                if (p1 > p && !strcmp( p1, " in file(s):" )) {
                    strcpy( ThreadState->UndefinedId,
                            IsolateFirstToken( &p, ' ' )
                          );
                    ThreadState->FilterProc = LinkFilter1;
                    return( TRUE );
                    }
                }

            return( FALSE );
            }
        else {
            p1++;
            }
        }

    return( FALSE );
}


BOOL
DetermineChildState(
    PTHREADSTATE ThreadState,
    LPSTR p
    );

//+---------------------------------------------------------------------------
//
//  Function:   CoffFilter
//
//----------------------------------------------------------------------------

BOOL
CoffFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning
                        )
       ) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   ClRiscFilter
//
//  Synopsis:   Risc compiler filter
//
//  BUGBUG -- It may be possible to remove this filter.
//
//----------------------------------------------------------------------------

BOOL
ClRiscFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;
    LPSTR q;

    if (TestPrefix( &p, "cfe: " )) {
        if (strncmp(p, "Error: ", strlen("Error: ")) == 0) {
            p += strlen("Error: ");
            Warning = FALSE;

        } else if (strncmp(p, "Warning: ", strlen("Warning: ")) == 0) {
            p += strlen("Warning: ");
            Warning = TRUE;
        } else {
            return(FALSE);
        }

        q = p;
        if (p = strstr( p, ".\\\\" )) {
            p += 3;
        } else {
            p = q;
        }

        FileName = p;
        while (*p > ' ') {
            if (*p == ',' || (*p == ':' && *(p+1) == ' ')) {
                *p++ = '\0';
                break;
                }

            p++;
            }

        if (*p != ' ') {
            return( FALSE );
            }

        *p++ = '\0';

        if (strcmp(p, "line ") == 0) {
            p += strlen("line ");

        }

        LineNumber = p;
        while (*p != '\0' && *p != ':') {
            p++;
            }

        if (*p != ':') {
            return( FALSE );
            }

        *p++ = '\0';
        if (*p == ' ') {
            Message = p+1;
            ThreadState->LinesToIgnore = 2;

            FormatMsErrorMessage( ThreadState,
                                  FileName,
                                  LineNumber,
                                  Message,
                                  Warning
                                );
            return( TRUE );
            }
        }
    //
    // If we did not recognize the cfe compiler, pass it to the MS compiler
    // message filter
    //

    return( C510Filter( ThreadState, p ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   MgClientFilter
//
//----------------------------------------------------------------------------

BOOL
MgClientFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    return( PassThrough( ThreadState, p, TRUE ) );
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatMsErrorMessage
//
//  Synopsis:   Take the information obtained from MsCompilerFilter,
//              reconstruct the error message, and print it to the screen.
//
//----------------------------------------------------------------------------

VOID
FormatMsErrorMessage(
    PTHREADSTATE ThreadState,
    LPSTR FileName,
    LPSTR LineNumber,
    LPSTR Message,
    BOOL Warning
    )
{
    char *DirectoryToUse;

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
    if (fColorConsole) {
        if (Warning)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);
        else
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
    }

    if (ThreadState->ChildState == STATE_LIBING) {
        if (Warning) {
            RunningTotals.NumberLibraryWarnings++;
            ThreadState->BuildMetrics.NumberLibraryWarnings++;
            }
        else {
            RunningTotals.NumberLibraryErrors++;
            ThreadState->BuildMetrics.NumberLibraryErrors++;
            }
        }

    else
    if ((ThreadState->ChildState == STATE_LINKING) ||
        (ThreadState->ChildState == STATE_BINPLACE)) {
        if (Warning) {
            RunningTotals.NumberLinkWarnings++;
            ThreadState->BuildMetrics.NumberLinkWarnings++;
            }
        else {
            RunningTotals.NumberLinkErrors++;
            ThreadState->BuildMetrics.NumberLinkErrors++;
            }
        }
    else {
        if (Warning) {
            RunningTotals.NumberCompileWarnings++;
            ThreadState->BuildMetrics.NumberCompileWarnings++;
            }
        else {
            RunningTotals.NumberCompileErrors++;
            ThreadState->BuildMetrics.NumberCompileErrors++;
            if (ThreadState->CompileDirDB) {
                ThreadState->CompileDirDB->DirFlags |= DIRDB_COMPILEERRORS;
                }
            }
        }

    // start filling up the buffer for the XML log file; 
    // however, we are going to use the same buffer even if no XML log is requested
    // safe to use - it is protected by the TTY critical section
    szXMLBuffer[0] = 0;

    if (fParallel && fThreadIndex ) {
        sprintf(szXMLBuffer, "%d>", ThreadState->ThreadIndex);
    }

    if (FileName) {
        DirectoryToUse = ThreadState->ChildCurrentDirectory;

        if (TestPrefix( &FileName, CurrentDirectory )) {
            DirectoryToUse = CurrentDirectory;
            if (*FileName == '\\') {
                FileName++;
                }
            }

        if (TestPrefix( &FileName, ThreadState->ChildCurrentDirectory )) {
            DirectoryToUse = ThreadState->ChildCurrentDirectory;
            if (*FileName == '\\') {
                FileName++;
                }
            }

        // check for some special cases when the FileName is actually the tool name
        // and should not be prepended with path

        if (ThreadState->FilterProc == CoffFilter && _stricmp(FileName, "link") == 0 ||
            ThreadState->FilterProc == CoffFilter && _stricmp(FileName, "lib") == 0) {
            strcat(szXMLBuffer, FileName);
            }
        else {
            strcat(szXMLBuffer, FormatPathName( DirectoryToUse, FileName));
            }
        }

    if (LineNumber && strlen(LineNumber) > 0) {
        strcat(szXMLBuffer, "(");
        strcat(szXMLBuffer, LineNumber);
        strcat(szXMLBuffer, ")");
        }
    if ((FileName && strlen(FileName) > 0) || (LineNumber && strlen(LineNumber) > 0)) {
        strcat(szXMLBuffer, " : ");
        }
    if (Warning) {
        strcat(szXMLBuffer, "warning ");
        }
    else {
        strcat(szXMLBuffer, "error ");
        }
    strcat(szXMLBuffer, Message);

    if (Warning) {
        ThreadState->BuildMetrics.NumberActWarnings++;
    }
    else {
        ThreadState->BuildMetrics.NumberActErrors++;
    }

    if (fXMLOutput) {
        XMLThreadWrite(ThreadState, "<%s MESSAGE=\"%s\"/>", Warning ? "WARNING" : "ERROR", XMLEncodeBuiltInEntities(szXMLBuffer, sizeof(szXMLBuffer)));
    }

    WriteTTYLoggingErrors( Warning, ThreadState, szXMLBuffer);
    WriteTTYLoggingErrors( Warning, ThreadState, "\r\n" );

    if (fColorConsole)
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
}


BOOL fAlreadyUnknown = FALSE;

//+---------------------------------------------------------------------------
//
//  Function:   DetermineChildState
//
//  Synopsis:   Parse the message given by the compiler (or whatever) and try
//              to figure out what it's doing.
//
//  Arguments:  [ThreadState] -- Current thread state
//              [p]           -- New message string
//
//  Returns:    TRUE if we figured it out, FALSE if we didn't recognize
//              anything.
//
//----------------------------------------------------------------------------

BOOL
DetermineChildState(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    PFILEREC FileDB;
    USHORT SaveRow;
    USHORT SaveCol;
    USHORT SaveRowTop;
    char buffer[ DB_MAX_PATH_LENGTH ];
    char CheckFileName[300];
    LPSTR FileName;
    LPSTR pCheckFileName;
    ULONG PercentDone;
    LONG FilesLeft;
    LONG LinesLeft;
    ULONG LinesPerSecond;
    ULONG SecondsLeft;
    BOOL fStatusOutput = FALSE;

    //
    // ************ Determine what state the child process is in.
    //               (Compiling, linking, running MIDL, etc.)
    //
    if ( TestCommandPrefix( &p, "rc ") || TestCommandPrefix( &p, "rc.exe ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
            ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
        else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
            ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_COMPILING;
        ThreadState->ChildFlags = 0;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestCommandPrefix( &p, "rc16 ") ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
            ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
        else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
            ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_COMPILING;
        ThreadState->ChildFlags = 0;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if ( TestCommandPrefix( &p, "cl " )  || TestCommandPrefix( &p, "cl.exe " ) ||
         TestCommandPrefix( &p, "covc " )  || TestCommandPrefix( &p, "covc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = C510Filter;
        ThreadState->ChildFlags = 0;
        if ( strstr( p, "/WX" ) != NULL || strstr( p, "-WX" ) != NULL) {
            ThreadState->ChildFlags |= FLAGS_WARNINGS_ARE_ERRORS;
        }
        if ((strstr( p, "/EP " ) != NULL) ||
            (strstr( p, "/E " ) != NULL) ||
            (strstr( p, "/P " ) != NULL) ||
            (strstr( p, "-EP " ) != NULL) ||
            (strstr( p, "-E " ) != NULL) ||
            (strstr( p, "-P " ) != NULL)
           ) {
            if (strstr( p, "i386") || strstr( p, "I386")) {
                ThreadState->ChildTarget = i386TargetMachine.Description;
            }
            else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
                ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
            else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
                ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
            else if (strstr( p, "ia64") || strstr( p, "IA64")) {
                ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
            else {
                ThreadState->ChildTarget = "unknown target";
            }

            strcpy( ThreadState->ChildCurrentFile,IsolateLastToken( p, ' ' ) );
            if ( strstr( p, ".s" ) != NULL )
                ThreadState->ChildState = STATE_S_PREPROC;
            else
                ThreadState->ChildState = STATE_C_PREPROC;
            }
        else
        if ( (pch = strstr( p, "/Yc" )) != NULL ) {
            size_t namelen = strcspn( pch+3, " \t" );
            if (strstr( p, "i386") || strstr( p, "I386")) {
                ThreadState->ChildTarget = i386TargetMachine.Description;
            }
            else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
                ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
            else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
                ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
            else if (strstr( p, "ia64") || strstr( p, "IA64")) {
                ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
            else {
                ThreadState->ChildTarget = "unknown target";
            }

            ThreadState->ChildState = STATE_PRECOMP;
            strncpy( ThreadState->ChildCurrentFile,
                     pch + 3, namelen
                  );
            ThreadState->ChildCurrentFile[namelen] = '\0';
            }
        else
        if (((pch = strstr( p, "*.c" )) != NULL ) || ((pch = strstr( p, "*.cxx" )) != NULL ) || ((pch = strstr( p, "*.cpp" )) != NULL ) ||
            (((pch = strstr( p, ".c " )) != NULL ) && ((pch2 = strstr( pch+1, ".c" )) != NULL )) ||
            (((pch = strstr( p, ".cxx " )) != NULL ) && ((pch2 = strstr( pch+1, ".cxx" )) != NULL )) ||
            (((pch = strstr( p, ".cpp " )) != NULL ) && ((pch2 = strstr( pch+1, ".cpp" )) != NULL ))) {
            if (strstr( p, "i386") || strstr( p, "I386")) {
                ThreadState->ChildTarget = i386TargetMachine.Description;
            }
            else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
                ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
            else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
                ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
            else if (strstr( p, "ia64") || strstr( p, "IA64")) {
                ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
            else {
                ThreadState->ChildTarget = "unknown target";
            }
            ThreadState->ChildState = STATE_BATCHCOMPILE;
            return FALSE;   // batch compiles will be counted by progress output
        }
        else {
            if (strstr( p, "i386") || strstr( p, "I386")) {
                ThreadState->ChildTarget = i386TargetMachine.Description;
            }
            else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
                ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
            else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
                ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
            else if (strstr( p, "ia64") || strstr( p, "IA64")) {
                ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
            else {
                ThreadState->ChildTarget = "unknown target";
            }
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateLastToken( p, ' ' )
                  );
            }
        }
    else

    if ( TestCommandPrefix( &p, "cl16 " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = C510Filter;
        ThreadState->ChildFlags = 0;
        if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
            ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
        else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
            ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }

        ThreadState->ChildState = STATE_COMPILING;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' ));
        }
    else

    if (TestCommandPrefix( &p, "bc " ) || TestCommandPrefix( &p, "bc.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        if (IsolateFirstToken( &p, '-' )) {
            if (*p == '\0')
                return FALSE; // This is a warning/error string
            while(*p != 'i')
            {
                if (!IsolateFirstToken( &p, '-' ))
                {
                    break;
                }
            }

            p++;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' ));

            ThreadState->ChildFlags = 0;
            ThreadState->ChildTarget = "all platforms";
            ThreadState->FilterProc = MSBCFilter;

            ThreadState->ChildState = STATE_COMPILING;
            }
        }
    else

    if (TestCommandPrefix( &p, "vbc " ) || TestCommandPrefix( &p, "vbc.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSBCFilter;

        ThreadState->ChildState = STATE_COMPILING;
        strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
    else

    if (TestCommandPrefix( &p, "jvc " ) || TestCommandPrefix( &p, "jvc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSJVCFilter;

        if (((pch = strstr( p, "*.java" )) != NULL ) || 
            (((pch = strstr( p, ".java" )) != NULL ) && ((pch2 = strstr( pch+1, ".java" )) != NULL ))) {
            ThreadState->ChildState = STATE_BATCHCOMPILE;
            // batch compiles will be counted by progress output
            if (getenv("JVC_TERSE") != NULL)
                strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, '\\' ) );
            else
                return FALSE;
        } else {
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
        }
    else

    if (TestCommandPrefix( &p, "coolc " ) || TestCommandPrefix( &p, "coolc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSCoolFilter;

        if (((pch = strstr( p, "*.cool" )) != NULL ) || 
            (((pch = strstr( p, ".cool" )) != NULL ) && ((pch2 = strstr( pch+1, ".cool" )) != NULL ))) {
            ThreadState->ChildState = STATE_BATCHCOMPILE;
            // batch compiles will be counted by progress output
            return FALSE;
        } else {
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
        }
    else

    if (TestCommandPrefix( &p, "csc " ) || TestCommandPrefix( &p, "csc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSCSharpFilter;

        if (((pch = strstr( p, "*.cs" )) != NULL ) || 
            (((pch = strstr( p, ".cs" )) != NULL ) && ((pch2 = strstr( pch+1, ".cs" )) != NULL ))) {
            ThreadState->ChildState = STATE_BATCHCOMPILE;
            // batch compiles will be counted by progress output
            return FALSE;
        } else {
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
        }
    else

    if (TestCommandPrefix( &p, "resgen " ) || TestCommandPrefix( &p, "resgen.exe " ) || TestCommandPrefix( &p, "ResGen: Error:" )) {
        //
        // resgen usage:
        // ResGen inputFile.ext [outputFile.ext]
        //   no wildcards

        if (*(p-1) == ':') {
            // this is an error string
            if (ThreadState->FilterProc != ResGenFilter) {
                // switch the filter proc if we didn't know that ResGen was running
                ThreadState->FilterProc = ResGenFilter;
                strcpy( ThreadState->ChildCurrentFile, "" );
                }
            return FALSE;
            }

        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = ResGenFilter;

        ThreadState->ChildState = STATE_COMPILING;
        strcpy( ThreadState->ChildCurrentFile, IsolateFirstToken( &p, ' ' ) );
        }
    else

    if (TestCommandPrefix( &p, "cscript " ) || TestCommandPrefix( &p, "cscript.exe " )) {
        //
        // cscript usage:
        // CScript [option...] scriptname.extension [option...] [arguments...]
        // options are prefixed with / or -

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->ChildState = STATE_VSTOOL;
        ThreadState->FilterProc = CScriptFilter;
        strcpy( ThreadState->ChildCurrentFile, "" );    // don't care about the name; it would be displayed on error
        }
    else

    if (TestCommandPrefix( &p, "docchecker " ) || TestCommandPrefix( &p, "docchecker.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_DOCCHECKING;
        ThreadState->ChildTarget = "all platforms";
        strcpy( ThreadState->ChildCurrentFile, "" );
        }
    else

    if (TestCommandPrefix( &p, "scc " ) || TestCommandPrefix( &p, "scc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSToolFilter;

        if (((pch = strstr( p, "*.sc" )) != NULL ) || 
            (((pch = strstr( p, ".sc" )) != NULL ) && ((pch2 = strstr( pch+1, ".sc" )) != NULL ))) {
            ThreadState->ChildState = STATE_BATCHCOMPILE;
            // batch compiles will be counted by progress output
            return FALSE;
        } else {
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
        }
    else

    if (TestCommandPrefix( &p, "wfctosafec " ) || TestCommandPrefix( &p, "wfctosafec.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSToolFilter;

        if (((pch = strstr( p, "*.sc" )) != NULL ) || 
            (((pch = strstr( p, ".sc" )) != NULL ) && ((pch2 = strstr( pch+1, ".sc" )) != NULL ))) {
            ThreadState->ChildState = STATE_BATCHCOMPILE;
            // batch compiles will be counted by progress output
            return FALSE;
        } else {
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
        }
    else

    if (TestCommandPrefix( &p, "ml " ) || TestCommandPrefix( &p, "ml.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_ASSEMBLING;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = i386TargetMachine.Description;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestCommandPrefix( &p, "masm ") || TestCommandPrefix( &p, "masm.exe ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_ASSEMBLING;
        ThreadState->ChildFlags = 0;
        if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
            ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
        else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
            ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }

        if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
            ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }

        if (strstr(p, ",")) {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateLastToken(IsolateFirstToken(&p,','), ' '));
            }
        else {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateLastToken(IsolateFirstToken(&p,';'), ' '));
            }

        }
    else

    if (TestCommandPrefix( &p, "lib " ) || TestCommandPrefix( &p, "lib.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }
        if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
            ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
        else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
            ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }
        ThreadState->FilterProc = CoffFilter;
        ThreadState->ChildFlags = 0;
        if (TestPrefix( &p, "-out:" )) {
            ThreadState->LinesToIgnore = 1;
            ThreadState->ChildState = STATE_LIBING;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' )
                  );
            }
        else
        if (TestPrefix( &p, "-def:" )) {
            ThreadState->LinesToIgnore = 1;
            ThreadState->ChildState = STATE_LIBING;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' )
                  );
            if (TestPrefix( &p, "-out:" )) {
                strcpy( ThreadState->ChildCurrentFile,
                        IsolateFirstToken( &p, ' ' )
                      );
                }
            }
        else {
            return FALSE;
            }
        }
    else

    if (TestCommandPrefix( &p, "implib " ) || TestCommandPrefix( &p, "implib.exe " ) ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }
        if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
            ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
        else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
            ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }

        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_LIBING;
        if (strstr(p, ";")) {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ';' ));
            }
        else {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' ));
            } 
        }
    else

    if (TestCommandPrefix( &p, "link " ) || TestCommandPrefix( &p, "link.exe " ) || 
        TestCommandPrefix( &p, "covlink ") || TestCommandPrefix( &p, "covlink.exe ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }
        if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
            ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
        else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
            ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }
        ThreadState->FilterProc = CoffFilter;
        ThreadState->ChildFlags = 0;
        if (TestPrefix( &p, "-out:" )) {
            ThreadState->LinesToIgnore = 2;
            ThreadState->ChildState = STATE_LINKING;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' )
                  );
            }
        }
    else

    if (TestCommandPrefix( &p, "link16" ) ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }
        if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "alpha64") || strstr( p, "ALPHA64")) {
            ThreadState->ChildTarget = Alpha64TargetMachine.Description;
            }
        else if (strstr( p, "alpha") || strstr( p, "ALPHA")) {
            ThreadState->ChildTarget = AlphaTargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }

        ThreadState->FilterProc = LinkFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_LINKING;
        p = IsolateLastToken(p, ' ');
        if (strstr(p, ";")) {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ';' ));
            }
        else {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ',' ));
            }

        }
    else

    if ( TestCommandPrefix( &p, "bscmake " ) || TestCommandPrefix( &p, "bscmake.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string

        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_BSCMAKING;
        ThreadState->ChildTarget = "all platforms";
        if ( (pch = strstr( p, "/o" )) != NULL ) {
            size_t namelen;
            pch2 = pch + 3;
            if ( *pch2 == '"' )
                pch2++;
            namelen = strcspn( pch2, " \t\"" );
            strncpy( ThreadState->ChildCurrentFile, pch2, namelen );
            ThreadState->ChildCurrentFile[namelen] = '\0';
            }
        }
    else

    if (TestCommandPrefix( &p, "asaxp " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_ASSEMBLING;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = AlphaTargetMachine.Description;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestCommandPrefix( &p, "icl ")) {
        while (*p == ' ') {
            p++;
            }
        ThreadState->ChildState = STATE_COMPILING;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = ia64TargetMachine.Description;
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestCommandPrefix( &p, "mktyplib " ) || TestCommandPrefix( &p, "mktyplib.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildState = STATE_MKTYPLIB;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestPrefix( &p, "MC: Compiling " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildState = STATE_MC;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestCommandPrefix( &p, "midl " ) || TestCommandPrefix( &p, "midl.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildState = STATE_MIDL;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestCommandPrefix( &p, "asn1 " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildState = STATE_ASN;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy(ThreadState->ChildCurrentFile, IsolateLastToken(p, ' '));
        }
    else

    if (TestPrefix( &p, "Build_Status " )) {
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildState = STATE_STATUS;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile, "" );
        }

    else
    if (TestCommandPrefix( &p, "binplace " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        // If this is a standard link/binplace step, don't tell the
        // user what's going on, just pass any errors/warnings to
        // the output.  If this is a straight binplace, list the state.

        if (ThreadState->ChildState == STATE_LINKING) {
            ThreadState->ChildState = STATE_BINPLACE;
            ThreadState->ChildFlags = 0;
            ThreadState->FilterProc = MSToolFilter;
            return TRUE;
        } else {
            ThreadState->ChildState = STATE_BINPLACE;
            ThreadState->ChildFlags = 0;
            ThreadState->FilterProc = MSToolFilter;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
    }

    else
    if (TestCommandPrefix( &p, "ctc " ) || TestCommandPrefix( &p, "ctc.exe " )) {
        size_t namelen;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_CTCOMPILING;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSToolFilter;
        while (*p == '-') {
            p = p + strcspn( p, " \t" );
            while (*p == ' ')
                p++;
        }
        namelen = strcspn( p, " \t" );
        strncpy( ThreadState->ChildCurrentFile, p, namelen );
        ThreadState->ChildCurrentFile[namelen] = '\0';
    }

    else
    if (TestCommandPrefix( &p, "idheader " )) {
        size_t namelen;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_VSTOOL;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSToolFilter;
        namelen = strcspn( p, " \t" );
        strncpy( ThreadState->ChildCurrentFile, p, namelen );
        ThreadState->ChildCurrentFile[namelen] = '\0';
    }

    else
    if (TestCommandPrefix( &p, "bison ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_VSTOOL;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSToolFilter;
        strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
    }

    else
    if (TestCommandPrefix( &p, "gnu_bison ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_VSTOOL;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = BisonFilter;
        strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
    }

    else
    if ( TestCommandPrefix( &p, "vsautodoc " ) || TestCommandPrefix( &p, "vsautodoc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_AUTODOCING;
        ThreadState->ChildTarget = "all platforms";
        if ( (pch = strstr( p, "/o" )) != NULL ) {
            size_t namelen;
            pch2 = pch + 3;
            if ( *pch2 == '"' )
                pch2++;
            namelen = strcspn( pch2, " \t\"" );
            strncpy( ThreadState->ChildCurrentFile, pch2, namelen );
            ThreadState->ChildCurrentFile[namelen] = '\0';
            }
        }
    else

    if (ThreadState->ChildState == STATE_BATCHCOMPILE) {
        if (strstr( p, "integral type to pointer") ||
            strstr( p, "this conversion is possible") ||
            strstr( p, "void cannot be converted") ||
            strstr( p, "Compiling...") ||
            strstr( p, "Generating Code...") ||
            strstr( p, "Parsing ") ||
            strstr( p, "Loading class:") ||
            strstr( p, "Generating file "))
            return FALSE;       // This is a warning/error/info string
        if (strstr( p, ".c") && !strchr( p, ' ') && !strchr( p, ':'))
            strcpy( ThreadState->ChildCurrentFile, p ); // C/C++ compile
        else if (strstr( p, ".java") && strstr( p, "Compiling ")) {
            if (getenv("JVC_TERSE") != NULL) {
                RunningTotals.NumberCompiles++;
                ThreadState->BuildMetrics.NumberCompiles++;
                return FALSE;
            } else {
                strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, '\\' ) ); // Java compile
            }
        }
        else
            return FALSE;
    }

    else {
        return FALSE;
        }

    //
    // ***************** Set the Thread State according to what we determined.
    //
    if ((strstr( ThreadState->ChildCurrentFile, "*.c" ) == NULL ) && (strstr( ThreadState->ChildCurrentFile, "*.cxx" ) == NULL ) &&
        (strstr( ThreadState->ChildCurrentFile, "*.cpp" ) == NULL ) && (strstr( ThreadState->ChildCurrentFile, "*.java" ) == NULL )) {
        FileName = ThreadState->ChildCurrentFile;

        // make sure directories match to trailing backslash
        strcpy(CheckFileName, FileName);
        pCheckFileName = CheckFileName;

        if (TestPrefix( &pCheckFileName, CurrentDirectory )) {
            if (*pCheckFileName == '\\') {
                FileName += (pCheckFileName - CheckFileName) + 1;
            }

            if (TestPrefix( &pCheckFileName, ThreadState->ChildCurrentDirectory )) {
                if (*pCheckFileName == '\\') {
                    FileName += (pCheckFileName - CheckFileName) + 1;
                }
            }

            strcpy( ThreadState->ChildCurrentFile, FileName );
        }
    }

    FileDB = NULL;

    if (ThreadState->ChildState == STATE_LIBING) {
        RunningTotals.NumberLibraries++;
        ThreadState->BuildMetrics.NumberLibraries++;
        }
    else
    if (ThreadState->ChildState == STATE_LINKING) {
        RunningTotals.NumberLinks++;
        ThreadState->BuildMetrics.NumberLinks++;
        }
    else
    if (ThreadState->ChildState == STATE_BSCMAKING) {
        RunningTotals.NumberBSCMakes++;
        ThreadState->BuildMetrics.NumberBSCMakes++;
        }
    else
    if ((ThreadState->ChildState == STATE_STATUS) ||
        (ThreadState->ChildState == STATE_BINPLACE) ||
        (ThreadState->ChildState == STATE_UNKNOWN)) {
        ;  // Do nothing.
        }
    else {
        if (ThreadState->CompileDirDB) {
            if ((strstr( ThreadState->ChildCurrentFile, "*.c" ) == NULL ) && (strstr( ThreadState->ChildCurrentFile, "*.cxx" ) == NULL ) &&
                (strstr( ThreadState->ChildCurrentFile, "*.cpp" ) == NULL ) && (strstr( ThreadState->ChildCurrentFile, "*.java" ) == NULL )) {
                RunningTotals.NumberCompiles++;
                ThreadState->BuildMetrics.NumberCompiles++;
                CopyString(ThreadState->ChildCurrentFile, ThreadState->ChildCurrentFile, TRUE);
            }

            if (!fQuicky) {
                FileDB = FindSourceFileDB(
                            ThreadState->CompileDirDB,
                            ThreadState->ChildCurrentFile,
                            NULL);
            }
        }
    }

    //
    // *********************** Print the thread state to the screen
    //
    if (ThreadState->IsStdErrTty) {
        GetScreenSize(ThreadState);
        assert(ThreadState->cColTotal != 0);
        assert(ThreadState->cRowTotal != 0);

        if (fStatus) {
            GetCursorPosition(&SaveRow, &SaveCol, &SaveRowTop);

            //  Clear row for process message
            ClearRows (ThreadState,
                       (USHORT) (SaveRowTop + ThreadState->ThreadIndex - 1),
                       1,
                       StatusCell);

            //  Clear row for status message
            ClearRows (ThreadState,
                       (USHORT) (SaveRowTop + NumberProcesses),
                       1,
                       StatusCell);

            //  Make sure there's still some room at the bottom
            if (SaveRow == LastRow(ThreadState)) {
                USHORT RowTop = 1 + SaveRowTop + (USHORT) NumberProcesses + 1;

                MoveRectangleUp (
                    RowTop,                     // Top
                    0,                          // Left
                    LastRow(ThreadState),       // Bottom
                    LastCol(ThreadState),       // Right
                    1,                          // NumRow
                    ScreenCell);                // FillCell

                SaveRow--;
            }

            SetCursorPosition(
                (USHORT) (SaveRowTop + ThreadState->ThreadIndex - 1),
                0);
            fStatusOutput = TRUE;
        }
    }

    if (strstr(ThreadState->ChildCurrentFile, ".cxx") ||
        strstr(ThreadState->ChildCurrentFile, ".cpp")) {
        ThreadState->ChildFlags |= FLAGS_CXX_FILE;
    }

    if (szBuildTag) {
        sprintf(buffer, "%s: ", szBuildTag);
        WriteTTY(ThreadState, buffer, fStatusOutput);
    }

    if (fParallel) {
        sprintf(buffer, "%d>", ThreadState->ThreadIndex);
        WriteTTY(ThreadState, buffer, fStatusOutput);
    }

    if (ThreadState->ChildState == STATE_UNKNOWN) {
        if (!fAlreadyUnknown) {
            WriteTTY(
                ThreadState,
                "Processing Unknown item(s)...\r\n",
                fStatusOutput);
            fAlreadyUnknown = TRUE;
        }
    }
    else
    if (ThreadState->ChildState == STATE_STATUS) {
        WriteTTY(ThreadState, p, fStatusOutput);
        WriteTTY(ThreadState, "\r\n", fStatusOutput);
    }
    else {
        fAlreadyUnknown = FALSE;
        WriteTTY(ThreadState, States[ThreadState->ChildState], fStatusOutput);
        WriteTTY(ThreadState, " - ", fStatusOutput);
        if ((strstr( ThreadState->ChildCurrentFile, "*.c" ) == NULL ) && (strstr( ThreadState->ChildCurrentFile, "*.cxx" ) == NULL ) &&
            (strstr( ThreadState->ChildCurrentFile, "*.cpp" ) == NULL ) && (strstr( ThreadState->ChildCurrentFile, "*.java" ) == NULL )) {
            WriteTTY(ThreadState, FormatPathName(ThreadState->ChildCurrentDirectory, ThreadState->ChildCurrentFile), fStatusOutput);
        } else {
            WriteTTY(ThreadState, ThreadState->ChildCurrentFile, fStatusOutput);
        }
        WriteTTY(ThreadState, " for ", fStatusOutput);
        WriteTTY(ThreadState, ThreadState->ChildTarget, fStatusOutput);
        WriteTTY(ThreadState, "\r\n", fStatusOutput);

        if (fXMLOutput) {
            XMLThreadInitBuffer(ThreadState);
            if (PXMLThreadStates[ThreadState->XMLThreadIndex]->fXMLInAction) {
                // check for action errors or warnings
                if (ThreadState->BuildMetrics.NumberActErrors || ThreadState->BuildMetrics.NumberActWarnings) {
                    sprintf(szXMLBuffer, "<ACTIONSUMMARY ");
                    if (ThreadState->BuildMetrics.NumberActErrors) {
                        sprintf(szXMLBuffer + strlen(szXMLBuffer), " ERRORS=\"%d\"", ThreadState->BuildMetrics.NumberActErrors);
                    }
                    if (ThreadState->BuildMetrics.NumberActWarnings) {
                        sprintf(szXMLBuffer + strlen(szXMLBuffer), " WARNINGS=\"%d\"", ThreadState->BuildMetrics.NumberActWarnings);
                    }
                    strcat(szXMLBuffer, "/>");
                    XMLThreadWrite(ThreadState, szXMLBuffer);
                }
                XMLThreadCloseTag(ThreadState, "ACTION");
                PXMLThreadStates[ThreadState->XMLThreadIndex]->fXMLInAction = FALSE;
            }
            XMLThreadOpenTag(ThreadState, "ACTION", "TYPE=\"%s\" FILE=\"%s\" TARGET=\"%s\"", States[ThreadState->ChildState], ThreadState->ChildCurrentFile, ThreadState->ChildTarget);
            PXMLThreadStates[ThreadState->XMLThreadIndex]->fXMLInAction = TRUE;
        }
        ThreadState->BuildMetrics.NumberDirActions++;
        ThreadState->BuildMetrics.NumberActErrors = 0;
        ThreadState->BuildMetrics.NumberActWarnings = 0;
    }

    if (StartCompileTime) {
        ElapsedCompileTime += time(NULL) - StartCompileTime;
    }

    if (FileDB != NULL) {
        StartCompileTime = time(NULL);
    }
    else {
        StartCompileTime = 0L;
    }

    //
    // ****************** Update the status line
    //
    if (fStatus) {
        if (FileDB != NULL) {
            FilesLeft = TotalFilesToCompile - TotalFilesCompiled;
            if (FilesLeft < 0) {
                FilesLeft = 0;
            }
            LinesLeft = TotalLinesToCompile - TotalLinesCompiled;
            if (LinesLeft < 0) {
                LinesLeft = 0;
                PercentDone = 99;
            }
            else if (TotalLinesToCompile != 0) {
                if (TotalLinesCompiled > 20000000L) {
                    int TLC = TotalLinesCompiled / 100;
                    int TLTC = TotalLinesToCompile / 100;

                    PercentDone = (TLC * 100L)/TLTC;
                }
                else
                    PercentDone = (TotalLinesCompiled * 100L)/TotalLinesToCompile;
            }
            else {
                PercentDone = 0;
            }

            if (ElapsedCompileTime != 0) {
                LinesPerSecond = TotalLinesCompiled / ElapsedCompileTime;
            }
            else {
                LinesPerSecond = 0;
            }

            if (LinesPerSecond != 0) {
                SecondsLeft = LinesLeft / LinesPerSecond;
            }
            else {
                SecondsLeft = LinesLeft / DEFAULT_LPS;
            }

            sprintf(
                buffer,
                "%2d%% done. %4ld %sLPS  Time Left:%s  Files: %d  %sLines: %s\r\n",
                PercentDone,
                LinesPerSecond,
                fStatusTree? "T" : "",
                FormatTime(SecondsLeft),
                FilesLeft,
                fStatusTree? "Total " : "",
                FormatNumber(LinesLeft));

            SetCursorPosition((USHORT) (SaveRowTop + NumberProcesses), 0);

            WriteTTY(ThreadState, buffer, fStatusOutput);
        }

        if (ThreadState->IsStdErrTty) {
            assert(ThreadState->cColTotal != 0);
            assert(ThreadState->cRowTotal != 0);
            SetCursorPosition(SaveRow, SaveCol);
        }
    }

    //
    // ***************** Keep track of how many files have been compiled.
    //
    if (ThreadState->ChildState == STATE_COMPILING  ||
        ThreadState->ChildState == STATE_ASSEMBLING ||
        ThreadState->ChildState == STATE_MKTYPLIB   ||
        ThreadState->ChildState == STATE_MIDL       ||
        ThreadState->ChildState == STATE_ASN        ||
        (FileDB != NULL && ThreadState->ChildState == STATE_PRECOMP)) {
        TotalFilesCompiled++;
    }
    if (FileDB != NULL) {
        TotalLinesCompiled += FileDB->TotalSourceLines;
    }

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessLine
//
//  Synopsis:   Watch the lines coming from the thread for special strings.
//
//----------------------------------------------------------------------------

BOOL
ProcessLine(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR p1;

    while (*p <= ' ') {
        if (!*p) {
            return( FALSE );
            }
        else {
            p++;
            }
        }

    p1 = p;
    while (*p1) {
        if (*p1 == '\r')
            break;
        else
            p1++;
        }
    *p1 = '\0';

    p1 = p;
    if (TestPrefix( &p1, "Stop." )) {
        return( TRUE );
        }

    //  Stop multithread access to shared:
    //      database
    //      window
    //      compilation stats

    EnterCriticalSection(&TTYCriticalSection);

    if (TestPrefix( &p1, "nmake :" )) {
        PassThrough( ThreadState, p, FALSE );
    }
    else
    if (ThreadState->LinesToIgnore) {
        ThreadState->LinesToIgnore--;
    }
    else {
        if ( !DetermineChildState( ThreadState, p ) ) {
            if (!ToolNotFoundFilter( ThreadState, p ))
                {
                if (ThreadState->FilterProc != NULL) {
                    (*ThreadState->FilterProc)( ThreadState, p );
                    }
                }
            }
        }

    if (fXMLVerboseOutput) {
        XMLThreadWrite(ThreadState, "<RAW MESSAGE=\"%s\"/>\r\n", XMLEncodeBuiltInEntitiesCopy(p, szXMLBuffer));
    }

    LeaveCriticalSection(&TTYCriticalSection);

    return( FALSE );
}


//+---------------------------------------------------------------------------
//
//  Function:   FilterThread
//
//  Synopsis:   Capture the output of the thread and process it.
//
//----------------------------------------------------------------------------

VOID
FilterThread(
    PTHREADSTATE ThreadState
    )
{
    UINT CountBytesRead;
    LPSTR StartPointer;
    LPSTR EndPointer;
    LPSTR NewPointer;
    ULONG BufSize = 512;
    UINT uThreadIdLen = 0;

    AllocMem(BufSize, &StartPointer, MT_THREADFILTER);
    while (TRUE) {
        EndPointer = StartPointer;
        do {
            if (BufSize - (EndPointer-StartPointer) < 512) {
                AllocMem(BufSize*2, &NewPointer, MT_THREADFILTER);
                RtlCopyMemory(
                    NewPointer,
                    StartPointer,
                    EndPointer - StartPointer + 1);     // copy null byte, too
                EndPointer += NewPointer - StartPointer;
                FreeMem(&StartPointer, MT_THREADFILTER);
                StartPointer = NewPointer;
                BufSize *= 2;
            }

            if (EndPointer==StartPointer && fParallel && fThreadIndex) {
                /*
                Add build thread index to beginning of message before raw thread output.
                */
                sprintf(EndPointer, "%d>", ThreadState->ThreadIndex);

                uThreadIdLen = strlen(EndPointer);
                if (!fgets(EndPointer+uThreadIdLen, 512-uThreadIdLen, ThreadState->ChildOutput)) {
                    if (errno != 0)
                        BuildError("Pipe read failed - errno = %d\n", errno);
                    FreeMem(&StartPointer, MT_THREADFILTER);
                    return;
                }
            }
            else
            {
                if (!fgets(EndPointer, 512, ThreadState->ChildOutput)) {
                    if (errno != 0)
                        BuildError("Pipe read failed - errno = %d\n", errno);
                    FreeMem(&StartPointer, MT_THREADFILTER);
                    return;
                }
            }
            CountBytesRead = strlen(EndPointer);
            EndPointer = EndPointer + CountBytesRead;
        } while (CountBytesRead == 511 && EndPointer[-1] != '\n');

        CountBytesRead = EndPointer - StartPointer;
        if (LogFile != NULL && CountBytesRead) {
            fwrite(StartPointer, 1, CountBytesRead, LogFile);
        }
        if (ProcessLine(ThreadState, StartPointer)) {
            FreeMem(&StartPointer, MT_THREADFILTER);
            return;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ExecuteProgram
//
//  Synopsis:   Spawn a new thread to execute the given program and filter
//              its output.
//
//  Arguments:  [ProgramName]       --
//              [CommandLine]       --
//              [MoreCommandLine]   --
//              [MustBeSynchronous] -- For synchronous operation on a
//                                      multi-processor machine.
//              [XMLDir]            -- For XML output only - the name of 
//                                      the directory processed.
//              [XMLAction]         -- For XML output only - what we are
//                                      doing with the directory.
//
//  Returns:    ERROR_SUCCESS, ERROR_NOTENOUGHMEMORY, or return code from
//              PipeSpawnClose.
//
//  Notes:      On a multiprocessor machine, this will spawn a new thread
//              and then return, letting the thread run asynchronously.  Use
//              WaitForParallelThreads() to ensure all threads are finished.
//              By default, this routine will spawn as many threads as the
//              machine has processors.  This can be overridden with the -M
//              option.
//
//----------------------------------------------------------------------------

char ExecuteProgramCmdLine[ 1024 ];

UINT
ExecuteProgram(
    LPSTR ProgramName,
    LPSTR CommandLine,
    LPSTR MoreCommandLine,
    BOOL MustBeSynchronous,
    LPCSTR XMLDir,
    LPCSTR XMLAction)
{
    LPSTR p;
    UINT rc;
    THREADSTATE *ThreadState;
    UINT OldErrorMode;
    DWORD dwStartTime;

    AllocMem(sizeof(THREADSTATE), &ThreadState, MT_THREADSTATE);

    memset(ThreadState, 0, sizeof(*ThreadState));
    ThreadState->ChildState = STATE_UNKNOWN;
    ThreadState->ChildTarget = "Unknown Target";
    ThreadState->IsStdErrTty = (BOOL) _isatty(_fileno(stderr));
    ThreadState->CompileDirDB = CurrentCompileDirDB;
    ThreadState->FilterProc = NMakeFilter;

    if (ThreadState->IsStdErrTty) {
        GetScreenSize(ThreadState);
        assert(ThreadState->cColTotal != 0);
        assert(ThreadState->cRowTotal != 0);

        // We're displaying to the screen, so initialize the console.

        if (!fConsoleInitialized) {
            StatusCell[1] =
                        BACKGROUND_RED |
                        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN |
                        FOREGROUND_INTENSITY;

            ReadConsoleCells(ScreenCell, sizeof(ScreenCell), 2, 0);

            // If we stumbled upon an old Status line in row 2 of the window,
            // try the current row to avoid using the Status line background
            // colors for fill when scrolling.

            if (ScreenCell[1] == StatusCell[1]) {
                USHORT Row, Col;

                GetCursorPosition(&Row, &Col, NULL);
                ReadConsoleCells(ScreenCell, sizeof(ScreenCell), Row, 0);
            }
            ScreenCell[0] = StatusCell[0] = ' ';

            GetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), &OldConsoleMode);
            NewConsoleMode = OldConsoleMode;
            fConsoleInitialized = TRUE;
        }
        if (fStatus)
        {
            NewConsoleMode = OldConsoleMode & ~(ENABLE_WRAP_AT_EOL_OUTPUT);
        } else
        {
            NewConsoleMode = OldConsoleMode | ENABLE_WRAP_AT_EOL_OUTPUT;
        }
        SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), NewConsoleMode);
    }
    else {
        ThreadState->cRowTotal = 0;
        ThreadState->cColTotal = 0;
    }

    p = ThreadState->ChildCurrentDirectory;
    GetCurrentDirectory(sizeof(ThreadState->ChildCurrentDirectory), p);

    if (TestPrefix(&p, CurrentDirectory)) {
        if (*p == '\\') {
            p++;
        }
        strcpy(ThreadState->ChildCurrentDirectory, p);
    }

    if (ThreadState->ChildCurrentDirectory[0]) {
        strcat(ThreadState->ChildCurrentDirectory, "\\");
    }

    sprintf(
        ExecuteProgramCmdLine,
        "%s %s%s",
        ProgramName,
        CommandLine,
        MoreCommandLine);
    LogMsg("'%s %s%s'\n", ProgramName, CommandLine, MoreCommandLine);

    if (fParallel && !MustBeSynchronous) {
        PPARALLEL_CHILD ChildData;
        DWORD i;
        DWORD ThreadId;

        AllocMem(sizeof(PARALLEL_CHILD), &ChildData, MT_CHILDDATA);
        strcpy(ChildData->ExecuteProgramCmdLine,ExecuteProgramCmdLine);
        ChildData->ThreadState = ThreadState;

        if (ThreadsStarted < NumberProcesses) {
            if (ThreadsStarted == 0) {
                AllocMem(
                    sizeof(HANDLE) * NumberProcesses,
                    (VOID **) &WorkerThreads,
                    MT_THREADHANDLES);
                AllocMem(
                    sizeof(HANDLE) * NumberProcesses,
                    (VOID **) &WorkerEvents,
                    MT_EVENTHANDLES);
            }
            WorkerEvents[ThreadsStarted] = CreateEvent(NULL,
                                                       FALSE,
                                                       FALSE,
                                                       NULL);
            ChildData->Event = WorkerEvents[ThreadsStarted];

            ThreadState->ThreadIndex = ThreadsStarted+1;
            if (fXMLOutput) {
                ThreadState->XMLThreadIndex = ThreadState->ThreadIndex;
            }

            /*
            Thread-specific directory message that associates directory to build thread.
            */
            if (fParallel && fThreadIndex && ThreadState->CompileDirDB) {
                char buffer[500];
                ThreadState->CompileDirDB;
                sprintf(buffer, "%d>BUILDMSG: Processing %s\n", ThreadState->ThreadIndex,
                    ThreadState->CompileDirDB->Name);
                fwrite(buffer, 1, strlen(buffer), LogFile);
            }

            if (fXMLOutput || fXMLFragment) {
                char buffer[1024];
                char* pszRelPath = (char*)XMLDir;
                if (TestPrefix(&pszRelPath, CurrentDirectory) && (*pszRelPath == '\\')) pszRelPath++;
                if (strlen(pszRelPath) == 0) {
                    pszRelPath = ".\\";
                }
                strcpy(buffer, "CMDLINE=\"");
                XMLEncodeBuiltInEntitiesCopy(ExecuteProgramCmdLine, buffer+strlen(buffer));
                sprintf(buffer + strlen(buffer), "\" ACTION=\"%s\" FULLPATH=\"%s\" RELPATH=\"%s\"", XMLAction, ThreadState->ChildCurrentDirectory, pszRelPath);
                if (fXMLOutput) {
                    XMLThreadInitBuffer(ThreadState);
                    XMLThreadOpenTag(ThreadState, "DIR", buffer);
                }
                if (fXMLFragment) {
                    XMLWriteDirFragmentFile(TRUE, pszRelPath, "<DIR %s/>", buffer);
                }
                dwStartTime = GetTickCount();
            }
            memset(&(ThreadState->BuildMetrics), 0, sizeof(BUILDMETRICS));

            WorkerThreads[ThreadsStarted] = CreateThread(NULL,
                                                         0,
                                (LPTHREAD_START_ROUTINE) ParallelChildStart,
                                                         ChildData,
                                                         0,
                                                         &ThreadId);
            if ((WorkerThreads[ThreadsStarted] == NULL) ||
                (WorkerEvents[ThreadsStarted] == NULL)) {
                FreeMem(&ChildData, MT_CHILDDATA);
                FreeMem(&ThreadState, MT_THREADSTATE);
                return(ERROR_NOT_ENOUGH_MEMORY);
            } else {
                WaitForSingleObject(WorkerEvents[ThreadsStarted],INFINITE);
                ++ThreadsStarted;
            }
        } else {
            //
            // Wait for a thread to complete before starting
            // the next one.
            //
            i = WaitForMultipleObjects(NumberProcesses,
                                       WorkerThreads,
                                       FALSE,
                                       INFINITE);
            CloseHandle(WorkerThreads[i]);
            ChildData->Event = WorkerEvents[i];
            ThreadState->ThreadIndex = i+1;
            if (fXMLOutput) {
                ThreadState->XMLThreadIndex = ThreadState->ThreadIndex;
            }

            /*
            Thread-specific directory message that associates directory to build thread.
            */
            if (fParallel && fThreadIndex && ThreadState->CompileDirDB) {
                char buffer[500];
                ThreadState->CompileDirDB;
                sprintf(buffer, "%d>BUILDMSG: Processing %s\n", ThreadState->ThreadIndex,
                    ThreadState->CompileDirDB->Name);
                fwrite(buffer, 1, strlen(buffer), LogFile);
            }

            if (fXMLOutput || fXMLFragment) {
                char buffer[1024];
                char* pszRelPath = (char*)XMLDir;
                if (TestPrefix(&pszRelPath, CurrentDirectory) && (*pszRelPath == '\\')) pszRelPath++;
                if (strlen(pszRelPath) == 0) {
                    pszRelPath = ".\\";
                }
                strcpy(buffer, "CMDLINE=\"");
                XMLEncodeBuiltInEntitiesCopy(ExecuteProgramCmdLine, buffer+strlen(buffer));
                sprintf(buffer + strlen(buffer), "\" ACTION=\"%s\" FULLPATH=\"%s\" RELPATH=\"%s\"", XMLAction, XMLDir, pszRelPath);
                if (fXMLOutput) {
                    XMLThreadInitBuffer(ThreadState);
                    XMLThreadOpenTag(ThreadState, "DIR", buffer);
                }
                if (fXMLFragment) {
                    XMLWriteDirFragmentFile(TRUE, pszRelPath, "<DIR %s/>", buffer);
                }
                dwStartTime = GetTickCount();
            }
            memset(&(ThreadState->BuildMetrics), 0, sizeof(BUILDMETRICS));

            WorkerThreads[i] = CreateThread(NULL,
                                            0,
                   (LPTHREAD_START_ROUTINE) ParallelChildStart,
                                            ChildData,
                                            0,
                                            &ThreadId);
            if (WorkerThreads[i] == NULL) {
                FreeMem(&ChildData, MT_CHILDDATA);
                FreeMem(&ThreadState, MT_THREADSTATE);
                return(ERROR_NOT_ENOUGH_MEMORY);
            } else {
                WaitForSingleObject(WorkerEvents[i],INFINITE);
            }
        }

        return(ERROR_SUCCESS);

    } else {

        //
        // Synchronous operation
        //
        StartCompileTime = 0L;
        ThreadState->ThreadIndex = 1;
        if (fXMLOutput) {
            // the synchronized directories are always processed by the main thread
            ThreadState->XMLThreadIndex = 0;
        }

        //
        // Disable child error popups in child processes.
        //

        if (fClean) {
            OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );
            }

        /*
        Thread-specific directory message that associates directory to build thread.
        */
        if (fParallel && fThreadIndex && ThreadState->CompileDirDB) {
            char buffer[500];
            ThreadState->CompileDirDB;
            sprintf(buffer, "%d>BUILDMSG: Processing %s\n", ThreadState->ThreadIndex,
                ThreadState->CompileDirDB->Name);
            fwrite(buffer, 1, strlen(buffer), LogFile);
        }

        if (fXMLOutput || fXMLFragment) {
            char buffer[1024];
            char* pszRelPath = (char*)XMLDir;
            if (TestPrefix(&pszRelPath, CurrentDirectory) && (*pszRelPath == '\\')) pszRelPath++;
            if (strlen(pszRelPath) == 0) {
                pszRelPath = ".\\";
            }
            strcpy(buffer, "CMDLINE=\"");
            XMLEncodeBuiltInEntitiesCopy(ExecuteProgramCmdLine, buffer+strlen(buffer));
            sprintf(buffer + strlen(buffer), "\" ACTION=\"%s\" FULLPATH=\"%s\" RELPATH=\"%s\"", XMLAction, XMLDir, pszRelPath);
            if (fXMLOutput) {
                XMLThreadInitBuffer(ThreadState);
                XMLThreadOpenTag(ThreadState, "DIR", buffer);
            }
            if (fXMLFragment) {
                XMLWriteDirFragmentFile(TRUE, pszRelPath, "<DIR %s/>", buffer);
            }
            dwStartTime = GetTickCount();
        }
        memset(&(ThreadState->BuildMetrics), 0, sizeof(BUILDMETRICS));

        ThreadState->ChildOutput = PipeSpawn( ExecuteProgramCmdLine );
        if (fClean) {
            SetErrorMode( OldErrorMode );
            }

        rc = ERROR_SUCCESS;

        if (ThreadState->ChildOutput == NULL) {
            BuildError(
                "Exec of '%s' failed - errno = %d\n",
                ExecuteProgramCmdLine,
                errno);
            }
        else {
            FilterThread( ThreadState );

            if (StartCompileTime) {
                ElapsedCompileTime += time(NULL) - StartCompileTime;
                }

            rc = PipeSpawnClose( ThreadState->ChildOutput );
            if (rc == -1) {
                BuildError("Child Terminate failed - errno = %d\n", errno);
            }
            else
            if (rc) {
                CONSOLE_SCREEN_BUFFER_INFO csbi;
                GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
                if (fColorConsole)
                    SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);
                BuildError("%s failed - rc = %d\n", ProgramName, rc);
                if (fColorConsole)
                    SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
                }
            }

        if (fXMLOutput || fXMLFragment) {
            XMLEnterCriticalSection();
            AddBuildMetrics(&PassMetrics, &ThreadState->BuildMetrics);

            if (fXMLOutput) {
                if (PXMLThreadStates[ThreadState->XMLThreadIndex]->fXMLInAction) {
                    // check for action errors or warnings
                    if (ThreadState->BuildMetrics.NumberActErrors || ThreadState->BuildMetrics.NumberActWarnings) {
                        sprintf(szXMLBuffer, "<ACTIONSUMMARY ");
                        if (ThreadState->BuildMetrics.NumberActErrors) {
                            sprintf(szXMLBuffer + strlen(szXMLBuffer), " ERRORS=\"%d\"", ThreadState->BuildMetrics.NumberActErrors);
                        }
                        if (ThreadState->BuildMetrics.NumberActWarnings) {
                            sprintf(szXMLBuffer + strlen(szXMLBuffer), " WARNINGS=\"%d\"", ThreadState->BuildMetrics.NumberActWarnings);
                        }
                        strcat(szXMLBuffer, "/>");
                        XMLThreadWrite(ThreadState, szXMLBuffer);
                    }
                    XMLThreadCloseTag(ThreadState, "ACTION");
                    PXMLThreadStates[ThreadState->XMLThreadIndex]->fXMLInAction = FALSE;
                }
            }
            sprintf(szXMLBuffer, "ELAPSED=\"%s\" ACTIONS=\"%d\" ", FormatElapsedTime(dwStartTime), ThreadState->BuildMetrics.NumberDirActions);
            strcat(szXMLBuffer, XMLBuildMetricsString(&(ThreadState->BuildMetrics)));

            if (fXMLOutput) {
                XMLThreadWrite(ThreadState, "<DIRSUMMARY %s/>", szXMLBuffer);
                XMLThreadCloseTag(ThreadState, "DIR");
                XMLThreadReleaseBuffer(ThreadState);
                XMLUpdateEndTag(FALSE);
            }
            if (fXMLFragment) {
                XMLWriteDirFragmentFile(
                    FALSE, 
                    strlen(ThreadState->ChildCurrentDirectory) == 0 ? ".\\" : ThreadState->ChildCurrentDirectory,
                    "<DIRSUMMARY %s/>", 
                    szXMLBuffer);
            }

            XMLLeaveCriticalSection();
        }

        if (ThreadState->IsStdErrTty) {
            RestoreConsoleMode();
        }

        FreeMem(&ThreadState, MT_THREADSTATE);
        return( rc );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   WaitForParallelThreads
//
//  Synopsis:   Wait for all threads to finish before returning.
//
//----------------------------------------------------------------------------

VOID
WaitForParallelThreads(
    VOID
    )
{
    if (fParallel) {
        WaitForMultipleObjects(ThreadsStarted,
                               WorkerThreads,
                               TRUE,
                               INFINITE);
        while (ThreadsStarted) {
            CloseHandle(WorkerThreads[--ThreadsStarted]);
            CloseHandle(WorkerEvents[ThreadsStarted]);
        }
        if (WorkerThreads != NULL) {
            FreeMem((VOID **) &WorkerThreads, MT_THREADHANDLES);
            FreeMem((VOID **) &WorkerEvents, MT_EVENTHANDLES);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ParallelChildStart
//
//  Synopsis:   Function that is run once for each thread.
//
//  Arguments:  [Data] -- Data given to CreateThread.
//
//----------------------------------------------------------------------------

DWORD
ParallelChildStart(
    PPARALLEL_CHILD Data
    )
{
    UINT OldErrorMode;
    UINT rc;
    DWORD dwStartTime = GetTickCount();

    //
    // Disable child error popups
    //
    if (fClean) {
        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );
    }
    Data->ThreadState->ChildOutput = PipeSpawn(Data->ExecuteProgramCmdLine);

    if (fClean) {
        SetErrorMode(OldErrorMode);
    }

    //
    // Poke the event to indicate that the child process has
    // started and it is ok for the main thread to change
    // the current directory.
    //
    SetEvent(Data->Event);

    if (Data->ThreadState->ChildOutput==NULL) {
        BuildError(
            "Exec of '%s' failed - errno = %d\n",
            ExecuteProgramCmdLine,
            errno);
    } else {
        FilterThread(Data->ThreadState);
        rc = PipeSpawnClose(Data->ThreadState->ChildOutput);
        if (rc == -1) {
            BuildError("Child terminate failed - errno = %d\n", errno);
        } else {
            if (rc) {
                BuildError("%s failed - rc = %d\n", Data->ExecuteProgramCmdLine, rc);
            }
        }
    }

    if (Data->ThreadState->IsStdErrTty) {
        RestoreConsoleMode();
    }

    if (fXMLOutput || fXMLFragment) {
        XMLEnterCriticalSection();
        AddBuildMetrics(&PassMetrics, &Data->ThreadState->BuildMetrics);

        if (fXMLOutput) {
            if (PXMLThreadStates[Data->ThreadState->XMLThreadIndex]->fXMLInAction) {
                // check for action errors or warnings
                if (Data->ThreadState->BuildMetrics.NumberActErrors || Data->ThreadState->BuildMetrics.NumberActWarnings) {
                    sprintf(szXMLBuffer, "<ACTIONSUMMARY ");
                    if (Data->ThreadState->BuildMetrics.NumberActErrors) {
                        sprintf(szXMLBuffer + strlen(szXMLBuffer), " ERRORS=\"%d\"", Data->ThreadState->BuildMetrics.NumberActErrors);
                    }
                    if (Data->ThreadState->BuildMetrics.NumberActWarnings) {
                        sprintf(szXMLBuffer + strlen(szXMLBuffer), " WARNINGS=\"%d\"", Data->ThreadState->BuildMetrics.NumberActWarnings);
                    }
                    strcat(szXMLBuffer, "/>");
                    XMLThreadWrite(Data->ThreadState, szXMLBuffer);
                }
                XMLThreadCloseTag(Data->ThreadState, "ACTION");
                PXMLThreadStates[Data->ThreadState->XMLThreadIndex]->fXMLInAction = FALSE;
            }
        }
        sprintf(szXMLBuffer, "ELAPSED=\"%s\" ACTIONS=\"%d\" ", FormatElapsedTime(dwStartTime), Data->ThreadState->BuildMetrics.NumberDirActions);
        strcat(szXMLBuffer, XMLBuildMetricsString(&(Data->ThreadState->BuildMetrics)));

        if (fXMLOutput) {
            XMLThreadWrite(Data->ThreadState, "<DIRSUMMARY %s/>", szXMLBuffer);
            XMLThreadCloseTag(Data->ThreadState, "DIR");
            XMLThreadReleaseBuffer(Data->ThreadState);
            XMLUpdateEndTag(FALSE);
        }
        if (fXMLFragment) {
            XMLWriteDirFragmentFile(
                FALSE, 
                strlen(Data->ThreadState->ChildCurrentDirectory) == 0 ? ".\\" : Data->ThreadState->ChildCurrentDirectory,
                "<DIRSUMMARY %s/>", 
                szXMLBuffer);
        }
        XMLLeaveCriticalSection();
    }

    FreeMem(&Data->ThreadState, MT_THREADSTATE);
    FreeMem(&Data, MT_CHILDDATA);
    return(rc);

}


//+---------------------------------------------------------------------------
//
//  Function:   ClearRows
//
//----------------------------------------------------------------------------

VOID
ClearRows(
    THREADSTATE *ThreadState,
    USHORT Top,
    USHORT NumRows,
    BYTE *Cell)
{
    COORD Coord;
    DWORD NumWritten;

    Coord.X = 0;
    Coord.Y = Top;

    FillConsoleOutputCharacter(
        GetStdHandle(STD_ERROR_HANDLE),
        Cell[0],
        ThreadState->cColTotal * NumRows,
        Coord,
        &NumWritten);
    FillConsoleOutputAttribute(
        GetStdHandle(STD_ERROR_HANDLE),
        (WORD) Cell[1],
        ThreadState->cColTotal * NumRows,
        Coord,
        &NumWritten);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetScreenSize
//
//----------------------------------------------------------------------------

VOID
GetScreenSize(THREADSTATE *ThreadState)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi)) {
        ThreadState->cRowTotal = 25;
        ThreadState->cColTotal = 80;
    }
    else {
        ThreadState->cRowTotal = csbi.srWindow.Bottom + 1;
        ThreadState->cColTotal = csbi.dwSize.X;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCursorPosition
//
//----------------------------------------------------------------------------

VOID
GetCursorPosition(
    USHORT *pRow,
    USHORT *pCol,
    USHORT *pRowTop)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
    *pRow = csbi.dwCursorPosition.Y;
    *pCol = csbi.dwCursorPosition.X;
    if (pRowTop != NULL) {
        *pRowTop = csbi.srWindow.Top;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SetCursorPosition
//
//----------------------------------------------------------------------------

VOID
SetCursorPosition(USHORT Row, USHORT Col)
{
    COORD Coord;

    Coord.X = Col;
    Coord.Y = Row;
    SetConsoleCursorPosition(GetStdHandle(STD_ERROR_HANDLE), Coord);
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteConsoleCells
//
//----------------------------------------------------------------------------

VOID
WriteConsoleCells(
    LPSTR String,
    USHORT StringLength,
    USHORT Row,
    USHORT Col,
    BYTE *Attribute)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD NumWritten;
    WORD OldAttribute;
    COORD StartCoord;

    //
    // Get current default attribute and save it.
    //

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    OldAttribute = csbi.wAttributes;

    //
    // Set the default attribute to the passed parameter, along with
    // the cursor position.
    //

    if ((BYTE) OldAttribute != *Attribute) {
        SetConsoleTextAttribute(
            GetStdHandle(STD_ERROR_HANDLE),
            (WORD) *Attribute);
    }

    StartCoord.X = Col;
    StartCoord.Y = Row;
    SetConsoleCursorPosition(GetStdHandle(STD_ERROR_HANDLE), StartCoord);

    //
    // Write the passed string at the current cursor position, using the
    // new default attribute.
    //

    WriteFile(
        (HANDLE) STD_ERROR_HANDLE,
        String,
        StringLength,
        &NumWritten,
        NULL);

    //
    // Restore previous default attribute.
    //

    if ((BYTE) OldAttribute != *Attribute) {
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), OldAttribute);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   MoveRectangleUp
//
//----------------------------------------------------------------------------

VOID
MoveRectangleUp (
    USHORT Top,
    USHORT Left,
    USHORT Bottom,
    USHORT Right,
    USHORT NumRow,
    BYTE  *FillCell)
{
    SMALL_RECT ScrollRectangle;
    COORD DestinationOrigin;
    CHAR_INFO Fill;

    ScrollRectangle.Left = Left;
    ScrollRectangle.Top = Top;
    ScrollRectangle.Right = Right;
    ScrollRectangle.Bottom = Bottom;
    DestinationOrigin.X = Left;
    DestinationOrigin.Y = Top - NumRow;
    Fill.Char.AsciiChar = FillCell[0];
    Fill.Attributes = (WORD) FillCell[1];

    ScrollConsoleScreenBuffer(
        GetStdHandle(STD_ERROR_HANDLE),
        &ScrollRectangle,
        NULL,
        DestinationOrigin,
        &Fill);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadConsoleCells
//
//----------------------------------------------------------------------------

VOID
ReadConsoleCells(
    BYTE *ScreenCell,
    USHORT cb,
    USHORT Row,
    USHORT Column)
{
    COORD BufferSize, BufferCoord;
    SMALL_RECT ReadRegion;
    CHAR_INFO CharInfo[1], *p;
    USHORT CountCells;

    CountCells = cb >> 1;
    assert(CountCells * sizeof(CHAR_INFO) <= sizeof(CharInfo));
    ReadRegion.Top = Row;
    ReadRegion.Left = Column;
    ReadRegion.Bottom = Row;
    ReadRegion.Right = Column + CountCells - 1;
    BufferSize.X = 1;
    BufferSize.Y = CountCells;
    BufferCoord.X = 0;
    BufferCoord.Y = 0;
    ReadConsoleOutput(
        GetStdHandle(STD_ERROR_HANDLE),
        CharInfo,
        BufferSize,
        BufferCoord,
        &ReadRegion);

    p = CharInfo;
    while (CountCells--) {
        *ScreenCell++ = p->Char.AsciiChar;
        *ScreenCell++ = (BYTE) p->Attributes;
        p++;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ClearLine
//
//----------------------------------------------------------------------------

VOID
ClearLine(VOID)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    COORD Coord;
    DWORD   NumWritten;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    Coord.Y = csbi.dwCursorPosition.Y;
    Coord.X = csbi.dwCursorPosition.X = 0;
    FillConsoleOutputCharacter(
            GetStdHandle(STD_ERROR_HANDLE),
            ' ',
            csbi.dwSize.X,
            csbi.dwCursorPosition,
            &NumWritten);

    SetConsoleCursorPosition(GetStdHandle(STD_ERROR_HANDLE), Coord);
    fLineCleared = TRUE;
}


// PipeSpawn variables.  We can get away with one copy per thread.

__declspec(thread) HANDLE ProcHandle;
__declspec(thread) FILE *pstream;

//+---------------------------------------------------------------------------
//
//  Function:   PipeSpawn (similar to _popen)
//
//----------------------------------------------------------------------------

FILE *
PipeSpawn (
    const CHAR *cmdstring
    )
{
    int PipeHandle[2];
    HANDLE WriteHandle, ErrorHandle;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL Status;
    char CmdLine[1024];

    if (cmdstring == NULL)
        return (NULL);

    // Open the pipe where we'll collect the output.

    _pipe(PipeHandle, 1024, _O_BINARY|_O_NOINHERIT);

    DuplicateHandle(GetCurrentProcess(),
                    (HANDLE)_get_osfhandle((LONG)PipeHandle[1]),
                    GetCurrentProcess(),
                    &WriteHandle,
                    0L,
                    TRUE,
                    DUPLICATE_SAME_ACCESS);

    DuplicateHandle(GetCurrentProcess(),
                    (HANDLE)_get_osfhandle((LONG)PipeHandle[1]),
                    GetCurrentProcess(),
                    &ErrorHandle,
                    0L,
                    TRUE,
                    DUPLICATE_SAME_ACCESS);

    _close(PipeHandle[1]);

    pstream = _fdopen(PipeHandle[0], "rb" );
    if (!pstream) {
        CloseHandle(WriteHandle);
        CloseHandle(ErrorHandle);
        _close(PipeHandle[0]);
        return(NULL);
    }

    strcpy(CmdLine, cmdexe);
    strcat(CmdLine, " /c ");
    strcat(CmdLine, cmdstring);

    memset(&StartupInfo, 0, sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);

    StartupInfo.hStdOutput = WriteHandle;
    StartupInfo.hStdError = ErrorHandle;
    StartupInfo.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    StartupInfo.dwFlags = STARTF_USESTDHANDLES;

    memset(&ProcessInformation, 0, sizeof(PROCESS_INFORMATION));

    // And start the process.

    Status = CreateProcess(cmdexe, CmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &StartupInfo, &ProcessInformation);

    CloseHandle(WriteHandle);
    CloseHandle(ErrorHandle);
    CloseHandle(ProcessInformation.hThread);

    if (!Status) {
        fclose(pstream);        // This will close the read handle
        pstream = NULL;
        ProcHandle = NULL;
    } else {
        ProcHandle = ProcessInformation.hProcess;
    }

    return(pstream);
}


//+---------------------------------------------------------------------------
//
//  Function:   PipeSpawnClose (similar to _pclose)
//
//----------------------------------------------------------------------------

DWORD
PipeSpawnClose (
    FILE *pstream
    )
{
    DWORD retval = 0;   /* return value (to caller) */

    if ( pstream == NULL) {
        return retval;
    }

    (void)fclose(pstream);

    if ( WaitForSingleObject(ProcHandle, (DWORD) -1L) == 0) {
        GetExitCodeProcess(ProcHandle, &retval);
    }
    CloseHandle(ProcHandle);

    return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\build\build.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

--*/

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       build.h
//
//  Contents:   Main Include file for build.exe
//
//  History:    16-May-89     SteveWo  Created
//              26-Jul-94     LyleC    Cleanup/Add Support for Pass0
//              05-Dec-00     sbonev   See SD changelist 2317
//
//----------------------------------------------------------------------------

#include <assert.h>
#include <process.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <malloc.h>
#include <errno.h>
#include <ctype.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <io.h>
#include <conio.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <windows.h>

#define UINT DWORD
#define HDIR HANDLE


VOID
ClearLine(VOID);


//
// Types and Constant Definitions
//

#if DBG
#define DEBUG_1 (fDebug & 1)
#else
#define DEBUG_1 FALSE
#endif

BOOL fDebug;
#define DEBUG_2 (fDebug & 3)
#define DEBUG_4 (fDebug & 4)

//
// Target specific dirs file name.
//

extern LPSTR pszTargetDirs;

#define MAX_TARGET_MACHINES 4

typedef struct _TARGET_MACHINE_INFO {
    UCHAR SourceSubDirMask;     // TMIDIR_I386
    LPSTR Description;          // "i386"
    LPSTR Switch;               // "-386"
    LPSTR MakeVariable;         // "386=1"
    LPSTR SourceVariable;       // "i386_SOURCES"
    LPSTR ObjectVariable;       // "386_OBJECTS"
    LPSTR AssociateDirectory;   // "i386"
    LPSTR SourceDirectory;      // "i386"
    LPSTR TargetDirs;           // "i386dirs"
    LPSTR ObjectDirectory[2];   // "i386" -- initialize only first entry
    ULONG DirIncludeMask;       // Platform/Group/etc.
    LPSTR ObjectMacro;          // don't initialize

} TARGET_MACHINE_INFO, *PTARGET_MACHINE_INFO;

#define DIR_INCLUDE_NONE     0x00000000
#define DIR_INCLUDE_X86      0x00000001
#define DIR_INCLUDE_ALPHA    0x00000002
#define DIR_INCLUDE_IA64     0x00000004
#define DIR_INCLUDE_ALPHA64  0x00000008
#define DIR_INCLUDE_WIN32    0x00000010
#define DIR_INCLUDE_WIN64    0x00000020
#define DIR_INCLUDE_RISC     0x00000040
#define DIR_INCLUDE_ALL      0xffffffff

// It's possible to have SOURCES= entries of the following forms:
//      entry           SourceSubDirMask
//      -----           ----------------
//      foo.c                    0
//      i386\foo.c               1
//      alpha64\foo.c            2
//      alpha\foo.c              4
//      unused - free            8
//      ia64\foo.c              10
//      ..\foo.c                80
//      ..\i386\foo.c           81
//      ..\alpha64\foo.c        82
//      ..\alpha\foo.c          84
//      unused - free           88
//      ..\ia64\foo.c           90

#define TMIDIR_I386     0x0001
#define TMIDIR_ALPHA64  0x0002
#define TMIDIR_ALPHA    0x0004
#define TMIDIR_IA64     0x0010
#define TMIDIR_PARENT   0x0080  // or'd in with above bits


#define SIG_DIRREC      0x44644464      // "DdDd"

#ifdef SIG_DIRREC
#define SIG_FILEREC     0x46664666      // "FfFf"
#define SIG_INCLUDEREC  0x49694969      // "IiIi"
#define SIG_SOURCEREC   0x53735373      // "SsSs"
#define SigCheck(s)     s
#else
#define SigCheck(s)
#endif

#define AssertDir(pdr) \
        SigCheck(assert((pdr) != NULL && (pdr)->Sig == SIG_DIRREC))

#define AssertOptionalDir(pdr) \
        SigCheck(assert((pdr) == NULL || (pdr)->Sig == SIG_DIRREC))

#define AssertFile(pfr) \
        SigCheck(assert((pfr) != NULL && (pfr)->Sig == SIG_FILEREC))

#define AssertOptionalFile(pfr) \
        SigCheck(assert((pfr) == NULL || (pfr)->Sig == SIG_FILEREC))

#define AssertInclude(pir) \
        SigCheck(assert((pir) != NULL && (pir)->Sig == SIG_INCLUDEREC))

#define AssertOptionalInclude(pir) \
        SigCheck(assert((pir) == NULL || (pir)->Sig == SIG_INCLUDEREC))

#define AssertSource(psr) \
        SigCheck(assert((psr) != NULL && (psr)->Sig == SIG_SOURCEREC))

#define AssertOptionalSource(psr) \
        SigCheck(assert((psr) == NULL || (psr)->Sig == SIG_SOURCEREC))

//
// Information about source directories is stored an in-memory database.
// The information is saved on disk by writing the contents of the database
// to "build.dat".  It is reloaded from disk for subsequent invocations,
// and re-written only when it has been updated.
//


typedef struct _INCLUDEREC {
    SigCheck(ULONG Sig;)
    struct _INCLUDEREC *Next;     // static list describes original arcs
    struct _INCLUDEREC *NextTree; // dynamic list -- cycles are collapsed
    struct _FILEREC *pfrCycleRoot;
    struct _FILEREC *pfrInclude;
    USHORT Version;
    USHORT IncFlags;
    char Name[1];
} INCLUDEREC, *PINCLUDEREC;


#define INCLUDEDB_LOCAL         0x0001  // include "foo.h"
#define INCLUDEDB_POST_HDRSTOP  0x0002  // appears after #pragma hdrstop
#define INCLUDEDB_MISSING       0x0400  // include file was once missing
#define INCLUDEDB_GLOBAL        0x0800  // include file is in global directory
#define INCLUDEDB_SNAPPED       0x1000  // include file snapped
#define INCLUDEDB_CYCLEALLOC    0x2000  // allocated to flatten cycle
#define INCLUDEDB_CYCLEROOT     0x4000  // moved to root file to flatten cycle
#define INCLUDEDB_CYCLEORPHAN   0x8000  // orphaned to flatten cycle

// Flags preserved when loading build.dat:

#define INCLUDEDB_DBPRESERVE    (INCLUDEDB_LOCAL | INCLUDEDB_POST_HDRSTOP)



#define IsCleanTree(pir)        \
  ((pir)->NextTree == NULL &&   \
   ((pir)->IncFlags &           \
    (INCLUDEDB_CYCLEALLOC | INCLUDEDB_CYCLEROOT | INCLUDEDB_CYCLEORPHAN)) == 0)


#if DBG
VOID AssertCleanTree(INCLUDEREC *pir, OPTIONAL struct _FILEREC *pfr);
#else
#define AssertCleanTree(pir, pfr)       assert(IsCleanTree(pir))
#endif

//
// Make file description structure definition.
//

typedef struct _FILEDESC {
    LPSTR   pszPattern;         //  pattern to match file name
    LPSTR   pszCommentToEOL;    //  comment-to-eol string
    BOOL    fNeedFileRec;       //  TRUE => file needs a file record
    ULONG   FileFlags;          //  flags to be set in file record
    ULONG   DirFlags;           //  flags to be set in directory record
} FILEDESC;

extern FILEDESC FileDesc[];

typedef struct _FILEREC {
    SigCheck(ULONG Sig;)
    struct _FILEREC *Next;
    struct _DIRREC *Dir;
    INCLUDEREC *IncludeFiles;       // static list describes original arcs
    INCLUDEREC *IncludeFilesTree;   // dynamic list -- cycles are collapsed
    struct _FILEREC *NewestDependency;
    LPSTR  pszCommentToEOL;         // comment-to-eol string in source
    ULONG  DateTime;
    ULONG  DateTimeTree;            // Newest DateTime for included tree
    ULONG  TotalSourceLines;        // line count in all included files
    ULONG  FileFlags;
    ULONG  SourceLines;
    USHORT Attr;
    USHORT SubDirIndex;
    USHORT Version;
    USHORT GlobalSequence;          // Sequence number for dynamic include tree
    USHORT LocalSequence;           // Sequence number for dynamic include tree
    USHORT idScan;                  // id used for detecting multiple inclusion
    USHORT CheckSum;                // Name checksum
    UCHAR fDependActive;            // TRUE-> we're scanning at or below this file.
    char Name[1];
} FILEREC, *PFILEREC;

#define MAKE_DATE_TIME( date, time )    \
    ((ULONG)(((USHORT)(time)) | ((ULONG)((USHORT)(date))) << 16))

#define FILEDB_SOURCE           0x00000001
#define FILEDB_DIR              0x00000002
#define FILEDB_HEADER           0x00000004
#define FILEDB_ASM              0x00000008
#define FILEDB_MASM             0x00000010
#define FILEDB_RC               0x00000020
#define FILEDB_C                0x00000040
#define FILEDB_MIDL             0x00000080
#define FILEDB_ASN              0x00000100
#define FILEDB_JAVA             0x00000200
#define FILEDB_MOF              0x00000400
#define FILEDB_VBP              0x00000800
#define FILEDB_SCANNED          0x00001000
#define FILEDB_OBJECTS_LIST     0x00002000
#define FILEDB_FILE_MISSING     0x00004000
#define FILEDB_MKTYPLIB         0x00008000
#define FILEDB_MULTIPLEPASS     0x00010000
#define FILEDB_PASS0            0x00020000

// Flags preserved when loading build.dat:

#define FILEDB_DBPRESERVE       (FILEDB_SOURCE |       \
                                 FILEDB_DIR |          \
                                 FILEDB_HEADER |       \
                                 FILEDB_ASM |          \
                                 FILEDB_MASM |         \
                                 FILEDB_RC |           \
                                 FILEDB_C |            \
                                 FILEDB_MIDL |         \
                                 FILEDB_ASN |          \
                                 FILEDB_JAVA |         \
                                 FILEDB_MOF |          \
                                 FILEDB_VBP |          \
                                 FILEDB_MKTYPLIB |     \
                                 FILEDB_MULTIPLEPASS | \
                                 FILEDB_PASS0)


typedef struct _SOURCEREC {
    SigCheck(ULONG Sig;)
    struct _SOURCEREC *psrNext;
    FILEREC *pfrSource;
    UCHAR SourceSubDirMask;
    UCHAR SrcFlags;
} SOURCEREC;

#define SOURCEDB_SOURCES_LIST           0x01
#define SOURCEDB_FILE_MISSING           0x02
#define SOURCEDB_PCH                    0x04
#define SOURCEDB_OUT_OF_DATE            0x08
#define SOURCEDB_COMPILE_NEEDED         0x10


typedef struct _DIRSUP {
    LPSTR TestType;
    LPSTR LocalIncludePath;
    LPSTR UserIncludePath;
    LPSTR LastIncludePath;
    LPSTR PchIncludeDir;
    LPSTR PchInclude;
    LPSTR PchTargetDir;
    LPSTR PchTarget;
    LPSTR PassZeroHdrDir;
    LPSTR PassZeroSrcDir1;
    LPSTR PassZeroSrcDir2;
    LPSTR ConditionalIncludes;
    ULONG DateTimeSources;
    ULONG IdlType;
    ULONG fNoTarget;
    LPSTR SourcesVariables[MAX_TARGET_MACHINES + 1];
    SOURCEREC *psrSourcesList[MAX_TARGET_MACHINES + 1];
} DIRSUP;


typedef struct _DIRREC {
    SigCheck(ULONG Sig;)
    struct _DIRREC *Next;
    DIRSUP *pds;                 // Used to preserve info from pass zero
    PFILEREC Files;
    LPSTR TargetPath;
    LPSTR TargetPathLib;
    LPSTR TargetName;
    LPSTR TargetExt;
    LPSTR KernelTest;
    LPSTR UserAppls;
    LPSTR UserTests;
    LPSTR NTTargetFile0;
    LPSTR Pch;
    LPSTR PchObj;
    LONG SourceLinesToCompile;
    LONG PassZeroLines;
    ULONG DirFlags;
    ULONG RecurseLevel;
    USHORT FindCount;
    USHORT CountSubDirs;
    SHORT CountOfFilesToCompile;
    SHORT CountOfPassZeroFiles;
    USHORT CheckSum;                // Name checksum
    char Name[1];
} DIRREC, *PDIRREC;


#define DIRDB_SOURCES           0x00000001
#define DIRDB_DIRS              0x00000002
#define DIRDB_MAKEFILE          0x00000004
#define DIRDB_MAKEFIL0          0x00000008
#define DIRDB_TARGETFILE0       0x00000010
#define DIRDB_TARGETFILES       0x00000020
#define DIRDB_RESOURCE          0x00000040
#define DIRDB_PASS0             0x00000080

#define DIRDB_SOURCES_SET       0x00000100
#define DIRDB_FULL_DEBUG        0x00000200
#define DIRDB_CHICAGO_INCLUDES  0x00000800

#define DIRDB_NEW               0x00001000
#define DIRDB_SCANNED           0x00002000
#define DIRDB_SHOWN             0x00004000
#define DIRDB_GLOBAL_INCLUDES   0x00008000

#define DIRDB_SYNCHRONIZE_BLOCK 0x00010000
#define DIRDB_SYNCHRONIZE_DRAIN 0x00020000
#define DIRDB_COMPILENEEDED     0x00040000
#define DIRDB_COMPILEERRORS     0x00080000

#define DIRDB_SOURCESREAD       0x00100000
#define DIRDB_DLLTARGET         0x00200000
#define DIRDB_LINKNEEDED        0x00400000
#define DIRDB_FORCELINK         0x00800000
#define DIRDB_PASS0NEEDED       0x01000000
#define DIRDB_MAKEFIL1          0x02000000
#define DIRDB_CHECKED_ALT_DIR   0x04000000

#define DIRDB_IDLTYPERPC        0x08000000

// Flags preserved when loading build.dat:

#define DIRDB_DBPRESERVE        0



typedef struct _TARGET {
    FILEREC *pfrCompiland;
    DIRREC *pdrBuild;
    LPSTR pszSourceDirectory;
    LPSTR ConditionalIncludes;
    ULONG DateTime;
    ULONG DirFlags;
    char Name[1];
} TARGET, *PTARGET;


#define BUILD_VERSION           0x0420
#define DBMASTER_NAME           "build.dat"
#define DB_MAX_PATH_LENGTH      256

// If you change or add any values to this enum,
// also fix MemTab in buildutl.c:

typedef enum _MemType {
    MT_TOTALS = 0,
    MT_UNKNOWN,

    MT_CHILDDATA,
    MT_CMDSTRING,
    MT_DIRDB,
    MT_DIRSUP,
    MT_DIRPATH,
    MT_DIRSTRING,
    MT_EVENTHANDLES,
    MT_FILEDB,
    MT_FILEREADBUF,
    MT_FRBSTRING,
    MT_INCLUDEDB,
    MT_IOBUFFER,
    MT_MACRO,
    MT_SOURCEDB,
    MT_TARGET,
    MT_THREADFILTER,
    MT_THREADHANDLES,
    MT_THREADSTATE,
    MT_XMLTHREADSTATE,
    MT_PXMLTHREADSTATE,

    MT_INVALID = 255,
} MemType;

struct _THREADSTATE;

typedef BOOL (*FILTERPROC)(struct _THREADSTATE *ThreadState, LPSTR p);

typedef struct _BUILDMETRICS {
    UINT NumberCompileWarnings;
    UINT NumberCompileErrors;
    UINT NumberCompiles;
    UINT NumberLibraries;
    UINT NumberLibraryWarnings;
    UINT NumberLibraryErrors;
    UINT NumberLinks;
    UINT NumberLinkWarnings;
    UINT NumberLinkErrors;
    UINT NumberBSCMakes;
    UINT NumberBSCWarnings;
    UINT NumberBSCErrors;
    UINT NumberVSToolErrors;
    UINT NumberVSToolWarnings;

// XML support and fragments
    UINT NumberDirActions;
    UINT NumberActWarnings;
    UINT NumberActErrors;
} BUILDMETRICS, *PBUILDMETRICS;

typedef struct _THREADSTATE {
    USHORT cRowTotal;
    USHORT cColTotal;
    BOOL IsStdErrTty;
    FILE *ChildOutput;
    UINT ChildState;
    UINT ChildFlags;
    LPSTR ChildTarget;
    UINT LinesToIgnore;
    FILTERPROC FilterProc;
    ULONG ThreadIndex;
    ULONG XMLThreadIndex;
    CHAR UndefinedId[ DB_MAX_PATH_LENGTH ];
    CHAR ChildCurrentDirectory[ DB_MAX_PATH_LENGTH ];
    CHAR ChildCurrentFile[ DB_MAX_PATH_LENGTH ];
    DIRREC *CompileDirDB;
    BUILDMETRICS BuildMetrics;
} THREADSTATE, *PTHREADSTATE;

//
// Global Data (uninit will always be FALSE)
//

BOOL fUsage;                     // Set when usage message is to be displayed
BOOL fStatus;                    // Set by -s and -S options
BOOL fStatusTree;                // Set by -S option
BOOL fShowTree;                  // Set by -t and -T options
BOOL fShowTreeIncludes;          // Set by -T option
BOOL fClean;                     // Set by -c option
BOOL fCleanLibs;                 // Set by -C option
BOOL fCleanRestart;              // Set by -r option
BOOL fRestartClean;              // Set if -c and -r were both given
BOOL fRestartCleanLibs;          // Set if -C and -r were both given
BOOL fPause;                     // Set by -p option
BOOL fParallel;                  // Set on a multiprocessor machine or by -M
BOOL fPrintElapsed;              // Set by -P option
BOOL fQuery;                     // Set by -q option
BOOL fQuicky;                    // Set by -z and -Z options
BOOL fQuickZero;                 // Set by -3
BOOL fSemiQuicky;                // Set by -Z option
BOOL fShowOutOfDateFiles;        // Set by -o option
BOOL fSyncLink;                  // Set by -a option
BOOL fForce;                     // Set by -f option
BOOL fEnableVersionCheck;        // Set by -v option
BOOL fSilentDependencies;        // Set by -i option
BOOL fKeep;                      // Set by -k option
BOOL fCompileOnly;               // Set by -L option
BOOL fLinkOnly;                  // Set by -l option
BOOL fErrorLog;                  // Set by -e option
BOOL fGenerateObjectsDotMacOnly; // Set by -O option
BOOL fShowWarningsOnScreen;      // Set by -w option
BOOL fNoisyScan;                 // Set by -y option
BOOL fFullErrors;                // Set by -b option
BOOL fWhyBuild;                  // Set by -why option
BOOL fChicagoProduct;            // Set if CHICAGO_PRODUCT is set in environment
BOOL fLineCleared;               // Current line on screen clear?
BOOL fPassZero;                  // Indicates we've found pass zero dirs
BOOL fFirstScan;                 // Indicates this is the first scan
BOOL fAlwaysPrintFullPath;       // Set by -F option
BOOL fTargetDirs;                // Set by -g option
BOOL fAlwaysKeepLogfile;         // Set by -E option
BOOL fShowUnusedDirs;            // Set by -u option
BOOL fCheckIncludePaths;         // Set by -# option
BOOL fColorConsole;              // set by -D option
BOOL fThreadIndex;               // Set by -n option
BOOL fErrorBaseline;             // Set by -B option
BOOL fPassZeroOnly;              // Set by -0 option
BOOL fXMLOutput;                 // Set by -X option
BOOL fXMLVerboseOutput;          // Set by -Xv option
BOOL fXMLFragment;               // Set bu -Xf option

#define MAX_INCLUDE_PATTERNS 32

LPSTR AcceptableIncludePatternList[ MAX_INCLUDE_PATTERNS + 1 ];
LPSTR UnacceptableIncludePatternList[ MAX_INCLUDE_PATTERNS + 1 ];

LPSTR MakeProgram;
char MakeParameters[ 512 ];
LPSTR MakeParametersTail;
char MakeTargets[ 256 ];
char RestartDir[ 256 ];
char NtRoot[ 256 ];
char DbMasterName[ 256 ];
char szNewLine[];

char BaselinePathName[DB_MAX_PATH_LENGTH];    // The file name for -B
BOOL bBaselineFailure;              // Indicates if there is a build failure that is not in the baseline file
VOID* pvBaselineContent;            // The content of the baseline file
DWORD cbBaselineContentSize;        // The size of the baseline file

char XMLFragmentDirectory[DB_MAX_PATH_LENGTH];  // The path for -Xf

char *pszIncOak;
char *pszIncDdk;
char *pszIncWdm;
char *pszIncSdk;
char *pszIncMfc;
char *pszIncCrt;
char *pszIncAtl;
char *pszIncPri;

char *szBuildTag;
char *pszObjDir;
char *pszObjDirSlash;
char *pszObjDirSlashStar;
BOOL fCheckedBuild;
ULONG iObjectDir;
extern ULONG NumberProcesses;
CRITICAL_SECTION TTYCriticalSection;
CRITICAL_SECTION XMLCriticalSection;

CHAR const *cmdexe;

LONG TotalFilesToCompile;
LONG TotalFilesCompiled;

LONG TotalLinesToCompile;
LONG TotalLinesCompiled;

ULONG ElapsedCompileTime;
DIRREC *CurrentCompileDirDB;

// Fixed length arrays...

UINT CountTargetMachines;
TARGET_MACHINE_INFO *TargetMachines[MAX_TARGET_MACHINES];
TARGET_MACHINE_INFO *PossibleTargetMachines[MAX_TARGET_MACHINES];
TARGET_MACHINE_INFO i386TargetMachine;
TARGET_MACHINE_INFO Alpha64TargetMachine;
TARGET_MACHINE_INFO AlphaTargetMachine;
TARGET_MACHINE_INFO ia64TargetMachine;
UINT TargetToPossibleTarget[MAX_TARGET_MACHINES];


#define MAX_OPTIONAL_DIRECTORIES        256
UINT CountOptionalDirs;
LPSTR OptionalDirs[MAX_OPTIONAL_DIRECTORIES];
BOOLEAN OptionalDirsUsed[MAX_OPTIONAL_DIRECTORIES];


#define MAX_EXCLUDE_DIRECTORIES         MAX_OPTIONAL_DIRECTORIES
UINT CountExcludeDirs;
LPSTR ExcludeDirs[MAX_EXCLUDE_DIRECTORIES];
BOOLEAN ExcludeDirsUsed[MAX_OPTIONAL_DIRECTORIES];


#define MAX_FULL_DEBUG_DIRECTORIES      MAX_OPTIONAL_DIRECTORIES
UINT CountFullDebugDirs;
LPSTR FullDebugDirectories[MAX_FULL_DEBUG_DIRECTORIES];
BOOLEAN FullDebugDirsUsed[MAX_OPTIONAL_DIRECTORIES];


#define MAX_EXCLUDE_INCS                128
UINT CountExcludeIncs;
LPSTR ExcludeIncs[MAX_EXCLUDE_INCS];


#define MAX_INCLUDE_DIRECTORIES         128
UINT CountIncludeDirs;
UINT CountSystemIncludeDirs;
DIRREC *IncludeDirs[MAX_INCLUDE_DIRECTORIES];



#define MAX_BUILD_DIRECTORIES           4096

UINT CountPassZeroDirs;
DIRREC *PassZeroDirs[MAX_BUILD_DIRECTORIES];

UINT CountCompileDirs;
DIRREC *CompileDirs[MAX_BUILD_DIRECTORIES];

UINT CountLinkDirs;
DIRREC *LinkDirs[MAX_BUILD_DIRECTORIES];

UINT CountShowDirs;
DIRREC *ShowDirs[MAX_BUILD_DIRECTORIES];



DIRREC *AllDirs;
CHAR CurrentDirectory[DB_MAX_PATH_LENGTH];

BOOL AllDirsInitialized;
BOOL AllDirsModified;

USHORT GlobalSequence;
USHORT LocalSequence;

BOOLEAN fConsoleInitialized;
DWORD NewConsoleMode;

LPSTR BuildDefault;
LPSTR BuildParameters;

LPSTR SystemIncludeEnv;
LPSTR LocalIncludeEnv;

LPSTR BigBuf;
UINT BigBufSize;

UINT RecurseLevel;

FILE *LogFile;
FILE *WrnFile;
FILE *ErrFile;
FILE *IPGScriptFile;
FILE *IncFile;
FILE *XMLFile;

BUILDMETRICS PassMetrics;
BUILDMETRICS BuildMetrics;
BUILDMETRICS RunningTotals;

char szAsterisks[];
ULONG BuildStartTime;

VOID ReportDirsUsage(VOID);

VOID SetObjDir(BOOL fAlternate);

//
// Data Base functions defined in builddb.c
//

PDIRREC
LoadDirDB(LPSTR DirName);

#if DBG
VOID
PrintAllDirs(VOID);
#endif

VOID
PrintSourceDBList(SOURCEREC *psr, int i);

VOID
PrintFileDB(FILE *pf, FILEREC *pfr, int DetailLevel);

VOID
PrintDirDB(DIRREC *pdr, int DetailLevel);

FILEREC *
FindSourceFileDB(DIRREC *pdr, LPSTR pszRelPath, DIRREC **ppdr);

DIRREC *
FindSourceDirDB(
    LPSTR pszDir,               // directory
    LPSTR pszRelPath,           // relative path
    BOOL fTruncateFileName);    // TRUE: drop last component of path

SOURCEREC *
FindSourceDB(
    SOURCEREC *psr,
    FILEREC *pfr);

SOURCEREC *
InsertSourceDB(
    SOURCEREC **ppsrNext,
    FILEREC *pfr,
    UCHAR SubDirMask,
    UCHAR SrcFlags);

VOID
FreeSourceDB(SOURCEREC **ppsr);

VOID
UnsnapIncludeFiles(FILEREC *pfr, BOOL fUnsnapGlobal);

VOID
UnsnapAllDirectories(VOID);

VOID
FreeAllDirs(VOID);

PFILEREC
LookupFileDB(
    PDIRREC DirDB,
    LPSTR FileName);


PFILEREC
InsertFileDB(
    PDIRREC DirDB,
    LPSTR FileName,
    ULONG DateTime,
    USHORT Attr,
    ULONG  FileFlags);

VOID
DeleteUnscannedFiles(PDIRREC DirDB);

PINCLUDEREC
InsertIncludeDB(
    PFILEREC FileDB,
    LPSTR IncludeFileName,
    USHORT IncFlags);

VOID
LinkToCycleRoot(INCLUDEREC *pir, FILEREC *pfrRoot);

VOID
RemoveFromCycleRoot(INCLUDEREC *pir, FILEREC *pfrRoot);

VOID
MergeIncludeFiles(FILEREC *pfr, INCLUDEREC *pirList, FILEREC *pfrRoot);

VOID
MarkIncludeFileRecords(PFILEREC FileDB);

VOID
DeleteIncludeFileRecords(PFILEREC FileDB);

PFILEREC
FindIncludeFileDB(
    FILEREC *pfrSource,
    FILEREC *pfrCompiland,
    DIRREC *pdrBuild,
    LPSTR pszSourceDirectory,
    INCLUDEREC *IncludeDB);

BOOL
SaveMasterDB(VOID);

void
LoadMasterDB(VOID);

PDIRREC
LoadMasterDirDB(LPSTR s);

PFILEREC
LoadMasterFileDB(LPSTR s);

PINCLUDEREC
LoadMasterIncludeDB(LPSTR s);


//
// Scanning functions defined in buildscn.c
//

VOID
AddIncludeDir(DIRREC *pdr, UINT *pui);

VOID
AddShowDir(DIRREC *pdr);

VOID
ScanIncludeDir(LPSTR IncludeDir);

VOID
ScanIncludeEnv(LPSTR IncludeEnv);

PDIRREC
ScanDirectory(LPSTR DirName);

BOOL
ScanFile(PFILEREC FileDB);


//
// Functions defined in buildmak.c
//

VOID
ScanSourceDirectories(LPSTR DirName);

VOID
CompilePassZeroDirectories(VOID);

VOID
CompileSourceDirectories(VOID);

VOID
LinkSourceDirectories(VOID);


VOID
FreeDirSupData(DIRSUP *pds);

VOID
FreeDirData(DIRREC *pdr);

BOOL
CheckDependencies(
    PTARGET Target,
    FILEREC *FileDB,
    BOOL CheckDate,
    FILEREC **ppFileDBRoot);

BOOL
CreateBuildDirectory(LPSTR Name);

VOID
CreatedBuildFile(LPSTR DirName, LPSTR FileName);

VOID
GenerateObjectsDotMac(DIRREC *DirDB, DIRSUP *pds, ULONG DateTimeSources);

VOID
ExpandObjAsterisk(
    LPSTR pbuf,
    LPSTR pszpath,
    LPSTR *ppszObjectDirectory);

//
// Build -# functions defined in buildinc.c
//

LPCTSTR
FindCountedSequenceInString(
    IN LPCTSTR String,
    IN LPCTSTR Sequence,
    IN DWORD   Length);

BOOL
DoesInstanceMatchPattern(
    IN LPCTSTR Instance,
    IN LPCTSTR Pattern);

LPSTR
CombinePaths(
    IN  LPCSTR ParentPath,
    IN  LPCSTR ChildPath,
    OUT LPSTR  TargetPath);

VOID
CreateRelativePath(
    IN  LPCSTR SourceAbsName,
    IN  LPCSTR TargetAbsName,
    OUT LPSTR  RelativePath);

BOOL
ShouldWarnInclude(
    IN LPCSTR CompilandFullName,
    IN LPCSTR IncludeeFullName);

VOID
CheckIncludeForWarning(
    IN LPCSTR CompilandDir,
    IN LPCSTR CompilandName,
    IN LPCSTR IncluderDir,
    IN LPCSTR IncluderName,
    IN LPCSTR IncludeeDir,
    IN LPCSTR IncludeeName);

//
// Utility functions defined in buildutl.c
//

VOID
AllocMem(UINT cb, VOID **ppv, MemType mt);

VOID
FreeMem(VOID **ppv, MemType mt);

VOID
ReportMemoryUsage(VOID);


BOOL
MyOpenFile(
    LPSTR DirName,
    LPSTR FileName,
    LPSTR Access,
    FILE **Stream,
    BOOL fBufferedIO);

BOOL
OpenFilePush(
    LPSTR pszdir,
    LPSTR pszfile,
    LPSTR pszCommentToEOL,
    FILE **ppf
    );

BOOL
SetupReadFile(LPSTR pszdir, LPSTR pszfile, LPSTR pszCommentToEOL,
              FILE **ppf);

ULONG
CloseReadFile(UINT *pcline);

LPSTR
ReadLine(FILE *pf);

UINT
ProbeFile(
    LPSTR DirName,
    LPSTR FileName);

BOOL
EnsureDirectoriesExist(
    LPSTR DirName);

ULONG
DateTimeFile(
    LPSTR DirName,
    LPSTR FileName);

ULONG
DateTimeFile2(
    LPSTR DirName,
    LPSTR FileName);

ULONG (*pDateTimeFile)(LPSTR, LPSTR);

BOOL (WINAPI * pGetFileAttributesExA)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

BOOL
DeleteSingleFile(
    LPSTR DirName,
    LPSTR FileName,
    BOOL QuietFlag);

BOOL
DeleteMultipleFiles(
    LPSTR DirName,
    LPSTR FilePattern);

BOOL
CloseOrDeleteFile(
    FILE **Stream,
    LPSTR FileName,
    ULONG SizeThreshold);

LPSTR
PushCurrentDirectory(LPSTR NewCurrentDirectory);

VOID
PopCurrentDirectory(LPSTR OldCurrentDirectory);

UINT
ExecuteProgram(
    LPSTR ProgramName,
    LPSTR CommandLine,
    LPSTR MoreCommandLine,
    BOOL MustBeSynchronous,
    LPCSTR XMLDir,
    LPCSTR XMLAction);

VOID
WaitForParallelThreads(VOID);


BOOL
CanonicalizePathName(
    LPSTR SourcePath,
    UINT Action,
    LPSTR FullPath);


#define CANONICALIZE_ONLY 0
#define CANONICALIZE_FILE 1
#define CANONICALIZE_DIR  2

LPSTR
FormatPathName(
    LPSTR DirName,
    LPSTR FileName);

#if DBG
VOID
AssertPathString(LPSTR pszPath);
#else
#define AssertPathString(p)
#endif

LPSTR
AppendString(
    LPSTR Destination,
    LPSTR Source,
    BOOL PrefixWithSpace);

LPSTR
CopyString(LPSTR Destination, LPSTR Source, BOOL fPath);

VOID
MakeString(
    LPSTR *Destination,
    LPSTR Source,
    BOOL fPath,
    MemType mt);

VOID
FreeString(LPSTR *Source, MemType mt);

LPSTR
FormatNumber(ULONG Number);

LPSTR
FormatTime(ULONG Seconds);

BOOL AToX(LPSTR *pp, ULONG *pul);
BOOL AToD(LPSTR *pp, ULONG *pul);
VOID _cdecl LogMsg(char *pszfmt, ...);
VOID _cdecl BuildMsg(char *pszfmt, ...);
VOID _cdecl BuildMsgRaw(char *pszfmt, ...);
VOID _cdecl BuildError(char *pszfmt, ...);
VOID _cdecl BuildErrorRaw(char *pszfmt, ...);

VOID*
memfind(VOID* pvWhere, DWORD cbWhere, VOID* pvWhat, DWORD cbWhat);

//
// XML logging
//

UINT NumberPasses;
DWORD XMLStartTicks;

#define XML_THREAD_BUFFER_SIZE  (2*1024*1024)
#define XML_LOCAL_BUFFER_SIZE   4096

#define XML_SCHEMA "buildschema.xml"

// general purpose buffer 
// initially used to hold the command line
char szXMLBuffer[XML_LOCAL_BUFFER_SIZE];

typedef struct _XMLTHREADSTATE {
    BYTE XMLBuffer[XML_THREAD_BUFFER_SIZE];
    long iXMLBufferPos;
    long iXMLBufferLen;
    long iXMLFileStart;
    BOOL fXMLInAction;      // indicates if the thread has opened action tag
} XMLTHREADSTATE, *PXMLTHREADSTATE;

PXMLTHREADSTATE* PXMLThreadStates;
PXMLTHREADSTATE PXMLGlobalState;

// Initializes the XML structures
BOOL
XMLInit(VOID);

// Frees the allocated memory
VOID
XMLUnInit(VOID);

// Prepares XML buffer fot the thread
VOID
XMLThreadInitBuffer(PTHREADSTATE ThreadState);

// writes into the thread's block and then all other threads' blocks
VOID _cdecl
XMLThreadWrite(PTHREADSTATE ThreadState, LPCSTR pszFmt, ...);

// opens tag in the thread's block
VOID _cdecl
XMLThreadOpenTag(PTHREADSTATE ThreadState, LPCSTR pszTag, LPCSTR pszFmt, ...);

// closes the last open tag; the argument is for verification only
VOID
XMLThreadCloseTag(PTHREADSTATE ThreadState, LPCSTR pszTag);

// writes out completely the thread's block and releases it
VOID
XMLThreadReleaseBuffer(PTHREADSTATE ThreadState);

// writes into the global block. It is restricted to not have any threads open
VOID _cdecl
XMLGlobalWrite(LPCSTR pszFmt, ...);

// opens tag in the global block
VOID _cdecl
XMLGlobalOpenTag(LPCSTR pszTag, LPCSTR pszFmt, ...);

// closes the last open tag
VOID
XMLGlobalCloseTag();

VOID
XMLUpdateEndTag(BOOL fCompleted);

LPSTR
XMLEncodeBuiltInEntities(LPSTR pszString, DWORD cbStringSize);

LPSTR
XMLEncodeBuiltInEntitiesCopy(LPSTR pszString, LPSTR pszTarget);

LPSTR
XMLBuildMetricsString(PBUILDMETRICS Metrics);

// XML fragment
VOID _cdecl
XMLWriteFragmentFile(LPCSTR pszBaseFileName, LPCSTR pszFmt, ...);

VOID _cdecl
XMLWriteDirFragmentFile(BOOL fOpen, LPCSTR pszRelPath, LPCSTR pszFmt, ...);

VOID
AddBuildMetrics(PBUILDMETRICS TargetMetrics, PBUILDMETRICS SourceMetrics);

VOID
XMLEnterCriticalSection();

VOID
XMLLeaveCriticalSection();

//
// Functions in buildsrc.c
//

extern DWORD StartTime;

VOID
StartElapsedTime(VOID);

VOID
PrintElapsedTime(VOID);

LPSTR
FormatElapsedTime(DWORD dwStartTime);

LPSTR
FormatCurrentDateTime();

BOOL
ReadDirsFile(DIRREC *DirDB);


VOID
ProcessLinkTargets(PDIRREC DirDB, LPSTR CurrentDirectory);

BOOL
SplitToken(LPSTR pbuf, char chsep, LPSTR *ppstr);

BOOL
MakeMacroString(LPSTR *pp, LPSTR p);

VOID
SaveMacro(LPSTR pszName, LPSTR pszValue);

VOID
FormatLinkTarget(
    LPSTR path,
    LPSTR *ObjectDirectory,
    LPSTR TargetPath,
    LPSTR TargetName,
    LPSTR TargetExt);

BOOL
ReadSourcesFile(DIRREC *DirDB, DIRSUP *pds, ULONG *pDateTimeSources);

VOID
PostProcessSources(DIRREC *pdr, DIRSUP *pds);

VOID
PrintDirSupData(DIRSUP *pds);

//+---------------------------------------------------------------------------
//
//  Function:   IsFullPath
//
//----------------------------------------------------------------------------

__inline BOOL
IsFullPath(char *pszfile)
{
    return(pszfile[0] == '\\' || (isalpha(pszfile[0]) && pszfile[1] == ':'));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\build\buildsrc.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       buildsrc.c
//
//  Contents:   Functions used to process SOURCES and DIRS files
//
//  History:    16-May-89     SteveWo    Created
//              26-Jul-94     LyleC      Split out from buildmak.c
//              05-Dec-00     sbonev     See SD changelist 2317
//
//----------------------------------------------------------------------------

#include "build.h"

//
// Definitions used by the macro functions
//

#define LPAREN  '('
#define RPAREN  ')'

// Legal character for a macro name.
#define MACRO_CHAR(ch) iscsym(ch)

#define CMACROMAX 256 // maximum unique macros per sources/dirs file

typedef struct _MACRO {
    LPSTR  pszValue;
    UCHAR  szName[1];
} MACRO;


MACRO *apMacro[CMACROMAX];
UINT cMacro = 0;

LPSTR *ppCurrentDirsFileName;
DWORD StartTime;
DWORD DirectoryStartTime;

#define SOURCES_TARGETNAME              0
#define SOURCES_TARGETPATH              1
#define SOURCES_TARGETPATHLIB           2
#define SOURCES_TARGETTYPE              3
#define SOURCES_TARGETEXT               4
#define SOURCES_INCLUDES                5
#define SOURCES_NTTEST                  6
#define SOURCES_UMTYPE                  7
#define SOURCES_UMTEST                  8
#define SOURCES_OPTIONAL_UMTEST         9
#define SOURCES_UMAPPL                  10
#define SOURCES_UMAPPLEXT               11
#define SOURCES_NTTARGETFILE0           12
#define SOURCES_NTTARGETFILES           13
#define SOURCES_PRECOMPILED_INCLUDE     14
#define SOURCES_PRECOMPILED_PCH         15
#define SOURCES_PRECOMPILED_OBJ         16
#define SOURCES_PRECOMPILED_TARGET      17
#define SOURCES_CHICAGO_PRODUCT         18
#define SOURCES_CONDITIONAL_INCLUDES    19
#define SOURCES_SYNCHRONIZE_BLOCK       20
#define SOURCES_SYNCHRONIZE_DRAIN       21
#define SOURCES_PASS0_SOURCEDIR         22
#define SOURCES_PASS0_HEADERDIR         23
#define SOURCES_PASS0_UUIDDIR           24
#define SOURCES_PASS0_CLIENTDIR         25
#define SOURCES_PASS0_SERVERDIR         26
#define SOURCES_IDLTYPE                 27
#define SOURCES_SOURCES_OPTIONS         28
#define SOURCES_MFC_INCLUDES            29
#define SOURCES_SDK_INC_PATH            30
#define SOURCES_CRT_INC_PATH            31
#define SOURCES_OAK_INC_PATH            32
#define SOURCES_DDK_INC_PATH            33
#define SOURCES_WDM_INC_PATH            34
#define SOURCES_PRIVATE_INC_PATH        35
#define SOURCES_CHECKED_ALT_DIR         36
#define SOURCES_USER_INCLUDES           37
#define SOURCES_LAST_INCLUDES           38
#define SOURCES_ATL_INC_PATH            39

LPSTR RelevantSourcesMacros[] = {
    "TARGETNAME",
    "TARGETPATH",
    "TARGETPATHLIB",
    "TARGETTYPE",
    "TARGETEXT",
    "INCLUDES",
    "NTTEST",
    "UMTYPE",
    "UMTEST",
    "OPTIONAL_UMTEST",
    "UMAPPL",
    "UMAPPLEXT",
    "NTTARGETFILE0",
    "NTTARGETFILES",
    "PRECOMPILED_INCLUDE",
    "PRECOMPILED_PCH",
    "PRECOMPILED_OBJ",
    "PRECOMPILED_TARGET",
    "CHICAGO_PRODUCT",
    "CONDITIONAL_INCLUDES",
    "SYNCHRONIZE_BLOCK",
    "SYNCHRONIZE_DRAIN",
    "PASS0_SOURCEDIR",
    "PASS0_HEADERDIR",
    "PASS0_UUIDDIR",
    "PASS0_CLIENTDIR",
    "PASS0_SERVERDIR",
    "IDL_TYPE",
    "SOURCES_OPTIONS",
    "MFC_INCLUDES",
    "SDK_INC_PATH",
    "CRT_INC_PATH",
    "OAK_INC_PATH",
    "DDK_INC_PATH",
    "WDM_INC_PATH",
    "PRIVATE_INC_PATH",
    "CHECKED_ALT_DIR",
    "USER_INCLUDES",
    "LAST_INCLUDES",
    "ATL_INC_PATH",
    NULL
};

#define SOURCES_MAX     \
        (sizeof(RelevantSourcesMacros)/sizeof(RelevantSourcesMacros[0]) - 1)

VOID
MarkDirNames(PDIRREC DirDB, LPSTR TextLine, BOOL Required);

//+---------------------------------------------------------------------------
//
//  Function:   CompressBlanks
//
//  Synopsis:   Compress multiple blank characters out of macro value, in
//              place.
//
//  Arguments:  [psrc] -- String to compress
//
//  Notes:      Note that tabs, CRs, continuation lines (and their line
//              breaks) have already been replaced with blanks.
//
//----------------------------------------------------------------------------

VOID
CompressBlanks(LPSTR psrc)
{
    LPSTR pdst = psrc;

    while (*psrc == ' ') {
        psrc++;                 // skip leading macro value blanks
    }
    while (*psrc != '\0') {
        if (*psrc == '#') {             // stop at comment
            break;
        }
        if ((*pdst++ = *psrc++) == ' ') {
            while (*psrc == ' ') {
                psrc++;         // skip multiple blanks
            }
        }
    }
    *pdst = '\0';                       // terminate the compressed copy
    if (*--pdst == ' ') {
        *pdst = '\0';           // trim trailing macro value blanks
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   GetBaseDir
//
//  Synopsis:   Return the value of BASEDIR, the base NT directory, if
//              appropriate.
//
//  Arguments:  [pname] -- path to split
//
//----------------------------------------------------------------------------

LPSTR
GetBaseDir(LPSTR pname)
{
    if (_stricmp("BASEDIR", pname) == 0) {
        return(NtRoot);
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindMacro
//
//  Synopsis:   Returns the value of a given macro by name.
//
//  Arguments:  [pszName] -- Name of macro who's value is desired.
//
//  Returns:    String containing the value of the macro
//
//----------------------------------------------------------------------------

LPSTR
FindMacro(LPSTR pszName)
{
    MACRO **ppm;

    for (ppm = apMacro; ppm < &apMacro[cMacro]; ppm++) {
        if (_stricmp(pszName, (*ppm)->szName) == 0) {
            return((*ppm)->pszValue);
        }
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveMacro
//
//  Synopsis:   Save the value of a macro
//
//  Arguments:  [pszName]  -- Name of macro to save
//              [pszValue] -- Value of macro
//
//  Notes:      A new string must be allocated and initialized prior to
//              freeing the old string when updating a macro value.
//
//----------------------------------------------------------------------------

VOID
SaveMacro(LPSTR pszName, LPSTR pszValue)
{
    MACRO **ppm;

    for (ppm = apMacro; ppm < &apMacro[cMacro]; ppm++) {
        if (_stricmp(pszName, (*ppm)->szName) == 0) {
            break;
        }
    }
    if (ppm == &apMacro[CMACROMAX]) {
        BuildError("Macro table full, ignoring: %s = %s\n", pszName, pszValue);
        return;
    }
    if (ppm == &apMacro[cMacro]) {
        cMacro++;
        AllocMem(sizeof(MACRO) + strlen(pszName), ppm, MT_MACRO);
        strcpy((*ppm)->szName, pszName);
        (*ppm)->pszValue = NULL;
    }
    MakeMacroString(&(*ppm)->pszValue, pszValue);
    if (DEBUG_1) {
        BuildMsg(
            "SaveMacro(%s = %s)\n",
            (*ppm)->szName,
            (*ppm)->pszValue == NULL? "NULL" : (*ppm)->pszValue);
    }
    if ((*ppm)->pszValue == NULL) {
        FreeMem(ppm, MT_MACRO);
        *ppm = apMacro[--cMacro];
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeMacros
//
//  Synopsis:   Free all macros
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
FreeMacros(VOID)
{
    MACRO **ppm;

    for (ppm = apMacro; ppm < &apMacro[cMacro]; ppm++) {
        FreeString(&(*ppm)->pszValue, MT_DIRSTRING);
        FreeMem(ppm, MT_MACRO);
        assert(*ppm == NULL);
    }
    cMacro = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   SplitMacro
//
//  Synopsis:   Take a string containing "MACRONAME = VALUE" and return
//              the target and value.
//
//  Arguments:  [pline] -- String to split and target return.
//
//  Returns:    Value of macro.
//
//----------------------------------------------------------------------------

LPSTR
SplitMacro(LPSTR *pszTarget)
{
    LPSTR pvalue, p, pline;

    pvalue = NULL;
    pline = *pszTarget;

    // Quickly reject comments and ! directives.
    if (*pline == '#' || *pline == '!') {
        return NULL;
    }

    if ((p = strchr(pline, '=')) != NULL) {
        pvalue = p + 1;                 // point past old '='
        while (p > pline && p[-1] == ' ') {
            p--;                        // point to start of trailing blanks
        }

        // Check for missing target.
        if (p == pline) {
            return NULL;
        }

        *p = '\0';                      // trim trailing blanks & '='

        // Perform macro substitution on target.
        *pszTarget = NULL;
        if (!MakeMacroString(pszTarget, pline)) {
            return NULL;
        }

        // Validate target name.  If must be a non-empty string of
        // valid macro name characters.
        if (**pszTarget == 0) {
            FreeString(pszTarget, MT_DIRSTRING);
            return NULL;
        }
        for (p = *pszTarget; *p != 0; p++) {
            if (!MACRO_CHAR(*p)) {
                FreeString(pszTarget, MT_DIRSTRING);
                return NULL;
            }
        }

        CompressBlanks(pvalue);
    }
    return(pvalue);
}


//+---------------------------------------------------------------------------
//
//  Function:   SubstituteString
//
//  Synopsis:   Perform any macro substitution.  This code was copied from the
//              nmake source.
//
//  Arguments:
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

void
SubstituteString(
    char **result,
    char **name,
    char **dest,
    char **end,
    char *source,
    unsigned *length
    )
{

#define ESCH  '^'

    char *oldString, *newString;
    char *pEq, *pPar, *t;
    char *s;
    unsigned i;

    ++*name;
    for (pEq = *name; *pEq && *pEq != '='; pEq++)
        if (*pEq == ESCH)
            pEq++;

    // Did we find the '=' sign?
    if (*pEq != '=')
        printf("Error1\n");

    // Did the user forget the initial string?
    if (pEq == *name)
        printf("Error2\n");

    for (pPar = pEq; *pPar && *pPar != ')'; pPar++)
        if (*pPar == ESCH)
            pPar++;

    if (*pPar != ')')
        printf("Error3\n");

    oldString = (char *)malloc((UINT)((pEq - *name) + 1));
    for (s = oldString, t = *name; *t != '='; *s++ = *t++)
        if (*t == ESCH)
            ++t;

    *s = '\0';
    i = strlen(oldString);
    newString = (char *)malloc((UINT)(pPar - pEq));
    for (s = newString, t++; *t != ')'; *s++ = *t++)
        if (*t == ESCH)
            ++t;

    *s = '\0';
    *name = pPar + 1;
    while (*source) {
        if ((*source == *oldString)                     // check for match
            && !strncmp(source, oldString, i)) {       // copy new in for
            for (s = newString; *s; *(*dest)++ = *s++)  //  old string
                if (*dest == *end) {
                    *result = realloc(*result, *length + 100);
                    *dest = *result + *length;
                    *length += 100;
                    *end = *result + *length;
                }
            source += i;
            continue;
        }
        if (*dest == *end) {
            *result = realloc(*result, *length + 100);
            *dest = *result + *length;
            *length += 100;
            *end = *result + *length;
        }
        *(*dest)++ = *source++;         // else copy 1 char
    }
    free(oldString);
    free(newString);
}


//+---------------------------------------------------------------------------
//
//  Function:   MakeMacroString
//
//  Synopsis:   Take a string, and expand any macros in it.  (e.g.
//              "$(BASEDIR)\foobar\myfile.lib" is expanded to
//              "f:\nt\private\foobar\myfile.lib" if $(BASEDIR) has a value of
//              "f:\nt\private".
//
//  Arguments:  [pp]   -- Output string
//              [psrc] -- Input string
//
//  Returns:
//
//  Notes:      Any previous string value in [pp] is freed before updating it.
//
//----------------------------------------------------------------------------

char MMSBuffer[64*1024];
BOOL
MakeMacroString(LPSTR *pp, LPSTR psrc)
{
    LPSTR pname, p2, pdst, p3;
    int cb;
    char chTerminator;
    int cNameChars;
    int cChars;

    pdst = MMSBuffer;
    cb = strlen(psrc);
    if (cb > sizeof(MMSBuffer) - 1) {
        BuildError(
            "(Fatal Error) Buffer overflow: MakeMacroString(%s)\n",
            psrc);
        exit(16);
    }
    while ((pname = strchr(psrc, '$')) != NULL &&
           ((pname[1] == LPAREN &&
             (p2 = strchr(pname, RPAREN)) != NULL) ||
            (MACRO_CHAR(pname[1]) &&
             !MACRO_CHAR(pname[2])))) {

        LPSTR pszvalue;

        // Handle one-character non-paren macro usage.
        if (pname[1] == LPAREN) {
            // Initialize cNameChars with the number of chars to
            // skip to get to the first name character.
            cNameChars = 2;
        } else {
            p2 = pname + 2;
            cNameChars = 1;
        }

        chTerminator = *p2;
        *pname = *p2 = '\0';

        // copy up to macro name
        cChars = strlen(psrc);
        memcpy(pdst, psrc, cChars + 1);
        psrc += cChars;
        pdst += cChars;

        *pname = '$';
        pname += cNameChars;
        cNameChars += strlen(pname) + (chTerminator == RPAREN ? 1 : 0);

        p3 = NULL;
        if (chTerminator == RPAREN &&
            (p3 = strchr(pname, ':')) != NULL) {
            // macro substitution exists.  ie: $(foo:old=new)
            *p3 = '\0';
        }

        if ((pszvalue = FindMacro(pname)) == NULL &&
            (pszvalue = getenv(pname)) == NULL &&
            (pszvalue = GetBaseDir(pname)) == NULL) {

            pszvalue = "";              // can't find macro name -- ignore it
        }

        if (p3) {
            char *pNew = malloc(10);
            char *pResult = pNew;
            char *pEnd = pNew+10;
            unsigned Len = 10;

            *p3 = ':';
            *p2=RPAREN;
            SubstituteString(&pResult, &p3, &pNew, &pEnd, pszvalue, &Len);
            *pNew = '\0';
            *p2='\0';
            pszvalue = pResult;
        }

        cb += strlen(pszvalue) - cNameChars;
        assert(cb >= 0);
        if (cb > sizeof(MMSBuffer) - 1) {
            BuildError(
                "(Fatal Error) Internal buffer overflow: MakeMacroString(%s[%s = %s]%s)\n",
                MMSBuffer,
                pname,
                pszvalue,
                p2 + 1);
            exit(16);
        }
        strcpy(pdst, pszvalue);         // copy expanded value

        if (p3) {
            free(pszvalue);
        }

        pdst += strlen(pdst);
        *p2 = chTerminator;
        psrc += cNameChars;
    }
    strcpy(pdst, psrc);                 // copy rest of string
    if (pdst != MMSBuffer) {
        CompressBlanks(MMSBuffer);
    }
    p2 = *pp;
    *pp = NULL;
    if (MMSBuffer[0] != '\0') {
        MakeString(pp, MMSBuffer, TRUE, MT_DIRSTRING);
    }
    if (p2 != NULL) {
        FreeMem(&p2, MT_DIRSTRING);
    }
    return(MMSBuffer[0] != '\0');
}


//+---------------------------------------------------------------------------
//
//  Function:   SetMacroString
//
//  Synopsis:   If the two macro names are the same, store the value in that
//              macro
//
//  Arguments:  [pMacro1] -- Name of first macro
//              [pMacro2] -- Name of second macro
//              [pValue]  -- Unexpanded value to store.
//              [ppValue] -- Expanded value of macro.
//
//  Returns:    BOOL
//
//----------------------------------------------------------------------------

BOOL
SetMacroString(LPSTR pMacro1, LPSTR pMacro2, LPSTR pValue, LPSTR *ppValue)
{
    if (_stricmp(pMacro1, pMacro2) == 0) {
        MakeMacroString(ppValue, pValue);
        return(TRUE);   // return TRUE even if MakeMacroString stored a NULL
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   SplitToken
//
//  Synopsis:   Split the string at the given separator character or space.
//
//  Arguments:  [pbuf]  -- First part of split string returned here.
//              [chsep] -- Separator character.
//              [ppstr] -- Source string to split.  Becomes the second half.
//
//  Returns:    TRUE if the split was successful.  FALSE if it wasn't split.
//
//  Notes:      If *ppstr = "path\filename" and chsep = '\' on input, then
//              pbuf = "path" and *ppstr = "\filename" on output.
//
//----------------------------------------------------------------------------

BOOL
SplitToken(LPSTR pbuf, char chsep, LPSTR *ppstr)
{
    LPSTR psrc, pdst;

    psrc = *ppstr;
    pdst = pbuf;
    //BuildError("SplitToken('%c', '%s') ==> ", chsep, psrc);
    while (*psrc == chsep || *psrc == ' ') {
        psrc++;
    }
    while (*psrc != '\0' && *psrc != chsep && *psrc != ' ') {
        *pdst = *psrc++;
        if (*pdst == '/') {
            *pdst = '\\';
        }
        pdst++;
    }
    *pdst = '\0';
    *ppstr = psrc;
    //BuildErrorRaw("('%s', '%s')\n", psrc, pbuf);
    return(pdst != pbuf);
}


//+---------------------------------------------------------------------------
//
//  Function:   CrackSources
//
//  Synopsis:   Parse the SOURCES= line in a sources file and adds those source
//              files to the list of sources in the DIRREC struct.
//
//  Arguments:  [pdr] -- Directory record
//              [pds] -- Supplemental directory information
//              [i]   -- Which platform we're parsing
//
//----------------------------------------------------------------------------

VOID
CrackSources(
    DIRREC *pdr,
    DIRSUP *pds,
    int i)

{

    LPSTR pszsubdir, plist;
    LPSTR pszfile, pszpath;
    FILEREC *pfr;
    DIRREC *pdrAssociate;
    DIRREC *pdrParent;
    DIRREC *pdrMachine;
    DIRREC *pdrParentMachine;
    DIRREC *pdrTarget;
    DIRREC **ppdr;
    LPSTR pszSources;
    char path[DB_MAX_PATH_LENGTH];
    TARGET_MACHINE_INFO *pMachine;

    if (i == 0) {
        pMachine = TargetMachines[0];
        pszSources = "SOURCES";

    } else {
        pMachine = PossibleTargetMachines[i - 1];
        pszSources = pMachine->SourceVariable;
    }

    pdrAssociate = pdrParent = pdrMachine = pdrParentMachine = pdrTarget = NULL;
    plist = pds->SourcesVariables[i];
    while (SplitToken(path, ' ', &plist)) {
        UCHAR SubDirMask, SrcFlags;

        SubDirMask = 0;
        ppdr = &pdr;                    // assume current directory
        pszsubdir = path;
        if (pszsubdir[0] == '.' && pszsubdir[1] == '\\') {
            BuildError(
                "%s: Ignoring current directory prefix in %s= entry: %s\n",
                pdr->Name,
                pszSources,
                path);
            pszsubdir += 2;
        }

        if (pszsubdir[0] == '.' &&
            pszsubdir[1] == '.' &&
            pszsubdir[2] == '\\') {

            SubDirMask = TMIDIR_PARENT;
            ppdr = &pdrParent;          // assume parent directory
            pszsubdir += 3;
        }

        pszpath = path;
        pszfile = strchr(pszsubdir, '\\');
        if (pszfile == NULL) {
            pszfile = pszsubdir;

        } else {
            LPSTR pszSecondSlash;
            LPSTR pszAssociateDir;
            LPSTR pszMachineDir;

            // Check for second slash and handle $O\.  If there is
            // no second slash, check for a machine specific directory name.
            // Second slashes are not legal if there's already been
            // a '..'.

            if ((SubDirMask & TMIDIR_PARENT) == 0) {
                pszSecondSlash = strchr(pszfile + 1, '\\');
                if (pszSecondSlash != NULL) {
                    pszfile = pszSecondSlash;
                }

            } else {
                pszSecondSlash = NULL;
            }


            *pszfile = '\0';
            if (pszSecondSlash != NULL) {
                pszMachineDir = pMachine->ObjectDirectory[iObjectDir];
                pszAssociateDir = pszMachineDir;

            } else {
                pszMachineDir = pMachine->SourceDirectory;
                pszAssociateDir = pMachine->AssociateDirectory;
            }

            if (((_stricmp(pszsubdir, pszAssociateDir) != 0) &&
                (_stricmp(pszsubdir, pszMachineDir) != 0)) ||
                strchr(pszfile + 1, '\\') != NULL) {

                *pszfile = '\\';
                BuildError(
                    "%s: Ignoring invalid directory prefix in %s= entry: %s\n",
                    pdr->Name,
                    pszSources,
                    path);

                //

                pszpath = strrchr(path, '\\');
                assert(pszpath != NULL);
                pszpath++;
                SubDirMask = 0;
                ppdr = &pdr;            // default to current direcory

            } else {
                SubDirMask |= pMachine->SourceSubDirMask;
                *pszfile++ = '\\';
                if (SubDirMask & TMIDIR_PARENT) {
                    ppdr = &pdrParentMachine;

                } else if (pszSecondSlash != NULL) {
                    // Must have matched $O.
                    ppdr = &pdrTarget;

                } else {
                    if (_stricmp(pszsubdir, pszMachineDir) != 0) {
                        ppdr = &pdrMachine;

                    } else {
                        ppdr = &pdrAssociate;
                    }
                }
            }
        }

NewDirectory:
        if (*ppdr == NULL) {
            pfr = FindSourceFileDB(pdr, pszpath, ppdr);

        } else {
            pfr = LookupFileDB(*ppdr, pszfile);
        }

        SrcFlags = SOURCEDB_SOURCES_LIST;
        if ((pfr == NULL) && !fPassZero) {
            if (fDebug) {
                BuildError("%s: Missing source file: %s\n", pdr->Name, path);
            }
            if (*ppdr == NULL) {
                if (fDebug || pszpath == path) {
                    BuildError(
                        "%s: Directory does not exist: %s\n",
                        pdr->Name,
                        path);
                }

                // Probably an error in the subordinate sources file.
                // since old versions of build managed to get these entries
                // into the objects lists, we have to do the same...
                //
                // If ..\ prefix exists, strip it off and try again.
                // Else try again with the current directory.

                if (SubDirMask & TMIDIR_PARENT) {
                    SubDirMask &= ~TMIDIR_PARENT;       // strip off "..\\"
                }
                else {
                    SubDirMask = 0;             // use current direcory
                }
                if (SubDirMask == 0) {
                    ppdr = &pdr;                // current direcory
                    pszpath = pszfile;
                }
                else {
                    ppdr = &pdrMachine;         // machine sub dir
                    pszpath = pszsubdir;
                }
                goto NewDirectory;
            }
            pfr = InsertFileDB(*ppdr, pszfile, 0, 0, FILEDB_FILE_MISSING);
            if (pfr == NULL) {
                BuildError(
                    "%s: Ignoring invalid %s= entry: %s\n",
                    pdr->Name,
                    pszSources,
                    path);
            }
        }
        if (pfr != NULL) {
            AssertFile(pfr);
            if (SubDirMask == 0) {
                pfr->FileFlags |= FILEDB_OBJECTS_LIST;
            }
            if (pfr->FileFlags & FILEDB_FILE_MISSING) {
                SrcFlags |= SOURCEDB_FILE_MISSING;
            }
            InsertSourceDB(&pds->psrSourcesList[i], pfr, SubDirMask, SrcFlags);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveUserTests
//
//  Synopsis:   Save the value of the UMTEST macro into the DIRREC struct.
//
//  Arguments:  [DirDB]    -- Dir struct to save into
//              [TextLine] -- String from UMTEST= line in sources file
//
//----------------------------------------------------------------------------

VOID
SaveUserTests(
    PDIRREC DirDB,
    LPSTR TextLine)
{
    UINT i;
    BOOL fSave = FALSE;
    char name[DB_MAX_PATH_LENGTH];
    char buf[512];

    buf[0] = '\0';
    if (DirDB->UserTests != NULL) {
        strcpy(buf, DirDB->UserTests);
    }
    CopyString(TextLine, TextLine, TRUE);
    while (SplitToken(name, '*', &TextLine)) {
        for (i = 0; i < CountOptionalDirs; i++) {
            if (!strcmp(name, OptionalDirs[i])) {
                if (buf[0] != '\0') {
                    strcat(buf, "*");
                    DirDB->DirFlags |= DIRDB_FORCELINK; // multiple targets
                }
                strcat(buf, name);
                fSave = TRUE;
                break;
            }
        }
    }
    if (fSave) {
        MakeMacroString(&DirDB->UserTests, buf);
        DirDB->DirFlags |= DIRDB_LINKNEEDED;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadSourcesFile
//
//  Synopsis:   Parses the sources files (common and platform specific)
//
//  Arguments:  [DirDB]            -- Directory containing sources file
//              [pds]              -- Supplementary info on directory
//              [pDateTimeSources] -- Timestamp of Sources file
//
//  Returns:    TRUE if read successfully
//
//----------------------------------------------------------------------------

BOOL
ReadSourcesFile(DIRREC *DirDB, DIRSUP *pds, ULONG *pDateTimeSources)
{
    FILE *InFileHandle;
#ifdef CREATE_TARGET_SUBDIRECTORIES
    LPSTR p, p1, TextLine;
#else // CREATE_TARGET_SUBDIRECTORIES
    LPSTR p, TextLine;
#endif // CREATE_TARGET_SUBDIRECTORIES
    LPSTR MacroName;
    UINT i, iMacro;
    int iTarget;
    ULONG DateTime;
    char path[DB_MAX_PATH_LENGTH];
    BOOL fCleanNTTargetFile0 = FALSE;

    memset(pds, 0, sizeof(*pds));
    pds->fNoTarget=FALSE;
    assert(DirDB->TargetPath == NULL);
    assert(DirDB->TargetPathLib == NULL);
    assert(DirDB->TargetName == NULL);
    assert(DirDB->TargetExt == NULL);
    assert(DirDB->KernelTest == NULL);
    assert(DirDB->UserAppls == NULL);
    assert(DirDB->UserTests == NULL);
    assert(DirDB->NTTargetFile0 == NULL);
    assert(DirDB->Pch == NULL);
    assert(DirDB->PchObj == NULL);
    assert(cMacro == 0);
    *pDateTimeSources = 0;

    //
    // Read the information in each of the target specific directories
    // and simulate concatenation of all of the sources files.
    //
    // Possible sources files are read from DirDB->Name | target-source
    // and DirDb->Name | ..\target-source.
    //
    // iTarget values, and the corresponding files processed are:
    //  -1      sources.
    //   0      PossibleTargetMachines[0]\sources.
    //   1      ..\PossibleTargetMachines[0]\sources.
    //   2      PossibleTargetMachines[1]\sources.
    //   3      ..\PossibleTargetMachines[1]\sources.
    //   4      PossibleTargetMachines[2]\sources.
    //   5      ..\PossibleTargetMachines[2]\sources.

    SaveMacro("MAKEDIR", DirDB->Name);
    SetObjDir(FALSE);
    SaveMacro("_OBJ_DIR", pszObjDir);
    // Define a default CONDITIONAL_INCLUDES line to deal with the mac hdrs in windows/rpc/ole32.h.
    MakeMacroString(&pds->ConditionalIncludes, "winwlm.h rpcmac.h rpcerr.h macapi.h macname1.h macname2.h macocidl.h macpub.h macwin32.h");

    for (iTarget = -1; iTarget < 2*MAX_TARGET_MACHINES; iTarget++) {
        path[0] = '\0';
        if (iTarget >= 0) {
            if (iTarget & 1) {
                strcat(path, "..\\");
            }
            strcat(path, PossibleTargetMachines[iTarget/2]->SourceDirectory);
            strcat(path, "\\");
        }
        strcat(path, "sources.");
        if (!OpenFilePush(DirDB->Name, path, "#", &InFileHandle)) {
            if (iTarget == -1) {
                FreeMacros();
                return(FALSE);
            }
            continue;           // skip non-existent subordinate sources files
        }
        if (DEBUG_1) {
            BuildMsg(
                "    Scanning%s file %s\n",
                iTarget >= 0 ? " subordinate" : "",
                FormatPathName(DirDB->Name, path));
        }

        // Update per-target macros.
        if (iTarget < 0) {
            SaveMacro("TARGET_DIRECTORY",
                      TargetMachines[0]->SourceDirectory);
            SaveMacro("O", TargetMachines[0]->
                      ObjectDirectory[iObjectDir]);
        } else {
            SaveMacro("TARGET_DIRECTORY",
                      PossibleTargetMachines[iTarget/2]->SourceDirectory);
            SaveMacro("O", PossibleTargetMachines[iTarget/2]->
                      ObjectDirectory[iObjectDir]);
        }

        DirDB->DirFlags |= DIRDB_SOURCESREAD;

        while ((TextLine = ReadLine(InFileHandle)) != NULL) {
            LPSTR pValue;

            pValue = SplitMacro(&TextLine);
            if (pValue == NULL) {
                continue;
            }
            iMacro = 0;

            //
            // This sets pds->SourcesVariables[0] to the value of SOURCES= if
            // the current line is SOURCES=...
            //
            if (SetMacroString(
                    "SOURCES",
                    TextLine,
                    pValue,
                    &pds->SourcesVariables[0])) {

                iMacro = SOURCES_MAX;
                DirDB->DirFlags |= DIRDB_SOURCES_SET;
            }
            else {
                for (i = 0; i < MAX_TARGET_MACHINES; i++) {
                    //
                    // This sets pds->SourcesVariables[0] to the value of
                    // PLAT_SOURCES= if the current line is PLAT_SOURCES=...
                    //
                    if (SetMacroString(
                            PossibleTargetMachines[i]->SourceVariable,
                            TextLine,
                            pValue,
                            &pds->SourcesVariables[i + 1])) {

                        iMacro = SOURCES_MAX;
                        DirDB->DirFlags |= DIRDB_SOURCES_SET;
                        break;
                    }
                }
            }
            while ((MacroName = RelevantSourcesMacros[iMacro]) != NULL) {
                if (_stricmp(TextLine, MacroName) == 0) {
                    break;
                }
                iMacro++;
            }
            if (MacroName != NULL) {    // if macro name found in list
                switch (iMacro) {
                    LPSTR *ppszPath;
                    LPSTR *ppszFile;

                    case SOURCES_TARGETNAME:
                        MakeMacroString(&DirDB->TargetName, pValue);
                        break;

                    case SOURCES_TARGETPATH:
                        if (strcmp(pValue, "obj") == 0) {
                            pValue = pszObjDir;
                        }
                        MakeMacroString(&DirDB->TargetPath, pValue);
                        if (DirDB->TargetPath != NULL) {
                            CreateBuildDirectory(DirDB->TargetPath);
#ifdef CREATE_TARGET_SUBDIRECTORIES
                            for (i = 0; i < CountTargetMachines; i++) {
                                p1 = TargetMachines[i]->ObjectDirectory[iObjectDir];
                                assert(strncmp(pszObjDirSlash, p1, strlen(pszObjDirSlash)) == 0);
                                p1 += strlen(pszObjDirSlash);
                                sprintf(path, "%s\\%s", DirDB->TargetPath, p1);
                                CreateBuildDirectory(path);
                            }
#endif // CREATE_TARGET_SUBDIRECTORIES
                        }
                        break;

                    case SOURCES_TARGETPATHLIB:
                        if (strcmp(pValue, "obj") == 0) {
                            pValue = pszObjDir;
                        }
                        MakeMacroString(&DirDB->TargetPathLib, pValue);
                        if (DirDB->TargetPathLib != NULL) {
                            CreateBuildDirectory(DirDB->TargetPathLib);
#ifdef CREATE_TARGET_SUBDIRECTORIES
                            for (i = 0; i < CountTargetMachines; i++) {
                                p1 = TargetMachines[i]->ObjectDirectory[iObjectDir];
                                assert(strncmp(pszObjDirSlash, p1, strlen(pszObjDirSlash)) == 0);
                                p1 += strlen(pszObjDirSlash);
                                sprintf(path, "%s\\%s", DirDB->TargetPathLib, p1);
                                CreateBuildDirectory(path);
                            }
#endif // CREATE_TARGET_SUBDIRECTORIES
                        }
                        break;

                    case SOURCES_TARGETTYPE:
                        if (!_stricmp(pValue, "PROGRAM")) {
                            DirDB->TargetExt = ".exe";
                            DirDB->DirFlags |= DIRDB_LINKNEEDED;
                            }
                        else
                        if (!_stricmp(pValue, "DRIVER")) {
                            DirDB->TargetExt = ".sys";
                            DirDB->DirFlags |= DIRDB_LINKNEEDED;
                            }
                        else
                        if (!_stricmp(pValue, "GDI_DRIVER")) {
                            DirDB->TargetExt = ".dll";
                            DirDB->DirFlags |= DIRDB_LINKNEEDED;
                            }
                        else
                        if (!_stricmp(pValue, "MINIPORT")) {
                            DirDB->TargetExt = ".sys";
                            DirDB->DirFlags |= DIRDB_LINKNEEDED;
                            }
                        else
                        if (!_stricmp(pValue, "EXPORT_DRIVER")) {
                            DirDB->TargetExt = ".sys";
                            DirDB->DirFlags |= DIRDB_LINKNEEDED;
                            DirDB->DirFlags |= DIRDB_DLLTARGET;
                            }
                        else
                        if (!_stricmp(pValue, "DYNLINK")) {
                            DirDB->TargetExt = ".dll";
                            DirDB->DirFlags |= DIRDB_LINKNEEDED;
                            DirDB->DirFlags |= DIRDB_DLLTARGET;
                            }
                        else
                        if (!_stricmp(pValue, "HAL")) {
                            DirDB->TargetExt = ".dll";
                            DirDB->DirFlags |= DIRDB_LINKNEEDED;
                            DirDB->DirFlags |= DIRDB_DLLTARGET;
                            }
                        else
                        if (!_stricmp(pValue, "LIBRARY")) {
                            DirDB->TargetExt = ".lib";
                            DirDB->DirFlags &= ~DIRDB_LINKNEEDED;
                            }
                        else
                        if (!_stricmp(pValue, "PROGLIB")) {
                            DirDB->TargetExt = ".exe";
                            DirDB->DirFlags |= DIRDB_LINKNEEDED;
                            }
                        else
                        if (!_stricmp(pValue, "UMAPPL_NOLIB")) {
                            DirDB->DirFlags &= ~DIRDB_LINKNEEDED;
                            }
                        else
                        if (!_stricmp(pValue, "NOTARGET")) {
                            //
                            // Used to indicate no target for a directory,
                            // e.g. if only pass0 files are generated
                            pds->fNoTarget = TRUE;
                            if (!fQuicky || (fQuickZero && fFirstScan)) {
                                DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                                }
                            }
                        else {
                            BuildError(
                                "Unsupported TARGETTYPE value - %s\n",
                                pValue);
                            }
                        break;

                    case SOURCES_TARGETEXT:
                        if (!_stricmp(pValue, "dll")) {
                            DirDB->TargetExt = ".dll";
                            }
                        else
                        if (!_stricmp(pValue, "fon")) {
                            DirDB->TargetExt = ".fon";
                            }
                        else
                        if (!_stricmp(pValue, "cpl")) {
                            DirDB->TargetExt = ".cpl";
                            }
                        else
                        if (!_stricmp(pValue, "drv")) {
                            DirDB->TargetExt = ".drv";
                            }
                        else
                        if (!_stricmp(pValue, "tsp")) {
                            DirDB->TargetExt = ".tsp";
                            }
                        else
                        if (!_stricmp(pValue, "pkg")) {
                            DirDB->TargetExt = ".pkg";
                        }
                        else
                        if (!_stricmp(pValue, "awx")) {
                            DirDB->TargetExt = ".awx";
                        }
                        else
                        if (!_stricmp(pValue, "ocx")) {
                            DirDB->TargetExt = ".ocx";
                        }
                        else
                        if (!_stricmp(pValue, "tlb")) {
                            DirDB->TargetExt = ".tlb";
                        }
                        else
                        if (!_stricmp(pValue, "hpa")) {
                            DirDB->TargetExt = ".hpa";
                        }
                        else
                        if (!_stricmp(pValue, "ime")) {
                            DirDB->TargetExt = ".ime";
                        }
                        else
                        if (!_stricmp(pValue, "tsp")) {
                            DirDB->TargetExt = ".tsp";
                        }
                        else
                        if (!_stricmp(pValue, "ax")) {
                            DirDB->TargetExt = ".ax";
                        }
                        else
                        if (!_stricmp(pValue, "ds")) {
                            DirDB->TargetExt = ".ds";
                        }
                        else
                        if (!_stricmp(pValue, "acm")) {
                            DirDB->TargetExt = ".acm";
                        }
                        else
                        if (!_stricmp(pValue, "rio")) {
                            DirDB->TargetExt = ".rio";
                        }
                        else
                        if (!_stricmp(pValue, "bos")) {
                            DirDB->TargetExt = ".bos";
                        }
                        else
                        if (!_stricmp(pValue, "io")) {
                            DirDB->TargetExt = ".io";
                        }
                        else
                        if (!_stricmp(pValue, "cfm")) {
                            DirDB->TargetExt = ".cfm";
                        }
                        else {
                            BuildError(
                                "Unsupported TARGETEXT value - %s\n",
                                pValue);
                        }
                        break;

                    case SOURCES_INCLUDES:
                        MakeMacroString(&pds->LocalIncludePath, pValue);
                        if (DEBUG_1) {
                            BuildMsg(
                                "        Found local INCLUDES=%s\n",
                                pds->LocalIncludePath);
                        }
                        break;

                    case SOURCES_USER_INCLUDES:
                        MakeMacroString(&pds->UserIncludePath, pValue);
                        if (DEBUG_1) {
                            BuildMsg(
                                "        Found local USER_INCLUDES=%s\n",
                                pds->UserIncludePath);
                        }
                        break;

                    case SOURCES_LAST_INCLUDES:
                        MakeMacroString(&pds->LastIncludePath, pValue);
                        if (DEBUG_1) {
                            BuildMsg(
                                "        Found local LAST_INCLUDES=%s\n",
                                pds->LastIncludePath);
                        }
                        break;

                    case SOURCES_MFC_INCLUDES:
                        // MFC_INCLUDES/SDK_INC/CRT_INC/OAK_INC really can't be changed
                        // in the sources file (yet) since we've already processed the
                        // system includes.  Lay the groundwork for now.
                        MakeMacroString((char **)&pszIncMfc, pValue);
                        break;

                    case SOURCES_SDK_INC_PATH:
                        MakeMacroString((char **)&pszIncSdk, pValue);
                        break;

                    case SOURCES_CRT_INC_PATH:
                        MakeMacroString((char **)&pszIncCrt, pValue);
                        break;

                    case SOURCES_OAK_INC_PATH:
                        MakeMacroString((char **)&pszIncOak, pValue);
                        break;

                    case SOURCES_DDK_INC_PATH:
                        MakeMacroString((char **)&pszIncDdk, pValue);
                        break;

                    case SOURCES_WDM_INC_PATH:
                        MakeMacroString((char **)&pszIncWdm, pValue);
                        break;

                    case SOURCES_ATL_INC_PATH:
                        MakeMacroString((char **)&pszIncAtl, pValue);
                        break;

                    case SOURCES_PRIVATE_INC_PATH:
                        MakeMacroString((char **)&pszIncPri, pValue);
                        break;

                    case SOURCES_PRECOMPILED_PCH:
                        MakeMacroString(&DirDB->Pch, pValue);
                        break;

                    case SOURCES_PRECOMPILED_OBJ:
                        MakeMacroString(&DirDB->PchObj, pValue);
                        break;

                    case SOURCES_PRECOMPILED_INCLUDE:
                    case SOURCES_PRECOMPILED_TARGET:
                        if (iMacro == SOURCES_PRECOMPILED_INCLUDE) {
                            ppszPath = &pds->PchIncludeDir;
                            ppszFile = &pds->PchInclude;
                        } else {
                            ppszPath = &pds->PchTargetDir;
                            ppszFile = &pds->PchTarget;
                        }

                        MakeMacroString(ppszPath, "");  // free old string
                        if (!MakeMacroString(ppszFile, pValue)) {
                            break;
                        }
                        p = *ppszFile + strlen(*ppszFile);
                        while (p > *ppszFile && *--p != '\\')
                            ;

                        if (p > *ppszFile) {
                            *p = '\0';
                            MakeMacroString(ppszPath, *ppszFile);
                            MakeMacroString(ppszFile, p + 1);
                        }

                        if (DEBUG_1) {
                            BuildMsg(
                                "Precompiled header%s is %s in directory %s\n",
                                iMacro == SOURCES_PRECOMPILED_INCLUDE?
                                    "" : " target",
                                *ppszFile,
                                *ppszPath != NULL?
                                    *ppszPath : "'.'");
                        }

                        if (iMacro == SOURCES_PRECOMPILED_INCLUDE ||
                            pds->PchTargetDir == NULL) {

                            break;
                        }

                        EnsureDirectoriesExist(pds->PchTargetDir);
                        break;

                    case SOURCES_PASS0_HEADERDIR:
                        MakeMacroString(&pds->PassZeroHdrDir, pValue);
                        EnsureDirectoriesExist(pds->PassZeroHdrDir);
                        if (DEBUG_1)
                        {
                            BuildMsg("Pass Zero Header Directory is '%s'\n",
                                     pds->PassZeroHdrDir);
                        }
                        break;

                    case SOURCES_PASS0_SOURCEDIR:
                        // SOURCES_PASS0_SOURCEDIR and SOURCES_PASS0_CLIENTDIR
                        // are mutually exclusive - enforced by makefile.def
                        DirDB->DirFlags &= ~DIRDB_IDLTYPERPC;
                        MakeMacroString(&pds->PassZeroSrcDir1, pValue);
                        EnsureDirectoriesExist(pds->PassZeroSrcDir1);
                        if (DEBUG_1)
                        {
                            BuildMsg("Pass Zero Source Directory is '%s'\n",
                                     pds->PassZeroSrcDir1);
                        }
                        break;

                    case SOURCES_PASS0_CLIENTDIR:
                        // SOURCES_PASS0_SOURCEDIR and SOURCES_PASS0_CLIENTDIR
                        // are mutually exclusive - enforced by makefile.def
                        DirDB->DirFlags |= DIRDB_IDLTYPERPC;
                        MakeMacroString(&pds->PassZeroSrcDir1, pValue);
                        EnsureDirectoriesExist(pds->PassZeroSrcDir1);
                        if (DEBUG_1)
                        {
                            BuildMsg("Pass Zero Client Directory is '%s'\n",
                                     pds->PassZeroSrcDir1);
                        }
                        break;

                    case SOURCES_PASS0_UUIDDIR:
                        // SOURCES_PASS0_UUIDDIR and SOURCES_PASS0_SERVERDIR
                        // are mutually exclusive - enforced by makefile.def
                        DirDB->DirFlags &= ~DIRDB_IDLTYPERPC;
                        MakeMacroString(&pds->PassZeroSrcDir2, pValue);
                        EnsureDirectoriesExist(pds->PassZeroSrcDir2);
                        if (DEBUG_1)
                        {
                            BuildMsg("Pass Zero UUID Source Directory is '%s'\n",
                                     pds->PassZeroSrcDir2);
                        }
                        break;

                    case SOURCES_PASS0_SERVERDIR:
                        // SOURCES_PASS0_UUIDDIR and SOURCES_PASS0_SERVERDIR
                        // are mutually exclusive - enforced by makefile.def
                        DirDB->DirFlags |= DIRDB_IDLTYPERPC;
                        MakeMacroString(&pds->PassZeroSrcDir2, pValue);
                        EnsureDirectoriesExist(pds->PassZeroSrcDir2);
                        if (DEBUG_1)
                        {
                            BuildMsg("Pass Zero Server Directory is '%s'\n",
                                     pds->PassZeroSrcDir2);
                        }
                        break;

                    case SOURCES_NTTEST:
						// VS 7.0 version didn't add NTTEST unless it
						// matched one of the the optional dirs.
						// But we (Xbox) need NTTEST to be added always,
						// which was the older behavior,
						// to allow the private\ntos\init directory to
						// build correctly.
						{
							BOOL addIt = TRUE;
							for (i = 0; i < CountOptionalDirs; i++) {
								if (!_stricmp(pValue, OptionalDirs[i])) {
									addIt = TRUE;
									break;
								}
							}
							if ( addIt ) {
								if (MakeMacroString(&DirDB->KernelTest, pValue)) {
									DirDB->DirFlags |= DIRDB_LINKNEEDED;
								}
							}
						}
                        break;

                    case SOURCES_UMTYPE:
                        MakeMacroString(&pds->TestType, pValue);
                        if (DEBUG_1) {
                            BuildMsg(
                                "        Found UMTYPE=%s\n",
                                pds->TestType);
                            }
                        break;

                    case SOURCES_UMTEST:
                    case SOURCES_OPTIONAL_UMTEST:
                        SaveUserTests(DirDB, pValue);
                        break;

                    case SOURCES_UMAPPL:
                        if (MakeMacroString(&DirDB->UserAppls, pValue)) {
                            DirDB->DirFlags |= DIRDB_LINKNEEDED;
                        }
                        break;

                    case SOURCES_UMAPPLEXT:
                        if (!_stricmp(pValue, ".exe")) {
                            DirDB->TargetExt = ".exe";
                            }
                        else
                        if (!_stricmp(pValue, ".com")) {
                            DirDB->TargetExt = ".com";
                            }
                        else
                        if (!_stricmp(pValue, ".scr")) {
                            DirDB->TargetExt = ".scr";
                            }
                        else {
                            BuildError(
                                "Unsupported UMAPPLEXT value - %s\n",
                                pValue);
                        }
                        break;

                    case SOURCES_IDLTYPE:
                        if (!_stricmp(pValue, "ole")) {
                            pds->IdlType = 0;
                            }
                        else
                        if (!_stricmp(pValue, "rpc")) {
                            pds->IdlType = 1;
                            }
                        else {
                            BuildError(
                                "Unsupported IDL_TYPE value - %s\n",
                                pValue);
                        }
                        break;

                    case SOURCES_SOURCES_OPTIONS:
                        fCleanNTTargetFile0 = fClean && strstr(pValue, "-c0");
                        break;

                    case SOURCES_NTTARGETFILE0:
                        DirDB->DirFlags |= DIRDB_TARGETFILE0;
                        if (fCleanNTTargetFile0) {
                            MakeMacroString(&DirDB->NTTargetFile0, pValue);
                        }
                        break;

                    case SOURCES_NTTARGETFILES:
                        DirDB->DirFlags |= DIRDB_TARGETFILES;
                        break;

                    case SOURCES_CHICAGO_PRODUCT:
                        DirDB->DirFlags |= DIRDB_CHICAGO_INCLUDES;
                        break;

                    case SOURCES_CONDITIONAL_INCLUDES:
                        MakeMacroString(&pds->ConditionalIncludes, pValue);
                        break;

                    case SOURCES_SYNCHRONIZE_BLOCK:
                        DirDB->DirFlags |= DIRDB_SYNCHRONIZE_BLOCK;
                        break;

                    case SOURCES_SYNCHRONIZE_DRAIN:
                        DirDB->DirFlags |= DIRDB_SYNCHRONIZE_DRAIN;
                        break;

                    case SOURCES_CHECKED_ALT_DIR:
                        DirDB->DirFlags |= DIRDB_CHECKED_ALT_DIR;
                        if (DEBUG_1) {
                            BuildMsg("Found CHECKED_ALT_DIR\n");
                        }
                        SetObjDir(TRUE);
                        if (fCheckedBuild) {
                            SaveMacro("_OBJ_DIR", pszObjDir);
                            if (iTarget < 0) {
                                SaveMacro("O", TargetMachines[0]->
                                          ObjectDirectory[iObjectDir]);
                            } else {
                                SaveMacro("O",
                                          PossibleTargetMachines[iTarget/2]->
                                          ObjectDirectory[iObjectDir]);
                            }
                        }
                        break;
                }
            }
            SaveMacro(TextLine, pValue);
            FreeString(&TextLine, MT_DIRSTRING);
        }

        // Subordinate files close themselves at EOF.  Timestamps
        // are propagated in CloseReadFile so the primary
        // file's timestamp is automatically updated.
    }

    // Close the primary file.
    DateTime = CloseReadFile(NULL);
    if (*pDateTimeSources < DateTime) {
        *pDateTimeSources = DateTime;       // keep newest timestamp
    }

    if (!pds->fNoTarget && (DirDB->TargetPath == NULL)) {
        strcpy(path, "sources.");
        SetupReadFile(DirDB->Name, path, "#", &InFileHandle);
        BuildError(
            "Unknown TARGETPATH value\n",
            NULL);
        CloseReadFile(NULL);
    }

    FreeMacros();

    if (fChicagoProduct) {
        DirDB->DirFlags |= DIRDB_CHICAGO_INCLUDES;
    }

    //
    // Directory has pass0 files in it (.idl, .mc, .asn, etc), check to make
    // sure they specified where the generated files should go.  Default to the
    // obj subdirectories if they didn't.  These always need to be non-null.
    //
    if (!pds->PassZeroHdrDir) {
        MakeString(&pds->PassZeroHdrDir, ".", TRUE, MT_DIRSTRING);
    }

    if (!pds->PassZeroSrcDir1) {
        MakeString(&pds->PassZeroSrcDir1, ".", TRUE, MT_DIRSTRING);
    }

    if (!pds->PassZeroSrcDir2)
        MakeString(&pds->PassZeroSrcDir2, pds->PassZeroSrcDir1, TRUE, MT_DIRSTRING);

    if (DirDB->UserTests != NULL) {
        _strlwr(DirDB->UserTests);
    }
    if (DirDB->UserAppls != NULL) {
        if (DirDB->UserTests != NULL || strchr(DirDB->UserAppls, '*') != NULL) {
            DirDB->DirFlags |= DIRDB_FORCELINK; // multiple targets
        }
    }

    PostProcessSources(DirDB, pds);

    if (DEBUG_1) {
        PrintDirDB(DirDB, 1|2);
        PrintDirSupData(pds);
        PrintDirDB(DirDB, 4);
    }

    pds->DateTimeSources = *pDateTimeSources;

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   PostProcessSources
//
//  Synopsis:   Scan the files in the given directory and add files to the
//              directory's list of source files (SOURCEREC), including PCH
//              files, UMTEST files, etc.
//
//  Arguments:  [pdr] -- Directory to process
//              [pds] -- Directory supplemental information
//
//----------------------------------------------------------------------------

void
PostProcessSources(DIRREC *pdr, DIRSUP *pds)
{
    PFILEREC FileDB, *FileDBNext;
    char path[DB_MAX_PATH_LENGTH];
    LPSTR p, p1;
    UINT i;

    for (i = 0; i < MAX_TARGET_MACHINES + 1; i++) {
        if (pds->SourcesVariables[i] != NULL) {
            CrackSources(pdr, pds, i);
        }
    }

    FileDBNext = &pdr->Files;
    while (FileDB = *FileDBNext) {

        if (pds->PchInclude && strcmp(FileDB->Name, pds->PchInclude) == 0) {
            InsertSourceDB(&pds->psrSourcesList[0], FileDB, 0, SOURCEDB_PCH);
            if (DEBUG_1) {
                BuildMsg("Adding PCH file to Sources List: %s.\n", FileDB->Name);
            }
        }

        if ((FileDB->FileFlags & (FILEDB_SOURCE | FILEDB_OBJECTS_LIST)) ==
            FILEDB_SOURCE) {

            p = FileDB->Name;
            p1 = path;
            while (*p != '\0' && *p != '.') {
                *p1++ = *p++;
            }
            *p1 = '\0';
            _strlwr(path);
            if (pdr->KernelTest != NULL &&
                !strcmp(path, pdr->KernelTest)) {

                FileDB->FileFlags |= FILEDB_OBJECTS_LIST;
            }
            else
            if (pdr->UserAppls != NULL &&
                (p = strstr(pdr->UserAppls, path)) &&
                (p == pdr->UserAppls || p[-1] == '*' || p[-1] == ' ')) {
                FileDB->FileFlags |= FILEDB_OBJECTS_LIST;
            }
            else
            if (pdr->UserTests != NULL &&
                (p = strstr(pdr->UserTests, path)) &&
                (p == pdr->UserTests || p[-1] == '*' || p[-1] == ' ')) {

                FileDB->FileFlags |= FILEDB_OBJECTS_LIST;
            }
            if (FileDB->FileFlags & FILEDB_OBJECTS_LIST) {
                InsertSourceDB(&pds->psrSourcesList[0], FileDB, 0, 0);
            }
        }
        FileDBNext = &FileDB->Next;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadDirsFile
//
//  Synopsis:   Parse the DIRS file
//
//  Arguments:  [DirDB] -- Directory to look in
//
//  Returns:    TRUE if parsed
//
//  Notes:      The existence of a file named 'mydirs' or the name of the
//              target specific dirs will override the normal 'dirs' file.
//
//----------------------------------------------------------------------------

BOOL
ReadDirsFile(
    PDIRREC DirDB
    )

{
    FILE *InFileHandle;
    LPSTR TextLine, pValue;
    LPSTR apszDirs[] = { "mydirs.", NULL, "dirs.", NULL };
    CHAR TargetName[16];

    strcpy(&TargetName[0], pszTargetDirs);
    strcat(&TargetName[0], ".");
    apszDirs[1] = &TargetName[0];

    for (ppCurrentDirsFileName = apszDirs;
         *ppCurrentDirsFileName != NULL;
         ppCurrentDirsFileName++) {
        if (SetupReadFile(DirDB->Name, *ppCurrentDirsFileName, "#", &InFileHandle)) {
            break;
        }
    }

    if (*ppCurrentDirsFileName == NULL) {
        FreeMacros();
        return(FALSE);
    }

    if (fFirstScan && (ppCurrentDirsFileName <= &apszDirs[1])) {
        BuildMsg("Using .\\%s instead of DIRS...\n",
                 FormatPathName(DirDB->Name, *ppCurrentDirsFileName));
    }

    if (DEBUG_1) {
        BuildMsg(
            "    Scanning file %s\n",
            FormatPathName(DirDB->Name, *ppCurrentDirsFileName));
    }

    assert(cMacro == 0);
    while ((TextLine = ReadLine(InFileHandle)) != NULL) {
        if ((pValue = SplitMacro(&TextLine)) != NULL) {
            SaveMacro(TextLine, pValue);
            FreeString(&TextLine, MT_DIRSTRING);
        }
    }
    CloseReadFile(NULL);
    if ((pValue = FindMacro("DIRS")) != NULL) {
        MarkDirNames(DirDB, pValue, TRUE);
    }
    if ((pValue = FindMacro("OPTIONAL_DIRS")) != NULL) {
        MarkDirNames(DirDB, pValue, FALSE);
    }
    if ((FindMacro("SYNCHRONIZE_DRAIN")) != NULL) {
        DirDB->DirFlags |= DIRDB_SYNCHRONIZE_DRAIN;
    }
    FreeMacros();
    return( TRUE );
}


//
// Debugging and Utility Functions
//

VOID
PrintDirSupData(DIRSUP *pds)
{
    int i;

    if (pds->LocalIncludePath != NULL) {
        BuildMsgRaw("  LocalIncludePath: %s\n", pds->LocalIncludePath);
    }
    if (pds->UserIncludePath != NULL) {
        BuildMsgRaw("  UserIncludePath: %s\n", pds->UserIncludePath);
    }
    if (pds->LastIncludePath != NULL) {
        BuildMsgRaw("  LastIncludePath: %s\n", pds->LastIncludePath);
    }
    if (pds->TestType != NULL) {
        BuildMsgRaw("  TestType: %s\n", pds->TestType);
    }
    if (pds->PchIncludeDir != NULL) {
        BuildMsgRaw("  PchIncludeDir: %s\n", pds->PchIncludeDir);
    }
    if (pds->PchInclude != NULL) {
        BuildMsgRaw("  PchInclude: %s\n", pds->PchInclude);
    }
    if (pds->PchTargetDir != NULL) {
        BuildMsgRaw("  PchTargetDir: %s\n", pds->PchTargetDir);
    }
    if (pds->PchTarget != NULL) {
        BuildMsgRaw("  PchTarget: %s\n", pds->PchTarget);
    }
    if (pds->ConditionalIncludes != NULL) {
        BuildMsgRaw("  ConditionalIncludes: %s\n", pds->ConditionalIncludes);
    }
    for (i = 0; i < MAX_TARGET_MACHINES + 1; i++) {
        if (pds->SourcesVariables[i] != NULL) {
            BuildMsgRaw(
                "  SourcesVariables[%d]: %s\n",
                i,
                pds->SourcesVariables[i]);
        }
        if (pds->psrSourcesList[i] != NULL) {
            BuildMsgRaw("  SourcesList[%d]:\n", i);
            PrintSourceDBList(pds->psrSourcesList[i], i - 1);
        }
    }
}


VOID
FreeDirSupData(DIRSUP *pds)
{
    int i;

    if (pds->LocalIncludePath != NULL) {
        FreeMem(&pds->LocalIncludePath, MT_DIRSTRING);
    }
    if (pds->UserIncludePath != NULL) {
        FreeMem(&pds->UserIncludePath, MT_DIRSTRING);
    }
    if (pds->LastIncludePath != NULL) {
        FreeMem(&pds->LastIncludePath, MT_DIRSTRING);
    }
    if (pds->TestType != NULL) {
        FreeMem(&pds->TestType, MT_DIRSTRING);
    }
    if (pds->PchInclude != NULL) {
        FreeMem(&pds->PchInclude, MT_DIRSTRING);
    }
    if (pds->PchIncludeDir != NULL) {
        FreeMem(&pds->PchIncludeDir, MT_DIRSTRING);
    }
    if (pds->PchTargetDir != NULL) {
        FreeMem(&pds->PchTargetDir, MT_DIRSTRING);
    }
    if (pds->PchTarget != NULL) {
        FreeMem(&pds->PchTarget, MT_DIRSTRING);
    }
    if (pds->ConditionalIncludes != NULL) {
        FreeMem(&pds->ConditionalIncludes, MT_DIRSTRING);
    }
    if (pds->PassZeroHdrDir != NULL) {
        FreeMem(&pds->PassZeroHdrDir, MT_DIRSTRING);
    }
    if (pds->PassZeroSrcDir1 != NULL) {
        FreeMem(&pds->PassZeroSrcDir1, MT_DIRSTRING);
    }
    if (pds->PassZeroSrcDir2 != NULL) {
        FreeMem(&pds->PassZeroSrcDir2, MT_DIRSTRING);
    }
    for (i = 0; i < MAX_TARGET_MACHINES + 1; i++) {
        if (pds->SourcesVariables[i] != NULL) {
            FreeMem(&pds->SourcesVariables[i], MT_DIRSTRING);
        }
        while (pds->psrSourcesList[i] != NULL) {
            FreeSourceDB(&pds->psrSourcesList[i]);
        }
    }
}


VOID
FreeDirData(DIRREC *pdr)
{
    if (pdr->TargetPath != NULL) {
        FreeMem(&pdr->TargetPath, MT_DIRSTRING);
    }
    if (pdr->TargetPathLib != NULL) {
        FreeMem(&pdr->TargetPathLib, MT_DIRSTRING);
    }
    if (pdr->TargetName != NULL) {
        FreeMem(&pdr->TargetName, MT_DIRSTRING);
    }
    if (pdr->KernelTest != NULL) {
        FreeMem(&pdr->KernelTest, MT_DIRSTRING);
    }
    if (pdr->UserAppls != NULL) {
        FreeMem(&pdr->UserAppls, MT_DIRSTRING);
    }
    if (pdr->UserTests != NULL) {
        FreeMem(&pdr->UserTests, MT_DIRSTRING);
    }
    if (pdr->NTTargetFile0 != NULL) {
        FreeMem(&pdr->NTTargetFile0, MT_DIRSTRING);
    }
    if (pdr->Pch != NULL) {
        FreeMem(&pdr->Pch, MT_DIRSTRING);
    }
    if (pdr->PchObj != NULL) {
        FreeMem(&pdr->PchObj, MT_DIRSTRING);
    }
    if (pdr->pds != NULL) {
        FreeDirSupData(pdr->pds);
        FreeMem(&pdr->pds, MT_DIRSUP);
        pdr->pds = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MarkDirNames
//
//  Synopsis:   Parses a DIRS= or OPTIONAL_DIRS line and marks the directories
//              appropriately.
//
//  Arguments:  [DirDB]    -- Directory containing DIRS file
//              [TextLine] -- DIRS= or OPTIONAL_DIRS= line
//              [Required] -- Indicates if directories are optional or not.
//
//----------------------------------------------------------------------------

VOID
MarkDirNames(PDIRREC DirDB, LPSTR TextLine, BOOL Required)
{
    UINT i;
    LPSTR p, token;
    PFILEREC FileDB, *FileDBNext;
    char dirbuf[DB_MAX_PATH_LENGTH];
    ULONG DirInclude;

    AssertPathString(TextLine);
    while (SplitToken(dirbuf, '*', &TextLine)) {
        // Assume all platforms are included for this dir.
        DirInclude = DIR_INCLUDE_ALL;
        for (p = dirbuf; *p != '\0'; p++) {
            if (*p == '{') {
                // An explicit include path was listed.
                DirInclude = DIR_INCLUDE_NONE;
                *p = '\0';
                token = strtok(p+1, ",}");
                while (token) {
                    if (!_stricmp(token, "X86") ||
                        !_stricmp(token, "I386") ||
                        !_stricmp(token, "386"))
                    {
                        DirInclude |= DIR_INCLUDE_X86;
                    } else if (!_stricmp(token, "ALPHA")) {
                        DirInclude |= DIR_INCLUDE_ALPHA;
                    } else if (!_stricmp(token, "32") ||
                               !_stricmp(token, "Win32"))
                    {
                        DirInclude |= DIR_INCLUDE_WIN32;
                    } else if (!_stricmp(token, "64") ||
                               !_stricmp(token, "Win64"))
                    {
                        DirInclude |= DIR_INCLUDE_WIN64;
                    } else if (!_stricmp(token, "IA64")) {
                        DirInclude |= DIR_INCLUDE_IA64;
                    } else if (!_stricmp(token, "ALPHA64")) {
                        DirInclude |= DIR_INCLUDE_ALPHA64;
                    } else if (!_stricmp(token, "RISC")) {
                        DirInclude |= DIR_INCLUDE_RISC;
                    }
                    token = strtok(NULL, ",}");
                }
                break;
            } else {
                if (!iscsym(*p) && *p != '.' && *p != '-') {
                    BuildError(
                        "%s: ignoring bad subdirectory: %s\n",
                        DirDB->Name,
                        dirbuf);
                    p = NULL;
                    break;
                }
            }
        }

        if (!(DirInclude & TargetMachines[0]->DirIncludeMask)) {
            continue;
        }

        if (p != NULL) {
            if (!Required) {
                for (i = 0; i < CountOptionalDirs; i++) {
                    if (!strcmp(dirbuf, OptionalDirs[i])) {
                        OptionalDirsUsed[i] = TRUE;
                        break;
                    }
                }
                if (i >= CountOptionalDirs) {
                    p = NULL;
                }
            }
            else {
                for (i = 0; i < CountExcludeDirs; i++) {
                    if (!strcmp(dirbuf, ExcludeDirs[i])) {
                        ExcludeDirsUsed[i] = TRUE;
                        p = NULL;
                        break;
                    }
                }
            }
        }
        if (p != NULL) {
            if ((fQuicky || fSemiQuicky) && (!fQuickZero)) {
                FileDB = InsertFileDB(
                            DirDB,
                            dirbuf,
                            0,
                            FILE_ATTRIBUTE_DIRECTORY,
                            0);
                if (FileDB != NULL) {
                    FileDB->SubDirIndex = ++DirDB->CountSubDirs;
                }
            }
            else {
                FileDBNext = &DirDB->Files;
                while (FileDB = *FileDBNext) {
                    if (FileDB->FileFlags & FILEDB_DIR) {
                        if (!strcmp(dirbuf, FileDB->Name)) {
                            FileDB->SubDirIndex = ++DirDB->CountSubDirs;
                            break;
                        }
                    }
                    FileDBNext = &FileDB->Next;
                }
                if (FileDB == NULL) {
                    BuildError(
                        "%s found in %s, is not a subdirectory of %s\n",
                        dirbuf,
                        FormatPathName(DirDB->Name, *ppCurrentDirsFileName),
                        DirDB->Name);
                }
            }

        }
    }
}

VOID
StartElapsedTime(VOID)
{
    // we don't want to check for fElapsedTime since if we want XML file, we need it anyway 
    // and single GetTickCount() call is not a perf hit
    if (StartTime == 0) {
        StartTime = GetTickCount();
    }
}

VOID
StartDirectoryElapsedTime(VOID)
{
    DirectoryStartTime = GetTickCount();
}

VOID
PrintElapsedTime(VOID)
{
    DWORD ElapsedTime;
    DWORD ElapsedHours;
    DWORD ElapsedMinutes;
    DWORD ElapsedSeconds;
    DWORD ElapsedMilliseconds;

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    if (fPrintElapsed) {
        ElapsedTime = GetTickCount() - StartTime;
        ElapsedHours = ElapsedTime/(1000 * 60 * 60);
        ElapsedTime = ElapsedTime % (1000 * 60 * 60);
        ElapsedMinutes = ElapsedTime/(1000 * 60);
        ElapsedTime = ElapsedTime % (1000 * 60);
        ElapsedSeconds = ElapsedTime/1000;
        ElapsedMilliseconds = ElapsedTime % 1000;
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN);
        BuildMsg(
            "Elapsed time [%d:%02d:%02d.%03d]\n",
            ElapsedHours,
            ElapsedMinutes,
            ElapsedSeconds,
            ElapsedMilliseconds);
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), csbi.wAttributes);
        LogMsg(
            "Elapsed time [%d:%02d:%02d.%03d]%s\n",
            ElapsedHours,
            ElapsedMinutes,
            ElapsedSeconds,
            ElapsedMilliseconds,
            szAsterisks);
    }
}

LPSTR
FormatElapsedTime(DWORD dwStartTime)
{
    static char FormatElapsedTimeBuffer[16];

    DWORD ElapsedTime;
    DWORD ElapsedHours;
    DWORD ElapsedMinutes;
    DWORD ElapsedSeconds;
    DWORD ElapsedMilliseconds;

    ElapsedTime = GetTickCount() - dwStartTime;
    ElapsedHours = ElapsedTime/(1000 * 60 * 60);
    ElapsedTime = ElapsedTime % (1000 * 60 * 60);
    ElapsedMinutes = ElapsedTime/(1000 * 60);
    ElapsedTime = ElapsedTime % (1000 * 60);
    ElapsedSeconds = ElapsedTime/1000;
    ElapsedMilliseconds = ElapsedTime % 1000;

    sprintf(
        FormatElapsedTimeBuffer, 
        "%d:%02d:%02d.%03d",
        ElapsedHours,
        ElapsedMinutes,
        ElapsedSeconds,
        ElapsedMilliseconds);

    return( FormatElapsedTimeBuffer );
}

LPSTR
FormatCurrentDateTime()
{
    static char FormatCurrentDateTimeBuffer[18];
	SYSTEMTIME st;

	GetLocalTime(&st);
    sprintf(
        FormatCurrentDateTimeBuffer,
        "%04d%02d%02d%02d%02d%02d%03d",
        st.wYear, st.wMonth, st.wDay, 
        st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    return ( FormatCurrentDateTimeBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\build\buildscn.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994
//
//  File:       buildscn.c
//
//  Contents:   Directory and File scanning functions for Build.exe
//
//
//  History:    16-May-89     SteveWo  Created
//                  ... see SLM logs
//              26-Jul-94     LyleC    Cleanup/Add pass0 support
//
//----------------------------------------------------------------------------

#include "build.h"

//+---------------------------------------------------------------------------
//
//  Function:   AddShowDir
//
//  Synopsis:   Add a directory to the ShowDir array
//
//----------------------------------------------------------------------------

VOID
AddShowDir(DIRREC *pdr)
{
    AssertDir(pdr);
    if (CountShowDirs >= MAX_BUILD_DIRECTORIES) {
        static BOOL fError = FALSE;

        if (!fError) {
            BuildError(
                "Show Directory table overflow, using first %u entries\n",
                MAX_BUILD_DIRECTORIES);
                fError = TRUE;
        }
    }
    else {
        ShowDirs[CountShowDirs++] = pdr;
    }
    pdr->DirFlags |= DIRDB_SHOWN;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddIncludeDir
//
//  Synopsis:   Add a directory to the IncludeDirs array
//
//----------------------------------------------------------------------------

VOID
AddIncludeDir(DIRREC *pdr, UINT *pui)
{
    AssertDir(pdr);
    assert(pdr->FindCount >= 1);
    assert(*pui <= MAX_INCLUDE_DIRECTORIES);
    if (*pui >= MAX_INCLUDE_DIRECTORIES) {
        BuildError(
            "Include Directory table overflow, %u entries allowed\n",
            MAX_INCLUDE_DIRECTORIES);
        exit(16);
    }
    IncludeDirs[(*pui)++] = pdr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanGlobalIncludeDirectory
//
//  Synopsis:   Scans a global include directory and adds it to the
//              IncludeDir array.
//
//----------------------------------------------------------------------------

VOID
ScanGlobalIncludeDirectory(LPSTR path)
{
    DIRREC *pdr;

    if ((pdr = ScanDirectory(path)) != NULL) {
        AddIncludeDir(pdr, &CountIncludeDirs);
        pdr->DirFlags |= DIRDB_GLOBAL_INCLUDES;
        if (fShowTreeIncludes && !(pdr->DirFlags & DIRDB_SHOWN)) {
            AddShowDir(pdr);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanIncludeDir
//
//----------------------------------------------------------------------------

VOID
ScanIncludeDir(LPSTR IncludeDir)
{
	// 24-Sep-1999 LeoN: added conditional. Some expansion failures can result in NULL IncludeDir.
	if (IncludeDir)
	{
		char Inc[DB_MAX_PATH_LENGTH];

		if (DEBUG_1) {
			BuildMsgRaw("ScanIncludeDir(%s)\n", IncludeDir);
		}
		sprintf(Inc, IncludeDir, NtRoot);
		ScanGlobalIncludeDirectory(Inc);
	}
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanIncludeEnv
//
//  Synopsis:   Scans all include directories specified in the INCLUDE
//              environment variable.
//
//  Arguments:  [IncludeEnv] -- value of the INCLUDE environment variable.
//
//  Notes:      The INCLUDE variable is a string with a list of directories
//              separated by semicolons (;).
//
//----------------------------------------------------------------------------

VOID
ScanIncludeEnv(
    LPSTR IncludeEnv
    )
{
    char path[DB_MAX_PATH_LENGTH];
    LPSTR IncDir, IncDirEnd;
    UINT cb;

    if (!IncludeEnv) {
        return;
        }

    if (DEBUG_1) {
        BuildMsgRaw("ScanIncludeEnv(%s)\n", IncludeEnv);
    }

    IncDir = IncludeEnv;
    while (*IncDir) {
        IncDir++;
        }

    while (IncDir > IncludeEnv) {
        IncDirEnd = IncDir;
        while (IncDir > IncludeEnv) {
            if (*--IncDir == ';') {
                break;
                }
            }

        if (*IncDir == ';') {
            if (cb = (UINT)(IncDirEnd-IncDir-1)) {
                strncpy( path, IncDir+1, cb );
                }
            }
        else {
            if (cb = (UINT)(IncDirEnd-IncDir)) {
                strncpy( path, IncDir, cb );
                }
            }
        path[ cb ] = '\0';
        while (path[ 0 ] == ' ') {
            strcpy( path, &path[ 1 ] );
            cb--;
            }

        while (cb > 0 && path[--cb] == ' ') {
            path[ cb ] = '\0';
            }

        if (path[0]) {
            ScanGlobalIncludeDirectory(path);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanSubDir
//
//  Synopsis:   Scans all the files in the given directory, sets the
//              directory flags appropriately (e.g.  DIRDB_SOURCES, etc),
//              and adds a list of interesting files to the Files list in
//              the DirDB structure for the directory.
//
//  Arguments:  [pszDir] -- Name of directory to scan
//              [pdr]    -- [out] Filled in DIRREC on return
//
//  Notes:      An 'interesting' file is one which has a recognized
//              extension.  See the InsertFileDB and MatchFileDesc
//              functions for more info.
//
//----------------------------------------------------------------------------

VOID
ScanSubDir(LPSTR pszDir, DIRREC *pdr)
{
    char FileName[DB_MAX_PATH_LENGTH];
    FILEREC *FileDB, **FileDBNext;
    WIN32_FIND_DATA FindFileData;
    HDIR FindHandle;
    ULONG DateTime;
    USHORT Attr;

    strcat(pszDir, "\\");
    strcat(pszDir, "*.*");

    pdr->DirFlags |= DIRDB_SCANNED;
    FindHandle = FindFirstFile(pszDir, &FindFileData);
    if (FindHandle == (HDIR)INVALID_HANDLE_VALUE) {
        if (DEBUG_1) {
            BuildMsg("FindFirstFile(%s) failed.\n", pszDir);
        }
        return;
    }
    do {
        Attr = (USHORT)(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
        if ((Attr & FILE_ATTRIBUTE_DIRECTORY) &&
            (!strcmp(FindFileData.cFileName, ".") ||
             !strcmp(FindFileData.cFileName, ".."))) {
            continue;
        }

        CopyString(FileName, FindFileData.cFileName, TRUE);

        FileTimeToDosDateTime(&FindFileData.ftLastWriteTime,
                              ((LPWORD) &DateTime) + 1,
                              (LPWORD) &DateTime);

        if ((pdr->DirFlags & DIRDB_NEW) == 0 &&
            (FileDB = LookupFileDB(pdr, FileName)) != NULL) {

            if (FileDB->FileFlags & FILEDB_PASS0)
                pdr->DirFlags |= DIRDB_PASS0;

            //
            // Clear the file missing flag, since we know the file exists now.
            // This flag may be set if the file was generated during pass zero.
            //
            if (FileDB->FileFlags & FILEDB_FILE_MISSING)
                FileDB->FileFlags &= ~FILEDB_FILE_MISSING;

            //
            // The time we last stored for this file is different than the
            // actual time on the file, so force it to be rescanned.
            //
            if (FileDB->DateTime != DateTime) {
                if (FileDB->FileFlags & (FILEDB_SOURCE | FILEDB_HEADER)) {
                    FileDB->FileFlags &= ~FILEDB_SCANNED;
                }
                else {
                    FileDB->FileFlags |= FILEDB_SCANNED;
                }

                if (DEBUG_1) {
                    BuildMsg(
                        "%s  -  DateTime (%lx != %lx)\n",
                        FileDB->Name,
                        FileDB->DateTime,
                        DateTime);
                }

                FileDB->DateTime = DateTime;
                FileDB->Attr = Attr;
            }
            else {
                FileDB->FileFlags |= FILEDB_SCANNED;
            }
        }
        else {
            FileDB = InsertFileDB(pdr, FileName, DateTime, Attr, 0);
        }
    } while (FindNextFile(FindHandle, &FindFileData));

    FindClose(FindHandle);

    if ((pdr->DirFlags & DIRDB_DIRS) && (pdr->DirFlags & DIRDB_SOURCES))
    {
        BuildError("%s\\sources. unexpected in directory with DIRS file\n",
                   pdr->Name);
        BuildError("Ignoring %s\\sources.\n", pdr->Name);

        pdr->DirFlags &= ~DIRDB_SOURCES;
    }
    //
    // Scan each file in this directory unless using QuickZero
    //
    if (fQuickZero && fFirstScan)
    {
       return;
    }
    FileDBNext = &pdr->Files;
    while (FileDB = *FileDBNext) {
        if (!(FileDB->FileFlags & (FILEDB_DIR | FILEDB_SCANNED))) {
            if (ScanFile(FileDB)) {
                AllDirsModified = TRUE;
            }
        }
        FileDBNext = &FileDB->Next;
    }
    DeleteUnscannedFiles(pdr);
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanDirectory
//
//  Synopsis:   Tries to find the given directory in the database, and if
//              not found calls ScanSubDir.
//
//  Arguments:  [pszDir] -- Directory to scan
//
//  Returns:    Filled in DIRREC structure for the directory.
//
//  Notes:      If fQuicky (-z or -Z options) are set, then instead of calling
//              ScanSubDir, which is long, it just checks for known files, like
//              'sources' for 'makefile' to determine whether or not the
//              directory should be compiled.
//
//----------------------------------------------------------------------------

PDIRREC
ScanDirectory(LPSTR pszDir)
{
    DIRREC *pdr;
    char FullPath[DB_MAX_PATH_LENGTH];

    if (DEBUG_1) {
        BuildMsgRaw("ScanDirectory(%s)\n", pszDir);
    }

    if (!CanonicalizePathName(pszDir, CANONICALIZE_DIR, FullPath)) {
        if (DEBUG_1) {
            BuildMsgRaw("CanonicalizePathName failed\n");
        }
        return(NULL);
    }
    pszDir = FullPath;

    if ((pdr = LoadDirDB(pszDir)) == NULL) {
        return(NULL);
    }

    if (fQuicky && (!fQuickZero)) {

        if (!(pdr->DirFlags & DIRDB_SCANNED)) {
            pdr->DirFlags |= DIRDB_SCANNED;
            if (ProbeFile(pdr->Name, "sources") != -1) {
                pdr->DirFlags |= DIRDB_SOURCES | DIRDB_MAKEFILE;
            }
            else
            if (ProbeFile(pdr->Name, "mydirs") != -1 ||
                ProbeFile(pdr->Name, "dirs") != -1 ||
                ProbeFile(pdr->Name, pszTargetDirs) != -1) {

                pdr->DirFlags |= DIRDB_DIRS;
                if (ProbeFile(pdr->Name, "makefil0") != -1) {
                    pdr->DirFlags |= DIRDB_MAKEFIL0;
                }
                if (ProbeFile(pdr->Name, "makefil1") != -1) {
                    pdr->DirFlags |= DIRDB_MAKEFIL1;
                }
                if (ProbeFile(pdr->Name, "makefile") != -1) {
                    pdr->DirFlags |= DIRDB_MAKEFILE;
                }
            }
        }
        return(pdr);
    }

    if (pdr->DirFlags & DIRDB_SCANNED) {
        return(pdr);
    }

    if (!RecurseLevel && fNoisyScan) {
        ClearLine();
        BuildMsgRaw("    Scanning %s ", pszDir);
        if (fDebug || !(BOOL) _isatty(_fileno(stderr))) {
            BuildMsgRaw(szNewLine);
        }
    }

    ScanSubDir(pszDir, pdr);

    if (!RecurseLevel) {
        ClearLine();
    }
    return(pdr);
}


#define BUILD_TLIB_INCLUDE_STMT "importlib"
#define BUILD_TLIB_INCLUDE_STMT_LENGTH (sizeof( BUILD_TLIB_INCLUDE_STMT )-1)

#define BUILD_MIDL_INCLUDE_STMT "import"
#define BUILD_MIDL_INCLUDE_STMT_LENGTH (sizeof( BUILD_MIDL_INCLUDE_STMT )-1)

#define BUILD_RC_INCLUDE_STMT "rcinclude"
#define BUILD_RC_INCLUDE_STMT_LENGTH (sizeof( BUILD_RC_INCLUDE_STMT )-1)

#define BUILD_ASN_INCLUDE_STMT "--<"
#define BUILD_ASN_INCLUDE_STMT_LENGTH (sizeof( BUILD_ASN_INCLUDE_STMT )-1)

#define BUILD_INCLUDE_STMT "include"
#define BUILD_INCLUDE_STMT_LENGTH (sizeof( BUILD_INCLUDE_STMT )-1)

#define BUILD_VER_COMMENT "/*++ BUILD Version: "
#define BUILD_VER_COMMENT_LENGTH (sizeof( BUILD_VER_COMMENT )-1)

#define BUILD_MASM_VER_COMMENT ";;;; BUILD Version: "
#define BUILD_MASM_VER_COMMENT_LENGTH (sizeof( BUILD_MASM_VER_COMMENT )-1)


//+---------------------------------------------------------------------------
//
//  Function:   IsIncludeStatement
//
//  Synopsis:   Tries to determine whether or not a given line contains an
//              include statement (e.g. #include <foobar.h> ).
//
//  Arguments:  [pfr] -- FILEREC of file being scanned
//              [p]   -- Current line of file
//
//  Returns:    NULL if line is not an include statment.  Returns pointer to
//              beginning of filename if it is (e.g. <foobar.h> ).
//
//  Notes:      The returned filename includes the surrounding quotes or
//              brackets, if any.  Also, the pointer is just a pointer into
//              the given string, not a separate copy.
//
//              Supported statements are:
//              All file types: #include <filename> and #include "filename"
//              MIDL files:     import "filename"
//              RC files:       rcinclude filename
//              MKTYPLIB files: importlib("filename")
//
//----------------------------------------------------------------------------

#define IsTokenPrefix0(psz, szToken, cchToken)               \
            (strncmp((psz), (szToken), (cchToken)) == 0)

#define IsTokenPrefix(psz, szToken, cchToken)               \
            (IsTokenPrefix0((psz), (szToken), (cchToken)) && \
             (psz)[cchToken] != '\0')

#define IsTokenMatch(psz, szToken, cchToken) \
            (IsTokenPrefix((psz), (szToken), (cchToken)) && \
             !iscsym((psz)[cchToken]))

#define IsCiTokenPrefix0(psz, szToken, cchToken)             \
            (_strnicmp((psz), (szToken), (cchToken)) == 0)

#define IsCiTokenPrefix(psz, szToken, cchToken)             \
            (IsCiTokenPrefix0((psz), (szToken), (cchToken)) && \
             (psz)[cchToken] != '\0')

#define IsCiTokenMatch(psz, szToken, cchToken) \
            (IsCiTokenPrefix((psz), (szToken), (cchToken)) && \
             !iscsym((psz)[cchToken]))

LPSTR
IsIncludeStatement(FILEREC *pfr, LPSTR p)
{
    if (!p || *p == '\0')
        return NULL;

    if (!(pfr->FileFlags & (FILEDB_MASM | FILEDB_MIDL | FILEDB_MKTYPLIB | FILEDB_RC | FILEDB_ASN))) {
        if (*p != '#') {
            return(NULL);
        }
    }

    if (*p == '#')
        p++;

    while (isspace(*(BYTE*)p)) {
        p++;
    }

    if (IsTokenMatch(p, BUILD_INCLUDE_STMT, BUILD_INCLUDE_STMT_LENGTH)) {
        p += BUILD_INCLUDE_STMT_LENGTH;
    }
    else
    if ((pfr->FileFlags & FILEDB_MASM) &&
        IsCiTokenMatch(p, BUILD_INCLUDE_STMT, BUILD_INCLUDE_STMT_LENGTH)) {
        p += BUILD_INCLUDE_STMT_LENGTH;
    }
    else
    if ((pfr->FileFlags & FILEDB_MIDL) &&
        IsTokenMatch(p, BUILD_MIDL_INCLUDE_STMT, BUILD_MIDL_INCLUDE_STMT_LENGTH)) {
        p += BUILD_MIDL_INCLUDE_STMT_LENGTH;
    }
    else
    if ((pfr->FileFlags & FILEDB_RC) &&
        IsTokenMatch(p, BUILD_RC_INCLUDE_STMT, BUILD_RC_INCLUDE_STMT_LENGTH)) {

        p += BUILD_RC_INCLUDE_STMT_LENGTH;
    }
    else
    if ((pfr->FileFlags & FILEDB_ASN) &&
        IsTokenPrefix0(p, BUILD_ASN_INCLUDE_STMT, BUILD_ASN_INCLUDE_STMT_LENGTH)) {

        p += BUILD_ASN_INCLUDE_STMT_LENGTH;
    }
    else
    if ((pfr->FileFlags & FILEDB_MKTYPLIB) &&
        IsTokenMatch(p, BUILD_TLIB_INCLUDE_STMT, BUILD_TLIB_INCLUDE_STMT_LENGTH)) {
        p += BUILD_TLIB_INCLUDE_STMT_LENGTH;
        while (isspace(*(BYTE*)p)) {
            p++;
        }

        if (*p == '(')   // Skip the open paren and get to the quote.
            p++;
    }
    else {
        return(NULL);
    }

    while (isspace(*(BYTE*)p)) {
        p++;
    }
    return(p);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsPragmaHdrStop
//
//  Synopsis:   Determines if the given line is a #pragma hdrstop line
//
//  Arguments:  [p] -- String to analyze
//
//  Returns:    TRUE if the line is a pragma hdrstop
//
//----------------------------------------------------------------------------

BOOL
IsPragmaHdrStop(LPSTR p)
{
    static char szPragma[] = "pragma";
    static char szHdrStop[] = "hdrstop";

    if (*p == '#') {
        while (*++p == ' ') {
            ;
        }
        if (strncmp(p, szPragma, sizeof(szPragma) - 1) == 0 &&
            *(p += sizeof(szPragma) - 1) == ' ') {

            while (*p == ' ') {
                p++;
            }
            if (strncmp(p, szHdrStop, sizeof(szHdrStop) - 1) == 0 &&
                !iscsym(p[sizeof(szHdrStop) - 1])) {

                return(TRUE);
            }
        }
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanFile
//
//  Synopsis:   Scans the given file to determine files which it includes.
//
//  Arguments:  [FileDB] -- File to scan.
//
//  Returns:    TRUE if successful
//
//  Notes:      This function is a nop if the given file does not have either
//              the FILEDB_SOURCE or FILEDB_HEADER flag set.
//              (see InsertSourceDB)
//
//              Note that the performance of this function is critical since
//              it is called for every file in each directory.
//
//----------------------------------------------------------------------------

#define ASN_NONE          0  // not in Asn INCLUDES statement
#define ASN_START         1  // expectimg "INCLUDES" token
#define ASN_FILENAME      2  // expecting a quoted "filename"
#define ASN_COMMA         3  // expecting end token (">--") or comma

#define ASN_CONTINUATION  8  // expecting comment token first

char *
AsnStateToString(UINT AsnState)
{
    static char buf[100];
    char *psz;

    switch (AsnState & ~ASN_CONTINUATION) {
        case ASN_NONE:      psz = "None"; break;
        case ASN_START:     psz = "Start"; break;
        case ASN_FILENAME:  psz = "Filename"; break;
        case ASN_COMMA:     psz = "Comma"; break;
        default:            psz = "???"; break;
    }
    sprintf(buf, "%s%s", psz, (AsnState & ASN_CONTINUATION)? "+Cont" : "");
    return(buf);
}


BOOL
ScanFile(
    PFILEREC FileDB
    )
{
    FILE *FileHandle;
    char CloseQuote;
    LPSTR p;
    LPSTR IncludeFileName, TextLine;
    BOOL fFirst = TRUE;
    USHORT IncFlags = 0;
    UINT i, cline;
    UINT AsnState = ASN_NONE;

    if ((FileDB->FileFlags & (FILEDB_SOURCE | FILEDB_HEADER)) == 0) {
        FileDB->FileFlags |= FILEDB_SCANNED;
        return(TRUE);
    }

    //
    // Don't scan non-pass-zero files if we're doing pass zero.
    //
    if (fPassZero && (FileDB->FileFlags & FILEDB_PASS0) == 0)
        return TRUE;

    if (!SetupReadFile(
            FileDB->Dir->Name,
            FileDB->Name,
            FileDB->pszCommentToEOL,
            &FileHandle)) {
        return(FALSE);
    }

    if (!RecurseLevel && fNoisyScan) {
        ClearLine();
        BuildMsgRaw(
            "    Scanning %s ",
            FormatPathName(FileDB->Dir->Name, FileDB->Name));
        if (!(BOOL) _isatty(_fileno(stderr))) {
            BuildMsgRaw(szNewLine);
        }
    }

    FileDB->SourceLines = 0;
    FileDB->Version = 0;

    MarkIncludeFileRecords( FileDB );
    FileDB->FileFlags |= FILEDB_SCANNED;

    AllDirsModified = TRUE;

    while ((TextLine = ReadLine(FileHandle)) != NULL) {
        if (fFirst) {
            fFirst = FALSE;
            if (FileDB->FileFlags & FILEDB_HEADER) {
                if (FileDB->FileFlags & FILEDB_MASM) {
                    if (!strncmp( TextLine,
                                  BUILD_MASM_VER_COMMENT,
                                  BUILD_MASM_VER_COMMENT_LENGTH)) {
                        FileDB->Version = (USHORT)
                            atoi( TextLine + BUILD_MASM_VER_COMMENT_LENGTH);
                    }
                }
                else
                if (!strncmp( TextLine,
                              BUILD_VER_COMMENT,
                              BUILD_VER_COMMENT_LENGTH)) {
                    FileDB->Version = (USHORT)
                        atoi( TextLine + BUILD_VER_COMMENT_LENGTH);
                }
            }
        }

        if (AsnState != ASN_NONE) {
            p = TextLine;
        }
        else {
            p = IsIncludeStatement(FileDB, TextLine);
        }

        if (p != NULL) {
            USHORT IncFlagsNew = IncFlags;

            if (FileDB->FileFlags & FILEDB_ASN) {
                if (AsnState & ASN_CONTINUATION) {
                    if (p[0] != '-' || p[1] != '-') {
                        AsnState = ASN_NONE;    // ignore includes and ...
                        p = NULL;
                        break;                  // get next line
                    }
                    p += 2;
                    AsnState &= ~ASN_CONTINUATION;
                }
moreasn:
                while (p != NULL) {
                    while (isspace(*(BYTE*)p)) {
                        p++;
                    }
                    if (*p == '\0') {
                        AsnState |= ASN_CONTINUATION;
                        goto nextline;          // get next line
                    }
                    switch (AsnState) {
                        case ASN_NONE:
                            AsnState = ASN_START;
                            continue;                // re-enter state machine

                        case ASN_START:
                            if (!IsTokenPrefix0(
                                        p,
                                        "INCLUDES",
                                        sizeof("INCLUDES") - 1)) {
                                goto terminate;
                            }
                            AsnState = ASN_FILENAME;
                            p += sizeof("INCLUDES") - 1;
                            continue;                // re-enter state machine

                        case ASN_FILENAME:
                            if (*p != '"') {
                                goto terminate;
                            }
                            AsnState = ASN_COMMA;
                            goto parsefilename;

                        case ASN_COMMA:
                            if (*p == '>' && p[1] == '-' && p[2] == '-') {
                                goto terminate;
                            }
                            if (*p != ',') {
                                goto terminate;
                            }
                            p++;
                            AsnState = ASN_FILENAME;
                            continue;                // re-enter state machine
                    }
                    assert(FALSE);            // Bad AsnState
terminate:
                    AsnState = ASN_NONE;    // ignore includes statement, & ...
nextline:
                    p = NULL;               // get next line
                    break;
                }
            }

parsefilename:
            if (p != NULL) {
                CloseQuote = (UCHAR) 0xff;
                if (*p == '<') {
                    p++;
                    CloseQuote = '>';
                }
                else
                if (*p == '"') {
                    p++;
                    IncFlagsNew |= INCLUDEDB_LOCAL;
                    CloseQuote = '"';
                }
                else
                if (FileDB->FileFlags & FILEDB_MASM) {
                    IncFlagsNew |= INCLUDEDB_LOCAL;
                    CloseQuote = ';';
                }

                IncludeFileName = p;
                while (*p != '\0' && *p != CloseQuote && *p != ' ') {
                    p++;
                }
                if (CloseQuote == ';' && (*p == ' ' || *p == '\0')) {
                    CloseQuote = *p;
                }

                if (*p != CloseQuote || CloseQuote == (UCHAR) 0xff) {
                    if (!fSilentDependencies) {
                        BuildError(
                        "%s - invalid include statement: %s\n",
                        FormatPathName(FileDB->Dir->Name, FileDB->Name),
                        TextLine);
                    }
                    break;
                }

                *p = '\0';
                CopyString(IncludeFileName, IncludeFileName, TRUE);
                for (i = 0; i < CountExcludeIncs; i++) {
                    if (!strcmp(IncludeFileName, ExcludeIncs[i])) {
                        IncludeFileName = NULL;
                        break;
                    }
                }

                if (IncludeFileName != NULL) {
                    InsertIncludeDB(FileDB, IncludeFileName, IncFlagsNew);
                }
                if (FileDB->FileFlags & FILEDB_ASN) {
                    p++;
                    goto moreasn;
                }
            }
        }
        else
        if (IncFlags == 0 &&
            (FileDB->FileFlags & (FILEDB_ASM | FILEDB_MASM | FILEDB_MIDL | FILEDB_ASN | FILEDB_RC | FILEDB_HEADER)) == 0 &&
            IsPragmaHdrStop(TextLine)) {

            IncFlags = INCLUDEDB_POST_HDRSTOP;
        }
    }
    CloseReadFile(&cline);
    FileDB->SourceLines = cline;

    DeleteIncludeFileRecords( FileDB );

    if (!RecurseLevel) {
        ClearLine();
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\build\makefile.inc ===
build.c : $(BASEDIR)\public\sdk\inc\ntverp.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\buffer.c ===
#include "precomp.h"
#pragma hdrstop

CRITICAL_SECTION GlobalBufferCritSect;

UINT nGlobalBufferTotalMemory;
UINT nGlobalBufferGranularity;



typedef struct _NODE NODE, *PNODE;

struct _NODE {
    PNODE  pNextNode;
    PNODE  pPrevNode;
    PUCHAR pMem;
    UINT   nSize;
    };

#ifdef DEBUG
    BOOL bGlobalBufferAllocatorHasBeenInitialized;
#endif

NODE BusyList = { &BusyList, &BusyList, NULL, 0 };      // empty head node
NODE FreeList = { &FreeList, &FreeList, NULL, 0 };      // empty head node
NODE NodeList = { &NodeList, &NodeList, NULL, 0 };      // empty head node
NODE VirtList = { &VirtList, &VirtList, NULL, 0 };      // empty head node

typedef struct _WAITER WAITER, *PWAITER;

struct _WAITER {
    PWAITER pNextWaiter;
    PWAITER pPrevWaiter;
    HANDLE  hEvent;
    UINT    nRequestSize;
    PNODE   *ppNode;
    };


WAITER WaiterList = { &WaiterList, &WaiterList, NULL, 0, NULL };
WAITER WaiterPool = { &WaiterPool, &WaiterPool, NULL, 0, NULL };

VOID
LinkBefore(
    PNODE pListMember,
    PNODE pNode
    )
    {
    pNode->pNextNode            = pListMember;
    pNode->pPrevNode            = pListMember->pPrevNode;
    pNode->pNextNode->pPrevNode = pNode;
    pNode->pPrevNode->pNextNode = pNode;
    }


VOID
Unlink(
    PNODE pNode
    )
    {

    ASSERT( pNode != &BusyList );
    ASSERT( pNode != &FreeList );
    ASSERT( pNode != &NodeList );
    ASSERT( pNode != &VirtList );
    ASSERT( pNode != (PNODE) &WaiterList );
    ASSERT( pNode != (PNODE) &WaiterPool );

    pNode->pPrevNode->pNextNode = pNode->pNextNode;
    pNode->pNextNode->pPrevNode = pNode->pPrevNode;
    }


PNODE
AllocateNode(
    VOID
    )
    {
    PNODE pNode;

    pNode = NodeList.pNextNode;

    if ( pNode == &NodeList ) {
        pNode = MyAllocNeverFreeLocked( sizeof( NODE ));
        }
    else {
        Unlink( pNode );
        }

    return pNode;
    }


VOID
RecycleNode(
    PNODE pNode
    )
    {
    LinkBefore( NodeList.pNextNode, pNode );    // push at head of node list
    }


PNODE
FreeNodeToBusyNode(
    PNODE pFreeNode,
    UINT  nBusySize
    )
    {
    PNODE pBusyNode;

    ASSERT( pFreeNode->nSize >= nBusySize );

    if ( pFreeNode->nSize > nBusySize ) {

        //
        //  Split into two blocks
        //

        pBusyNode         = AllocateNode();
        pBusyNode->pMem   = pFreeNode->pMem;
        pBusyNode->nSize  = nBusySize;

        pFreeNode->pMem  += nBusySize;
        pFreeNode->nSize -= nBusySize;

        }
    else {

        //
        //  Using whole block
        //

        pBusyNode = pFreeNode;
        Unlink( pFreeNode );                // remove from free list

        }

    LinkBefore( &BusyList, pBusyNode );     // enqueue at tail of busy list

    return pBusyNode;
    }


BOOL
Adjacent(
    PNODE pLowerNode,
    PNODE pUpperNode
    )
    {
    return (( pLowerNode->pMem + pLowerNode->nSize ) == pUpperNode->pMem );
    }


VOID
BusyNodeToFreeNode(
    PNODE pBusyNode
    )
    {
    PNODE pNodeAfter;
    PNODE pNodeBefore;
    PNODE pFreeNode;

    Unlink( pBusyNode );    // remove from busy list

    pFreeNode = pBusyNode;  // just for namesake

    //
    // coalesce into free list
    //

    for ( pNodeAfter  = FreeList.pNextNode;
          pNodeAfter != &FreeList;
          pNodeAfter  = pNodeAfter->pNextNode ) {

        if ( pNodeAfter->pMem > pFreeNode->pMem ) {
            break;
            }
        }

    LinkBefore( pNodeAfter, pFreeNode );

    if ( Adjacent( pFreeNode, pNodeAfter )) {

        pFreeNode->nSize += pNodeAfter->nSize;
        Unlink( pNodeAfter );
        RecycleNode( pNodeAfter );

        }

    pNodeBefore = pFreeNode->pPrevNode;

    if ( Adjacent( pNodeBefore, pFreeNode )) {

        pNodeBefore->nSize += pFreeNode->nSize;
        Unlink( pFreeNode );
        RecycleNode( pFreeNode );

        }

    }


PNODE
FindFreeMem(
    UINT nRequestSize
    )
    {
    PNODE pProbeNode = FreeList.pNextNode;
    PNODE pFoundNode = NULL;
    UINT  nFoundSize = 0xFFFFFFFF;
    UINT  nProbeSize;

    while (( pProbeNode != &FreeList ) && ( nFoundSize > nRequestSize )) {

        nProbeSize = pProbeNode->nSize;

        if (( nProbeSize >= nRequestSize ) && ( nProbeSize < nFoundSize )) {
            pFoundNode = pProbeNode;
            nFoundSize = nProbeSize;
            }

        pProbeNode = pProbeNode->pNextNode;
        }

    if ( pFoundNode == NULL )
        return NULL;

    return FreeNodeToBusyNode( pFoundNode, nRequestSize );
    }


PNODE
FindBusyMem(
    PVOID pMem
    )
    {
    PNODE pNode = BusyList.pNextNode;

    while ( pNode != &BusyList ) {

        if ( pNode->pMem == pMem ) {
            return pNode;
            }

        pNode = pNode->pNextNode;
        }

    return NULL;
    }


PNODE
FindVirtMem(
    PVOID pMem
    )
    {
    PNODE pNode = VirtList.pNextNode;

    while ( pNode != &VirtList ) {

        if ( pNode->pMem == pMem ) {
            return pNode;
            }

        pNode = pNode->pNextNode;
        }

    return NULL;
    }


PWAITER
AllocateWaiter(
    VOID
    )
    {
    PWAITER pWaiter;

    pWaiter = WaiterPool.pNextWaiter;

    if ( pWaiter == &WaiterPool ) {
        pWaiter = MyAllocNeverFreeLocked( sizeof( WAITER ));
        }
    else {
        Unlink( (PNODE) pWaiter );
        }

    return pWaiter;
    }


VOID
RecycleWaiter(
    PWAITER pWaiter
    )
    {
    LinkBefore( (PNODE) WaiterPool.pNextWaiter, (PNODE) pWaiter );  // push
    }


VOID
DispatchAndDequeueWaiter(
    PWAITER pWaiter,
    PNODE   pNode
    )
    {
    *( pWaiter->ppNode ) = pNode;
    SetEvent( pWaiter->hEvent );
    Unlink( (PNODE) pWaiter );
    RecycleWaiter( pWaiter );
    }


PVOID
AllocateBuffer(
    UINT nRequestSize,
    BOOL bZeroMemory
    )
    {
    HANDLE  hEvent;
    PNODE   pNode;
    PWAITER pWaiter;
    UINT    nBufferSize;

    ASSERT( bGlobalBufferAllocatorHasBeenInitialized );

    nBufferSize = ROUNDUP2( nRequestSize, nGlobalBufferGranularity );

    if ( nBufferSize > nGlobalBufferTotalMemory ) {

        //
        //  This request cannot be met with buffer pool.
        //  Allocate a new VM for this request.
        //

        DEBUGCODE(
            printf(
                "Buffer request is %d (0x%X) bytes, allocating VM\r\n",
                nBufferSize,
                nBufferSize
                )
            );

        EnterCriticalSection( &GlobalBufferCritSect );

        pNode        = AllocateNode();
        ASSERT(pNode != NULL);
        pNode->pMem  = MyVirtualAlloc( nBufferSize );
        ASSERT(pNode->pMem != NULL);
        pNode->nSize = nBufferSize;

        LinkBefore( &VirtList, pNode );

        LeaveCriticalSection( &GlobalBufferCritSect );

        //
        //  MyVirtualAlloc provides already-zeroed memory.
        //

        }

    else {

        if ( nBufferSize == 0 ) {
            ASSERT( nBufferSize > 0 );
            ErrorExit( 0, "Requested buffer size is zero\r\n" );
            }

        EnterCriticalSection( &GlobalBufferCritSect );

        if ( WaiterList.pNextWaiter != &WaiterList ) {  // another waiter already waiting
            pNode = NULL;
            }
        else {
            pNode = FindFreeMem( nBufferSize );
            }

        if ( pNode == NULL ) {


            // BUGBUG
//            printf("Making a waiter for %u\r\n",GetCurrentThreadId());

            pWaiter               = AllocateWaiter();
            ASSERT(pWaiter != NULL);
            pWaiter->hEvent       = AllocateAutoEvent();
            ASSERT(pWaiter->hEvent != NULL);
            pWaiter->nRequestSize = nBufferSize;
            pWaiter->ppNode       = &pNode;

            LinkBefore( (PNODE) &WaiterList, (PNODE) pWaiter ); // enqueue at tail

            hEvent = pWaiter->hEvent;

            }
        else {
            hEvent = NULL;
            }

        LeaveCriticalSection( &GlobalBufferCritSect );

        if ( hEvent ) {
            WaitForSingleObject( hEvent, INFINITE );

            // BUGBUG
  //          printf("Done waiting %u\r\n",GetCurrentThreadId());

            RecycleAutoEvent( hEvent );
            ASSERT( pNode != NULL );
            }

        if ( bZeroMemory ) {
            ZeroMemory( pNode->pMem, nRequestSize );
            }

        }

    /*
#ifdef DEBUG

    ASSERT( pNode->nSize >= nRequestSize );

    if ( bZeroMemory ) {

        UINT TailBytes = pNode->nSize - nRequestSize;

        if ( TailBytes ) {
            memset( pNode->pMem + nRequestSize, 0xEE, TailBytes );
            }
        }

    else {

        memset( pNode->pMem, 0xEE, pNode->nSize );

        }

#endif // DEBUG
    printf("Allocating buffer at %p - %u\r\n",pNode->pMem,GetCurrentThreadId());
    */

    return pNode->pMem;
    }


VOID
ReleaseBuffer(
    PVOID pBuffer
    )
    {
    PNODE   pNode;
    PWAITER pWaiter;

    ASSERT( bGlobalBufferAllocatorHasBeenInitialized );

    EnterCriticalSection( &GlobalBufferCritSect );

    /*
#ifdef DEBUG
    printf("Releasing memory at %p - %u\r\n",pBuffer,GetCurrentThreadId());
#endif
    */

    pNode = FindVirtMem( pBuffer );

    if ( pNode != NULL ) {

        MyVirtualFree( pNode->pMem );
        Unlink( pNode );
        RecycleNode( pNode );

        }

    else {

        pNode = FindBusyMem( pBuffer );

        ASSERT( pNode != NULL );

        pWaiter = WaiterList.pNextWaiter;

        if (( pWaiter != &WaiterList ) && ( pWaiter->nRequestSize == pNode->nSize )) {
            DispatchAndDequeueWaiter( pWaiter, pNode );
            }
        else {

            BusyNodeToFreeNode( pNode );

            if ( pWaiter != &WaiterList ) {

                pNode = FindFreeMem( pWaiter->nRequestSize );

                if ( pNode != NULL ) {

                    DispatchAndDequeueWaiter( pWaiter, pNode );

                    }
                }
            }
        }

    LeaveCriticalSection( &GlobalBufferCritSect );
    }


DWORD
GetLargestFreeBufferSize(
    VOID
    )
    {
    UINT  nSize = 0;
    PNODE pNode;

    ASSERT( bGlobalBufferAllocatorHasBeenInitialized );

    EnterCriticalSection( &GlobalBufferCritSect );

    if ( WaiterList.pNextWaiter == &WaiterList ) {  // no waiters

        for ( pNode  = FreeList.pNextNode;
              pNode != &FreeList;
              pNode = pNode->pNextNode ) {

            if ( pNode->nSize > nSize )
                nSize = pNode->nSize;

            }
        }

    LeaveCriticalSection( &GlobalBufferCritSect );

    return nSize;
    }


DWORD
AdjustWorkingSetAndLockImage(
    DWORD MinimumRingBufferSize,
    DWORD IndividualBufferSize
    )
    {
    SYSTEM_INFO           SysInfo;
    MEMORYSTATUS          MemStatus      = { sizeof( MEMORYSTATUS ) };
    HANDLE                CurrentProcess = GetCurrentProcess();
    PVOID                 BaseOfImage    = GetModuleHandle( NULL );     // hopefully, base address of mapped cdimage.exe
    PIMAGE_DOS_HEADER     DosHeader;
    PIMAGE_NT_HEADERS     NtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG                 SectionSize;
    ULONG                 SectionCount;
    PVOID                 SectionBase;
    DWORD                 ImageLockSize;
    DWORD                 RingBufferSize;
    DWORD                 MinWorkingSet;
    DWORD                 MaxWorkingSet;
    DWORD                 BaseWorkingSet;
    BOOL                  bSuccess;

    GetSystemInfo( &SysInfo );

    GetProcessWorkingSetSize( CurrentProcess, &BaseWorkingSet, &MaxWorkingSet );

#ifdef DEBUG

    ASSERT( ISPOWER2( IndividualBufferSize ));
    ASSERT( ISALIGN2( IndividualBufferSize,  SysInfo.dwPageSize ));
    ASSERT( ISALIGN2( MinimumRingBufferSize, IndividualBufferSize ));

    printf( "InitialProcessWorkingSet: dwMin=%X, dwMax=%X\r\n", BaseWorkingSet, MaxWorkingSet );

#endif // DEBUG


    //
    //  Walk image section headers and determine size we want to lock down
    //  so we can increase the working set accordingly.
    //

    ImageLockSize = 0;

    try {

        DosHeader = BaseOfImage;

        if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {

            NtHeader = (PVOID)((PCHAR)BaseOfImage + DosHeader->e_lfanew );

            if ( NtHeader->Signature == IMAGE_NT_SIGNATURE ) {

                SectionHeader = (PVOID)((PCHAR)NtHeader +
                                        sizeof(ULONG)   +
                                        sizeof(IMAGE_FILE_HEADER) +
                                        NtHeader->FileHeader.SizeOfOptionalHeader
                                        );

                SectionCount = NtHeader->FileHeader.NumberOfSections;

                while ( SectionCount-- ) {

                    if (( memcmp( SectionHeader->Name, ".text",  6 ) == 0 ) ||
                        ( memcmp( SectionHeader->Name, ".data",  6 ) == 0 ) ||
                        ( memcmp( SectionHeader->Name, ".rdata", 7 ) == 0 ) ||
                        ( memcmp( SectionHeader->Name, ".idata", 7 ) == 0 )) {

                        SectionSize = SectionHeader->Misc.VirtualSize;

                        ImageLockSize += ROUNDUP2( SectionSize, SysInfo.dwPageSize );

                        }

                    SectionHeader++;

                    }
                }
            }
        }

    except( EXCEPTION_EXECUTE_HANDLER ) {

        DEBUGCODE( printf( "Exception walking module info\r\n" ));

        }

    if ( ImageLockSize == 0 )
         ImageLockSize = 0x40000;   // guestimate 256K if fail to walk image


    //
    //  Assume OS needs 8MB of physical memory, take remaining memory and
    //  use 1/4 of it for ring buffer (in case need to run multiple instances
    //  of cdimage).  On a 16MB system this will result in 2MB, 4MB on 24MB,
    //  6MB on 32MB, 8MB on 40MB, 14MB on 64MB, etc.
    //
    //  NOTE: On NT 4.0 Server system, the cache manager is a pig and keeps at
    //  least half of RAM to itself.
    //

    GlobalMemoryStatus( &MemStatus );

    if (( bOptimizeStorage ) && ( MemStatus.dwTotalPhys > 0x800000 )) {

        RingBufferSize = ROUNDUP2(
                             ( MemStatus.dwTotalPhys - 0x800000 ) / 4,
                             IndividualBufferSize
                             );

        if ( RingBufferSize < MinimumRingBufferSize ) {
             RingBufferSize = MinimumRingBufferSize;
             }
        }

    else {

        RingBufferSize = MinimumRingBufferSize;

        }

    MaxWorkingSet = MemStatus.dwTotalPhys / 2;      // don't exceed half of physical RAM

    MinWorkingSet = RingBufferSize + ImageLockSize + 0x10000;

    bSuccess = SetProcessWorkingSetSize(
                   CurrentProcess,
                   MinWorkingSet,
                   MaxWorkingSet
                   );

    if ( ! bSuccess ) {

        if ( GetLastError() == ERROR_PRIVILEGE_NOT_HELD ) {

            DEBUGCODE( printf( "Insufficient privilege to grow working set\r\n" ));

            printf(
                "\r\n"
                "WARNING: Current user does not have privilege to grow the process working set\r\n"
                "         which can increase the performance of creating an image.  To acquire\r\n"
                "         this privilege, the user can be made a member of the Administrators\r\n"
                "         group on the local machine, or the Adminstrator can grant the\r\n"
                "         \"Increase Scheduling Priority\" privilege to \"Everyone\" on the\r\n"
                "         local machine via MUSRMGR.EXE's \"Policy\", \"User Rights\" dialog.\r\n"
                "\r\n"
                );
            fflush( stdout );

            return MinimumRingBufferSize;
            }

        DEBUGCODE( printf( "SetWorkingSet( %X, %X ) failed (GLE=%d), trying incremental\r\n",
                           MinWorkingSet,
                           MaxWorkingSet,
                           GetLastError() ));

        bSuccess = TRUE;

        while (( bSuccess ) && ( BaseWorkingSet < MinWorkingSet )) {

            BaseWorkingSet += 0x10000;

            bSuccess = SetProcessWorkingSetSize(
                           CurrentProcess,
                           BaseWorkingSet,
                           MaxWorkingSet
                           );
            }

        BaseWorkingSet -= 0x10000;

        if ( BaseWorkingSet > MinimumRingBufferSize ) {

            RingBufferSize = BaseWorkingSet - MinimumRingBufferSize;

            }
        else {

            RingBufferSize = MinimumRingBufferSize;

            }
        }

    GetProcessWorkingSetSize( CurrentProcess, &MinWorkingSet, &MaxWorkingSet );

#ifdef DEBUG

    printf( "NegotiatedProcessWorkingSet: dwMin=%X, dwMax=%X\r\n", MinWorkingSet, MaxWorkingSet );
    printf( "BufferAllocation=%X\r\n", RingBufferSize );

#endif // DEBUG

    //
    //  Now try to lock down our code and static image data.
    //

    if ( MinWorkingSet > ( RingBufferSize + ImageLockSize )) {

        try {

            DosHeader = BaseOfImage;

            if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {

                NtHeader = (PVOID)((PCHAR)BaseOfImage + DosHeader->e_lfanew );

                if ( NtHeader->Signature == IMAGE_NT_SIGNATURE ) {

                    SectionHeader = (PVOID)((PCHAR)NtHeader +
                                            sizeof(ULONG)   +
                                            sizeof(IMAGE_FILE_HEADER) +
                                            NtHeader->FileHeader.SizeOfOptionalHeader
                                            );

                    SectionCount  = NtHeader->FileHeader.NumberOfSections;

                    while ( SectionCount-- ) {

                        if (( memcmp( SectionHeader->Name, ".text",  6 ) == 0 ) ||
                            ( memcmp( SectionHeader->Name, ".data",  6 ) == 0 ) ||
                            ( memcmp( SectionHeader->Name, ".rdata", 7 ) == 0 ) ||
                            ( memcmp( SectionHeader->Name, ".idata", 7 ) == 0 )) {

                            SectionBase = (PCHAR)BaseOfImage + SectionHeader->VirtualAddress;
                            SectionSize = SectionHeader->Misc.VirtualSize;

                            MyVirtualLock( SectionBase, SectionSize );

                            }

                        SectionHeader++;

                        }
                    }
                }
            }

        except( EXCEPTION_EXECUTE_HANDLER ) {

            DEBUGCODE( printf( "Exception walking module info\r\n" ));

            }
        }

    return RingBufferSize;
    }

DWORD
InitializeBufferAllocator(
    DWORD RequestedRingBufferSize,
    DWORD MinimumRingBufferSize,
    DWORD IndividualBufferSize
    )
    {
    PUCHAR pMem;
    PUCHAR pEnd;
    PUCHAR pSection;
    ULONG  SectionSize;
    ULONG  TotalLocked;
    ULONG  ActualRingBufferSize;
    BOOL   bSuccess;
    PNODE  pNode;

    InitializeCriticalSection( &GlobalBufferCritSect );

    ActualRingBufferSize = RequestedRingBufferSize;

    pMem = MyVirtualAlloc( RequestedRingBufferSize );

    if ( ! MyVirtualLock( pMem, RequestedRingBufferSize )) {

        DEBUGCODE( printf( "Failed to lock ring buffer all at once, trying incremental\r\n" ));

        TotalLocked = 0;
        pSection    = pMem;
        pEnd        = pMem + RequestedRingBufferSize;
        bSuccess    = TRUE;

        while (( bSuccess ) && ( pSection < pEnd )) {

            SectionSize = IndividualBufferSize;

            if (( pSection + SectionSize ) > pEnd )
                SectionSize = ( pEnd - pSection );

            bSuccess = MyVirtualLock( pSection, SectionSize );

            if ( bSuccess ) {
                TotalLocked += SectionSize;
                pSection    += SectionSize;
                }
            }

        ActualRingBufferSize = TotalLocked;

        if ( ActualRingBufferSize < MinimumRingBufferSize )
             ActualRingBufferSize = MinimumRingBufferSize;

        if ( ActualRingBufferSize < RequestedRingBufferSize )
             VirtualFree( pMem + ActualRingBufferSize, 0, MEM_DECOMMIT );

        DEBUGCODE( printf( "Locked %d bytes of %d byte ring buffer\r\n", TotalLocked, ActualRingBufferSize ));

        }

    pNode        = AllocateNode();
    pNode->pMem  = pMem;
    pNode->nSize = ActualRingBufferSize;

    LinkBefore( &FreeList, pNode );

    nGlobalBufferTotalMemory = ActualRingBufferSize;
    nGlobalBufferGranularity = IndividualBufferSize;

    DEBUGCODE( bGlobalBufferAllocatorHasBeenInitialized = TRUE );

    return ActualRingBufferSize;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\build\buildutl.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994
//
//  File:       buildutl.c
//
//  Contents:   Utility functions for Build.exe
//
//  History:    16-May-89     SteveWo  Created
//                 ... See SLM log
//              26-Jul-94     LyleC    Cleanup/Add pass0 support
//              05-Dec-00     sbonev   See SD changelist 2317
//
//----------------------------------------------------------------------------

#include "build.h"

#if DBG
//+---------------------------------------------------------------------------
//
//  Memory Allocation/Deallocation functions
//
//  These functions provide leak tracking on a debug build.
//
//----------------------------------------------------------------------------

typedef struct _MEMHEADER {
    MemType mt;
    ULONG cbRequest;
    struct _MEMHEADER *pmhPrev;
    struct _MEMHEADER *pmhNext;
} MEMHEADER;

#define CBHEADER        sizeof(MEMHEADER)
#define CBTAIL          sizeof(ULONG)

char patternFree[CBTAIL] = { 'M', 'E', 'M', 'D' };
char patternBusy[CBTAIL] = { 'm', 'e', 'm', 'd' };

__inline MEMHEADER *
GetHeader(VOID *pvblock)
{
    return((MEMHEADER *) (pvblock) - 1);
}

__inline VOID *
GetBlock(MEMHEADER *pmh)
{
    return((VOID *) (pmh + 1));
}

__inline VOID
FillTailBusy(LPSTR p)
{
    memcpy(p, patternBusy, sizeof(patternBusy));
}

__inline VOID
FillTailFree(LPSTR p)
{
    memcpy(p, patternFree, sizeof(patternFree));
}

__inline BOOL
CheckTail(LPSTR p)
{
    return(memcmp(p, patternBusy, sizeof(patternBusy)) == 0);
}


typedef struct _MEMTAB {
    LPSTR pszType;
    ULONG cbAlloc;
    ULONG cAlloc;
    ULONG cbAllocTotal;
    ULONG cAllocTotal;
    MEMHEADER mh;
} MEMTAB;

ULONG cbAllocMax;
ULONG cAllocMax;

MEMTAB MemTab[] = {
    { "Totals", },              // MT_TOTALS
    { "Unknown", },             // MT_UNKNOWN

    { "ChildData", },           // MT_CHILDDATA
    { "CmdString", },           // MT_CMDSTRING
    { "DirDB", },               // MT_DIRDB
    { "DirSup", },              // MT_DIRSUP
    { "DirPath", },             // MT_DIRPATH
    { "DirString", },           // MT_DIRSTRING
    { "EventHandles", },        // MT_EVENTHANDLES
    { "FileDB", },              // MT_FILEDB
    { "FileReadBuf", },         // MT_FILEREADBUF
    { "FrbString", },           // MT_FRBSTRING
    { "IncludeDB", },           // MT_INCLUDEDB
    { "IoBuffer", },            // MT_IOBUFFER
    { "Macro", },               // MT_MACRO
    { "SourceDB", },            // MT_SOURCEDB
    { "Target", },              // MT_TARGET
    { "ThreadFilter", },        // MT_THREADFILTER
    { "ThreadHandles", },       // MT_THREADHANDLES
    { "ThreadState", },         // MT_THREADSTATE
    { "XMLThreadState", },      // MT_XMLTHREADSTATE
    { "PXMLThreadState", },     // MT_PXMLTHREADSTATE
};
#define MT_MAX  (sizeof(MemTab)/sizeof(MemTab[0]))


VOID
InitMem(VOID)
{
    MEMTAB *pmt;
    for (pmt = MemTab; pmt < &MemTab[MT_MAX]; pmt++) {
        assert(pmt->cAllocTotal == 0);
        pmt->mh.mt = MT_INVALID;
        pmt->mh.pmhNext = &pmt->mh;
        pmt->mh.pmhPrev = &pmt->mh;
    }
}


#else

#define CBHEADER        0
#define CBTAIL          0

#endif


//+---------------------------------------------------------------------------
//
//  Function:   AllocMem
//
//  Synopsis:   Allocate memory
//
//  Arguments:  [cb]  -- Requested Size
//              [ppv] -- [out] allocated memory
//              [mt]  -- Type of memory being allocated (MT_XXX)
//
//----------------------------------------------------------------------------

VOID
AllocMem(UINT cb, VOID **ppv, MemType mt)
{
    *ppv = malloc(cb + CBHEADER + CBTAIL);
    if (*ppv == NULL) {
        BuildError("(Fatal Error) malloc(%u) failed\n", cb);
        exit(16);
    }
#if DBG
    {
        MEMTAB *pmt;
        MEMHEADER *pmh;

        pmh = *ppv;
        *ppv = GetBlock(pmh);

        if (mt >= MT_MAX) {
            mt = MT_UNKNOWN;
        }
        pmt = &MemTab[MT_TOTALS];
        if (pmt->cAllocTotal == 0) {
            InitMem();
        }
        pmt->cAlloc++;
        pmt->cAllocTotal++;
        pmt->cbAlloc += cb;
        pmt->cbAllocTotal += cb;
        if (cbAllocMax < pmt->cbAlloc) {
            cbAllocMax = pmt->cbAlloc;
        }
        if (cAllocMax < pmt->cAlloc) {
            cAllocMax = pmt->cAlloc;
        }

        pmt = &MemTab[mt];
        pmt->cAlloc++;
        pmt->cAllocTotal++;
        pmt->cbAlloc += cb;
        pmt->cbAllocTotal += cb;

        pmh->mt = mt;
        pmh->cbRequest = cb;

        pmh->pmhNext = pmt->mh.pmhNext;
        pmt->mh.pmhNext = pmh;
        pmh->pmhPrev = pmh->pmhNext->pmhPrev;
        pmh->pmhNext->pmhPrev = pmh;

        FillTailBusy((char *) *ppv + cb);

        if (DEBUG_4 && DEBUG_1) {
            BuildError("AllocMem(%d, mt=%s) -> %lx\n", cb, pmt->pszType, *ppv);
        }
    }
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   FreeMem
//
//  Synopsis:   Free memory allocated by AllocMem
//
//  Arguments:  [ppv] -- Memory pointer
//              [mt]  -- Type of memory (MT_XXX)
//
//  Notes:      Sets the memory pointer to null after freeing it.
//
//----------------------------------------------------------------------------

VOID
FreeMem(VOID **ppv, MemType mt)
{
    assert(*ppv != NULL);
#if DBG
    {
        MEMTAB *pmt;
        MEMHEADER *pmh;

        pmh = GetHeader(*ppv);
        if (mt == MT_DIRDB ||
            mt == MT_FILEDB ||
            mt == MT_INCLUDEDB ||
            mt == MT_SOURCEDB) {

            SigCheck(assert(((DIRREC *) (*ppv))->Sig == 0));
        }
        if (mt >= MT_MAX) {
            mt = MT_UNKNOWN;
        }
        pmt = &MemTab[MT_TOTALS];
        pmt->cAlloc--;
        pmt->cbAlloc -= pmh->cbRequest;
        pmt = &MemTab[mt];
        pmt->cAlloc--;
        pmt->cbAlloc -= pmh->cbRequest;

        if (DEBUG_4 && DEBUG_1) {
            BuildError(
                "FreeMem(%d, mt=%s) <- %lx\n",
                pmh->cbRequest,
                pmt->pszType,
                *ppv);
        }
        assert(CheckTail((char *) *ppv + pmh->cbRequest));
        FillTailFree((char *) *ppv + pmh->cbRequest);
        assert(mt == pmh->mt);

        pmh->pmhNext->pmhPrev = pmh->pmhPrev;
        pmh->pmhPrev->pmhNext = pmh->pmhNext;
        pmh->pmhNext = pmh->pmhPrev = NULL;

        pmh->mt = MT_INVALID;
        *ppv = pmh;
    }
#endif
    free(*ppv);
    *ppv = NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReportMemoryUsage
//
//  Synopsis:   Report current memory usage (if any) on a debug build.  If
//              called just before termination, memory leaks will be
//              displayed.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
ReportMemoryUsage(VOID)
{
#if DBG
    MEMTAB *pmt;
    UINT i;

    if (DEBUG_1) {
        BuildErrorRaw(
            "Maximum memory usage: %5lx bytes in %4lx blocks\n",
            cbAllocMax,
            cAllocMax);
        for (pmt = MemTab; pmt < &MemTab[MT_MAX]; pmt++) {
            BuildErrorRaw(
            "%5lx bytes in %4lx blocks, %5lx bytes in %4lx blocks Total (%s)\n",
                pmt->cbAlloc,
                pmt->cAlloc,
                pmt->cbAllocTotal,
                pmt->cAllocTotal,
                pmt->pszType);
        }
    }
    FreeMem(&BigBuf, MT_IOBUFFER);
    if (fDebug & 8) {
        PrintAllDirs();
    }
    FreeAllDirs();
    for (i = 0; i < CountFullDebugDirs; i++) {
        FreeMem(&FullDebugDirectories[i], MT_CMDSTRING);
    }
    if (DEBUG_1 || MemTab[MT_TOTALS].cbAlloc != 0) {
        BuildErrorRaw(szNewLine);
        if (MemTab[MT_TOTALS].cbAlloc != 0) {
            BuildError("Internal memory leaks detected:\n");
        }
        for (pmt = MemTab; pmt < &MemTab[MT_MAX]; pmt++) {
            BuildErrorRaw(
            "%5lx bytes in %4lx blocks, %5lx bytes in %4lx blocks Total (%s)\n",
                pmt->cbAlloc,
                pmt->cAlloc,
                pmt->cbAllocTotal,
                pmt->cAllocTotal,
                pmt->pszType);
        }
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   MyOpenFile
//
//  Synopsis:   Open a file
//
//----------------------------------------------------------------------------

BOOL
MyOpenFile(
    LPSTR DirName,
    LPSTR FileName,
    LPSTR Access,
    FILE **ppf,
    BOOL BufferedIO)
{
    char path[ DB_MAX_PATH_LENGTH ];

    strcpy(path, DirName);
    if (path[0] != '\0') {
        strcat(path, "\\");
    }
    strcat(path, FileName);
    *ppf = fopen( path, Access );
    if (*ppf == NULL) {
        if (*Access == 'w') {
            BuildError("%s: create file failed\n", path);
        }
        return(FALSE);
    }
    if (!BufferedIO) {
        setvbuf(*ppf, NULL, _IONBF, 0);      // Clear buffering on the stream.
    }
    return(TRUE);
}


typedef struct _FILEREADBUF {
    struct _FILEREADBUF *pfrbNext;
    LPSTR pszFile;
    LPSTR pbBuffer;
    LPSTR pbNext;
    UINT cbBuf;
    UINT cbBuffer;
    UINT cbTotal;
    UINT cbFile;
    USHORT cLine;
    USHORT cNull;
    ULONG DateTime;
    FILE *pf;
    LPSTR pszCommentToEOL;
    size_t cbCommentToEOL;
    BOOLEAN fEof;
    BOOLEAN fOpen;
    BOOLEAN fMakefile;
} FILEREADBUF;

static FILEREADBUF Frb;
char achzeros[16];


//+---------------------------------------------------------------------------
//
//  Function:   OpenFilePush
//
//----------------------------------------------------------------------------

BOOL
OpenFilePush(
    LPSTR pszdir,
    LPSTR pszfile,
    LPSTR pszCommentToEOL,
    FILE **ppf
    )
{
    FILEREADBUF *pfrb;

    if (Frb.fOpen) {
        AllocMem(sizeof(*pfrb), &pfrb, MT_FILEREADBUF);
        memcpy(pfrb, &Frb, sizeof(*pfrb));
        memset(&Frb, 0, sizeof(Frb));
        Frb.pfrbNext = pfrb;
    } else {
        pfrb = NULL;
    }

    if (!SetupReadFile(
            pszdir,
            pszfile,
            pszCommentToEOL,
            ppf)) {
        
        if (pfrb != NULL) {
            memcpy(&Frb, pfrb, sizeof(*pfrb));
            FreeMem(&pfrb, MT_FILEREADBUF);
        }
        
        return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadFilePush
//
//----------------------------------------------------------------------------

LPSTR
ReadFilePush(LPSTR pszfile)
{
    FILE *pf;
    
    assert(Frb.fOpen);
    OpenFilePush(IsFullPath(pszfile) ? "" : Frb.pszFile, pszfile,
                 Frb.pszCommentToEOL, &pf);
    return(ReadLine(Frb.pf));
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadFilePop
//
//----------------------------------------------------------------------------

LPSTR
ReadFilePop(VOID)
{
    if (Frb.pfrbNext == NULL) {
        return(NULL);
    }
    CloseReadFile(NULL);
    return(ReadLine(Frb.pf));
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadBuf
//
//----------------------------------------------------------------------------

BOOL
ReadBuf(FILE *pf)
{
    LPSTR p, p2;

    assert(pf == Frb.pf);
    assert(!Frb.fEof);
    Frb.pbNext = Frb.pbBuffer;
    Frb.cbBuf = fread(Frb.pbBuffer, 1, Frb.cbBuffer - 1, Frb.pf);
    if (Frb.cbBuf == 0) {
        Frb.fEof = TRUE;        // no more to read
        return(FALSE);
    }
    if (Frb.cbTotal == 0 &&
        Frb.cbBuf > sizeof(achzeros) &&
        memcmp(Frb.pbBuffer, achzeros, sizeof(achzeros)) == 0) {

        BuildError("ignoring binary file\n");
        Frb.fEof = TRUE;
        return(FALSE);
    }
    p = &Frb.pbBuffer[Frb.cbBuf - 1];
    if (Frb.cbTotal + Frb.cbBuf < Frb.cbFile) {
        do {
            while (p > Frb.pbBuffer && *p != '\n') {
                p--;
            }
            p2 = p;             // save end of last complete line
            if (p > Frb.pbBuffer && *p == '\n') {
                p--;
                if (p > Frb.pbBuffer && *p == '\r') {
                    p--;
                }
                while (p > Frb.pbBuffer && (*p == '\t' || *p == ' ')) {
                    p--;
                }
            }
        } while (*p == '\\');
        if (p == Frb.pbBuffer) {
            BuildError("(Fatal Error) too many continuation lines\n");
            exit(8);
        }
        p = p2;                 // restore end of last complete line
        Frb.cbBuf = (UINT)(p - Frb.pbBuffer + 1);
    } else {
        Frb.fEof = TRUE;        // no more to read
    }
    p[1] = '\0';
    Frb.cbTotal += Frb.cbBuf;

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsNmakeInclude
//
//----------------------------------------------------------------------------

LPSTR
IsNmakeInclude(LPSTR pinc)
{
    static char szInclude[] = "include";
    LPSTR pnew, p;

    while (*pinc == ' ') {
        pinc++;
    }
    if (_strnicmp(pinc, szInclude, sizeof(szInclude) - 1) == 0 &&
        pinc[sizeof(szInclude) - 1] == ' ') {

        pnew = NULL;
        pinc += sizeof(szInclude);
        while (*pinc == ' ') {
            pinc++;
        }

        if (MakeMacroString(&pnew, pinc)) {
            p = strchr(pnew, ' ');
            if (p != NULL) {
                *p = '\0';
            }
            return(pnew);
        }
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadLine
//
//  Synopsis:   Read a line from the input file.
//
//  Arguments:  [pf] -- File to read from
//
//  Returns:    Line read from file
//
//  Notes:      ReadLine returns a canonical line from the input file.
//              This involves:
//
//              1)  Converting tab to spaces.  Various editors/users change
//                      tabbing.
//              2)  Uniformly terminate lines.  Some editors drop CR in
//                      CRLF or add extras.
//              3)  Handle file-type-specific continuations.
//
//----------------------------------------------------------------------------

LPSTR
ReadLine(FILE *pf)
{
    LPSTR p, pend, pline;
    LPSTR pcont;
    LPSTR pcomment;
    UCHAR chComment0 = Frb.pszCommentToEOL[0];
    BOOL fInComment, fWhiteSpace;

    assert(pf == Frb.pf || (pf != NULL && Frb.pfrbNext != NULL));
    if (Frb.cbBuf == 0) {
        if (Frb.fEof) {
            return(ReadFilePop());
        }
        fseek(Frb.pf, Frb.cbTotal, SEEK_SET);
        if (!ReadBuf(Frb.pf)) {
            return(ReadFilePop());
        }
    }
    pline = p = Frb.pbNext;
    pend = &p[Frb.cbBuf];
    pcont = NULL;
    pcomment = NULL;
    
    //  scan through line forward

    fInComment = FALSE;
    while (p < pend) {
        switch (*p) {
            
        case ' ':
        case '\t':
        case '\r':
            *p = ' ';
            break;
            
        case '\\':
            pcont = p;          // remember continuation character
            break;
            
        case '\n':                      //  Are we at an end of line?
        case '\0':
            if (*p == '\n') {
                Frb.cLine++;
            }

            if (fInComment) {
                memset(pcomment, ' ', p-pcomment-1);        
                fInComment = FALSE;
            }

            if (pcont == NULL) {
                goto eol;               // bail out if single line
            }                           // else combine multiple lines...

            *pcont = ' ';               // remove continuation char
            pcont = NULL;               // eat only one line per continuation

            *p = ' ';                   // join the lines with blanks
            break;

        default:

            //  See if the character we're examining begins the
            //  comment-to-EOL string.

            if (*p == chComment0 &&
                !strncmp(p, Frb.pszCommentToEOL, Frb.cbCommentToEOL) &&
                !fInComment) {
                fInComment = TRUE;
                pcomment = p;
            }
            pcont = NULL;               // not a continuation character
            break;
        }
        p++;
    }
    
eol:
    assert(Frb.cbBuf >= (UINT) (p - Frb.pbNext));
    Frb.cbBuf -= (UINT)(p - Frb.pbNext);
    Frb.pbNext = p;

    if (pcont != NULL) {
        *pcont = ' ';                   // file ended with backslash...
    }
    assert(*p == '\0' || *p == '\n');
    if (p < pend) {
        if (*p == '\0') {
            if (Frb.cNull++ == 0) {
                BuildError("null byte at offset %lx\n",
                    Frb.cbTotal - Frb.cbBuf + p - Frb.pbNext);
            }
        }
        *p = '\0';                      // terminate line
        assert(Frb.cbBuf >= 1);
        Frb.cbBuf--;                    // account for newline (or null)
        Frb.pbNext++;
    } else {
        assert(p == pend && *p == '\0');
        if (*pline == 'Z' - 64 && p == &pline[1] && Frb.cbBuf == 0) {
            pline = NULL;                       // found CTL-Z at end of file
        } else {
//            BuildError( "last line incomplete\n");
        }
    }
    fWhiteSpace = FALSE;
    if (pline != NULL) {
        while (*pline == ' ') {
            pline++;                    // skip leading whitespace
            fWhiteSpace = TRUE;
        }
        if (*p != '\0') {
            BuildError( "\"*p != '\\0'\" at offset %lx\n",
                Frb.cbTotal - Frb.cbBuf + p - Frb.pbNext);
            BuildError(
                "pline=%x(%s) p=%x(%s)\n",
                pline,
                pline,
                p,
                p,
                Frb.cbTotal - Frb.cbBuf + p - Frb.pbNext);
        }
        assert(*p == '\0');
        while (p > pline && *--p == ' ') {
            *p = '\0';                  // truncate trailing whitespace
        }
    }
    if (pline == NULL) {
        return(ReadFilePop());
    }
    if (Frb.fMakefile && !fWhiteSpace && *pline == '!') {
        p = IsNmakeInclude(pline + 1);
        if (p != NULL) {
            if (Frb.fMakefile && DEBUG_4) {
                BuildError("!include(%s)\n", p);
            }
            pline = ReadFilePush(p);
            FreeMem(&p, MT_DIRSTRING);
        }
    }
    return(pline);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetupReadFile
//
//  Synopsis:   Open a file and prepare to read from it.
//
//  Arguments:  [pszdir]          -- Directory name
//              [pszfile]         -- Filename
//              [pszCommentToEOL] -- Comment to EOL string
//              [ppf]             -- [out] Open file handle
//
//  Returns:    TRUE if opened successfully
//
//  Notes:      This function, in order to minimize disk hits, reads the
//              entire file into a buffer, which is then used by the ReadLine
//              function.
//
//----------------------------------------------------------------------------

BOOL
SetupReadFile(
    LPSTR pszdir,
    LPSTR pszfile,
    LPSTR pszCommentToEOL,
    FILE **ppf
    )
{
    char path[DB_MAX_PATH_LENGTH];

    assert(!Frb.fOpen);
    assert(Frb.pf == NULL);
    assert(Frb.pszFile == NULL);
    Frb.fMakefile = strcmp(pszCommentToEOL, "#") == 0;
    Frb.DateTime = 0;

    strcpy(path, pszdir);
    if (Frb.pfrbNext != NULL) {         // if a nested open
        LPSTR p;

        if (Frb.fMakefile && !IsFullPath(pszfile)) {

            // nmake handles relative includes in makefiles by
            // attempting to locate the file relative to each makefile
            // in the complete include chain.
                
            FILEREADBUF *pfrb;

            for (pfrb = Frb.pfrbNext; pfrb != NULL; pfrb = pfrb->pfrbNext) {
                assert(pfrb->pszFile != NULL);
                
                strcpy(path, pfrb->pszFile);
                p = strrchr(path, '\\');
                if (p != NULL) {
                    *p = '\0';
                }

                if (ProbeFile(path, pszfile) != -1) {
                    break;
                }
            }

            if (pfrb == NULL) {
                // Unable to find file anywhere along path.
                return FALSE;
            }
        } else {
            p = strrchr(path, '\\');
            if (p != NULL) {
                *p = '\0';
            }
        }
    }

    if (!MyOpenFile(path, pszfile, "rb", ppf, TRUE)) {
        *ppf = NULL;
        return(FALSE);
    }
    if (Frb.fMakefile) {
        Frb.DateTime = (*pDateTimeFile)(path, pszfile);
    }
    Frb.cLine = 0;
    Frb.cNull = 0;
    Frb.cbTotal = 0;
    Frb.pf = *ppf;
    Frb.fEof = FALSE;
    Frb.pszCommentToEOL = pszCommentToEOL;
    Frb.cbCommentToEOL = strlen(pszCommentToEOL);

    fseek(Frb.pf, 0L, SEEK_END);
    Frb.cbFile = ftell(Frb.pf);
    fseek(Frb.pf, 0L, SEEK_SET);

    Frb.cbBuffer = BigBufSize;
    if (Frb.pfrbNext != NULL) {
        if (Frb.cbBuffer > Frb.cbFile + 1) {
            Frb.cbBuffer = Frb.cbFile + 1;
        }
        AllocMem(Frb.cbBuffer, &Frb.pbBuffer, MT_IOBUFFER);
    } else {
        Frb.pbBuffer = BigBuf;
    }
    if (!ReadBuf(Frb.pf)) {
        fclose(Frb.pf);
        Frb.pf = *ppf = NULL;
        if (Frb.pfrbNext != NULL) {
            FreeMem(&Frb.pbBuffer, MT_IOBUFFER);
        }
        return(FALSE);          // zero byte file
    }
    if (path[0] != '\0') {
        strcat(path, "\\");
    }
    strcat(path, pszfile);
    MakeString(&Frb.pszFile, path, TRUE, MT_FRBSTRING);
    Frb.fOpen = TRUE;
    if (Frb.fMakefile && DEBUG_4) {
        BuildError(
            "Opening file: cbFile=%lu cbBuf=%lu\n",
            Frb.cbTotal,
            Frb.cbBuffer);
    }
    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CloseReadFile
//
//  Synopsis:   Close the open file buffer.
//
//  Arguments:  [pcline] -- [out] Count of lines in file.
//
//  Returns:    Timestamp of file
//
//----------------------------------------------------------------------------

ULONG
CloseReadFile(
    UINT *pcline
    )
{
    assert(Frb.fOpen);
    assert(Frb.pf != NULL);
    assert(Frb.pszFile != NULL);

    if (Frb.fMakefile && DEBUG_4) {
        BuildError("Closing file\n");
    }
    if (Frb.cNull > 1) {
        BuildError("%hu null bytes in file\n", Frb.cNull);
    }
    fclose(Frb.pf);
    Frb.fOpen = FALSE;
    Frb.pf = NULL;
    FreeString(&Frb.pszFile, MT_FRBSTRING);
    if (Frb.pfrbNext != NULL) {
        FILEREADBUF *pfrb;

        FreeMem(&Frb.pbBuffer, MT_IOBUFFER);
        pfrb = Frb.pfrbNext;
        if (pfrb->DateTime < Frb.DateTime) {
            pfrb->DateTime = Frb.DateTime;  // propagate subordinate timestamp
        }
        memcpy(&Frb, pfrb, sizeof(*pfrb));
        FreeMem(&pfrb, MT_FILEREADBUF);
    }
    if (pcline != NULL) {
        *pcline = Frb.cLine;
    }
    return(Frb.DateTime);
}


//+---------------------------------------------------------------------------
//
//  Function:   ProbeFile
//
//  Synopsis:   Determine if a file exists
//
//----------------------------------------------------------------------------

UINT
ProbeFile(
    LPSTR DirName,
    LPSTR FileName
    )
{
    char path[ DB_MAX_PATH_LENGTH ];

    if (DirName != NULL) {
        sprintf(path, "%s\\%s", DirName, FileName);
        FileName = path;
    }
    return(GetFileAttributes(FileName));
}

//+---------------------------------------------------------------------------
//
//  Function:   EnsureDirectoriesExist
//
//  Synopsis:   Ensures the given directory exists. If the path contains
//              an asterisk, it will be expanded into all current machine
//              target names.
//
//  Arguments:  [DirName] -- Name of directory to create if necessary
//
//  Returns:    FALSE if the directory could not be created, TRUE if it
//              already exists or it could be created.
//
//----------------------------------------------------------------------------

BOOL
EnsureDirectoriesExist(
    LPSTR DirName
    )
{
    char path[ DB_MAX_PATH_LENGTH ];
    char *p;
    UINT i;

    if (!DirName || DirName[0] == '\0')
        return FALSE;

    for (i = 0; i < CountTargetMachines; i++) {

        // Replace '*' with appropriate name

        ExpandObjAsterisk(
            path,
            DirName,
            TargetMachines[i]->ObjectDirectory);

        if (ProbeFile(NULL, path) != -1) {
            continue;
        }
        p = path;
        while (TRUE) {
            p = strchr(p, '\\');
            if (p != NULL) {
                *p = '\0';
            }
            if (!CreateBuildDirectory(path)) {
                    return FALSE;
            }
            if (p == NULL) {
                break;
            }
            *p++ = '\\';
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DateTimeFile
//
//  Synopsis:   Get the timestamp on a file
//
//----------------------------------------------------------------------------

ULONG
DateTimeFile(
    LPSTR DirName,
    LPSTR FileName
    )
{
    char path[ DB_MAX_PATH_LENGTH ];
    WIN32_FIND_DATA FindFileData;
    HDIR FindHandle;
    ULONG FileDateTime;

    if (DirName == NULL || DirName[0] == '\0') {
        FindHandle = FindFirstFile( FileName, &FindFileData );
    } else {
        sprintf( path, "%s\\%s", DirName, FileName );
        FindHandle = FindFirstFile( path, &FindFileData );
    }

    if (FindHandle == (HDIR)INVALID_HANDLE_VALUE) {
        return( 0L );
    } else {
        FindClose( FindHandle );
        FileDateTime = 0L;
        FileTimeToDosDateTime( &FindFileData.ftLastWriteTime,
                               ((LPWORD)&FileDateTime)+1,
                               (LPWORD)&FileDateTime
                             );

        return( FileDateTime );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DateTimeFile2
//
//  Synopsis:   Get the timestamp on a file using the new GetFileAttributesExA
//
//----------------------------------------------------------------------------

ULONG
DateTimeFile2(
    LPSTR DirName,
    LPSTR FileName
    )
{
    char path[ DB_MAX_PATH_LENGTH ];
    WIN32_FILE_ATTRIBUTE_DATA FileData;
    ULONG FileDateTime;
    BOOL rc;

    if (DirName == NULL || DirName[0] == '\0') {
        strcpy( path, FileName );
    } else {
        sprintf( path, "%s\\%s", DirName, FileName );
    }

    rc = (*pGetFileAttributesExA) (path, GetFileExInfoStandard, (LPVOID)&FileData);

    if (!rc) {
        return( 0L );
    } else {
        FILETIME ftSystemTime;
        SYSTEMTIME stSystemTime;
        unsigned __int64 ui64Local, ui64File;
        GetSystemTime(&stSystemTime);
        SystemTimeToFileTime(&stSystemTime, &ftSystemTime);

        ui64Local = (((unsigned __int64) ftSystemTime.dwHighDateTime) << 32) +
                      (unsigned __int64) ftSystemTime.dwLowDateTime;

        ui64File = (((unsigned __int64) FileData.ftLastWriteTime.dwHighDateTime) << 32) +
                     (unsigned __int64) FileData.ftLastWriteTime.dwLowDateTime;

        if (ui64File > ui64Local) {
            BuildError("ERROR - \"%s\" file time is in the future.\n", path);
        }

        FileDateTime = 0L;
        FileTimeToDosDateTime( &FileData.ftLastWriteTime,
                               ((LPWORD)&FileDateTime)+1,
                               (LPWORD)&FileDateTime
                             );
        return( FileDateTime );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteSingleFile
//
//  Synopsis:   Delete the given file
//
//----------------------------------------------------------------------------

BOOL
DeleteSingleFile(
    LPSTR DirName,
    LPSTR FileName,
    BOOL QuietFlag
    )
{
    char path[ DB_MAX_PATH_LENGTH ];

    if (DirName) {
        sprintf( path, "%s\\%s", DirName, FileName );
        }
    else {
        strcpy( path, FileName );
        }

    if (!QuietFlag && fQuery) {
        BuildMsgRaw("'erase %s'\n", path);
        return( TRUE );
        }

    return( DeleteFile( path ) );
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteMultipleFiles
//
//  Synopsis:   Delete one or more files matching a pattern.
//
//----------------------------------------------------------------------------

BOOL
DeleteMultipleFiles(
    LPSTR DirName,
    LPSTR FilePattern
    )
{
    char path[ DB_MAX_PATH_LENGTH ];
    WIN32_FIND_DATA FindFileData;
    HDIR FindHandle;

    sprintf( path, "%s\\%s", DirName, FilePattern );

    if (fQuery) {
        BuildMsgRaw("'erase %s'\n", path);
        return( TRUE );
        }

    FindHandle = FindFirstFile( path, &FindFileData );
    if (FindHandle == (HDIR)INVALID_HANDLE_VALUE) {
        return( FALSE );
        }

    do {
        if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            DeleteSingleFile( DirName, FindFileData.cFileName, TRUE );
            }
        }
    while (FindNextFile( FindHandle, &FindFileData ));

    FindClose( FindHandle );
    return( TRUE );
}


//+---------------------------------------------------------------------------
//
//  Function:   CloseOrDeleteFile
//
//----------------------------------------------------------------------------

BOOL
CloseOrDeleteFile(
    FILE **ppf,
    LPSTR FileName,
    ULONG SizeThreshold
    )
{
    ULONG Temp;

    if (*ppf == NULL) {
        return TRUE;
    }

    Temp = ftell( *ppf );
    fclose( *ppf );
    *ppf = NULL;
    if (Temp <= SizeThreshold) {
        return( DeleteSingleFile( ".", FileName, TRUE ) );
        }
    else {
        CreatedBuildFile(".", FileName);
        return( TRUE );
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   PushCurrentDirectory
//
//----------------------------------------------------------------------------

LPSTR
PushCurrentDirectory(
    LPSTR NewCurrentDirectory
    )
{
    LPSTR OldCurrentDirectory;
    char path[DB_MAX_PATH_LENGTH];

    GetCurrentDirectory(sizeof(path), path);
    AllocMem(strlen(path) + 1, &OldCurrentDirectory, MT_DIRPATH);
    strcpy(OldCurrentDirectory, path);
    SetCurrentDirectory(NewCurrentDirectory);
    return(OldCurrentDirectory);
}


//+---------------------------------------------------------------------------
//
//  Function:   PopCurrentDirectory
//
//----------------------------------------------------------------------------

VOID
PopCurrentDirectory(
    LPSTR OldCurrentDirectory
    )
{
    if (OldCurrentDirectory) {
        SetCurrentDirectory(OldCurrentDirectory);
        FreeMem(&OldCurrentDirectory, MT_DIRPATH);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CanonicalizePathName
//
//  Synopsis:   Take the given relative pathname and the current directory
//              and obtain the full absolute path of the file.
//
//  Arguments:  [SourcePath] -- Relative path
//              [Action]     -- Canonicalizing flags
//              [FullPath]   -- [out] Full path of file or directory
//
//  Returns:    TRUE if canonicalization succeeded.
//
//  Notes:      [Action] indicates whether the function will fail if the
//              resulting path is not of the correct type.  CANONICALIZE_ONLY
//              never fails, and CANON..._FILE or CANON..._DIR will fail if
//              the resulting path is not of the specified type.
//
//----------------------------------------------------------------------------

BOOL
CanonicalizePathName(
    LPSTR SourcePath,
    UINT Action,
    LPSTR FullPath
    )
{
    char   PathBuffer[DB_MAX_PATH_LENGTH],
          *FilePart;
    char *psz;
    DWORD  attr;

    if (!GetFullPathName(
            SourcePath,
            sizeof(PathBuffer),
            PathBuffer,
            &FilePart)) {
        BuildError(
            "CanonicalizePathName: GetFullPathName(%s) failed - rc = %d.\n",
             SourcePath,
             GetLastError());
        return( FALSE );
    }
    CopyString(FullPath, PathBuffer, TRUE);

    if (Action == CANONICALIZE_ONLY) {
        return( TRUE );
    }

    if ((attr = GetFileAttributes( PathBuffer )) == -1) {
        UINT rc = GetLastError();

        if (DEBUG_1 ||
            (rc != ERROR_FILE_NOT_FOUND && rc != ERROR_PATH_NOT_FOUND)) {
            BuildError(
                "CanonicalizePathName: GetFileAttributes(%s --> %s) failed - rc = %d.\n",
                 SourcePath,
                 PathBuffer,
                 rc);
        }
        return( FALSE );
    }

    if (Action == CANONICALIZE_DIR) {
        if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
            return(TRUE);
        }
        psz = "directory";
    }
    else {
        if ((attr & FILE_ATTRIBUTE_DIRECTORY) == 0) {
            return(TRUE);
        }
        psz = "file";
    }
    BuildError(
        "CanonicalizePathName: %s --> %s is not a %s\n",
        SourcePath,
        PathBuffer,
        psz);
    return(FALSE);
}

static char FormatPathBuffer[ DB_MAX_PATH_LENGTH ];

//+---------------------------------------------------------------------------
//
//  Function:   FormatPathName
//
//  Synopsis:   Take a directory name and relative pathname and merges the
//              two into a correctly formatted path.  If the resulting path
//              has the current directory as a component, the current
//              directory part is removed.
//
//  Arguments:  [DirName]  -- Directory
//              [FileName] -- Pathname relative to [DirName]
//
//  Returns:    Resulting string (should not be freed).
//
//  Notes:      Example: DirName="f:\nt\private\foo\subdir1\subdir2"
//                       FileName="..\..\bar.c"
//                       CurrentDirectory="f:\nt\private"
//                       Result="foo\bar.c"
//
//----------------------------------------------------------------------------

LPSTR
FormatPathName(
    LPSTR DirName,
    LPSTR FileName
    )
{
    UINT cb;
    LPSTR p;

    CopyString(FormatPathBuffer, CurrentDirectory, TRUE);
    if (DirName && *DirName) {
        if (DirName[1] == ':') {
            p = FormatPathBuffer;
        }
        else
        if (DirName[0] == '\\') {
            p = FormatPathBuffer + 2;
        }
        else {
            p = FormatPathBuffer + strlen(FormatPathBuffer);
            *p++ = '\\';
        }
        CopyString(p, DirName, TRUE);
    }
    p = FormatPathBuffer + strlen(FormatPathBuffer);
    if (p[-1] != '\\') {
        *p++ = '\\';
        *p = '\0';
    }

    if (FileName[1] == ':') {
        p = FormatPathBuffer;
    }
    else
    if (FileName[0] == '\\') {
        p = FormatPathBuffer + 2;
    }
    else
    if (!strncmp(FileName, ".\\", 2)) {
        FileName += 2;
    }
    else
    if (!strncmp(FileName, "..\\", 3)) {
        do
        {
            p--;
            while (*--p != '\\') {
                if (p <= FormatPathBuffer) {
                    p = FormatPathBuffer;
                    break;
                }
            }
            p++;
            FileName += 3;

        }
        while (!strncmp(FileName, "..\\", 3) && (p != FormatPathBuffer));
    }
    CopyString(p, FileName, TRUE);

    cb = strlen(CurrentDirectory);
    p = FormatPathBuffer + cb;
    if (!fAlwaysPrintFullPath) {
        if (!_strnicmp(CurrentDirectory, FormatPathBuffer, cb) && *p == '\\') {
            return(p + 1);
        }
    }
    return(FormatPathBuffer);
}

//+---------------------------------------------------------------------------
//
//  Function:   AppendString
//
//----------------------------------------------------------------------------

LPSTR
AppendString(
    LPSTR Destination,
    LPSTR Source,
    BOOL PrefixWithSpace
    )
{
    if (Source != NULL) {
        while (*Destination) {
            Destination++;
        }
        if (PrefixWithSpace) {
            *Destination++ = ' ';
        }
        while (*Destination = *Source++) {
            Destination++;
        }
    }
    return(Destination);
}


#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   AssertPathString
//
//----------------------------------------------------------------------------

VOID
AssertPathString(LPSTR pszPath)
{
    LPSTR p = pszPath;

    while (*p != '\0') {
        if ((*p >= 'A' && *p <= 'Z') || *p == '/') {
            BuildError("Bad Path string: '%s'\n", pszPath);
            assert(FALSE);
        }
        p++;
    }
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   CopyString
//
//----------------------------------------------------------------------------

LPSTR
CopyString(
    LPSTR Destination,
    LPSTR Source,
    BOOL fPath)
{
    UCHAR ch;
    LPSTR Result;

    Result = Destination;
    while ((ch = *Source++) != '\0') {
        if (fPath) {
            if (ch >= 'A' && ch <= 'Z') {
                ch -= (UCHAR) ('A' - 'a');
            } else if (ch == '/') {
                ch = '\\';
            }
        }
        *Destination++ = ch;
    }
    *Destination = ch;
    return(Result);
}


//+---------------------------------------------------------------------------
//
//  Function:   MakeString
//
//----------------------------------------------------------------------------

VOID
MakeString(
    LPSTR *Destination,
    LPSTR Source,
    BOOL fPath,
    MemType mt
    )
{
    if (Source == NULL) {
        Source = "";
    }
    AllocMem(strlen(Source) + 1, Destination, mt);
    *Destination = CopyString(*Destination, Source, fPath);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeString
//
//----------------------------------------------------------------------------

VOID
FreeString(LPSTR *ppsz, MemType mt)
{
    if (*ppsz != NULL) {
        FreeMem(ppsz, mt);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatNumber
//
//----------------------------------------------------------------------------

LPSTR
FormatNumber(
    ULONG Number
    )
{
    USHORT i;
    LPSTR p;
    static char FormatNumberBuffer[16];

    p = FormatNumberBuffer + sizeof( FormatNumberBuffer ) - 1;
    *p = '\0';
    i = 0;
    do {
        if (i != 0 && (i % 3) == 0) {
            *--p = ',';
        }
        i++;
        *--p = (UCHAR) ((Number % 10) + '0');
        Number /= 10;
    } while (Number != 0);
    return( p );
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatTime
//
//----------------------------------------------------------------------------

LPSTR
FormatTime(
    ULONG Seconds
    )
{
    ULONG Hours, Minutes;
    static char FormatTimeBuffer[16];

    Hours = Seconds / 3600;
    Seconds = Seconds % 3600;
    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    sprintf( FormatTimeBuffer,
             "%2ld:%02ld:%02ld",
             Hours,
             Minutes,
             Seconds
           );

    return( FormatTimeBuffer );
}


//+---------------------------------------------------------------------------
//
//  Function:   AToX
//
//  Synopsis:   Hex atoi with pointer bumping and success flag
//
//  Arguments:  [pp]  -- String to convert
//              [pul] -- [out] Result
//
//  Returns:    TRUE if success
//
//----------------------------------------------------------------------------

BOOL
AToX(LPSTR *pp, ULONG *pul)
{
    LPSTR p = *pp;
    int digit;
    ULONG r;
    BOOL fRet = FALSE;

    while (*p == ' ') {
        p++;
    }
    for (r = 0; isxdigit(digit = *p); p++) {
        fRet = TRUE;
        if (isdigit(digit)) {
            digit -= '0';
        } else if (isupper(digit)) {
            digit -= 'A' - 10;
        } else {
            digit -= 'a' - 10;
        }
        r = (r << 4) + digit;
    }
    *pp = p;
    *pul = r;
    return(fRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   AToD
//
//  Synopsis:   Decimal atoi with pointer bumping and success flag
//
//  Arguments:  [pp]  -- String to convert
//              [pul] -- [out] Result
//
//  Returns:    TRUE if success
//
//----------------------------------------------------------------------------

BOOL
AToD(LPSTR *pp, ULONG *pul)
{
    LPSTR p = *pp;
    int digit;
    ULONG r;
    BOOL fRet = FALSE;

    while (*p == ' ') {
        p++;
    }
    for (r = 0; isdigit(digit = *p); p++) {
        fRet = TRUE;
        r = (r * 10) + digit - '0';
    }
    *pp = p;
    *pul = r;
    return(fRet);
}

//+---------------------------------------------------------------------------
//
//  Logging and Display Functions
//
//----------------------------------------------------------------------------

VOID _cdecl
LogMsg(char *pszfmt, ...)
{
    register va_list va;

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        vfprintf(LogFile, pszfmt, va);
        va_end(va);
    }
}


VOID
EnterMessageMode(VOID)
{
    EnterCriticalSection(&TTYCriticalSection);
    if (fConsoleInitialized &&
        (NewConsoleMode & ENABLE_WRAP_AT_EOL_OUTPUT) == 0) {

        SetConsoleMode(
            GetStdHandle(STD_ERROR_HANDLE),
            NewConsoleMode | ENABLE_WRAP_AT_EOL_OUTPUT);
    }
}


VOID
LeaveMessageMode(VOID)
{
    if (fConsoleInitialized &&
        (NewConsoleMode & ENABLE_WRAP_AT_EOL_OUTPUT) == 0) {

        SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), NewConsoleMode);
    }
    LeaveCriticalSection(&TTYCriticalSection);
}


VOID _cdecl
BuildMsg(char *pszfmt, ...)
{
    register va_list va;

    EnterMessageMode();

    ClearLine();
    va_start(va, pszfmt);
    fprintf(stderr, "BUILD: ");
    vfprintf(stderr, pszfmt, va);
    va_end(va);
    fflush(stderr);

    LeaveMessageMode();
}


VOID _cdecl
BuildMsgRaw(char *pszfmt, ...)
{
    register va_list va;

    EnterMessageMode();

    va_start(va, pszfmt);
    vfprintf(stderr, pszfmt, va);
    va_end(va);
    fflush(stderr);

    LeaveMessageMode();
}


VOID _cdecl
BuildError(char *pszfmt, ...)
{
    register va_list va;

    EnterMessageMode();

    ClearLine();
    va_start(va, pszfmt);
    fprintf(stderr, "BUILD: ");

    if (Frb.fOpen) {
        fprintf (stderr, "%s(%hu): ", Frb.pszFile, Frb.cLine);
    }

    vfprintf(stderr, pszfmt, va);
    va_end(va);
    fflush(stderr);

    LeaveMes